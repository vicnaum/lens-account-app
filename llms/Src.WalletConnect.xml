This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/types, packages/core
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  core/
    src/
      constants/
        core.ts
        crypto.ts
        echo.ts
        events.ts
        expirer.ts
        history.ts
        index.ts
        keychain.ts
        messages.ts
        pairing.ts
        publisher.ts
        relayer.ts
        store.ts
        subscriber.ts
        verify.ts
      controllers/
        crypto.ts
        echo.ts
        events.ts
        expirer.ts
        history.ts
        index.ts
        keychain.ts
        messages.ts
        pairing.ts
        publisher.ts
        relayer.ts
        store.ts
        subscriber.ts
        topicmap.ts
        verify.ts
      core.ts
      index.ts
    test/
      shared/
        helpers.ts
        index.ts
        values.ts
        ws.ts
      core.spec.ts
      crypto.spec.ts
      events.spec.ts
      expirer.spec.ts
      history.spec.ts
      keychain.spec.ts
      messages.spec.ts
      pairing.spec.ts
      persistence.spec.ts
      publisher.spec.ts
      relayer.spec.ts
      store.spec.ts
      subscriber.spec.ts
      verify.spec.ts
    .npmignore
    CHANGELOG.md
    LICENSE
    package.json
    README.md
    rollup.config.js
    tsconfig.json
  types/
    src/
      core/
        core.ts
        crypto.ts
        echo.ts
        events.ts
        expirer.ts
        history.ts
        index.ts
        keychain.ts
        messages.ts
        pairing.ts
        publisher.ts
        relayer.ts
        store.ts
        subscriber.ts
        verify.ts
      sign-client/
        auth.ts
        client.ts
        engine.ts
        index.ts
        jsonrpc.ts
        pendingRequest.ts
        proposal.ts
        session.ts
      index.ts
    .npmignore
    CHANGELOG.md
    LICENSE
    package.json
    README.md
    rollup.config.js
    tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/core/src/constants/core.ts">
export const CORE_PROTOCOL = "wc";
export const CORE_VERSION = 2;
export const CORE_CONTEXT = "core";

export const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;

export const CORE_DEFAULT = {
  name: CORE_CONTEXT,
  logger: "error",
};

export const CORE_STORAGE_OPTIONS = {
  database: ":memory:",
};
</file>

<file path="packages/core/src/constants/crypto.ts">
import { ONE_DAY } from "@walletconnect/time";

export const CRYPTO_CONTEXT = "crypto";

export const CRYPTO_CLIENT_SEED = "client_ed25519_seed";

export const CRYPTO_JWT_TTL = ONE_DAY;
</file>

<file path="packages/core/src/constants/echo.ts">
export const ECHO_CONTEXT = "echo";

export const ECHO_URL = "https://echo.walletconnect.com";
</file>

<file path="packages/core/src/constants/events.ts">
export const EVENT_CLIENT_CONTEXT = "event-client";

export const EVENT_CLIENT_PAIRING_TRACES = {
  pairing_started: "pairing_started",
  pairing_uri_validation_success: "pairing_uri_validation_success",
  pairing_uri_not_expired: "pairing_uri_not_expired",
  store_new_pairing: "store_new_pairing",
  subscribing_pairing_topic: "subscribing_pairing_topic",
  subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
  existing_pairing: "existing_pairing",
  pairing_not_expired: "pairing_not_expired",
  emit_inactive_pairing: "emit_inactive_pairing",
  emit_session_proposal: "emit_session_proposal",
  subscribing_to_pairing_topic: "subscribing_to_pairing_topic",
};

export const EVENT_CLIENT_PAIRING_ERRORS = {
  no_wss_connection: "no_wss_connection",
  no_internet_connection: "no_internet_connection",
  malformed_pairing_uri: "malformed_pairing_uri",
  active_pairing_already_exists: "active_pairing_already_exists",
  subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
  pairing_expired: "pairing_expired",
  proposal_expired: "proposal_expired",
  proposal_listener_not_found: "proposal_listener_not_found",
};

export const EVENT_CLIENT_SESSION_TRACES = {
  session_approve_started: "session_approve_started",
  proposal_not_expired: "proposal_not_expired",
  session_namespaces_validation_success: "session_namespaces_validation_success",
  create_session_topic: "create_session_topic",
  subscribing_session_topic: "subscribing_session_topic",
  subscribe_session_topic_success: "subscribe_session_topic_success",
  publishing_session_approve: "publishing_session_approve",
  session_approve_publish_success: "session_approve_publish_success",
  store_session: "store_session",
  publishing_session_settle: "publishing_session_settle",
  session_settle_publish_success: "session_settle_publish_success",
};

export const EVENT_CLIENT_SESSION_ERRORS = {
  no_internet_connection: "no_internet_connection",
  no_wss_connection: "no_wss_connection",
  proposal_expired: "proposal_expired",
  subscribe_session_topic_failure: "subscribe_session_topic_failure",
  session_approve_publish_failure: "session_approve_publish_failure",
  session_settle_publish_failure: "session_settle_publish_failure",
  session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
  proposal_not_found: "proposal_not_found",
};

export const EVENT_CLIENT_AUTHENTICATE_TRACES = {
  authenticated_session_approve_started: "authenticated_session_approve_started",
  authenticated_session_not_expired: "authenticated_session_not_expired",
  chains_caip2_compliant: "chains_caip2_compliant",
  chains_evm_compliant: "chains_evm_compliant",
  create_authenticated_session_topic: "create_authenticated_session_topic",
  cacaos_verified: "cacaos_verified",
  store_authenticated_session: "store_authenticated_session",
  subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
  subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
  publishing_authenticated_session_approve: "publishing_authenticated_session_approve",
  authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success",
};

export const EVENT_CLIENT_AUTHENTICATE_ERRORS = {
  no_internet_connection: "no_internet_connection",
  no_wss_connection: "no_wss_connection",
  missing_session_authenticate_request: "missing_session_authenticate_request",
  session_authenticate_request_expired: "session_authenticate_request_expired",
  chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
  chains_evm_compliant_failure: "chains_evm_compliant_failure",
  invalid_cacao: "invalid_cacao",
  subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
  authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
  authenticated_session_pending_request_not_found:
    "authenticated_session_pending_request_not_found",
};

export const EVENTS_STORAGE_VERSION = 0.1;

export const EVENTS_STORAGE_CONTEXT = "event-client";

export const EVENTS_STORAGE_CLEANUP_INTERVAL = 86400;

export const EVENTS_CLIENT_API_URL = "https://pulse.walletconnect.org/batch";
</file>

<file path="packages/core/src/constants/expirer.ts">
import { ONE_DAY } from "@walletconnect/time";

export const EXPIRER_CONTEXT = "expirer";

export const EXPIRER_EVENTS = {
  created: "expirer_created",
  deleted: "expirer_deleted",
  expired: "expirer_expired",
  sync: "expirer_sync",
};

export const EXPIRER_STORAGE_VERSION = "0.3";

export const EXPIRER_DEFAULT_TTL = ONE_DAY;
</file>

<file path="packages/core/src/constants/history.ts">
export const HISTORY_EVENTS = {
  created: "history_created",
  updated: "history_updated",
  deleted: "history_deleted",
  sync: "history_sync",
};

export const HISTORY_CONTEXT = "history";

export const HISTORY_STORAGE_VERSION = "0.3";
</file>

<file path="packages/core/src/constants/index.ts">
export * from "./core";
export * from "./crypto";
export * from "./keychain";
export * from "./messages";
export * from "./publisher";
export * from "./relayer";
export * from "./store";
export * from "./subscriber";
export * from "./pairing";
export * from "./history";
export * from "./expirer";
export * from "./verify";
export * from "./echo";
export * from "./events";
</file>

<file path="packages/core/src/constants/keychain.ts">
export const KEYCHAIN_CONTEXT = "keychain";

export const KEYCHAIN_STORAGE_VERSION = "0.3";
</file>

<file path="packages/core/src/constants/messages.ts">
export const MESSAGES_CONTEXT = "messages";

export const MESSAGES_STORAGE_VERSION = "0.3";
</file>

<file path="packages/core/src/constants/pairing.ts">
import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from "@walletconnect/time";
import { RelayerTypes, PairingJsonRpcTypes } from "@walletconnect/types";

export const PAIRING_CONTEXT = "pairing";

export const PAIRING_STORAGE_VERSION = "0.3";

export const PAIRING_DEFAULT_TTL = THIRTY_DAYS;

export const PAIRING_RPC_OPTS: Record<
  PairingJsonRpcTypes.WcMethod | "unregistered_method",
  {
    req: RelayerTypes.PublishOptions;
    res: RelayerTypes.PublishOptions;
  }
> = {
  wc_pairingDelete: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1000,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1001,
    },
  },
  wc_pairingPing: {
    req: {
      ttl: THIRTY_SECONDS,
      prompt: false,
      tag: 1002,
    },
    res: {
      ttl: THIRTY_SECONDS,
      prompt: false,
      tag: 1003,
    },
  },
  unregistered_method: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 0,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 0,
    },
  },
};

export const PAIRING_EVENTS = {
  create: "pairing_create",
  expire: "pairing_expire",
  delete: "pairing_delete",
  ping: "pairing_ping",
};
</file>

<file path="packages/core/src/constants/publisher.ts">
import { SIX_HOURS } from "@walletconnect/time";

export const PUBLISHER_DEFAULT_TTL = SIX_HOURS;

export const PUBLISHER_CONTEXT = "publisher";
</file>

<file path="packages/core/src/constants/relayer.ts">
export const RELAYER_DEFAULT_PROTOCOL = "irn";

export const RELAYER_DEFAULT_LOGGER = "error";

export const RELAYER_DEFAULT_RELAY_URL = "wss://relay.walletconnect.org";

export const RELAYER_CONTEXT = "relayer";

export const RELAYER_EVENTS = {
  message: "relayer_message",
  message_ack: "relayer_message_ack",
  connect: "relayer_connect",
  disconnect: "relayer_disconnect",
  error: "relayer_error",
  connection_stalled: "relayer_connection_stalled",
  transport_closed: "relayer_transport_closed",
  publish: "relayer_publish",
};

export const RELAYER_SUBSCRIBER_SUFFIX = "_subscription";

export const RELAYER_PROVIDER_EVENTS = {
  payload: "payload",
  connect: "connect",
  disconnect: "disconnect",
  error: "error",
};

export const RELAYER_RECONNECT_TIMEOUT = 0.1;

export const RELAYER_STORAGE_OPTIONS = {
  database: ":memory:",
};

// Updated automatically via `new-version` npm script.

export const RELAYER_SDK_VERSION = "2.19.2";

// delay to wait before closing the transport connection after init if not active
export const RELAYER_TRANSPORT_CUTOFF = 10_000;

export const TRANSPORT_TYPES = {
  link_mode: "link_mode",
  relay: "relay",
} as const;

export const MESSAGE_DIRECTION = {
  inbound: "inbound",
  outbound: "outbound",
} as const;
</file>

<file path="packages/core/src/constants/store.ts">
export const STORE_STORAGE_VERSION = "0.3";

export const WALLETCONNECT_CLIENT_ID = "WALLETCONNECT_CLIENT_ID";
export const WALLETCONNECT_LINK_MODE_APPS = "WALLETCONNECT_LINK_MODE_APPS";
</file>

<file path="packages/core/src/constants/subscriber.ts">
import { THIRTY_DAYS, FIVE_SECONDS } from "@walletconnect/time";

export const SUBSCRIBER_EVENTS = {
  created: "subscription_created",
  deleted: "subscription_deleted",
  expired: "subscription_expired",
  disabled: "subscription_disabled",
  sync: "subscription_sync",
  resubscribed: "subscription_resubscribed",
};

export const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;

export const SUBSCRIBER_CONTEXT = "subscription";

export const SUBSCRIBER_STORAGE_VERSION = "0.3";

export const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;
</file>

<file path="packages/core/src/constants/verify.ts">
export const VERIFY_CONTEXT = "verify-api";

const VERIFY_SERVER_COM = "https://verify.walletconnect.com";
const VERIFY_SERVER_ORG = "https://verify.walletconnect.org";
export const VERIFY_SERVER = VERIFY_SERVER_ORG;
export const VERIFY_SERVER_V3 = `${VERIFY_SERVER}/v3`;

export const TRUSTED_VERIFY_URLS = [VERIFY_SERVER_COM, VERIFY_SERVER_ORG];
</file>

<file path="packages/core/src/controllers/crypto.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { safeJsonParse, safeJsonStringify } from "@walletconnect/safe-json";
import { ICore, ICrypto, IKeyChain } from "@walletconnect/types";
import * as relayAuth from "@walletconnect/relay-auth";
import { fromString } from "uint8arrays/from-string";
import {
  decrypt,
  deriveSymKey,
  encrypt,
  generateKeyPair as generateKeyPairUtil,
  hashKey,
  getInternalError,
  generateRandomBytes32,
  validateEncoding,
  validateDecoding,
  isTypeOneEnvelope,
  isTypeTwoEnvelope,
  encodeTypeTwoEnvelope,
  decodeTypeTwoEnvelope,
  deserialize,
  decodeTypeByte,
  BASE16,
  BASE64,
} from "@walletconnect/utils";
import { toString } from "uint8arrays";

import { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from "../constants";
import { KeyChain } from "./keychain";

export class Crypto implements ICrypto {
  public name = CRYPTO_CONTEXT;
  public keychain: ICrypto["keychain"];
  public readonly randomSessionIdentifier = generateRandomBytes32();

  private initialized = false;

  constructor(
    public core: ICore,
    public logger: Logger,
    keychain?: IKeyChain,
  ) {
    this.core = core;
    this.logger = generateChildLogger(logger, this.name);
    this.keychain = keychain || new KeyChain(this.core, this.logger);
  }

  public init: ICrypto["init"] = async () => {
    if (!this.initialized) {
      await this.keychain.init();
      this.initialized = true;
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  public hasKeys: ICrypto["hasKeys"] = (tag) => {
    this.isInitialized();
    return this.keychain.has(tag);
  };

  public getClientId: ICrypto["getClientId"] = async () => {
    this.isInitialized();
    const seed = await this.getClientSeed();
    const keyPair = relayAuth.generateKeyPair(seed);
    const clientId = relayAuth.encodeIss(keyPair.publicKey);
    return clientId;
  };

  public generateKeyPair: ICrypto["generateKeyPair"] = () => {
    this.isInitialized();
    const keyPair = generateKeyPairUtil();
    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);
  };

  public signJWT: ICrypto["signJWT"] = async (aud) => {
    this.isInitialized();
    const seed = await this.getClientSeed();
    const keyPair = relayAuth.generateKeyPair(seed);
    const sub = this.randomSessionIdentifier;
    const ttl = CRYPTO_JWT_TTL;
    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);
    return jwt;
  };

  public generateSharedKey: ICrypto["generateSharedKey"] = (
    selfPublicKey,
    peerPublicKey,
    overrideTopic,
  ) => {
    this.isInitialized();
    const selfPrivateKey = this.getPrivateKey(selfPublicKey);
    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);
    return this.setSymKey(symKey, overrideTopic);
  };

  public setSymKey: ICrypto["setSymKey"] = async (symKey, overrideTopic) => {
    this.isInitialized();
    const topic = overrideTopic || hashKey(symKey);
    await this.keychain.set(topic, symKey);
    return topic;
  };

  public deleteKeyPair: ICrypto["deleteKeyPair"] = async (publicKey: string) => {
    this.isInitialized();
    await this.keychain.del(publicKey);
  };

  public deleteSymKey: ICrypto["deleteSymKey"] = async (topic: string) => {
    this.isInitialized();
    await this.keychain.del(topic);
  };

  public encode: ICrypto["encode"] = async (topic, payload, opts) => {
    this.isInitialized();
    const params = validateEncoding(opts);
    const message = safeJsonStringify(payload);

    if (isTypeTwoEnvelope(params)) {
      return encodeTypeTwoEnvelope(message, opts?.encoding);
    }

    if (isTypeOneEnvelope(params)) {
      const selfPublicKey = params.senderPublicKey;
      const peerPublicKey = params.receiverPublicKey;
      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);
    }
    const symKey = this.getSymKey(topic);
    const { type, senderPublicKey } = params;
    const result = encrypt({ type, symKey, message, senderPublicKey, encoding: opts?.encoding });
    return result;
  };

  public decode: ICrypto["decode"] = async (topic, encoded, opts) => {
    this.isInitialized();
    const params = validateDecoding(encoded, opts);
    if (isTypeTwoEnvelope(params)) {
      const message = decodeTypeTwoEnvelope(encoded, opts?.encoding);
      return safeJsonParse(message);
    }
    if (isTypeOneEnvelope(params)) {
      const selfPublicKey = params.receiverPublicKey;
      const peerPublicKey = params.senderPublicKey;
      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);
    }
    try {
      const symKey = this.getSymKey(topic);
      const message = decrypt({ symKey, encoded, encoding: opts?.encoding });
      const payload = safeJsonParse(message);
      return payload;
    } catch (error) {
      this.logger.error(
        `Failed to decode message from topic: '${topic}', clientId: '${await this.getClientId()}'`,
      );
      this.logger.error(error);
    }
  };

  public getPayloadType: ICrypto["getPayloadType"] = (encoded, encoding = BASE64) => {
    const deserialized = deserialize({ encoded, encoding });
    return decodeTypeByte(deserialized.type);
  };

  public getPayloadSenderPublicKey: ICrypto["getPayloadSenderPublicKey"] = (
    encoded,
    encoding = BASE64,
  ) => {
    const deserialized = deserialize({ encoded, encoding });
    return deserialized.senderPublicKey
      ? toString(deserialized.senderPublicKey, BASE16)
      : undefined;
  };

  // ---------- Private ----------------------------------------------- //

  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {
    await this.keychain.set(publicKey, privateKey);
    return publicKey;
  }

  private getPrivateKey(publicKey: string) {
    const privateKey = this.keychain.get(publicKey);
    return privateKey;
  }

  private async getClientSeed(): Promise<Uint8Array> {
    let seed = "";
    try {
      seed = this.keychain.get(CRYPTO_CLIENT_SEED);
    } catch {
      seed = generateRandomBytes32();
      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);
    }
    return fromString(seed, "base16");
  }

  private getSymKey(topic: string) {
    const symKey = this.keychain.get(topic);
    return symKey;
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/echo.ts">
import { generateChildLogger, Logger } from "@walletconnect/logger";
import { IEchoClient } from "@walletconnect/types";
import { ECHO_CONTEXT, ECHO_URL } from "../constants";

export class EchoClient extends IEchoClient {
  public readonly context = ECHO_CONTEXT;
  constructor(
    public projectId: string,
    public logger: Logger,
  ) {
    super(projectId, logger);
    this.logger = generateChildLogger(logger, this.context);
  }

  public registerDeviceToken: IEchoClient["registerDeviceToken"] = async (params) => {
    const { clientId, token, notificationType, enableEncrypted = false } = params;

    const echoUrl = `${ECHO_URL}/${this.projectId}/clients`;

    await fetch(echoUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        client_id: clientId,
        type: notificationType,
        token,
        always_raw: enableEncrypted,
      }),
    });
  };
}
</file>

<file path="packages/core/src/controllers/events.ts">
import { generateChildLogger, Logger } from "@walletconnect/logger";
import { ICore, IEventClient, EventClientTypes } from "@walletconnect/types";
import { formatUA, isTestRun, uuidv4, getAppMetadata } from "@walletconnect/utils";
import {
  CORE_STORAGE_PREFIX,
  EVENTS_CLIENT_API_URL,
  EVENTS_STORAGE_CLEANUP_INTERVAL,
  EVENTS_STORAGE_CONTEXT,
  EVENTS_STORAGE_VERSION,
  RELAYER_SDK_VERSION,
} from "../constants";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { fromMiliseconds } from "@walletconnect/time";

export class EventClient extends IEventClient {
  public readonly context = EVENTS_STORAGE_CONTEXT;
  private readonly storagePrefix = CORE_STORAGE_PREFIX;
  private readonly storageVersion = EVENTS_STORAGE_VERSION;
  private events = new Map<string, EventClientTypes.Event>();
  private shouldPersist = false;
  constructor(
    public core: ICore,
    public logger: Logger,
    telemetryEnabled = true,
  ) {
    super(core, logger, telemetryEnabled);
    this.logger = generateChildLogger(logger, this.context);
    this.telemetryEnabled = telemetryEnabled;
    if (telemetryEnabled) {
      this.restore().then(async () => {
        await this.submit();
        this.setEventListeners();
      });
    } else {
      // overwrite any persisted events with an empty array
      this.persist();
    }
  }

  get storageKey() {
    return (
      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
    );
  }

  public init: IEventClient["init"] = async () => {
    if (isTestRun()) return;
    try {
      const initEvent = {
        eventId: uuidv4(),
        timestamp: Date.now(),
        domain: this.getAppDomain(),
        props: {
          event: "INIT",
          type: "",
          properties: {
            client_id: await this.core.crypto.getClientId(),
            user_agent: formatUA(
              this.core.relayer.protocol,
              this.core.relayer.version,
              RELAYER_SDK_VERSION,
            ),
          },
        },
      };
      await this.sendEvent([initEvent] as unknown as EventClientTypes.Event[]);
    } catch (error) {
      this.logger.warn(error);
    }
  };

  public createEvent: IEventClient["createEvent"] = (params) => {
    const {
      event = "ERROR",
      type = "",
      properties: { topic, trace },
    } = params;
    const eventId = uuidv4();
    const bundleId = this.core.projectId || "";
    const timestamp = Date.now();
    const props = {
      event,
      type,
      properties: {
        topic,
        trace,
      },
    };
    const eventObj = {
      eventId,
      timestamp,
      props,
      bundleId,
      domain: this.getAppDomain(),
      ...this.setMethods(eventId),
    };
    if (this.telemetryEnabled) {
      this.events.set(eventId, eventObj);
      this.shouldPersist = true;
    }

    return eventObj;
  };

  public getEvent: IEventClient["getEvent"] = (params) => {
    const { eventId, topic } = params;
    if (eventId) {
      return this.events.get(eventId);
    }
    const event = Array.from(this.events.values()).find(
      (event) => event.props.properties.topic === topic,
    );

    if (!event) return;

    return {
      ...event,
      ...this.setMethods(event.eventId),
    };
  };

  public deleteEvent: IEventClient["deleteEvent"] = (params) => {
    const { eventId } = params;
    this.events.delete(eventId);
    this.shouldPersist = true;
  };

  private setEventListeners = () => {
    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {
      if (this.shouldPersist) await this.persist();
      // cleanup events older than EVENTS_STORAGE_CLEANUP_INTERVAL
      this.events.forEach((event) => {
        if (
          fromMiliseconds(Date.now()) - fromMiliseconds(event.timestamp) >
          EVENTS_STORAGE_CLEANUP_INTERVAL
        ) {
          this.events.delete(event.eventId);
          this.shouldPersist = true;
        }
      });
    });
  };

  private setMethods = (eventId: string) => {
    return {
      addTrace: (trace: string) => this.addTrace(eventId, trace),
      setError: (errorType: string) => this.setError(eventId, errorType),
    };
  };

  private addTrace = (eventId: string, trace: string) => {
    const event = this.events.get(eventId);
    if (!event) return;
    event.props.properties.trace.push(trace);
    this.events.set(eventId, event);
    this.shouldPersist = true;
  };

  private setError = (eventId: string, errorType: string) => {
    const event = this.events.get(eventId);
    if (!event) return;
    event.props.type = errorType;
    event.timestamp = Date.now();
    this.events.set(eventId, event);
    this.shouldPersist = true;
  };

  private persist = async () => {
    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values()));
    this.shouldPersist = false;
  };

  private restore = async () => {
    try {
      const events =
        (await this.core.storage.getItem<EventClientTypes.Event[]>(this.storageKey)) || [];
      if (!events.length) return;
      events.forEach((event) => {
        this.events.set(event.eventId, {
          ...event,
          ...this.setMethods(event.eventId),
        });
      });
    } catch (error) {
      this.logger.warn(error);
    }
  };

  private submit = async () => {
    if (!this.telemetryEnabled) return;

    if (this.events.size === 0) return;

    const eventsToSend: EventClientTypes.Event[] = [];
    // exclude events without type as they can be considered `in progress`
    for (const [_, event] of this.events) {
      if (event.props.type) {
        eventsToSend.push(event);
      }
    }

    if (eventsToSend.length === 0) return;

    try {
      const response = await this.sendEvent(eventsToSend);
      if (response.ok) {
        for (const event of eventsToSend) {
          this.events.delete(event.eventId);
          this.shouldPersist = true;
        }
      }
    } catch (error) {
      this.logger.warn(error);
    }
  };

  private sendEvent = async (events: EventClientTypes.Event[]) => {
    // if domain isn't available, set `sp` as `desktop` so data would be extracted on api side
    const platform = this.getAppDomain() ? "" : "&sp=desktop";
    const response = await fetch(
      `${EVENTS_CLIENT_API_URL}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${RELAYER_SDK_VERSION}${platform}`,
      {
        method: "POST",
        body: JSON.stringify(events),
      },
    );
    return response;
  };

  private getAppDomain = () => {
    return getAppMetadata().url;
  };
}
</file>

<file path="packages/core/src/controllers/expirer.ts">
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { toMiliseconds } from "@walletconnect/time";
import { ExpirerTypes, ICore, IExpirer } from "@walletconnect/types";
import { getInternalError, formatIdTarget, formatTopicTarget } from "@walletconnect/utils";
import { EventEmitter } from "events";
import {
  CORE_STORAGE_PREFIX,
  EXPIRER_CONTEXT,
  EXPIRER_EVENTS,
  EXPIRER_STORAGE_VERSION,
} from "../constants";

export class Expirer extends IExpirer {
  public expirations = new Map<string, ExpirerTypes.Expiration>();
  public events = new EventEmitter();
  public name = EXPIRER_CONTEXT;
  public version = EXPIRER_STORAGE_VERSION;

  private cached: ExpirerTypes.Expiration[] = [];
  private initialized = false;

  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger);
    this.logger = generateChildLogger(logger, this.name);
  }

  public init: IExpirer["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      await this.restore();
      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));
      this.cached = [];
      this.registerEventListeners();
      this.initialized = true;
    }
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get length(): number {
    return this.expirations.size;
  }

  get keys(): string[] {
    return Array.from(this.expirations.keys());
  }

  get values(): ExpirerTypes.Expiration[] {
    return Array.from(this.expirations.values());
  }

  public has: IExpirer["has"] = (key) => {
    try {
      const target = this.formatTarget(key);
      const expiration = this.getExpiration(target);
      return typeof expiration !== "undefined";
    } catch (e) {
      // ignore
      return false;
    }
  };

  public set: IExpirer["set"] = (key, expiry) => {
    this.isInitialized();
    const target = this.formatTarget(key);
    const expiration = { target, expiry };
    this.expirations.set(target, expiration);
    this.checkExpiry(target, expiration);
    this.events.emit(EXPIRER_EVENTS.created, {
      target,
      expiration,
    } as ExpirerTypes.Created);
  };

  public get: IExpirer["get"] = (key) => {
    this.isInitialized();
    const target = this.formatTarget(key);
    return this.getExpiration(target);
  };

  public del: IExpirer["del"] = (key) => {
    this.isInitialized();
    const exists = this.has(key);
    if (exists) {
      const target = this.formatTarget(key);
      const expiration = this.getExpiration(target);
      this.expirations.delete(target);
      this.events.emit(EXPIRER_EVENTS.deleted, {
        target,
        expiration,
      } as ExpirerTypes.Deleted);
    }
  };

  public on: IExpirer["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: IExpirer["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: IExpirer["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: IExpirer["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  // ---------- Private ----------------------------------------------- //

  private formatTarget(key: string | number) {
    if (typeof key === "string") {
      return formatTopicTarget(key);
    } else if (typeof key === "number") {
      return formatIdTarget(key);
    }
    const { message } = getInternalError("UNKNOWN_TYPE", `Target type: ${typeof key}`);
    throw new Error(message);
  }

  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {
    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);
  }

  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {
    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);
    return expirations;
  }

  private async persist() {
    await this.setExpirations(this.values);
    this.events.emit(EXPIRER_EVENTS.sync);
  }

  private async restore() {
    try {
      const persisted = await this.getExpirations();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.expirations.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored expirations for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private getExpiration(target: string): ExpirerTypes.Expiration {
    const expiration = this.expirations.get(target);
    if (!expiration) {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${target}`);
      this.logger.warn(message);
      throw new Error(message);
    }
    return expiration;
  }

  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {
    const { expiry } = expiration;
    const msToTimeout = toMiliseconds(expiry) - Date.now();
    if (msToTimeout <= 0) this.expire(target, expiration);
  }

  private expire(target: string, expiration: ExpirerTypes.Expiration): void {
    this.expirations.delete(target);
    this.events.emit(EXPIRER_EVENTS.expired, {
      target,
      expiration,
    } as ExpirerTypes.Expired);
  }

  private checkExpirations(): void {
    // avoid auto expiring if the relayer is not connected
    if (!this.core.relayer.connected) return;
    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));
  }

  private registerEventListeners(): void {
    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());
    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {
      const eventName = EXPIRER_EVENTS.created;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: createdEvent });
      this.persist();
    });
    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {
      const eventName = EXPIRER_EVENTS.expired;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
      this.persist();
    });
    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {
      const eventName = EXPIRER_EVENTS.deleted;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
      this.persist();
    });
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/history.ts">
import { formatJsonRpcRequest, isJsonRpcError } from "@walletconnect/jsonrpc-utils";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from "@walletconnect/types";
import { calcExpiry, getInternalError } from "@walletconnect/utils";
import { EventEmitter } from "events";
import { THIRTY_DAYS, toMiliseconds } from "@walletconnect/time";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import {
  CORE_STORAGE_PREFIX,
  HISTORY_CONTEXT,
  HISTORY_EVENTS,
  HISTORY_STORAGE_VERSION,
} from "../constants";

export class JsonRpcHistory extends IJsonRpcHistory {
  public records = new Map<number, JsonRpcRecord>();
  public events = new EventEmitter();
  public name = HISTORY_CONTEXT;
  public version = HISTORY_STORAGE_VERSION;

  private cached: JsonRpcRecord[] = [];
  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger);
    this.logger = generateChildLogger(logger, this.name);
  }

  public init: IJsonRpcHistory["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      await this.restore();
      this.cached.forEach((record) => this.records.set(record.id, record));
      this.cached = [];
      this.registerEventListeners();
      this.initialized = true;
    }
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get size(): number {
    return this.records.size;
  }

  get keys(): number[] {
    return Array.from(this.records.keys());
  }

  get values() {
    return Array.from(this.records.values());
  }

  get pending(): RequestEvent[] {
    const requests: RequestEvent[] = [];
    this.values.forEach((record) => {
      if (typeof record.response !== "undefined") return;
      const requestEvent: RequestEvent = {
        topic: record.topic,
        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),
        chainId: record.chainId,
      };
      return requests.push(requestEvent);
    });
    return requests;
  }

  public set: IJsonRpcHistory["set"] = (topic, request, chainId) => {
    this.isInitialized();
    this.logger.debug(`Setting JSON-RPC request history record`);
    this.logger.trace({ type: "method", method: "set", topic, request, chainId });
    if (this.records.has(request.id)) return;
    const record: JsonRpcRecord = {
      id: request.id,
      topic,
      request: { method: request.method, params: request.params || null },
      chainId,
      expiry: calcExpiry(THIRTY_DAYS),
    };
    this.records.set(record.id, record);
    this.persist();
    this.events.emit(HISTORY_EVENTS.created, record);
  };

  public resolve: IJsonRpcHistory["resolve"] = async (response) => {
    this.isInitialized();
    this.logger.debug(`Updating JSON-RPC response history record`);
    this.logger.trace({ type: "method", method: "update", response });
    if (!this.records.has(response.id)) return;
    const record = await this.getRecord(response.id);
    if (typeof record.response !== "undefined") return;
    record.response = isJsonRpcError(response)
      ? { error: response.error }
      : { result: response.result };
    this.records.set(record.id, record);
    this.persist();
    this.events.emit(HISTORY_EVENTS.updated, record);
  };

  public get: IJsonRpcHistory["get"] = async (topic, id) => {
    this.isInitialized();
    this.logger.debug(`Getting record`);
    this.logger.trace({ type: "method", method: "get", topic, id });
    const record = await this.getRecord(id);
    return record;
  };

  public delete: IJsonRpcHistory["delete"] = (topic, id) => {
    this.isInitialized();
    this.logger.debug(`Deleting record`);
    this.logger.trace({ type: "method", method: "delete", id });
    this.values.forEach((record: JsonRpcRecord) => {
      if (record.topic === topic) {
        if (typeof id !== "undefined" && record.id !== id) return;
        this.records.delete(record.id);
        this.events.emit(HISTORY_EVENTS.deleted, record);
      }
    });
    this.persist();
  };

  public exists: IJsonRpcHistory["exists"] = async (topic, id) => {
    this.isInitialized();
    if (!this.records.has(id)) return false;
    const record = await this.getRecord(id);
    return record.topic === topic;
  };

  public on: IJsonRpcHistory["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: IJsonRpcHistory["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: IJsonRpcHistory["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: IJsonRpcHistory["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  // ---------- Private ----------------------------------------------- //

  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {
    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);
  }

  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {
    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);
    return records;
  }

  private getRecord(id: number) {
    this.isInitialized();
    const record = this.records.get(id);
    if (!record) {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${id}`);
      throw new Error(message);
    }
    return record;
  }

  private async persist() {
    await this.setJsonRpcRecords(this.values);
    this.events.emit(HISTORY_EVENTS.sync);
  }

  private async restore() {
    try {
      const persisted = await this.getJsonRpcRecords();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.records.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored records for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private registerEventListeners(): void {
    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {
      const eventName = HISTORY_EVENTS.created;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, record });
    });
    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {
      const eventName = HISTORY_EVENTS.updated;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, record });
    });

    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {
      const eventName = HISTORY_EVENTS.deleted;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, record });
    });

    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }

  private cleanup() {
    try {
      this.isInitialized();
      let deleted = false;
      this.records.forEach((record: JsonRpcRecord) => {
        const msToExpiry = toMiliseconds(record.expiry || 0) - Date.now();
        if (msToExpiry <= 0) {
          this.logger.info(`Deleting expired history log: ${record.id}`);
          this.records.delete(record.id);
          this.events.emit(HISTORY_EVENTS.deleted, record, false);
          deleted = true;
        }
      });
      if (deleted) {
        this.persist();
      }
    } catch (e) {
      this.logger.warn(e);
    }
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/index.ts">
export * from "./crypto";
export * from "./messages";
export * from "./relayer";
export * from "./store";
export * from "./subscriber";
export * from "./keychain";
export * from "./pairing";
export * from "./history";
export * from "./expirer";
export * from "./verify";
export * from "./echo";
export * from "./events";
</file>

<file path="packages/core/src/controllers/keychain.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IKeyChain } from "@walletconnect/types";
import { getInternalError, mapToObj, objToMap } from "@walletconnect/utils";

import { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from "../constants";

export class KeyChain implements IKeyChain {
  public keychain = new Map<string, string>();
  public name = KEYCHAIN_CONTEXT;
  public version = KEYCHAIN_STORAGE_VERSION;

  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    this.core = core;
    this.logger = generateChildLogger(logger, this.name);
  }

  public init: IKeyChain["init"] = async () => {
    if (!this.initialized) {
      const keychain = await this.getKeyChain();
      if (typeof keychain !== "undefined") {
        this.keychain = keychain;
      }
      this.initialized = true;
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  public has: IKeyChain["has"] = (tag) => {
    this.isInitialized();
    return this.keychain.has(tag);
  };

  public set: IKeyChain["set"] = async (tag, key) => {
    this.isInitialized();
    this.keychain.set(tag, key);
    await this.persist();
  };

  public get: IKeyChain["get"] = (tag) => {
    this.isInitialized();
    const key = this.keychain.get(tag);
    if (typeof key === "undefined") {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${tag}`);
      throw new Error(message);
    }
    return key;
  };

  public del: IKeyChain["del"] = async (tag) => {
    this.isInitialized();
    this.keychain.delete(tag);
    await this.persist();
  };

  // ---------- Private ----------------------------------------------- //

  private async setKeyChain(keychain: Map<string, string>) {
    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));
  }

  private async getKeyChain() {
    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);
    return typeof keychain !== "undefined" ? objToMap(keychain) : undefined;
  }

  private async persist() {
    await this.setKeyChain(this.keychain);
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/messages.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IMessageTracker, MessageRecord } from "@walletconnect/types";
import { hashMessage, mapToObj, objToMap, getInternalError } from "@walletconnect/utils";
import {
  CORE_STORAGE_PREFIX,
  MESSAGE_DIRECTION,
  MESSAGES_CONTEXT,
  MESSAGES_STORAGE_VERSION,
} from "../constants";

export class MessageTracker extends IMessageTracker {
  public messages = new Map<string, MessageRecord>();
  /**
   * stores messages that have not been acknowledged by the implementing client
   * this is used to prevent losing messages in race conditions such as
   * when a message is received by the relayer before the implementing client is ready to receive it
   */
  public messagesWithoutClientAck = new Map<string, MessageRecord>();
  public name = MESSAGES_CONTEXT;
  public version = MESSAGES_STORAGE_VERSION;

  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public logger: Logger,
    public core: ICore,
  ) {
    super(logger, core);
    this.logger = generateChildLogger(logger, this.name);
    this.core = core;
  }

  public init: IMessageTracker["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      try {
        const messages = await this.getRelayerMessages();
        if (typeof messages !== "undefined") {
          this.messages = messages;
        }
        const messagesWithoutClientAck = await this.getRelayerMessagesWithoutClientAck();
        if (typeof messagesWithoutClientAck !== "undefined") {
          this.messagesWithoutClientAck = messagesWithoutClientAck;
        }
        this.logger.debug(`Successfully Restored records for ${this.name}`);
        this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
      } catch (e) {
        this.logger.debug(`Failed to Restore records for ${this.name}`);
        this.logger.error(e as any);
      } finally {
        this.initialized = true;
      }
    }
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get storageKeyWithoutClientAck() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name +
      "_withoutClientAck"
    );
  }

  public set: IMessageTracker["set"] = async (topic, message, direction) => {
    this.isInitialized();
    const hash = hashMessage(message);
    let messages = this.messages.get(topic);
    if (typeof messages === "undefined") {
      messages = {};
    }
    if (typeof messages[hash] !== "undefined") {
      return hash;
    }
    messages[hash] = message;
    this.messages.set(topic, messages);
    // Only store messages without client ack for inbound messages
    if (direction === MESSAGE_DIRECTION.inbound) {
      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};
      this.messagesWithoutClientAck.set(topic, {
        ...messagesWithoutClientAck,
        [hash]: message,
      });
    }

    await this.persist();
    return hash;
  };

  public get: IMessageTracker["get"] = (topic) => {
    this.isInitialized();
    let messages = this.messages.get(topic);
    if (typeof messages === "undefined") {
      messages = {};
    }
    return messages;
  };

  public getWithoutAck: IMessageTracker["getWithoutAck"] = (topics) => {
    this.isInitialized();
    const messages: Record<string, string[]> = {};
    for (const topic of topics) {
      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};
      messages[topic] = Object.values(messagesWithoutClientAck);
    }
    return messages;
  };

  public has: IMessageTracker["has"] = (topic, message) => {
    this.isInitialized();
    const messages = this.get(topic);
    const hash = hashMessage(message);
    return typeof messages[hash] !== "undefined";
  };

  public ack: IMessageTracker["ack"] = async (topic, message) => {
    this.isInitialized();
    const messages = this.messagesWithoutClientAck.get(topic);
    if (typeof messages === "undefined") {
      return;
    }

    const hash = hashMessage(message);

    delete messages[hash];
    if (Object.keys(messages).length === 0) {
      this.messagesWithoutClientAck.delete(topic);
    } else {
      this.messagesWithoutClientAck.set(topic, messages);
    }
    await this.persist();
  };

  public del: IMessageTracker["del"] = async (topic) => {
    this.isInitialized();
    this.messages.delete(topic);
    this.messagesWithoutClientAck.delete(topic);
    await this.persist();
  };

  // ---------- Private ----------------------------------------------- //

  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {
    await this.core.storage.setItem<Record<string, MessageRecord>>(
      this.storageKey,
      mapToObj(messages),
    );
  }

  private async setRelayerMessagesWithoutClientAck(
    messages: Map<string, MessageRecord>,
  ): Promise<void> {
    await this.core.storage.setItem<Record<string, MessageRecord>>(
      this.storageKeyWithoutClientAck,
      mapToObj(messages),
    );
  }

  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {
    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(
      this.storageKey,
    );
    return typeof messages !== "undefined" ? objToMap(messages) : undefined;
  }

  private async getRelayerMessagesWithoutClientAck(): Promise<
    Map<string, MessageRecord> | undefined
  > {
    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(
      this.storageKeyWithoutClientAck,
    );
    return typeof messages !== "undefined" ? objToMap(messages) : undefined;
  }

  private async persist() {
    await this.setRelayerMessages(this.messages);
    await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/pairing.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import {
  ICore,
  PairingTypes,
  IPairing,
  IPairingPrivate,
  IStore,
  RelayerTypes,
  PairingJsonRpcTypes,
  ExpirerTypes,
  EventClientTypes,
} from "@walletconnect/types";
import {
  getInternalError,
  parseUri,
  calcExpiry,
  generateRandomBytes32,
  formatUri,
  getSdkError,
  engineEvent,
  createDelayedPromise,
  isValidParams,
  isValidUrl,
  isValidString,
  isExpired,
  parseExpirerTarget,
  TYPE_1,
} from "@walletconnect/utils";
import {
  formatJsonRpcRequest,
  formatJsonRpcResult,
  formatJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isJsonRpcError,
} from "@walletconnect/jsonrpc-utils";
import { FIVE_MINUTES, toMiliseconds } from "@walletconnect/time";
import EventEmitter from "events";
import {
  PAIRING_CONTEXT,
  PAIRING_STORAGE_VERSION,
  CORE_STORAGE_PREFIX,
  RELAYER_DEFAULT_PROTOCOL,
  PAIRING_RPC_OPTS,
  RELAYER_EVENTS,
  EXPIRER_EVENTS,
  PAIRING_EVENTS,
  EVENT_CLIENT_PAIRING_TRACES,
  EVENT_CLIENT_PAIRING_ERRORS,
  TRANSPORT_TYPES,
} from "../constants";
import { Store } from "../controllers/store";

export class Pairing implements IPairing {
  public name = PAIRING_CONTEXT;
  public version = PAIRING_STORAGE_VERSION;

  public events = new EventEmitter();
  public pairings: IStore<string, PairingTypes.Struct>;

  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;
  private ignoredPayloadTypes = [TYPE_1];
  private registeredMethods: string[] = [];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    this.core = core;
    this.logger = generateChildLogger(logger, this.name);
    this.pairings = new Store(this.core, this.logger, this.name, this.storagePrefix);
  }

  public init: IPairing["init"] = async () => {
    if (!this.initialized) {
      await this.pairings.init();
      await this.cleanup();
      this.registerRelayerEvents();
      this.registerExpirerEvents();
      this.initialized = true;
      this.logger.trace(`Initialized`);
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  public register: IPairing["register"] = ({ methods }) => {
    this.isInitialized();
    this.registeredMethods = [...new Set([...this.registeredMethods, ...methods])];
  };

  public create: IPairing["create"] = async (params) => {
    this.isInitialized();
    const symKey = generateRandomBytes32();
    const topic = await this.core.crypto.setSymKey(symKey);
    const expiry = calcExpiry(FIVE_MINUTES);
    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };
    const pairing = { topic, expiry, relay, active: false, methods: params?.methods };
    const uri = formatUri({
      protocol: this.core.protocol,
      version: this.core.version,
      topic,
      symKey,
      relay,
      expiryTimestamp: expiry,
      methods: params?.methods,
    });
    this.events.emit(PAIRING_EVENTS.create, pairing);
    this.core.expirer.set(topic, expiry);
    await this.pairings.set(topic, pairing);
    await this.core.relayer.subscribe(topic, { transportType: params?.transportType });

    return { topic, uri };
  };

  public pair: IPairing["pair"] = async (params) => {
    this.isInitialized();

    const event = this.core.eventClient.createEvent({
      properties: {
        topic: params?.uri,
        trace: [EVENT_CLIENT_PAIRING_TRACES.pairing_started],
      },
    });

    this.isValidPair(params, event);

    const { topic, symKey, relay, expiryTimestamp, methods } = parseUri(params.uri);

    event.props.properties.topic = topic;
    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_validation_success);
    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_not_expired);

    let existingPairing;
    if (this.pairings.keys.includes(topic)) {
      existingPairing = this.pairings.get(topic);
      event.addTrace(EVENT_CLIENT_PAIRING_TRACES.existing_pairing);
      if (existingPairing.active) {
        event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
        throw new Error(
          `Pairing already exists: ${topic}. Please try again with a new connection URI.`,
        );
      } else {
        event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_not_expired);
      }
    }

    const expiry = expiryTimestamp || calcExpiry(FIVE_MINUTES);
    const pairing = { topic, relay, expiry, active: false, methods };
    this.core.expirer.set(topic, expiry);
    await this.pairings.set(topic, pairing);

    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.store_new_pairing);

    if (params.activatePairing) {
      await this.activate({ topic });
    }

    this.events.emit(PAIRING_EVENTS.create, pairing);

    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_inactive_pairing);

    // avoid overwriting keychain pairing already exists
    if (!this.core.crypto.keychain.has(topic)) {
      await this.core.crypto.setSymKey(symKey, topic);
    }
    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribing_pairing_topic);

    try {
      await this.core.relayer.confirmOnlineStateOrThrow();
    } catch (error) {
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.no_internet_connection);
    }

    try {
      await this.core.relayer.subscribe(topic, { relay });
    } catch (error) {
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.subscribe_pairing_topic_failure);
      throw error;
    }

    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribe_pairing_topic_success);

    return pairing;
  };

  public activate: IPairing["activate"] = async ({ topic }) => {
    this.isInitialized();
    const expiry = calcExpiry(FIVE_MINUTES);
    this.core.expirer.set(topic, expiry);
    await this.pairings.update(topic, { active: true, expiry });
  };

  /**
   * @deprecated Ping will be removed in the next major release.
   */
  public ping: IPairing["ping"] = async (params) => {
    this.isInitialized();
    await this.isValidPing(params);
    this.logger.warn("ping() is deprecated and will be removed in the next major release.");
    const { topic } = params;
    if (this.pairings.keys.includes(topic)) {
      const id = await this.sendRequest(topic, "wc_pairingPing", {});
      const { done, resolve, reject } = createDelayedPromise<void>();
      this.events.once(engineEvent("pairing_ping", id), ({ error }) => {
        if (error) reject(error);
        else resolve();
      });
      await done();
    }
  };

  public updateExpiry: IPairing["updateExpiry"] = async ({ topic, expiry }) => {
    this.isInitialized();
    await this.pairings.update(topic, { expiry });
  };

  public updateMetadata: IPairing["updateMetadata"] = async ({ topic, metadata }) => {
    this.isInitialized();
    await this.pairings.update(topic, { peerMetadata: metadata });
  };

  public getPairings: IPairing["getPairings"] = () => {
    this.isInitialized();
    return this.pairings.values;
  };

  public disconnect: IPairing["disconnect"] = async (params) => {
    this.isInitialized();
    await this.isValidDisconnect(params);
    const { topic } = params;
    if (this.pairings.keys.includes(topic)) {
      await this.sendRequest(topic, "wc_pairingDelete", getSdkError("USER_DISCONNECTED"));
      await this.deletePairing(topic);
    }
  };

  public formatUriFromPairing: IPairing["formatUriFromPairing"] = (pairing) => {
    this.isInitialized();
    const { topic, relay, expiry, methods } = pairing;
    const symKey = this.core.crypto.keychain.get(topic);
    return formatUri({
      protocol: this.core.protocol,
      version: this.core.version,
      topic,
      symKey,
      relay,
      expiryTimestamp: expiry,
      methods,
    });
  };

  // ---------- Private Helpers ----------------------------------------------- //

  private sendRequest: IPairingPrivate["sendRequest"] = async (topic, method, params) => {
    const payload = formatJsonRpcRequest(method, params);
    const message = await this.core.crypto.encode(topic, payload);
    const opts = PAIRING_RPC_OPTS[method].req;
    this.core.history.set(topic, payload);
    this.core.relayer.publish(topic, message, opts);
    return payload.id;
  };

  private sendResult: IPairingPrivate["sendResult"] = async (id, topic, result) => {
    const payload = formatJsonRpcResult(id, result);
    const message = await this.core.crypto.encode(topic, payload);
    const record = await this.core.history.get(topic, id);
    const method = record.request.method as PairingJsonRpcTypes.WcMethod;
    const opts = PAIRING_RPC_OPTS[method].res;
    await this.core.relayer.publish(topic, message, opts);
    await this.core.history.resolve(payload);
  };

  private sendError: IPairingPrivate["sendError"] = async (id, topic, error) => {
    const payload = formatJsonRpcError(id, error);
    const message = await this.core.crypto.encode(topic, payload);
    const record = await this.core.history.get(topic, id);
    const method = record.request.method as PairingJsonRpcTypes.WcMethod;

    const opts = PAIRING_RPC_OPTS[method]
      ? PAIRING_RPC_OPTS[method].res
      : PAIRING_RPC_OPTS.unregistered_method.res;

    await this.core.relayer.publish(topic, message, opts);
    await this.core.history.resolve(payload);
  };

  private deletePairing: IPairingPrivate["deletePairing"] = async (topic, expirerHasDeleted) => {
    // Await the unsubscribe first to avoid deleting the symKey too early below.
    await this.core.relayer.unsubscribe(topic);
    await Promise.all([
      this.pairings.delete(topic, getSdkError("USER_DISCONNECTED")),
      this.core.crypto.deleteSymKey(topic),
      expirerHasDeleted ? Promise.resolve() : this.core.expirer.del(topic),
    ]);
  };

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private cleanup = async () => {
    const expiredPairings = this.pairings.getAll().filter((pairing) => isExpired(pairing.expiry));
    await Promise.all(expiredPairings.map((pairing) => this.deletePairing(pairing.topic)));
  };

  // ---------- Relay Events Router ----------------------------------- //

  private registerRelayerEvents() {
    this.core.relayer.on(RELAYER_EVENTS.message, async (event: RelayerTypes.MessageEvent) => {
      const { topic, message, transportType } = event;

      // Do not handle if the topic is not related to known pairing topics.
      if (!this.pairings.keys.includes(topic)) return;

      // Do not handle link-mode messages
      if (transportType === TRANSPORT_TYPES.link_mode) return;

      // messages of certain types should be ignored as they are handled by their respective SDKs
      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(message))) return;

      try {
        const payload = await this.core.crypto.decode(topic, message);

        if (isJsonRpcRequest(payload)) {
          this.core.history.set(topic, payload);
          await this.onRelayEventRequest({ topic, payload });
        } else if (isJsonRpcResponse(payload)) {
          await this.core.history.resolve(payload);
          await this.onRelayEventResponse({ topic, payload });
          this.core.history.delete(topic, payload.id);
        }
        await this.core.relayer.messages.ack(topic, message);
      } catch (error) {
        this.logger.error(error);
      }
    });
  }

  private onRelayEventRequest: IPairingPrivate["onRelayEventRequest"] = async (event) => {
    const { topic, payload } = event;
    const reqMethod = payload.method as PairingJsonRpcTypes.WcMethod;

    switch (reqMethod) {
      case "wc_pairingPing":
        return await this.onPairingPingRequest(topic, payload);
      case "wc_pairingDelete":
        return await this.onPairingDeleteRequest(topic, payload);
      default:
        return await this.onUnknownRpcMethodRequest(topic, payload);
    }
  };

  private onRelayEventResponse: IPairingPrivate["onRelayEventResponse"] = async (event) => {
    const { topic, payload } = event;
    const record = await this.core.history.get(topic, payload.id);
    const resMethod = record.request.method as PairingJsonRpcTypes.WcMethod;

    switch (resMethod) {
      case "wc_pairingPing":
        return this.onPairingPingResponse(topic, payload);
      default:
        return this.onUnknownRpcMethodResponse(resMethod);
    }
  };

  private onPairingPingRequest: IPairingPrivate["onPairingPingRequest"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    try {
      this.isValidPing({ topic });
      await this.sendResult<"wc_pairingPing">(id, topic, true);
      this.events.emit(PAIRING_EVENTS.ping, { id, topic });
    } catch (err: any) {
      await this.sendError(id, topic, err);
      this.logger.error(err);
    }
  };

  private onPairingPingResponse: IPairingPrivate["onPairingPingResponse"] = (_topic, payload) => {
    const { id } = payload;
    // put at the end of the stack to avoid a race condition
    // where pairing_ping listener is not yet initialized
    setTimeout(() => {
      if (isJsonRpcResult(payload)) {
        this.events.emit(engineEvent("pairing_ping", id), {});
      } else if (isJsonRpcError(payload)) {
        this.events.emit(engineEvent("pairing_ping", id), { error: payload.error });
      }
    }, 500);
  };

  private onPairingDeleteRequest: IPairingPrivate["onPairingDeleteRequest"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    try {
      this.isValidDisconnect({ topic });
      await this.deletePairing(topic);
      this.events.emit(PAIRING_EVENTS.delete, { id, topic });
    } catch (err: any) {
      await this.sendError(id, topic, err);
      this.logger.error(err);
    }
  };

  private onUnknownRpcMethodRequest: IPairingPrivate["onUnknownRpcMethodRequest"] = async (
    topic,
    payload,
  ) => {
    const { id, method } = payload;

    try {
      // Ignore if the implementing client has registered this method as known.
      if (this.registeredMethods.includes(method)) return;
      const error = getSdkError("WC_METHOD_UNSUPPORTED", method);
      await this.sendError(id, topic, error);
      this.logger.error(error);
    } catch (err: any) {
      await this.sendError(id, topic, err);
      this.logger.error(err);
    }
  };

  private onUnknownRpcMethodResponse: IPairingPrivate["onUnknownRpcMethodResponse"] = (method) => {
    // Ignore if the implementing client has registered this method as known.
    if (this.registeredMethods.includes(method)) return;
    this.logger.error(getSdkError("WC_METHOD_UNSUPPORTED", method));
  };

  // ---------- Expirer Events ---------------------------------------- //

  private registerExpirerEvents() {
    this.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {
      const { topic } = parseExpirerTarget(event.target);
      if (!topic) return;
      if (!this.pairings.keys.includes(topic)) return;
      await this.deletePairing(topic, true);
      this.events.emit(PAIRING_EVENTS.expire, { topic });
    });
  }

  // ---------- Validation Helpers ----------------------------------- //

  private isValidPair = (params: { uri: string }, event: EventClientTypes.Event) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() params: ${params}`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    if (!isValidUrl(params.uri)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri: ${params.uri}`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    const uri = parseUri(params?.uri);
    if (!uri?.relay?.protocol) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri#relay-protocol`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    if (!uri?.symKey) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri#symKey`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    if (uri?.expiryTimestamp) {
      const expiration = toMiliseconds(uri?.expiryTimestamp);
      if (expiration < Date.now()) {
        event.setError(EVENT_CLIENT_PAIRING_ERRORS.pairing_expired);
        const { message } = getInternalError(
          "EXPIRED",
          `pair() URI has expired. Please try again with a new connection URI.`,
        );
        throw new Error(message);
      }
    }
  };

  private isValidPing = async (params: { topic: string }) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `ping() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;
    await this.isValidPairingTopic(topic);
  };

  private isValidDisconnect = async (params: { topic: string }) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `disconnect() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;
    await this.isValidPairingTopic(topic);
  };

  private isValidPairingTopic = async (topic: any) => {
    if (!isValidString(topic, false)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `pairing topic should be a string: ${topic}`,
      );
      throw new Error(message);
    }
    if (!this.pairings.keys.includes(topic)) {
      const { message } = getInternalError(
        "NO_MATCHING_KEY",
        `pairing topic doesn't exist: ${topic}`,
      );
      throw new Error(message);
    }
    if (isExpired(this.pairings.get(topic).expiry)) {
      await this.deletePairing(topic);
      const { message } = getInternalError("EXPIRED", `pairing topic: ${topic}`);
      throw new Error(message);
    }
  };
}
</file>

<file path="packages/core/src/controllers/publisher.ts">
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { JsonRpcPayload, RequestArguments } from "@walletconnect/jsonrpc-types";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { RelayJsonRpc } from "@walletconnect/relay-api";
import { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from "@walletconnect/types";
import {
  getRelayProtocolApi,
  getRelayProtocolName,
  isUndefined,
  createExpiringPromise,
} from "@walletconnect/utils";
import { EventEmitter } from "events";

import { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from "../constants";
import { getBigIntRpcId } from "@walletconnect/jsonrpc-utils";
import { ONE_MINUTE, ONE_SECOND, toMiliseconds } from "@walletconnect/time";

type IPublishType = PublisherTypes.Params & {
  attestation?: string;
  attempt: number;
};
export class Publisher extends IPublisher {
  public events = new EventEmitter();
  public name = PUBLISHER_CONTEXT;
  public queue = new Map<string, IPublishType>();

  private publishTimeout = toMiliseconds(ONE_MINUTE);
  private initialPublishTimeout = toMiliseconds(ONE_SECOND * 15);
  private needsTransportRestart = false;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super(relayer, logger);
    this.relayer = relayer;
    this.logger = generateChildLogger(logger, this.name);
    this.registerEventListeners();
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  public publish: IPublisher["publish"] = async (topic, message, opts) => {
    this.logger.debug(`Publishing Payload`);
    this.logger.trace({ type: "method", method: "publish", params: { topic, message, opts } });

    const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;
    const relay = getRelayProtocolName(opts);
    const prompt = opts?.prompt || false;
    const tag = opts?.tag || 0;
    const id = opts?.id || (getBigIntRpcId().toString() as any);
    const params = {
      topic,
      message,
      opts: {
        ttl,
        relay,
        prompt,
        tag,
        id,
        attestation: opts?.attestation,
        tvf: opts?.tvf,
      },
    };
    const failedPublishMessage = `Failed to publish payload, please try again. id:${id} tag:${tag}`;

    try {
      /**
       * attempt to publish the payload for <initialPublishTimeout> seconds,
       * if the publish fails, add the payload to the queue and it will be retried on every pulse
       * until it is successfully published or <publishTimeout> seconds have passed
       */
      const publishPromise = new Promise(async (resolve) => {
        const onPublish = ({ id }: { id: string }) => {
          if (params.opts.id === id) {
            this.removeRequestFromQueue(id);
            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);
            resolve(params);
          }
        };
        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);
        const initialPublish = createExpiringPromise(
          new Promise((resolve, reject) => {
            this.rpcPublish({
              topic,
              message,
              ttl,
              prompt,
              tag,
              id,
              attestation: opts?.attestation,
              tvf: opts?.tvf,
            })
              .then(resolve)
              .catch((e) => {
                this.logger.warn(e, e?.message);
                reject(e);
              });
          }),
          this.initialPublishTimeout,
          `Failed initial publish, retrying.... id:${id} tag:${tag}`,
        );
        try {
          await initialPublish;
          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);
        } catch (e) {
          this.queue.set(id, { ...params, attempt: 1 });
          this.logger.warn(e, (e as Error)?.message);
        }
      });
      this.logger.trace({
        type: "method",
        method: "publish",
        params: { id, topic, message, opts },
      });

      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);
    } catch (e) {
      this.logger.debug(`Failed to Publish Payload`);
      this.logger.error(e as any);
      if (opts?.internal?.throwOnFailedPublish) {
        throw e;
      }
    } finally {
      this.queue.delete(id);
    }
  };

  public on: IPublisher["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: IPublisher["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: IPublisher["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: IPublisher["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  // ---------- Private ----------------------------------------------- //

  private async rpcPublish(params: {
    topic: string;
    message: string;
    ttl?: number;
    prompt?: boolean;
    tag?: number;
    id?: number;
    attestation?: string;
    tvf?: RelayerTypes.ITVF;
  }) {
    const {
      topic,
      message,
      ttl = PUBLISHER_DEFAULT_TTL,
      prompt,
      tag,
      id,
      attestation,
      tvf,
    } = params;
    const api = getRelayProtocolApi(getRelayProtocolName().protocol);
    const request: RequestArguments<RelayJsonRpc.PublishParams> = {
      method: api.publish,
      params: {
        topic,
        message,
        ttl,
        prompt,
        tag,
        attestation,
        ...tvf,
      },
      id,
    };
    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;
    if (isUndefined(request.params?.tag)) delete request.params?.tag;
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "message", direction: "outgoing", request });
    const result = await this.relayer.request(request);
    this.relayer.events.emit(RELAYER_EVENTS.publish, params);
    this.logger.debug(`Successfully Published Payload`);
    return result;
  }

  private removeRequestFromQueue(id: string) {
    this.queue.delete(id);
  }

  private checkQueue() {
    this.queue.forEach(async (params, id) => {
      const attempt = params.attempt + 1;
      this.queue.set(id, { ...params, attempt });
      const { topic, message, opts, attestation } = params;
      this.logger.warn(
        {},
        `Publisher: queue->publishing: ${params.opts.id}, tag: ${params.opts.tag}, attempt: ${attempt}`,
      );
      await this.rpcPublish({
        ...params,
        topic,
        message,
        ttl: opts.ttl,
        prompt: opts.prompt,
        tag: opts.tag,
        id: opts.id,
        attestation,
        tvf: opts.tvf,
      });
      this.logger.warn({}, `Publisher: queue->published: ${params.opts.id}`);
    });
  }

  private registerEventListeners() {
    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
      // restart the transport if needed
      // queue will be processed on the next pulse
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false;
        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
        return;
      }
      this.checkQueue();
    });
    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {
      this.removeRequestFromQueue(event.id.toString());
    });
  }
}
</file>

<file path="packages/core/src/controllers/relayer.ts">
import { EventEmitter } from "events";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
import {
  formatJsonRpcResult,
  getBigIntRpcId,
  IJsonRpcProvider,
  isJsonRpcRequest,
  isJsonRpcResponse,
  JsonRpcPayload,
  JsonRpcRequest,
  RequestArguments,
} from "@walletconnect/jsonrpc-utils";
import WsConnection from "@walletconnect/jsonrpc-ws-connection";
import {
  generateChildLogger,
  getDefaultLoggerOptions,
  getLoggerContext,
  pino,
  Logger,
} from "@walletconnect/logger";
import { RelayJsonRpc } from "@walletconnect/relay-api";
import {
  FIVE_MINUTES,
  ONE_SECOND,
  FIVE_SECONDS,
  THIRTY_SECONDS,
  toMiliseconds,
} from "@walletconnect/time";
import {
  ICore,
  IMessageTracker,
  IPublisher,
  IRelayer,
  ISubscriber,
  RelayerOptions,
  RelayerTypes,
  SubscriberTypes,
} from "@walletconnect/types";
import {
  createExpiringPromise,
  formatRelayRpcUrl,
  isOnline,
  subscribeToNetworkChange,
  getAppId,
  isAndroid,
  isIos,
  getInternalError,
  isNode,
  calcExpiry,
} from "@walletconnect/utils";

import {
  RELAYER_SDK_VERSION,
  RELAYER_CONTEXT,
  RELAYER_DEFAULT_LOGGER,
  RELAYER_EVENTS,
  RELAYER_PROVIDER_EVENTS,
  RELAYER_SUBSCRIBER_SUFFIX,
  RELAYER_DEFAULT_RELAY_URL,
  SUBSCRIBER_EVENTS,
  RELAYER_RECONNECT_TIMEOUT,
  TRANSPORT_TYPES,
  MESSAGE_DIRECTION,
} from "../constants";
import { MessageTracker } from "./messages";
import { Publisher } from "./publisher";
import { Subscriber } from "./subscriber";

export class Relayer extends IRelayer {
  public protocol = "wc";
  public version = 2;

  public core: ICore;
  public logger: Logger;
  public events = new EventEmitter();
  public provider: IJsonRpcProvider;
  public messages: IMessageTracker;
  public subscriber: ISubscriber;
  public publisher: IPublisher;
  public name = RELAYER_CONTEXT;
  public transportExplicitlyClosed = false;

  private initialized = false;
  private connectionAttemptInProgress = false;

  private relayUrl: string;
  private projectId: string | undefined;
  private packageName: string | undefined;
  private bundleId: string | undefined;
  private hasExperiencedNetworkDisruption = false;
  private pingTimeout: NodeJS.Timeout | undefined;
  /**
   * the relay pings the client 30 seconds after the last message was received
   * meaning if we don't receive a message in 30 seconds, the connection can be considered dead
   */
  private heartBeatTimeout = toMiliseconds(THIRTY_SECONDS + FIVE_SECONDS);
  private reconnectTimeout: NodeJS.Timeout | undefined;
  private connectPromise: Promise<void> | undefined;
  private reconnectInProgress = false;
  private requestsInFlight: string[] = [];
  private connectTimeout = toMiliseconds(ONE_SECOND * 15);
  constructor(opts: RelayerOptions) {
    super(opts);
    this.core = opts.core;
    this.logger =
      typeof opts.logger !== "undefined" && typeof opts.logger !== "string"
        ? generateChildLogger(opts.logger, this.name)
        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));
    this.messages = new MessageTracker(this.logger, opts.core);
    this.subscriber = new Subscriber(this, this.logger);
    this.publisher = new Publisher(this, this.logger);

    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;
    this.projectId = opts.projectId;

    if (isAndroid()) {
      this.packageName = getAppId();
    } else if (isIos()) {
      this.bundleId = getAppId();
    }

    // re-assigned during init()
    this.provider = {} as IJsonRpcProvider;
  }

  public async init() {
    this.logger.trace(`Initialized`);
    this.registerEventListeners();
    await Promise.all([this.messages.init(), this.subscriber.init()]);
    this.initialized = true;
    if (this.subscriber.hasAnyTopics) {
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e, (e as Error)?.message);
      }
    }
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  get connected() {
    // @ts-expect-error
    return this.provider?.connection?.socket?.readyState === 1 || false;
  }

  get connecting() {
    return (
      // @ts-expect-error
      this.provider?.connection?.socket?.readyState === 0 ||
      this.connectPromise !== undefined ||
      false
    );
  }

  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {
    this.isInitialized();
    await this.publisher.publish(topic, message, opts);
    await this.recordMessageEvent(
      {
        topic,
        message,
        // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.
        publishedAt: Date.now(),
        transportType: TRANSPORT_TYPES.relay,
      },
      MESSAGE_DIRECTION.outbound,
    );
  }

  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {
    this.isInitialized();
    if (!opts?.transportType || opts?.transportType === "relay") {
      await this.toEstablishConnection();
    }
    // throw unless explicitly set to false
    const shouldThrowOnFailure =
      typeof opts?.internal?.throwOnFailedPublish === "undefined"
        ? true
        : opts?.internal?.throwOnFailedPublish;

    let id = this.subscriber.topicMap.get(topic)?.[0] || "";
    let resolvePromise: () => void;
    const onSubCreated = (subscription: SubscriberTypes.Active) => {
      if (subscription.topic === topic) {
        this.subscriber.off(SUBSCRIBER_EVENTS.created, onSubCreated);
        resolvePromise();
      }
    };

    await Promise.all([
      new Promise<void>((resolve) => {
        resolvePromise = resolve;
        this.subscriber.on(SUBSCRIBER_EVENTS.created, onSubCreated);
      }),
      new Promise<void>(async (resolve, reject) => {
        const result = await this.subscriber
          .subscribe(topic, {
            internal: {
              throwOnFailedPublish: shouldThrowOnFailure,
            },
            ...opts,
          })
          .catch((error) => {
            if (shouldThrowOnFailure) {
              reject(error);
            }
          });
        id = result || id;
        resolve();
      }),
    ]);
    return id;
  }

  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {
    this.logger.debug(`Publishing Request Payload`);
    const id = request.id || (getBigIntRpcId().toString() as any);
    await this.toEstablishConnection();
    try {
      this.logger.trace(
        {
          id,
          method: request.method,
          topic: request.params?.topic,
        },
        "relayer.request - publishing...",
      );
      const tag = `${id}:${(request.params as any)?.tag || ""}`;
      this.requestsInFlight.push(tag);
      const result = await this.provider.request(request);
      this.requestsInFlight = this.requestsInFlight.filter((i) => i !== tag);
      return result;
    } catch (e) {
      this.logger.debug(`Failed to Publish Request: ${id}`);
      throw e;
    }
  };

  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {
    this.isInitialized();
    await this.subscriber.unsubscribe(topic, opts);
  }

  public on(event: string, listener: any) {
    this.events.on(event, listener);
  }

  public once(event: string, listener: any) {
    this.events.once(event, listener);
  }

  public off(event: string, listener: any) {
    this.events.off(event, listener);
  }

  public removeListener(event: string, listener: any) {
    this.events.removeListener(event, listener);
  }

  public async transportDisconnect() {
    if (this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)) {
      await createExpiringPromise(this.provider.disconnect(), 2000, "provider.disconnect()").catch(
        () => this.onProviderDisconnect(),
      );
    } else {
      this.onProviderDisconnect();
    }
  }

  public async transportClose() {
    this.transportExplicitlyClosed = true;
    await this.transportDisconnect();
  }

  async transportOpen(relayUrl?: string) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn(
        "Starting WS connection skipped because the client has no topics to work with.",
      );
      return;
    }

    if (this.connectPromise) {
      this.logger.debug({}, `Waiting for existing connection attempt to resolve...`);
      await this.connectPromise;
      this.logger.debug({}, `Existing connection attempt resolved`);
    } else {
      this.connectPromise = new Promise(async (resolve, reject) => {
        await this.connect(relayUrl)
          .then(resolve)
          .catch(reject)
          .finally(() => {
            this.connectPromise = undefined;
          });
      });
      await this.connectPromise;
    }
    if (!this.connected) {
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
    }
  }

  public async restartTransport(relayUrl?: string) {
    this.logger.debug({}, "Restarting transport...");
    if (this.connectionAttemptInProgress) return;
    this.relayUrl = relayUrl || this.relayUrl;
    await this.confirmOnlineStateOrThrow();
    await this.transportClose();
    await this.transportOpen();
  }

  public async confirmOnlineStateOrThrow() {
    if (await isOnline()) return;
    throw new Error("No internet connection detected. Please restart your network and try again.");
  }

  public async handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]) {
    if (messages?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const sortedMessages = messages.sort((a, b) => a.publishedAt - b.publishedAt);
    this.logger.debug(`Batch of ${sortedMessages.length} message events sorted`);
    for (const message of sortedMessages) {
      try {
        await this.onMessageEvent(message);
      } catch (e) {
        this.logger.warn(e, "Error while processing batch message event: " + (e as Error)?.message);
      }
    }
    this.logger.trace(`Batch of ${sortedMessages.length} message events processed`);
  }

  public async onLinkMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
    opts: { sessionExists: boolean },
  ) {
    const { topic } = messageEvent;

    if (!opts.sessionExists) {
      const expiry = calcExpiry(FIVE_MINUTES);
      const pairing = { topic, expiry, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(topic, pairing);
    }

    this.events.emit(RELAYER_EVENTS.message, messageEvent);
    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);
  }

  // ---------- Private ----------------------------------------------- //

  private async connect(relayUrl?: string) {
    await this.confirmOnlineStateOrThrow();
    if (relayUrl && relayUrl !== this.relayUrl) {
      this.relayUrl = relayUrl;
      await this.transportDisconnect();
    }

    this.connectionAttemptInProgress = true;
    this.transportExplicitlyClosed = false;
    let attempt = 1;
    while (attempt < 6) {
      try {
        if (this.transportExplicitlyClosed) {
          break;
        }
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${attempt}...`);
        // Always create new socket instance when trying to connect because if the socket was dropped due to `socket hang up` exception
        // It wont be able to reconnect
        await this.createProvider();

        await new Promise<void>(async (resolve, reject) => {
          const onDisconnect = () => {
            reject(new Error(`Connection interrupted while trying to subscribe`));
          };
          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);

          await createExpiringPromise(
            new Promise((resolve, reject) => {
              this.provider.connect().then(resolve).catch(reject);
            }),
            this.connectTimeout,
            `Socket stalled when trying to connect to ${this.relayUrl}`,
          )
            .catch((e) => {
              reject(e);
            })
            .finally(() => {
              this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
              clearTimeout(this.reconnectTimeout);
            });
          await new Promise(async (resolve, reject) => {
            const onDisconnect = () => {
              reject(new Error(`Connection interrupted while trying to subscribe`));
            };
            this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
            await this.subscriber
              .start()
              .then(resolve)
              .catch(reject)
              .finally(() => {
                this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
              });
          });
          this.hasExperiencedNetworkDisruption = false;
          resolve();
        });
      } catch (e) {
        await this.subscriber.stop();
        const error = e as Error;
        this.logger.warn({}, error.message);
        this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }

      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${attempt}`);
        break;
      }

      await new Promise((resolve) => setTimeout(resolve, toMiliseconds(attempt * 1)));
      attempt++;
    }
  }

  /*
   * In Node, we must detect when the connection is stalled and terminate it.
   * The logic is, if we don't receive ping from the relay within a certain time, we terminate the connection.
   * The timer is refreshed on every message received from the relay.
   *
   * In the browser, ping/pong events are not exposed, so the above behaviour is handled by `subscribeToNetworkChange` and `isOnline` functions.
   */
  private startPingTimeout() {
    if (!isNode()) return;
    try {
      //@ts-expect-error - Types are divergent between the node and browser WS API
      if (this.provider?.connection?.socket) {
        //@ts-expect-error
        this.provider?.connection?.socket?.on("ping", () => {
          this.resetPingTimeout();
        });
      }
      this.resetPingTimeout();
    } catch (e) {
      this.logger.warn(e, (e as Error)?.message);
    }
  }

  private resetPingTimeout = () => {
    if (!isNode()) return;
    clearTimeout(this.pingTimeout);
    this.pingTimeout = setTimeout(() => {
      try {
        this.logger.debug({}, "pingTimeout: Connection stalled, terminating...");
        //@ts-expect-error
        this.provider?.connection?.socket?.terminate?.();
      } catch (e) {
        this.logger.warn(e, (e as Error)?.message);
      }
    }, this.heartBeatTimeout);
  };

  private async createProvider() {
    if (this.provider.connection) {
      this.unregisterProviderListeners();
    }
    const auth = await this.core.crypto.signJWT(this.relayUrl);

    this.provider = new JsonRpcProvider(
      new WsConnection(
        formatRelayRpcUrl({
          sdkVersion: RELAYER_SDK_VERSION,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth,
          useOnCloseEvent: true,
          bundleId: this.bundleId,
          packageName: this.packageName,
        }),
      ),
    );
    this.registerProviderListeners();
  }

  private async recordMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
    direction?: RelayerTypes.MessageDirection,
  ) {
    const { topic, message } = messageEvent;
    await this.messages.set(topic, message, direction);
  }

  private async shouldIgnoreMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
  ): Promise<boolean> {
    const { topic, message } = messageEvent;

    // Ignore if incoming `message` is clearly invalid.
    if (!message || message.length === 0) {
      this.logger.warn(`Ignoring invalid/empty message: ${message}`);
      return true;
    }

    // Ignore if `topic` is not known to the subscriber.
    if (!(await this.subscriber.isKnownTopic(topic))) {
      this.logger.warn(`Ignoring message for unknown topic ${topic}`);
      return true;
    }

    // Ignore if `message` is a duplicate.
    const exists = this.messages.has(topic, message);
    if (exists) {
      this.logger.warn(`Ignoring duplicate message: ${message}`);
    }
    return exists;
  }

  private async onProviderPayload(payload: JsonRpcPayload) {
    this.logger.debug(`Incoming Relay Payload`);
    this.logger.trace({ type: "payload", direction: "incoming", payload });
    if (isJsonRpcRequest(payload)) {
      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;
      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;
      const { topic, message, publishedAt, attestation } = event.data;
      const messageEvent: RelayerTypes.MessageEvent = {
        topic,
        message,
        publishedAt,
        transportType: TRANSPORT_TYPES.relay,
        attestation,
      };
      this.logger.debug(`Emitting Relayer Payload`);
      this.logger.trace({ type: "event", event: event.id, ...messageEvent });
      this.events.emit(event.id, messageEvent);
      await this.acknowledgePayload(payload);
      await this.onMessageEvent(messageEvent);
    } else if (isJsonRpcResponse(payload)) {
      this.events.emit(RELAYER_EVENTS.message_ack, payload);
    }
  }

  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {
    if (await this.shouldIgnoreMessageEvent(messageEvent)) {
      return;
    }
    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);
    this.events.emit(RELAYER_EVENTS.message, messageEvent);
  }

  private async acknowledgePayload(payload: JsonRpcPayload) {
    const response = formatJsonRpcResult(payload.id, true);
    await this.provider.connection.send(response);
  }

  // ---------- Events Handlers ----------------------------------------------- //
  private onPayloadHandler = (payload: JsonRpcPayload) => {
    this.onProviderPayload(payload);
    this.resetPingTimeout();
  };

  private onConnectHandler = () => {
    this.logger.warn({}, "Relayer connected ");
    this.startPingTimeout();
    this.events.emit(RELAYER_EVENTS.connect);
  };

  private onDisconnectHandler = () => {
    this.logger.warn({}, `Relayer disconnected `);
    this.requestsInFlight = [];
    this.onProviderDisconnect();
  };

  private onProviderErrorHandler = (error: Error) => {
    this.logger.fatal(`Fatal socket error: ${error.message}`);
    this.events.emit(RELAYER_EVENTS.error, error);
    // close the transport when a fatal error is received as there's no way to recover from it
    // usual cases are missing/invalid projectId, expired jwt token, invalid origin etc
    this.logger.fatal("Fatal socket error received, closing transport");
    this.transportClose();
  };

  private registerProviderListeners = () => {
    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);
    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);
    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);
    this.provider.on(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);
  };

  private unregisterProviderListeners() {
    this.provider.off(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);
    this.provider.off(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);
    this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);
    this.provider.off(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);
    clearTimeout(this.pingTimeout);
  }

  private async registerEventListeners() {
    let lastConnectedState = await isOnline();
    subscribeToNetworkChange(async (connected: boolean) => {
      // sometimes the network change event is triggered multiple times so avoid reacting to the samFe value
      if (lastConnectedState === connected) return;

      lastConnectedState = connected;
      if (!connected) {
        // when the device network is restarted, the socket might stay in false `connected` state
        this.hasExperiencedNetworkDisruption = true;
        await this.transportDisconnect();
        this.transportExplicitlyClosed = false;
      } else {
        await this.transportOpen().catch((error) =>
          this.logger.error(error, (error as Error)?.message),
        );
      }
    });
  }

  private async onProviderDisconnect() {
    clearTimeout(this.pingTimeout);
    this.events.emit(RELAYER_EVENTS.disconnect);
    this.connectionAttemptInProgress = false;
    if (this.reconnectInProgress) return;

    this.reconnectInProgress = true;
    await this.subscriber.stop();

    if (!this.subscriber.hasAnyTopics) return;
    if (this.transportExplicitlyClosed) return;

    this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((error) =>
        this.logger.error(error, (error as Error)?.message),
      );
      this.reconnectTimeout = undefined;
      this.reconnectInProgress = false;
    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow();
    if (this.connected) return;
    await this.connect();
  }
}
</file>

<file path="packages/core/src/controllers/store.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IStore } from "@walletconnect/types";
import {
  getInternalError,
  isProposalStruct,
  isSessionStruct,
  isUndefined,
} from "@walletconnect/utils";
import { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from "../constants";
import { isEqual } from "es-toolkit/compat";

export class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {
  public map = new Map<Key, Data>();
  public version = STORE_STORAGE_VERSION;

  private cached: Data[] = [];
  private initialized = false;

  /**
   * Regenerates the value key to retrieve it from cache
   */
  private getKey: ((data: Data) => Key) | undefined;

  private storagePrefix = CORE_STORAGE_PREFIX;

  // stores recently deleted key to return different rejection message when key is not found
  private recentlyDeleted: Key[] = [];
  private recentlyDeletedLimit = 200;

  /**
   * @param {ICore} core Core
   * @param {Logger} logger Logger
   * @param {string} name Store's name
   * @param {Store<Key, Data>["getKey"]} getKey Regenerates the value key to retrieve it from cache
   * @param {string} storagePrefix Prefixes value keys
   */
  constructor(
    public core: ICore,
    public logger: Logger,
    public name: string,
    storagePrefix: string = CORE_STORAGE_PREFIX,
    getKey: Store<Key, Data>["getKey"] = undefined,
  ) {
    super(core, logger, name, storagePrefix);
    this.logger = generateChildLogger(logger, this.name);
    this.storagePrefix = storagePrefix;
    this.getKey = getKey;
  }

  public init: IStore<Key, Data>["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);

      await this.restore();

      this.cached.forEach((value) => {
        if (this.getKey && value !== null && !isUndefined(value)) {
          this.map.set(this.getKey(value), value);
        } else if (isProposalStruct(value)) {
          // TODO(pedro) revert type casting as any
          this.map.set(value.id as any, value);
        } else if (isSessionStruct(value)) {
          // TODO(pedro) revert type casting as any
          this.map.set(value.topic as any, value);
        }
      });

      this.cached = [];
      this.initialized = true;
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get length() {
    return this.map.size;
  }

  get keys() {
    return Array.from(this.map.keys());
  }

  get values() {
    return Array.from(this.map.values());
  }

  public set: IStore<Key, Data>["set"] = async (key, value) => {
    this.isInitialized();
    if (this.map.has(key)) {
      await this.update(key, value);
    } else {
      this.logger.debug(`Setting value`);
      this.logger.trace({ type: "method", method: "set", key, value });
      this.map.set(key, value);
      await this.persist();
    }
  };

  public get: IStore<Key, Data>["get"] = (key) => {
    this.isInitialized();
    this.logger.debug(`Getting value`);
    this.logger.trace({ type: "method", method: "get", key });
    const value = this.getData(key);
    return value;
  };

  public getAll: IStore<Key, Data>["getAll"] = (filter) => {
    this.isInitialized();
    if (!filter) return this.values;

    return this.values.filter((value) =>
      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),
    );
  };

  public update: IStore<Key, Data>["update"] = async (key, update) => {
    this.isInitialized();
    this.logger.debug(`Updating value`);
    this.logger.trace({ type: "method", method: "update", key, update });
    const value = { ...this.getData(key), ...update };
    this.map.set(key, value);
    await this.persist();
  };

  public delete: IStore<Key, Data>["delete"] = async (key, reason) => {
    this.isInitialized();
    if (!this.map.has(key)) return;
    this.logger.debug(`Deleting value`);
    this.logger.trace({ type: "method", method: "delete", key, reason });
    this.map.delete(key);
    this.addToRecentlyDeleted(key);
    await this.persist();
  };

  // ---------- Private ----------------------------------------------- //

  private addToRecentlyDeleted(key: Key) {
    this.recentlyDeleted.push(key);
    // limit the size of the recentlyDeleted array, truncate the 100 oldest entries.
    if (this.recentlyDeleted.length >= this.recentlyDeletedLimit) {
      this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
    }
  }

  private async setDataStore(value: Data[]) {
    await this.core.storage.setItem<Data[]>(this.storageKey, value);
  }

  private async getDataStore() {
    const value = await this.core.storage.getItem<Data[]>(this.storageKey);
    return value;
  }

  private getData(key: Key) {
    const value = this.map.get(key);
    if (!value) {
      if (this.recentlyDeleted.includes(key)) {
        const { message } = getInternalError(
          "MISSING_OR_INVALID",
          `Record was recently deleted - ${this.name}: ${key}`,
        );
        this.logger.error(message);
        throw new Error(message);
      }

      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${key}`);
      this.logger.error(message);
      throw new Error(message);
    }
    return value;
  }

  private async persist() {
    await this.setDataStore(this.values);
  }

  private async restore() {
    try {
      const persisted = await this.getDataStore();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.map.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored value for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/subscriber.ts">
import { EventEmitter } from "events";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { ErrorResponse, RequestArguments } from "@walletconnect/jsonrpc-types";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { RelayJsonRpc } from "@walletconnect/relay-api";
import { ONE_SECOND, ONE_MINUTE, toMiliseconds } from "@walletconnect/time";
import {
  IRelayer,
  ISubscriber,
  RelayerTypes,
  SubscriberEvents,
  SubscriberTypes,
} from "@walletconnect/types";
import {
  getSdkError,
  getInternalError,
  getRelayProtocolApi,
  getRelayProtocolName,
  createExpiringPromise,
  hashMessage,
  sleep,
} from "@walletconnect/utils";
import {
  CORE_STORAGE_PREFIX,
  SUBSCRIBER_CONTEXT,
  SUBSCRIBER_EVENTS,
  SUBSCRIBER_STORAGE_VERSION,
  RELAYER_EVENTS,
  TRANSPORT_TYPES,
} from "../constants";
import { SubscriberTopicMap } from "./topicmap";

export class Subscriber extends ISubscriber {
  public subscriptions = new Map<string, SubscriberTypes.Active>();
  public topicMap = new SubscriberTopicMap();
  public events = new EventEmitter();
  public name = SUBSCRIBER_CONTEXT;
  public version = SUBSCRIBER_STORAGE_VERSION;
  public pending = new Map<string, SubscriberTypes.Params>();

  private cached: SubscriberTypes.Active[] = [];
  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;
  private subscribeTimeout = toMiliseconds(ONE_MINUTE);
  private initialSubscribeTimeout = toMiliseconds(ONE_SECOND * 15);
  private clientId: string;
  private batchSubscribeTopicsLimit = 500;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super(relayer, logger);
    this.relayer = relayer;
    this.logger = generateChildLogger(logger, this.name);
    this.clientId = ""; // assigned when calling this.getClientId()
  }

  public init: ISubscriber["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      this.registerEventListeners();
      await this.restore();
    }
    this.initialized = true;
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return (
      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    );
  }

  get length() {
    return this.subscriptions.size;
  }

  get ids() {
    return Array.from(this.subscriptions.keys());
  }

  get values() {
    return Array.from(this.subscriptions.values());
  }

  get topics() {
    return this.topicMap.topics;
  }

  get hasAnyTopics() {
    return (
      this.topicMap.topics.length > 0 ||
      this.pending.size > 0 ||
      this.cached.length > 0 ||
      this.subscriptions.size > 0
    );
  }

  public subscribe: ISubscriber["subscribe"] = async (topic, opts) => {
    this.isInitialized();
    this.logger.debug(`Subscribing Topic`);
    this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
    try {
      const relay = getRelayProtocolName(opts);
      const params = { topic, relay, transportType: opts?.transportType };
      this.pending.set(topic, params);
      const id = await this.rpcSubscribe(topic, relay, opts);
      if (typeof id === "string") {
        this.onSubscribe(id, params);
        this.logger.debug(`Successfully Subscribed Topic`);
        this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
      }
      return id;
    } catch (e) {
      this.logger.debug(`Failed to Subscribe Topic`);
      this.logger.error(e as any);
      throw e;
    }
  };

  public unsubscribe: ISubscriber["unsubscribe"] = async (topic, opts) => {
    this.isInitialized();
    if (typeof opts?.id !== "undefined") {
      await this.unsubscribeById(topic, opts.id, opts);
    } else {
      await this.unsubscribeByTopic(topic, opts);
    }
  };

  /**
   * returns `true` only if the topic is actively subscribed to i.e. not pending or cached
   */
  public isSubscribed: ISubscriber["isSubscribed"] = (topic: string) => {
    return new Promise((resolve) => {
      resolve(this.topicMap.topics.includes(topic));
    });
  };

  /**
   * returns `true` if the topic is known to the subscriber i.e. it is actively subscribed, pending, cached or in the topic map
   */
  public isKnownTopic: ISubscriber["isKnownTopic"] = (topic: string) => {
    return new Promise((resolve) => {
      resolve(
        this.topicMap.topics.includes(topic) ||
          this.pending.has(topic) ||
          this.cached.some((s) => s.topic === topic),
      );
    });
  };

  public on: ISubscriber["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: ISubscriber["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: ISubscriber["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: ISubscriber["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  public start: ISubscriber["start"] = async () => {
    await this.onConnect();
  };

  public stop: ISubscriber["stop"] = async () => {
    await this.onDisconnect();
  };

  // ---------- Private ----------------------------------------------- //

  private hasSubscription(id: string, topic: string) {
    let result = false;
    try {
      const subscription = this.getSubscription(id);
      result = subscription.topic === topic;
    } catch (e) {
      // ignore error
    }
    return result;
  }

  private reset() {
    this.cached = [];
    this.initialized = true;
  }

  private onDisable() {
    this.cached = this.values;
    this.subscriptions.clear();
    this.topicMap.clear();
  }

  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {
    const ids = this.topicMap.get(topic);
    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));
  }

  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {
    this.logger.debug(`Unsubscribing Topic`);
    this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });

    try {
      const relay = getRelayProtocolName(opts);
      await this.restartToComplete({ topic, id, relay });
      await this.rpcUnsubscribe(topic, id, relay);
      const reason = getSdkError("USER_DISCONNECTED", `${this.name}, ${topic}`);
      await this.onUnsubscribe(topic, id, reason);
      this.logger.debug(`Successfully Unsubscribed Topic`);
      this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
    } catch (e) {
      this.logger.debug(`Failed to Unsubscribe Topic`);
      this.logger.error(e as any);
      throw e;
    }
  }

  private async rpcSubscribe(
    topic: string,
    relay: RelayerTypes.ProtocolOptions,
    opts?: RelayerTypes.SubscribeOptions,
  ) {
    if (!opts || opts?.transportType === TRANSPORT_TYPES.relay) {
      await this.restartToComplete({ topic, id: topic, relay });
    }
    const api = getRelayProtocolApi(relay.protocol);
    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {
      method: api.subscribe,
      params: {
        topic,
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    const shouldThrow = opts?.internal?.throwOnFailedPublish;
    try {
      const subId = await this.getSubscriptionId(topic);
      // in link mode, allow the app to update its network state (i.e. active airplane mode) with small delay before attempting to subscribe
      if (opts?.transportType === TRANSPORT_TYPES.link_mode) {
        setTimeout(() => {
          if (this.relayer.connected || this.relayer.connecting) {
            this.relayer.request(request).catch((e) => this.logger.warn(e));
          }
        }, toMiliseconds(ONE_SECOND));
        return subId;
      }
      const subscribePromise = new Promise(async (resolve) => {
        const onSubscribe = (subscription: SubscriberEvents.Created) => {
          if (subscription.topic === topic) {
            this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);
            resolve(subscription.id);
          }
        };
        this.events.on(SUBSCRIBER_EVENTS.created, onSubscribe);
        try {
          const result = await createExpiringPromise(
            new Promise((resolve, reject) => {
              this.relayer
                .request(request)
                .catch((e) => {
                  this.logger.warn(e, e?.message);
                  reject(e);
                })
                .then(resolve);
            }),
            this.initialSubscribeTimeout,
            `Subscribing to ${topic} failed, please try again`,
          );
          this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);
          resolve(result);
        } catch (err) {}
      });

      const subscribe = createExpiringPromise(
        subscribePromise,
        this.subscribeTimeout,
        `Subscribing to ${topic} failed, please try again`,
      );

      const result = await subscribe;
      if (!result && shouldThrow) {
        throw new Error(`Subscribing to ${topic} failed, please try again`);
      }
      // return null to indicate that the subscription failed
      return result ? subId : null;
    } catch (err) {
      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);
      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
      if (shouldThrow) {
        throw err;
      }
    }
    return null;
  }

  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;
    const relay = subscriptions[0].relay;
    const api = getRelayProtocolApi(relay!.protocol);
    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {
      method: api.batchSubscribe,
      params: {
        topics: subscriptions.map((s) => s.topic),
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    try {
      const subscribe = await createExpiringPromise(
        new Promise((resolve) => {
          this.relayer
            .request(request)
            .catch((e) => this.logger.warn(e))
            .then(resolve);
        }),
        this.subscribeTimeout,
        "rpcBatchSubscribe failed, please try again",
      );
      await subscribe;
    } catch (err) {
      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
    }
  }

  private async rpcBatchFetchMessages(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;
    const relay = subscriptions[0].relay;
    const api = getRelayProtocolApi(relay!.protocol);
    const request: RequestArguments<RelayJsonRpc.BatchFetchMessagesParams> = {
      method: api.batchFetchMessages,
      params: {
        topics: subscriptions.map((s) => s.topic),
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    let result;
    try {
      const fetchMessagesPromise = await createExpiringPromise(
        new Promise((resolve, reject) => {
          this.relayer
            .request(request)
            .catch((e) => {
              this.logger.warn(e);
              reject(e);
            })
            .then(resolve);
        }),
        this.subscribeTimeout,
        "rpcBatchFetchMessages failed, please try again",
      );
      result = (await fetchMessagesPromise) as {
        messages: RelayerTypes.MessageEvent[];
      };
    } catch (err) {
      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
    }
    return result;
  }

  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {
    const api = getRelayProtocolApi(relay.protocol);
    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {
      method: api.unsubscribe,
      params: {
        topic,
        id,
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    return this.relayer.request(request);
  }

  private onSubscribe(id: string, params: SubscriberTypes.Params) {
    this.setSubscription(id, { ...params, id });
    this.pending.delete(params.topic);
  }

  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {
    if (!subscriptions.length) return;
    subscriptions.forEach((subscription) => {
      this.setSubscription(subscription.id, { ...subscription });
      this.pending.delete(subscription.topic);
    });
  }

  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {
    this.events.removeAllListeners(id);
    if (this.hasSubscription(id, topic)) {
      this.deleteSubscription(id, reason);
    }
    await this.relayer.messages.del(topic);
  }

  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {
    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(
      this.storageKey,
      subscriptions,
    );
  }

  private async getRelayerSubscriptions() {
    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(
      this.storageKey,
    );
    return subscriptions;
  }

  private setSubscription(id: string, subscription: SubscriberTypes.Active) {
    this.logger.debug(`Setting subscription`);
    this.logger.trace({ type: "method", method: "setSubscription", id, subscription });
    this.addSubscription(id, subscription);
  }

  private addSubscription(id: string, subscription: SubscriberTypes.Active) {
    this.subscriptions.set(id, { ...subscription });
    this.topicMap.set(subscription.topic, id);
    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);
  }

  private getSubscription(id: string) {
    this.logger.debug(`Getting subscription`);
    this.logger.trace({ type: "method", method: "getSubscription", id });
    const subscription = this.subscriptions.get(id);
    if (!subscription) {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${id}`);
      throw new Error(message);
    }
    return subscription;
  }

  private deleteSubscription(id: string, reason: ErrorResponse) {
    this.logger.debug(`Deleting subscription`);
    this.logger.trace({ type: "method", method: "deleteSubscription", id, reason });
    const subscription = this.getSubscription(id);
    this.subscriptions.delete(id);
    this.topicMap.delete(subscription.topic, id);
    this.events.emit(SUBSCRIBER_EVENTS.deleted, {
      ...subscription,
      reason,
    } as SubscriberEvents.Deleted);
  }

  private restart = async () => {
    await this.restore();
    await this.onRestart();
  };

  private async persist() {
    await this.setRelayerSubscriptions(this.values);
    this.events.emit(SUBSCRIBER_EVENTS.sync);
  }

  private async onRestart() {
    if (this.cached.length) {
      const subs = [...this.cached];
      const numOfBatches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i = 0; i < numOfBatches; i++) {
        const batch = subs.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(batch);
      }
    }
    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);
  }

  private async restore() {
    try {
      const persisted = await this.getRelayerSubscriptions();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.subscriptions.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;

    await this.rpcBatchSubscribe(subscriptions);
    this.onBatchSubscribe(
      await Promise.all(
        subscriptions.map(async (s) => {
          return { ...s, id: await this.getSubscriptionId(s.topic) };
        }),
      ),
    );
  }

  // @ts-ignore
  private async batchFetchMessages(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;
    this.logger.trace(`Fetching batch messages for ${subscriptions.length} subscriptions`);
    const response = await this.rpcBatchFetchMessages(subscriptions);
    if (response && response.messages) {
      await sleep(toMiliseconds(ONE_SECOND));
      await this.relayer.handleBatchMessageEvents(response.messages);
    }
  }

  private async onConnect() {
    await this.restart();
    this.reset();
  }

  private onDisconnect() {
    this.onDisable();
  }

  private checkPending = async () => {
    if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) {
      return;
    }
    const pendingSubscriptions: SubscriberTypes.Params[] = [];
    this.pending.forEach((params) => {
      pendingSubscriptions.push(params);
    });

    await this.batchSubscribe(pendingSubscriptions);
  };

  private registerEventListeners = () => {
    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    });
    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {
      const eventName = SUBSCRIBER_EVENTS.created;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: createdEvent });
      await this.persist();
    });
    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {
      const eventName = SUBSCRIBER_EVENTS.deleted;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
      await this.persist();
    });
  };

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private async restartToComplete(subscription: SubscriberTypes.Active) {
    if (!this.relayer.connected && !this.relayer.connecting) {
      this.cached.push(subscription);
      await this.relayer.transportOpen();
    }
  }

  private async getClientId() {
    if (!this.clientId) {
      this.clientId = await this.relayer.core.crypto.getClientId();
    }
    return this.clientId;
  }

  private async getSubscriptionId(topic: string) {
    return hashMessage(topic + (await this.getClientId()));
  }
}
</file>

<file path="packages/core/src/controllers/topicmap.ts">
import { ISubscriberTopicMap } from "@walletconnect/types";

export class SubscriberTopicMap implements ISubscriberTopicMap {
  public map = new Map<string, string[]>();

  get topics(): string[] {
    return Array.from(this.map.keys());
  }

  public set: ISubscriberTopicMap["set"] = (topic, id) => {
    const ids = this.get(topic);
    if (this.exists(topic, id)) return;
    this.map.set(topic, [...ids, id]);
  };

  public get: ISubscriberTopicMap["get"] = (topic) => {
    const ids = this.map.get(topic);
    return ids || [];
  };

  public exists: ISubscriberTopicMap["exists"] = (topic, id) => {
    const ids = this.get(topic);
    return ids.includes(id);
  };

  public delete: ISubscriberTopicMap["delete"] = (topic, id) => {
    if (typeof id === "undefined") {
      this.map.delete(topic);
      return;
    }
    if (!this.map.has(topic)) return;
    const ids = this.get(topic);
    if (!this.exists(topic, id)) return;
    const remaining = ids.filter((x) => x !== id);
    if (!remaining.length) {
      this.map.delete(topic);
      return;
    }
    this.map.set(topic, remaining);
  };

  public clear: ISubscriberTopicMap["clear"] = () => {
    this.map.clear();
  };
}
</file>

<file path="packages/core/src/controllers/verify.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IVerify } from "@walletconnect/types";
import { isBrowser, isTestRun, P256KeyDataType, verifyP256Jwt } from "@walletconnect/utils";
import { FIVE_SECONDS, ONE_SECOND, toMiliseconds } from "@walletconnect/time";
import { getDocument } from "@walletconnect/window-getters";
import { decodeJWT } from "@walletconnect/relay-auth";

import {
  CORE_STORAGE_PREFIX,
  CORE_VERSION,
  TRUSTED_VERIFY_URLS,
  VERIFY_CONTEXT,
  VERIFY_SERVER,
  VERIFY_SERVER_V3,
} from "../constants";
import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";

type Jwk = {
  publicKey: P256KeyDataType;
  expiresAt: number;
};
type JwkPayload = {
  exp: number;
  id: string;
  origin: string;
  isScam: boolean;
  isVerified: boolean;
};
export class Verify extends IVerify {
  public name = VERIFY_CONTEXT;
  private abortController: AbortController;
  private isDevEnv;
  private verifyUrlV3 = VERIFY_SERVER_V3;
  private storagePrefix = CORE_STORAGE_PREFIX;
  private version = CORE_VERSION;
  private publicKey?: Jwk;
  private fetchPromise?: Promise<Jwk>;

  constructor(
    public core: ICore,
    public logger: Logger,
    public store: IKeyValueStorage,
  ) {
    super(core, logger, store);
    this.logger = generateChildLogger(logger, this.name);
    this.abortController = new AbortController();
    this.isDevEnv = isTestRun();
    this.init();
  }

  get storeKey(): string {
    return (
      this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + `verify:public:key`
    );
  }

  public init = async () => {
    if (this.isDevEnv) return;
    this.publicKey = await this.store.getItem(this.storeKey);
    if (this.publicKey && toMiliseconds(this.publicKey?.expiresAt) < Date.now()) {
      this.logger.debug("verify v2 public key expired");
      await this.removePublicKey();
    }
  };

  public register: IVerify["register"] = async (params) => {
    if (!isBrowser() || this.isDevEnv) return;
    const origin = window.location.origin;
    const { id, decryptedId } = params;
    const src = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${origin}&id=${id}&decryptedId=${decryptedId}`;
    try {
      const document = getDocument() as Document;
      const abortTimeout = this.startAbortTimer(ONE_SECOND * 5);
      const attestationJwt = await new Promise((resolve, reject) => {
        const abortListener = () => {
          window.removeEventListener("message", listener);
          document.body.removeChild(iframe);
          reject("attestation aborted");
        };
        this.abortController.signal.addEventListener("abort", abortListener);
        const iframe = document.createElement("iframe");
        iframe.src = src;
        iframe.style.display = "none";
        iframe.addEventListener("error", abortListener, { signal: this.abortController.signal });
        const listener = (event: MessageEvent) => {
          if (!event.data) return;
          if (typeof event.data !== "string") return;
          try {
            const data = JSON.parse(event.data);
            if (data.type === "verify_attestation") {
              const decoded = decodeJWT(data.attestation) as unknown as { payload: JwkPayload };
              if (decoded.payload.id !== id) return;

              clearInterval(abortTimeout);
              document.body.removeChild(iframe);
              this.abortController.signal.removeEventListener("abort", abortListener);
              window.removeEventListener("message", listener);
              resolve(data.attestation === null ? "" : data.attestation);
            }
          } catch (e) {
            this.logger.warn(e);
          }
        };
        document.body.appendChild(iframe);
        window.addEventListener("message", listener, { signal: this.abortController.signal });
      });
      this.logger.debug("jwt attestation", attestationJwt);
      return attestationJwt as string;
    } catch (e) {
      this.logger.warn(e);
    }
    return "";
  };

  public resolve: IVerify["resolve"] = async (params) => {
    if (this.isDevEnv) return "";
    const { attestationId, hash, encryptedId } = params;
    if (attestationId === "") {
      this.logger.debug("resolve: attestationId is empty, skipping");
      return;
    }

    if (attestationId) {
      const decoded = decodeJWT(attestationId) as unknown as { payload: JwkPayload };
      if (decoded.payload.id !== encryptedId) return;
      const validation = await this.isValidJwtAttestation(attestationId);
      if (validation) {
        if (!validation.isVerified) {
          this.logger.warn("resolve: jwt attestation: origin url not verified");
          return;
        }
        return validation;
      }
    }
    if (!hash) return;
    const verifyUrl = this.getVerifyUrl(params?.verifyUrl);
    return this.fetchAttestation(hash, verifyUrl);
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  private fetchAttestation = async (attestationId: string, url: string) => {
    this.logger.debug(`resolving attestation: ${attestationId} from url: ${url}`);
    // set artificial timeout to prevent hanging
    const timeout = this.startAbortTimer(ONE_SECOND * 5);
    const result = await fetch(`${url}/attestation/${attestationId}?v2Supported=true`, {
      signal: this.abortController.signal,
    });
    clearTimeout(timeout);
    return result.status === 200 ? await result.json() : undefined;
  };

  private startAbortTimer(timer: number) {
    this.abortController = new AbortController();
    return setTimeout(() => this.abortController.abort(), toMiliseconds(timer));
  }

  private getVerifyUrl = (verifyUrl?: string) => {
    let url = verifyUrl || VERIFY_SERVER;
    if (!TRUSTED_VERIFY_URLS.includes(url)) {
      this.logger.info(
        `verify url: ${url}, not included in trusted list, assigning default: ${VERIFY_SERVER}`,
      );
      url = VERIFY_SERVER;
    }
    return url;
  };

  private fetchPublicKey = async () => {
    try {
      this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
      const timeout = this.startAbortTimer(FIVE_SECONDS);
      const result = await fetch(`${this.verifyUrlV3}/public-key`, {
        signal: this.abortController.signal,
      });
      clearTimeout(timeout);
      return (await result.json()) as Jwk;
    } catch (e) {
      this.logger.warn(e);
    }
    return undefined;
  };

  private persistPublicKey = async (publicKey: Jwk) => {
    this.logger.debug(`persisting public key to local storage`, publicKey);
    await this.store.setItem(this.storeKey, publicKey);
    this.publicKey = publicKey;
  };

  private removePublicKey = async () => {
    this.logger.debug(`removing verify v2 public key from storage`);
    await this.store.removeItem(this.storeKey);
    this.publicKey = undefined;
  };

  private isValidJwtAttestation = async (attestation: string) => {
    const key = await this.getPublicKey();
    try {
      if (key) {
        const validation = this.validateAttestation(attestation, key);
        return validation;
      }
    } catch (e) {
      this.logger.error(e);
      this.logger.warn("error validating attestation");
    }
    const newKey = await this.fetchAndPersistPublicKey();
    try {
      if (newKey) {
        const validation = this.validateAttestation(attestation, newKey);
        return validation;
      }
    } catch (e) {
      this.logger.error(e);
      this.logger.warn("error validating attestation");
    }
    return undefined;
  };

  private getPublicKey = async () => {
    if (this.publicKey) return this.publicKey;
    return await this.fetchAndPersistPublicKey();
  };

  private fetchAndPersistPublicKey = async () => {
    if (this.fetchPromise) {
      await this.fetchPromise;
      return this.publicKey;
    }
    this.fetchPromise = new Promise(async (resolve) => {
      const key = await this.fetchPublicKey();
      if (!key) return;
      await this.persistPublicKey(key);
      resolve(key);
    });
    const key = await this.fetchPromise;
    this.fetchPromise = undefined;
    return key;
  };

  private validateAttestation = (attestation: string, key: Jwk) => {
    const result = verifyP256Jwt<JwkPayload>(attestation, key.publicKey);
    const validation = {
      hasExpired: toMiliseconds(result.exp) < Date.now(),
      payload: result,
    };

    if (validation.hasExpired) {
      this.logger.warn("resolve: jwt attestation expired");
      throw new Error("JWT attestation expired");
    }

    return {
      origin: validation.payload.origin,
      isScam: validation.payload.isScam,
      isVerified: validation.payload.isVerified,
    };
  };
}
</file>

<file path="packages/core/src/core.ts">
import { EventEmitter } from "events";

import { HeartBeat } from "@walletconnect/heartbeat";
import KeyValueStorage from "@walletconnect/keyvaluestorage";
import {
  ChunkLoggerController,
  generateChildLogger,
  generatePlatformLogger,
  getDefaultLoggerOptions,
  getLoggerContext,
} from "@walletconnect/logger";
import { CoreTypes, ICore } from "@walletconnect/types";

import {
  CORE_CONTEXT,
  CORE_DEFAULT,
  CORE_PROTOCOL,
  CORE_STORAGE_OPTIONS,
  CORE_VERSION,
  RELAYER_DEFAULT_RELAY_URL,
  TRANSPORT_TYPES,
  WALLETCONNECT_CLIENT_ID,
  WALLETCONNECT_LINK_MODE_APPS,
} from "./constants";
import {
  Crypto,
  EchoClient,
  EventClient,
  Expirer,
  JsonRpcHistory,
  Pairing,
  Relayer,
  Verify,
} from "./controllers";

export class Core extends ICore {
  public readonly protocol = CORE_PROTOCOL;
  public readonly version = CORE_VERSION;

  public readonly name: ICore["name"] = CORE_CONTEXT;
  public readonly relayUrl: ICore["relayUrl"];
  public readonly projectId: ICore["projectId"];
  public readonly customStoragePrefix: ICore["customStoragePrefix"];
  public events: ICore["events"] = new EventEmitter();
  public logger: ICore["logger"];
  public heartbeat: ICore["heartbeat"];
  public relayer: ICore["relayer"];
  public crypto: ICore["crypto"];
  public storage: ICore["storage"];
  public history: ICore["history"];
  public expirer: ICore["expirer"];
  public pairing: ICore["pairing"];
  public verify: ICore["verify"];
  public echoClient: ICore["echoClient"];
  public linkModeSupportedApps: ICore["linkModeSupportedApps"];
  public eventClient: ICore["eventClient"];

  private initialized = false;
  private logChunkController: ChunkLoggerController | null;

  static async init(opts?: CoreTypes.Options) {
    const core = new Core(opts);
    await core.initialize();
    const clientId = await core.crypto.getClientId();
    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);

    return core;
  }

  constructor(opts?: CoreTypes.Options) {
    super(opts);

    const globalCore = this.getGlobalCore(opts?.customStoragePrefix);
    if (globalCore) {
      try {
        this.customStoragePrefix = globalCore.customStoragePrefix;
        this.logger = globalCore.logger;
        this.heartbeat = globalCore.heartbeat;
        this.crypto = globalCore.crypto;
        this.history = globalCore.history;
        this.expirer = globalCore.expirer;
        this.storage = globalCore.storage;
        this.relayer = globalCore.relayer;
        this.pairing = globalCore.pairing;
        this.verify = globalCore.verify;
        this.echoClient = globalCore.echoClient;
        this.linkModeSupportedApps = globalCore.linkModeSupportedApps;
        this.eventClient = globalCore.eventClient;
        this.initialized = globalCore.initialized;
        this.logChunkController = globalCore.logChunkController;
        return globalCore;
      } catch (error) {
        console.warn("Failed to copy global core", error);
      }
    }

    this.projectId = opts?.projectId;
    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;
    this.customStoragePrefix = opts?.customStoragePrefix ? `:${opts.customStoragePrefix}` : "";

    const loggerOptions = getDefaultLoggerOptions({
      level: typeof opts?.logger === "string" && opts.logger ? opts.logger : CORE_DEFAULT.logger,
      name: CORE_CONTEXT,
    });

    const { logger, chunkLoggerController } = generatePlatformLogger({
      opts: loggerOptions,
      maxSizeInBytes: opts?.maxLogBlobSizeInBytes,
      loggerOverride: opts?.logger,
    });

    this.logChunkController = chunkLoggerController;

    if (this.logChunkController?.downloadLogsBlobInBrowser) {
      // @ts-ignore
      window.downloadLogsBlobInBrowser = async () => {
        // Have to null check twice becquse there is no guarantee
        // this.logChunkController.downloadLogsBlobInBrowser is always truthy
        if (this.logChunkController?.downloadLogsBlobInBrowser) {
          this.logChunkController?.downloadLogsBlobInBrowser({
            clientId: await this.crypto.getClientId(),
          });
        }
      };
    }

    this.logger = generateChildLogger(logger, this.name);
    this.heartbeat = new HeartBeat();
    this.crypto = new Crypto(this, this.logger, opts?.keychain);
    this.history = new JsonRpcHistory(this, this.logger);
    this.expirer = new Expirer(this, this.logger);
    this.storage = opts?.storage
      ? opts.storage
      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });
    this.relayer = new Relayer({
      core: this,
      logger: this.logger,
      relayUrl: this.relayUrl,
      projectId: this.projectId,
    });
    this.pairing = new Pairing(this, this.logger);
    this.verify = new Verify(this, this.logger, this.storage);
    this.echoClient = new EchoClient(this.projectId || "", this.logger);
    this.linkModeSupportedApps = [];
    this.eventClient = new EventClient(this, this.logger, opts?.telemetryEnabled);
    this.setGlobalCore(this);
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  // ---------- Public ----------------------------------------------- //

  public async start() {
    if (this.initialized) return;
    await this.initialize();
  }

  public async getLogsBlob() {
    return this.logChunkController?.logsToBlob({
      clientId: await this.crypto.getClientId(),
    });
  }

  public async addLinkModeSupportedApp(universalLink: string) {
    if (this.linkModeSupportedApps.includes(universalLink)) return;
    this.linkModeSupportedApps.push(universalLink);
    await this.storage.setItem(WALLETCONNECT_LINK_MODE_APPS, this.linkModeSupportedApps);
  }

  // ---------- Events ----------------------------------------------- //

  public on = (name: any, listener: any) => {
    return this.events.on(name, listener);
  };

  public once = (name: any, listener: any) => {
    return this.events.once(name, listener);
  };

  public off = (name: any, listener: any) => {
    return this.events.off(name, listener);
  };

  public removeListener = (name: any, listener: any) => {
    return this.events.removeListener(name, listener);
  };

  // ---------- Link-mode ----------------------------------------------- //

  public dispatchEnvelope = ({
    topic,
    message,
    sessionExists,
  }: {
    topic: string;
    message: string;
    sessionExists: boolean;
  }) => {
    if (!topic || !message) return;

    const payload = {
      topic,
      message,
      publishedAt: Date.now(),
      transportType: TRANSPORT_TYPES.link_mode,
    };

    this.relayer.onLinkMessageEvent(payload, { sessionExists });
  };

  // ---------- Private ----------------------------------------------- //

  private async initialize() {
    this.logger.trace(`Initialized`);
    try {
      await this.crypto.init();
      await this.history.init();
      await this.expirer.init();
      await this.relayer.init();
      await this.heartbeat.init();
      await this.pairing.init();
      this.linkModeSupportedApps = (await this.storage.getItem(WALLETCONNECT_LINK_MODE_APPS)) || [];

      this.initialized = true;
      this.logger.info(`Core Initialization Success`);
    } catch (error) {
      this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, error);
      this.logger.error((error as any).message);
      throw error;
    }
  }

  private getGlobalCore(customStoragePrefix = ""): Core | undefined {
    try {
      if (this.isGlobalCoreDisabled()) {
        return undefined;
      }
      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;

      const counterKey = `${globalCorePrefix}_count`;
      globalThis[counterKey] = (globalThis[counterKey] || 0) + 1;
      if (globalThis[counterKey] > 1) {
        console.warn(
          `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[counterKey]} times.`,
        );
      }

      return globalThis[globalCorePrefix];
    } catch (error) {
      console.warn("Failed to get global WalletConnect core", error);
      return undefined;
    }
  }

  private setGlobalCore(core: Core) {
    try {
      if (this.isGlobalCoreDisabled()) {
        return;
      }
      const customStoragePrefix = core.opts?.customStoragePrefix || "";
      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;
      globalThis[globalCorePrefix] = core;
    } catch (error) {
      console.warn("Failed to set global WalletConnect core", error);
    }
  }

  private isGlobalCoreDisabled() {
    try {
      return typeof process !== "undefined" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch (error) {
      return true;
    }
  }
}
</file>

<file path="packages/core/src/index.ts">
import { Core as WalletConnectCore } from "./core";

export * from "./constants";
export * from "./controllers";

export const Core = WalletConnectCore;
export default WalletConnectCore;
</file>

<file path="packages/core/test/shared/helpers.ts">
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { CoreTypes, ICore } from "@walletconnect/types";
import { DEFAULT_DB_NAME, MOCK_STORE_NAME, TEST_CORE_OPTIONS, storeTestValues } from "./values";
import { Core, Store } from "../../src";

export type MockStoreValue = { id: string; value: string };

export async function throttle(timeout: number) {
  return await new Promise<void>((resolve) =>
    setTimeout(() => {
      resolve();
    }, timeout),
  );
}

/**
 * Initializes a core instance with default options
 * Default uses custom db to isolate persistence tests
 * @param customOpts = custom core init opts
 * @returns Initialized core instance
 */
export const initCore = async (
  customOpts: CoreTypes.Options = { storageOptions: { database: DEFAULT_DB_NAME } },
) => {
  const coreOptions = {
    ...TEST_CORE_OPTIONS,
    ...customOpts,
  };
  const core = new Core(coreOptions);
  await core.start();
  return core;
};

/**
 * Initializes a store instance with default options
 * @param core = core to use for store
 * @returns Initialized store instance
 */
export const initStore = async (core: ICore) => {
  const logger = pino(getDefaultLoggerOptions({ level: "fatal" }));

  const store = new Store<string, MockStoreValue>(
    core,
    logger,
    MOCK_STORE_NAME,
    undefined,
    (val) => val.value,
  );
  await store.init();
  storeTestValues.forEach((val) => store.set(val.id, val));
  return store;
};

/**
 * Prevents gross code duplication in tests that require restarting core
 * @param beforeRestart function to run before each restart
 * @param afterRestart function to run after each restart
 * @param n_restarts number of times to restart core
 * @param customOpts custom core options
 */
export const restartCore = async (
  beforeRestart?: () => Promise<void>,
  afterRestart?: () => Promise<void>,
  n_restarts = 1,
  customOpts = { storageOptions: { database: DEFAULT_DB_NAME } },
) => {
  for (let i = 0; i < n_restarts; i++) {
    if (beforeRestart) await beforeRestart();
    await initCore(customOpts);
    if (afterRestart) await afterRestart();
  }
};

/**
 * Search for a topic in a list of records
 * @param records
 * @param topic
 * @returns true if topic is found, false otherwise
 */
export const searchRecords = (records: any, topic: string) => {
  for (const [_, record] of records.entries()) {
    if (record.topic === topic) return true;
  }
  return false;
};

export const waitForEvent = async (checkForEvent: (...args: any[]) => boolean) => {
  await new Promise((resolve) => {
    const intervalId = setInterval(() => {
      if (checkForEvent()) {
        clearInterval(intervalId);
        resolve({});
      }
    }, 100);
  });
};
</file>

<file path="packages/core/test/shared/index.ts">
export * from "./values";
export * from "./ws";
export * from "./helpers";
</file>

<file path="packages/core/test/shared/values.ts">
import { CoreTypes } from "@walletconnect/types";

export const TEST_RELAY_URL = process.env.TEST_RELAY_URL
  ? process.env.TEST_RELAY_URL
  : "ws://0.0.0.0:5555";

export const TEST_PROJECT_ID = process.env.TEST_PROJECT_ID
  ? process.env.TEST_PROJECT_ID
  : undefined;

export const TEST_PROJECT_ID_MOBILE = process.env.TEST_PROJECT_ID_MOBILE
  ? process.env.TEST_PROJECT_ID_MOBILE
  : undefined;

export const TEST_CORE_OPTIONS: CoreTypes.Options = {
  logger: "fatal",
  relayUrl: TEST_RELAY_URL,
  projectId: TEST_PROJECT_ID,
  storageOptions: {
    database: ":memory:",
  },
};

export const TEST_MOBILE_APP_ID = process.env.TEST_MOBILE_APP_ID
  ? process.env.TEST_MOBILE_APP_ID
  : undefined;

// default db name for persistent storage tests
export const DEFAULT_DB_NAME = "./test/tmp/persistent-test.db";

// default store name for persistent storage tests
export const MOCK_STORE_NAME = "persistent-store";

// default test values for persistent storage tests
export const storeTestValues = [
  { id: "1", value: "foo" },
  { id: "2", value: "bar" },
  { id: "3", value: "baz" },
];
</file>

<file path="packages/core/test/shared/ws.ts">
import { IRelayer } from "@walletconnect/types";

export async function disconnectSocket(relayer: IRelayer) {
  if (relayer && relayer.connected) {
    await relayer.transportClose();
  }
}
</file>

<file path="packages/core/test/core.spec.ts">
import { expect, describe, it } from "vitest";
import sinon from "sinon";
import Core from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Core", () => {
  it("does not duplicate initialization if `Core.start()` is called repeatedly", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    const cryptoInitSpy = sinon.spy();
    const relayerInitSpy = sinon.spy();
    const heartbeatInitSpy = sinon.spy();
    // Spy on subcontroller `init` as a proxy to the private `Core.initialize`.
    core.crypto.init = cryptoInitSpy;
    core.relayer.init = relayerInitSpy;
    core.heartbeat.init = heartbeatInitSpy;
    await core.start();
    await core.start();
    expect(cryptoInitSpy.callCount).to.equal(1);
    expect(relayerInitSpy.callCount).to.equal(1);
    expect(heartbeatInitSpy.callCount).to.equal(1);
  });
  it("saves core instance in global scope", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core = await Core.init(TEST_CORE_OPTIONS);
    expect(globalThis._walletConnectCore_).to.deep.equal(core);
    globalThis._walletConnectCore_ = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
  it("saves core instance in global scope with custom storage prefix", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
    expect(globalThis._walletConnectCore_test).to.deep.equal(core);
    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
    globalThis._walletConnectCore_test = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
  it("does not save core instance in global scope if disabled", async () => {
    process.env.DISABLE_GLOBAL_CORE = "true";
    await Core.init(TEST_CORE_OPTIONS);
    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
  });
  it("does not save core instance in global scope if disabled with custom storage prefix", async () => {
    process.env.DISABLE_GLOBAL_CORE = "true";
    await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
    expect(globalThis._walletConnectCore_test).to.deep.equal(undefined);
    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
  });
  it("saves multiple core instances in global scope", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core1 = await Core.init(TEST_CORE_OPTIONS);
    const core2 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
    expect(globalThis._walletConnectCore_).to.deep.equal(core1);
    expect(globalThis._walletConnectCore_test).to.deep.equal(core2);
    globalThis._walletConnectCore_ = undefined;
    globalThis._walletConnectCore_test = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
  it("saves multiple core instances in global scope with custom storage prefix", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core1 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test1" });
    const core2 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test2" });
    expect(globalThis._walletConnectCore_test1).to.deep.equal(core1);
    expect(globalThis._walletConnectCore_test2).to.deep.equal(core2);
    globalThis._walletConnectCore_test1 = undefined;
    globalThis._walletConnectCore_test2 = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
});
</file>

<file path="packages/core/test/crypto.spec.ts">
import { expect, describe, it, beforeEach } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import * as utils from "@walletconnect/utils";
import Sinon from "sinon";
import { Core, CORE_DEFAULT, Crypto } from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Crypto", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
  const core = new Core(TEST_CORE_OPTIONS);

  let crypto: Crypto;

  beforeEach(async () => {
    crypto = new Crypto(core, logger);
    await crypto.init();
  });

  it("initializes the keychain subcontroller a single time", async () => {
    const spy = Sinon.spy();
    const _crypto = new Crypto(core, logger);
    _crypto.keychain.init = spy;
    await _crypto.init();
    await _crypto.init();
    expect(spy.callCount).to.equal(1);
  });

  describe("generateKeyPair", () => {
    it("throws if not initialized", () => {
      const invalidCrypto = new Crypto(core, logger);
      expect(() => invalidCrypto.generateKeyPair()).to.throw("Not initialized. crypto");
    });
    it("generates a keyPair, sets it in the keychain and returns publicKey", async () => {
      const privateKey = utils.generateRandomBytes32();
      const publicKey = utils.generateRandomBytes32();
      // Stub `utils.generateKeyPair` to return predictable values.
      Sinon.stub(utils, "generateKeyPair").returns({ publicKey, privateKey });
      const keychainSpy = Sinon.spy();
      crypto.keychain.set = keychainSpy;
      const returnedPublicKey = await crypto.generateKeyPair();
      const [calledPublicKey, calledPrivateKey] = keychainSpy.getCall(0).args;
      expect(calledPublicKey).to.equal(publicKey);
      expect(calledPrivateKey).to.equal(privateKey);
      expect(returnedPublicKey).to.equal(publicKey);
    });
  });

  describe("generateSharedKey", () => {
    it("throws if not initialized", () => {
      const invalidCrypto = new Crypto(core, logger);
      expect(() => invalidCrypto.generateSharedKey("a", "b")).to.throw("Not initialized. crypto");
    });
    it("generates a shared symKey, sets it in the keychain and returns the topic", async () => {
      const overrideTopic = utils.generateRandomBytes32();
      const peerPublicKey = utils.generateRandomBytes32();
      const selfPublicKey = await crypto.generateKeyPair();
      const selfPrivateKey = crypto.keychain.get(selfPublicKey);
      const expectedSymKey = utils.deriveSymKey(selfPrivateKey, peerPublicKey);
      const spy = Sinon.spy();
      crypto.setSymKey = spy;
      await crypto.generateSharedKey(selfPublicKey, peerPublicKey, overrideTopic);
      const [calledSymKey, calledOverrideTopic] = spy.getCall(0).args;
      expect(calledSymKey).to.equal(expectedSymKey);
      expect(calledOverrideTopic).to.equal(overrideTopic);
    });
  });

  describe("setSymKey", () => {
    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.setSymKey("key")).rejects.toThrow("Not initialized. crypto");
    });
    it("sets expected topic-symKey pair in keychain, returns topic", async () => {
      const spy = Sinon.spy();
      crypto.keychain.set = spy;
      const fakeSymKey = utils.generateRandomBytes32();
      const topic = utils.hashKey(fakeSymKey);
      const returnedTopic = await crypto.setSymKey(fakeSymKey);
      const [calledTopic, calledSymKey] = spy.getCall(0).args;
      expect(calledTopic).to.equal(topic);
      expect(calledSymKey).to.equal(fakeSymKey);
      expect(returnedTopic).to.equal(topic);
    });
    it("sets expected topic-symKey pair in keychain if overrideTopic is passed", async () => {
      const spy = Sinon.spy();
      crypto.keychain.set = spy;
      const fakeSymKey = utils.generateRandomBytes32();
      const topic = utils.generateRandomBytes32();
      const returnedTopic = await crypto.setSymKey(fakeSymKey, topic);
      const [calledTopic, calledSymKey] = spy.getCall(0).args;
      expect(calledTopic).to.equal(topic);
      expect(calledSymKey).to.equal(fakeSymKey);
      expect(returnedTopic).to.equal(topic);
    });
  });

  describe("deleteKeyPair", () => {
    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.deleteKeyPair("key")).rejects.toThrow("Not initialized. crypto");
    });
    it("deletes the expected topic-symKey pair from keychain", async () => {
      const publicKey = utils.generateRandomBytes32();
      const spy = Sinon.spy();
      crypto.keychain.del = spy;
      await crypto.deleteKeyPair(publicKey);
      const [calledTopic] = spy.getCall(0).args;
      expect(calledTopic).to.equal(publicKey);
    });
  });

  describe("deleteSymKey", () => {
    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.deleteSymKey("key")).rejects.toThrow("Not initialized. crypto");
    });
    it("deletes the expected topic-symKey pair from keychain", async () => {
      const topic = utils.generateRandomBytes32();
      const spy = Sinon.spy();
      crypto.keychain.del = spy;
      await crypto.deleteSymKey(topic);
      const [calledTopic] = spy.getCall(0).args;
      expect(calledTopic).to.equal(topic);
    });
  });

  describe("encode", () => {
    const symKey = "5720435e682cd03ee45b484f9a213f0e3246a0ccc2cca183b72ab1cbfbefb702";
    const payload = { id: 1, jsonrpc: "2.0", result: "result" };
    // const encoded =
    //   "AG7iJl9mMl9K04REnuWaKLQU6kwMcQWUd69OxGOJ5/A+VRRKkxnKhBeIAl4JRaIft3qZKEfnBvc7/Fife1DWcERqAfJwzPI=";

    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.encode("topic", payload)).rejects.toThrow(
        "Not initialized. crypto",
      );
    });
    it.skip("encrypts `payload` if the passed topic is known", async () => {
      const topic = await crypto.setSymKey(symKey);
      // FIXME: needs to be tested dynamically because of random IV generation
      await crypto.encode(topic, payload);
    });
  });

  describe("decode", () => {
    const symKey = "5720435e682cd03ee45b484f9a213f0e3246a0ccc2cca183b72ab1cbfbefb702";
    const payload = { id: 1, jsonrpc: "2.0", result: "result" };
    const encoded =
      "AG7iJl9mMl9K04REnuWaKLQU6kwMcQWUd69OxGOJ5/A+VRRKkxnKhBeIAl4JRaIft3qZKEfnBvc7/Fife1DWcERqAfJwzPI=";

    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.decode("topic", "encoded")).rejects.toThrow(
        "Not initialized. crypto",
      );
    });
    it("decrypts `payload` if the passed topic is known", async () => {
      const topic = await crypto.setSymKey(symKey);
      const decoded = await crypto.decode(topic, encoded);
      expect(decoded).to.eql(payload);
    });
    it("should not throw on failed decrypt", async () => {
      const decoded = await crypto.decode("non-existent-topic", "dummymessage");
      expect(decoded).to.eql(undefined);
    });
  });
});
</file>

<file path="packages/core/test/events.spec.ts">
import { expect, describe, it } from "vitest";
import Core, {
  EVENTS_STORAGE_CLEANUP_INTERVAL,
  EVENT_CLIENT_CONTEXT,
  EVENT_CLIENT_PAIRING_ERRORS,
} from "../src";
import { TEST_CORE_OPTIONS } from "./shared";
import { toMiliseconds } from "@walletconnect/time";

describe("Events Client", () => {
  it("Init events client", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    expect(core.eventClient).toBeDefined();
    expect(core.eventClient.context).toBe(EVENT_CLIENT_CONTEXT);
    expect(core.eventClient.core).toBe(core);
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(0);
  });
  it("should create event", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe(type);
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(1);
  });

  it("should create multiple events", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const eventsToCreate = 10;
    for (let i = 0; i < eventsToCreate; i++) {
      const topic = "test topic";
      const trace = ["test trace", "test trace 2"];
      const eventType = "ERROR";
      const event = core.eventClient.createEvent({
        event: eventType,
        type,
        properties: {
          topic,
          trace,
        },
      });
      expect(event).toBeDefined();
      expect(event.props.event).toBe(eventType);
      expect(event.props.type).toBe(type);
      expect(event.props.properties.topic).toBe(topic);
      expect(event.props.properties.trace).toBe(trace);
    }
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(eventsToCreate);
  });
  it("should create & delete event", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe(type);
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(1);

    core.eventClient.deleteEvent({ eventId: event.eventId });

    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(0);
  });
  it("should add trace", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe(type);
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    expect(event.addTrace).to.exist;
    expect(event.setError).to.exist;

    const additionalTrace = ["test trace 3", "test trace 4"];
    const additionlTraceLenght = additionalTrace.length;
    const defaultTraceLength = trace.length;
    event.addTrace(additionalTrace[0]);
    event.addTrace(additionalTrace[1]);
    expect(event.props.properties.trace.length).toEqual(defaultTraceLength + additionlTraceLenght);
    expect(event.props.properties.trace).toContain(additionalTrace[0]);
    expect(event.props.properties.trace).toContain(additionalTrace[1]);
  });
  it("should set error type", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe("");
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    expect(event.addTrace).to.exist;
    expect(event.setError).to.exist;

    event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);

    expect(event.props.type).toBe(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
  });
  it("should clean up old events", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });

    event.timestamp = Date.now() - toMiliseconds(EVENTS_STORAGE_CLEANUP_INTERVAL);
    // @ts-expect-error - accessing private properties
    expect(core.eventClient.events.size).toBe(1);
    await new Promise((resolve) => setTimeout(resolve, 5000));
    // @ts-expect-error - accessing private properties
    expect(core.eventClient.events.size).toBe(0);
  });
  it("should not store events when telemetry is disabled", async () => {
    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    // @ts-expect-error - accessing private properties
    expect(core.eventClient.events.size).toBe(0);
  });

  it("should not send automatic init event", async () => {
    process.env.IS_VITEST = false as any;
    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
    let initCalled = false;
    // @ts-expect-error - accessing private properties
    core.eventClient.sendEvent = async (payload: any) => {
      initCalled = true;
      expect(payload).toBeDefined();
      expect(payload.length).to.eql(1);
      expect(payload[0].props.event).to.eql("INIT");
      expect(payload[0].props.properties.client_id).to.eql(await core.crypto.getClientId());
    };
    await core.start();
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(initCalled).to.eql(false);
    process.env.IS_VITEST = true as any;
  });

  it("should send init event", async () => {
    process.env.IS_VITEST = false as any;
    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
    let initCalled = false;
    // @ts-expect-error - accessing private properties
    core.eventClient.sendEvent = async (payload: any) => {
      initCalled = true;
      expect(payload).toBeDefined();
      expect(payload.length).to.eql(1);
      expect(payload[0].props.event).to.eql("INIT");
      expect(payload[0].props.properties.client_id).to.eql(await core.crypto.getClientId());
    };
    await core.start();
    await new Promise((resolve) => setTimeout(resolve, 500));

    expect(initCalled).to.eql(false);
    await core.eventClient.init();
    expect(initCalled).to.eql(true);
    if (!initCalled) {
      throw new Error("init not called");
    }
    process.env.IS_VITEST = true as any;
  });
});
</file>

<file path="packages/core/test/expirer.spec.ts">
import { pino, getDefaultLoggerOptions } from "@walletconnect/logger";
import { expect, describe, it } from "vitest";
import { calcExpiry, formatExpirerTarget } from "@walletconnect/utils";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";

import {
  Core,
  Expirer,
  EXPIRER_EVENTS,
  CORE_STORAGE_PREFIX,
  EXPIRER_STORAGE_VERSION,
  EXPIRER_CONTEXT,
  CORE_DEFAULT,
} from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";
import { generateRandomBytes32 } from "../../utils/src";

describe("Expirer", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const core = new Core(TEST_CORE_OPTIONS);
      const expirer = new Expirer(core, logger);
      expect(expirer.storageKey).to.equal(
        CORE_STORAGE_PREFIX + EXPIRER_STORAGE_VERSION + "//" + EXPIRER_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const expirer = new Expirer(core, logger);
      expect(expirer.storageKey).to.equal(
        CORE_STORAGE_PREFIX + EXPIRER_STORAGE_VERSION + ":test" + "//" + EXPIRER_CONTEXT,
      );
    });
  });

  it("should expire payload", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    await core.relayer.subscribe(generateRandomBytes32());
    // confirm the expirer is empty
    expect(core.expirer.length).to.eq(0);
    // set a payload
    const topic = "test";
    core.expirer.set(topic, calcExpiry(1));
    // confirm the expirer is not empty
    expect(core.expirer.length).to.eq(1);
    setTimeout(() => {
      // emit heartbeat pulse event to trigger expirer
      core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
    }, 1_000);
    await new Promise<void>((resolve) => {
      core.expirer.on(EXPIRER_EVENTS.expired, (payload: any) => {
        expect(payload.target).to.eq(formatExpirerTarget("topic", topic));
        // confirm the expirer is empty again
        expect(core.expirer.length).to.eq(0);
        resolve();
      });
    });
    await disconnectSocket(core.relayer);
  });
});
</file>

<file path="packages/core/test/history.spec.ts">
import { pino, getDefaultLoggerOptions } from "@walletconnect/logger";
import { vi, expect, describe, it, beforeEach, afterEach } from "vitest";
import { calcExpiry } from "@walletconnect/utils";
import { THIRTY_DAYS, toMiliseconds } from "@walletconnect/time";
import { ICore, JsonRpcRecord } from "@walletconnect/types";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  HISTORY_STORAGE_VERSION,
  HISTORY_CONTEXT,
  HISTORY_EVENTS,
  JsonRpcHistory,
} from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";

describe("history", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
  let core: ICore;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    await core.start();
  });
  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const core = new Core(TEST_CORE_OPTIONS);
      const history = new JsonRpcHistory(core, logger);
      expect(history.storageKey).to.equal(
        CORE_STORAGE_PREFIX + HISTORY_STORAGE_VERSION + "//" + HISTORY_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const history = new JsonRpcHistory(core, logger);
      expect(history.storageKey).to.equal(
        CORE_STORAGE_PREFIX + HISTORY_STORAGE_VERSION + ":test" + "//" + HISTORY_CONTEXT,
      );
    });
  });

  it("should set a record expiry", async () => {
    expect(core.history.records.size).to.eq(0);
    const request = {
      id: 1687958477400360,
      topic: "24fd0e137c4ccc655ca9e1b9d0e2481bb3d028dc307edc62d2a5190bb081c1b9",
      jsonrpc: "2.0",
      method: "test",
      params: {
        request: {
          method: "personal_sign",
          params: [
            "0x4d7920656d61696c206973206a6f686e40646f652e636f6d202d2031363837393538343737333838",
            "0x7770471b86c6dd889a6D81DA53Fb7eeE1F9a2ba7",
          ],
        },
        chainId: "eip155:5",
      },
    };
    core.history.set(request.topic, request);
    expect(core.history.records.size).to.eq(1);
    const record = core.history.records.get(request.id);
    expect(record).to.not.be.undefined;
    expect(record?.expiry).to.not.be.undefined;
    expect(record?.expiry).to.be.greaterThan(0);
    expect(toMiliseconds(record?.expiry || 0)).to.be.approximately(
      toMiliseconds(calcExpiry(THIRTY_DAYS)),
      10,
    ); // delta ~10ms execution variance

    vi.useFakeTimers();
    vi.advanceTimersByTime(toMiliseconds(calcExpiry(THIRTY_DAYS)));
    // move time forward to force expiry and wait for heartbeat to delete the record
    await new Promise<void>((resolve) => {
      core.history.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {
        expect(record).to.not.be.undefined;
        expect(record.id).to.eq(request.id);
        resolve();
      });
    });
    vi.useRealTimers();
    expect(core.history.records.size).to.eq(0);
  });
});
</file>

<file path="packages/core/test/keychain.spec.ts">
import { expect, describe, it } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  KeyChain,
  KEYCHAIN_CONTEXT,
  KEYCHAIN_STORAGE_VERSION,
} from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Keychain", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const core = new Core(TEST_CORE_OPTIONS);
      const keychain = new KeyChain(core, logger);
      expect(keychain.storageKey).to.equal(
        CORE_STORAGE_PREFIX + KEYCHAIN_STORAGE_VERSION + "//" + KEYCHAIN_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const keychain = new KeyChain(core, logger);
      expect(keychain.storageKey).to.equal(
        CORE_STORAGE_PREFIX + KEYCHAIN_STORAGE_VERSION + ":test" + "//" + KEYCHAIN_CONTEXT,
      );
    });
  });
});
</file>

<file path="packages/core/test/messages.spec.ts">
import { expect, describe, it, beforeEach } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { generateRandomBytes32, hashMessage } from "@walletconnect/utils";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  MESSAGE_DIRECTION,
  MESSAGES_CONTEXT,
  MESSAGES_STORAGE_VERSION,
  MessageTracker,
} from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Messages", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  let messageTracker: MessageTracker;
  let topic: string;

  beforeEach(async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    messageTracker = new MessageTracker(logger, core);
    topic = generateRandomBytes32();
    await messageTracker.init();
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      expect(messageTracker.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + "//" + MESSAGES_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const messageTracker = new MessageTracker(logger, core);
      expect(messageTracker.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + ":test" + "//" + MESSAGES_CONTEXT,
      );
    });
  });

  describe("set", () => {
    it("throws if not initialized", async () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      await expect(invalidMessageTracker.set(topic, "some message")).rejects.toThrow(
        "Not initialized. messages",
      );
    });
    it("sets an entry on the messages map for a new topic-message pair", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      const key = hashMessage(mockMessage);
      const message = messageTracker.messages.get(topic) ?? {};
      expect(message[key]).to.equal(mockMessage);
      const messagesWithoutClientAck = messageTracker.messagesWithoutClientAck.get(topic) ?? {};
      expect(messagesWithoutClientAck[key]).to.equal(mockMessage);
    });
  });

  describe("get", () => {
    it("throws if not initialized", () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      expect(() => invalidMessageTracker.get(topic)).to.throw("Not initialized. messages");
    });
    it("returns an empty object for an unknown topic", () => {
      const message = messageTracker.get("fakeTopic");
      expect(message).to.deep.equal({});
    });
    it("returns the expected message based on the topic", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.get(topic)).to.deep.equal({ [hashMessage(mockMessage)]: mockMessage });
      const messagesWithoutClientAck = messageTracker.messagesWithoutClientAck.get(topic) ?? {};
      expect(messagesWithoutClientAck[hashMessage(mockMessage)]).to.equal(mockMessage);
    });
  });

  describe("has", () => {
    it("throws if not initialized", () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      expect(() => invalidMessageTracker.has(topic, "message")).to.throw(
        "Not initialized. messages",
      );
    });
    it("returns `false` by default", () => {
      expect(messageTracker.has("fakeTopic", "message")).to.be.false;
    });
    it("returns `true` if provided topic-message pair exists", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage);
      expect(messageTracker.has(topic, mockMessage)).to.be.true;
    });
  });

  describe("del", () => {
    it("throws if not initialized", async () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      await expect(invalidMessageTracker.del(topic)).rejects.toThrow("Not initialized. messages");
    });
    it("removes the matching topic-message pair for the provided topic", async () => {
      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.inbound);
      expect(messageTracker.messages.size).to.equal(1);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(1);
      await messageTracker.del(topic);
      expect(messageTracker.messages.size).to.equal(0);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
    });
  });

  describe("ack", () => {
    it("throws if not initialized", async () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      await expect(invalidMessageTracker.ack(topic, "message")).rejects.toThrow(
        "Not initialized. messages",
      );
    });
    it("removes the the topic-message pair from `messagesWithoutClientAck` when acknowledged", async () => {
      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.inbound);
      await messageTracker.ack(topic, "message");
      expect(messageTracker.messages.size).to.equal(1);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
    });

    it("doesn't store outbound messages in `messagesWithoutClientAck`", async () => {
      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.outbound);
      expect(messageTracker.messages.size).to.equal(1);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
    });

    it("doesn't throw if the topic-message pair doesn't exist", async () => {
      expect(await messageTracker.ack(topic, "message")).to.be.undefined;
    });
  });

  describe("getWithoutAck", () => {
    it("returns an empty map if no topics are provided", () => {
      expect(messageTracker.getWithoutAck([])).to.deep.equal({});
    });

    it("returns empty map if no messages are available for the provided topic", () => {
      expect(messageTracker.getWithoutAck([topic])).to.deep.equal({ [topic]: [] });
    });
    it("returns correct messages for the provided topic", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic])).to.deep.equal({
        [topic]: [mockMessage],
      });
    });
    it("returns correct messages for multiple provided topics", async () => {
      const mockMessage = "test message";
      const topic2 = generateRandomBytes32();
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic2, mockMessage, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic, topic2])).to.deep.equal({
        [topic]: [mockMessage],
        [topic2]: [mockMessage],
      });
    });
    it("returns correct messages for multiple provided topics. Test 2", async () => {
      const mockMessage = "test message";
      const mockMessage2 = "test message 2";
      const mockMessage3 = "test message 3";
      const topic2 = generateRandomBytes32();
      const topic3 = generateRandomBytes32();
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic2, mockMessage2, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic3, mockMessage3, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic2, topic3])).to.deep.equal({
        [topic2]: [mockMessage2],
        [topic3]: [mockMessage3],
      });
    });
    it("returns correct messages for multiple provided topics. Test 3", async () => {
      const mockMessage = "test message";
      const mockMessage2 = "test message 2";
      const mockMessage3 = "test message 3";
      const topic2 = generateRandomBytes32();
      const topic3 = generateRandomBytes32();
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic, mockMessage2, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic2, mockMessage3, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic, topic2, topic3])).to.deep.equal({
        [topic]: [mockMessage, mockMessage2],
        [topic2]: [mockMessage3],
        [topic3]: [],
      });
    });
  });
});
</file>

<file path="packages/core/test/pairing.spec.ts">
import { expect, describe, it, beforeEach, afterEach } from "vitest";
import { ICore } from "@walletconnect/types";
import { Core, CORE_PROTOCOL, CORE_VERSION, PAIRING_EVENTS, SUBSCRIBER_EVENTS } from "../src";
import { TEST_CORE_OPTIONS, disconnectSocket, waitForEvent } from "./shared";
import { calcExpiry, generateRandomBytes32, parseUri, toBase64 } from "@walletconnect/utils";
import { FIVE_MINUTES } from "@walletconnect/time";

const createCoreClients: () => Promise<{ coreA: ICore; coreB: ICore }> = async () => {
  const coreA = new Core(TEST_CORE_OPTIONS);
  const coreB = new Core(TEST_CORE_OPTIONS);
  await coreA.start();
  await coreB.start();
  return { coreA, coreB };
};

describe("Pairing", () => {
  let coreA: ICore;
  let coreB: ICore;

  beforeEach(async () => {
    const coreClients = await createCoreClients();
    coreA = coreClients.coreA;
    coreB = coreClients.coreB;
  });

  afterEach(async () => {
    await disconnectSocket(coreA.relayer);
    await disconnectSocket(coreB.relayer);
  });

  describe("init", () => {
    it("initializes", () => {
      expect(coreA.pairing.pairings).toBeDefined();
      expect(coreB.pairing.pairings).toBeDefined();
    });
  });

  describe("create", () => {
    it("returns the pairing topic and URI in expected format", async () => {
      const { topic, uri } = await coreA.pairing.create();
      expect(topic.length).toBe(64);
      expect(uri.startsWith(`${CORE_PROTOCOL}:${topic}@${CORE_VERSION}`)).toBe(true);
    });
  });

  describe("pair", () => {
    it("can pair via provided URI", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });
    it("can pair via base64 provided URI", async () => {
      const { uri } = await coreA.pairing.create();
      const encodedUri = toBase64(uri, true);
      await coreB.pairing.pair({ uri: encodedUri });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });

    it("can pair via provided android deeplink URI", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri: `wc://${uri}` });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });

    it("can pair via provided iOS deeplink URI", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri: `wc:${uri}` });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });

    it("can auto-activate the pairing on pair step", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri, activatePairing: true });

      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(true);
    });

    it("throws when pairing is attempted on topic that already exists", async () => {
      const { topic, uri } = await coreA.pairing.create();
      coreA.pairing.pairings.get(topic).active = true;
      await expect(coreA.pairing.pair({ uri })).rejects.toThrowError(
        `Pairing already exists: ${topic}`,
      );
    });

    it("should not override existing keychain values", async () => {
      const keychainTopic = generateRandomBytes32();
      const keychainValue = generateRandomBytes32();
      let { topic, uri } = await coreA.pairing.create();
      coreA.crypto.keychain.set(keychainTopic, keychainValue);
      uri = uri.replace(topic, keychainTopic);
      await coreA.pairing.pair({ uri });
      expect(coreA.crypto.keychain.get(keychainTopic)).toBe(keychainValue);
    });
  });

  describe("activate", () => {
    it("can activate a pairing", async () => {
      const { topic } = await coreA.pairing.create();

      const inactivePairing = coreA.pairing.pairings.get(topic);
      expect(inactivePairing.active).toBe(false);
      await coreA.pairing.activate({ topic });
      const activePairing = coreA.pairing.pairings.get(topic);
      expect(activePairing.active).toBe(true);
      // inactive pairing should have an expiry of 5 minutes
      expect(inactivePairing.expiry).to.be.approximately(calcExpiry(FIVE_MINUTES), 5);
      // active pairing should still have an expiry of 5 minutes
      expect(activePairing.expiry).to.be.approximately(calcExpiry(FIVE_MINUTES), 5);
    });
  });

  describe("updateExpiry", () => {
    it("can update a pairing's expiry", async () => {
      const mockExpiry = 11111111;
      const { topic } = await coreA.pairing.create();

      await coreA.pairing.updateExpiry({ topic, expiry: mockExpiry });
      expect(coreA.pairing.pairings.get(topic).expiry).toBe(mockExpiry);
    });
  });

  describe("updateMetadata", () => {
    it("can update a pairing's `peerMetadata`", async () => {
      const mockMetadata = {
        name: "Mock",
        description: "Mock Metadata",
        url: "https://mockurl.com",
        icons: [],
      };
      const { topic } = await coreA.pairing.create();

      expect(coreA.pairing.pairings.get(topic).peerMetadata).toBeUndefined();
      await coreA.pairing.updateMetadata({ topic, metadata: mockMetadata });
      expect(coreA.pairing.pairings.get(topic).peerMetadata).toEqual(mockMetadata);
    });
  });

  describe("formatUriFromPairing", () => {
    it("should generate pairing uri from pairing", async () => {
      let generatedUri = "";
      coreA.pairing.events.once("pairing_create", (payload) => {
        generatedUri = coreA.pairing.formatUriFromPairing(payload);
      });
      const { uri } = await coreA.pairing.create({
        methods: ["eth_sendTransaction", "personal_sign"],
      });
      expect(generatedUri).to.be.eq(uri);
      const parsedUri = parseUri(uri);
      const parsedGeneratedUri = parseUri(generatedUri);
      expect(parsedGeneratedUri).to.deep.equal(parsedUri);
    });
  });

  describe("ping", () => {
    it("clients can ping each other", async () => {
      const { uri, topic } = await coreA.pairing.create();
      let gotPing = false;

      coreB.pairing.events.on("pairing_ping", () => {
        gotPing = true;
      });

      await coreB.pairing.pair({ uri });
      await coreA.pairing.ping({ topic });
      await waitForEvent(() => gotPing);

      expect(gotPing).toBe(true);
    });
  });

  describe("disconnect", () => {
    it("can disconnect a known pairing", async () => {
      const { uri, topic } = await coreA.pairing.create();
      let hasDeleted = false;

      coreA.pairing.events.on("pairing_delete", () => {
        hasDeleted = true;
      });

      await coreB.pairing.pair({ uri });
      await coreB.pairing.disconnect({ topic });
      await waitForEvent(() => hasDeleted);

      expect(coreA.pairing.pairings.keys.length).toBe(0);
      expect(coreB.pairing.pairings.keys.length).toBe(0);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
    });
  });

  describe("validations", () => {
    describe("pair", () => {
      it("throws when no params are passed", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.pair()).rejects.toThrowError(
          "Missing or invalid. pair() params: undefined",
        );
      });

      it("throws when empty uri is provided", async () => {
        await expect(coreA.pairing.pair({ uri: "" })).rejects.toThrowError(
          "Missing or invalid. pair() uri: ",
        );
      });

      it("throws when invalid uri is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.pair({ uri: 123 })).rejects.toThrowError(
          "Missing or invalid. pair() uri: 123",
        );
      });

      it("throws when no uri is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.pair({ uri: undefined })).rejects.toThrowError(
          "Missing or invalid. pair() uri: undefined",
        );
      });
      it("throws when uri missing relay protocol is provided", async () => {
        // Using v1 pairing URI as it is unsupported
        const v1PairingUri =
          "wc:e9d6ef98-6b65-490b-8726-a21e1afb181d@1?bridge=https%3A%2F%2Fwalletconnect.com&key=73f096cb97aaee97b3d9871ced35fdce1668e652db3d39423ea6cd22e14528bf";
        await expect(
          coreA.pairing.pair({
            uri: v1PairingUri,
          }),
        ).rejects.toThrowError("Missing or invalid. pair() uri#relay-protocol");
      });
      it("throws when uri missing relay protocol is provided", async () => {
        await expect(
          coreA.pairing.pair({
            uri: "wc:e9d6ef98-6b65-490b-8726-a21e1afb181d@1?bridge=https%3A%2F%2Fwalletconnect.com&relay-protocol=irn",
          }),
        ).rejects.toThrowError("Missing or invalid. pair() uri#symKey");
      });
    });

    describe("ping", () => {
      it("throws when no params are passed", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.ping()).rejects.toThrowError(
          "Missing or invalid. ping() params: undefined",
        );
      });

      it("throws when invalid topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.ping({ topic: 123 })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: 123",
        );
      });

      it("throws when empty topic is provided", async () => {
        await expect(coreA.pairing.ping({ topic: "" })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: ",
        );
      });

      it("throws when no topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.ping({ topic: undefined })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: undefined",
        );
      });

      it("throws when non existent topic is provided", async () => {
        await expect(coreA.pairing.ping({ topic: "none" })).rejects.toThrowError(
          "No matching key. pairing topic doesn't exist: none",
        );
      });
    });

    describe("disconnect", () => {
      it("throws when no params are passed", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.disconnect()).rejects.toThrowError(
          "Missing or invalid. disconnect() params: undefined",
        );
      });

      it("throws when invalid topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.disconnect({ topic: 123 })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: 123",
        );
      });

      it("throws when empty topic is provided", async () => {
        await expect(coreA.pairing.disconnect({ topic: "" })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: ",
        );
      });

      it("throws when no topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.disconnect({ topic: undefined })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: undefined",
        );
      });

      it("throws when non existent topic is provided", async () => {
        await expect(coreA.pairing.disconnect({ topic: "none" })).rejects.toThrowError(
          "No matching key. pairing topic doesn't exist: none",
        );
      });
    });
  });
  describe("events", () => {
    it("should emit 'pairing_create' event", async () => {
      let pairingCreatedEvent = false;
      coreB.pairing.events.on(PAIRING_EVENTS.create, () => (pairingCreatedEvent = true));
      const { uri } = await coreA.pairing.create();
      coreB.pairing.pair({ uri });
      await waitForEvent(() => pairingCreatedEvent);
    });
    it("should store pairing before subscribing to its topic", async () => {
      let pairingCreatedEvent = false;
      let pairingCreatedEventTime = 0;
      let subscriptionCreatedEvent = false;
      let subscriptionCreatedEventTime = 0;
      const { uri } = await coreA.pairing.create();
      const { topic } = parseUri(uri);
      coreB.pairing.events.on(PAIRING_EVENTS.create, () => {
        pairingCreatedEventTime = performance.now();
        pairingCreatedEvent = true;
      });

      coreB.relayer.subscriber.events.on(SUBSCRIBER_EVENTS.created, () => {
        subscriptionCreatedEventTime = performance.now();
        subscriptionCreatedEvent = true;
      });

      coreB.pairing.pair({ uri });
      await waitForEvent(() => pairingCreatedEvent);
      await waitForEvent(() => subscriptionCreatedEvent);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.values[0].topic).toEqual(topic);
      expect(subscriptionCreatedEventTime).toBeGreaterThan(pairingCreatedEventTime);
    });
  });
});
</file>

<file path="packages/core/test/persistence.spec.ts">
import { expect, describe, it, beforeEach, afterEach } from "vitest";
import { ICore, IStore } from "@walletconnect/types";
import {
  MockStoreValue,
  TEST_CORE_OPTIONS,
  disconnectSocket,
  initCore,
  initStore,
  restartCore,
  searchRecords,
  storeTestValues,
  waitForEvent,
} from "./shared";
import { Core } from "../src";
import { generateRandomBytes32 } from "@walletconnect/utils";

describe("Persistence", () => {
  let core: ICore;
  let store: IStore<string, MockStoreValue>;

  beforeEach(async () => {
    core = await initCore();
  });

  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  it("should persist store values across restarts", async () => {
    store = await initStore(core);
    await restartCore();
    expect(store.getAll()).to.toMatchObject(storeTestValues);
  });

  it("should persist store values of PAIRINGS across restarts", async () => {
    // --- setup ---
    const coreA = core; // alias for clarity
    const coreB = new Core(TEST_CORE_OPTIONS);
    await coreB.start();

    // --- after restart routine ---
    const afterRestart = async () => {
      const { uri, topic } = await coreA.pairing.create();
      let hasDeleted = false;
      coreA.pairing.events.on("pairing_delete", () => {
        hasDeleted = true;
      });

      await coreB.pairing.pair({ uri });

      // pairing was created
      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);

      // topic does not exist in history
      expect(searchRecords(coreA.history.records, topic)).toBe(false);
      expect(searchRecords(coreB.history.records, topic)).toBe(false);

      // ensure that keychain is updated
      expect(coreA.crypto.keychain.keychain.has(topic)).toBe(true);
      expect(coreB.crypto.keychain.keychain.has(topic)).toBe(true);

      // ensure that expiry is updated
      expect(coreA.expirer.values.length).toBe(1);
      expect(coreB.expirer.values.length).toBe(1);

      await coreB.pairing.disconnect({ topic });

      await waitForEvent(() => hasDeleted);

      // pairing was deleted
      expect(coreA.pairing.pairings.keys.length).toBe(0);
      expect(coreB.pairing.pairings.keys.length).toBe(0);

      // topic was added to history
      expect(searchRecords(coreA.history.records, topic)).toBe(true);
      expect(searchRecords(coreB.history.records, topic)).toBe(true);

      // keychain was updated
      expect(coreA.crypto.keychain.keychain.has(topic)).toBe(false);
      expect(coreB.crypto.keychain.keychain.has(topic)).toBe(false);

      // ensure that expiry is updated
      expect(coreA.expirer.values.length).toBe(0);
      expect(coreB.expirer.values.length).toBe(0);
    };

    // start routine
    await restartCore(undefined, afterRestart);

    // final check of pairings
    expect(coreA.pairing.getPairings()).to.deep.equal(coreB.pairing.getPairings());
  });

  it("should persist store values of SESSIONS across restarts", async () => {
    // --- setup ---
    const subscriber = core.relayer.subscriber;
    const datashare = { topic: generateRandomBytes32() };

    // --- before core restarts routine ---
    const beforeRestart = async () => {
      const topic = generateRandomBytes32();
      await subscriber.subscribe(topic);
      datashare.topic = topic;
    };

    // --- after core restarts routine ---
    const afterRestart = async () => {
      // check that the session, topic were restored
      expect(subscriber.subscriptions.size).to.equal(1);
      expect(subscriber.topics).to.contain(datashare.topic);

      await subscriber.unsubscribe(datashare.topic);

      // check that the session, topic were cleared correctly
      expect(subscriber.subscriptions.size).to.equal(0);
      expect(subscriber.topics.length).to.equal(0);
    };

    // start routine
    await restartCore(beforeRestart, afterRestart);
  });
});
</file>

<file path="packages/core/test/publisher.spec.ts">
import { expect, describe, it, beforeEach, afterEach } from "vitest";
import Sinon from "sinon";
import { ICore } from "@walletconnect/types";
import { generateRandomBytes32, hashMessage } from "@walletconnect/utils";
import { Publisher } from "../src/controllers/publisher";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";

import { Core, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS, throttle } from "./shared";
import { getBigIntRpcId } from "@walletconnect/jsonrpc-utils";

const getId = () => {
  return getBigIntRpcId().toString() as any;
};

describe("Publisher", () => {
  let core: ICore;
  let publisher: Publisher;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    publisher = core.relayer.publisher as Publisher;
  });

  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  describe("init", () => {
    it("should process queue", async () => {
      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 0 };
      const items = [
        {
          topic: generateRandomBytes32(),
          message: "itemA",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemB",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemC",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemD",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemE",
          opts: { ...opts, id: getId() },
        },
      ];

      const requestSpy = Sinon.spy();
      publisher.relayer.request = requestSpy;

      // Manually set some items in the queue.
      items.forEach((item) => publisher.queue.set(item.opts.id.toString(), item));
      expect(publisher.queue.size).to.equal(items.length);
      // Emit heartbeat pulse event
      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);

      // Emit ACKs
      items.forEach((item) =>
        core.relayer.events.emit(RELAYER_EVENTS.message_ack, { id: item.opts.id }),
      );

      // -> Queue should clear after the ACKs.
      expect(publisher.queue.size).to.equal(0);
      // Emit heartbeat pulse event
      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
      await throttle(100);
      // Emit heartbeat pulse event
      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);

      // -> Queue should still be clear after the pulses.
      expect(publisher.queue.size).to.equal(0);
      // -> `request` should not have been called more times than the n items regardless of the n of pulses.
      expect(requestSpy.callCount).to.equal(items.length);
    });
    it("should process queue with delayed ACK", () => {
      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 0 };
      const items = [
        {
          topic: generateRandomBytes32(),
          message: "itemA",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemB",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemC",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemD",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemE",
          opts: { ...opts, id: getId() },
        },
      ];

      const requestSpy = Sinon.spy();
      publisher.relayer.request = requestSpy;

      // Manually set some items in the queue.
      items.forEach((item) => publisher.queue.set(item.opts.id.toString(), item));
      expect(publisher.queue.size).to.equal(items.length);

      const pulsesBeforeAck = 5;
      // emit multiple pulses to ensure queue is works correctly if ACK is delayed
      Array.from(Array(pulsesBeforeAck).keys()).forEach(async () => {
        publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
        await throttle(100);
      });

      // Emit ACKs
      items.forEach((item) =>
        core.relayer.events.emit(RELAYER_EVENTS.message_ack, { id: item.opts.id }),
      );

      // -> Queue should clear after the ACKs.
      expect(publisher.queue.size).to.equal(0);
      // -> all requests should have been sent once per pulse
      const expectedCallCount = items.length * pulsesBeforeAck;
      expect(requestSpy.callCount).to.equal(expectedCallCount);

      const pulsesAfterAck = 5;
      // emit additional pulses
      Array.from(Array(pulsesAfterAck).keys()).forEach(async () => {
        publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
        await throttle(100);
      });

      // request count should stay the same even after additional pulses
      expect(requestSpy.callCount).to.equal(expectedCallCount);
    });
  });

  describe("publish", () => {
    let topic: string;
    let requestSpy: Sinon.SinonSpy;

    beforeEach(() => {
      requestSpy = Sinon.spy();
      topic = generateRandomBytes32();
      publisher.relayer.request = requestSpy;
    });

    it("calls `provider.request` with the expected request shape", async () => {
      const message = "test message";
      const id = getId();
      await publisher.publish(topic, message, { id });
      expect(requestSpy.callCount).to.equal(1);
      expect(requestSpy.getCall(0).args[0]).to.deep.equal({
        method: "irn_publish",
        params: {
          topic,
          message,
          prompt: false,
          ttl: PUBLISHER_DEFAULT_TTL,
          tag: 0,
          attestation: undefined,
        },
        id,
      });
    });
    it("allows overriding of defaults via `opts` param", async () => {
      const message = "test message";
      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 1, id: getId(1) };
      await publisher.publish(topic, message, opts);
      expect(requestSpy.callCount).to.equal(1);
      expect(requestSpy.getCall(0).args[0]).to.deep.equal({
        method: "irn_publish",
        params: {
          topic,
          message,
          prompt: opts.prompt,
          ttl: opts.ttl,
          tag: opts.tag,
          attestation: undefined,
        },
        id: opts.id,
      });
    });
  });
});
</file>

<file path="packages/core/test/relayer.spec.ts">
import { expect, describe, it, beforeEach, afterEach, vi } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";

import {
  Core,
  CORE_DEFAULT,
  Relayer,
  RELAYER_DEFAULT_RELAY_URL,
  RELAYER_EVENTS,
  RELAYER_PROVIDER_EVENTS,
  RELAYER_SUBSCRIBER_SUFFIX,
  SUBSCRIBER_EVENTS,
  TRANSPORT_TYPES,
} from "../src";
import {
  disconnectSocket,
  TEST_MOBILE_APP_ID,
  TEST_CORE_OPTIONS,
  TEST_PROJECT_ID_MOBILE,
  throttle,
} from "./shared";
import { ICore, IRelayer, ISubscriber } from "@walletconnect/types";
import Sinon from "sinon";
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";
import { createExpiringPromise, generateRandomBytes32, hashMessage } from "@walletconnect/utils";
import * as utils from "@walletconnect/utils";

describe("Relayer", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  let core: ICore;
  let relayer: IRelayer;
  const randomTopic = generateRandomBytes32();

  describe("init", () => {
    let initSpy: Sinon.SinonSpy;
    beforeEach(async () => {
      initSpy = Sinon.spy();
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
      relayer.subscriber.topicMap.set(randomTopic, randomTopic);
    });
    afterEach(async () => {
      await disconnectSocket(relayer);
    });

    it("should not throw unhandled on network disconnect when there is no provider instance", async () => {
      relayer.messages.init = initSpy;
      relayer.subscriber.topicMap.clear();
      await relayer.init();
      expect(relayer.provider).to.be.empty;
      expect(relayer.connected).to.be.false;
      // @ts-expect-error - private property
      relayer.hasExperiencedNetworkDisruption = true;
      // @ts-expect-error - private method
      await relayer.transportDisconnect();
    });
    it("initializes a MessageTracker", async () => {
      relayer.messages.init = initSpy;
      await relayer.init();
      expect(initSpy.calledOnce).to.be.true;
    });
    it("initializes a Subscriber", async () => {
      relayer.subscriber.init = initSpy;
      await relayer.init();
      expect(initSpy.calledOnce).to.be.true;
    });
    it("initializes a Publisher", async () => {
      relayer.subscriber.init = initSpy;
      await relayer.init();
      expect(initSpy.calledOnce).to.be.true;
    });
    it("initializes a JsonRpcProvider", async () => {
      expect(relayer.provider).to.be.empty;
      await relayer.init();
      await relayer.transportOpen();
      expect(relayer.provider).not.to.be.empty;
      expect(relayer.provider instanceof JsonRpcProvider).to.be.true;
    });
    it("registers provider event listeners", async () => {
      const emitSpy = Sinon.spy();
      await relayer.init();
      await relayer.transportOpen();
      relayer.events.emit = emitSpy;
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.connect);
      expect(emitSpy.calledOnceWith(RELAYER_EVENTS.connect)).to.be.true;
    });
  });

  describe("publish", () => {
    beforeEach(async () => {
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
    });

    const topic = "abc123";
    const message = "publish me";
    it("calls `publisher.publish` with provided args", async () => {
      const spy = Sinon.spy();
      relayer.publisher.publish = spy;
      await relayer.publish(topic, message);
      expect(spy.calledOnceWith(topic, message)).to.be.true;
    });
    it("records a message with provided args", async () => {
      const spy = Sinon.spy();
      relayer.publisher.publish = () => Promise.resolve();
      relayer.messages.set = spy;
      await relayer.publish(topic, message);
      expect(spy.calledOnceWith(topic, message)).to.be.true;
    });
  });

  describe("subscribe", () => {
    beforeEach(async () => {
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
    });
    it("returns the id provided by calling `subscriber.subscribe` with the passed topic", async () => {
      const spy = Sinon.spy(
        (topic) =>
          new Promise((resolve) => {
            relayer.subscriber.events.emit(SUBSCRIBER_EVENTS.created, { topic });
            resolve(topic);
          }),
      );
      relayer.subscriber.subscribe = spy;

      const testTopic = "abc123";
      let id;
      await new Promise<void>(async (resolve) => {
        id = await relayer.subscribe(testTopic);
        resolve();
      });
      // @ts-expect-error
      expect(spy.calledOnceWith(testTopic)).to.be.true;
      expect(id).to.eq(testTopic);
    });

    it("should subscribe multiple topics", async () => {
      const spy = Sinon.spy(
        (topic) =>
          new Promise((resolve) => {
            relayer.subscriber.events.emit(SUBSCRIBER_EVENTS.created, { topic });
            resolve(topic);
          }),
      );
      relayer.subscriber.subscribe = spy;
      const subscriber = relayer.subscriber as ISubscriber;
      // record the number of listeners before subscribing
      const startNumListeners = subscriber.events.listenerCount(SUBSCRIBER_EVENTS.created);
      const topicsToSubscribe = Array.from(Array(5).keys()).map(() => generateRandomBytes32());
      const subscribePromises = topicsToSubscribe.map((topic) => relayer.subscribe(topic));
      await Promise.all([...subscribePromises]);
      // expect the number of listeners to be the same as before subscribing to confirm proper cleanup
      expect(subscriber.events.listenerCount(SUBSCRIBER_EVENTS.created)).to.eq(startNumListeners);
    });

    it("should throw when subscribe reaches a publish timeout", async () => {
      relayer.subscriber.subscribeTimeout = 5_000;
      relayer.request = () => {
        return new Promise<void>((_, reject) => {
          setTimeout(() => {
            reject(new Error("Subscription timeout"));
          }, 100_000);
        });
      };
      const topic = generateRandomBytes32();
      await expect(relayer.subscribe(topic)).rejects.toThrow(
        `Subscribing to ${topic} failed, please try again`,
      );
    });

    it("should throw when subscribe publish fails", async () => {
      await relayer.transportOpen();
      await relayer.toEstablishConnection();
      relayer.subscriber.subscribeTimeout = 5_000;
      relayer.request = () => {
        return new Promise<void>((resolve) => {
          resolve();
        });
      };
      const topic = generateRandomBytes32();
      await expect(relayer.subscribe(topic)).rejects.toThrow(
        `Subscribing to ${topic} failed, please try again`,
      );
    });

    it("should be able to resubscribe on topic that already exists", async () => {
      const topic = generateRandomBytes32();
      const id = await relayer.subscribe(topic);
      const expectedId = hashMessage(topic + (await core.crypto.getClientId()));
      const a = await relayer.subscribe(topic);
      const b = await relayer.subscribe(topic);
      const c = await relayer.subscribe(topic);
      expect(a).to.equal(id);
      expect(a).to.equal(b);
      expect(b).to.equal(c);
      expect(a).to.equal(expectedId);
      expect(b).to.equal(expectedId);
      expect(c).to.equal(expectedId);
      expect(id).to.equal(expectedId);
    });
  });

  describe("unsubscribe", () => {
    beforeEach(async () => {
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
      relayer.subscriber.topicMap.set(randomTopic, randomTopic);
      await relayer.transportOpen();
    });
    it("calls `subscriber.unsubscribe` with the passed topic", async () => {
      const spy = Sinon.spy();
      relayer.subscriber.unsubscribe = spy;
      await relayer.unsubscribe("abc123");
      expect(spy.calledOnceWith("abc123")).to.be.true;
    });

    describe("onProviderPayload", () => {
      const validPayload: JsonRpcRequest = {
        id: 123,
        jsonrpc: "2.0",
        method: "mock" + RELAYER_SUBSCRIBER_SUFFIX,
        params: {
          id: "abc123",
          data: {
            topic: "ababab",
            message: "deadbeef",
            publishedAt: 1677151760537,
            transportType: TRANSPORT_TYPES.relay,
            attestation: undefined,
          },
        },
      };

      it("does nothing if payload is not a valid JsonRpcRequest.", () => {
        const spy = Sinon.spy();
        relayer.events.emit = spy;
        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, {});
        expect(spy.notCalled).to.be.true;
      });
      it(`does nothing if payload.method does not have the ${RELAYER_SUBSCRIBER_SUFFIX} suffix`, () => {
        const spy = Sinon.spy();
        relayer.events.emit = spy;
        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, {
          ...validPayload,
          method: "mock",
        });
        expect(spy.notCalled).to.be.true;
      });
      it("emits an event based on `payload.params.id`", () => {
        const spy = Sinon.spy();
        relayer.events.emit = spy;
        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, validPayload);
        expect(
          spy.calledOnceWith(validPayload.params.id, {
            topic: validPayload.params.data.topic,
            message: validPayload.params.data.message,
            publishedAt: validPayload.params.data.publishedAt,
            transportType: validPayload.params.data.transportType,
            attestation: validPayload.params.data.attestation,
          }),
        ).to.be.true;
      });
    });
    describe("transport", () => {
      beforeEach(async () => {
        core = new Core(TEST_CORE_OPTIONS);
        relayer = core.relayer;
        await core.start();
        relayer.subscriber.subscriptions.set(randomTopic, {
          topic: randomTopic,
          id: randomTopic,
          relay: { protocol: "irn" },
        });
      });
      it("should restart transport after connection drop", async () => {
        const randomSessionIdentifier = relayer.core.crypto.randomSessionIdentifier;
        await relayer.transportOpen();
        const timeout = setTimeout(() => {
          throw new Error("Connection did not restart after disconnect");
        }, 5_001);
        await Promise.all([
          new Promise<void>((resolve) => {
            relayer.once(RELAYER_EVENTS.connect, () => {
              expect(relayer.connected).to.be.true;
              resolve();
            });
          }),
          new Promise<void>((resolve) => {
            relayer.once(RELAYER_EVENTS.disconnect, () => {
              expect(relayer.connected).to.be.false;
              resolve();
            });
          }),
          relayer.provider.connection.close(),
        ]);
        clearTimeout(timeout);
        // the identifier should be the same
        expect(relayer.core.crypto.randomSessionIdentifier).to.eq(randomSessionIdentifier);
      });
      it("should connect once regardless of the number of disconnect events", async () => {
        const disconnectsToEmit = 10;
        let disconnectsReceived = 0;
        let connectReceived = 0;
        relayer.on(RELAYER_EVENTS.connect, () => {
          connectReceived++;
        });
        relayer.on(RELAYER_EVENTS.disconnect, () => {
          disconnectsReceived++;
        });
        await Promise.all(
          Array.from(Array(disconnectsToEmit).keys()).map(() => relayer.onDisconnectHandler()),
        );
        await throttle(5_000);
        expect(connectReceived).to.eq(1);
        expect(disconnectsReceived).to.eq(disconnectsToEmit);
      });

      it("should not start wss connection on init without subscriber topics", async () => {
        relayer = new Relayer({
          core,
          relayUrl: TEST_CORE_OPTIONS.relayUrl,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        await throttle(1_000); // +1 sec buffer
        expect(relayer.connected).to.be.false;
      });

      it("should start transport on subscribe attempt", async () => {
        relayer = new Relayer({
          core,
          relayUrl: TEST_CORE_OPTIONS.relayUrl,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        expect(relayer.connected).to.be.false;
        const topic = generateRandomBytes32();
        await relayer.subscribe(topic);
        await throttle(1_000); // +1 sec buffer
        expect(relayer.connected).to.be.true;
      });
      it(`should connect to ${RELAYER_DEFAULT_RELAY_URL} relay url`, async () => {
        relayer = new Relayer({
          core,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        relayer.subscriber.subscriptions.set(randomTopic, {
          topic: randomTopic,
          id: randomTopic,
          relay: { protocol: "irn" },
        });
        await relayer.transportOpen();
        const wsConnection = relayer.provider.connection as unknown as WebSocket;
        expect(relayer.connected).to.be.true;
        expect(wsConnection.url.startsWith(RELAYER_DEFAULT_RELAY_URL)).to.be.true;
      });
      it("should not throw an error if terminate() is not available", async () => {
        const relayer = new Relayer({
          core,
          relayUrl: TEST_CORE_OPTIONS.relayUrl,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        relayer.subscriber.subscriptions.set(randomTopic, {
          topic: randomTopic,
          id: randomTopic,
          relay: { protocol: "irn" },
        });
        await relayer.transportOpen();
        expect(relayer.connected).to.be.true;
        //@ts-expect-error - private property
        relayer.provider.connection.socket.terminate = undefined;
        //@ts-expect-error - private property
        relayer.heartBeatTimeout = 1000;
        //@ts-expect-error - private method
        relayer.resetPingTimeout();
        await throttle(2000);
        await relayer.transportClose();
        expect(relayer.connected).to.be.false;
      });
    });
  });
  describe("packageName and bundleId validations", () => {
    beforeEach(async () => {
      core = new Core({ ...TEST_CORE_OPTIONS, projectId: TEST_PROJECT_ID_MOBILE });
      relayer = core.relayer;
      await core.start();
    });

    it("[Android] packageName included in Cloud Settings - should connect", async () => {
      // Mock Android environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      await relayer.subscribe(randomTopic);

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).to.include(`packageName=${TEST_MOBILE_APP_ID}`);
      expect(relayer.connected).to.be.true;
    });

    it("[Android] packageName undefined - should connect", async () => {
      // Mock Android environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue(undefined);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      await relayer.subscribe(randomTopic);

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).not.to.include("packageName=");
      expect(relayer.connected).to.be.true;
    });

    it("[Android] packageName not included in Cloud Settings - should fail", async () => {
      // Mock Android environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue("com.example.wrong");

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();

      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });

      let errorReceived = false;
      relayer.on(RELAYER_EVENTS.error, (payload) => {
        expect(payload.message).to.include("Unauthorized: origin not allowed");
        errorReceived = true;
      });
      await relayer.transportOpen().catch((e) => {});
      await throttle(1000);
      expect(errorReceived).to.be.true;
    });

    it("[iOS] bundleId included in Cloud Settings - should connect", async () => {
      // Mock iOS environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(true);
      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      await relayer.subscribe(randomTopic);

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).to.include(`bundleId=${TEST_MOBILE_APP_ID}`);
    });

    it("[iOS] bundleId undefined - should connect", async () => {
      // Mock iOS environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(true);
      vi.spyOn(utils, "getAppId").mockReturnValue(undefined);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });
      await relayer.transportOpen();

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).not.to.include("bundleId=");
      expect(relayer.connected).to.be.true;
    });

    it("[iOS] bundleId not included in Cloud Settings - should fail", async () => {
      // Mock iOS environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(true);
      vi.spyOn(utils, "getAppId").mockReturnValue("com.example.wrong");

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });

      let errorReceived = false;
      relayer.on(RELAYER_EVENTS.error, (payload) => {
        expect(payload.message).to.include("Unauthorized: origin not allowed");
        errorReceived = true;
      });

      await relayer.transportOpen().catch((e) => {});

      await throttle(1000);
      expect(errorReceived).to.be.true;
    });

    it("[Web] packageName and bundleId not set - should connect", async () => {
      // Mock non-mobile environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });
      await relayer.transportOpen();

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).not.to.include("packageName=");
      expect(wsUrl).not.to.include("bundleId=");
    });

    afterEach(() => {
      vi.restoreAllMocks();
    });
  });
});
</file>

<file path="packages/core/test/store.spec.ts">
import { expect, describe, it, beforeEach } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { Core, CORE_STORAGE_PREFIX, Store, STORE_STORAGE_VERSION } from "../src";
import { TEST_CORE_OPTIONS } from "./shared";
import { ICore, IStore, SessionTypes } from "@walletconnect/types";

const MOCK_STORE_NAME = "mock-entity";

describe("Store", () => {
  const logger = pino(getDefaultLoggerOptions({ level: "fatal" }));

  let core: ICore;
  type MockValue = { id: string; value: string };
  let store: IStore<any, any>;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    store = new Store(core, logger, MOCK_STORE_NAME);
    await store.init();
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const store = new Store(core, logger, MOCK_STORE_NAME);
      expect(store.storageKey).to.equal(
        CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + "//" + MOCK_STORE_NAME,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const store = new Store(core, logger, MOCK_STORE_NAME);
      expect(store.storageKey).to.equal(
        CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + ":test" + "//" + MOCK_STORE_NAME,
      );
    });
  });

  describe("init", () => {
    const ids = ["1", "2", "3", "foo"];
    const STORAGE_KEY = CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + "//" + MOCK_STORE_NAME;

    beforeEach(() => {
      const cachedValues = ids.map((id) => ({ id, value: "foo" }));
      core.storage.setItem(STORAGE_KEY, cachedValues);
    });

    it("retrieves from cache using getKey", async () => {
      const store = new Store<string, MockValue>(
        core,
        logger,
        MOCK_STORE_NAME,
        undefined,
        (val) => val.id,
      );
      await store.init();
      for (const id of ids) {
        expect(store.keys).includes(id);
      }
    });

    it("safely overwrites values when retrieving from cache using getKey", async () => {
      const store = new Store<string, MockValue>(
        core,
        logger,
        MOCK_STORE_NAME,
        undefined,
        (val) => val.value,
      );
      await store.init();
      expect(store.keys).to.eql(["foo"]);
    });

    it("handles null and undefined cases", async () => {
      core.storage.setItem(STORAGE_KEY, [undefined, null, { id: 1, value: "foo" }]);
      const store = new Store<string, MockValue>(
        core,
        logger,
        MOCK_STORE_NAME,
        undefined,
        (val) => val.value,
      );
      await store.init();
      expect(store.keys).to.eql(["foo"]);
    });
  });

  describe("set", () => {
    it("creates a new entry for a new key", async () => {
      const key = "newKey";
      const value = {
        topic: "abc123",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      expect(store.length).to.equal(1);
      expect(store.keys.includes(key)).to.be.true;
      expect(store.values.includes(value)).to.be.true;
    });
    it("updates an existing entry for a known key", async () => {
      const key = "key";
      const value = {
        topic: "111",
        expiry: 1000,
      } as SessionTypes.Struct;
      const updatedValue = {
        topic: "222",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      await store.set(key, updatedValue);
      expect(store.length).to.equal(1);
      expect(store.map.has(key)).to.be.true;
      expect(store.values.some((val: any) => val.topic === updatedValue.topic)).to.be.true;
    });
  });

  describe("get", () => {
    it("returns the value for a known key", async () => {
      const key = "key";
      const value = {
        topic: "abc123",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      expect(await store.get(key)).to.equal(value);
    });
    it("throws with expected error if passed an unknown key", () => {
      const unknownKey = "unknown";
      expect(() => store.get(unknownKey)).to.throw(
        `No matching key. ${MOCK_STORE_NAME}: ${unknownKey}`,
      );
    });
  });

  describe("delete", () => {
    it("removes a known key from the map", async () => {
      const key = "key";
      const value = {
        topic: "abc123",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      expect(store.length).to.equal(1);
      await store.delete(key, { code: 0, message: "reason" });
      expect(store.length).to.equal(0);
    });
    it("does nothing if key is unknown", async () => {
      await store.delete("key", { code: 0, message: "reason" });
      expect(store.length).to.equal(0);
    });
    it("should add deleted key to the recentlyDeleted list", async () => {
      const key = "key";
      const value = "value";
      await store.set(key, value);
      await store.delete(key, { code: 0, message: "reason" });
      try {
        await store.get(key);
      } catch (e) {
        expect(e.message).to.equal(
          `Missing or invalid. Record was recently deleted - mock-entity: ${key}`,
        );
      }
    });
    it("should cleanup recentlyDeleted when size limit is reached", async () => {
      //@ts-expect-error
      const itemsToDelete = store.recentlyDeletedLimit - 1;
      // populate recentlyDeleted just below the limit
      for (let i = 0; i < itemsToDelete; i++) {
        const key = `key${i}`;
        const value = `value${i}`;
        await store.set(key, value);
        await store.delete(key, { code: 0, message: "reason" });
      }
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.be.greaterThan(1);
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.equal(itemsToDelete);
      // add one more to reach the limit
      await store.set("test", "test");
      await store.delete("test", { code: 0, message: "reason" });

      // check that the recentlyDeleted list has been halved
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.be.greaterThan(1);
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.equal(store.recentlyDeletedLimit / 2);
    });
  });

  describe("getAll", () => {
    const key1 = "key1";
    const key2 = "key2";
    const value1 = { topic: "abc123", expiry: 1000, active: false };
    const value2 = { topic: "abc456", expiry: 1000, active: true };

    it("returns all values if no filter was provided", async () => {
      await store.set(key1, value1);
      await store.set(key2, value2);
      const all = store.getAll();
      expect(all.length).to.equal(2);
    });
    it("only returns values that satisfy filter", async () => {
      await store.set(key1, value1);
      await store.set(key2, value2);
      const filtered = store.getAll({ active: true });
      expect(filtered.length).to.equal(1);
      expect(filtered[0].active).to.equal(true);
    });
  });
});
</file>

<file path="packages/core/test/subscriber.spec.ts">
import { expect, describe, it, beforeEach, afterAll, afterEach } from "vitest";
import Sinon from "sinon";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { ICore, IRelayer, ISubscriber } from "@walletconnect/types";
import { generateRandomBytes32, getRelayProtocolName, hashMessage } from "@walletconnect/utils";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  MESSAGES_STORAGE_VERSION,
  RELAYER_PROVIDER_EVENTS,
  Subscriber,
  SUBSCRIBER_CONTEXT,
} from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";

describe("Subscriber", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  let relayer: IRelayer;
  let subscriber: ISubscriber;
  let core: ICore;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    relayer = core.relayer;
    subscriber = relayer.subscriber;
    subscriber.relayer.provider.request = () => Promise.resolve({} as any);
  });

  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  describe("init", () => {
    it.skip("should call batch fetch messages on init when it has cached topics", async () => {
      const requestSpy: Sinon.SinonSpy = Sinon.spy(() => {
        return Promise.resolve({} as any);
      });
      subscriber.relayer.provider.request = requestSpy;

      const topic = generateRandomBytes32();
      // manually switch off the subscriber
      // @ts-expect-error
      subscriber.onDisconnect();
      // add a topic to the subscriber as if it was loaded from persistence
      // @ts-expect-error
      subscriber.cached = [{ topic, relay: { protocol: "irn" } }];

      // restart the subscriber
      // @ts-expect-error
      subscriber.onConnect();

      await new Promise((resolve) => setTimeout(resolve, 2000));

      // first req should be the batch fetch messages call followed by the batch subscribe call
      expect(requestSpy.getCalls().length).toBe(2);
      expect(requestSpy.getCalls()[0].args[0].method).toBe("irn_batchFetchMessages");
      expect(requestSpy.getCalls()[1].args[0].method).toBe("irn_batchSubscribe");
      expect(
        requestSpy.calledWith(
          Sinon.match({
            method: "irn_batchFetchMessages",
            params: {
              topics: [topic],
            },
          }),
        ),
      ).to.be.true;

      expect(
        requestSpy.calledWith(
          Sinon.match({
            method: "irn_batchSubscribe",
            params: {
              topics: [topic],
            },
          }),
        ),
      ).to.be.true;
    });
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const subscriber = new Subscriber(relayer, logger);
      expect(subscriber.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + "//" + SUBSCRIBER_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const subscriber = new Subscriber(core.relayer, logger);
      expect(subscriber.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + ":test" + "//" + SUBSCRIBER_CONTEXT,
      );
    });
  });

  describe("init", () => {
    it("registers event listeners", async () => {
      expect(subscriber.clientId).to.equal("");

      const topic = generateRandomBytes32();
      const emitSpy = Sinon.spy();
      subscriber.events.emit = emitSpy;
      // subscribe to a topic
      await subscriber.subscribe(topic);
      expect(subscriber.subscriptions.size).to.equal(1);
      expect(subscriber.topics.length).to.equal(1);
      // relayer.provider emits a `disconnect` event -> should clear both subscriptions and topics.
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.disconnect);
      expect(subscriber.subscriptions.size).to.equal(0);
      expect(subscriber.topics.length).to.equal(0);

      expect(subscriber.clientId).to.not.equal("");
    });

    it("should set hasAnyTopics", async () => {
      const topic = generateRandomBytes32();
      expect(subscriber.hasAnyTopics).toBe(false);
      subscriber.topicMap.set(topic, topic);
      expect(subscriber.hasAnyTopics).toBe(true);
      subscriber.topicMap.clear();
      expect(subscriber.hasAnyTopics).toBe(false);
      // @ts-expect-error - private property
      subscriber.cached = [{ topic }];
      expect(subscriber.hasAnyTopics).toBe(true);
      // @ts-expect-error - private property
      subscriber.cached = [];
      expect(subscriber.hasAnyTopics).toBe(false);
      subscriber.pending.set(topic, { topic });
      expect(subscriber.hasAnyTopics).toBe(true);
      subscriber.pending.clear();
      expect(subscriber.hasAnyTopics).toBe(false);
    });
  });

  describe("subscribe", () => {
    let topic: string;
    let requestSpy: Sinon.SinonSpy;

    beforeEach(async () => {
      await relayer.connect();
      requestSpy = Sinon.spy(() => Promise.resolve(["test-id"]));
      topic = generateRandomBytes32();
      subscriber.relayer.provider.request = requestSpy;
    });

    it("throws if Subscriber was not initialized", async () => {
      const subscriber = new Subscriber(relayer, logger);
      await expect(subscriber.subscribe(topic)).rejects.toThrow("Not initialized. subscription");
    });
    it("calls `provider.request` with the expected request shape", async () => {
      await subscriber.subscribe(topic);
      expect(
        requestSpy.calledOnceWith(
          Sinon.match({
            method: "irn_subscribe",
            params: {
              topic,
            },
          }),
        ),
      ).to.be.true;
    });
    it("returns the subscription id", async () => {
      const id = await subscriber.subscribe(topic);
      const expectedId = hashMessage(topic + (await core.crypto.getClientId()));
      expect(id).to.equal(expectedId);
    });
    it("should subscribe a topic immediately after connect", async () => {
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.disconnect);
      expect(subscriber.subscriptions.size).to.equal(0);
      expect(subscriber.topics.length).to.equal(0);
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.connect);
      await relayer.subscriber.subscribe(generateRandomBytes32());
      expect(subscriber.subscriptions.size).to.equal(1);
      expect(subscriber.topics.length).to.equal(1);
    });
  });

  describe("unsubscribe", () => {
    let topic: string;
    let requestSpy: Sinon.SinonSpy;
    let messageDeleteSpy: Sinon.SinonSpy;

    beforeEach(async () => {
      await relayer.connect();
      requestSpy = Sinon.spy(() => Promise.resolve(["test-id"]));
      messageDeleteSpy = Sinon.spy();
      topic = generateRandomBytes32();
      subscriber.relayer.provider.request = requestSpy;
      subscriber.relayer.messages.del = messageDeleteSpy;
    });
    it("throws if Subscriber was not initialized", async () => {
      const subscriber = new Subscriber(relayer, logger);
      await expect(subscriber.unsubscribe(topic)).rejects.toThrow("Not initialized. subscription");
    });
    it("unsubscribes by individual id if `opts.id` is provided", async () => {
      const id = "test-id";
      await subscriber.unsubscribe(topic, { id, relay: getRelayProtocolName() });
      expect(messageDeleteSpy.calledOnceWith(topic)).to.be.true;
      expect(
        requestSpy.calledOnceWith(
          Sinon.match({
            method: "irn_unsubscribe",
            params: {
              topic,
            },
          }),
        ),
      ).to.be.true;
    });
    it("unsubscribes by topic by default", async () => {
      await subscriber.subscribe(topic);
      expect(subscriber.topics.length).to.equal(1);
      await subscriber.unsubscribe(topic);
      expect(subscriber.topics.length).to.equal(0);
      expect(
        requestSpy.getCall(1).calledWith(
          Sinon.match({
            method: "irn_unsubscribe",
            params: {
              topic,
            },
          }),
        ),
      ).to.be.true;
    });
  });
});
</file>

<file path="packages/core/test/verify.spec.ts">
import { expect, describe, it } from "vitest";
import { hashMessage } from "@walletconnect/utils";

import { Core, VERIFY_SERVER } from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";

// TODO: re-enable this suite when we have a way to provide/mock CSRF token now required by the server.
describe.skip("verify", () => {
  it("should register attestation", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();

    expect(core.expirer.length).to.eq(0);

    const POST_URL = `${VERIFY_SERVER}/attestation`;
    const attestationId = hashMessage("some");
    const origin = "localhost";

    const postResponse = await fetch(POST_URL, {
      method: "POST",
      body: JSON.stringify({ attestationId, origin }),
      headers: { "Content-Type": "application/json" },
    });

    expect(postResponse.status).toBe(200);

    const getResponse = await fetch(`${VERIFY_SERVER}/attestation/${attestationId}`);
    const result: any = await getResponse.json();

    expect(getResponse.status).toBe(200);
    expect(result.origin).toBe(origin);
    expect(result.attestationId).toBe(attestationId);

    await disconnectSocket(core.relayer);
  });
});
</file>

<file path="packages/core/.npmignore">
*.log
npm-debug.log*

# Coverage directory used by tools like istanbul
coverage
.nyc_output

# Dependency directories
node_modules

# npm package lock
package-lock.json
yarn.lock

# project files
src
test
CHANGELOG.md
.travis.yml
.editorconfig
.eslintignore
.eslintrc
.babelrc
.gitignore
.watchmanconfig
</file>

<file path="packages/core/CHANGELOG.md">
# @walletconnect/core

## 2.20.0

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.20.0
  - @walletconnect/types@2.20.0

## 2.19.4

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.19.4
  - @walletconnect/types@2.19.4

## 2.19.3

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.19.3
  - @walletconnect/types@2.19.3
</file>

<file path="packages/core/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="packages/core/package.json">
{
  "name": "@walletconnect/core",
  "description": "Core for WalletConnect Protocol",
  "version": "2.20.0",
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
  "license": "Apache-2.0",
  "main": "dist/index.cjs.js",
  "module": "dist/index.es.js",
  "unpkg": "dist/index.umd.js",
  "types": "dist/types/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "keywords": [
    "wallet",
    "walletconnect"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build:pre": "npm run clean",
    "build:types": "tsc",
    "build:source": "rollup --config rollup.config.js",
    "build": "npm run build:pre; npm run build:source; npm run build:types",
    "test:pre": "rm -rf ./test/tmp",
    "test:run": "vitest run --dir test",
    "test": "npm run test:pre; npm run test:run",
    "test:ignoreUnhandled": "npm run test:pre; npm run test:run -- --dangerouslyIgnoreUnhandledErrors",
    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
    "prettier": "prettier --check '{src,test}/**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@walletconnect/heartbeat": "1.2.2",
    "@walletconnect/jsonrpc-provider": "1.0.14",
    "@walletconnect/jsonrpc-types": "1.0.4",
    "@walletconnect/jsonrpc-utils": "1.0.8",
    "@walletconnect/jsonrpc-ws-connection": "1.0.16",
    "@walletconnect/keyvaluestorage": "1.1.1",
    "@walletconnect/logger": "2.1.2",
    "@walletconnect/relay-api": "1.0.11",
    "@walletconnect/relay-auth": "1.1.0",
    "@walletconnect/safe-json": "1.0.2",
    "@walletconnect/time": "1.0.2",
    "@walletconnect/types": "2.20.0",
    "@walletconnect/utils": "2.20.0",
    "@walletconnect/window-getters": "1.0.1",
    "es-toolkit": "1.33.0",
    "events": "3.3.0",
    "uint8arrays": "3.1.0"
  },
  "engines": {
    "node": ">=18"
  }
}
</file>

<file path="packages/core/README.md">
# @walletconnect/core

Core for WalletConnect Protocol

## License

Apache 2.0
</file>

<file path="packages/core/rollup.config.js">
import { name, dependencies } from "./package.json";
import createConfig from "../../rollup.config";

export default createConfig(name, Object.keys(dependencies));
</file>

<file path="packages/core/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["./src/**/*"],
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "./dist/types",
    "emitDeclarationOnly": true
  }
}
</file>

<file path="packages/types/src/core/core.ts">
import { IEvents } from "@walletconnect/events";
import { IHeartBeat } from "@walletconnect/heartbeat";
import { IKeyValueStorage, KeyValueStorageOptions } from "@walletconnect/keyvaluestorage";

import { ICrypto } from "./crypto";
import { IRelayer } from "./relayer";
import { IKeyChain } from "./keychain";
import { IJsonRpcHistory } from "./history";
import { IExpirer } from "./expirer";
import { IPairing } from "./pairing";
import { Logger } from "@walletconnect/logger";
import { IVerify } from "./verify";
import { IEchoClient } from "./echo";
import { IEventClient } from "./events";
export declare namespace CoreTypes {
  interface Options {
    projectId?: string;
    name?: string;
    relayUrl?: string;
    logger?: string | Logger;
    keychain?: IKeyChain;
    storage?: IKeyValueStorage;
    storageOptions?: KeyValueStorageOptions;
    maxLogBlobSizeInBytes?: number;
    customStoragePrefix?: string;
    telemetryEnabled?: boolean;
  }

  interface Metadata {
    name: string;
    description: string;
    url: string;
    icons: string[];
    verifyUrl?: string;
    redirect?: {
      native?: string;
      universal?: string;
      linkMode?: boolean;
    };
  }
}

export abstract class ICore extends IEvents {
  public readonly protocol = "wc";
  public readonly version = 2;

  public abstract readonly name: string;
  public abstract readonly context: string;
  public abstract readonly relayUrl?: string;
  public abstract readonly projectId?: string;
  public abstract readonly customStoragePrefix: string;

  public abstract logger: Logger;
  public abstract heartbeat: IHeartBeat;
  public abstract crypto: ICrypto;
  public abstract relayer: IRelayer;
  public abstract storage: IKeyValueStorage;
  public abstract history: IJsonRpcHistory;
  public abstract expirer: IExpirer;
  public abstract pairing: IPairing;
  public abstract verify: IVerify;
  public abstract echoClient: IEchoClient;
  public abstract linkModeSupportedApps: string[];
  public abstract eventClient: IEventClient;

  constructor(public opts?: CoreTypes.Options) {
    super();
  }

  public abstract start(): Promise<void>;
  public abstract dispatchEnvelope(params: {
    topic: string;
    message: string;
    sessionExists: boolean;
  }): void;

  public abstract addLinkModeSupportedApp(universalLink: string): void;
}
</file>

<file path="packages/types/src/core/crypto.ts">
import { JsonRpcPayload } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";
import { IKeyChain } from "./keychain";

export declare namespace CryptoTypes {
  export type EncodingType = "base64pad" | "base64url";

  export interface Participant {
    publicKey: string;
  }

  export interface KeyPair {
    privateKey: string;
    publicKey: string;
  }

  export interface EncryptParams {
    message: string;
    symKey: string;
    type?: number;
    iv?: string;
    senderPublicKey?: string;
    encoding?: EncodingType;
  }

  export interface DecryptParams {
    symKey: string;
    encoded: string;
    encoding?: EncodingType;
  }

  export interface EncodingParams {
    type: Uint8Array;
    sealed: Uint8Array;
    iv: Uint8Array;
    senderPublicKey?: Uint8Array;
    encoding?: EncodingType;
  }

  export interface DecodingParams {
    encoded: string;
    encoding?: EncodingType;
  }

  export interface EncodeOptions {
    type?: number;
    senderPublicKey?: string;
    receiverPublicKey?: string;
    encoding?: EncodingType;
  }

  export interface DecodeOptions {
    receiverPublicKey?: string;
    encoding?: EncodingType;
  }

  export interface EncodingValidation {
    type: number;
    senderPublicKey?: string;
    receiverPublicKey?: string;
  }

  export interface TypeOneParams {
    type: 1;
    senderPublicKey: string;
    receiverPublicKey: string;
  }
}

export abstract class ICrypto {
  public abstract name: string;

  public abstract readonly context: string;

  public abstract keychain: IKeyChain;

  public abstract readonly randomSessionIdentifier: string;

  constructor(
    public core: ICore,
    public logger: Logger,
    // @ts-ignore
    keychain?: IKeyChain,
  ) {}

  public abstract init(): Promise<void>;

  public abstract hasKeys(tag: string): boolean;

  public abstract getClientId(): Promise<string>;

  public abstract generateKeyPair(): Promise<string>;

  public abstract generateSharedKey(
    selfPublicKey: string,
    peerPublicKey: string,
    overrideTopic?: string,
  ): Promise<string>;

  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;

  public abstract deleteKeyPair(publicKey: string): Promise<void>;

  public abstract deleteSymKey(topic: string): Promise<void>;

  public abstract encode(
    topic: string,
    payload: JsonRpcPayload,
    opts?: CryptoTypes.EncodeOptions,
  ): Promise<string>;

  public abstract decode(
    topic: string,
    encoded: string,
    opts?: CryptoTypes.DecodeOptions,
  ): Promise<JsonRpcPayload>;

  public abstract signJWT(aud: string): Promise<string>;
  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;
  public abstract getPayloadSenderPublicKey(
    encoded: string,
    encoding?: CryptoTypes.EncodingType,
  ): string | undefined;
}
</file>

<file path="packages/types/src/core/echo.ts">
import { Logger } from "@walletconnect/logger";

export declare namespace EchoClientTypes {
  type RegisterDeviceTokenParams = {
    clientId: string;
    token: string;
    notificationType: "fcm" | "apns" | "apns-sandbox" | "noop";
    enableEncrypted?: boolean;
  };
}
export abstract class IEchoClient {
  public abstract readonly context: string;
  constructor(
    public projectId: string,
    public logger: Logger,
  ) {}

  public abstract registerDeviceToken(
    params: EchoClientTypes.RegisterDeviceTokenParams,
  ): Promise<void>;
}
</file>

<file path="packages/types/src/core/events.ts">
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export declare namespace EventClientTypes {
  export interface Event {
    eventId: string;
    bundleId: string;
    timestamp: number;
    props: Props;
    addTrace: (trace: string) => void;
    setError: (error: string) => void;
  }

  export interface Props {
    event: string;
    type: string;
    properties: Properties;
  }

  export interface Properties {
    topic: string;
    trace: Trace;
  }

  export type Trace = string[];
}

export abstract class IEventClient {
  public abstract readonly context: string;

  constructor(
    public core: ICore,
    public logger: Logger,
    public telemetryEnabled: boolean,
  ) {}

  public abstract init(): Promise<void>;

  public abstract createEvent(params: {
    event?: "ERROR";
    type?: string;
    properties: {
      topic: string;
      trace: EventClientTypes.Trace;
    };
  }): EventClientTypes.Event;

  public abstract getEvent(params: {
    eventId?: string;
    topic?: string;
  }): EventClientTypes.Event | undefined;

  public abstract deleteEvent(params: { eventId: string }): void;
}
</file>

<file path="packages/types/src/core/expirer.ts">
import { IEvents } from "@walletconnect/events";
import { Logger } from "@walletconnect/logger";

import { ICore } from "./core";

export declare namespace ExpirerTypes {
  interface Expiration {
    target: string;
    expiry: number;
  }

  interface Created {
    target: string;
    expiration: Expiration;
  }

  interface Deleted {
    target: string;
    expiration: Expiration;
  }

  interface Expired {
    target: string;
    expiration: Expiration;
  }
}

export abstract class IExpirer extends IEvents {
  public abstract name: string;

  public abstract readonly context: string;

  public abstract readonly length: number;

  public abstract readonly keys: string[];

  public abstract readonly values: ExpirerTypes.Expiration[];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract has(key: string | number): boolean;

  public abstract set(key: string | number, expiry: number): void;

  public abstract get(key: string | number): ExpirerTypes.Expiration;

  public abstract del(key: string | number): void;
}
</file>

<file path="packages/types/src/core/history.ts">
import { IEvents } from "@walletconnect/events";
import {
  ErrorResponse,
  JsonRpcRequest,
  JsonRpcResponse,
  RequestArguments,
} from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";

import { ICore } from "./core";

export interface JsonRpcRecord {
  id: number;
  topic: string;
  request: RequestArguments;
  chainId?: string;
  response?: { result: any } | { error: ErrorResponse };
  expiry?: number;
}

export interface RequestEvent {
  topic: string;
  request: JsonRpcRequest;
  chainId?: string;
}

export abstract class IJsonRpcHistory extends IEvents {
  public records = new Map<number, JsonRpcRecord>();

  public abstract readonly context: string;

  public abstract readonly size: number;

  public abstract readonly keys: number[];

  public abstract readonly values: JsonRpcRecord[];

  public abstract readonly pending: RequestEvent[];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;

  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;

  public abstract resolve(response: JsonRpcResponse): Promise<void>;

  public abstract delete(topic: string, id?: number): void;

  public abstract exists(topic: string, id: number): Promise<boolean>;
}
</file>

<file path="packages/types/src/core/index.ts">
export * from "./core";
export * from "./crypto";
export * from "./history";
export * from "./messages";
export * from "./publisher";
export * from "./relayer";
export * from "./store";
export * from "./subscriber";
export * from "./keychain";
export * from "./expirer";
export * from "./pairing";
export * from "./verify";
export * from "./echo";
export * from "./events";
</file>

<file path="packages/types/src/core/keychain.ts">
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export abstract class IKeyChain {
  public abstract keychain: Map<string, string>;

  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {}

  public abstract init(): Promise<void>;

  public abstract has(tag: string, opts?: any): boolean;

  public abstract set(tag: string, key: string, opts?: any): Promise<void>;

  public abstract get(tag: string, opts?: any): string;

  public abstract del(tag: string, opts?: any): Promise<void>;
}
</file>

<file path="packages/types/src/core/messages.ts">
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export type MessageRecord = Record<string, string>;

export abstract class IMessageTracker {
  public abstract messages: Map<string, MessageRecord>;
  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;

  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public logger: Logger,
    public core: ICore,
  ) {}

  public abstract init(): Promise<void>;

  public abstract set(
    topic: string,
    message: string,
    direction?: "inbound" | "outbound",
  ): Promise<string>;

  public abstract get(topic: string): MessageRecord;

  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;

  public abstract has(topic: string, message: string): boolean;

  public abstract del(topic: string): Promise<void>;

  public abstract ack(topic: string, message: string): Promise<void>;
}
</file>

<file path="packages/types/src/core/pairing.ts">
import {
  ErrorResponse,
  JsonRpcRequest,
  JsonRpcResponse,
  JsonRpcResult,
  JsonRpcError,
} from "@walletconnect/jsonrpc-types";
import EventEmitter from "events";

import { ICore, CoreTypes } from "./core";
import { IStore } from "./store";

import { RelayerTypes } from "../core/relayer";
import { Logger } from "@walletconnect/logger";

export declare namespace PairingTypes {
  interface Struct {
    topic: string;
    expiry: number;
    relay: RelayerTypes.ProtocolOptions;
    active: boolean;
    peerMetadata?: CoreTypes.Metadata;
    methods?: string[];
  }
}

export declare namespace PairingJsonRpcTypes {
  // -- core ------------------------------------------------------- //
  type DefaultResponse = true | ErrorResponse;

  type WcMethod = "wc_pairingDelete" | "wc_pairingPing";

  type Error = ErrorResponse;

  // -- requests --------------------------------------------------- //

  interface RequestParams {
    wc_pairingDelete: {
      code: number;
      message: string;
    };
    wc_pairingPing: Record<string, unknown>;
  }

  // -- responses -------------------------------------------------- //
  interface Results {
    wc_pairingDelete: true;
    wc_pairingPing: true;
  }

  // -- events ----------------------------------------------------- //
  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
    topic: string;
    payload: T;
  }
}

export type IPairingStore = IStore<string, PairingTypes.Struct>;

export abstract class IPairing {
  public abstract name: string;
  public abstract readonly context: string;
  public abstract events: EventEmitter;
  public abstract pairings: IPairingStore;

  constructor(
    public logger: Logger,
    public core: ICore,
  ) {}

  public abstract init(): Promise<void>;

  public abstract pair(params: {
    uri: string;
    activatePairing?: boolean;
  }): Promise<PairingTypes.Struct>;

  // for proposer to create inactive pairing
  public abstract create(params?: {
    methods?: string[];
    transportType?: RelayerTypes.SubscribeOptions["transportType"];
  }): Promise<{ topic: string; uri: string }>;

  // for either to activate a previously created pairing
  public abstract activate(params: { topic: string }): Promise<void>;

  // for both to subscribe on methods requests
  public abstract register(params: { methods: string[] }): void;

  // for either to update the expiry of an existing pairing.
  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;

  // for either to update the metadata of an existing pairing.
  public abstract updateMetadata(params: {
    topic: string;
    metadata: CoreTypes.Metadata;
  }): Promise<void>;

  // query pairings
  public abstract getPairings(): PairingTypes.Struct[];

  // for either to ping a peer
  public abstract ping(params: { topic: string }): Promise<void>;

  // for either peer to disconnect a pairing
  public abstract disconnect(params: { topic: string }): Promise<void>;

  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;
}

export interface IPairingPrivate {
  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(
    topic: string,
    method: M,
    params: PairingJsonRpcTypes.RequestParams[M],
  ): Promise<number>;

  sendResult<M extends PairingJsonRpcTypes.WcMethod>(
    id: number,
    topic: string,
    result: PairingJsonRpcTypes.Results[M],
  ): Promise<void>;

  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;

  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;

  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;

  onPairingPingRequest(
    topic: string,
    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams["wc_pairingPing"]>,
  ): Promise<void>;

  onPairingPingResponse(
    topic: string,
    payload: JsonRpcResult<PairingJsonRpcTypes.Results["wc_pairingPing"]> | JsonRpcError,
  ): void;

  onPairingDeleteRequest(
    topic: string,
    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams["wc_pairingDelete"]>,
  ): Promise<void>;

  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;

  onUnknownRpcMethodResponse(method: string): void;

  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;
}
</file>

<file path="packages/types/src/core/publisher.ts">
import { IEvents } from "@walletconnect/events";
import { Logger } from "@walletconnect/logger";

import { IRelayer, RelayerTypes } from "./relayer";

export declare namespace PublisherTypes {
  export interface Params {
    topic: string;
    message: string;
    opts: Omit<RelayerTypes.PublishOptions, "internal">;
  }
}

export abstract class IPublisher extends IEvents {
  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super();
  }

  public abstract publish(
    topic: string,
    message: string,
    opts?: RelayerTypes.PublishOptions,
  ): Promise<void>;
}
</file>

<file path="packages/types/src/core/relayer.ts">
import { IEvents } from "@walletconnect/events";
import { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";

import { ICore } from "./core";
import { IMessageTracker } from "./messages";
import { IPublisher } from "./publisher";
import { ISubscriber } from "./subscriber";

export declare namespace RelayerTypes {
  export interface ProtocolOptions {
    protocol: string;
    data?: string;
  }
  export interface PublishOptions {
    relay?: ProtocolOptions;
    ttl?: number;
    prompt?: boolean;
    tag?: number;
    id?: number;
    internal?: {
      throwOnFailedPublish?: boolean;
    };
    tvf?: ITVF;
    attestation?: string;
  }

  export type TransportType = "relay" | "link_mode";

  export interface SubscribeOptions {
    relay?: ProtocolOptions;
    transportType?: TransportType;
    internal?: {
      throwOnFailedPublish?: boolean;
    };
  }

  export interface UnsubscribeOptions {
    id?: string;
    relay: ProtocolOptions;
  }

  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;

  export interface PublishPayload {
    topic: string;
    message: string;
    opts?: RelayerTypes.PublishOptions;
  }
  export interface MessageEvent {
    topic: string;
    message: string;
    publishedAt: number;
    transportType?: TransportType;
    attestation?: string;
  }

  export interface RpcUrlParams {
    protocol: string;
    version: number;
    auth: string;
    relayUrl: string;
    sdkVersion: string;
    projectId?: string;
    useOnCloseEvent?: boolean;
    bundleId?: string;
    packageName?: string;
  }

  export interface ITVF {
    correlationId?: number;
    rpcMethods?: string[];
    chainId?: string;
    txHashes?: string[];
    contractAddresses?: string[];
  }

  export type MessageDirection = "inbound" | "outbound";
}

export interface RelayerOptions {
  core: ICore;
  logger?: string | Logger;
  relayUrl?: string;
  projectId?: string;
}

export interface RelayerClientMetadata {
  protocol: string;
  version: number;
  env: string;
  host?: string;
}

export abstract class IRelayer extends IEvents {
  public abstract protocol: string;

  public abstract version: number;

  public abstract core: ICore;

  public abstract logger: Logger;

  public abstract subscriber: ISubscriber;

  public abstract publisher: IPublisher;

  public abstract messages: IMessageTracker;

  public abstract provider: IJsonRpcProvider;

  public abstract name: string;

  public abstract transportExplicitlyClosed: boolean;

  public abstract readonly context: string;

  public abstract readonly connected: boolean;

  public abstract readonly connecting: boolean;

  constructor(
    // @ts-ignore
    opts: RelayerOptions,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract publish(
    topic: string,
    message: string,
    opts?: RelayerTypes.PublishOptions,
  ): Promise<void>;

  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;

  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;

  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;
  public abstract transportClose(): Promise<void>;
  public abstract transportOpen(relayUrl?: string): Promise<void>;
  public abstract restartTransport(relayUrl?: string): Promise<void>;
  public abstract confirmOnlineStateOrThrow(): Promise<void>;
  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;
  public abstract onLinkMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
    opts?: { sessionExists?: boolean },
  ): Promise<void>;
}
</file>

<file path="packages/types/src/core/store.ts">
import { ErrorResponse } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export abstract class IStore<Key, Value> {
  public abstract map: Map<Key, Value>;

  public abstract readonly context: string;

  public abstract readonly length: number;

  public abstract readonly keys: Key[];

  public abstract readonly values: Value[];

  constructor(
    public core: ICore,
    public logger: Logger,
    public name: string,
    // @ts-ignore
    storagePrefix?: string,
  ) {}

  public abstract init(): Promise<void>;

  public abstract set(key: Key, value: Value): Promise<void>;

  public abstract get(key: Key): Value;

  public abstract getAll(filter?: Partial<Value>): Value[];

  public abstract update(key: Key, update: Partial<Value>): Promise<void>;

  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;
}
</file>

<file path="packages/types/src/core/subscriber.ts">
import { IEvents } from "@walletconnect/events";
import { ErrorResponse } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";

import { IRelayer, RelayerTypes } from "./relayer";

export declare namespace SubscriberTypes {
  export interface Params extends RelayerTypes.SubscribeOptions {
    topic: string;
  }

  export interface Active extends Params {
    id: string;
  }
}

export declare namespace SubscriberEvents {
  export type Created = SubscriberTypes.Active;

  export interface Deleted extends SubscriberTypes.Active {
    reason: ErrorResponse;
  }

  export type Expired = Deleted;
}

export abstract class ISubscriberTopicMap {
  public map = new Map<string, string[]>();

  public abstract readonly topics: string[];

  public abstract set(topic: string, id: string): void;

  public abstract get(topic: string): string[];

  public abstract exists(topic: string, id: string): boolean;

  public abstract delete(topic: string, id?: string): void;

  public abstract clear(): void;
}

export abstract class ISubscriber extends IEvents {
  public abstract subscriptions: Map<string, SubscriberTypes.Active>;

  public abstract topicMap: ISubscriberTopicMap;

  public abstract pending: Map<string, SubscriberTypes.Params>;

  public abstract readonly length: number;

  public abstract readonly ids: string[];

  public abstract readonly values: SubscriberTypes.Active[];

  public abstract readonly topics: string[];

  public abstract readonly hasAnyTopics: boolean;

  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract subscribe(
    topic: string,
    opts?: RelayerTypes.SubscribeOptions,
  ): Promise<string | null>;

  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;

  public abstract isSubscribed(topic: string): Promise<boolean>;

  public abstract isKnownTopic(topic: string): Promise<boolean>;

  public abstract start(): Promise<void>;

  public abstract stop(): Promise<void>;
}
</file>

<file path="packages/types/src/core/verify.ts">
import { Logger } from "@walletconnect/logger";
import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";
import { ICore } from "./core";

export declare namespace Verify {
  export interface Context {
    verified: {
      origin: string;
      validation: "UNKNOWN" | "VALID" | "INVALID";
      verifyUrl: string;
      isScam?: boolean;
    };
  }
}

export abstract class IVerify {
  public abstract readonly context: string;

  constructor(
    public core: ICore,
    public logger: Logger,
    public store: IKeyValueStorage,
  ) {}

  public abstract register(params: {
    id: string;
    decryptedId: string;
  }): Promise<string | undefined>;

  public abstract resolve(params: {
    attestationId?: string;
    hash?: string;
    encryptedId?: string;
    verifyUrl?: string;
  }): Promise<{ origin: string; isScam?: boolean }>;
}
</file>

<file path="packages/types/src/sign-client/auth.ts">
import {
  ErrorResponse,
  JsonRpcError,
  JsonRpcRequest,
  JsonRpcResponse,
  JsonRpcResult,
} from "@walletconnect/jsonrpc-types";
import { CoreTypes, ICore, IStore, RelayerTypes, Verify } from "../core";
import { SessionTypes } from "./session";

export declare namespace AuthTypes {
  type Event = "session_authenticate";

  interface AuthRequestEventArgs {
    requester: Participant;
    authPayload: PayloadParams;
    expiryTimestamp: number;
    transportType?: RelayerTypes.TransportType;
  }

  type AuthResponseEventArgs =
    | { message: string; code: number }
    | JsonRpcResult<Cacao>
    | JsonRpcError;

  interface BaseEventArgs<T = unknown> {
    id: number;
    topic: string;
    params: T;
    verifyContext?: Verify.Context;
  }

  interface EventArguments {
    auth_request: BaseEventArgs<AuthRequestEventArgs>;
    auth_response: BaseEventArgs<AuthResponseEventArgs>;
    sign_request: BaseEventArgs<{
      request: { method: string; params: any };
      chainId: string;
    }>;
    sign_response: BaseEventArgs<JsonRpcResult | JsonRpcError>;
  }

  interface Options extends CoreTypes.Options {
    metadata: Metadata;
    core?: ICore;
    projectId: string;
  }

  interface Metadata {
    name: string;
    description: string;
    url: string;
    icons: string[];
    redirect?: {
      native?: string;
      universal?: string;
      linkMode?: boolean;
    };
    verifyUrl?: string;
  }

  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
    topic: string;
    payload: T;
  }

  /**
   * `aud` is used in protocol request
   * `uri` is more descriptive and is used in client APIs
   * formatMessageParams should accept either `aud` or `uri` as a parameter to construct the message
   */
  type FormatMessageParams = {
    aud?: string;
    uri?: string;
  } & Omit<BaseAuthRequestParams, "aud" | "chainId">;

  interface BaseAuthRequestParams {
    domain: string;
    aud: string;
    nonce: string;
    version?: string;
    iat?: string;
    nbf?: string;
    exp?: string;
    chainId?: string;
    statement?: string;
    requestId?: string;
    resources?: string[];
    expiry?: number;
    type?: string;
  }

  // https://github.com/ChainAgnostic/CAIPs/pull/74
  type RequestParams = {
    chains: string[];
  } & BaseAuthRequestParams;

  type SessionAuthenticateParams = {
    pairingTopic?: string;
    methods?: string[];
    uri: string;
  } & Omit<RequestParams, "aud">;

  type PayloadParams = {
    version: string;
    iat: string;
  } & RequestParams;

  type CacaoPayload = {
    iss: string;
  } & BaseAuthRequestParams;

  interface CacaoHeader {
    t: "caip122";
  }

  interface CacaoSignature {
    t: "eip191" | "eip1271";
    s: string;
    m?: string;
  }

  interface Cacao {
    h: CacaoHeader;
    p: CacaoPayload;
    s: CacaoSignature;
  }

  interface PendingRequest {
    id: number;
    pairingTopic: string;
    requester: Participant;
    expiryTimestamp: number;
    authPayload: PayloadParams;
    verifyContext: Verify.Context;
    transportType?: RelayerTypes.TransportType;
  }

  interface ApproveSessionAuthenticateParams {
    id: number;
    auths: Cacao[];
  }

  interface SessionAuthenticateResponseParams {
    responder: Participant;
    cacaos: Cacao[];
  }

  interface AuthErrorResponse {
    id: number;
    error: ErrorResponse;
  }

  type AuthResponse = SessionAuthenticateResponseParams["cacaos"];

  interface Participant {
    publicKey: string;
    metadata: Metadata;
  }

  interface SessionAuthenticateRequestParams {
    requester: Participant;
    authPayload: PayloadParams;
    expiryTimestamp: number;
  }

  interface SessionAuthenticateRequest extends SessionAuthenticateRequestParams {
    verifyContext: Verify.Context;
  }

  type AuthenticateResponseResult = {
    auths?: AuthTypes.AuthResponse;
    session: SessionTypes.Struct;
  };
}

export type IAuth = {
  init(): Promise<void>;
  authKeys: IStore<string, { responseTopic: string; publicKey: string }>;
  pairingTopics: IStore<string, { topic: string; pairingTopic: string }>;
  requests: IStore<number, AuthTypes.PendingRequest>;
};
</file>

<file path="packages/types/src/sign-client/client.ts">
import { Logger } from "@walletconnect/logger";
import EventEmmiter from "events";
import { CoreTypes, ICore } from "../core/core";
import { IEngine } from "./engine";
import { IPendingRequest } from "./pendingRequest";
import { IProposal, ProposalTypes } from "./proposal";
import { ISession, SessionTypes } from "./session";
import { Verify } from "../core/verify";
import { IAuth, AuthTypes } from "./auth";
import { RelayerTypes } from "../core";

export declare namespace SignClientTypes {
  type Event =
    | "session_proposal"
    | "session_update"
    | "session_extend"
    | "session_ping"
    | "session_delete"
    | "session_expire"
    | "session_request"
    | "session_request_sent"
    | "session_event"
    | "session_authenticate"
    | "proposal_expire"
    | "session_request_expire"
    | "session_connect";

  interface BaseEventArgs<T = unknown> {
    id: number;
    topic: string;
    params: T;
  }
  interface EventArguments {
    session_proposal: {
      verifyContext: Verify.Context;
    } & Omit<BaseEventArgs<ProposalTypes.Struct>, "topic">;
    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;
    session_extend: Omit<BaseEventArgs, "params">;
    session_ping: Omit<BaseEventArgs, "params">;
    session_delete: Omit<BaseEventArgs, "params">;
    session_expire: { topic: string };
    session_request: {
      verifyContext: Verify.Context;
    } & BaseEventArgs<{
      request: { method: string; params: any; expiryTimestamp?: number };
      chainId: string;
    }>;
    session_request_sent: {
      request: { method: string; params: any };
      topic: string;
      chainId: string;
      id: number;
    };
    session_event: BaseEventArgs<{
      event: { name: string; data: any };
      chainId: string;
    }>;
    session_authenticate: {
      verifyContext: Verify.Context;
      transportType?: RelayerTypes.TransportType;
    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;
    proposal_expire: { id: number };
    session_request_expire: { id: number };
    session_connect: { session: SessionTypes.Struct };
  }

  type Metadata = CoreTypes.Metadata;

  type SignConfig = {
    disableRequestQueue?: boolean;
  };

  interface Options extends CoreTypes.Options {
    core?: ICore;
    metadata?: Metadata;
    signConfig?: SignConfig;
  }
}

export abstract class ISignClientEvents extends EventEmmiter {
  constructor() {
    super();
  }

  public abstract emit: <E extends SignClientTypes.Event>(
    event: E,
    args: SignClientTypes.EventArguments[E],
  ) => boolean;

  public abstract on: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract once: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract off: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract removeListener: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;
}

export abstract class ISignClient {
  public readonly protocol = "wc";
  public readonly version = 2;

  public abstract readonly name: string;
  public abstract readonly context: string;
  public abstract readonly metadata: SignClientTypes.Metadata;

  public abstract core: ICore;
  public abstract logger: Logger;
  public abstract events: ISignClientEvents;
  public abstract engine: IEngine;
  public abstract session: ISession;
  public abstract proposal: IProposal;
  public abstract pendingRequest: IPendingRequest;
  public abstract auth: IAuth;
  public abstract signConfig?: SignClientTypes.SignConfig;

  constructor(public opts?: SignClientTypes.Options) {}

  public abstract connect: IEngine["connect"];
  public abstract pair: IEngine["pair"];
  public abstract approve: IEngine["approve"];
  public abstract reject: IEngine["reject"];
  public abstract update: IEngine["update"];
  public abstract extend: IEngine["extend"];
  public abstract request: IEngine["request"];
  public abstract respond: IEngine["respond"];
  public abstract ping: IEngine["ping"];
  public abstract emit: IEngine["emit"];
  public abstract disconnect: IEngine["disconnect"];
  public abstract find: IEngine["find"];
  public abstract getPendingSessionRequests: IEngine["getPendingSessionRequests"];
  public abstract authenticate: IEngine["authenticate"];
  public abstract formatAuthMessage: IEngine["formatAuthMessage"];
  public abstract approveSessionAuthenticate: IEngine["approveSessionAuthenticate"];
  public abstract rejectSessionAuthenticate: IEngine["rejectSessionAuthenticate"];
}
</file>

<file path="packages/types/src/sign-client/engine.ts">
import {
  JsonRpcResponse,
  JsonRpcRequest,
  ErrorResponse,
  JsonRpcResult,
  JsonRpcError,
} from "@walletconnect/jsonrpc-types";
import { ISignClient } from "./client";
import { RelayerTypes } from "../core/relayer";
import { SessionTypes } from "./session";
import { ProposalTypes } from "./proposal";
import { PairingTypes } from "../core/pairing";
import { JsonRpcTypes } from "./jsonrpc";
import { EventEmitter } from "events";
import { PendingRequestTypes } from "./pendingRequest";
import { AuthTypes } from "./auth";
import { CryptoTypes } from "../core";

export declare namespace EngineTypes {
  type Event =
    | "session_connect"
    | "session_approve"
    | "session_update"
    | "session_extend"
    | "session_ping"
    | "pairing_ping"
    | "session_request";

  interface EventArguments {
    session_connect: {
      error?: ErrorResponse;
      session?: SessionTypes.Struct;
    };
    session_approve: { error?: ErrorResponse };
    session_update: { error?: ErrorResponse };
    session_extend: { error?: ErrorResponse };
    session_ping: { error?: ErrorResponse };
    pairing_ping: { error?: ErrorResponse };
    session_request: { error?: ErrorResponse; result?: any };
  }

  interface UriParameters {
    protocol: string;
    version: number;
    topic: string;
    symKey: string;
    relay: RelayerTypes.ProtocolOptions;
    methods?: string[];
    expiryTimestamp?: number;
  }

  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
    topic: string;
    payload: T;
    transportType?: RelayerTypes.MessageEvent["transportType"];
    attestation?: string;
    encryptedId?: string;
  }

  interface ConnectParams {
    requiredNamespaces?: ProposalTypes.RequiredNamespaces;
    optionalNamespaces?: ProposalTypes.OptionalNamespaces;
    sessionProperties?: ProposalTypes.SessionProperties;
    scopedProperties?: ProposalTypes.ScopedProperties;
    pairingTopic?: string;
    relays?: RelayerTypes.ProtocolOptions[];
  }

  interface PairParams {
    uri: string;
  }

  interface ApproveParams {
    id: number;
    namespaces: SessionTypes.Namespaces;
    sessionProperties?: ProposalTypes.SessionProperties;
    scopedProperties?: ProposalTypes.ScopedProperties;
    sessionConfig?: SessionTypes.SessionConfig;
    relayProtocol?: string;
  }

  interface RejectParams {
    id: number;
    reason: ErrorResponse;
  }

  interface UpdateParams {
    topic: string;
    namespaces: SessionTypes.Namespaces;
  }

  interface ExtendParams {
    topic: string;
  }

  interface RequestParams {
    topic: string;
    request: {
      method: string;
      params: any;
    };
    chainId: string;
    expiry?: number;
  }

  interface RespondParams {
    topic: string;
    response: JsonRpcResponse;
  }

  interface EmitParams {
    topic: string;
    event: {
      name: string;
      data: any;
    };
    chainId: string;
  }

  interface PingParams {
    topic: string;
  }

  interface DisconnectParams {
    topic: string;
    reason: ErrorResponse;
  }

  interface FindParams {
    requiredNamespaces: ProposalTypes.RequiredNamespaces;
  }

  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;

  type SessionAuthenticateResponsePromise = {
    uri: string;
    response: () => Promise<AuthTypes.AuthenticateResponseResult>;
  };

  interface RpcOpts {
    req: RelayerTypes.PublishOptions & {
      ttl: number;
    };
    res: RelayerTypes.PublishOptions & {
      ttl: number;
    };
    reject?: RelayerTypes.PublishOptions & {
      ttl: number;
    };
    autoReject?: RelayerTypes.PublishOptions & {
      ttl: number;
    };
  }

  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;

  type EngineQueue<T> = {
    state: "IDLE" | "ACTIVE";
    queue: T[];
  };
}

export abstract class IEngineEvents extends EventEmitter {
  constructor() {
    super();
  }

  public abstract emit: <E extends EngineTypes.Event>(
    event: string,
    args: EngineTypes.EventArguments[E],
  ) => boolean;

  public abstract once: <E extends EngineTypes.Event>(
    event: string,
    listener: (args: EngineTypes.EventArguments[E]) => any,
  ) => this;
}

// -- private method interface -------------------------------------- //

export interface EnginePrivate {
  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {
    topic: string;
    method: M;
    params: JsonRpcTypes.RequestParams[M];
    expiry?: number;
    relayRpcId?: number;
    clientRpcId?: number;
    throwOnFailedPublish?: boolean;
    appLink?: string;
    tvf?: RelayerTypes.ITVF;
  }): Promise<number>;

  sendResult<M extends JsonRpcTypes.WcMethod>(args: {
    id: number;
    topic: string;
    result: JsonRpcTypes.Results[M];
    throwOnFailedPublish?: boolean;
    encodeOpts?: CryptoTypes.EncodeOptions;
    appLink?: string;
  }): Promise<void>;

  sendError(params: {
    id: number;
    topic: string;
    error: JsonRpcTypes.Error;
    encodeOpts?: CryptoTypes.EncodeOptions;
    rpcOpts?: RelayerTypes.PublishOptions;
    appLink?: string;
  }): Promise<void>;

  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;

  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;

  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;

  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;

  deleteSession(params: {
    topic: string;
    expirerHasDeleted?: boolean;
    id?: number;
    emitEvent?: boolean;
  }): Promise<void>;

  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;

  setExpiry(topic: string, expiry: number): Promise<void>;

  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;

  setAuthRequest(
    id: number,
    params: {
      request: AuthTypes.SessionAuthenticateRequest;
      pairingTopic: string;
      transportType?: RelayerTypes.MessageEvent["transportType"];
    },
  ): Promise<void>;

  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;

  deletePendingSessionRequest(
    id: number,
    reason: ErrorResponse,
    expirerHasDeleted?: boolean,
  ): Promise<void>;

  deletePendingAuthRequest(
    id: number,
    reason: ErrorResponse,
    expirerHasDeleted?: boolean,
  ): Promise<void>;

  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;

  cleanup(): Promise<void>;

  onSessionProposeRequest(params: {
    topic: string;
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionPropose"]>;
    attestation?: string;
    encryptedId?: string;
  }): Promise<void>;

  onSessionProposeResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionPropose"]> | JsonRpcError,
    transportType?: RelayerTypes.MessageEvent["transportType"],
  ): Promise<void>;

  onSessionSettleRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionSettle"]>,
  ): Promise<void>;

  onSessionSettleResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionSettle"]> | JsonRpcError,
  ): Promise<void>;

  onSessionUpdateRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionUpdate"]>,
  ): Promise<void>;

  onSessionUpdateResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionUpdate"]> | JsonRpcError,
  ): void;

  onSessionExtendRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionExtend"]>,
  ): Promise<void>;

  onSessionExtendResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionExtend"]> | JsonRpcError,
  ): void;

  onSessionPingRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionPing"]>,
  ): Promise<void>;

  onSessionPingResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionPing"]> | JsonRpcError,
  ): void;

  onSessionDeleteRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionDelete"]>,
  ): Promise<void>;

  onSessionRequest(params: {
    topic: string;
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionRequest"]>;
    transportType?: RelayerTypes.MessageEvent["transportType"];
    attestation?: string;
    encryptedId?: string;
  }): Promise<void>;

  onSessionRequestResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionRequest"]> | JsonRpcError,
  ): void;

  onSessionEventRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionEvent"]>,
  ): Promise<void>;

  onSessionAuthenticateRequest(params: {
    topic: string;
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionAuthenticate"]>;
    transportType?: RelayerTypes.MessageEvent["transportType"];
    attestation?: string;
    encryptedId?: string;
  }): Promise<void>;

  onSessionAuthenticateResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionAuthenticate"]> | JsonRpcError,
  ): void;

  // -- Validators ---------------------------------------------------- //
  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;

  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams["wc_sessionSettle"]): void;

  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;

  isValidReject(params: EngineTypes.RejectParams): Promise<void>;

  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;

  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;

  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;

  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;

  isValidPing(params: EngineTypes.PingParams): Promise<void>;

  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;

  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;
}

// -- class interface ----------------------------------------------- //

export abstract class IEngine {
  constructor(public client: ISignClient) {}

  public abstract init(): Promise<void>;

  public abstract connect(
    params: EngineTypes.ConnectParams,
  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;

  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;

  public abstract approve(
    params: EngineTypes.ApproveParams,
  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;

  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;

  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;

  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;

  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;

  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;

  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;

  public abstract ping(params: EngineTypes.PingParams): Promise<void>;

  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;

  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];

  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];

  public abstract authenticate: (
    params: AuthTypes.SessionAuthenticateParams,
    walletUniversalLink?: string,
  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;

  public abstract approveSessionAuthenticate: (
    params: AuthTypes.ApproveSessionAuthenticateParams,
  ) => Promise<{ session: SessionTypes.Struct | undefined }>;

  public abstract formatAuthMessage: (params: {
    request: AuthTypes.BaseAuthRequestParams;
    iss: string;
  }) => string;

  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;

  public abstract processRelayMessageCache(): void;
}
</file>

<file path="packages/types/src/sign-client/index.ts">
export * from "./client";
export * from "./engine";
export * from "./jsonrpc";
export * from "./proposal";
export * from "./session";
export * from "./pendingRequest";
export * from "./auth";
</file>

<file path="packages/types/src/sign-client/jsonrpc.ts">
import { ErrorResponse, JsonRpcResult } from "@walletconnect/jsonrpc-types";
import { SignClientTypes } from "./client";
import { RelayerTypes } from "../core/relayer";
import { SessionTypes } from "./session";
import { ProposalTypes } from "./proposal";
import { AuthTypes } from ".";

export declare namespace JsonRpcTypes {
  // -- core ------------------------------------------------------- //
  export type DefaultResponse = true | ErrorResponse;

  export type WcMethod =
    | "wc_sessionPropose"
    | "wc_sessionSettle"
    | "wc_sessionUpdate"
    | "wc_sessionExtend"
    | "wc_sessionDelete"
    | "wc_sessionPing"
    | "wc_sessionRequest"
    | "wc_sessionEvent"
    | "wc_sessionAuthenticate";

  // -- requests --------------------------------------------------- //

  export interface RequestParams {
    wc_pairingDelete: {
      code: number;
      message: string;
    };
    wc_pairingPing: Record<string, unknown>;
    wc_sessionPropose: {
      relays: RelayerTypes.ProtocolOptions[];
      requiredNamespaces: ProposalTypes.RequiredNamespaces;
      optionalNamespaces: ProposalTypes.OptionalNamespaces;
      sessionProperties?: ProposalTypes.SessionProperties;
      proposer: {
        publicKey: string;
        metadata: SignClientTypes.Metadata;
      };
      expiryTimestamp?: number;
    };
    wc_sessionSettle: {
      relay: RelayerTypes.ProtocolOptions;
      namespaces: SessionTypes.Namespaces;
      sessionProperties?: ProposalTypes.SessionProperties;
      scopedProperties?: ProposalTypes.ScopedProperties;
      sessionConfig?: SessionTypes.SessionConfig;
      expiry: number;
      controller: {
        publicKey: string;
        metadata: SignClientTypes.Metadata;
      };
    };
    wc_sessionUpdate: {
      namespaces: SessionTypes.Namespaces;
    };
    wc_sessionExtend: Record<string, unknown>;
    wc_sessionDelete: {
      code: number;
      message: string;
    };
    wc_sessionPing: Record<string, unknown>;
    wc_sessionRequest: {
      request: {
        method: string;
        params: any;
        expiryTimestamp?: number;
      };
      chainId: string;
    };
    wc_sessionEvent: {
      event: {
        name: string;
        data: unknown;
      };
      chainId: string;
    };
    wc_sessionAuthenticate: AuthTypes.SessionAuthenticateRequestParams;
  }

  // -- responses -------------------------------------------------- //
  export interface Results {
    wc_pairingDelete: true;
    wc_pairingPing: true;
    wc_sessionPropose: {
      relay: RelayerTypes.ProtocolOptions;
      responderPublicKey: string;
    };
    wc_sessionSettle: true;
    wc_sessionUpdate: true;
    wc_sessionExtend: true;
    wc_sessionDelete: true;
    wc_sessionPing: true;
    wc_sessionRequest: JsonRpcResult;
    wc_sessionEvent: true;
    wc_sessionAuthenticate: AuthTypes.SessionAuthenticateResponseParams;
  }

  export type Error = ErrorResponse;
}
</file>

<file path="packages/types/src/sign-client/pendingRequest.ts">
import { IStore, Verify } from "../core";
import { SignClientTypes } from "./";

export declare namespace PendingRequestTypes {
  export interface Struct {
    topic: string;
    id: number;
    params: SignClientTypes.EventArguments["session_request"]["params"];
    verifyContext: Verify.Context;
  }
}
export type IPendingRequest = IStore<number, PendingRequestTypes.Struct>;
</file>

<file path="packages/types/src/sign-client/proposal.ts">
import { SignClientTypes } from "./client";
import { RelayerTypes } from "../core/relayer";
import { IStore } from "../core/store";

export declare namespace ProposalTypes {
  interface BaseRequiredNamespace {
    chains?: string[];
    methods: string[];
    events: string[];
  }

  type RequiredNamespace = BaseRequiredNamespace;

  type RequiredNamespaces = Record<string, RequiredNamespace>;
  type OptionalNamespaces = Record<string, RequiredNamespace>;
  type SessionProperties = Record<string, string>;
  type ScopedProperties = Record<string, unknown>;

  export interface Struct {
    id: number;
    /**
     * @deprecated in favor of expiryTimestamp
     */
    expiry?: number;
    expiryTimestamp: number;
    relays: RelayerTypes.ProtocolOptions[];
    proposer: {
      publicKey: string;
      metadata: SignClientTypes.Metadata;
    };
    requiredNamespaces: RequiredNamespaces;
    optionalNamespaces: OptionalNamespaces;
    sessionProperties?: SessionProperties;
    scopedProperties?: ScopedProperties;
    pairingTopic: string;
  }
}

export type IProposal = IStore<number, ProposalTypes.Struct>;
</file>

<file path="packages/types/src/sign-client/session.ts">
import { RelayerTypes } from "../core/relayer";
import { IStore } from "../core/store";
import { SignClientTypes } from "./client";
import { ProposalTypes } from "./proposal";
import { AuthTypes } from "./auth";

export declare namespace SessionTypes {
  type Expiry = number;

  interface BaseNamespace {
    chains?: string[];
    accounts: string[];
    methods: string[];
    events: string[];
  }

  type Namespace = BaseNamespace;

  type Namespaces = Record<string, Namespace>;

  type SessionProperties = ProposalTypes.SessionProperties;
  type ScopedProperties = ProposalTypes.ScopedProperties;

  interface SessionConfig {
    disableDeepLink?: boolean;
  }

  interface Struct {
    topic: string;
    pairingTopic: string;
    relay: RelayerTypes.ProtocolOptions;
    expiry: Expiry;
    acknowledged: boolean;
    controller: string;
    namespaces: Namespaces;
    requiredNamespaces: ProposalTypes.RequiredNamespaces;
    optionalNamespaces: ProposalTypes.OptionalNamespaces;
    sessionProperties?: SessionProperties;
    scopedProperties?: ScopedProperties;
    sessionConfig?: SessionConfig;
    self: {
      publicKey: string;
      metadata: SignClientTypes.Metadata;
    };
    peer: {
      publicKey: string;
      metadata: SignClientTypes.Metadata;
    };
    authentication?: AuthTypes.Cacao[];
    transportType?: RelayerTypes.TransportType;
  }
}

export type ISession = IStore<string, SessionTypes.Struct>;
</file>

<file path="packages/types/src/index.ts">
export * from "./core";
export * from "./sign-client";
</file>

<file path="packages/types/.npmignore">
*.log
npm-debug.log*

# Coverage directory used by tools like istanbul
coverage
.nyc_output

# Dependency directories
node_modules

# npm package lock
package-lock.json
yarn.lock

# project files
src
test
CHANGELOG.md
.travis.yml
.editorconfig
.eslintignore
.eslintrc
.babelrc
.gitignore
.watchmanconfig
</file>

<file path="packages/types/CHANGELOG.md">
# @walletconnect/types

## 2.20.0

## 2.19.4

## 2.19.3
</file>

<file path="packages/types/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="packages/types/package.json">
{
  "name": "@walletconnect/types",
  "description": "Typings for WalletConnect Protocol",
  "version": "2.20.0",
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
  "license": "Apache-2.0",
  "main": "dist/index.cjs.js",
  "module": "dist/index.es.js",
  "unpkg": "dist/index.umd.js",
  "types": "dist/types/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "keywords": [
    "wallet",
    "walletconnect"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build:pre": "npm run clean",
    "build:types": "tsc",
    "build:source": "rollup --config rollup.config.js",
    "build": "npm run build:pre; npm run build:source; npm run build:types",
    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
    "prettier": "prettier --check 'src/**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@walletconnect/events": "1.0.1",
    "@walletconnect/heartbeat": "1.2.2",
    "@walletconnect/jsonrpc-types": "1.0.4",
    "@walletconnect/keyvaluestorage": "1.1.1",
    "@walletconnect/logger": "2.1.2",
    "events": "3.3.0"
  }
}
</file>

<file path="packages/types/README.md">
# @walletconnect/types

Typings for WalletConnect Protocol
</file>

<file path="packages/types/rollup.config.js">
import { name, dependencies } from "./package.json";
import createConfig from "../../rollup.config";

export default createConfig(name, Object.keys(dependencies));
</file>

<file path="packages/types/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["./src/**/*"],
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "./dist/types",
    "emitDeclarationOnly": true
  }
}
</file>

</files>
