This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: site/**/*.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
site/
  .vitepress/
    theme/
      components/
        AsideSponsors.vue
        Banner.vue
        HomeBanner.vue
        HomePage.vue
      composables/
        useSponsors.ts
      index.ts
      style.css
    config.ts
    constants.ts
    sidebar.ts
  cli/
    api/
      commands/
        generate.md
        init.md
      plugins/
        actions.md
        blockExplorer.md
        etherscan.md
        fetch.md
        foundry.md
        hardhat.md
        react.md
        sourcify.md
      commands.md
      plugins.md
    config/
      configuring-cli.md
      options.md
    guides/
      migrate-from-v1-to-v2.md
    create-wagmi.md
    getting-started.md
    installation.md
    why.md
  components/
    Browsers.vue
    SearchChains.vue
  core/
    api/
      actions/
        call.md
        connect.md
        deployContract.md
        disconnect.md
        estimateFeesPerGas.md
        estimateGas.md
        estimateMaxPriorityFeePerGas.md
        getAccount.md
        getBalance.md
        getBlock.md
        getBlockNumber.md
        getBlockTransactionCount.md
        getBytecode.md
        getCallsStatus.md
        getCapabilities.md
        getChainId.md
        getChains.md
        getClient.md
        getConnections.md
        getConnectorClient.md
        getConnectors.md
        getEnsAddress.md
        getEnsAvatar.md
        getEnsName.md
        getEnsResolver.md
        getEnsText.md
        getFeeHistory.md
        getGasPrice.md
        getProof.md
        getPublicClient.md
        getStorageAt.md
        getToken.md
        getTransaction.md
        getTransactionConfirmations.md
        getTransactionCount.md
        getTransactionReceipt.md
        getWalletClient.md
        multicall.md
        prepareTransactionRequest.md
        readContract.md
        readContracts.md
        reconnect.md
        sendCalls.md
        sendTransaction.md
        showCallsStatus.md
        signMessage.md
        signTypedData.md
        simulateContract.md
        switchAccount.md
        switchChain.md
        verifyMessage.md
        verifyTypedData.md
        waitForCallsStatus.md
        waitForTransactionReceipt.md
        watchAccount.md
        watchAsset.md
        watchBlockNumber.md
        watchBlocks.md
        watchChainId.md
        watchClient.md
        watchConnections.md
        watchConnectors.md
        watchContractEvent.md
        watchPendingTransactions.md
        watchPublicClient.md
        writeContract.md
        writeContracts.md
      connectors/
        coinbaseWallet.md
        injected.md
        metaMask.md
        mock.md
        safe.md
        walletConnect.md
      transports/
        custom.md
        fallback.md
        http.md
        unstable_connector.md
        webSocket.md
      utilities/
        cookieToInitialState.md
        deserialize.md
        normalizeChainId.md
        serialize.md
      actions.md
      chains.md
      connectors.md
      createConfig.md
      createConnector.md
      createStorage.md
      errors.md
      transports.md
    guides/
      chain-properties.md
      error-handling.md
      ethers.md
      faq.md
      framework-adapters.md
      migrate-from-v1-to-v2.md
      testing.md
      viem.md
    getting-started.md
    installation.md
    typescript.md
    why.md
  dev/
    contributing.md
    creating-connectors.md
  public/
    favicon.svg
    logo-dark.svg
    logo-light.svg
  react/
    api/
      connectors/
        coinbaseWallet.md
        injected.md
        metaMask.md
        mock.md
        safe.md
        walletConnect.md
      hooks/
        useAccount.md
        useAccountEffect.md
        useBalance.md
        useBlock.md
        useBlockNumber.md
        useBlockTransactionCount.md
        useBytecode.md
        useCall.md
        useCallsStatus.md
        useCapabilities.md
        useChainId.md
        useChains.md
        useClient.md
        useConfig.md
        useConnect.md
        useConnections.md
        useConnectorClient.md
        useConnectors.md
        useDeployContract.md
        useDisconnect.md
        useEnsAddress.md
        useEnsAvatar.md
        useEnsName.md
        useEnsResolver.md
        useEnsText.md
        useEstimateFeesPerGas.md
        useEstimateGas.md
        useEstimateMaxPriorityFeePerGas.md
        useFeeHistory.md
        useGasPrice.md
        useInfiniteReadContracts.md
        usePrepareTransactionRequest.md
        useProof.md
        usePublicClient.md
        useReadContract.md
        useReadContracts.md
        useReconnect.md
        useSendCalls.md
        useSendTransaction.md
        useShowCallsStatus.md
        useSignMessage.md
        useSignTypedData.md
        useSimulateContract.md
        useStorageAt.md
        useSwitchAccount.md
        useSwitchChain.md
        useToken.md
        useTransaction.md
        useTransactionConfirmations.md
        useTransactionCount.md
        useTransactionReceipt.md
        useVerifyMessage.md
        useVerifyTypedData.md
        useWaitForCallsStatus.md
        useWaitForTransactionReceipt.md
        useWalletClient.md
        useWatchAsset.md
        useWatchBlockNumber.md
        useWatchBlocks.md
        useWatchContractEvent.md
        useWatchPendingTransactions.md
        useWriteContract.md
        useWriteContracts.md
      transports/
        custom.md
        fallback.md
        http.md
        unstable_connector.md
        webSocket.md
      utilities/
        cookieToInitialState.md
        deserialize.md
        normalizeChainId.md
        serialize.md
      actions.md
      chains.md
      connectors.md
      createConfig.md
      createStorage.md
      errors.md
      hooks.md
      transports.md
      WagmiProvider.md
    guides/
      chain-properties.md
      connect-wallet.md
      error-handling.md
      ethers.md
      faq.md
      migrate-from-v1-to-v2.md
      read-from-contract.md
      send-transaction.md
      ssr.md
      tanstack-query.md
      testing.md
      viem.md
      write-to-contract.md
    comparisons.md
    getting-started.md
    installation.md
    typescript.md
    why.md
  shared/
    connectors/
      coinbaseWallet.md
      injected.md
      metaMask.md
      mock.md
      safe.md
      walletConnect.md
    transports/
      custom.md
      fallback.md
      http.md
      unstable_connector.md
      webSocket.md
    utilities/
      cookieToInitialState.md
      deserialize.md
      normalizeChainId.md
      serialize.md
    create-chain.md
    createConfig.md
    createStorage.md
    errors.md
    faq.md
    getAccount-return-type.md
    installation.md
    mutation-imports.md
    mutation-options.md
    mutation-result.md
    query-imports.md
    query-options.md
    query-result.md
  snippets/
    core/
      config-chain-properties.ts
      config.ts
    react/
      app.tsx
      config-chain-properties.ts
      config.ts
    vue/
      App.vue
      config-chain-properties.ts
      config.ts
      main.ts
    abi-event.ts
    abi-infinite-read.ts
    abi-read.ts
    abi-write.ts
    typedData.ts
  vue/
    api/
      composables/
        useAccount.md
        useAccountEffect.md
        useBalance.md
        useBlockNumber.md
        useBytecode.md
        useChainId.md
        useChains.md
        useClient.md
        useConfig.md
        useConnect.md
        useConnections.md
        useConnectorClient.md
        useConnectors.md
        useDisconnect.md
        useEnsAddress.md
        useEnsAvatar.md
        useEnsName.md
        useEstimateGas.md
        useReadContract.md
        useReconnect.md
        useSendTransaction.md
        useSignMessage.md
        useSignTypedData.md
        useSimulateContract.md
        useSwitchAccount.md
        useSwitchChain.md
        useTransaction.md
        useTransactionReceipt.md
        useWaitForTransactionReceipt.md
        useWatchBlockNumber.md
        useWatchContractEvent.md
        useWriteContract.md
      connectors/
        coinbaseWallet.md
        injected.md
        metaMask.md
        mock.md
        safe.md
        walletConnect.md
      transports/
        custom.md
        fallback.md
        http.md
        unstable_connector.md
        webSocket.md
      utilities/
        deserialize.md
        serialize.md
      actions.md
      chains.md
      composables.md
      connectors.md
      createConfig.md
      createStorage.md
      errors.md
      Nuxt.md
      transports.md
      WagmiPlugin.md
    guides/
      chain-properties.md
      connect-wallet.md
      error-handling.md
      faq.md
      read-from-contract.md
      send-transaction.md
      ssr.md
      tanstack-query.md
      viem.md
      write-to-contract.md
    getting-started.md
    installation.md
    typescript.md
    why.md
  index.md
  package.json
  tsconfig.json
  vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="site/.vitepress/theme/components/AsideSponsors.vue">
<script setup lang="ts">
import { VPDocAsideSponsors } from 'vitepress/theme'
import { computed } from 'vue'
import { useSponsors } from '../composables/useSponsors'

const { data } = useSponsors()

const sponsors = computed(() => {
  return (
    data?.value
      ?.filter(
        (sponsor) => sponsor.type === 'platinum' || sponsor.type === 'gold',
      )
      .map((sponsor) => {
        return {
          size: sponsor.type === 'platinum' ? 'mini' : 'xmini',
          items: sponsor.items,
        }
      }) ?? []
  )
})
</script>

<template>
  <VPDocAsideSponsors v-if="data" :data="sponsors" />
</template>
</file>

<file path="site/.vitepress/theme/components/Banner.vue">
// TODO: Dismissable, a11y, etc.
// https://github.com/faker-js/faker/pull/1487

<template>
  <div class="banner" font-medium items-center justify-center text-center text-sm py-4 px-3 mb-8 rounded-lg>
    Wagmi is participating in Gitcoin Grants round 21. Consider <a class="underline"
      href="https://explorer.gitcoin.co/#/round/42161/389/74">supporting the project</a>. Thank you. üôè
  </div>
</template>

<style scoped>
.banner {
  background: var(--vp-c-indigo-soft);
  text-wrap: balance;
}
</style>
</file>

<file path="site/.vitepress/theme/components/HomeBanner.vue">
<template>
  <div class="banner" font-medium items-center justify-center text-center text-sm py-3>
    Looking for the 1.x docs? Check out <a underline underline-dotted href="https://1.x.wagmi.sh">1.x.wagmi.sh</a>.
  </div>
</template>

<style scoped>
.banner {
  background: var(--vp-c-bg-soft);
  color: var(--vp-c-text-1);
}
</style>
</file>

<file path="site/.vitepress/theme/components/HomePage.vue">
<script setup lang="ts">
import type DefaultTheme from 'vitepress/theme'
import { VPButton, VPSponsors, VPTeamMembers } from 'vitepress/theme'
import { farcasterIcon } from '../../constants'
import { useSponsors } from '../composables/useSponsors'

const { data: sponsors } = useSponsors()

const teamMembers = [
  {
    avatar: 'https://www.github.com/tmm.png',
    name: 'tmm',
    links: [
      { icon: 'github', link: 'https://github.com/tmm' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/tmm.dev' },
      { icon: 'x', link: 'https://twitter.com/awkweb' },
      {
        icon: {
          svg: farcasterIcon,
        },
        link: 'https://warpcast.com/awkweb',
      },
    ],
  },
  {
    avatar: 'https://www.github.com/jxom.png',
    name: 'jxom',
    links: [
      { icon: 'github', link: 'https://github.com/jxom' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/jxom.dev' },
      { icon: 'x', link: 'https://twitter.com/_jxom' },
      {
        icon: {
          svg: farcasterIcon,
        },
        link: 'https://warpcast.com/jxom',
      },
    ],
  },
] satisfies DefaultTheme.TeamMember[]
</script>

<template>
  <div class="content">
    <div class="content-container">
      <main class="main">
        <div class="vp-doc" flex flex-col items-center mt-10>
          <h2 id="meet-the-team" op50 font-normal p="t-10 b-2">
            Meet The Team
          </h2>
          <div w-full p-10>
            <VPTeamMembers size="small" :members="teamMembers" />
          </div>

          <h2 id="sponsored-by" op50 font-normal pt-5 pb-2>
            Sponsored by
          </h2>

          <div w-full p-10 class="container">
            <VPSponsors v-if="sponsors" :data="sponsors" />

            <div pt-10 text-center>
              <VPButton theme="alt" text="Become a sponsor" href="https://github.com/sponsors/wevm" />
            </div>
          </div>

          <div flex flex-col gap-2 items-center pt-10>
            <div>
              <a href="https://vercel.com/?utm_source=wevm&utm_campaign=oss">
                <img src="https://www.datocms-assets.com/31049/1618983297-powered-by-vercel.svg" alt="Powered by Vercel" h8>
              </a>
            </div>
            <div>
              <a href="https://quicknode.com/?utm_source=wevm&utm_campaign=oss">
                <img src="https://raw.githubusercontent.com/wevm/.github/refs/heads/main/content/quicknode-badge.svg" alt="Powered by QuickNode" h8>
              </a>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
</template>

<style>
.vp-doc .VPTeamMembers.small.count-2 .container {
  max-width: calc(276px * 2 + 24px) !important;
}

.container {
  margin: 0 auto;
  max-width: 1152px;
}

h3.vp-sponsor-tier {
  margin: 0;
  margin-bottom: 4px;
}

.VercelBadge {
  align-items: center;
  color: var(--vp-c-text-2) !important;
  display: flex;
  font-size: 0.85rem;
  font-weight: 500;
  gap: 0.35rem;
  justify-content: center;
}

.VercelBadge:hover {
  text-decoration: none !important;
}

.VercelBadge svg {
  color: var(--vp-c-text-2);
  height: 0.85rem;
}
</style>
</file>

<file path="site/.vitepress/theme/composables/useSponsors.ts">
import { onMounted, ref } from 'vue'

type Sponsor = {
  name: string
  img: string
  url: string
}

type Data = {
  size: 'big' | 'medium' | 'small'
  items: Sponsor[]
  tier: string
  type: 'platinum' | 'gold' | 'silver'
}[]

// shared data across instances so we load only once.
const data = ref<Data>()

// TODO: Data powered
// const dataHost = 'https://sponsors.vuejs.org'
// const dataUrl = `${dataHost}/vite.json`

export function useSponsors() {
  onMounted(async () => {
    if (data.value) return

    // const result = await fetch(dataUrl)
    // const json = await result.json()
    // console.log(json)
    const sponsors = {
      platinum: [
        {
          name: 'Paradigm',
          url: 'https://paradigm.xyz',
          img: 'paradigm-light.svg',
        },
        {
          name: 'Ithaca',
          url: 'https://ithaca.xyz',
          img: 'ithaca-light.svg',
        },
      ],
      gold: [
        {
          name: 'Stripe',
          url: 'https://www.stripe.com',
          img: 'stripe-light.svg',
        },
        {
          name: 'zkSync',
          url: 'https://zksync.io',
          img: 'zksync-light.svg',
        },
        {
          name: 'Linea',
          url: 'https://linea.build',
          img: 'linea-light.svg',
        },
        {
          name: 'Routescan',
          url: 'https://routescan.io',
          img: 'routescan-light.svg',
        },
      ],
      silver: [
        {
          name: 'Family',
          url: 'https://twitter.com/family',
          img: 'family-light.svg',
        },
        {
          name: 'Context',
          url: 'https://twitter.com/context',
          img: 'context-light.svg',
        },
        {
          name: 'WalletConnect',
          url: 'https://walletconnect.com',
          img: 'walletconnect-light.svg',
        },
        {
          name: 'PartyDAO',
          url: 'https://twitter.com/prtyDAO',
          img: 'partydao-light.svg',
        },
        {
          name: 'SushiSwap',
          url: 'https://www.sushi.com',
          img: 'sushi-light.svg',
        },
        {
          name: 'Dynamic',
          url: 'https://www.dynamic.xyz',
          img: 'dynamic-light.svg',
        },
        {
          name: 'Privy',
          url: 'https://privy.io',
          img: 'privy-light.svg',
        },
        {
          name: 'PancakeSwap',
          url: 'https://pancakeswap.finance',
          img: 'pancake-light.svg',
        },
        {
          name: 'Celo',
          url: 'https://celo.org',
          img: 'celo-light.svg',
        },
        {
          name: 'Rainbow',
          url: 'https://rainbow.me',
          img: 'rainbow-light.svg',
        },
        {
          name: 'Pimlico',
          url: 'https://pimlico.io',
          img: 'pimlico-light.svg',
        },
        {
          name: 'Zora',
          url: 'https://zora.co',
          img: 'zora-light.svg',
        },
        {
          name: 'Lattice',
          url: 'https://lattice.xyz',
          img: 'lattice-light.svg',
        },
        {
          name: 'Supa',
          url: 'https://twitter.com/supafinance',
          img: 'supa-light.svg',
        },
        {
          name: 'Syndicate',
          url: 'https://syndicate.io',
          img: 'syndicate-light.svg',
        },
        {
          name: 'Reservoir',
          url: 'https://reservoir.tools',
          img: 'reservoir-light.svg',
        },
        {
          name: 'Uniswap',
          url: 'https://uniswap.org',
          img: 'uniswap-light.svg',
        },
        {
          name: 'Biconomy',
          url: 'https://biconomy.io',
          img: 'biconomy-light.svg',
        },
        {
          name: 'Thirdweb',
          url: 'https://thirdweb.com',
          img: 'thirdweb-light.svg',
        },
        {
          name: 'Polymarket',
          url: 'https://polymarket.com',
          img: 'polymarket-light.svg',
        },
        {
          name: 'Sequence',
          url: 'https://sequence.xyz',
          img: 'sequence-light.svg',
        },
      ],
    }

    data.value = mapSponsors(sponsors)
  })

  return { data }
}

function mapSponsors(sponsors: {
  platinum: Sponsor[]
  gold: Sponsor[]
  silver: Sponsor[]
}) {
  return [
    {
      size: 'big',
      items: mapImgPath(sponsors.platinum),
      tier: 'Collaborators',
      type: 'platinum',
    },
    {
      size: 'medium',
      items: mapImgPath(sponsors.gold),
      tier: 'Large Enterprises',
      type: 'gold',
    },
    {
      size: 'small',
      items: mapImgPath(sponsors.silver),
      tier: 'Small Enterprises',
      type: 'silver',
    },
  ] satisfies Data
}

function mapImgPath(sponsors: Sponsor[]) {
  return sponsors.map((sponsor) => ({
    ...sponsor,
    img: `https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/${sponsor.img}`,
  }))
}
</file>

<file path="site/.vitepress/theme/index.ts">
import TwoslashFloatingVue from '@shikijs/vitepress-twoslash/client'
import type { Theme } from 'vitepress'
import DefaultTheme from 'vitepress/theme'
// https://vitepress.dev/guide/custom-theme
import { h } from 'vue'

import '@shikijs/vitepress-twoslash/style.css'
import 'uno.css'
import './style.css'

import AsideSponsors from './components/AsideSponsors.vue'
// import Banner from './components/Banner.vue'
import HomeBanner from './components/HomeBanner.vue'
import HomePage from './components/HomePage.vue'

export default {
  extends: DefaultTheme,
  Layout() {
    return h(DefaultTheme.Layout, null, {
      // https://vitepress.dev/guide/extending-default-theme#layout-slots
      'aside-ads-before': () => h(AsideSponsors),
      // 'doc-before': () => h(Banner),
      'home-features-after': () => h(HomePage),
      'home-hero-before': () => h(HomeBanner),
    })
  },
  enhanceApp({ app }) {
    app.use(TwoslashFloatingVue)
  },
} satisfies Theme
</file>

<file path="site/.vitepress/theme/style.css">
/**
 * Customize default theme styling by overriding CSS variables:
 * https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css
 */

/**
 * Colors
 *
 * Each colors have exact same color scale system with 3 levels of solid
 * colors with different brightness, and 1 soft color.
 *
 * - `XXX-1`: The most solid color used mainly for colored text. It must
 *   satisfy the contrast ratio against when used on top of `XXX-soft`.
 *
 * - `XXX-2`: The color used mainly for hover state of the button.
 *
 * - `XXX-3`: The color for solid background, such as bg color of the button.
 *   It must satisfy the contrast ratio with pure white (#ffffff) text on
 *   top of it.
 *
 * - `XXX-soft`: The color used for subtle background such as custom container
 *   or badges. It must satisfy the contrast ratio when putting `XXX-1` colors
 *   on top of it.
 *
 *   The soft color must be semi transparent alpha channel. This is crucial
 *   because it allows adding multiple "soft" colors on top of each other
 *   to create a accent, such as when having inline code block inside
 *   custom containers.
 *
 * - `default`: The color used purely for subtle indication without any
 *   special meanings attached to it such as bg color for menu hover state.
 *
 * - `brand`: Used for primary brand colors, such as link text, button with
 *   brand theme, etc.
 *
 * - `tip`: Used to indicate useful information. The default theme uses the
 *   brand color for this by default.
 *
 * - `warning`: Used to indicate warning to the users. Used in custom
 *   container, badges, etc.
 *
 * - `danger`: Used to show error, or dangerous message to the users. Used
 *   in custom container, badges, etc.
 * -------------------------------------------------------------------------- */

:root {
  --vp-c-default-1: var(--vp-c-gray-1);
  --vp-c-default-2: var(--vp-c-gray-2);
  --vp-c-default-3: var(--vp-c-gray-3);
  --vp-c-default-soft: var(--vp-c-gray-soft);

  --vp-c-brand-1: var(--vp-c-indigo-1);
  --vp-c-brand-2: var(--vp-c-indigo-2);
  --vp-c-brand-3: var(--vp-c-indigo-3);
  --vp-c-brand-soft: var(--vp-c-indigo-soft);

  --vp-c-tip-1: var(--vp-c-brand-1);
  --vp-c-tip-2: var(--vp-c-brand-2);
  --vp-c-tip-3: var(--vp-c-brand-3);
  --vp-c-tip-soft: var(--vp-c-brand-soft);

  --vp-c-warning-1: var(--vp-c-yellow-1);
  --vp-c-warning-2: var(--vp-c-yellow-2);
  --vp-c-warning-3: var(--vp-c-yellow-3);
  --vp-c-warning-soft: var(--vp-c-yellow-soft);

  --vp-c-danger-1: var(--vp-c-red-1);
  --vp-c-danger-2: var(--vp-c-red-2);
  --vp-c-danger-3: var(--vp-c-red-3);
  --vp-c-danger-soft: var(--vp-c-red-soft);
}

/**
 * Component: Button
 * -------------------------------------------------------------------------- */

:root {
  --vp-button-brand-border: transparent;
  --vp-button-brand-text: var(--vp-c-white);
  --vp-button-brand-bg: var(--vp-c-brand-3);
  --vp-button-brand-hover-border: transparent;
  --vp-button-brand-hover-text: var(--vp-c-white);
  --vp-button-brand-hover-bg: var(--vp-c-brand-2);
  --vp-button-brand-active-border: transparent;
  --vp-button-brand-active-text: var(--vp-c-white);
  --vp-button-brand-active-bg: var(--vp-c-brand-1);
}

/**
 * Component: Home
 * -------------------------------------------------------------------------- */

:root {
  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: -webkit-linear-gradient(
    120deg,
    #bd34fe 30%,
    #41d1ff
  );

  --vp-home-hero-image-background-image: linear-gradient(
    -45deg,
    #bd34fe 50%,
    #47caff 50%
  );
  --vp-home-hero-image-filter: blur(44px);
}

@media (min-width: 640px) {
  :root {
    --vp-home-hero-image-filter: blur(56px);
  }
}

@media (min-width: 960px) {
  :root {
    --vp-home-hero-image-filter: blur(68px);
  }
}

/**
 * Component: Custom Block
 * -------------------------------------------------------------------------- */

:root {
  --vp-custom-block-tip-border: transparent;
  --vp-custom-block-tip-text: var(--vp-c-text-1);
  --vp-custom-block-tip-bg: var(--vp-c-brand-soft);
  --vp-custom-block-tip-code-bg: var(--vp-c-brand-soft);
}

/**
 * Component: Algolia
 * -------------------------------------------------------------------------- */

.DocSearch {
  --docsearch-primary-color: var(--vp-c-brand-1) !important;
}

.vp-doc [class*="language-"] .has-focused-lines .line:not(.has-focus) {
  filter: unset;
  opacity: 0.3;
}

.twoslash-error-line {
  max-width: min-content;
  white-space: wrap;
}
</file>

<file path="site/.vitepress/config.ts">
import {
  defaultHoverInfoProcessor,
  transformerTwoslash,
} from '@shikijs/vitepress-twoslash'
import { presetAttributify, presetIcons, presetUno } from 'unocss'
import Unocss from 'unocss/vite'
import { defineConfig } from 'vitepress'

import { farcasterIcon } from './constants'
import { getSidebar } from './sidebar'

// https://vitepress.dev/reference/site-config
export default defineConfig({
  cleanUrls: true,
  description: 'Reactivity for Ethereum apps',
  head: [
    [
      'meta',
      {
        name: 'keywords',
        content: 'react, ethereum, typescript, react, react hooks, open source',
      },
    ],
    ['link', { rel: 'icon', href: '/favicon.svg' }],
    ['meta', { name: 'theme-color', content: '#646cff' }],
    // Open Graph
    ['meta', { property: 'og:type', content: 'website' }],
    ['meta', { property: 'og:image', content: 'https://wagmi.sh/og.png' }],
    ['meta', { property: 'og:url', content: 'https://wagmi.sh' }],
    // Twitter
    ['meta', { name: 'twitter:card', content: 'summary_large_image' }],
    ['meta', { name: 'twitter:creator', content: '@wevm_dev' }],
    ['meta', { name: 'twitter:image', content: 'https://wagmi.sh/og.png' }],
    ['meta', { name: 'twitter:site', content: 'wagmi.sh' }],
    // Fathom
    [
      'script',
      {
        src: 'https://cdn.usefathom.com/script.js',
        'data-site': 'QWAXSUPT',
        defer: '',
      },
    ],
  ],
  ignoreDeadLinks: false,
  lang: 'en-US',
  lastUpdated: true,
  markdown: {
    codeTransformers: [
      transformerTwoslash({
        processHoverInfo(info) {
          return (
            defaultHoverInfoProcessor(info)
              // Remove shiki_core namespace
              .replace(/_shikijs_core[\w_]*\./g, '')
          )
        },
      }),
    ],
    theme: {
      light: 'vitesse-light',
      dark: 'vitesse-dark',
    },
  },
  themeConfig: {
    editLink: {
      pattern: 'https://github.com/wevm/wagmi/edit/main/site/:path',
      text: 'Suggest changes to this page',
    },
    footer: {
      message:
        'Released under the <a href="https://github.com/wevm/wagmi/blob/main/LICENSE">MIT License</a>.',
      copyright: 'Copyright ¬© 2022-present Weth, LLC',
    },
    logo: {
      light: '/logo-light.svg',
      dark: '/logo-dark.svg',
      alt: 'wagmi logo',
    },
    nav: [
      { text: 'React', link: '/react/getting-started' },
      { text: 'Vue', link: '/vue/getting-started' },
      { text: 'Core', link: '/core/getting-started' },
      { text: 'CLI', link: '/cli/getting-started' },
      // { text: 'Examples', link: '/examples/connect-wallet' },
      {
        text: 'More',
        items: [
          {
            text: 'Discussions ',
            link: 'https://github.com/wevm/wagmi/discussions',
          },
          {
            text: 'Release Notes ',
            link: 'https://github.com/wevm/wagmi/releases',
          },
          {
            text: 'Contributing ',
            link: '/dev/contributing',
          },
        ],
      },
    ],
    outline: [2, 3],
    search: {
      provider: 'local',
      options: {
        _render(src, env, md) {
          const html = md.render(src, env)
          if (env.frontmatter?.search === false) return ''
          if (env.relativePath.startsWith('shared')) return ''
          return html
        },
      },
    },
    sidebar: getSidebar(),
    siteTitle: false,
    socialLinks: [
      {
        icon: 'github',
        link: 'https://github.com/wevm/wagmi',
      },
      { icon: 'bluesky', link: 'https://bsky.app/profile/wevm.dev' },
      { icon: 'x', link: 'https://twitter.com/wevm_dev' },
      { icon: { svg: farcasterIcon }, link: 'https://warpcast.com/wevm' },
      { icon: 'discord', link: 'https://discord.gg/9zHPXuBpqy' },
    ],
  },
  title: 'Wagmi',
  vite: {
    plugins: [
      Unocss({
        shortcuts: [
          [
            'btn',
            'px-4 py-1 rounded inline-flex justify-center gap-2 text-white leading-30px children:mya !no-underline cursor-pointer disabled:cursor-default disabled:bg-gray-600 disabled:opacity-50',
          ],
        ],
        presets: [
          presetUno({
            dark: 'media',
          }),
          presetAttributify(),
          presetIcons({
            scale: 1.2,
          }),
        ],
      }),
    ],
  },
})
</file>

<file path="site/.vitepress/constants.ts">
export const farcasterIcon =
  '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.23077 9.51613L0 5.25807H5.49112V1H26.1302V5.25807H32L30.7692 9.51613H29.7278V26.7419C30.2507 26.7419 30.6746 27.1752 30.6746 27.7097V28.871H30.8639C31.3868 28.871 31.8107 29.3042 31.8107 29.8387V31H21.2071V29.8387C21.2071 29.3042 21.631 28.871 22.1538 28.871H22.3432V27.7097C22.3432 27.2415 22.6685 26.851 23.1006 26.7613V17.2581H23.0709C22.736 13.4601 19.6134 10.4839 15.8107 10.4839C12.0079 10.4839 8.88526 13.4601 8.55043 17.2581H8.52071V26.7419H8.71006C9.23293 26.7419 9.65681 27.1752 9.65681 27.7097V28.871H9.84616C10.369 28.871 10.7929 29.3042 10.7929 29.8387V31H0.189349V29.8387C0.189349 29.3042 0.613221 28.871 1.13609 28.871H1.32544V27.7097C1.32544 27.1752 1.74932 26.7419 2.27219 26.7419V9.51613H1.23077Z" fill="currentColor"/></svg>'
</file>

<file path="site/.vitepress/sidebar.ts">
import type { DefaultTheme } from 'vitepress'

export function getSidebar() {
  return {
    '/react': [
      {
        text: 'Introduction',
        items: [
          { text: 'Why Wagmi', link: '/react/why' },
          { text: 'Installation', link: '/react/installation' },
          { text: 'Getting Started', link: '/react/getting-started' },
          { text: 'TypeScript', link: '/react/typescript' },
          { text: 'Comparisons', link: '/react/comparisons' },
        ],
      },
      {
        text: 'Guides',
        items: [
          {
            text: 'TanStack Query',
            link: '/react/guides/tanstack-query',
          },
          {
            text: 'Viem',
            link: '/react/guides/viem',
          },
          {
            text: 'Error Handling',
            link: '/react/guides/error-handling',
          },
          {
            text: 'Ethers.js Adapters',
            link: '/react/guides/ethers',
          },
          // {
          //   text: 'Testing',
          //   link: '/react/guides/testing',
          // },
          {
            text: 'Chain Properties',
            link: '/react/guides/chain-properties',
          },
          {
            text: 'SSR',
            link: '/react/guides/ssr',
          },
          {
            text: 'Connect Wallet',
            link: '/react/guides/connect-wallet',
          },
          {
            text: 'Send Transaction',
            link: '/react/guides/send-transaction',
          },
          {
            text: 'Read from Contract',
            link: '/react/guides/read-from-contract',
          },
          {
            text: 'Write to Contract',
            link: '/react/guides/write-to-contract',
          },
          {
            text: 'FAQ / Troubleshooting',
            link: '/react/guides/faq',
          },
          {
            text: 'Migrate from v1 to v2',
            link: '/react/guides/migrate-from-v1-to-v2',
          },
        ],
      },
      {
        text: 'Configuration',
        items: [
          { text: 'createConfig', link: '/react/api/createConfig' },
          { text: 'createStorage', link: '/react/api/createStorage' },
          { text: 'Chains', link: '/react/api/chains' },
          {
            text: 'Connectors',
            collapsed: true,
            link: '/react/api/connectors',
            items: [
              {
                text: 'coinbaseWallet',
                link: '/react/api/connectors/coinbaseWallet',
              },
              { text: 'injected', link: '/react/api/connectors/injected' },
              {
                text: 'metaMask',
                link: '/react/api/connectors/metaMask',
              },
              {
                text: 'mock',
                link: '/react/api/connectors/mock',
              },
              {
                text: 'safe',
                link: '/react/api/connectors/safe',
              },
              {
                text: 'walletConnect',
                link: '/react/api/connectors/walletConnect',
              },
            ],
          },
          {
            text: 'Transports',
            collapsed: true,
            link: '/react/api/transports',
            items: [
              {
                text: 'custom (EIP-1193)',
                link: '/react/api/transports/custom',
              },
              {
                text: 'fallback',
                link: '/react/api/transports/fallback',
              },
              {
                text: 'http',
                link: '/react/api/transports/http',
              },
              {
                text: 'unstable_connector',
                link: '/react/api/transports/unstable_connector',
              },
              {
                text: 'webSocket',
                link: '/react/api/transports/webSocket',
              },
            ],
          },
          { text: 'WagmiProvider', link: '/react/api/WagmiProvider' },
        ],
      },
      {
        text: 'Hooks',
        link: '/react/api/hooks',
        items: [
          { text: 'useAccount', link: '/react/api/hooks/useAccount' },
          {
            text: 'useAccountEffect',
            link: '/react/api/hooks/useAccountEffect',
          },
          { text: 'useBalance', link: '/react/api/hooks/useBalance' },
          {
            text: 'useBlockNumber',
            link: '/react/api/hooks/useBlockNumber',
          },
          {
            text: 'useBlock',
            link: '/react/api/hooks/useBlock',
          },
          {
            text: 'useBlockTransactionCount',
            link: '/react/api/hooks/useBlockTransactionCount',
          },
          {
            text: 'useBytecode',
            link: '/react/api/hooks/useBytecode',
          },
          { text: 'useCall', link: '/react/api/hooks/useCall' },
          { text: 'useChainId', link: '/react/api/hooks/useChainId' },
          { text: 'useChains', link: '/react/api/hooks/useChains' },
          { text: 'useClient', link: '/react/api/hooks/useClient' },
          { text: 'useConfig', link: '/react/api/hooks/useConfig' },
          { text: 'useConnect', link: '/react/api/hooks/useConnect' },
          {
            text: 'useConnections',
            link: '/react/api/hooks/useConnections',
          },
          {
            text: 'useConnectorClient',
            link: '/react/api/hooks/useConnectorClient',
          },
          {
            text: 'useConnectors',
            link: '/react/api/hooks/useConnectors',
          },
          {
            text: 'useDeployContract',
            link: '/react/api/hooks/useDeployContract',
          },
          { text: 'useDisconnect', link: '/react/api/hooks/useDisconnect' },
          { text: 'useEnsAddress', link: '/react/api/hooks/useEnsAddress' },
          { text: 'useEnsAvatar', link: '/react/api/hooks/useEnsAvatar' },
          { text: 'useEnsName', link: '/react/api/hooks/useEnsName' },
          {
            text: 'useEnsResolver',
            link: '/react/api/hooks/useEnsResolver',
          },
          {
            text: 'useEnsText',
            link: '/react/api/hooks/useEnsText',
          },
          {
            text: 'useFeeHistory',
            link: '/react/api/hooks/useFeeHistory',
          },
          {
            text: 'useProof',
            link: '/react/api/hooks/useProof',
          },
          {
            text: 'usePublicClient',
            link: '/react/api/hooks/usePublicClient',
          },
          {
            text: 'useEstimateFeesPerGas',
            link: '/react/api/hooks/useEstimateFeesPerGas',
          },
          {
            text: 'useEstimateGas',
            link: '/react/api/hooks/useEstimateGas',
          },
          {
            text: 'useEstimateMaxPriorityFeePerGas',
            link: '/react/api/hooks/useEstimateMaxPriorityFeePerGas',
          },
          {
            text: 'useGasPrice',
            link: '/react/api/hooks/useGasPrice',
          },
          {
            text: 'useInfiniteReadContracts',
            link: '/react/api/hooks/useInfiniteReadContracts',
          },
          {
            text: 'usePrepareTransactionRequest',
            link: '/react/api/hooks/usePrepareTransactionRequest',
          },
          {
            text: 'useReadContract',
            link: '/react/api/hooks/useReadContract',
          },
          {
            text: 'useReadContracts',
            link: '/react/api/hooks/useReadContracts',
          },
          { text: 'useReconnect', link: '/react/api/hooks/useReconnect' },
          {
            text: 'useSendTransaction',
            link: '/react/api/hooks/useSendTransaction',
          },
          {
            text: 'useSignMessage',
            link: '/react/api/hooks/useSignMessage',
          },
          {
            text: 'useSignTypedData',
            link: '/react/api/hooks/useSignTypedData',
          },
          {
            text: 'useSimulateContract',
            link: '/react/api/hooks/useSimulateContract',
          },
          {
            text: 'useStorageAt',
            link: '/react/api/hooks/useStorageAt',
          },
          {
            text: 'useSwitchAccount',
            link: '/react/api/hooks/useSwitchAccount',
          },
          {
            text: 'useSwitchChain',
            link: '/react/api/hooks/useSwitchChain',
          },
          {
            text: 'useTransaction',
            link: '/react/api/hooks/useTransaction',
          },
          {
            text: 'useTransactionConfirmations',
            link: '/react/api/hooks/useTransactionConfirmations',
          },
          {
            text: 'useTransactionCount',
            link: '/react/api/hooks/useTransactionCount',
          },
          {
            text: 'useTransactionReceipt',
            link: '/react/api/hooks/useTransactionReceipt',
          },
          {
            text: 'useToken',
            link: '/react/api/hooks/useToken',
          },
          {
            text: 'useWaitForTransactionReceipt',
            link: '/react/api/hooks/useWaitForTransactionReceipt',
          },
          {
            text: 'useVerifyMessage',
            link: '/react/api/hooks/useVerifyMessage',
          },
          {
            text: 'useVerifyTypedData',
            link: '/react/api/hooks/useVerifyTypedData',
          },
          {
            text: 'useWalletClient',
            link: '/react/api/hooks/useWalletClient',
          },
          {
            text: 'useWatchAsset',
            link: '/react/api/hooks/useWatchAsset',
          },
          {
            text: 'useWatchBlocks',
            link: '/react/api/hooks/useWatchBlocks',
          },
          {
            text: 'useWatchBlockNumber',
            link: '/react/api/hooks/useWatchBlockNumber',
          },
          {
            text: 'useWatchContractEvent',
            link: '/react/api/hooks/useWatchContractEvent',
          },
          {
            text: 'useWatchPendingTransactions',
            link: '/react/api/hooks/useWatchPendingTransactions',
          },
          {
            text: 'useWriteContract',
            link: '/react/api/hooks/useWriteContract',
          },
        ],
      },
      {
        text: 'Miscellaneous',
        items: [
          { text: 'Actions', link: '/react/api/actions' },
          { text: 'Errors', link: '/react/api/errors' },
          {
            text: 'Utilities',
            collapsed: true,
            items: [
              {
                text: 'cookieToInitialState',
                link: '/react/api/utilities/cookieToInitialState',
              },
              { text: 'deserialize', link: '/react/api/utilities/deserialize' },
              {
                text: 'normalizeChainId',
                link: '/react/api/utilities/normalizeChainId',
              },
              { text: 'serialize', link: '/react/api/utilities/serialize' },
            ],
          },
        ],
      },
      {
        text: 'Experimental',
        items: [
          {
            text: 'useCallsStatus',
            link: '/react/api/hooks/useCallsStatus',
          },
          {
            text: 'useCapabilities',
            link: '/react/api/hooks/useCapabilities',
          },
          {
            text: 'useSendCalls',
            link: '/react/api/hooks/useSendCalls',
          },
          {
            text: 'useShowCallsStatus',
            link: '/react/api/hooks/useShowCallsStatus',
          },
          {
            text: 'useWaitForCallsStatus',
            link: '/react/api/hooks/useWaitForCallsStatus',
          },
        ],
      },
    ],
    '/vue': [
      {
        text: 'Introduction',
        items: [
          { text: 'Why Wagmi', link: '/vue/why' },
          { text: 'Installation', link: '/vue/installation' },
          { text: 'Getting Started', link: '/vue/getting-started' },
          { text: 'TypeScript', link: '/vue/typescript' },
        ],
      },
      {
        text: 'Guides',
        items: [
          {
            text: 'TanStack Query',
            link: '/vue/guides/tanstack-query',
          },
          {
            text: 'Viem',
            link: '/vue/guides/viem',
          },
          {
            text: 'Error Handling',
            link: '/vue/guides/error-handling',
          },
          {
            text: 'Chain Properties',
            link: '/vue/guides/chain-properties',
          },
          {
            text: 'SSR',
            link: '/vue/guides/ssr',
          },
          {
            text: 'Connect Wallet',
            link: '/vue/guides/connect-wallet',
          },
          {
            text: 'Send Transaction',
            link: '/vue/guides/send-transaction',
          },
          {
            text: 'Read from Contract',
            link: '/vue/guides/read-from-contract',
          },
          {
            text: 'Write to Contract',
            link: '/vue/guides/write-to-contract',
          },
          {
            text: 'FAQ / Troubleshooting',
            link: '/vue/guides/faq',
          },
        ],
      },
      {
        text: 'Configuration',
        items: [
          { text: 'createConfig', link: '/vue/api/createConfig' },
          { text: 'createStorage', link: '/vue/api/createStorage' },
          { text: 'Chains', link: '/vue/api/chains' },
          {
            text: 'Connectors',
            collapsed: true,
            link: '/vue/api/connectors',
            items: [
              {
                text: 'coinbaseWallet',
                link: '/vue/api/connectors/coinbaseWallet',
              },
              { text: 'injected', link: '/vue/api/connectors/injected' },
              {
                text: 'metaMask',
                link: '/vue/api/connectors/metaMask',
              },
              {
                text: 'mock',
                link: '/vue/api/connectors/mock',
              },
              {
                text: 'safe',
                link: '/vue/api/connectors/safe',
              },
              {
                text: 'walletConnect',
                link: '/vue/api/connectors/walletConnect',
              },
            ],
          },
          {
            text: 'Transports',
            collapsed: true,
            link: '/vue/api/transports',
            items: [
              {
                text: 'custom (EIP-1193)',
                link: '/vue/api/transports/custom',
              },
              {
                text: 'fallback',
                link: '/vue/api/transports/fallback',
              },
              {
                text: 'http',
                link: '/vue/api/transports/http',
              },
              {
                text: 'unstable_connector',
                link: '/vue/api/transports/unstable_connector',
              },
              {
                text: 'webSocket',
                link: '/vue/api/transports/webSocket',
              },
            ],
          },
          { text: 'WagmiPlugin', link: '/vue/api/WagmiPlugin' },
          { text: 'Nuxt', link: '/vue/api/Nuxt' },
        ],
      },
      {
        text: 'Composables',
        link: '/vue/api/composables',
        items: [
          { text: 'useAccount', link: '/vue/api/composables/useAccount' },
          {
            text: 'useAccountEffect',
            link: '/vue/api/composables/useAccountEffect',
          },
          {
            text: 'useBalance',
            link: '/vue/api/composables/useBalance',
          },
          {
            text: 'useBlockNumber',
            link: '/vue/api/composables/useBlockNumber',
          },
          {
            text: 'useBytecode',
            link: '/vue/api/composables/useBytecode',
          },
          { text: 'useChainId', link: '/vue/api/composables/useChainId' },
          { text: 'useChains', link: '/vue/api/composables/useChains' },
          { text: 'useClient', link: '/vue/api/composables/useClient' },
          { text: 'useConfig', link: '/vue/api/composables/useConfig' },
          { text: 'useConnect', link: '/vue/api/composables/useConnect' },
          {
            text: 'useConnections',
            link: '/vue/api/composables/useConnections',
          },
          {
            text: 'useConnectorClient',
            link: '/vue/api/composables/useConnectorClient',
          },
          {
            text: 'useConnectors',
            link: '/vue/api/composables/useConnectors',
          },
          {
            text: 'useDisconnect',
            link: '/vue/api/composables/useDisconnect',
          },
          {
            text: 'useEnsAddress',
            link: '/vue/api/composables/useEnsAddress',
          },
          {
            text: 'useEnsAvatar',
            link: '/vue/api/composables/useEnsAvatar',
          },
          {
            text: 'useEstimateGas',
            link: '/vue/api/composables/useEstimateGas',
          },
          {
            text: 'useReadContract',
            link: '/vue/api/composables/useReadContract',
          },
          {
            text: 'useReconnect',
            link: '/vue/api/composables/useReconnect',
          },
          {
            text: 'useSendTransaction',
            link: '/vue/api/composables/useSendTransaction',
          },
          {
            text: 'useSignMessage',
            link: '/vue/api/composables/useSignMessage',
          },
          {
            text: 'useSignTypedData',
            link: '/vue/api/composables/useSignTypedData',
          },
          {
            text: 'useSimulateContract',
            link: '/vue/api/composables/useSimulateContract',
          },
          {
            text: 'useSwitchAccount',
            link: '/vue/api/composables/useSwitchAccount',
          },
          {
            text: 'useSwitchChain',
            link: '/vue/api/composables/useSwitchChain',
          },
          {
            text: 'useTransaction',
            link: '/vue/api/composables/useTransaction',
          },
          {
            text: 'useTransactionReceipt',
            link: '/vue/api/composables/useTransactionReceipt',
          },
          {
            text: 'useWaitForTransactionReceipt',
            link: '/vue/api/composables/useWaitForTransactionReceipt',
          },
          {
            text: 'useWatchBlockNumber',
            link: '/vue/api/composables/useWatchBlockNumber',
          },
          {
            text: 'useWatchContractEvent',
            link: '/vue/api/composables/useWatchContractEvent',
          },
          {
            text: 'useWriteContract',
            link: '/vue/api/composables/useWriteContract',
          },
        ],
      },
      {
        text: 'Miscellaneous',
        items: [
          { text: 'Actions', link: '/vue/api/actions' },
          { text: 'Errors', link: '/vue/api/errors' },
          {
            text: 'Utilities',
            collapsed: true,
            items: [
              {
                text: 'deserialize',
                link: '/vue/api/utilities/deserialize',
              },
              { text: 'serialize', link: '/vue/api/utilities/serialize' },
            ],
          },
        ],
      },
    ],
    '/core': [
      {
        text: 'Introduction',
        items: [
          { text: 'Why Wagmi', link: '/core/why' },
          { text: 'Installation', link: '/core/installation' },
          { text: 'Getting Started', link: '/core/getting-started' },
          { text: 'TypeScript', link: '/core/typescript' },
        ],
      },
      {
        text: 'Guides',
        items: [
          {
            text: 'Viem',
            link: '/core/guides/viem',
          },
          {
            text: 'Framework Adapters',
            link: '/core/guides/framework-adapters',
          },
          {
            text: 'Error Handling',
            link: '/core/guides/error-handling',
          },
          {
            text: 'Ethers.js Adapters',
            link: '/core/guides/ethers',
          },
          // {
          //   text: 'Testing',
          //   link: '/core/guides/testing',
          // },
          {
            text: 'Chain Properties',
            link: '/core/guides/chain-properties',
          },
          {
            text: 'FAQ / Troubleshooting',
            link: '/core/guides/faq',
          },
          {
            text: 'Migrate from v1 to v2',
            link: '/core/guides/migrate-from-v1-to-v2',
          },
        ],
      },
      {
        text: 'Configuration',
        items: [
          { text: 'createConfig', link: '/core/api/createConfig' },
          { text: 'createConnector', link: '/core/api/createConnector' },
          { text: 'createStorage', link: '/core/api/createStorage' },
          { text: 'Chains', link: '/core/api/chains' },
          {
            text: 'Connectors',
            collapsed: true,
            link: '/core/api/connectors',
            items: [
              {
                text: 'coinbaseWallet',
                link: '/core/api/connectors/coinbaseWallet',
              },
              { text: 'injected', link: '/core/api/connectors/injected' },
              {
                text: 'metaMask',
                link: '/core/api/connectors/metaMask',
              },
              {
                text: 'mock',
                link: '/core/api/connectors/mock',
              },
              {
                text: 'safe',
                link: '/core/api/connectors/safe',
              },
              {
                text: 'walletConnect',
                link: '/core/api/connectors/walletConnect',
              },
            ],
          },
          {
            text: 'Transports',
            collapsed: true,
            link: '/core/api/transports',
            items: [
              {
                text: 'custom (EIP-1193)',
                link: '/core/api/transports/custom',
              },
              {
                text: 'fallback',
                link: '/core/api/transports/fallback',
              },
              {
                text: 'http',
                link: '/core/api/transports/http',
              },
              {
                text: 'unstable_connector',
                link: '/core/api/transports/unstable_connector',
              },
              {
                text: 'webSocket',
                link: '/core/api/transports/webSocket',
              },
            ],
          },
        ],
      },
      {
        text: 'Actions',
        link: '/core/api/actions',
        items: [
          {
            text: 'call',
            link: '/core/api/actions/call',
          },
          { text: 'connect', link: '/core/api/actions/connect' },
          { text: 'deployContract', link: '/core/api/actions/deployContract' },
          { text: 'disconnect', link: '/core/api/actions/disconnect' },
          {
            text: 'estimateFeesPerGas',
            link: '/core/api/actions/estimateFeesPerGas',
          },
          { text: 'estimateGas', link: '/core/api/actions/estimateGas' },
          {
            text: 'estimateMaxPriorityFeePerGas',
            link: '/core/api/actions/estimateMaxPriorityFeePerGas',
          },
          { text: 'getAccount', link: '/core/api/actions/getAccount' },
          { text: 'getBalance', link: '/core/api/actions/getBalance' },
          {
            text: 'getBlock',
            link: '/core/api/actions/getBlock',
          },
          {
            text: 'getBlockNumber',
            link: '/core/api/actions/getBlockNumber',
          },
          {
            text: 'getBlockTransactionCount',
            link: '/core/api/actions/getBlockTransactionCount',
          },
          {
            text: 'getBytecode',
            link: '/core/api/actions/getBytecode',
          },
          { text: 'getChainId', link: '/core/api/actions/getChainId' },
          { text: 'getChains', link: '/core/api/actions/getChains' },
          {
            text: 'getClient',
            link: '/core/api/actions/getClient',
          },
          {
            text: 'getConnections',
            link: '/core/api/actions/getConnections',
          },
          {
            text: 'getConnectorClient',
            link: '/core/api/actions/getConnectorClient',
          },
          {
            text: 'getConnectors',
            link: '/core/api/actions/getConnectors',
          },
          {
            text: 'getEnsAddress',
            link: '/core/api/actions/getEnsAddress',
          },
          { text: 'getEnsAvatar', link: '/core/api/actions/getEnsAvatar' },
          { text: 'getEnsName', link: '/core/api/actions/getEnsName' },
          {
            text: 'getEnsResolver',
            link: '/core/api/actions/getEnsResolver',
          },
          {
            text: 'getEnsText',
            link: '/core/api/actions/getEnsText',
          },
          {
            text: 'getFeeHistory',
            link: '/core/api/actions/getFeeHistory',
          },
          {
            text: 'getGasPrice',
            link: '/core/api/actions/getGasPrice',
          },
          {
            text: 'getProof',
            link: '/core/api/actions/getProof',
          },
          {
            text: 'getPublicClient',
            link: '/core/api/actions/getPublicClient',
          },
          {
            text: 'getStorageAt',
            link: '/core/api/actions/getStorageAt',
          },
          { text: 'getToken', link: '/core/api/actions/getToken' },
          {
            text: 'getTransaction',
            link: '/core/api/actions/getTransaction',
          },
          {
            text: 'getTransactionConfirmations',
            link: '/core/api/actions/getTransactionConfirmations',
          },
          {
            text: 'getTransactionCount',
            link: '/core/api/actions/getTransactionCount',
          },
          {
            text: 'getTransactionReceipt',
            link: '/core/api/actions/getTransactionReceipt',
          },
          {
            text: 'getWalletClient',
            link: '/core/api/actions/getWalletClient',
          },
          {
            text: 'multicall',
            link: '/core/api/actions/multicall',
          },
          {
            text: 'prepareTransactionRequest',
            link: '/core/api/actions/prepareTransactionRequest',
          },
          { text: 'reconnect', link: '/core/api/actions/reconnect' },
          {
            text: 'readContract',
            link: '/core/api/actions/readContract',
          },
          {
            text: 'readContracts',
            link: '/core/api/actions/readContracts',
          },
          {
            text: 'sendTransaction',
            link: '/core/api/actions/sendTransaction',
          },
          {
            text: 'signMessage',
            link: '/core/api/actions/signMessage',
          },
          {
            text: 'signTypedData',
            link: '/core/api/actions/signTypedData',
          },
          {
            text: 'simulateContract',
            link: '/core/api/actions/simulateContract',
          },
          {
            text: 'switchAccount',
            link: '/core/api/actions/switchAccount',
          },
          {
            text: 'switchChain',
            link: '/core/api/actions/switchChain',
          },
          {
            text: 'verifyMessage',
            link: '/core/api/actions/verifyMessage',
          },
          {
            text: 'verifyTypedData',
            link: '/core/api/actions/verifyTypedData',
          },
          {
            text: 'waitForTransactionReceipt',
            link: '/core/api/actions/waitForTransactionReceipt',
          },
          {
            text: 'watchAccount',
            link: '/core/api/actions/watchAccount',
          },
          {
            text: 'watchAsset',
            link: '/core/api/actions/watchAsset',
          },
          {
            text: 'watchBlocks',
            link: '/core/api/actions/watchBlocks',
          },
          {
            text: 'watchBlockNumber',
            link: '/core/api/actions/watchBlockNumber',
          },
          {
            text: 'watchChainId',
            link: '/core/api/actions/watchChainId',
          },
          {
            text: 'watchClient',
            link: '/core/api/actions/watchClient',
          },
          {
            text: 'watchConnections',
            link: '/core/api/actions/watchConnections',
          },
          {
            text: 'watchConnectors',
            link: '/core/api/actions/watchConnectors',
          },
          {
            text: 'watchContractEvent',
            link: '/core/api/actions/watchContractEvent',
          },
          {
            text: 'watchPendingTransactions',
            link: '/core/api/actions/watchPendingTransactions',
          },
          {
            text: 'watchPublicClient',
            link: '/core/api/actions/watchPublicClient',
          },
          {
            text: 'writeContract',
            link: '/core/api/actions/writeContract',
          },
        ],
      },
      {
        text: 'Miscellaneous',
        items: [
          { text: 'Errors', link: '/core/api/errors' },
          {
            text: 'Utilities',
            collapsed: true,
            items: [
              {
                text: 'cookieToInitialState',
                link: '/core/api/utilities/cookieToInitialState',
              },
              { text: 'deserialize', link: '/core/api/utilities/deserialize' },
              {
                text: 'normalizeChainId',
                link: '/core/api/utilities/normalizeChainId',
              },
              { text: 'serialize', link: '/core/api/utilities/serialize' },
            ],
          },
        ],
      },
      {
        text: 'Experimental',
        items: [
          {
            text: 'getCallsStatus',
            link: '/core/api/actions/getCallsStatus',
          },
          {
            text: 'getCapabilities',
            link: '/core/api/actions/getCapabilities',
          },
          {
            text: 'sendCalls',
            link: '/core/api/actions/sendCalls',
          },
          {
            text: 'showCallsStatus',
            link: '/core/api/actions/showCallsStatus',
          },
          {
            text: 'waitForCallsStatus',
            link: '/core/api/actions/waitForCallsStatus',
          },
        ],
      },
    ],
    '/cli': [
      {
        text: 'Introduction',
        items: [
          { text: 'Why Wagmi CLI', link: '/cli/why' },
          { text: 'Installation', link: '/cli/installation' },
          { text: 'Getting Started', link: '/cli/getting-started' },
        ],
      },
      {
        text: 'Guides',
        items: [
          {
            text: 'Migrate from v1 to v2',
            link: '/cli/guides/migrate-from-v1-to-v2',
          },
        ],
      },
      {
        text: 'Config File',
        items: [
          {
            text: 'Configuring CLI',
            link: '/cli/config/configuring-cli',
          },
          { text: 'Config Options', link: '/cli/config/options' },
        ],
      },
      {
        text: 'Commands',
        link: '/cli/api/commands',
        items: [
          {
            text: 'generate',
            link: '/cli/api/commands/generate',
          },
          {
            text: 'init',
            link: '/cli/api/commands/init',
          },
        ],
      },
      {
        text: 'Plugins',
        link: '/cli/api/plugins',
        items: [
          { text: 'actions', link: '/cli/api/plugins/actions' },
          { text: 'blockExplorer', link: '/cli/api/plugins/blockExplorer' },
          { text: 'etherscan', link: '/cli/api/plugins/etherscan' },
          { text: 'fetch', link: '/cli/api/plugins/fetch' },
          { text: 'foundry', link: '/cli/api/plugins/foundry' },
          { text: 'hardhat', link: '/cli/api/plugins/hardhat' },
          { text: 'react', link: '/cli/api/plugins/react' },
          { text: 'sourcify', link: '/cli/api/plugins/sourcify' },
        ],
      },
      {
        text: 'create-wagmi',
        link: '/cli/create-wagmi',
      },
    ],
    '/dev': [
      {
        text: 'Dev',
        items: [
          { text: 'Contributing', link: '/dev/contributing' },
          { text: 'Creating Connectors', link: '/dev/creating-connectors' },
        ],
      },
    ],
    '/examples': [
      {
        text: 'React',
        items: [
          { text: 'Connect Wallet', link: '/examples/connect-wallet' },
          { text: 'Send Transaction', link: '/examples/send-transaction' },
          { text: 'Write Contract', link: '/examples/contract-write' },
          {
            text: 'Write Contract (Dynamic Args)',
            link: '/examples/contract-write-dynamic',
          },
          { text: 'Sign Message', link: '/examples/sign-message' },
          {
            text: 'Sign In With Ethereum',
            link: '/examples/sign-in-with-ethereum',
          },
        ],
      },
    ],
  } satisfies DefaultTheme.Sidebar
}
</file>

<file path="site/cli/api/commands/generate.md">
# generate

Generates code based on configuration, using `contracts` and `plugins`.

## Usage

```bash
wagmi generate 
```

## Options

### -c, --config \<path\>

`string`

Path to config file.

```bash
wagmi generate --config wagmi.config.ts
```

### -r, --root \<path\>

`string`

Root path to resolve config from.

```bash
wagmi generate --root path/to/root
```

### -w, --watch

`boolean`

Watch for changes (for plugins that support watch mode).

```bash
wagmi generate --watch
```

### -h, --help

Displays help message.

```bash
wagmi generate --help
```
</file>

<file path="site/cli/api/commands/init.md">
# init

Creates configuration file. If TypeScript is detected, the config file will use TypeScript and be named `wagmi.config.ts`. Otherwise, the config file will use JavaScript and be named `wagmi.config.js`.

## Usage

```bash
wagmi init 
```

## Options

### -c, --config \<path\>

`string`

Path to config file.

```bash
wagmi init --config wagmi.config.ts
```

### -r, --root \<path\>

`string`

Root path to resolve config from.

```bash
wagmi init --root path/to/root
```

### -h, --help

Displays help message.

```bash
wagmi init --help
```
</file>

<file path="site/cli/api/plugins/actions.md">
# actions

Plugin for type-safe VanillaJS actions.

## Import

```ts
import { actions } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6}
import { defineConfig } from '@wagmi/cli'
import { actions } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    actions(),
  ],
})
```

## Configuration

```ts
import { type ActionsConfig } from '@wagmi/cli/plugins'
```

### getActionName

`` 'legacy' | ((options: { contractName: string; type: 'read' | 'simulate' | 'watch' | 'write' }) => `use${string}`) ``

- Function for setting custom hook names.
- Defaults to `` `${type}${contractName}` ``. For example, `readErc20`, `simulateErc20`, `watchErc20Event`, `writeErc20`.
- When `'legacy'` (deprecated), hook names are set to `@wagmi/cli@1` format.

```ts
import { defineConfig } from '@wagmi/cli'
import { actions } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    actions({
      getActionName({ contractName, type }) { // [!code focus]
        return `${contractName}__${type}` // [!code focus]
      }, // [!code focus]
    }),
  ],
})
```

### overridePackageName

`'@wagmi/core' | 'wagmi'`

- Override detected import source.
- Defaults to `'wagmi'` or `'@wagmi/core'` depending on which package is installed.

```ts
import { defineConfig } from '@wagmi/cli'
import { actions } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    actions({
      overridePackageName: 'wagmi', // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/api/plugins/blockExplorer.md">
# blockExplorer

Plugin for fetching ABIs from block explorers that supports the `?module=contract&action=getabi` API format.

## Import

```ts
import { blockExplorer } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6-14}
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      baseUrl: 'https://api.etherscan.io/v2/api',
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

## Configuration

```ts
import { type BlockExplorerConfig } from '@wagmi/cli/plugins'
```

### apiKey

`string | undefined`

API key for block explorer. Appended to the request URL as query param `&apikey=${apiKey}`.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      apiKey: process.env.ETHERSCAN_API_KEY, // [!code focus]
      baseUrl: 'https://api.etherscan.io/v2/api',
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

### baseUrl

`string`

Base URL for block explorer.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      baseUrl: 'https://api.etherscan.io/v2/api', // [!code focus]
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

### cacheDuration

`number | undefined`

Duration in milliseconds to cache ABIs. Defaults to `1_800_000` (30 minutes).

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      baseUrl: 'https://api.etherscan.io/v2/api',
      cacheDuration: 300_000, // [!code focus]
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

### chainId

`number | undefined`

Chain ID for block explorer. Appended to the request URL as query param `&chainId=${chainId}`.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      apiKey: process.env.ETHERSCAN_API_KEY,
      baseUrl: 'https://api.etherscan.io/v2/api',
      chainId: 1, // [!code focus]
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```


### contracts

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      baseUrl: 'https://api.etherscan.io/v2/api',
      contracts: [ // [!code focus]
        { // [!code focus]
          name: 'Wagmigotchi', // [!code focus]
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    }),
  ],
})
```

### getAddress

`((config: { address: Address | Record<number, Address> }) => Address) | undefined`

- Function to get address from contract config.
- Defaults to `({ address }) => typeof address === 'string' ? address : Object.values(address)[0]`.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      baseUrl: 'https://api.etherscan.io/v2/api',
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      getAddress({ address }) { // [!code focus]
        if (typeof address === 'string') return address // [!code focus]
        return Object.values(address)[0] // [!code focus]
      }, // [!code focus]
    }),
  ],
})
```

### name

`string`

- Name of source.
- Defaults to `'Block Explorer'`.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    blockExplorer({
      baseUrl: 'https://api.etherscan.io/v2/api',
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      name: 'Etherscan', // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/api/plugins/etherscan.md">
# etherscan

Plugin for fetching ABIs from [Etherscan](https://etherscan.io) and adding into `contracts` config.

## Import

```ts
import { etherscan } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6-14}
import { defineConfig } from '@wagmi/cli'
import { etherscan } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY,
      chainId: 1,
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

## Configuration

```ts
import { type EtherscanConfig } from '@wagmi/cli/plugins'
```

### apiKey

`string`

Etherscan API key. Etherscan API keys are specific per network and include testnets (e.g. Ethereum Mainnet and Sepolia share same API key).

```ts
import { defineConfig } from '@wagmi/cli'
import { etherscan } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY, // [!code focus]
      chainId: 1,
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

### cacheDuration

`number | undefined`

- Duration in milliseconds to cache ABIs.
- Defaults to `1_800_000` (30 minutes).

```ts
import { defineConfig } from '@wagmi/cli'
import { etherscan } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY,
      cacheDuration: 300_000, // [!code focus]
      chainId: 1,
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
    }),
  ],
})
```

### chainId

`number`

Chain ID to use for fetching ABI. If [`address`](/cli/config/options#address) is an object, `chainId` is used to select the address.

View supported chains on the [Etherscan docs](https://docs.etherscan.io/etherscan-v2/getting-started/supported-chains).

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY,
      chainId: 1, // [!code focus]
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
        {
          name: 'EnsRegistry',
          address: {
            1: '0x314159265dd8dbb310642f98f50c066173c1259b',
            5: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
          },
        },
      ],
    }),
  ],
})
```

### contracts

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

```ts
import { defineConfig } from '@wagmi/cli'
import { etherscan } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY,
      chainId: 1,
      contracts: [ // [!code focus]
        { // [!code focus]
          name: 'Wagmigotchi', // [!code focus]
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    }),
  ],
})
```

### tryFetchProxyImplementation

`boolean | undefined`

- Whether to try fetching proxy implementation address of the contract.
- Defaults to `false`.

```ts
import { defineConfig } from '@wagmi/cli'
import { blockExplorer } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY,
      chainId: 1, 
      contracts: [
        {
          name: 'FiatToken',
          address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
        },
      ],
      tryFetchProxyImplementation: true, // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/api/plugins/fetch.md">
# fetch

Plugin for fetching and parsing ABIs from network resource with `fetch`.

## Import

```ts
import { fetch } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6-23}
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    fetch({
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      request(contract) {
        if (!contract.address) throw new Error('address is required')
        const address =
          typeof contract.address === 'string'
            ? contract.address
            : Object.values(contract.address)[0]
        return {
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
        }
      },
    }),
  ],
})
```


## Configuration

```ts
import { type FetchConfig } from '@wagmi/cli/plugins'
```

### cacheDuration

`number | undefined`

- Duration in milliseconds to cache ABIs.
- Defaults to `1_800_000` (30 minutes).

```ts
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    fetch({
      cacheDuration: 300_000, // [!code focus]
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      request(contract) {
        if (!contract.address) throw new Error('address is required')
        const address =
          typeof contract.address === 'string'
            ? contract.address
            : Object.values(contract.address)[0]
        return {
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
        }
      },
    }),
  ],
})
```

### contracts

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

```ts
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    fetch({
      contracts: [ // [!code focus]
        { // [!code focus]
          name: 'Wagmigotchi', // [!code focus]
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
      request(contract) {
        if (!contract.address) throw new Error('address is required')
        const address =
          typeof contract.address === 'string'
            ? contract.address
            : Object.values(contract.address)[0]
        return {
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
        }
      },
    }),
  ],
})

```

### getCacheKey

`((config: { contract: { address: Address | Record<chainId, Address> | undefined; name: string } }) => string) | undefined`

- Function for creating a cache key for contract. Contract data is cached at `~/.wagmi-cli/plugins/fetch/cache/`.
- Defaults to `({ contract }) => JSON.stringify(contract)`.

```ts
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    fetch({
      contracts: [
        {
          name: 'wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      getCacheKey({ contract }) { // [!code focus]
        if (typeof contract.address === 'string') // [!code focus]
          return `${name}:${contract.address}` // [!code focus]
        return `${name}:${JSON.stringify(contract.address)}` // [!code focus]
      }, // [!code focus]
      request(contract) {
        if (!contract.address) throw new Error('address is required')
        const address =
          typeof contract.address === 'string'
            ? contract.address
            : Object.values(contract.address)[0]
        return {
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
        }
      },
    }),
  ],
})

```

### name

`string`

- Name of source.
- Defaults to `'Fetch'`.

```ts
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    fetch({
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      name: 'Etherscan', // [!code focus]
      request(contract) {
        if (!contract.address) throw new Error('address is required')
        const address =
          typeof contract.address === 'string'
            ? contract.address
            : Object.values(contract.address)[0]
        return {
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
        }
      },
    }),
  ],
})
```

### parse

`((config: { response: Response }) => Abi | Promise<Abi>) | undefined`

- Function for parsing ABI from fetch response.
- Defaults to `({ response }) => response.json()`

```ts
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'
 
export default defineConfig({
  plugins: [
    fetch({
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      async parse({ response }) { // [!code focus]
        const json = await response.json() // [!code focus]
        if (json.status === '0') throw new Error(json.message) // [!code focus]
        return json.result // [!code focus]
      }, // [!code focus]
      request(contract) {
        if (!contract.address) throw new Error('address is required')
        const address =
          typeof contract.address === 'string'
            ? contract.address
            : Object.values(contract.address)[0]
        return {
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
        }
      },
    }),
  ],
})
```

### request

`(config: { address?: Address | Record<chainId, Address> | undefined }) => { url: RequestInfo; init?: RequestInit | undefined } | Promise<{ url: RequestInfo; init?: RequestInit | undefined }>`

Function for returning a request to fetch ABI from.

```ts
import { defineConfig } from '@wagmi/cli'
import { fetch } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    fetch({
      contracts: [
        {
          name: 'Wagmigotchi',
          address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
        },
      ],
      request(contract) { // [!code focus]
        if (!contract.address) throw new Error('address is required') // [!code focus]
        const address = // [!code focus]
          typeof contract.address === 'string' // [!code focus]
            ? contract.address // [!code focus]
            : Object.values(contract.address)[0] // [!code focus]
        return { // [!code focus]
          url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`, // [!code focus]
        } // [!code focus]
      }, // [!code focus]
    }),
  ],
})

```
</file>

<file path="site/cli/api/plugins/foundry.md">
# foundry

Plugin for resolving ABIs from [Foundry](https://github.com/foundry-rs/foundry) projects. Supports [`watch`](/cli/api/commands/generate#w-watch) mode.

## Import

```ts
import { foundry } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6-8}
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({
      project: '../hello_foundry',
    }),
  ],
})
```

## Configuration

```ts
import { type FoundryConfig } from '@wagmi/cli/plugins'
```

### artifacts

`string | undefined`

- Project's artifacts directory. Same as your `foundry.toml`/`forge`s `--out` (`-o`) option.
- Defaults to `'out/'`.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({
      artifacts: 'out/', // [!code focus]
    }),
  ],
})
```

### deployments

`{ [key: string]: address?: Address | Record<chainId, Address> | undefined } | undefined`

Mapping of addresses to attach to artifacts.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({
      deployments: { // [!code focus]
        Counter: { // [!code focus]
          1: '0x314159265dd8dbb310642f98f50c066173c1259b', // [!code focus]
          5: '0x112234455c3a32fd11230c42e7bccd4a84e02010', // [!code focus]
        }, // [!code focus]
      }, // [!code focus]
    }),
  ],
})
```

### exclude

`string[] | undefined`

Artifact files to exclude relative to `artifacts`. Supports glob patterns.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({
      exclude: [ // [!code focus]
        // the following patterns are excluded by default // [!code focus]
        'Common.sol/**', // [!code focus]
        'Components.sol/**', // [!code focus]
        'Script.sol/**', // [!code focus]
        'StdAssertions.sol/**', // [!code focus]
        'StdInvariant.sol/**', // [!code focus]
        'StdError.sol/**', // [!code focus]
        'StdCheats.sol/**', // [!code focus]
        'StdMath.sol/**', // [!code focus]
        'StdJson.sol/**', // [!code focus]
        'StdStorage.sol/**', // [!code focus]
        'StdUtils.sol/**', // [!code focus]
        'Vm.sol/**', // [!code focus]
        'console.sol/**', // [!code focus]
        'console2.sol/**', // [!code focus]
        'test.sol/**', // [!code focus]
        '**.s.sol/*.json', // [!code focus]
        '**.t.sol/*.json', // [!code focus]
      ], // [!code focus]
    }),
  ],
})
```

### forge

`{ clean?: boolean | undefined; build?: boolean | undefined; path?: string | undefined; rebuild?: boolean | undefined } | undefined`

Options for `forge`.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({
      forge: {  // [!code focus]
        clean: true,  // [!code focus]
        build: true,  // [!code focus]
        path: 'path/to/forge',  // [!code focus]
        rebuild: true,  // [!code focus]
      },  // [!code focus]
    }),
  ],
})
```

#### clean

- Remove build artifacts and cache directories on start up.
- Defaults to `false`.

#### build

- Build Foundry project before fetching artifacts.
- Defaults to `true`.

#### path

- Path to `forge` executable command.
- Defaults to `forge`.

#### rebuild

- Rebuild every time a watched file or directory is changed. Used for setting up [`watch`](/cli/api/commands/generate#w-watch) mode.
- Defaults to `true`.

### include

`string[] | undefined`

Artifact files to include relative to `artifacts`. Supports glob patterns.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({
      include: [  // [!code focus]
        // the following patterns are included by default  // [!code focus]
        '*.json',  // [!code focus]
      ],  // [!code focus]
    }),
  ],
})
```

### namePrefix

`string | undefined`

Prefix to prepend to artifact names. Useful for preventing name collisions between contracts from other sources.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({  // [!code focus]
      namePrefix: 'HelloFoundry',  // [!code focus]
    }),  // [!code focus]
  ],
})
```

### project

`string | undefined`

- Path to Foundry project.
- Defaults to Foundry configuration using `forge config --json` command.

```ts
import { defineConfig } from '@wagmi/cli'
import { foundry } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    foundry({ // [!code focus]
      project: '../hello_foundry', // [!code focus]
    }), // [!code focus]
  ],
})
```
</file>

<file path="site/cli/api/plugins/hardhat.md">
# hardhat

Plugin for resolving ABIs from [Hardhat](https://hardhat.org) projects. Supports [`watch`](/cli/api/commands/generate#w-watch) mode.

```ts
import { hardhat } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6-8}
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      project: '../hello_hardhat',
    }),
  ],
})
```

## Configuration

```ts
import { type HardhatConfig } from '@wagmi/cli/plugins'
```

### artifacts

`string | undefined`

- Project's artifacts directory. Same as your project's `artifacts` [path configuration](https://hardhat.org/hardhat-runner/docs/config#path-configuration) option.
- Defaults to `'artifacts/'`.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      artifacts: 'out/', // [!code focus]
      project: '../hello_hardhat',
    }),
  ],
})
```

### deployments

`{ [key: string]: address?: Address | Record<chainId, Address> | undefined } | undefined`

Mapping of addresses to attach to artifacts.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      project: '../hello_hardhat',
      deployments: { // [!code focus]
        Counter: { // [!code focus]
          1: '0x314159265dd8dbb310642f98f50c066173c1259b', // [!code focus]
          5: '0x112234455c3a32fd11230c42e7bccd4a84e02010', // [!code focus]
        }, // [!code focus]
      }, // [!code focus]
    }),
  ],
})
```

### exclude

`string[] | undefined`

Artifact files to exclude relative to `artifacts`. Supports glob patterns.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      exclude: [ // [!code focus]
        // the following patterns are excluded by default // [!code focus]
        'build-info/**', // [!code focus]
        '*.dbg.json', // [!code focus]
      ], // [!code focus]
      project: '../hello_hardhat',
    }),
  ],
})
```

### commands

`{ clean?: string | boolean | undefined; build?: string | boolean | undefined; rebuild?: string | boolean | undefined } | undefined`

Hardhat command options.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      commands: { // [!code focus]
        clean: 'pnpm hardhat clean', // [!code focus]
        build: 'pnpm hardhat compile', // [!code focus]
        rebuild: 'pnpm hardhat compile', // [!code focus]
      }, // [!code focus]
      project: '../hello_hardhat',
    }),
  ],
})
```

#### clean

- Remove build artifacts and cache directories on start up.
- Defaults to `'${packageManger} hardhat clean'`.

#### build

- Build Foundry project before fetching artifacts.
- Defaults to `'${packageManger} hardhat compile'`.

#### rebuild

- Command to run when watched file or directory is changed. Used for setting up [`watch`](/cli/api/commands/generate#w-watch) mode.
- Defaults to `'${packageManger} hardhat compile'`.

### include

`string[] | undefined`

Artifact files to include relative to `artifacts`. Supports glob patterns.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      include: [ // [!code focus]
        // the following patterns are included by default // [!code focus]
        '*.json', // [!code focus]
      ], // [!code focus]
      project: '../hello_hardhat',
    }),
  ],
})
```

### namePrefix

`string | undefined`

Prefix to prepend to artifact names. Useful for preventing name collisions between contracts from other sources.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      namePrefix: 'HelloHardhat', // [!code focus]
      project: '../hello_hardhat',
    }),
  ],
})
```

### project

`string`

Path to Hardhat project.

```ts
import { defineConfig } from '@wagmi/cli'
import { hardhat } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    hardhat({
      project: '../hello_hardhat', // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/api/plugins/react.md">
# react

Plugin for generating type-safe [Wagmi Hooks](/react/api/hooks).

## Import

```ts
import { react } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6}
import { defineConfig } from '@wagmi/cli'
import { react } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    react(),
  ],
})
```

## Configuration

```ts
import { type ReactConfig } from '@wagmi/cli/plugins'
```

### getHookName

`` 'legacy' | ((options: { contractName: string; type: 'read' | 'simulate' | 'watch' | 'write' }) => `use${string}`) ``

- Function for setting custom hook names.
- Defaults to `` `use${type}${contractName}` ``. For example, `useReadErc20`, `useSimulateErc20`, `useWatchErc20Event`, `useWriteErc20`.
- When `'legacy'` (deprecated), hook names are set to `@wagmi/cli@1` format.

```ts
import { defineConfig } from '@wagmi/cli'
import { react } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    react({
      getHookName({ contractName, type }) { // [!code focus]
        return `use${contractName}__${type}` // [!code focus]
      }, // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/api/plugins/sourcify.md">
# sourcify

Plugin for fetching ABIs from [Sourcify](https://sourcify.dev/). Sourcify is a decentralized, open-source, smart contract verification and metadata repository.

## Import

```ts
import { sourcify } from '@wagmi/cli/plugins'
```

## Usage

```ts{2,6-13}
import { defineConfig } from '@wagmi/cli'
import { sourcify } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    sourcify({
      contracts: [
        {
          name: 'deposit',
          address: '0x00000000219ab540356cbb839cbe05303d7705fa',
        },
      ],
    }),
  ],
})
```

## Configuration

```ts
import { type SourcifyConfig } from '@wagmi/cli/plugins'
```

### cacheDuration

`number | undefined`

- Duration in milliseconds to cache ABIs.
- Defaults to `1_800_000` (30 minutes).

```ts
import { defineConfig } from '@wagmi/cli'
import { sourcify } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    sourcify({
      cacheDuration: 300_000, // [!code focus]
      chainId: 100,
      contracts: [
        {
          name: 'Deposit',
          address: '0x00000000219ab540356cbb839cbe05303d7705fa',
        },
      ],
    }),
  ],
})
```

### chainId

`number`

Chain ID to use for fetching ABI. If `address` is an object, `chainId` is used to select the address. See [Sourcify docs](https://docs.sourcify.dev/docs/chains) for supported chains.

```ts
import { defineConfig } from '@wagmi/cli'
import { sourcify } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    sourcify({
      chainId: 100, // [!code focus]
      contracts: [
        {
          name: 'Community',
          address: {
            100: '0xC4c622862a8F548997699bE24EA4bc504e5cA865',
            137: '0xC4c622862a8F548997699bE24EA4bc504e5cA865',
          },
        },
      ],
    }),
  ],
})
```

### contracts

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

```ts
import { defineConfig } from '@wagmi/cli'
import { sourcify } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    sourcify({
      chainId: 100,
      contracts: [ // [!code focus]
        { // [!code focus]
          name: 'Deposit', // [!code focus]
          address: '0x00000000219ab540356cbb839cbe05303d7705fa', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/api/commands.md">
# Commands

## Available Commands

- [`init`](/cli/api/commands/init) Creates configuration file.
- [`generate`](/cli/api/commands/generate) Generates code based on configuration, using `contracts` and `plugins`.

## Display Info

### `-h`, `--help`

Show help message when `-h`, `--help` flags appear.

::: code-group
```bash [pnpm]
pnpm wagmi --help
```

```bash [npm]
npx wagmi --help
```

```bash [yarn]
yarn wagmi --help
```

```bash [bun]
bun wagmi --help
```
:::

### `-v`, `--version`

Show version number when `-v`, `--version` flags appear.

::: code-group
```bash [pnpm]
pnpm wagmi --version
```

```bash [npm]
npx wagmi --version
```

```bash [yarn]
yarn wagmi --version
```

```bash [bun]
bun wagmi --version
```
:::
</file>

<file path="site/cli/api/plugins.md">
# Plugins

Plugins for managing ABIs, generating code, and more.

## Import

Import via the `'@wagmi/cli/plugins'` entrypoint.

```ts
import { etherscan } from '@wagmi/cli/plugins'
```

## Available Plugins

- [`actions`](/cli/api/plugins/actions) Generate type-safe VanillaJS actions from configuration `contracts`.
- [`blockExplorer`](/cli/api/plugins/blockExplorer) Fetch ABIs from Block Explorers that support `?module=contract&action=getabi`.
- [`etherscan`](/cli/api/plugins/etherscan) Fetch ABIs from Etherscan and add into configuration.
- [`fetch`](/cli/api/plugins/fetch) Fetch and parse ABIs from network resource with `fetch`.
- [`foundry`](/cli/api/plugins/foundry) Generate ABIs and watch for Foundry project changes.
- [`hardhat`](/cli/api/plugins/hardhat) Generate ABIs and watch for Hardhat projects changes.
- [`react`](/cli/api/plugins/react) Generate type-safe React Hooks from configuration `contracts`.
- [`sourcify`](/cli/api/plugins/sourcify) Fetch ABIs from Sourcify from configuration `contracts`.

## Create Plugin

Creating plugins to hook into the CLI is quite simple. Plugins most commonly inject contracts into `contracts` config, e.g. [`etherscan`](/cli/api/plugins/etherscan), and/or generate code using the `run` option, e.g. [`react`](/cli/api/plugins/react). All you need to do is write a function that returns the `Plugin` type.

```ts{3-8}
import { type Plugin, defineConfig } from '@wagmi/cli'

function myPlugin(): Plugin {
  // `name` is the only required property.
  name: 'MyPlugin',
  // You likely want to at least include `contracts` or `run`.
  // ...
}

export default defineConfig({
  out: 'src/generated.ts',
  plugins: [myPlugin()],
})
```
</file>

<file path="site/cli/config/configuring-cli.md">
# Configuring CLI

When running `wagmi` from the command line, `@wagmi/cli` will automatically try to resolve a config file named `wagmi.config.js` or `wagmi.config.ts` inside the project root. The most basic config file looks like this:

::: code-group
```js [wagmi.config.js]
export default {
  // config options
}
```
:::

Note `@wagmi/cli` supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. `"type": "module"` in package.json. In this case, the config file is auto pre-processed before load.

You can also explicitly specify a config file to use with the `--config`/`-c` CLI option (resolved relative to the current directory):

```bash
wagmi --config my-config.js
```

To scaffold a config file quickly, check out the [`init`](/cli/api/commands/init) command.

## Config Intellisense

Since Wagmi CLI ships with TypeScript typings, you can use your editor's intellisense with [JSDoc](https://jsdoc.app) type hints:

::: code-group
```js [wagmi.config.js]
/** @type {import('@wagmi/cli').Config} */
export default {
  // ...
}
```
:::

Alternatively, you can use the `defineConfig` utility which should provide intellisense without the need for JSDoc annotations:

::: code-group
```js [wagmi.config.js]
import { defineConfig } from '@wagmi/cli'

export default defineConfig({
  // ...
})
```
:::

Wagmi CLI also directly supports TypeScript config files. You can use `wagmi.config.ts` with the `defineConfig` helper as well.

## Conditional Config

If the config needs to conditionally determine options based on the environment, it can export a function instead:

::: code-group
```js [wagmi.config.js]
export default defineConfig(() => {
  if (process.env.NODE_ENV === 'dev') {
    return {
      // dev specific config
    }
  } else {
    return {
      // production specific config
    }
  }
})
```
:::

## Async Config

If the config needs to call async function, it can export a async function instead:

::: code-group
```js [wagmi.config.js]
export default defineConfig(async () => {
  const data = await asyncFunction()
  return {
    // ...
  }
})
```
:::

This can be useful for resolving external resources from the network or filesystem that are required for configuration ahead of running a command.

## Array Config

The config can also be represented either as a pre-defined array or returned as an array from a function:

::: code-group
```js [wagmi.config.js]
export default defineConfig([
  {
  // config 1
  },
  {
  // config 2
  },
])
```
:::

## Environment Variables

Environmental Variables can be obtained from `process.env` as usual.

Note that Wagmi CLI doesn't load `.env` files by default as the files to load can only be determined after evaluating the config. However, you can use the exported `loadEnv` utility to load the specific `.env` files if needed.

::: code-group
```js [wagmi.config.js]
import { defineConfig, loadEnv } from '@wagmi/cli'

export default defineConfig(() => {
  const env = loadEnv({
    mode: process.env.NODE_ENV,
    envDir: process.cwd(),
  })
  return {
    // ...
  }
})
```
:::
</file>

<file path="site/cli/config/options.md">
# Config Options

Configuration options for Wagmi CLI.

## contracts

`ContractConfig[] | undefined`

Array of contracts to use when running [commands](/cli/api/commands). `abi` and `name` are required, all other properties are optional.

### address

`Address | Record<chainId, Address> | undefined`

Contract address or addresses. Accepts an object `{ [chainId]: address }` for targeting specific chains.

::: code-group
```ts {6,11-14} [wagmi.config.ts]
export default {
  out: 'src/generated.ts',
  contracts: [
    {
      abi: [‚Ä¶],
      address: '0x‚Ä¶',
      name: 'MyCoolContract',
    },
    {
      abi: [‚Ä¶],
      address: {
        1: '0xfoo‚Ä¶',
        5: '0xbar‚Ä¶',
      },
      name: 'MyCoolMultichainContract'
    }
  ],
}
```
:::

### abi

`Abi`

ABI for contract. Used by [plugins](/cli/api/plugins) to generate code base on properties.

::: code-group
```ts {5} [wagmi.config.ts]
export default {
  out: 'src/generated.ts',
  contracts: [
    {
      abi: [‚Ä¶],
      name: 'MyCoolContract'
    },
  ],
}
```
:::

### name

`string`

Name of contract. Must be unique. Used by [plugins](/cli/api/plugins) to name generated code.

::: code-group
```ts {6} [wagmi.config.ts]
export default {
  out: 'src/generated.ts',
  contracts: [
    {
      abi: [‚Ä¶],
      name: 'MyCoolContract'
    },
  ],
}
```
:::

## out

`string`

Path to output generated code. Must be unique per config. Use an [Array Config](/cli/config/configuring-cli#array-config) for multiple outputs.

::: code-group
```ts {2} [wagmi.config.ts]
export default {
  out: 'src/generated.ts',
  contracts: [
    {
      abi: [‚Ä¶],
      name: 'MyCoolContract'
    },
  ],
}
```
:::

## plugins

`Plugin[] | undefined`

Plugins to use and their configuration.

Wagmi CLI has multiple [built-in plugins](/cli/api/plugins) that are used to manage ABIs, generate code, etc.

::: code-group
```ts {1,5-20} [wagmi.config.ts]
import { etherscan, react } from '@wagmi/cli/plugins'

export default {
  out: 'src/generated.js',
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY,
      chainId: 5,
      contracts: [
        {
          name: 'EnsRegistry',
          address: {
            1: '0x314159265dd8dbb310642f98f50c066173c1259b',
            5: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
          },
        },
      ],
    }),
    react(),
  ],
}
```
:::
</file>

<file path="site/cli/guides/migrate-from-v1-to-v2.md">
---
title: Migrate from v1 to v2
titleTemplate: Wagmi CLI
description: Guide for migrating from Wagmi CLI v1 to v2.
---

# Migrate from v1 to v2

To get started, install the latest version of the Wagmi CLI.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/cli
```

```bash-vue [npm]
npm install @wagmi/cli
```

```bash-vue [yarn]
yarn add @wagmi/cli
```

```bash-vue [bun]
bun add @wagmi/cli
```
:::

::: info Not ready to migrate yet?
The Wagmi CLI v1 docs are still available at [1.x.wagmi.sh/cli](https://1.x.wagmi.sh/cli).
:::

## Changed generated action and hook names

Generated action and hook names now align with [Wagmi v2 naming conventions](/react/guides/migrate-from-v1-to-v2#renamed-hooks). If you want hooks to still follow Wagmi v1 naming conventions, set [`getActionName`](/cli/api/plugins/actions#getactionname) and [`getHookName`](/cli/api/plugins/react#gethookname) to `'legacy'`.

```ts
import { defineConfig } from '@wagmi/cli'
import { actions, react } from '@wagmi/cli/plugins'

export default defineConfig({
  plugins: [
    actions({
      getActionName: 'legacy', // [!code focus]
    }),
    react({
      getHookName: 'legacy', // [!code focus]
    }),
  ],
})
```
</file>

<file path="site/cli/create-wagmi.md">
# create-wagmi

## Overview

create-wagmi is a command line interface (CLI) for scaffolding new Wagmi projects.

## Usage

::: code-group
```bash [pnpm]
pnpm create wagmi
```
```bash [npm]
npm create wagmi@latest
```
```bash [yarn]
yarn create wagmi
```
```bash [bun]
bun create wagmi
```
:::

## Options

### `-t`, `--template`

You can specify a custom [template](#templates) by passing the `--template`/`-t` flag:

::: code-group
```bash [pnpm]
pnpm create wagmi --template next
```
```bash [npm]
npm create wagmi@latest --template next
```
```bash [yarn]
yarn create wagmi --template next
```
```bash [bun]
bun create wagmi --template next
```
:::

### `--bun`/`--npm`/`--pnpm`/`--yarn`

Use a specific package manager to install dependencies. By default, `create-wagmi` will use the package manager you used to run the command.

### `-h`, `--help`

Prints the help message.

### `-v`, `--version`

Prints the CLI version.

## Templates

`create-wagmi` currently comes with the following templates:

- `next`: A Next.js Wagmi project.
- `nuxt`: A Nuxt Wagmi project.
- `vite-react`: A Vite (React) Wagmi project.
- `vite-vanilla`: A Vite Wagmi Core project.
- `vite-vue`: A Vite (Vue) Wagmi project.

If you do not specify the template on the command line, you will be prompted to select a framework and variant.

- **React** : A React project.
  - **Vite** : A React + Vite Wagmi project (`vite-react`).
  - **Next** : A React + Next Wagmi project (`next`).
- **Vue**: A Vue project.
  - **Vite**: A Vue + Vite Wagmi project (`vite-vue`).
  - **Nuxt**: A Vue + Nuxt Wagmi project (`nuxt`).
- **Vanilla**: A Vite Wagmi project without React (`vite-vanilla`).
</file>

<file path="site/cli/getting-started.md">
# Getting Started

## Overview

Wagmi CLI is a command line interface for managing ABIs (from Etherscan/block explorers, Foundry/Hardhat projects, etc.), generating code (e.g. React Hooks), and much more. It makes working with Ethereum easier by automating manual work so you can build faster. You can learn more about the rationale behind the project in the [Why Wagmi CLI](/cli/why) section.

## Manual Installation

To manually add Wagmi CLI to your project, install the required packages.

::: code-group
```bash [pnpm]
pnpm add -D @wagmi/cli
```

```bash [npm]
npm install --save-dev @wagmi/cli
```

```bash [yarn]
yarn add -D @wagmi/cli
```

```bash [bun]
bun add -D @wagmi/cli
```
:::

## Create Config File

Run the `init` command to generate a configuration file: either `wagmi.config.ts` if TypeScript is detected, otherwise `wagmi.config.js`. You can also create the configuration file manually. See [Configuring CLI](/cli/config/configuring-cli) for more info.

::: code-group
```bash [pnpm]
pnpm wagmi init
```

```bash [npm]
npx wagmi init
```

```bash [yarn]
yarn wagmi init
```

```bash [bun]
bun wagmi init
```
:::

The generated configuration file will look something like this:

::: code-group
```ts [wagmi.config.ts]
import { defineConfig } from '@wagmi/cli'

export default defineConfig({
  out: 'src/generated.ts',
  contracts: [],
  plugins: [],
})
```
:::

## Add Contracts And Plugins

Once the configuration file is set up, you can add contracts and plugins to it. These contracts and plugins are used to manage ABIs (fetch from block explorers, resolve from the file system, etc.), generate code (React hooks, etc.), and much more!

For example, we can add the ERC-20 contract from Viem, and the [`etherscan`](/cli/api/plugins/etherscan) and [`react`](/cli/api/plugins/react) plugins.

::: code-group
```ts{2,3,9-12,15-27,28} [wagmi.config.ts]
import { defineConfig } from '@wagmi/cli'
import { etherscan, react } from '@wagmi/cli/plugins'
import { erc20Abi } from 'viem'
import { mainnet, sepolia } from 'wagmi/chains'
 
export default defineConfig({
  out: 'src/generated.ts',
  contracts: [
    {
      name: 'erc20',
      abi: erc20Abi,
    },
  ],
  plugins: [
    etherscan({
      apiKey: process.env.ETHERSCAN_API_KEY!,
      chainId: mainnet.id,
      contracts: [
        {
          name: 'EnsRegistry',
          address: {
            [mainnet.id]: '0x314159265dd8dbb310642f98f50c066173c1259b',
            [sepolia.id]: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
          },
        },
      ],
    }),
    react(),
  ],
})
```
:::

## Run Code Generation

Now that we added a few contracts and plugins to the configuration file, we can run the [`generate`](/cli/api/commands/generate) command to resolve ABIs and generate code to the `out` file.

::: code-group
```bash [pnpm]
pnpm wagmi generate
```

```bash [npm]
npx wagmi generate
```

```bash [yarn]
yarn wagmi generate
```

```bash [bun]
bun wagmi generate
```
:::

In this example, the `generate` command will do the following:

- Validate the `etherscan` and `react` plugins
- Fetch and cache the ENS Registry ABI from the Mainnet Etherscan API
- Pull in the `erc20Abi` using the name `'ERC20'`
- Generate React Hooks for both ABIs
- Save ABIs, ENS Registry deployment addresses, and React Hooks to the `out` file

## Use Generated Code

Once `out` is created, you can start using the generated code in your project.

```ts
import { useReadErc20, useReadErc20BalanceOf } from './generated'

// Use the generated ERC-20 read hook
const { data } = useReadErc20({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  functionName: 'balanceOf',
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
})

// Use the generated ERC-20 "balanceOf" hook
const { data } = useReadErc20BalanceOf({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
})
```

::: tip
Instead of committing the `out` file, you likely want to add `out` to your `.gitignore` and run `generate` during the build process or before you start your dev server in a `"predev"` script.
:::

## Next Steps

For more information on what to do next, check out the following topics.

- [**Configuring CLI**](/cli/config/configuring-cli) Learn how to configure the CLI to work best for your project.
- [**Commands**](/cli/api/commands) Learn more about the CLI commands and how to use them.
- [**Plugins**](/cli/api/plugins) Browse the collection of plugins and set them up with your config.
</file>

<file path="site/cli/installation.md">
# Installation

Install Wagmi CLI via your package manager.

## Package Manager

Install the required package.

::: code-group
```bash [pnpm]
pnpm add @wagmi/cli
```

```bash [npm]
npm install @wagmi/cli
```

```bash [yarn]
yarn add @wagmi/cli
```

```bash [bun]
bun add @wagmi/cli
```
:::

## Using Unreleased Commits

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

::: code-group
```bash [pnpm]
pnpm add @wagmi/cli@canary
```

```bash [npm]
npm install @wagmi/cli@canary
```

```bash [yarn]
yarn add @wagmi/cli@canary
```

```bash [bun]
bun add @wagmi/cli@canary
```
:::

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

```bash
git clone https://github.com/wevm/wagmi.git
cd wagmi
pnpm install
pnpm build
cd packages/cli
pnpm link --global
```

Then go to the project where you are using the Wagmi CLI and run `pnpm link --global @wagmi/cli` (or the package manager that you used to link Wagmi CLI globally).
</file>

<file path="site/cli/why.md">
# Why Wagmi CLI

## The Problem

The most common way to interact with smart contracts is through [Application Binary Interfaces](https://docs.soliditylang.org/en/latest/abi-spec.html). ABIs describe smart contracts' public functionality (e.g. functions, events, errors) as well as how to encode and decode related data (e.g. arguments and results).

While ABIs are extremely powerful, there isn't a uniform way developers manage them in their apps. Developers do a bunch of different things, like:

- Publish packages on npm containing ABIs
- Write custom scripts to fetch ABIs from external sources
- Compile contracts into application project
- Copy and paste ABIs from local projects or block explorers

All these approaches take time that you could spend doing more important things, like interacting with your smart contracts!

## The Solution

The Wagmi CLI is an attempt to automate manual work so you can build faster. In short, the CLI manages ABIs and generates code. It takes ABIs as inputs and outputs ABIs and generated code. For example, the [Etherscan plugin](/cli/api/plugins/etherscan) allows you to fetch ABIs across multiple chains and deployments and immediately start importing them into your project.

Code generation is another big advantage of the CLI. Using the [React plugin](/cli/api/plugins/react), you can generate [Wagmi Hooks](/react/api/hooks) for ABIs. When you combine this with the CLI's different ABI sources, like Etherscan, Foundry/Hardhat, and more, you reduce a lot of boilerplate code.

::: code-group
```ts [Diff]
import { useReadContract, useWriteContract } from 'wagmi' // [!code --]
import { froggyFriendsAbi, froggyFriendsAddress } from './generated' // [!code --]
import { useReadFroggyFriends, useWriteFroggyFriends } from './generated' // [!code ++]

function App() {
  const { data } = useReadContract({ // [!code --]
  const { data } = useReadFroggyFriends({ // [!code ++]
    abi: froggyFriendsAbi, // [!code --]
    address: froggyFriendsAddress, // [!code --]
    functionName: 'tokenURI',
    args: [123n],
  })

  const { write } = useWriteContract() // [!code --]
  const { write } = useWriteFroggyFriends() // [!code ++]
  const onClick = React.useCallback(() => {
    write({
      abi: froggyFriendsAbi, // [!code --]
      address: froggyFriendsAddress, // [!code --]
      functionName: 'mint',
      args: ['foo', 123n],
    })
  }, [write])
}
```
```ts [Before]
import { useReadContract, useWriteContract } from 'wagmi'
import { froggyFriendsAbi, froggyFriendsAddress } from './generated'

function App() {
  const { data } = useReadContract({
    abi: froggyFriendsAbi,
    address: froggyFriendsAddress,
    functionName: 'tokenURI',
    args: [123n],
  })

  const { write } = useWriteContract()
  const onClick = React.useCallback(() => {
    write({
      abi: froggyFriendsAbi,
      address: froggyFriendsAddress,
      functionName: 'mint',
      args: ['foo', 123n],
    })
  }, [write])
}
```
```ts [After]
import { useReadFroggyFriends, useWriteFroggyFriends } from './generated'

function App() {
  const { data } = useReadFroggyFriends({
    functionName: 'tokenURI',
    args: [123n],
  })

  const { write } = useWriteFroggyFriends()
  const onClick = React.useCallback(() => {
    write({
      functionName: 'mint',
      args: ['foo', 123n],
    })
  }, [write])
}
```
:::

Finally, the Wagmi CLI supports popular smart contract development tools, [Foundry](/cli/api/plugins/foundry) and [Hardhat](/cli/api/plugins/hardhat). You can run the CLI in [watch mode](/cli/api/commands/generate#w-watch), make changes to your contracts, and the CLI will automatically pick up ABI changes and run plugins over those changes. A major boon to working a monorepo and shortening the feedback loop across your stack.
</file>

<file path="site/components/Browsers.vue">
<script setup>
const browsers = ['chrome', 'edge', 'firefox', 'opera', 'safari']
</script>

<template>
  <div flex my-6 gap-1.5>
    <img v-for="browser of browsers" h-16 :src="`/browsers/${browser}.png`" :alt="browser" />
  </div>
</template>
</file>

<file path="site/components/SearchChains.vue">
<script setup>
import * as allChains from 'viem/chains'
import { computed, ref } from 'vue'

const message = ref('')
const chains = Object.entries(allChains)
  .map(([key, value]) => ({ ...value, import: key }))
  .sort((a, b) => a.id - b.id)
const filteredChains = computed(() => {
  const filterMessage = message.value.toLowerCase().trim()
  return chains.filter(
    (chain) =>
      chain.id.toString().includes(filterMessage) ||
      chain.import.toLowerCase().includes(filterMessage) ||
      chain.name.toLowerCase().includes(filterMessage) ||
      chain.nativeCurrency.symbol.toLowerCase().includes(filterMessage),
  )
})
</script>

<template>
  <div relative flex="~ items-center" mb-4>
    <input class="Search" h-10 w-full aria-label="Search chains" placeholder="Search chains" v-model="message" />
    <span absolute right-4 font-500 op-50 text-xs>{{ filteredChains.length }} {{ filteredChains.length === 1 ?
      "Chain" :
      "Chains"
      }}</span>
  </div>

  <div class="Columns">
    <div v-for="chain of filteredChains" class="Item" h-30 flex="~ col items-center justify-center gap-1.5">
      <div mt-3 text-sm font-500 text-truncate max-w-50>{{ chain.name }}</div>
      <code text-xs>{{ chain.import }}</code>
      <div flex="~ gap-1" op-50 text-xs>
        <span>{{ chain.id }}</span> -
        <span>{{ chain.nativeCurrency.symbol }}</span>
      </div>
    </div>
  </div>
</template>

<style scoped>
.Columns {
  --grid-layout-gap: 0.5rem;
  --grid-column-count: 8;
  --grid-item--min-width: 200px;

  /** Calculated values. */
  --gap-count: calc(var(--grid-column-count) - 1);
  --total-gap-width: calc(var(--gap-count) * var(--grid-layout-gap));
  --grid-item--max-width: calc((100% - var(--total-gap-width)) / var(--grid-column-count));

  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(max(var(--grid-item--min-width), var(--grid-item--max-width)), 1fr));
  grid-gap: var(--grid-layout-gap);
}

.Item {
  background-color: var(--vp-c-bg-soft);
  border: 1px solid var(--vp-c-bg-soft);
  border-radius: 8px;
}

.Search {
  background-color: var(--vp-c-bg-alt);
  border: 1px solid transparent;
  border-radius: 8px;
  outline: none;
  padding: 16px;
  font-size: 0.9rem;
  font-weight: 500;
}

.Search::placeholder {
  color: var(--vp-c-text-1);
}

.Search:hover,
.Search:focus {
  border-color: var(--vp-c-brand);
}
</style>
</file>

<file path="site/core/api/actions/call.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'call'
const typeName = 'call'
</script>

# call

Action for executing a new message call immediately without submitting a transaction to the network.

## Import

```ts
import { call } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts twoslash
import { type CallParameters } from '@wagmi/core'
```

### account

`Account | Address | undefined`

The Account to call from.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`Address | undefined`

The contract address or recipient.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  accessList: [ // [!code focus:6] 
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined`

The gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  gas: 1_000_000n, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseGwei } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseGwei } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseGwei } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  nonce: 420, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value (in wei) sent with this transaction.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`number | undefined`

The block number to perform the call against.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  blockNumber: 15121123n, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to perform the call against.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  blockTag: 'safe', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The block tag to perform the call against.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'
import { mainnet } from '@wagmi/core/chains'

await call(config, {
  chainId: mainnet.id, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts twoslash
import { type CallReturnType } from '@wagmi/core'
```

`{ data: 0x${string} }`

The call data.

## Error

```ts twoslash
import { type CallErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`call`](https://viem.sh/docs/actions/public/call.html)
</file>

<file path="site/core/api/actions/connect.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'connect'
const typeName = 'Connect'
</script>

# connect

Action for connecting accounts with [connectors](/core/api/connectors).

## Import

```ts
import { connect } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { connect } from '@wagmi/core'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await connect(config, { connector: injected() })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ConnectParameters } from '@wagmi/core'
```

### chainId

`number | undefined`

Chain ID to connect to.

Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider is connected to.

::: code-group
```ts [index.ts]
import { connect } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await connect(config, {
  chainId: mainnet.id, // [!code focus]
  connector: injected(),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`CreateConnectorFn | Connector`

[Connector](/core/api/connectors) to connect with.

::: code-group
```ts [index.ts]
import { connect } from '@wagmi/core'
import { injected } from '@wagmi/connectors' // [!code focus]
import { config } from './config'

const result = await connect(config, {
  connector: injected(), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ConnectReturnType } from '@wagmi/core'
```

### accounts

`readonly [Address, ...Address[]]`

Connected accounts from connector.

### chainId

`number`

Connected chain ID from connector.

## Error

```ts
import { type ConnectErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="site/core/api/actions/deployContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'deployContract'
const typeName = 'DeployContract'
</script>

# deployContract <Badge text="viem@>=2.8.18" />

Action for deploying a contract to the network, given bytecode, and constructor arguments.

## Import

```ts
import { deployContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Deploying with Constructor Args

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::


## Parameters

```ts
import { type DeployContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI.

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi, // [!code focus]
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when deploying a contract. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when deploying the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420], // [!code focus]
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### bytecode

`Hex`

The contract's bytecode.

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...', // [!code focus]
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to use when deploying a contract.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getAccount, deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const { connector } = getAccount(config)
const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  connector, // [!code focus]
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type DeployContractReturnType } from '@wagmi/core'
```

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

Transaction hash.

## Error

```ts
import { type DeployContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`deployContract`](https://viem.sh/docs/contract/deployContract)
</file>

<file path="site/core/api/actions/disconnect.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'disconnect'
const typeName = 'Disconnect'
</script>

# disconnect

Action for disconnecting connections.

## Import

```ts
import { disconnect } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { disconnect } from '@wagmi/core'
import { config } from './config'

await disconnect(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type DisconnectParameters } from '@wagmi/core'
```

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to disconnect with.

::: code-group
```ts [index.ts]
import { disconnect, getAccount } from '@wagmi/core'
import { config } from './config'

const { connector } = getAccount(config)
const result = await disconnect(config, {
  connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Error

```ts
import { type DisconnectErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="site/core/api/actions/estimateFeesPerGas.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'estimateFeesPerGas'
const typeName = 'EstimateFeesPerGas'
</script>

# estimateFeesPerGas

Returns an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { estimateFeesPerGas } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { config } from './config'

const result = await estimateFeesPerGas(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type EstimateFeesPerGasParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await estimateFeesPerGas(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { config } from './config'

const feesPerGas = estimateFeesPerGas(config, {
  formatUnits: 'ether', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559'`

- Fee value type.
- Defaults to `'eip1559'`

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { config } from './config'

const result = estimateFeesPerGas(config, {
  type: 'legacy', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type EstimateFeesPerGasReturnType } from '@wagmi/core'
```

[`FeeValues`](https://viem.sh/docs/glossary/types.html#feevalues)

An estimate (in wei) for the fees per gas.

### formatted
 
`{ gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }`

Object of formatted values using [`formatUnits`](#formatunits).

### gasPrice

`bigint | undefined`

- Gas price.
- When [`type`](#type) is `'eip1559'`, value is `undefined`.

### maxFeePerGas

`bigint | undefined`

- Max fee per gas.
- When [`type`](#type) is `'legacy'`, value is `undefined`.

### maxPriorityFeePerGas

`bigint | undefined`

- Max priority fee per gas.
- When [`type`](#type) is `'legacy'`, value is `undefined`.

## Error

```ts
import { type EstimateFeesPerGasErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`estimateFeesPerGas`](https://viem.sh/docs/actions/public/estimateFeesPerGas.html)
</file>

<file path="site/core/api/actions/estimateGas.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'estimateGas'
const typeName = 'EstimateGas'
</script>

# estimateGas

Action for estimating the gas necessary to complete a transaction without submitting it to the network.

## Import

```ts
import { estimateGas } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type EstimateGasParameters } from '@wagmi/core'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when estimating gas.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  chainId: mainnet.id, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

::: code-group
```ts [index.ts]
import { getConnections, estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const connections = getConnections(config)
const result = await estimateGas(config, {
  connector: connections[0]?.connector, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  gas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  nonce: 123, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`Address | undefined`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  type: 'eip1559', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type EstimateGasReturnType } from '@wagmi/core'
```

`bigint`

The gas estimate in wei.

## Error

```ts
import { type EstimateGasErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`estimateGas`](https://viem.sh/docs/actions/public/estimateGas.html)
</file>

<file path="site/core/api/actions/estimateMaxPriorityFeePerGas.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'estimateMaxPriorityFeePerGas'
const typeName = 'EstimateFeesPerGas'
</script>

# estimateMaxPriorityFeePerGas

Returns an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
import { config } from './config'

const result = await estimateMaxPriorityFeePerGas(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type EstimateFeesPerGasParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await estimateMaxPriorityFeePerGas(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type EstimateFeesPerGasReturnType } from '@wagmi/core'
```

`bigint`

An estimate (in wei) for the max priority fee per gas.

## Error

```ts
import { type EstimateFeesPerGasErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`estimateMaxPriorityFeePerGas`](https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html)
</file>

<file path="site/core/api/actions/getAccount.md">
# getAccount

Action for getting current account.

## Import

```ts
import { getAccount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getAccount } from '@wagmi/core'
import { config } from './config'

const account = getAccount(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetAccountReturnType } from '@wagmi/core'
```

<!--@include: @shared/getAccount-return-type.md-->
</file>

<file path="site/core/api/actions/getBalance.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBalance'
const typeName = 'GetBalance'
</script>

# getBalance

Action for fetching native currency or token balance.

## Import

```ts
import { getBalance } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBalanceParameters } from '@wagmi/core'
```

### address

`Address`

Address to get balance for.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get balance at.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockTag: 'latest', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const balance = await getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### token

`Address | undefined`

ERC-20 token address to get balance for.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### unit

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  unit: 'ether', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBalanceReturnType } from '@wagmi/core'
```

### decimals

`number`

Number of decimals for balance [`value`](#value).

### formatted

`string`

Formatted value of balance using [`unit`](#unit).

### symbol

`string`

Symbol of native currency or token.

### value

`bigint`

Raw value of balance.

## Error

```ts
import { type GetBalanceErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBalance`](https://viem.sh/docs/actions/public/getBalance.html) for native currency balances
- [`multicall`](https://viem.sh/docs/actions/public/multicall.html) for token balances
</file>

<file path="site/core/api/actions/getBlock.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBlock'
const typeName = 'GetBlock'
</script>

# getBlock

Action for fetching information about a block at a block number, hash or tag.

## Import

```ts
import { getBlock } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBlockParameters } from '@wagmi/core'
```

### blockHash

`` `0x${string}` ``

Information at a given block hash.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`` bigint ``

Information at a given block number.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  blockNumber: 42069n // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`` 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' ``

Information at a given block tag. Defaults to `'latest'`.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  blockTag: 'pending' // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const blockNumber = await getBlock(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### includeTransactions

`boolean`

Whether or not to include transactions as objects.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  includeTransactions: true // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBlockReturnType } from '@wagmi/core'
```

[`Block`](https://viem.sh/docs/glossary/types.html#block)

Information about the block.

## Error

```ts
import { type GetBlockErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBlock`](https://viem.sh/docs/actions/public/getBlock.html)
</file>

<file path="site/core/api/actions/getBlockNumber.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBlockNumber'
const typeName = 'GetBlockNumber'
</script>

# getBlockNumber

Action for fetching the number of the most recent block seen.

## Import

```ts
import { getBlockNumber } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBlockNumber } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlockNumber(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBlockNumberParameters } from '@wagmi/core'
```

### cacheTime

`number | undefined`

Time in milliseconds that cached block number will remain in memory.

::: code-group
```ts [index.ts]
import { getBlockNumber } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlockNumber(config, {
  cacheTime: 4_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBlockNumber } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const blockNumber = await getBlockNumber(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBlockNumberReturnType } from '@wagmi/core'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type GetBlockNumberErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBlockNumber`](https://viem.sh/docs/actions/public/getBlockNumber.html)
- [`watchBlockNumber`](https://viem.sh/docs/actions/public/watchBlockNumber.html)
</file>

<file path="site/core/api/actions/getBlockTransactionCount.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBlockTransactionCount'
const typeName = 'GetBlockTransactionCount'
</script>

# getBlockTransactionCount

Action for fetching the number of Transactions at a block number, hash or tag.

## Import

```ts
import { getBlockTransactionCount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBlockTransactionCount } from '@wagmi/core'
import { config } from './config'

const blockTransactionCount = await getBlockTransactionCount(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBlockTransactionCountParameters } from '@wagmi/core'
```

### cacheTime

`number | undefined`

Time in milliseconds that cached block transaction count will remain in memory.

::: code-group
```ts [index.ts]
import { getBlockTransactionCount } from '@wagmi/core'
import { config } from './config'

const blockTransactionCount = await getBlockTransactionCount(config, {
  cacheTime: 4_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBlockTransactionCount } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const blockTransactionCount = await getBlockTransactionCount(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBlockTransactionCountReturnType } from '@wagmi/core'
```

`number`

The number of Transactions at a block number

## Error

```ts
import { type GetBlockTransactionCountErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBlockTransactionCount`](https://viem.sh/docs/actions/public/getBlockTransactionCount.html)
</file>

<file path="site/core/api/actions/getBytecode.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBytecode'
const typeName = 'getBytecode'
</script>

# getBytecode

Action for retrieving the bytecode at an address.

## Import

```ts
import { getBytecode } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBytecodeParameters } from '@wagmi/core'
```

### address

`Address`

The contract address.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the bytecode at.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockNumber: 16280770n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockTag: 'safe', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await getBytecode(config, {
  chainId: mainnet.id, // [!code focus]
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBytecodeReturnType } from '@wagmi/core'
```

`Hex`

The contract's bytecode.

## Error

```ts
import { type GetBytecodeErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getCode`](https://viem.sh/docs/contract/getCode)
</file>

<file path="site/core/api/actions/getCallsStatus.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'getCallsStatus'
const typeName = 'GetCallsStatus'
</script>

# getCallsStatus

Action to fetch the status and receipts of a call batch that was sent via [`sendCalls`](/core/api/actions/sendCalls).

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_getcallsstatus)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { getCallsStatus } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { getCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await getCallsStatus(config, {
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetCallsStatusParameters } from '@wagmi/core/experimental'
```

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```ts [index.ts]
import { getConnections, getCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const status = await getCallsStatus(config, {
  connector: connections[0]?.connector, // [!code focus]
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { getCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await getCallsStatus(config, {
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetCallsStatusReturnType } from '@wagmi/core/experimental'
```

`{ status: 'PENDING' | 'CONFIRMED', receipts: TransactionReceipt[] }`

The status and receipts of the call batch.

## Error

```ts
import { type GetCallsStatusErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getCallsStatus`](https://viem.sh/experimental/eip5792/getCallsStatus)
</file>

<file path="site/core/api/actions/getCapabilities.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'getCapabilities'
const typeName = 'GetCapabilities'
</script>

# getCapabilities

Action to extract capabilities (grouped by chain ID) that a connected wallet supports (e.g. paymasters, session keys, etc).

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_getcapabilities)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { getCapabilities } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { getCapabilities } from '@wagmi/core/experimental'
import { config } from './config'

const capabilities = await getCapabilities(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetCapabilitiesParameters } from '@wagmi/core/experimental'
```

### account

`Account | Address | undefined`

Fetch capabilities for the provided account.

::: code-group
```ts [index.ts]
import { getCapabilities } from '@wagmi/core/experimental'
import { config } from './config'

const capabilities = await getCapabilities(config, {
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get capabilities from.

::: code-group
```ts [index.ts]
import { getConnections, getCapabilities } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const capabilities = await getCapabilities(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetCapabilitiesReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type GetCapabilitiesErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getCapabilities`](https://viem.sh/experimental/eip5792/getCapabilities)
</file>

<file path="site/core/api/actions/getChainId.md">
# getChainId

Action for getting current chain ID.


## Import

```ts
import { getChainId } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getChainId } from '@wagmi/core'
import { config } from './config'

const chainId = getChainId(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainIdReturnType } from '@wagmi/core'
```

`number`

Current chain ID from [`config.state.chainId`](/core/api/createConfig#chainid).

::: info
Only returns chain IDs for chains configured via `createConfig`'s [`chains`](/core/api/createConfig#chains) parameter.

If the active [connection](/core/api/createConfig#connection) [`chainId`](/core/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `getChainId` will return the last configured chain ID.
:::
</file>

<file path="site/core/api/actions/getChains.md">
# getChains

Action for getting configured chains.

## Import

```ts
import { getChains } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getChains } from '@wagmi/core'
import { config } from './config'

const chains = getChains(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainsReturnType } from '@wagmi/core'
```

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](/core/api/createConfig#chains).
</file>

<file path="site/core/api/actions/getClient.md">
# getClient

Action for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Import

```ts
import { getClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getClient } from '@wagmi/core'
import { config } from './config'

const client = getClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetClientParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

::: code-group
```ts [index.ts]
import { getClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = await getClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetClientReturnType } from '@wagmi/core'
```

`Client`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.
</file>

<file path="site/core/api/actions/getConnections.md">
# getConnections

Action for getting active connections.

## Import

```ts
import { getConnections } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnections } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetConnectionsReturnType } from '@wagmi/core'
```

[`Connection[]`](/core/api/createConfig#connection)

Active connections.
</file>

<file path="site/core/api/actions/getConnectorClient.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getConnectorClient'
const typeName = 'GetConnectorClient'
</script>

# getConnectorClient

Action for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Import

```ts
import { getConnectorClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnectorClient } from '@wagmi/core'
import { config } from './config'

const client = await getConnectorClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetConnectorClientParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { getConnectorClient } from '@wagmi/core'
import { config } from './config'

const client = await getConnectorClient(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

::: code-group
```ts [index.ts]
import { getConnectorClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = await getConnectorClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getConnections, getConnectorClient } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const client = await getConnectorClient(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainIdReturnType } from '@wagmi/core'
```

`Client`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Error

```ts
import { type GetConnectorClientErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->
</file>

<file path="site/core/api/actions/getConnectors.md">
# getConnectors

Action for getting configured connectors.

## Import

```ts
import { getConnectors } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnectors } from '@wagmi/core'
import { config } from './config'

const connectors = getConnectors(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetConnectorsReturnType } from '@wagmi/core'
```

`readonly Connector[]`

Connectors from [`config.connectors`](/core/api/createConfig#connectors-1).
</file>

<file path="site/core/api/actions/getEnsAddress.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsAddress'
const typeName = 'GetEnsAddress'
</script>

# getEnsAddress

Action for fetching ENS address for name.

## Import

```ts
import { getEnsAddress } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = getEnsAddress(config, {
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsAddressParameters } from '@wagmi/core'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS address at.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = getEnsAddress(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = getEnsAddress(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### coinType

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  coinType: 60, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the address for.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  name: normalize('wevm.eth'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsAddressReturnType } from '@wagmi/core'
```

`string`

ENS address.

## Error

```ts
import { type GetEnsAddressErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsAddress`](https://viem.sh/docs/ens/actions/getEnsAddress.html)
</file>

<file path="site/core/api/actions/getEnsAvatar.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsAvatar'
const typeName = 'GetEnsAvatar'
</script>

# getEnsAvatar

Action for fetching ENS address for avatar.

## Import

```ts
import { getEnsAvatar } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsAvatarParameters } from '@wagmi/core'
```

---

### assetGatewayUrls <Badge text="viem@>=2.3.1" />

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  assetGatewayUrls: { // [!code focus]
    ipfs: 'https://cloudflare-ipfs.com', // [!code focus]
  }, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::


### blockNumber

`bigint | undefined`

Block number to get avatar at.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get avatar at.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gatewayUrls

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  gatewayUrls: ['https://cloudflare-ipfs.com'] { // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the avatar for.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  name: normalize('wevm.eth'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsAvatarReturnType } from '@wagmi/core'
```

`string | null`

The avatar URI for ENS name.

## Error

```ts
import { type getEnsAvatarError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsAvatar`](https://viem.sh/docs/ens/actions/getEnsAvatar.html)
</file>

<file path="site/core/api/actions/getEnsName.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsName'
const typeName = 'GetEnsName'
</script>

# getEnsName

Action for fetching primary ENS name for address.

## Import

```ts
import { getEnsName } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetEnsNameParameters } from '@wagmi/core'
```

### address

`Address`

Address to get the name for.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = await getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get name at.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get name at.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockTag: 'latest', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const ensName = await getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = await getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  universalResolverName: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsNameReturnType } from '@wagmi/core'
```

`string | null`

The primary ENS name for the address. Returns `null` if address does not have primary name assigned.

## Error

```ts
import { type GetEnsNameErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsName`](https://viem.sh/docs/ens/actions/getEnsName.html)
</file>

<file path="site/core/api/actions/getEnsResolver.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsResolver'
const typeName = 'GetEnsResolver'
</script>

# getEnsResolver

Action for fetching ENS resolver for name.

## Import

```ts
import { getEnsResolver } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = getEnsResolver(config, {
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsResolver`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsResolverParameters } from '@wagmi/core'
```

---

### blockNumber

`bigint | undefined`

Block number to get resolver at.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = getEnsResolver(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get resolver at.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = getEnsResolver(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = await getEnsResolver(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the resolver for.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = await getEnsResolver(config, {
  name: normalize('wevm.eth'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = await getEnsResolver(config, {
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsResolverReturnType } from '@wagmi/core'
```

`Address`

The address of the resolver.

## Error

```ts
import { type getEnsResolverError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsResolver`](https://viem.sh/docs/ens/actions/getEnsResolver.html)
</file>

<file path="site/core/api/actions/getEnsText.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsText'
const typeName = 'GetEnsText'
</script>

# getEnsText

Action for fetching a text record for a specified ENS name and key.

## Import

```ts
import { getEnsText } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = getEnsText(config, {
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsText`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsTextParameters } from '@wagmi/core'
```

---

### blockNumber

`bigint | undefined`

Block number to get the text at.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = getEnsText(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the text at.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = getEnsText(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### key

`string`

ENS key to get Text for.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  name: normalize('wevm.eth'),
  key: 'com.twitter', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the text for.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  name: normalize('wevm.eth'), // [!code focus]
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsTextReturnType } from '@wagmi/core'
```

`string | null`

The text record for ENS name.

Returns `null` if name does not have text assigned.

## Error

```ts
import { type getEnsTextError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html)
</file>

<file path="site/core/api/actions/getFeeHistory.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getFeeHistory'
const typeName = 'GetFeeHistory'
</script>

# getFeeHistory

Action for fetching a collection of historical gas information.

## Import

```ts
import { getFeeHistory } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  rewardPercentiles: [25, 75]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetFeeHistoryParameters } from '@wagmi/core'
```

### blockCount

`number`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4, // [!code focus]
  rewardPercentiles: [25, 75]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### rewardPercentiles

`number[]`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  rewardPercentiles: [25, 75] // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Highest number block of the requested range.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  blockNumber: 1551231n, // [!code focus]
  rewardPercentiles: [25, 75],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag of the highest number block of the requested range.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  blockTag: 'safe', // [!code focus]
  rewardPercentiles: [25, 75],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  chainId: mainnet.id, // [!code focus]
  rewardPercentiles: [25, 75],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetFeeHistoryReturnType } from '@wagmi/core'
```

[`FeeHistory`](https://viem.sh/docs/glossary/types.html#feehistory)

The fee history.

## Error

```ts
import { type GetFeeHistoryErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getFeeHistory`](https://viem.sh/docs/actions/public/getFeeHistory.html)
</file>

<file path="site/core/api/actions/getGasPrice.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getGasPrice'
const typeName = 'GetGasPrice'
</script>

# getGasPrice

Action for fetching the current price of gas (in wei).

## Import

```ts
import { getGasPrice } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getGasPrice } from '@wagmi/core'
import { config } from './config'

const gasPrice = await getGasPrice(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetGasPriceParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getGasPrice } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const gasPrice = await getGasPrice(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetGasPriceReturnType } from '@wagmi/core'
```

`bigint`

Current price of gas (in wei).

## Error

```ts
import { type GetGasPriceErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getGasPrice`](https://viem.sh/docs/actions/public/getGasPrice.html)
</file>

<file path="site/core/api/actions/getProof.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getProof'
const typeName = 'getProof'
</script>

# getProof

Action for return the account and storage values of the specified account including the Merkle-proof.

## Import

```ts
import { getProof } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetProofParameters } from '@wagmi/core'
```

### address

`Address`

The account address to get the proof for.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016', // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### storageKeys

`` `0x${string}`[] ``

Array of storage-keys that should be proofed and included.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [ // [!code focus:3]
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Proof at a given block number.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  blockNumber: 42069n, // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Proof at a given block tag.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  blockTag: 'latest', // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to get the proof for.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'
import { optimism } from '@wagmi/core/chains'

await getProof(config, {
  chainId: optimism.id, // [!code focus]
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetProofReturnType } from '@wagmi/core'
```

`Proof`

Proof data.

## Error

```ts
import { type GetProofErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getProof`](https://viem.sh/docs/actions/public/getProof.html)
</file>

<file path="site/core/api/actions/getPublicClient.md">
# getPublicClient

Action for getting Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

## Import

```ts
import { getPublicClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getPublicClient } from '@wagmi/core'
import { config } from './config'

const client = getPublicClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`getClient`](/core/api/actions/getClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Public Client has all public actions attached directly to it.
:::

## Parameters

```ts
import { type GetClientParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Public Client.

::: code-group
```ts [index.ts]
import { getPublicClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = getPublicClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetPublicClientReturnType } from '@wagmi/core'
```

`PublicClient | undefined`

Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.
</file>

<file path="site/core/api/actions/getStorageAt.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getStorageAt'
const typeName = 'getStorageAt'
</script>

# getStorageAt

Action for returning the value from a storage slot at a given address.

## Import

```ts
import { getStorageAt } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetStorageAtParameters } from '@wagmi/core'
```

### address

`Address`

The contract address.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### slot

`Hex`

The storage position (as a hex encoded value).

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: '0x0', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the storage at.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockNumber: 16280770n, // [!code focus]
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the storage at.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockTag: 'safe', // [!code focus]
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the storage at.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await getStorageAt(config, {
  chainId: mainnet.id, // [!code focus]
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetStorageAtReturnType } from '@wagmi/core'
```

`Hex`

The value of the storage slot.

## Error

```ts
import { type GetStorageAtErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getStorageAt`](https://viem.sh/docs/contract/getStorageAt)
</file>

<file path="site/core/api/actions/getToken.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getToken'
const typeName = 'GetToken'
</script>

# getToken

Action for fetching token info.

## Import

```ts
import { getToken } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { config } from './config'

const token = getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTokenParameters } from '@wagmi/core'
```

### address

`Address`

Address to get token for.

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { config } from './config'

const token = getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const token = await getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { config } from './config'

const token = getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  formatUnits: 'ether', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTokenReturnType } from '@wagmi/core'
```

### address 

`Address`

Address of token.

### decimals 

`number`

Number of decimals for token.

### name 

`string | undefined`

Name of token.

### symbol 

`string | undefined`

Symbol of token.

### totalSupply 

`{ formatted: string; value: bigint; }`

Total supply of token. `formatted` is formatted using [`formatUnits`](#formatunits).

## Error

```ts
import { type GetTokenErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`multicall`](https://viem.sh/docs/contract/multicall)
</file>

<file path="site/core/api/actions/getTransaction.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransaction'
const typeName = 'GetTransaction'
</script>

# getTransaction

Action for fetching transactions given hashes or block identifiers.

## Import

```ts
import { getTransaction } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionParameters } from '@wagmi/core'
```

---

### blockHash

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  index: 0,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockNumber: 17829139n, // [!code focus]
  index: 0,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockTag: 'safe', // [!code focus]
  index: 0,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const transaction = await getTransaction(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### hash

`` `0x${string}` | undefined ``

Hash to get transaction.

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### index

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockTag: 'safe',
  index: 0  // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTransactionReturnType } from '@wagmi/core'
```

[`Transaction`](https://viem.sh/docs/glossary/types.html#transaction)

## Error

```ts
import { type GetTransactionErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransaction`](https://viem.sh/docs/actions/public/getTransaction.html)
</file>

<file path="site/core/api/actions/getTransactionConfirmations.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransactionConfirmations'
const typeName = 'GetTransactionConfirmations'
</script>

# getTransactionConfirmations

Action for fetching the number of blocks passed (confirmations) since the transaction was processed on a block. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

## Import

```ts
import { getTransactionConfirmations } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { config } from './config'

const transaction = getTransactionConfirmations(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionConfirmationsParameters } from '@wagmi/core'
```

---

### hash

`` `0x${string}` | undefined ``

The hash of the transaction.

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { config } from './config'

const transaction = getTransactionConfirmations(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### transactionReceipt

`TransactionReceipt | undefined`

The transaction receipt.

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { config } from './config'

const transaction = getTransactionConfirmations(config, {
  transactionReceipt: { ... }, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const transaction = await getTransactionConfirmations(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTransactionConfirmationsReturnType } from '@wagmi/core'
```

`bigint`

The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

## Error

```ts
import { type GetTransactionConfirmationsErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransactionConfirmations`](https://viem.sh/docs/actions/public/getTransactionConfirmations.html)
</file>

<file path="site/core/api/actions/getTransactionCount.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransactionCount'
const typeName = 'GetTransactionCount'
</script>

# getTransactionCount

Action for fetching the number of transactions an Account has sent.

## Import

```ts
import { getTransactionCount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionCountParameters } from '@wagmi/core'
```

---

### address

`Address`

The address of the account.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Get the count at a block number.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Get the count at a block tag.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockTag: 'latest', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::


## Return Type

```ts
import { type GetTransactionCountReturnType } from '@wagmi/core'
```

`number`

The number of transactions an account has sent.

## Error

```ts
import { type GetTransactionCountErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransactionCount`](https://viem.sh/docs/actions/public/getTransactionCount.html)
</file>

<file path="site/core/api/actions/getTransactionReceipt.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransactionReceipt'
const typeName = 'getTransactionReceipt'
</script>

# getTransactionReceipt

Action for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

## Import

```ts
import { getTransactionReceipt } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransactionReceipt } from '@wagmi/core'
import { config } from './config'

await getTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionReceiptParameters } from '@wagmi/core'
```

### hash

`` `0x${string}` ``

A transaction hash.

::: code-group
```ts [index.ts]
import { getTransactionReceipt } from '@wagmi/core'
import { config } from './config'

await getTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

::: code-group
```ts [index.ts]
import { getTransactionReceipt } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await getTransactionReceipt(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTransactionReceiptReturnType } from '@wagmi/core'
```

[`TransactionReceipt`](https://viem.sh/docs/glossary/types.html#transactionreceipt)

The transaction receipt.

## Error

```ts
import { type GetTransactionReceiptErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransactionReceipt`](https://viem.sh/docs/actions/public/getTransactionReceipt.html)
</file>

<file path="site/core/api/actions/getWalletClient.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getWalletClient'
const typeName = 'GetWalletClient'
</script>

# getWalletClient

Action for getting a Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

## Import

```ts
import { getWalletClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getWalletClient } from '@wagmi/core'
import { config } from './config'

const client = getWalletClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`getConnectorClient`](/core/api/actions/getConnectorClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Wallet Client has all wallet actions attached directly to it.
:::

## Parameters

```ts
import { type GetWalletClientParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { getWalletClient } from '@wagmi/core'
import { config } from './config'

const client = getWalletClient(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

::: code-group
```ts [index.ts]
import { getWalletClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = getWalletClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getConnections, getWalletClient } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const client = getWalletClient(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainIdReturnType } from '@wagmi/core'
```

`WalletClient`

Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

## Error

```ts
import { type GetWalletClientErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->
</file>

<file path="site/core/api/actions/multicall.md">
# multicall

Action for batching up multiple functions on a contract in a single RPC call via the [Multicall3 contract](https://github.com/mds1/multicall).

## Import

```ts
import { multicall } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { multicall } from '@wagmi/core'
import { config } from './config'

const wagmigotchiContract = {
  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: wagmigotchiABI,
} as const
const mlootContract = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: mlootABI,
} as const

const result = await multicall(config, {
  contracts: [
    {
      ...wagmigotchiContract,
      functionName: 'getAlive',
    },
    {
      ...wagmigotchiContract,
      functionName: 'getBoredom',
    },
    {
      ...mlootContract,
      functionName: 'getChest',
      args: [69],
    },
    {
      ...mlootContract,
      functionName: 'getWaist',
      args: [69],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type MulticallParameters } from '@wagmi/core'
```

### contracts

`readonly Contract[]`

Set of contracts to call.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI, // [!code hl]
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df', // [!code hl]
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69], // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
      chainId: 1, // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::


#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest', // [!code hl]
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### allowFailure

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `multicall` will fail silently and its error will be logged in the results array. Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  allowFailure: false, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### batchSize

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  batchSize: 1_024, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number`

The block number to perform the read against.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  blockNumber: 69420n, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  blockTag: 'safe', // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### multicallAddress

`Address`

Address of multicall contract.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
  multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11', // [!code hl]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::


## Return Type

```ts
import { type MulticallReturnType } from '@wagmi/core'
```

## Type Inference

With [`contracts[number]['abi']`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type MulticallErrorType } from '@wagmi/core'
```

## Viem

- [`multicall`](https://viem.sh/docs/actions/public/multicall.html)
</file>

<file path="site/core/api/actions/prepareTransactionRequest.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'prepareTransactionRequest'
const typeName = 'prepareTransactionRequest'
</script>

# prepareTransactionRequest

Action for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

## Import

```ts
import { prepareTransactionRequest } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type PrepareTransactionRequestParameters } from '@wagmi/core'
```

### account

`Account | Address | undefined`

The Account to send the transaction from. 

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`` `0x${string}` | undefined ``

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',  // [!code focus]
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to prepare the transaction request for.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  chainId: mainnet.id, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
  nonce: 5, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### parameters

`("fees" | "gas" | "nonce" | "type")[] | undefined`

Parameters to prepare.

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  parameters: ['gas', 'nonce'], // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type PrepareTransactionRequestReturnType } from '@wagmi/core'
```

[`TransactionRequest`](https://viem.sh/docs/glossary/types.html#transactionrequest)

The transaction request.

## Error

```ts
import { type PrepareTransactionRequestErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`prepareTransactionRequest`](https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html)
</file>

<file path="site/core/api/actions/readContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'readContract'
const typeName = 'ReadContract'
</script>

# readContract

Action for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

## Import

```ts
import { readContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ReadContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const result = await readContract(config, {
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address`

The contract's address.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'totalSupply',
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  blockTag: 'safe', // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### functionName

`string`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf', // [!code focus]
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ReadContractReturnType } from '@wagmi/core'
```

`unknown`

- Result of contract read-only function.
- Inferred from [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args).

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type ReadContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`readContract`](https://viem.sh/docs/contract/readContract.html)
</file>

<file path="site/core/api/actions/readContracts.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'readContracts'
const typeName = 'ReadContracts'
</script>

# readContracts

Action for calling multiple read methods on a contract.

## Import

```ts
import { readContracts } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const wagmigotchiContract = {
  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: wagmigotchiABI,
} as const
const mlootContract = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: mlootABI,
} as const

const result = await readContracts(config, {
  contracts: [
    {
      ...wagmigotchiContract,
      functionName: 'getAlive',
    },
    {
      ...wagmigotchiContract,
      functionName: 'getBoredom',
    },
    {
      ...mlootContract,
      functionName: 'getChest',
      args: [69],
    },
    {
      ...mlootContract,
      functionName: 'getWaist',
      args: [69],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ReadContractsParameters } from '@wagmi/core'
```

### contracts

`readonly Contract[]`

Set of contracts to call.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI, // [!code hl]
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df', // [!code hl]
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69], // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
      chainId: 1, // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::


#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest', // [!code hl]
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### allowFailure

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `readContracts` will fail silently and its error will be logged in the results array. Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  allowFailure: false, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### batchSize

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  batchSize: 1_024, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number`

The block number to perform the read against.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  blockNumber: 69420n, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  blockTag: 'safe', // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### multicallAddress

`Address`

Address of multicall contract.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
  multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11', // [!code hl]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type ReadContractsReturnType } from '@wagmi/core'
```

## Type Inference

With [`contracts[number]['abi']`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type ReadContractsErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`multicall`](https://viem.sh/docs/actions/public/multicall.html) when supported by current chain.
- [`readContract`](https://viem.sh/docs/contract/readContract.html) when multicall is not supported.
</file>

<file path="site/core/api/actions/reconnect.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'reconnect'
const typeName = 'Reconnect'
</script>

# reconnect

Action for reconnecting [connectors](/core/api/connectors).

## Import

```ts
import { reconnect } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { reconnect } from '@wagmi/core'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await reconnect(config, { connectors: [injected()] })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ReconnectParameters } from '@wagmi/core'
```

### connectors

`(CreateConnectorFn | Connector)[] | undefined`

- [Connectors](/core/api/connectors) to reconnect to.
- Defaults to [`Config['connectors']`](/core/api/createConfig#connectors).

::: code-group
```ts [index.ts]
import { reconnect } from '@wagmi/core'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await reconnect(config, {
    connectors: [injected()], // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ReconnectReturnType } from '@wagmi/core'
```

`Connection[]`

[Connections](/core/api/createConfig#connection) that were successfully reconnected.

## Error

```ts
import { type ReconnectErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="site/core/api/actions/sendCalls.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'sendCalls'
const typeName = 'SendCalls'
</script>

# sendCalls

Action that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { sendCalls } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SendCallsParameters } from '@wagmi/core/experimental'
```

### account

`Account | Address | null | undefined`

Account to execute the calls. 

If set to `null`, it is assumed that the wallet will handle filling the sender of the calls.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### calls

`{ to: Hex, data?: Hex, value?: bigint }[]`

Calls to execute.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [ // [!code focus]
    { // [!code focus]
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
      value: parseEther('1') // [!code focus]
    }, // [!code focus]
    { // [!code focus]
      data: '0xdeadbeef', // [!code focus]
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
    }, // [!code focus]
  ], // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### capabilities

`WalletCapabilities | undefined`

Capability metadata for the calls (e.g. specifying a paymaster).

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
  capabilities: { // [!code focus]
    paymasterService: { // [!code focus]
      url: 'https://...' // [!code focus]
    } // [!code focus]
  } // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`number | undefined`

The target chain ID to broadcast the calls.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
  chainId: 10, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get send the calls with.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { getConnections } from '@wagmi/core'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SendCallsReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type SendCallsErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`sendCalls`](https://viem.sh/experimental/eip5792/sendCalls)
</file>

<file path="site/core/api/actions/sendTransaction.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'sendTransaction'
const typeName = 'SendTransaction'
</script>

# sendTransaction

Action for creating, signing, and sending transactions to networks.

## Import

```ts
import { sendTransaction } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SendTransactionParameters } from '@wagmi/core'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when sending transaction. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  chainId: mainnet.id, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to send transaction with.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getConnections, sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const connections = getConnections(config)
const result = await sendTransaction(config, {
  connector: connections[0]?.connector, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined | null`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  gas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  nonce: 123, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`Address`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  type: 'eip1559', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SendTransactionReturnType } from '@wagmi/core'
```

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

Transaction hash.

## Error

```ts
import { type SendTransactionErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html)
</file>

<file path="site/core/api/actions/showCallsStatus.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'showCallsStatus'
const typeName = 'ShowCallsStatus'
</script>

# showCallsStatus

Action to request for the wallet to show information about a call batch that was sent via `showCalls`.

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_showcallsstatus)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { showCallsStatus } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { showCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

await showCallsStatus(config, {
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ShowCallsStatusParameters } from '@wagmi/core/experimental'
```

### connector

`Connector | undefined`

Connector to show call statuses with.

::: code-group
```ts [index.ts]
import { getConnections, showCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
await showCallsStatus(config, {
  connector: connections[0]?.connector, // [!code focus]
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { showCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

await showCallsStatus(config, {
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ShowCallsStatusReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type ShowCallsStatusErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`showCallsStatus`](https://viem.sh/experimental/eip5792/showCallsStatus)
</file>

<file path="site/core/api/actions/signMessage.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'signMessage'
const typeName = 'SignMessage'
</script>

# signMessage

Action for signing messages.

## Import

```ts
import { signMessage } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { signMessage } from '@wagmi/core'
import { config } from './config'

await signMessage(config, { message: 'hello world' })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SignMessageParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use when signing message. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { signMessage } from '@wagmi/core'
import { config } from './config'

const result = await signMessage(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  message: 'hello world',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign message with.

::: code-group
```ts [index.ts]
import { getAccount, signMessage } from '@wagmi/core'
import { config } from './config'

const { connector } = getAccount(config)
const result = await signMessage(config, {
  connector, // [!code focus]
  message: 'hello world',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### message

`string | { raw: Hex | ByteArray }`

Message to sign.

::: code-group
```ts [index.ts]
import { signMessage } from '@wagmi/core'
import { config } from './config'

const result = await signMessage(config, {
  message: 'hello world', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

```ts
import { signMessage } from '@wagmi/core'
import { config } from './config'

const result = await signMessage(config, {
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus]
})
```
:::

## Return Type

```ts
import { type SignMessageReturnType } from '@wagmi/core'
```

[`Hex`](https://viem.sh/docs/glossary/types.html#hex)

The signed message.

## Error

```ts
import { type SignMessageErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`signMessage`](https://viem.sh/docs/actions/wallet/signMessage.html)
</file>

<file path="site/core/api/actions/signTypedData.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'signTypedData'
const typeName = 'SignTypedData'
</script>

# signTypedData

Action for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

## Import

```ts
import { signTypedData } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'

const result = await signTypedData(config, {
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SignTypedDataParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign data with.

::: code-group
```ts [index.ts]
import { getAccount, signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const { connector } = getAccount(config)
const result = await signTypedData(config, {
  connector, // [!code focus]
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### domain

`TypedDataDomain | undefined`

- The typed data domain.
- If `EIP712Domain` key exists in [`types`](#types), `domain` schema is inferred from it.

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  domain: { // [!code focus]
    name: 'Ether Mail', // [!code focus]
    chainId: 1, // [!code focus]
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC', // [!code focus]
    version: '1', // [!code focus]
  }, // [!code focus]
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### message

`Record<string, unknown>`

- Data to sign.
- Type inferred from [`types`](#types) and [`primaryType`](#primarytype).

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  types,
  primaryType: 'Mail',
  message: { // [!code focus]
    from: { // [!code focus]
      name: 'Cow', // [!code focus]
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826', // [!code focus]
    }, // [!code focus]
    to: { // [!code focus]
      name: 'Bob', // [!code focus]
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB', // [!code focus]
    }, // [!code focus]
    contents: 'Hello, Bob!', // [!code focus]
  }, // [!code focus]
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### primaryType

`string`

- The primary type to extract from [`types`](#types) and use in [`message`](#message).
- Type inferred from [`types`](#types).

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  types,
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### types

`TypedData`

- The type definitions for the typed data.
- By defining inline or adding a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) to `types`, TypeScript will infer the correct types for [`message`](#message) and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/core/typescript) for more information.

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'

const result = await signTypedData(config, {
  types: { // [!code focus]
    Person: [ // [!code focus]
      { name: 'name', type: 'string' }, // [!code focus]
      { name: 'wallet', type: 'address' }, // [!code focus]
    ], // [!code focus]
    Mail: [ // [!code focus]
      { name: 'from', type: 'Person' }, // [!code focus]
      { name: 'to', type: 'Person' }, // [!code focus]
      { name: 'contents', type: 'string' }, // [!code focus]
    ], // [!code focus]
  }, // [!code focus]
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SignTypedDataReturnType } from '@wagmi/core'
```

[`Hex`](https://viem.sh/docs/glossary/types.html#hex)

The signed data.

## Type Inference

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/core/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { createConfig, http, signTypedData } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const result = await signTypedData(config, {
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
```ts twoslash [Const-Asserted]
import { createConfig, http, signTypedData } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const

const result = await signTypedData(config, {
  types,
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
:::

## Error

```ts
import { type SignTypedDataErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`signTypedData`](https://viem.sh/docs/actions/wallet/signTypedData.html)
</file>

<file path="site/core/api/actions/simulateContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'simulateContract'
const typeName = 'SimulateContract'
</script>

# simulateContract

Action for simulating/validating a contract interaction.

## Import

```ts
import { simulateContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SimulateContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const result = await simulateContract(config, {
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address`

The contract's address.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::


### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [ // [!code focus]
    '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    123n, // [!code focus]
  ], // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to simulate against.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to simulate against.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  blockTag: 'safe', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to simulate transaction with.

::: code-group
```ts [index.ts]
import { getAccount, simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const { connector } = getAccount(config)
const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  connector, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  dataSuffix: '0xdeadbeef', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### functionName

`string`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'approve', // [!code focus]
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 123n]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gasPrice: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  nonce: 123, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  type: 'eip1559', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SimulateContractReturnType } from '@wagmi/core'
```

The simulation result and write request.

### request

Write request that includes [parameters](#parameters).

### response

`unknown`

- Result of contract simulation.
- Inferred from [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args).

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type SimulateContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`simulateContract`](https://viem.sh/docs/contract/simulateContract.html)
</file>

<file path="site/core/api/actions/switchAccount.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'switchAccount'
const typeName = 'SwitchAccount'
</script>

# switchAccount

Action for switching the current account.

## Import

```ts
import { switchAccount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnections, switchAccount } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const result = await switchAccount(config, {
  connector: connections[0]?.connector,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SwitchAccountParameters } from '@wagmi/core'
```

### connector

`Connector`

[Connector](/core/api/connectors) to switch to.

::: code-group
```ts [index.ts]
import { getConnections, switchAccount } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const result = await switchAccount(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SwitchAccountReturnType } from '@wagmi/core'
```

### accounts

`readonly [Address, ...Address[]]`
  
Connected accounts from connector.

### chainId

`number`

Connected chain ID from connector.

## Error

```ts
import { type SwitchAccountErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="site/core/api/actions/switchChain.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'switchChain'
const typeName = 'SwitchChain'
</script>

# switchChain

Action for switching the target chain for a connector or the Wagmi [`Config`](/core/api/createConfig#config).

## Import

```ts
import { switchChain } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { switchChain } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await switchChain(config, { chainId: mainnet.id })
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](/core/api/createConfig#config).
:::

## Parameters

```ts
import { type SwitchChainParameters } from '@wagmi/core'
```

### addEthereumChainParameter

`{ chainName: string; nativeCurrency?: { name: string; symbol: string; decimals: number } | undefined; rpcUrls: readonly string[]; blockExplorerUrls?: string[] | undefined; iconUrls?: string[] | undefined } | undefined`

[EIP-3085 parameters](https://eips.ethereum.org/EIPS/eip-3085) to use when adding chain to connector (when supported).

::: code-group
```ts [index.ts]
import { switchChain } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await switchChain(config, {
  addEthereumChainParameter: { // [!code focus]
    iconUrls: ['https://example.com/icon.png'], // [!code focus]
  }, // [!code focus]
  chainId: mainnet.id,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to switch to.

::: code-group
```ts [index.ts]
import { switchChain } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await switchChain(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector`

[Connector](/core/api/connectors) to switch chain with.

::: code-group
```ts [index.ts]
import { getConnections, switchAccount } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const connections = getConnections(config)
const result = await switchChain(config, {
  chainId: mainnet.id,
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SwitchChainReturnType } from '@wagmi/core'
```

`Chain`

Chain that was switched to.

## Error

```ts
import { type SwitchChainErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`switchChain`](https://viem.sh/docs/actions/wallet/switchChain.html) when connected.
</file>

<file path="site/core/api/actions/verifyMessage.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'verifyMessage'
const typeName = 'VerifyMessage'
</script>

# verifyMessage

Action for verify that a message was signed by the provided address. It supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { verifyMessage } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type VerifyMessageParameters } from '@wagmi/core'
```

### address

`Address`

The Ethereum address that signed the original message.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### message

`string | { raw: Hex | ByteArray }`

The message to be verified.

By default, wagmi verifies the UTF-8 representation of the message.

::: code-group
```ts [index.ts]
import { getAccount, verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

```ts
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: { raw: '0x68656c6c6f20776f726c64' } // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
:::

### signature

`Hex | ByteArray `

The signature that was generated by signing the message with the address's signer.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await verifyMessage(config, {
  chainId: mainnet.id, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  blockNumber: 12345678n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  blockTag: 'latest', // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type VerifyMessageReturnType } from '@wagmi/core'
```

`boolean`

Whether the signed message is valid for the given address.

## Error

```ts
import { type VerifyMessageErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`verifyMessage`](https://viem.sh/docs/actions/public/verifyMessage.html)
</file>

<file path="site/core/api/actions/verifyTypedData.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'verifyTypedData'
const typeName = 'verifyTypedData'
</script>

# verifyTypedData

Action for verify that a typed data was signed by the provided address. It supports verifying typed data that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { verifyTypedData } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type VerifyTypedDataParameters } from '@wagmi/core'
```

### address

`Address`

The Ethereum address that signed the original typed data.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### domain

`TypedDataDomain`

The typed data domain.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### types

The type definitions for the typed data.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### primaryType

`string`

The primary `type` to extract from types and use in `value`.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail', // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### message

Type inferred from `types` & `primaryType`.

The message to be verified.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### signature

`Hex | ByteArray`

The signature that was generated by signing the typed data with the address's signer.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },  
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  chainId: mainnet.id, // [!code focus]
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  blockNumber: 12345678n, // [!code focus]
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  blockTag: 'latest', // [!code focus]
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type VerifyTypedDataReturnType } from '@wagmi/core'
```

`boolean`

Whether the signed message is valid for the given address.

## Type Inference

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type VerifyTypedDataErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`verifyTypedData`](https://viem.sh/docs/actions/public/verifyTypedData.html)
</file>

<file path="site/core/api/actions/waitForCallsStatus.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'waitForCallsStatus'
const typeName = 'WaitForCallsStatus'
</script>

# waitForCallsStatus

Waits for a call bundle to be confirmed & included on a block before returning the status & receipts.

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { waitForCallsStatus } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls, waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [{
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1')
  }]
})

const { status, receipts } = await waitForCallsStatus(config, { // [!code focus]
  id, // [!code focus]
}) // [!code focus]
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WaitForCallsStatusParameters } from '@wagmi/core/experimental'
```

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```ts [index.ts]
import { getConnections, waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const status = await waitForCallsStatus(config, {
  connector: connections[0]?.connector, // [!code focus]
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await waitForCallsStatus(config, {
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number`

Polling interval in milliseconds.

::: code-group
```ts [index.ts]
import { waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await waitForCallsStatus(config, {
  id: '0x1234567890abcdef',
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### timeout

`number`

Timeout in milliseconds before `waitForCallsStatus` stops polling.

::: code-group
```ts [index.ts]
import { waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await waitForCallsStatus(config, {
  id: '0x1234567890abcdef',
  timeout: 10_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WaitForCallsStatusReturnType } from '@wagmi/core/experimental'
```

`{ status: 'PENDING' | 'CONFIRMED', receipts: TransactionReceipt[] }`

The status and receipts of the call batch.

## Error

```ts
import { type WaitForCallsStatusErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`waitForCallsStatus`](https://viem.sh/experimental/eip5792/waitForCallsStatus)
</file>

<file path="site/core/api/actions/waitForTransactionReceipt.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'waitForTransactionReceipt'
const typeName = 'WaitForTransactionReceipt'
</script>

# waitForTransactionReceipt

Action that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

## Import

```ts
import { waitForTransactionReceipt } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WaitForTransactionReceiptParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### confirmations

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  confirmations: 2, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onReplaced

`
(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined
`

Optional callback to emit if the transaction has been replaced.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  onReplaced: replacement => console.log(replacement), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### hash

`` `0x${string}` ``

The transaction hash to wait for.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WaitForTransactionReceiptReturnType } from '@wagmi/core'
```

[`TransactionReceipt`](https://viem.sh/docs/glossary/types.html#transactionreceipt)

The transaction receipt.

## Error

```ts
import { type WaitForTransactionReceiptErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`waitForTransactionReceipt`](https://viem.sh/docs/actions/public/waitForTransactionReceipt.html)
</file>

<file path="site/core/api/actions/watchAccount.md">
# watchAccount

Subscribe to account changes.

## Import

```ts
import { watchAccount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchAccount } from '@wagmi/core'
import { config } from './config'

const unwatch = watchAccount(config, {
  onChange(data) {
    console.log('Account changed!', data)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchAccountParameters } from '@wagmi/core'
```

### onChange

`onChange(account: GetAccountReturnType, prevAccount: GetAccountReturnType): void`

Callback function called when account changes.

::: code-group
```ts [index.ts]
import { watchAccount } from '@wagmi/core'
import { config } from './config'

const unwatch = watchAccount(config, {
  onChange(account) { // [!code focus:3]
    console.log('Account changed!', account)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchAccountReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="site/core/api/actions/watchAsset.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'watchAsset'
const typeName = 'WatchAsset'
</script>

# watchAsset

Action for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

## Import

```ts
import { watchAsset } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchAsset } from '@wagmi/core'
import { config } from './config'

await watchAsset(config, {
  type: 'ERC20',
  options: {
    address: '0x0000000000000000000000000000000000000000',
    symbol: 'WAGMI',
    decimals: 18,
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchAssetParameters } from '@wagmi/core'
```

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign message with.

::: code-group
```ts [index.ts]
import { getAccount, watchAsset } from '@wagmi/core'
import { config } from './config'

const { connector } = getAccount(config)
const result = await watchAsset(config, {
  connector, // [!code focus]
  options: {
    address: '0x0000000000000000000000000000000000000000',
    symbol: 'WAGMI',
    decimals: 18,
  },
  type: 'ERC20',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### options

`{ address: string; symbol: string; decimals: number; image?: string | undefined; }`

Asset options.

::: code-group
```ts [index.ts]
import { watchAsset } from '@wagmi/core'
import { config } from './config'

const result = await watchAsset(config, {
  options: { // [!code focus]
    address: '0x0000000000000000000000000000000000000000', // [!code focus]
    symbol: 'WAGMI', // [!code focus]
    decimals: 18, // [!code focus]
  }, // [!code focus]
  type: 'ERC20',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'ERC20'`

Type of asset.

::: code-group
```ts [index.ts]
import { watchAsset } from '@wagmi/core'
import { config } from './config'

const result = await watchAsset(config, {
  options: {
    address: '0x0000000000000000000000000000000000000000',
    symbol: 'WAGMI',
    decimals: 18,
  },
  type: 'ERC20', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchAssetReturnType } from '@wagmi/core'
```

`boolean`

Returns a boolean indicating if the token was successfully added.

## Error

```ts
import { type WatchAssetErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`watchAsset`](https://viem.sh/docs/actions/wallet/watchAsset.html)
</file>

<file path="site/core/api/actions/watchBlockNumber.md">
# watchBlockNumber

Action that watches for block number changes.

## Import

```ts
import { watchBlockNumber } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchBlockNumberParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  chainId: mainnet.id, // [!code focus]
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean | undefined`

Whether or not to emit the latest block number to the callback when the subscription opens.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  emitOnBegin: true, // [!code focus]
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean | undefined`

Whether or not to emit the missed block numbers to the callback.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  emitMissed: true, // [!code focus]
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::


### onBlockNumber

`(blockNumber: bigint, prevBlockNumber: bigint | undefined) => void`

Callback for when block number changes.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { // [!code focus]
    console.log('Block number changed!', blockNumber) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { 
    console.log('Block number changed!', blockNumber) 
  }, 
  onError(error) { // [!code focus]
    console.error('Block number error', error) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { 
    console.log('Block number changed!', blockNumber) 
  }, 
  poll: true, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { 
    console.log('Block number changed!', blockNumber) 
  }, 
  pollingInterval: 1_000, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
  syncConnectedChain: false, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchBlockNumberReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.

## Viem

- [`watchBlockNumber`](https://viem.sh/docs/actions/public/watchBlockNumber.html)
</file>

<file path="site/core/api/actions/watchBlocks.md">
# watchBlocks

Action that watches for block changes.

## Import

```ts
import { watchBlocks } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchBlocksParameters } from '@wagmi/core'
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Watch for new blocks on a given tag. Defaults to `'latest'`.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  blockTag: 'pending', // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const unwatch = watchBlocks(config, {
  chainId: mainnet.id, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  emitMissed: true, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  emitOnBegin: true, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onBlock

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) { // [!code focus]
    console.log('Block changed!', block) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) { 
    console.log('Block changed!', block) 
  }, 
  onError(error) { // [!code focus]
    console.error('Block error', error) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  poll: true, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  pollingInterval: 1_000, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) {
    console.log('Block changed!', block)
  },
  syncConnectedChain: false, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchBlocksReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.

## Viem

- [`watchBlocks`](https://viem.sh/docs/actions/public/watchBlocks.html)
</file>

<file path="site/core/api/actions/watchChainId.md">
# watchChainId

Subscribe to chain ID changes.

## Import

```ts
import { watchChainId } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchChainId } from '@wagmi/core'
import { config } from './config'

const unwatch = watchChainId(config, {
  onChange(chainId) {
    console.log('Chain ID changed!', chainId)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchChainIdParameters } from '@wagmi/core'
```

### onChange

`onChange(chainId: GetChainIdReturnType, prevChainId: GetChainIdReturnType): void`

Callback function called when chain ID changes.

::: code-group
```ts [index.ts]
import { watchChainId } from '@wagmi/core'
import { config } from './config'

const unwatch = watchChainId(config, {
  onChange(chainId) { // [!code focus:3]
    console.log('Chain ID changed!', chainId)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchChainIdReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="site/core/api/actions/watchClient.md">
# watchClient

Subscribe to Client changes.

## Import

```ts
import { watchClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchClient(config, {
  onChange(client) {
    console.log('Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchClientParameters } from '@wagmi/core'
```

### onChange

`onChange(client: GetClientReturnType, prevClient: GetClientReturnType): void`

Callback function called when Client changes.

::: code-group
```ts [index.ts]
import { watchClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchClient(config, {
  onChange(client) { // [!code focus:3]
    console.log('Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchClientReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="site/core/api/actions/watchConnections.md">
# watchConnections

Subscribe to connections changes.

## Import

```ts
import { watchConnections } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchConnections } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnections(config, {
  onChange(data) {
    console.log('Connections changed!', data)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchConnectionsParameters } from '@wagmi/core'
```

### onChange

`onChange(connections: GetConnectionsReturnType, prevConnections: GetConnectionsReturnType): void`

Callback function called when connections changes.

::: code-group
```ts [index.ts]
import { watchConnections } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnections(config, {
  onChange(data) { // [!code focus:3]
    console.log('Connections changed!', data)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchConnectionsReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="site/core/api/actions/watchConnectors.md">
# watchConnectors

Subscribe to connectors changes.

## Import

```ts
import { watchConnectors } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchConnectors } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnectors(config, {
  onChange(connectors) {
    console.log('Connectors changed!', connectors)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchConnectorsParameters } from '@wagmi/core'
```

### onChange

`onChange(connectors: GetConnectorsReturnType, prevConnectors: GetConnectorsReturnType): void`

Callback function called when connectors changes.

::: code-group
```ts [index.ts]
import { watchConnectors } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnectors(config, {
  onChange(connectors) { // [!code focus:3]
    console.log('Connectors changed!', connectors)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchConnectorsReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="site/core/api/actions/watchContractEvent.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'watchContractEvent'
const typeName = 'WatchContractEvent'
</script>

# watchContractEvent

Action that watches and returns emitted contract event logs.

## Import

```ts
import { watchContractEvent } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  abi,
  eventName: 'Transfer',
  onLogs(logs) {
    console.log('New logs!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchContractEventParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### args

`object | readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`eventName`](#eventname).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  args: { // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  }, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### batch

`boolean | undefined`

- Whether or not the events should be batched on each invocation.
- Defaults to `true`.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  batch: false, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  chainId: mainnet.id, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### eventName

`string`

- Event to listen for the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  eventName: 'Approval', // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) { 
    console.log('Logs changed!', logs) 
  }, 
  onError(error) { // [!code focus]
    console.error('Logs error', error) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### onLogs

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) { // [!code focus]
    console.log('Logs changed!', logs) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  poll: true, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  pollingInterval: 1_000, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### strict

`boolean | undefined`

- Defaults to `false`.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  strict: true, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  syncConnectedChain: false, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchContractEventReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`eventName`](#eventname), [`args`](#args), and [`onLogs`](#onlogs) parameters. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type WatchContractEventError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`watchContractEvent`](https://viem.sh/docs/contract/watchContractEvent.html)
</file>

<file path="site/core/api/actions/watchPendingTransactions.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'watchPendingTransactions'
const typeName = 'WatchPendingTransactions'
</script>

# watchPendingTransactions

Action that watches and returns pending transaction hashes.

## Import

```ts
import { watchPendingTransactions } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchPendingTransactionsParameters } from '@wagmi/core'
```

### batch

`boolean | undefined`

- Whether or not the transactions should be batched on each invocation.
- Defaults to `true`.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'

const unwatch = watchPendingTransactions(config, {
  batch: false, // [!code focus]
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  chainId: mainnet.id, // [!code focus]
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from watching pending transactions.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onError(error) { // [!code focus]
    console.log('Error', error) // [!code focus]
  }, // [!code focus]
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onTransactions

`(transactions: Hash[], prevTransactions: Hash[] | undefined) => void`

Callback when new incoming pending transactions are detected.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) { // [!code focus]
    console.log('New transactions!', transactions) // [!code focus]
  }, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
  poll: false, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
  syncConnectedChain: false, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchPendingTransactionsReturnType } from '@wagmi/core'
```

Function to unsubscribe from pending transaction listener.

## Error

```ts
import { type WatchPendingTransactionsError } from '@wagmi/core'
```

## Viem

- [`watchPendingTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html)
</file>

<file path="site/core/api/actions/watchPublicClient.md">
# watchPublicClient

Subscribe to Public Client changes.

## Import

```ts
import { watchPublicClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchPublicClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPublicClient(config, {
  onChange(client) {
    console.log('Public Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchPublicClientParameters } from '@wagmi/core'
```

### onChange

`onChange(client: GetPublicClientReturnType, prevClient: GetPublicClientReturnType): void`

Callback function called when Public Client changes.

::: code-group
```ts [index.ts]
import { watchPublicClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPublicClient(config, {
  onChange(client) { // [!code focus:3]
    console.log('Public Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchPublicClientReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="site/core/api/actions/writeContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'writeContract'
const typeName = 'WriteContract'
</script>

# writeContract

Action for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

## Import

```ts
import { writeContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

::::tip Pairing with `simulateContract`

Pairing [`simulateContract`](/core/api/actions/simulateContract) with `writeContract` allows you to validate if the transaction will succeed ahead of time. If the simulate succeeds, `writeContract` can execute the transaction.

::: code-group
```ts [index.ts]
import { simulateContract, writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const { request } = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
const hash = await writeContract(config, request)
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::
::::


## Parameters

```ts
import { type WriteContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const result = await writeContract(config, {
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address`

The contract's address.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::


### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [ // [!code focus]
    '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    123n, // [!code focus]
  ] // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign data with.

::: code-group
```ts [index.ts]
import { getAccount, writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const { connector } = getAccount(config)
const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  connector, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  dataSuffix: '0xdeadbeef', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### functionName

`string`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'approve', // [!code focus]
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 123n]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::


### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gasPrice: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  nonce: 123, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  type: 'eip1559', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WriteContractReturnType } from '@wagmi/core'
```

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

The transaction hash.

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type WriteContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`writeContract`](https://viem.sh/docs/contract/writeContract.html)
</file>

<file path="site/core/api/actions/writeContracts.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'writeContracts'
const typeName = 'WriteContracts'
</script>

# writeContracts

Action that requests for the wallet to sign and broadcast a batch of write contract calls (transactions) to the network.

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { writeContracts } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WriteContractsParameters } from '@wagmi/core/experimental'
```

### account

`Account | Address | undefined`

Account to execute the calls.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### contracts

`{ to: Hex, data?: Hex, value?: bigint }[]`

Calls to execute.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [ // [!code focus]
    { // [!code focus]
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
      abi, // [!code focus]
      functionName: 'approve', // [!code focus]
      args: [ // [!code focus]
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
        100n // [!code focus]
      ], // [!code focus]
    }, // [!code focus]
    { // [!code focus]
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
      abi, // [!code focus]
      functionName: 'transferFrom', // [!code focus]
      args: [ // [!code focus]
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
        '0x0000000000000000000000000000000000000000', // [!code focus]
        100n // [!code focus]
      ], // [!code focus]
    }, // [!code focus]
  ], // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### capabilities

`WalletCapabilities | undefined`

Capability metadata for the calls (e.g. specifying a paymaster).

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
  capabilities: { // [!code focus]
    paymasterService: { // [!code focus]
      url: 'https://...' // [!code focus]
    } // [!code focus]
  } // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`number | undefined`

The target chain ID to broadcast the calls.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
  chainId: 10, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get send the calls with.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { getConnections } from '@wagmi/core'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const connections = getConnections(config)
const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WriteContractsReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type WriteContractsErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`writeContracts`](https://viem.sh/experimental/eip5792/writeContracts)
</file>

<file path="site/core/api/connectors/coinbaseWallet.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/coinbaseWallet.md -->
</file>

<file path="site/core/api/connectors/injected.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/injected.md -->
</file>

<file path="site/core/api/connectors/metaMask.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/metaMask.md -->
</file>

<file path="site/core/api/connectors/mock.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/mock.md -->
</file>

<file path="site/core/api/connectors/safe.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/safe.md -->
</file>

<file path="site/core/api/connectors/walletConnect.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/walletConnect.md -->
</file>

<file path="site/core/api/transports/custom.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/custom.md -->
</file>

<file path="site/core/api/transports/fallback.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/fallback.md -->
</file>

<file path="site/core/api/transports/http.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/http.md -->
</file>

<file path="site/core/api/transports/unstable_connector.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/unstable_connector.md -->
</file>

<file path="site/core/api/transports/webSocket.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/webSocket.md -->
</file>

<file path="site/core/api/utilities/cookieToInitialState.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/cookieToInitialState.md-->
</file>

<file path="site/core/api/utilities/deserialize.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/deserialize.md-->
</file>

<file path="site/core/api/utilities/normalizeChainId.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/normalizeChainId.md-->
</file>

<file path="site/core/api/utilities/serialize.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/serialize.md-->
</file>

<file path="site/core/api/actions.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const actions = getSidebar()['/core']
  .find(x => x.text.includes('Actions')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Actions

Actions for accounts, wallets, contracts, transactions, signing, ENS, and more.

## Import

```ts
import { getAccount } from '@wagmi/core'
```

## Available Actions

<ul>
  <li v-for="action of actions">
    <a :href="action.link">{{ action.text }}</a>
  </li>
</ul>
</file>

<file path="site/core/api/chains.md">
<script setup>
import packageJson from '../../../package.json'
import SearchChains from '../../components/SearchChains.vue'

const viemVersion = packageJson.devDependencies.viem
</script>

# Chains

## Import

Import via the `'@wagmi/core/chains'` entrypoint (proxies all chains from `'viem/chains'`).

```ts
import { mainnet } from '@wagmi/core/chains'
```

## Available Chains

Chain definitions as of `viem@{{viemVersion}}`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

<SearchChains />

<!--@include: @shared/create-chain.md-->
</file>

<file path="site/core/api/connectors.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const connectors = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Connectors')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Connectors

Connectors for popular wallet providers and protocols.

## Import

```ts
import { injected } from 'wagmi/connectors'
```

## Built-In Connectors

Available via the `'wagmi/connectors'` entrypoint.

<ul>
  <li v-for="connector of connectors">
    <a :href="connector.link">{{ connector.text }}</a>
  </li>
</ul>
</file>

<file path="site/core/api/createConfig.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!--@include: @shared/createConfig.md-->
</file>

<file path="site/core/api/createConnector.md">
# createConnector

Creates new [`CreateConnectorFn`](#parameters).

## Import

```ts
import { createConnector } from '@wagmi/core'
```

## Usage

```ts
import { createConnector } from '@wagmi/core'

export type InjectedParameters = {}

export function injected(parameters: InjectedParameters = {}) {
  return createConnector((config) => ({
    // ...
  }))
}
```

## Parameters

```ts
import { type CreateConnectorFn } from '@wagmi/core'
```

Read [Creating Connectors](/dev/creating-connectors) for more info on the `CreateConnectorFn` type.
</file>

<file path="site/core/api/createStorage.md">
<script setup>
const docsPath = "core"
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/createStorage.md-->
</file>

<file path="site/core/api/errors.md">
<script setup>
const docsPath = "core"
const packageName = '@wagmi/core'
</script>

# Errors

Error classes used by Wagmi.

<!--@include: @shared/errors.md-->
</file>

<file path="site/core/api/transports.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const transports = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Transports')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Transports

[`createConfig`](/core/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

## Import

```ts
import { http } from '@wagmi/core'
```

## Built-In Transports

Available via the `'@wagmi/core'` entrypoint.

<ul>
  <li v-for="transport of transports">
    <a :href="transport.link">{{ transport.text }}</a>
  </li>
</ul>
</file>

<file path="site/core/guides/chain-properties.md">
# Chain Properties

Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains support all additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

## Narrowing Parameters

When you pass your `config` to an action, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { simulateContract } from '@wagmi/core'
import { config } from './config'

const result = await simulateContract(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  feeCurrency: '0x‚Ä¶', // [!code focus]
})
```
<<< @/snippets/core/config-chain-properties.ts[config.ts]
:::

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { simulateContract } from '@wagmi/core'
import { celo } from 'wagmi/chains'

const result = await simulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  chainId: celo.id, // [!code focus]
  feeCurrency: '0x‚Ä¶', // [!code focus]
  // ^? (property) feeCurrency?: `0x${string}` | undefined // [!code focus]
})
```
<<< @/snippets/core/config-chain-properties.ts[config.ts]
:::

## Narrowing Return Types

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

::: code-group
```ts [index.tsx]
import { waitForTransactionReceipt } from '@wagmi/core'
import { zkSync } from '@wagmi/core/chains'

const result = await waitForTransactionReceipt({
  chainId: zkSync.id,
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

result.logs
//     ^? (property) logs: ZkSyncLog[] | undefined
```
<<< @/snippets/core/config-chain-properties.ts[config.ts]
:::

### `chainId` Data Property

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

::: code-group
```ts [index.tsx]
import { waitForTransactionReceipt } from '@wagmi/core'
import { zkSync } from '@wagmi/core/chains'

const result = await waitForTransactionReceipt({
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

if (result.chainId === zkSync.id) {
  result.logs
  //     ^? (property) logs: ZkSyncLog[] | undefined
}
```
<<< @/snippets/core/config-chain-properties.ts[config.ts]
:::

## Troubleshooting

If chain properties aren't working, make sure [TypeScript](/core/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).
</file>

<file path="site/core/guides/error-handling.md">
# Error Handling

Every module in Wagmi Core exports an accompanying error type which you can use to strongly type your `catch` statements.

These types come in the form of `<Module>ErrorType`. For example, the `getBlockNumber` action exports a `GetBlockNumberErrorType` type.

Unfortunately, [TypeScript doesn't have an abstraction for typed exceptions](https://github.com/microsoft/TypeScript/issues/13219), so the most pragmatic & vanilla approach would be to explicitly cast error types in the `catch` statement.

::: code-group
```tsx [index.tsx]
import { type GetBlockNumberErrorType, getBlockNumber } from '@wagmi/core'
import { config } from './config'

try {
  const blockNumber = await getBlockNumber(config)
} catch (e) {
  const error = e as GetBlockNumberErrorType
  error.name
  //    ^? (property) name: "Error" | "ChainDisconnectedError" | "HttpRequestError" | "InternalRpcError" | "InvalidInputRpcError" | "InvalidParamsRpcError" | "InvalidRequestRpcError" | "JsonRpcVersionUnsupportedError" | ... 16 more ... | "WebSocketRequestError"

  if (error.name === 'InternalRpcError')
    error.code
    //    ^? (property) code: -32603

  if (error.name === 'HttpRequestError')
    error.headers
    //    ^? (property) headers: Headers
    error.status
    //    ^? (property) status: number
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
If you are using [Wagmi Hooks](/react/api/hooks), errors are [already strongly typed](/react/guides/error-handling) via the `error` property.
:::
</file>

<file path="site/core/guides/ethers.md">
# Ethers.js Adapters

It is recommended for projects to migrate to [Viem](https://viem.sh) when using Wagmi, but there are some cases where you might still need to use [Ethers.js](https://ethers.org) in your project:

- You may want to **incrementally migrate** Ethers.js usage to Viem
- Some **third-party libraries & SDKs** may only support Ethers.js
- Personal preference

We have provided reference implementations for Viem ‚Üí Ethers.js adapters that you can copy + paste in your project.

## Client ‚Üí Provider

### Reference Implementation

Copy the following reference implementation into a file of your choice:

::: code-group

```ts [Ethers v5]
import { type Config, getClient } from '@wagmi/core'
import { providers } from 'ethers'
import type { Client, Chain, Transport } from 'viem'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback')
    return new providers.FallbackProvider(
      (transport.transports as ReturnType<Transport>[]).map(
        ({ value }) => new providers.JsonRpcProvider(value?.url, network),
      ),
    )
  return new providers.JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Public Client to an ethers.js Provider. */
export function getEthersProvider(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = getClient(config, { chainId })
  if (!client) return
  return clientToProvider(client)
}
```

```ts [Ethers v6]
import { type Config, getClient } from '@wagmi/core'
import { FallbackProvider, JsonRpcProvider } from 'ethers'
import type { Client, Chain, Transport } from 'viem'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback') {
    const providers = (transport.transports as ReturnType<Transport>[]).map(
      ({ value }) => new JsonRpcProvider(value?.url, network),
    )
    if (providers.length === 1) return providers[0]
    return new FallbackProvider(providers)
  }
  return new JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Client to an ethers.js Provider. */
export function getEthersProvider(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = getClient(config, { chainId })
  if (!client) return
  return clientToProvider(client)
}
```

:::

### Usage

Now you can use the `getEthersProvider` function in your components:

::: code-group

```ts [example.ts]
import { getEthersProvider } from './ethers'
import { config } from './config'

function example() {
  const provider = getEthersProvider(config)
  ...
}
```

```ts [ethers.ts (Ethers v5)]
import { type Config, getClient } from '@wagmi/core'
import { providers } from 'ethers'
import type { Client, Chain, Transport } from 'viem'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback')
    return new providers.FallbackProvider(
      (transport.transports as ReturnType<Transport>[]).map(
        ({ value }) => new providers.JsonRpcProvider(value?.url, network),
      ),
    )
  return new providers.JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Public Client to an ethers.js Provider. */
export function getEthersProvider(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = getClient(config, { chainId })
  if (!client) return
  return clientToProvider(client)
}

```

```ts [ethers.ts (Ethers v6)]
import { type Config, getClient } from '@wagmi/core'
import { FallbackProvider, JsonRpcProvider } from 'ethers'
import type { Client, Chain, Transport } from 'viem'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback') {
    const providers = (transport.transports as ReturnType<Transport>[]).map(
      ({ value }) => new JsonRpcProvider(value?.url, network),
    )
    if (providers.length === 1) return providers[0]
    return new FallbackProvider(providers)
  }
  return new JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Client to an ethers.js Provider. */
export function getEthersProvider(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = getClient(config, { chainId })
  if (!client) return
  return clientToProvider(client)
}
```

:::

## Connector Client ‚Üí Signer

### Reference Implementation

Copy the following reference implementation into a file of your choice:

::: code-group

```ts [Ethers v5]
import { Config, getConnectorClient } from '@wagmi/core'
import { providers } from 'ethers'
import type { Account, Chain, Client, Transport } from 'viem'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new providers.Web3Provider(transport, network)
  const signer = provider.getSigner(account.address)
  return signer
}

/** Action to convert a Viem Client to an ethers.js Signer. */
export async function getEthersSigner(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = await getConnectorClient(config, { chainId })
  return clientToSigner(client)
}
```

```ts [Ethers v6]
import { Config, getConnectorClient } from '@wagmi/core'
import { BrowserProvider, JsonRpcSigner } from 'ethers'
import type { Account, Chain, Client, Transport } from 'viem'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new BrowserProvider(transport, network)
  const signer = new JsonRpcSigner(provider, account.address)
  return signer
}

/** Action to convert a viem Wallet Client to an ethers.js Signer. */
export async function getEthersSigner(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = await getConnectorClient(config, { chainId })
  return clientToSigner(client)
}

```

:::

### Usage

Now you can use the `getEthersSigner` function in your components:

::: code-group

```ts [example.ts]
import { getEthersSigner } from './ethers'
import { config } from './config'

function example() {
  const provider = getEthersSigner(config)
  ...
}
```

```ts [ethers.ts (Ethers v5)]
import { Config, getConnectorClient } from '@wagmi/core'
import { providers } from 'ethers'
import type { Account, Chain, Client, Transport } from 'viem'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new providers.Web3Provider(transport, network)
  const signer = provider.getSigner(account.address)
  return signer
}

/** Action to convert a Viem Client to an ethers.js Signer. */
export async function getEthersSigner(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = await getConnectorClient(config, { chainId })
  return clientToSigner(client)
}
```

```ts [ethers.ts (Ethers v6)]
import { Config, getConnectorClient } from '@wagmi/core'
import { BrowserProvider, JsonRpcSigner } from 'ethers'
import type { Account, Chain, Client, Transport } from 'viem'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new BrowserProvider(transport, network)
  const signer = new JsonRpcSigner(provider, account.address)
  return signer
}

/** Action to convert a viem Wallet Client to an ethers.js Signer. */
export async function getEthersSigner(
  config: Config,
  { chainId }: { chainId?: number } = {},
) {
  const client = await getConnectorClient(config, { chainId })
  return clientToSigner(client)
}

```

:::
</file>

<file path="site/core/guides/faq.md">
<script setup>
const docsPath = 'core'
</script>

# FAQ / Troubleshooting

Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

<!--@include: @shared/faq.md-->
</file>

<file path="site/core/guides/framework-adapters.md">
# Framework Adapters

Folks often ask if they can use Wagmi with other frameworks, like Svelte, Solid.js, and more.

The short answer is ‚Äî you already can! Wagmi Core is pure VanillaJS that you can use with any framework. For some, this answer is (understandably) unsatisfying as they want a tight integration between Wagmi Core and their favorite framework's reactivity system, e.g. what Wagmi is for React and Vue.

Someday, we would love to support additional frameworks, but unfortunately the core team doesn't have time to build and support them in a high-quality way at the moment. This could change in the future with additional [sponsors](https://github.com/sponsors/wevm), reshuffling of the roadmap, or if someone from the community wants to lead the effort.

In the meantime, here are some tips on how to create tighter bonds between Wagmi Core and other frameworks.

## Dependency Injection

Once you create a Wagmi Config, you'll need to make sure your framework has access to it inside your higher-level functions (e.g. hooks for React, composables for Vue). For example, Wagmi uses [React Context](https://react.dev/learn/passing-data-deeply-with-context) to inject the Config into React Hooks and update it if it changes. This makes it so your users don't need to pass a Config object every time they use a hook.

## Reactivity Layer

All frameworks approach reactivity in a different way. To hook into your favorite frameworks, reactivity system, it's often helpful to see what other popular libraries for your framework are doing.

The most important thing to hook up Wagmi Core with your framework is to make sure changes to the Wagmi Config are tracked. This enables behavior, like switching chains or connecting accounts, to propagate throughout your app and update state. Check out [`useAccount`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useAccount.ts), [`useChainId`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useChainId.ts), [`useClient`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useClient.ts), and [`useConnectorClient`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useConnectorClient.ts) ‚Äî versions of these for your framework are important to get right as they power a lot of internals.

## TanStack Query

Wagmi uses [TanStack Query](https://tanstack.com/query) to enable caching, deduplication, persistence, and more in React and Vue applications. Normally, you would need to find a similar library for your framework, but the good news is TanStack Query supports other frameworks! (Svelte, Solid, and Angular at the time of writing.)

To get started with your framework, install and set up the related TanStack Query adapter. Next, import query keys/functions and mutation functions from the `'@wagmi/core/query'` entrypoint. You can plug these directly into your framework's TanStack Query adapter functions.

If you are building a library, you'll also want to make sure that you wire up generics correctly so type-inference and safety work correctly. The best way to make sure you are doing this correctly, is to see how we do this for React with Wagmi by checking out the [source code](https://github.com/wevm/wagmi/tree/main/packages/react/src/hooks).

## Testing

If you are building a library, you'll want to write tests. Wagmi uses [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) to test hooks. [Testing Library](https://testing-library.com) also supports other frameworks, like Svelte, Solid, and more. You can take a look at how the React tests work and do something similar for your code.

## Proxy Exports

Wagmi proxies exports directly from Wagmi Core and [Viem](https://viem.sh) to make importing easier. You'll likely want to imitate this behavior for your framework.
</file>

<file path="site/core/guides/migrate-from-v1-to-v2.md">
---
title: Migrate from v1 to v2
titleTemplate: Wagmi Core
description: Guide for migrating from Wagmi Core v1 to v2.
---

<script setup>
import packageJson from '../../../packages/core/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Migrate from v1 to v2

Wagmi Core v2 redesigns the core APIs to mesh better with [Viem](https://viem.sh). This major version transforms Wagmi into a light wrapper around Viem, sprinkling in multichain support and account management. As such, there are some breaking changes and deprecations to be aware of outlined in this guide.

To get started, install the latest version of Wagmi and it's required peer dependencies.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/core viem@{{viemVersion}} @wagmi/connectors
```

```bash-vue [npm]
npm install @wagmi/core viem@{{viemVersion}} @wagmi/connectors
```

```bash-vue [yarn]
yarn add @wagmi/core viem@{{viemVersion}} @wagmi/connectors
```

```bash-vue [bun]
bun add @wagmi/core viem@{{viemVersion}} @wagmi/connectors
```
:::

::: info Wagmi Core v2 should be the last major version that will have this many actionable breaking changes. 
Moving forward, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.
:::

::: info Not ready to migrate yet?
The Wagmi Core v1 docs are still available at [1.x.wagmi.sh/core](https://1.x.wagmi.sh/core).
:::

## Dependencies

### Dropped CommonJS support

Wagmi v2 no longer publishes a separate `cjs` tag since very few people use this tag and ESM is the future. See [Sindre Sorhus' guide](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c) for more info about switching to ESM.

## Actions

### Removed `config` singleton

Before v2, when you called [`createConfig`](/core/api/createConfig), it set a global `config` singleton that was used internally by actions. For v2, `config` is now a required first parameter for actions.

::: code-group
```ts [index.ts]
import { getAccount, readContract } from '@wagmi/core'
import { parseAbi } from 'viem'
import { config } from './config' // [!code ++]

const account = getAccount() // [!code --]
const account = getAccount(config) // [!code ++]

const balanceOf = readContract({ // [!code --]
const balanceOf = readContract(config, { // [!code ++]
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
  functionName: 'balanceOf',
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

The previous global `config` singleton made it so you couldn't use multiple `Config` objects in the same project. In addition, we think passing `config` is more explicit and makes it easier to understand what's going on. Finally, types can be inferred directly from the `config`, like [chain properties](/core/guides/chain-properties) and more.

### Removed `getContract`

Removed `getContract` export. Use Viem's [`getContract`](https://viem.sh/docs/contract/getContract.html) instead.

```ts
import { getContract } from '@wagmi/core' // [!code --]
import { getContract } from 'viem' // [!code ++]

const contract = getContract() // [!code --]
const contract = getContract() // [!code ++]
```

### Removed `getNetwork` and `watchNetwork`

The `getNetwork` and `watchNetwork` actions were removed since the connected chain is typically based on the connected account.

- Use [`config.chains`](/core/api/createConfig#chains-1) instead to get `chains`.

  ::: code-group
  ```ts [index.ts]
  import { getNetwork } from '@wagmi/core' // [!code --]

  const { chains } = getNetwork() // [!code --]
  const chains = config.chains // [!code ++]
  ```
  <<< @/snippets/core/config.ts[config.ts]
  :::

- Use [`getAccount`](/core/api/actions/getAccount) and `config.chains` instead to get `chain`.

  ::: code-group
  ```ts [index.ts]
  import { getNetwork } from '@wagmi/core' // [!code --]
  import { getAccount } from '@wagmi/core' // [!code ++]
  import { config } from './config' // [!code ++]

  const { chain } = getNetwork() // [!code --]
  const { chainId } = getAccount(config) // [!code ++]
  const chain = chains.find(chain => chain.id === chainId) // [!code ++]
  ```
  <<< @/snippets/core/config.ts[config.ts]
  :::

  Before v2, `getNetwork().chain` could result in an invalid chain if the active connector's `chainId` was not configured in the list of `config.chains`. Using `getAccount` and `config.chains` is more work, but ensures that chain is either valid or not defined. You can also use `getAccount(config).chain` if you don't care about the chain being `undefined` when not configured.

- Use `watchAccount` instead of `watchNetwork`.

  ::: code-group
  ```ts [index.ts]
  import { watchNetwork } from '@wagmi/core' // [!code --]
  import { watchAccount } from '@wagmi/core' // [!code ++]
  import { config } from './config' // [!code ++]

  const unwatch = watchNetwork((data) => console.log('Changed!', data)) // [!code --]
  const unwatch = watchAccount(config, { // [!code ++]
    onChange(data) { // [!code ++]
      const chains = config.chains // [!code ++]
      const chain = chains.find(chain => chain.id === data.chainId) // [!code ++]
    }, // [!code ++]
  }) // [!code ++]
  ```
  <<< @/snippets/core/config.ts[config.ts]
  :::

### Removed `getWebSocketPublicClient` and `watchWebSocketPublicClient`

Viem [Transports](https://viem.sh/docs/clients/intro.html#transports) now determine the type of client that is returned. You can use [`getPublicClient`](/core/api/actions/getPublicClient) and [`watchPublicClient`](/core/api/actions/watchPublicClient) to retrieve Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instances.

Alternatively, you can use [`getClient`](/core/api/actions/getClient) and [`watchClient`](/core/api/actions/watchClient) to retrieve plain Viem [`Client`](https://viem.sh/docs/clients/custom.html) instances. This is a better option for users that care about optimizing bundle size to be as small as possible.

### Removed `watchReadContract`, `watchReadContracts`, and `watchReadMulticall`

Use [`watchBlockNumber`](/core/api/actions/watchBlockNumber) along with [`readContract`](/core/api/actions/readContract), [`readContracts`](/core/api/actions/readContracts), and [`multicall`](/core/api/actions/multicall) actions instead. Before v2, `watchReadContract`, `watchReadContracts`, and `watchReadMulticall` were all wrappers around `watchBlockNumber` and this simplifies the API.

::: code-group
```ts [index.ts]
import { watchReadContract } from '@wagmi/core' // [!code --]
import { watchBlockNumber, readContract } from '@wagmi/core' // [!code ++]
import { config } from './config' // [!code ++]

const unwatch = watchReadContract( // [!code --]
  { // [!code --]
    address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // [!code --]
    abi: parseAbi(['function balanceOf(address) view returns (uint256)']), // [!code --]
    functionName: 'balanceOf', // [!code --]
    args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], // [!code --]
  }, // [!code --]
  (result) => console.log('Changed!', result), // [!code --]
) // [!code --]
const unwatch = watchBlockNumber(config, { // [!code ++]
  onBlockNumber() { // [!code ++]
    const balanceOf = readContract(config, { // [!code ++]
      address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // [!code ++]
      abi: parseAbi(['function balanceOf(address) view returns (uint256)']), // [!code ++]
      functionName: 'balanceOf', // [!code ++]
      args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], // [!code ++]
    }) // [!code ++]
    console.log('Changed!', balanceOf)// [!code ++]
  }, // [!code ++]
}) // [!code ++]
```
<<< @/snippets/core/config.ts[config.ts]
:::

### Removed `fetchFeeData`

Removed `fetchFeeData`. Use [`estimateFeesPerGas`](/core/api/actions/estimateFeesPerGas) instead.

::: code-group
```ts [index.ts]
import { fetchFeeData } from '@wagmi/core' // [!code --]
import { estimateFeesPerGas } from '@wagmi/core' // [!code ++]
import { config } from './config' // [!code ++]

const result = await fetchFeeData() // [!code --]
const result = await estimateFeesPerGas(config) // [!code ++]
```
<<< @/snippets/core/config.ts[config.ts]
:::

### Removed `prepareWriteContract`

Removed `prepareWriteContract`. Use [`simulateContract`](/core/api/actions/simulateContract) instead.

::: code-group
```ts [index.ts]
import { prepareWriteContract } from '@wagmi/core' // [!code --]
import { simulateContract } from '@wagmi/core' // [!code ++]
import { config } from './config' // [!code ++]

const result = await prepareWriteContract({ ... }) // [!code --]
const result = await simulateContract(config, { ... }) // [!code ++]
```
<<< @/snippets/core/config.ts[config.ts]
:::

### Removed `prepareSendTransaction`

Removed `prepareSendTransaction`. Use [`estimateGas`](/core/api/actions/estimateGas) instead.

::: code-group
```ts [index.ts]
import { prepareSendTransaction } from '@wagmi/core' // [!code --]
import { estimateGas } from '@wagmi/core' // [!code ++]
import { config } from './config' // [!code ++]

const result = await prepareSendTransaction({ ... }) // [!code --]
const result = await estimateGas(config, { ... }) // [!code ++]
```
<<< @/snippets/core/config.ts[config.ts]
:::

### Updated `sendTransaction` and `writeContract` return type

Updated [`sendTransaction`](/core/api/actions/sendTransaction) and [`writeContract`](/core/api/actions/writeContract) return type from `` { hash: `0x${string}` } `` to `` `0x${string}` ``.

```ts
const result = await sendTransaction({ hash: '0x...' })
result.hash // [!code --]
result // [!code ++]
```

### Updated `connect` return type

Updated [`connect`](/core/api/actions/connect) return type from `` { account: Address; chain: { id: number; unsupported?: boolean }; connector: Connector } `` to `` { accounts: readonly Address[]; chainId: number } ``. This better reflects the ability to have multiple accounts per connector.

### Renamed parameters and return types

All hook parameters and return types follow the naming pattern of `[PascalCaseActionName]Parameters` and `[PascalCaseActionName]ReturnType`. For example, `GetAccountParameters` and `GetAccountReturnType`.

```ts
import { GetAccountConfig, GetAccountResult } from '@wagmi/core' // [!code --]
import { GetAccountParameters, GetAccountReturnType } from '@wagmi/core' // [!code ++]
```

## Connectors

### Moved Wagmi Connectors to peer dependencies

Wagmi Core v2 no longer exports connectors via the `'@wagmi/core/connectors/*'` entrypoints. Instead, you should install the `@wagmi/connectors` package.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/connectors
```

```bash-vue [npm]
npm install @wagmi/connectors
```

```bash-vue [yarn]
yarn add @wagmi/connectors
```

```bash-vue [bun]
bun add @wagmi/connectors
```
:::

And import connectors from there.

```ts
import { injected } from '@wagmi/connectors'
```

See the [connectors documentation](/core/api/connectors) for more information.

### Updated connector API

In order to maximize type-safety and ease of creating connectors, the connector API changed. Follow the [Creating Connectors guide](/dev/creating-connectors) for more info on creating new connectors and converting Wagmi v1 connectors.

### Removed individual entrypoints

Previously, each connector had its own entrypoint to optimize tree-shaking. Since all connectors now have [`package.json#sideEffects`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) enabled, this is no longer necessary and the entrypoint is unified. Use the `'@wagmi/connectors'` package instead.

```ts
import { InjectedConnector } from '@wagmi/core/connectors/injected' // [!code --]
import { CoinbaseWalletConnector } from '@wagmi/core/connectors/coinbaseWallet' // [!code --]
import { coinbaseWallet, injected } from '@wagmi/connectors' // [!code ++]
```

### Removed `MetaMaskConnector`

The `MetaMaskConnector` was removed since it was nearly the same thing as the `InjectedConnector`. Use the [`injected`](/core/api/connectors/injected) connector instead, along with the [`target`](/core/api/connectors/injected#target) parameter set to `'metaMask'`, for the same behavior.

```ts
import { MetaMaskConnector } from '@wagmi/core/connectors/metaMask' // [!code --]
import { injected } from '@wagmi/connectors' // [!code ++]

const connector = new MetaMaskConnector() // [!code --]
const connector = injected({ target: 'metaMask' }) // [!code ++]
```

### Renamed connectors

In Wagmi v1, connectors were classes you needed to instantiate. In Wagmi v2, connectors are functions. As a result, the API has changed. Connectors have the following new names:

- `CoinbaseWalletConnector` is now [`coinbaseWallet`](/core/api/connectors/coinbaseWallet).
- `InjectedConnector` is now [`injected`](/core/api/connectors/injected).
- `SafeConnector` is now [`safe`](/core/api/connectors/safe).
- `WalletConnectConnector` is now [`walletConnect`](/core/api/connectors/walletConnect).

To create a connector, you now call the connector function with parameters.

```ts
import { WalletConnectConnector } from '@wagmi/core/connectors/walletConnect' // [!code --]
import { walletConnect } from '@wagmi/connectors' // [!code ++]

const connector = new WalletConnectConnector({ // [!code --]
const connector = walletConnect({ // [!code ++]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### Removed `WalletConnectLegacyConnector`

WalletConnect v1 was sunset June 28, 2023. Use the [`walletConnect`](/core/api/connectors/walletConnect) connector instead.

```ts
import { WalletConnectLegacyConnector } from '@wagmi/core/connectors/walletConnectLegacy' // [!code --]
import { walletConnect } from '@wagmi/connectors' // [!code ++]

const connector = new WalletConnectLegacyConnector({ // [!code --]
const connector = walletConnect({ // [!code ++]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

## Chains

### Updated `'@wagmi/core/chains'` entrypoint

Chains now live in the [Viem repository](https://github.com/wevm/viem). As a result, the `'@wagmi/core/chains'` entrypoint now proxies all chains from `'viem/chains'` directly.

### Removed `mainnet` and `sepolia` from main entrypoint

Since the `'@wagmi/core/chains'` entrypoint now proxies `'viem/chains'`, `mainnet` and `sepolia` were removed from the main entrypoint. Use the `'@wagmi/core/chains'` entrypoint instead.

```ts
import { mainnet, sepolia } from '@wagmi/core' // [!code --]
import { mainnet, sepolia } from '@wagmi/core/chains' // [!code ++]
```

## Errors

A number of errors were renamed to better reflect their functionality or replaced by Viem errors.

## Miscellaneous

### Removed internal ENS normalization

Before v2, Wagmi handled ENS name normalization internally for `getEnsAddress`, `getEnsAvatar`, and `getEnsResolver`, using Viem's [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function. This added extra bundle size as full normalization is quite heavy. For v2, you must normalize ENS names yourself before passing them to these actions. You can use Viem's `normalize` function or any other function that performs [UTS-46 normalization](https://unicode.org/reports/tr46).


::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem' // [!code ++]
import { config } from './config'

const result = await getEnsAddress(config, {
  name: 'wevm.eth', // [!code --]
  name: normalize('wevm.eth'), // [!code ++]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

By inverting control, Wagmi lets you choose how much normalization to do. For example, maybe your project only allows ENS names that are numeric so no normalization is not needed. Check out the [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) for more information on normalizing names.

### Removed `configureChains`

The Wagmi v2 `Config` now has native multichain support using the [`chains`](/core/api/createConfig) parameter so the `configureChains` function is no longer required.

```ts
import { configureChains, createConfig } from '@wagmi/core' // [!code --]
import { http, createConfig } from '@wagmi/core' // [!code ++]
import { mainnet, sepolia } from '@wagmi/core/chains'

const { chains, publicClient } = configureChains( // [!code --]
  [mainnet, sepolia], // [!code --]
  [publicProvider(), publicProvider()], // [!code --]
) // [!code --]

export const config = createConfig({
  publicClient, // [!code --]
  chains: [mainnet, sepolia], // [!code ++]
  transports: { // [!code ++]
    [mainnet.id]: http(), // [!code ++]
    [sepolia.id]: http(), // [!code ++]
  }, // [!code ++]
})
```

### Removed ABI exports

Import from Viem instead.

```ts
import { erc20ABI } from '@wagmi/core' // [!code --]
import { erc20Abi } from 'viem' // [!code ++]
```

### Removed `'@wagmi/core/providers/*` entrypoints

It never made sense that we would have provider URLs hardcoded in the Wagmi codebase. Use [Viem transports](https://viem.sh/docs/clients/intro.html#transports) along with RPC provider URLs instead.

```ts
import { alchemyProvider } from '@wagmi/core/providers/alchemy' // [!code --]
import { http } from 'viem' // [!code ++]

const transport = http('https://mainnet.example.com')
```

### Updated `createConfig` parameters

- Removed `autoConnect`. The reconnecting behavior must be managed manually and is not related to the Wagmi `Config`. Use the [`reconnect`](/core/api/actions/reconnect) action instead.
- Removed `publicClient` and `webSocketPublicClient`. Use [`transports`](/core/api/createConfig#transports) or [`client`](/core/api/createConfig#client) instead.
- Removed `logger`. Wagmi no longer logs debug information to console.

### Updated `Config` object

- Removed `config.connector`. Use `config.state.connections.get(config.state.current)?.connector` instead.
- Removed `config.data`. Use `config.state.connections.get(config.state.current)` instead.
- Removed `config.error`. Was unused and not needed.
- Removed `config.lastUsedChainId`. Use `config.state.connections.get(config.state.current)?.chainId` instead.
- Removed `config.publicClient`. Use [`config.getClient()`](/core/api/createConfig#getclient) or [`getPublicClient`](/core/api/actions/getPublicClient) instead.
- Removed `config.status`. Use [`config.state.status`](/core/api/createConfig#status) instead.
- Removed `config.webSocketClient`. Use [`config.getClient()`](/core/api/createConfig#getclient) or [`getPublicClient`](/core/api/actions/getPublicClient) instead.
- Removed `config.clearState`. Was unused and not needed.
- Removed `config.autoConnect()`. Use [`reconnect`](/core/api/actions/reconnect) action instead.
- Renamed `config.setConnectors`. Use `config._internal.setConnectors` instead.
- Removed `config.setLastUsedConnector`. Use `config.storage?.setItem('recentConnectorId', connectorId)` instead.
- Removed `getConfig`. `config` should be passed explicitly to actions instead of using global `config`.

## Deprecations

### Deprecated `getBalance` `token` parameter

Moving forward, `getBalance` will only work for native currencies, thus the `token` parameter is no longer supported. Use [`readContracts`](/core/api/actions/readContracts) instead.

```ts
import { getBalance } from '@wagmi/core' // [!code --]
import { readContracts } from '@wagmi/core' // [!code ++]
import { erc20Abi } from 'viem' // [!code ++]
import { config } from './config' // [!code ++]

const result = await getBalance(config, { // [!code --]
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code --]
  token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code --]
}) // [!code --]
const result = await readContracts(config, { // [!code ++]
  allowFailure: false, // [!code ++]
  contracts: [ // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'balanceOf', // [!code ++]
      args: ['0x4557B18E779944BFE9d78A672452331C186a9f48'], // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'decimals', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'symbol', // [!code ++]
    }, // [!code ++]
  ] // [!code ++]
}) // [!code ++]
```

### Deprecated `getBalance` `unit` parameter and `formatted` return value

Moving forward, `getBalance` will not accept the `unit` parameter or return a `formatted` value. Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

```ts
import { formatUnits } from 'viem' // [!code ++]
import { getBalance } from '@wagmi/core'

const result = await getBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  unit: 'ether', // [!code --]
})
result.formatted // [!code --]
formatUnits(result.value, result.decimals) // [!code ++]
```

### Deprecated `getToken`

Moving forward, `getToken` is no longer supported. Use [`readContracts`](/core/api/actions/readContracts) instead.

```ts
import { getToken } from '@wagmi/core' // [!code --]
import { readContracts } from '@wagmi/core' // [!code ++]
import { erc20Abi } from 'viem' // [!code ++]
import { config } from './config' // [!code ++]

const result = await getToken(config, { // [!code --]
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code --]
}) // [!code --]
const result = await readContracts(config, { // [!code ++]
  allowFailure: false, // [!code ++]
  contracts: [ // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'decimals', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'name', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'symbol', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'totalSupply', // [!code ++]
    }, // [!code ++]
  ] // [!code ++]
}) // [!code ++]
```

### Deprecated `formatUnits` parameters and return values

The `formatUnits` parameter and related return values (e.g. `result.formatted`) are deprecated for the following actions:

- [`estimateFeesPerGas`](/core/api/actions/estimateFeesPerGas)
- [`getToken`](/core/api/actions/getToken)

Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

```ts
import { formatUnits } from 'viem' // [!code ++]
import { getToken } from '@wagmi/core'

const result = await getToken({
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  formatUnits: 'ether',
})
result.totalSupply.formatted  // [!code --]
formatUnits(result.totalSupply.value, 18)  // [!code ++]
```

This allows us to invert control to users so they can handle number formatting however they want, taking into account precision, localization, and more.

### Renamed actions

The following actions were renamed to better reflect their functionality and underlying [Viem](https://viem.sh) actions:

- `fetchBalance` is now [`getBalance`](/core/api/actions/getBalance)
- `fetchBlockNumber` is now [`getBlockNumber`](/core/api/actions/getBlockNumber)
- `fetchEnsAddress` is now [`getEnsAddress`](/core/api/actions/getEnsAddress)
- `fetchEnsAvatar` is now [`getEnsAvatar`](/core/api/actions/getEnsAvatar)
- `fetchEnsName` is now [`getEnsName`](/core/api/actions/getEnsName)
- `fetchEnsResolver` is now [`getEnsResolver`](/core/api/actions/getEnsResolver)
- `fetchToken` is now [`getToken`](/core/api/actions/getToken)
- `fetchTransaction` is now [`getTransaction`](/core/api/actions/getTransaction)
- `switchNetwork` is now [`switchChain`](/core/api/actions/switchChain)
- `waitForTransaction` is now [`waitForTransactionReceipt`](/core/api/actions/waitForTransactionReceipt)
</file>

<file path="site/core/guides/testing.md">
# Testing
</file>

<file path="site/core/guides/viem.md">
# Viem

[Viem](https://viem.sh) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](/core/api/createConfig) and automatic account management via [Connectors](/core/api/connectors).

## Leveraging Viem Actions

All of the core [Wagmi Actions](/core/api/actions) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](/core/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe an Action doesn't exist in Wagmi yet). In these cases, you can import Viem Actions directly via `viem/actions` and plug in a Viem Client returned by the [`getClient` Action](/core/api/actions/getClient).

The example below demonstrates two different ways to utilize Viem Actions:

1. **Tree-shakable Actions (recommended):** Uses `getClient` (for public actions) and `getConnectorClient` (for wallet actions).
2. **Client Actions:** Uses `getPublicClient` (for public actions) and  `getWalletClient` (for wallet actions).

::: tip

It is highly recommended to use the **tree-shakable** method to ensure that you are only pulling modules you use, and keep your bundle size low.

:::

::: code-group

```tsx [Tree-shakable Actions]
// 1. Import modules. 
import { http, createConfig, getClient, getConnectorClient } from '@wagmi/core' 
import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
import { getLogs, watchAsset } from 'viem/actions' // [!code hl]

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

// 3. Extract a Viem Client for the current active chain.
const publicClient = getClient(config)
const logs = await getLogs(publicClient, /* ... */) // [!code hl]

// 4. Extract a Viem Client for the current active chain & account.
const walletClient = getConnectorClient(config)
const success = await watchAsset(walletClient, /* ... */) // [!code hl]
```

```tsx [Client Actions]
// 1. Import modules. 
import { http, createConfig, getPublicClient, getWalletClient } from '@wagmi/core' 
import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

// 3. Extract a Viem Public Client for the current active chain.
const publicClient = getPublicClient(config)
const logs = await publicClient.getLogs(publicClient, /* ... */) // [!code hl]

// 4. Extract a Viem Wallet Client for the current active chain & account.
const walletClient = getWalletClient(config)
const success = await walletClient.watchAsset(walletClient, /* ... */) // [!code hl]
```

:::

## Multi-chain Viem Client

The [Viem Client](https://viem.sh/docs/client) provides an interface to interact with an JSON-RPC Provider. By nature, JSON-RPC Providers are single-chain, so the Viem Client is designed to be instantiated with a single `chain`. As a result, setting up Viem to be multi-chain aware can get a bit verbose.

The good news is that you can create a **"multi-chain Viem Client"** with **Wagmi** by utilizing [`createConfig`](/core/api/createConfig) and [`getClient`](/core/api/actions/getClient).

::: code-group

```tsx [Wagmi Usage]
// 1. Import modules. 
import { http, createConfig, getClient, getConnectorClient } from '@wagmi/core' 
import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
import { getBlockNumber, sendTransaction } from 'viem/actions' // [!code hl]

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

// 3. Extract a Viem Client for the current active chain.
const publicClient = getClient(config)
const blockNumber = await getBlockNumber(publicClient) // [!code hl]

// 4. Extract a Viem Client for the current active chain & account.
const walletClient = getConnectorClient(config)
const hash = await sendTransaction(walletClient, /* ... */) // [!code hl]
```

```tsx [Viem Usage]
// Manually set up Viem Clients without wagmi. Don't do this, it's only here 
// to demonstrate the amount of boilerplate required.

import { createPublicClient, createWalletClient, http } from 'viem'
import { base, mainnet, optimism, zora } from 'viem/chains'

const publicClient = {
  base: createPublicClient({
    chain: base,
    transport: http()
  }),
  mainnet: createPublicClient({
    chain: mainnet,
    transport: http()
  }),
  optimism: createPublicClient({
    chain: optimism,
    transport: http()
  }),
  zora: createPublicClient({
    chain: zora,
    transport: http()
  })
} as const

const walletClient = {
  base: createWalletClient({
    chain: base,
    transport: custom(window.ethereum)
  }),
  mainnet: createWalletClient({
    chain: mainnet,
    transport: custom(window.ethereum)
  }),
  optimism: createWalletClient({
    chain: optimism,
    transport: custom(window.ethereum)
  }),
  zora: createWalletClient({
    chain: zora,
    transport: custom(window.ethereum)
  })
} as const

const blockNumber = await publicClient.mainnet.getBlockNumber()
const hash = await walletClient.mainnet.sendTransaction(/* ... */)
```

:::

## Private Key & Mnemonic Accounts

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

```tsx
import { http, createConfig, sendTransaction } from '@wagmi/core' 
import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
import { parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

const account = privateKeyToAccount('0x...') // [!code hl]

const hash = await sendTransaction({ 
  account, // [!code hl]
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

::: info

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config ‚Äì meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open a discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).

:::
</file>

<file path="site/core/getting-started.md">
<script setup>
import packageJson from '../../packages/core/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Getting Started

## Overview

Wagmi Core is a VanillaJS library for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](/core/why) section.

## Manual Installation

To manually add Wagmi to your project, install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/core @wagmi/connectors viem@{{viemVersion}}
```

```bash-vue [npm]
npm install @wagmi/core @wagmi/connectors viem@{{viemVersion}}
```

```bash-vue [yarn]
yarn add @wagmi/core @wagmi/connectors viem@{{viemVersion}}
```

```bash-vue [bun]
bun add @wagmi/core @wagmi/connectors viem@{{viemVersion}}
```
:::

- [Wagmi Connectors](/core/api/connectors) is a collection of interfaces for linking accounts/wallets to Wagmi.
- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TypeScript](/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/core/typescript).

### Create Config

Create and export a new Wagmi config using `createConfig`.

::: code-group
<<< @/snippets/core/config.ts[config.ts]
:::

In this example, Wagmi is configured to use the Mainnet and Sepolia chains. Check out the [`createConfig` docs](/core/api/createConfig) for more configuration options.

### Use Wagmi

Now that everything is set up, you can pass the `config` to use actions.

::: code-group
```tsx [index.ts]
import { getAccount, getEnsName } from '@wagmi/core'
import { config } from './config'

const { address } = getAccount(config)
const ensName = await getEnsName(config, { address })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Next Steps

For more information on what to do next, check out the following topics.

- [**TypeScript**](/core/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
- [**Actions**](/core/api/actions) Browse the collection of actions and learn how to use them.
- [**Framework Adapters**](/core/guides/framework-adapters) Learn how to create a Wagmi-like adapter for your favorite framework.
- [**Viem docs**](https://viem.sh) Wagmi Core is a wrapper around Viem that manages account and client reactivity. Learn more about Viem and how to use it.
</file>

<file path="site/core/installation.md">
<script setup>
import packageJson from '../../packages/core/package.json'
import Browsers from '../components/Browsers.vue'

const docsPath = 'core'
const packageDir = 'core'
const packageName = '@wagmi/core'
const viemVersion = packageJson.peerDependencies.viem
</script>

# Installation

Install Wagmi Core via your package manager, a `<script>` tag, or build from source.

## Package Manager

Install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/core viem@{{viemVersion}}
```

```bash-vue [npm]
npm install @wagmi/core viem@{{viemVersion}}
```

```bash-vue [yarn]
yarn add @wagmi/core viem@{{viemVersion}}
```

```bash-vue [bun]
bun add @wagmi/core viem@{{viemVersion}}
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TypeScript](/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/react/typescript).

## CDN

If you're not using a package manager, you can also use Wagmi Core via an ESM-compatible CDN such as [esm.sh](https://esm.sh). Simply add a `<script type="module">` tag to the bottom of your HTML file with the following content.

```html-vue
<script type="module">
  import { createClient } from 'https://esm.sh/viem'
  import { createConfig } from 'https://esm.sh/@wagmi/core@{{viemVersion}}'
  import { injected } from 'https://esm.sh/@wagmi/connectors'
</script>
```

<!--@include: @shared/installation.md-->
</file>

<file path="site/core/typescript.md">
<script setup>
import packageJson from '../../packages/core/package.json'

const typescriptVersion = packageJson.peerDependencies.typescript
</script>

# TypeScript

## Requirements

Wagmi Core is designed to be as type-safe as possible! Things to keep in mind:

- Types currently require using TypeScript {{typescriptVersion}}.
- [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
- Changes to types in this repository are considered non-breaking and are usually released as patch  changes (otherwise every type enhancement would be a major version!).
- It is highly recommended that you lock your `@wagmi/core` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
- The non-type-related public API of Wagmi Core still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

::: code-group
```json [tsconfig.json]
{
  "compilerOptions": {
    "strict": true
  }
}
```
:::

## Const-Assert ABIs & Typed Data

Wagmi Core can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

```ts
const result = await readContract({
  abi: [‚Ä¶], // <--- defined inline // [!code focus]
})
```

```ts
const abi = [‚Ä¶] as const // <--- const assertion // [!code focus]
const result = readContract({ abi })
```

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

::: tip
Unfortunately [TypeScript doesn't support importing JSON `as const` yet](https://github.com/microsoft/TypeScript/issues/32063). Check out the [Wagmi CLI](/cli/getting-started) to help with this! It can automatically fetch ABIs from Etherscan and other block explorers, resolve ABIs from your Foundry/Hardhat projects, and more.
:::

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`readContract`](/core/api/actions/readContract) looks like with and without a const-asserted `abi` property.

::: code-group
```ts twoslash [Const-Asserted]
import { createConfig, http } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})

const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { readContract } from '@wagmi/core'

const result = await readContract(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

result
// ^?
```
```ts twoslash [Not Const-Asserted]
import { createConfig, http } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})

declare const erc721Abi: {
  name: string;
  type: string;
  stateMutability: string;
  inputs: {
    type: string;
    name: string;
  }[];
  outputs: {
    type: string;
  }[];
}[]
// ---cut---
import { readContract } from '@wagmi/core'

const result = await readContract(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

result
// ^?
```
:::

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. üéâ

```ts twoslash
// @errors: 2820
import { createConfig, http } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})

const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { readContract } from '@wagmi/core'

readContract(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanecOf',
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
})
```

## Configure Internal Types

For advanced use-cases, you may want to configure wagmi's internal types. Most of wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev) for more info on how to configure types.
</file>

<file path="site/core/why.md">
# Why Wagmi Core

## The Problems

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi Core solves all these problems and more ‚Äî allowing app developers to focus on building high-quality and performant experiences for Ethereum ‚Äî by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

## Developer Experience

Wagmi Core delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi Core's APIs might seem more verbose at first, it makes Wagmi Core's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi Core is a great way to learn how to interact with Ethereum in general.

Wagmi Core also provides [strongly typed APIs](/core/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi Core can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](/core/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi Core. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20(TDD),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

## Performance

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi Core uses and is built by the same team behind [Viem](https://viem.sh), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi Core is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times. 

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi Core supports caching, deduplication, persistence, and much more through [TanStack Query](/react/guides/tanstack-query) via the `'@wagmi/core/query'` entrypoint so you can [plug it into your framework](/core/guides/framework-adapters) of choice, like Vue, Svelte, and more.

## Feature Coverage

Wagmi Core supports the most popular and commonly-used Ethereum features out of the box with 40+ VanillaJS Actions for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi Core also supports just about any wallet out there through its official [connectors](/core/api/connectors), [EIP-6963 support](/core/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Viem](https://viem.sh), which Wagmi Core uses internally to perform blockchain operations. Wagmi Core also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi Core has a [CLI](/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz), [Privy](https://privy.io), and many more, so you can get started quickly without needing to build everything from scratch.

## Stability

Stability is a fundamental principle for Wagmi Core. Many organizations, large and small, rely heavily on Wagmi Core and expect it to be entirely stable for their users and applications.

Wagmi Core's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi Core follows semver so developers can upgrade between versions with confidence. Starting with Wagmi Core v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi Core and [related projects](https://github.com/wevm), and is constantly improving Wagmi Core and keeping it up-to-date with industry trends and changes.
</file>

<file path="site/dev/contributing.md">
<script setup>
import packageJson from '../../package.json'

const nodeVersion = packageJson.engines.node
const packageManager = packageJson.packageManager
</script>

# Contributing

Thanks for your interest in contributing to Wagmi! Please take a moment to review this document **before submitting a pull request.**

## Overview

This guide is intended to help you get started with contributing. By following these steps, you will understand the development process and workflow. If you want to contribute, but aren't sure where to start, you can create a [new discussion](https://github.com/wevm/wagmi/discussions/new/choose).

:::warning
**Please ask first before starting work on any significant new features. This includes things like adding new hooks, actions, connectors, etc.**

It's never a fun experience to have your pull request declined after investing time and effort into a new feature. To avoid this from happening, we request that contributors first create a [feature request](https://github.com/wevm/wagmi/discussions/new?category=ideas) to discuss any API changes or significant new ideas.
:::

## 1. Cloning the repository

To start contributing to the project, clone it to your local machine using git:

```bash
git clone https://github.com/wevm/wagmi.git
```

Or the [GitHub CLI](https://cli.github.com):

```bash
gh repo clone wevm/wagmi
```

## 2. Installing Node.js and pnpm

Wagmi uses Node.js with [pnpm workspaces](https://pnpm.io/workspaces) to manage multiple projects. You can run the following command in your terminal to check your local Node.js version.

```bash
node -v
```

If **`node@{{nodeVersion}}`** is not installed, you can install via [fnm](https://github.com/Schniz/fnm) or from the [official website](https://nodejs.org).

Once Node.js is installed, run the following to install [Corepack](https://nodejs.org/api/corepack.html). Corepack automatically installs and manages **`{{packageManager}}`**.

```bash
corepack enable
```

## 3. Installing dependencies

Once in the project's root directory, run the following command to install pnpm (via Corepack) and the project's dependencies:

```bash
pnpm install
```

After the install completes, pnpm links packages across the project for development and [git hooks](https://github.com/toplenboren/simple-git-hooks) are set up.

## 4. Adding the env variables

The [dev playgrounds](#_5-running-the-dev-playgrounds) and [test suite](#_6-running-the-test-suite) require environment variables to be set. Copy over the following environment variables to `.env`, and fill them out.

```bash
VITE_MAINNET_FORK_URL=https://eth.merkle.io
VITE_OPTIMISM_FORK_URL=https://mainnet.optimism.io

NEXT_PUBLIC_WC_PROJECT_ID=3fbb6bba6f1de962d911bb5b5c9dba88
NUXT_PUBLIC_WC_PROJECT_ID=3fbb6bba6f1de962d911bb5b5c9dba88
VITE_WC_PROJECT_ID=3fbb6bba6f1de962d911bb5b5c9dba88

NEXT_TELEMETRY_DISABLED=1
NUXT_TELEMETRY_DISABLED=1
```

You might want to change `*_FORK_URL` to a paid RPC provider for better performance.

## 5. Running the dev playgrounds

To start the local development playgrounds, run one of the following commands. These commands run playground apps, located at `./playgrounds`, that are set up for trying out code while making changes.

```bash
pnpm dev              # `wagmi` playground
pnpm dev:core         # `@wagmi/core` playground
pnpm dev:create-wagmi # `create-wagmi` cli tool
pnpm dev:cli          # `@wagmi/cli` tool
pnpm dev:next         # `wagmi` playground with Next.js
pnpm dev:nuxt         # `@wagmi/vue` playground with Nuxt.js
pnpm dev:react        # `wagmi` playground (same as `pnpm dev`)
pnpm dev:vue          # `@wagmi/vue` playground
```

Once a playground dev server is running, you can make changes to any of the package source files (e.g. `packages/react`) and it will automatically update the playground.

## 6. Running the test suite

Wagmi uses [Vitest](https://vitest.dev) to run tests and [Prool](https://github.com/wevm/prool) to execute tests against locally running chain forks. First, install [Anvil](https://github.com/foundry-rs/foundry/tree/master/crates/anvil) via [Foundryup](https://book.getfoundry.sh/getting-started/installation).

```bash
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

Next, make sure you have set up your [env variables](#_4-adding-the-env-variables). Now you are ready to run the tests! You have the following options for running tests:

- `pnpm test [package?]` ‚Äî runs tests in watch mode
- `pnpm test:cov` ‚Äî runs tests and reports coverage
- `pnpm test:core` ‚Äî runs `@wagmi/core` tests
- `pnpm test:react` ‚Äî runs `wagmi` tests
- `pnpm test:vue` ‚Äî runs `@wagmi/vue` tests

When adding new features or fixing bugs, it's important to add test cases to cover the new or updated behavior. If snapshot tests fail, you can run the `test:update` command to update the snapshots.

## 7. Writing documentation

Documentation is crucial to helping developers of all experience levels use Wagmi. Wagmi uses [VitePress](https://vitepress.dev) for the documentation site (located at `./site`). To start the site in dev mode, run:

```bash
pnpm docs:dev
```

Try to keep documentation brief and use plain language so folks of all experience levels can understand. If you think something is unclear or could be explained better, you are welcome to open a pull request.

## 8. Submitting a pull request

When you're ready to submit a pull request, you can follow these naming conventions:

- Pull request titles use the [Imperative Mood](https://en.wikipedia.org/wiki/Imperative_mood) (e.g., `Add something`, `Fix something`).
- [Changesets](#versioning) use past tense verbs (e.g., `Added something`, `Fixed something`).

When you submit a pull request, GitHub will automatically lint, build, and test your changes. If you see an ‚ùå, it's most likely a bug in your code. Please, inspect the logs through the GitHub UI to find the cause.

**Please make sure that "Allow edits from maintainers" is enabled so the core team can make updates to your pull request if necessary.**

## 9. Versioning

When adding new features or fixing bugs, we'll need to bump the package versions. We use [Changesets](https://github.com/changesets/changesets) to do this.

::: tip
Only changes to the codebase that affect the public API or existing behavior (e.g. bugs) need changesets.
:::

Each changeset defines which packages should be published and whether the change should be a major/minor/patch release, as well as providing release notes that will be added to the changelog upon release.

To create a new changeset, run `pnpm changeset`. This will run the Changesets CLI, prompting you for details about the change. You‚Äôll be able to edit the file after it‚Äôs created ‚Äî don‚Äôt worry about getting everything perfect up front.

Even though you can technically use any markdown formatting you like, headings should be avoided since each changeset will ultimately be nested within a bullet list. Instead, bold text should be used as section headings.

If your PR is making changes to an area that already has a changeset (e.g. there‚Äôs an existing changeset covering theme API changes but you‚Äôre making further changes to the same API), you should update the existing changeset in your PR rather than creating a new one.

### Releasing to npm

The first time a PR with a changeset is merged after a release, a new PR will automatically be created called `chore: version packages`. Any subsequent PRs with changesets will automatically update this existing version packages PR. Merging this PR triggers the release process by publishing to npm and cleaning up the changeset files.

### Creating a snapshot release

If a PR has changesets, you can create a [snapshot release](https://github.com/changesets/changesets/blob/main/docs/snapshot-releases.md) by [manually dispatching](https://github.com/wevm/wagmi/actions/workflows/canary.yml) the Canary workflow. This publishes a tagged version to npm with the PR branch name and timestamp.

## 10. Updating dependencies

Use [Taze](https://github.com/antfu/taze) by running:

```bash
pnpm deps       # prints outdated deps
pnpm deps patch # print outdated deps with new patch versions
pnpm deps -w    # updates deps (best done with clean working tree)
```

[Socket](https://socket.dev) checks pull requests for vulnerabilities when new dependencies and versions are added, but you should also be vigilant! When updating dependencies, you should check release notes and source code as well as lock versions when possible.
</file>

<file path="site/dev/creating-connectors.md">
# Creating Connectors

Thanks for your interest in adding a new connector to Wagmi! Please take a moment to review this document **before starting work on a new connector.**

## Overview

This guide details how to create new connectors and upstream them back into Wagmi. By following these steps, you will understand the development process, workflow, and requirements for new connectors. **Not all connectors will be accepted into Wagmi** for a variety of reasons outlined in this document.

In addition, for connector requests to be accepted, the team creating the connector must [sponsor Wagmi](https://github.com/sponsors/wevm). It takes time and effort to maintain third-party connectors. Wagmi is an OSS project that depends on sponsors and grants to continue our work. Please get in touch via [dev@wevm.dev](mailto:dev@wevm.dev) if you have questions about sponsoring.

::: warning **Please ask first before starting work on a new connector.**
To avoid having your pull request declined after investing time and effort into a new connector, we ask that contributors create a [Connector Request](https://github.com/wevm/wagmi/discussions/new?category=connector-request) before starting work. This ensures the connector solves for an important or general use-case of interest to Wagmi users and is well supported by the Wagmi and connector teams.
:::

## 1. Follow the contributing guide

Check out the [Contributing Guide](/dev/contributing) to get your local development environment set up and learn more about the contributing workflow.

## 2. Create a new file for the connector

Create a new file in `packages/connector/src` named after the connector you want to add.

For example, if you want to add Foo, you would create a file named `foo.ts`. File names should be camel-cased and as short as possible.

## 3. Create the connector object.

Import `createConnector` from `@wagmi/core` and export a new function that accepts a parameters object and returns the `createConnector` result. This is the base of all connectors. The name of the connector name should be the same as the file name.

```ts
import { createConnector } from '@wagmi/core'

export type FooBarBazParameters = {}

export function fooBarBaz(parameters: FooBarBazParameters = {}) {
  return createConnector((config) => ({}))
}
```

## 4. Add the missing properties to the object

Now that the base of the connector is set up, you should see a type error that looks something like this:

```ts twoslash
// @errors: 2740
import { createConnector } from '@wagmi/core'
// ---cut---
createConnector((config) => ({}))
```

The type error tells you what properties are missing from `createConnector`'s return type. Add them all in!

#### Properties

- `icon`: Optional icon URL for the connector.
- `id`: The ID for the connector. This should be camel-cased and as short as possible. Example: `fooBarBaz`.
- `name`: Human-readable name for the connector. Example: `'Foo Bar Baz'`.
- `rdns`: Optional reverse DNS for the connector. This is used to filter out duplicate [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) injected providers when `createConfig#multiInjectedProviderDiscovery` is enabled.

#### Methods

- `connect`: Function for connecting the connector.
- `disconnect`: Function for disconnecting the connector.
- `getAccounts`: Function that returns the connected accounts for the connector.
- `getChainId`: Function that returns the connected chain ID for the connector.
- `getProvider`: Function that returns the underlying provider interface for internal use throughout the connector.
- `isAuthorized`: Function that returns whether the connector has connected previously and is still authorized.
- `setup`: Optional function for running when the connector is first created.
- `switchChain`: Optional function for switching the connector's active chain.

#### Events

- `onAccountsChanged`: Function for subscribing to account changes internally in the connector.
- `onChainChanged`: Function for subscribing to chain changes internally in the connector.
- `onConnect`: Function for subscribing to connection events internally in the connector.
- `onDisconnect`: Function for subscribing to disconnection events internally in the connector.
- `onMessage`: Optional function for subscribing to messages internally in the connector.

#### Parameters

`createConnector` also has the following config properties you can use within the connector:

- `chains`: List of chains configured by the user.
- `emitter`: Emitter for emitting events. Used to sync connector state with Wagmi `Config`. The following events are available:
  - `change`: Emitted when the connected accounts or chain changes.
  - `connect`: Emitted when the connector connects.
  - `disconnect`: Emitted when the connector disconnects.
  - `error`: Emitted when the connector receives an error.
  - `message`: Emitted when the connector receives a message.
- `storage`: Optional storage configured by the user. Defaults to wrapper around localStorage.

::: tip
If you plan to use a third-party SDK, it should have minimal dependencies (limit bundle size, supply chain attacks, etc.) and use the most permissive license possible (ideally MIT). Any third-party packages, should also have [`"sideEffects": false`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) in their `package.json` file for maximum tree-shakability support.
:::

::: tip
All address values returned and emitted by the connector should be checksummed using Viem's [`getAddress`](https://viem.sh/docs/utilities/getAddress).
:::

## 5. Export the connector

Export the connector from `packages/connector/src/exports/index.ts` in alphabetic order.

```ts
export { fooBarBaz } from './fooBarBaz.js'
```

## 6. Try out the connector and add tests

While building a connector, it can be useful to try it out with Wagmi. You can use the [development playgrounds](/dev/contributing#_5-running-the-dev-playgrounds) for testing your changes.

Ideally, you should also be able to add tests for the connector in a `connectorName.test.ts` file. This isn't always easy so at a minimum please create a test file with instructions for how to test the connector manually. The test file should include actual tests or "instruction tests" for the following:

- How to connect the connector.
- How to disconnect the connector.
- How to switch the connector's active chain (if applicable).

Remember to include all info required to test the connector, like software to install (browser extension, mobile app, etc.), smart contracts to interact with/deploy, etc.

Finally, you should also update the test file in `packages/connectors/src/exports/index.test.ts` to include the new connector. You can do this manually or by running:

```bash
pnpm test:update packages/connectors/src/exports/index.test.ts
```

## 7. Add your team to CODEOWNERS

It is critical that connectors are updated in a timely manner and actively maintained so that users of Wagmi can rely on them in production settings.

The Wagmi core team will provide as much assistance as possible to keep connectors up-to-date with breaking changes from Wagmi, but it is your responsibility to ensure that any dependencies and issues/discussions related to the connector are handled in a timely manner. If issues are not resolved in a timely manner, the connector may be removed from Wagmi.

In support of this goal, add at least one member of your team to the [CODEOWNERS](https://github.com/wevm/wagmi/blob/main/.github/CODEOWNERS) file so that you get notified of pull requests, issues, etc. related to the connector. You can add your team like this:

```
/packages/connectors/src/fooBarBaz @tmm @jxom
```

For more info about GitHub code owners, check out the [GitHub Documentation](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).

## 8. Document the connector

The connector should be documented. Follow the step on [writing documentation](/dev/contributing#_7-writing-documentation) to get set up with running the docs site locally and add the required pages.

## 9. Create a changeset

Now that the connector works and has tests, it's time to create a changeset to prepare for release. Run the following to create a changeset:

```bash
pnpm changeset
```

The changeset should be a `patch` applied to the `@wagmi/connectors` repository with the description `Added [ConnectorName]`, For example, `Added Foo Bar Baz`.

## 10. Create a pull request

The connector is ready to go! Create a [pull request](/dev/contributing#_8-submitting-a-pull-request) and the connector should make it into a future release of Wagmi after some review.
</file>

<file path="site/public/favicon.svg">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="629" height="629" viewBox="0 0 629 629" fill="none">
<g clip-path="url(#clip0_131_142)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M71.788 366.47C71.788 386.294 87.8583 402.364 107.682 402.364H179.47C199.294 402.364 215.364 386.294 215.364 366.47L215.364 222.894C215.364 203.07 231.434 187 251.258 187C271.082 187 287.152 203.07 287.152 222.894V366.47C287.152 386.294 303.222 402.364 323.046 402.364H394.834C414.658 402.364 430.728 386.294 430.728 366.47V222.894C430.728 203.07 446.798 187 466.622 187C486.446 187 502.516 203.07 502.516 222.894V438.258C502.516 458.082 486.446 474.152 466.622 474.152H35.894C16.0703 474.152 0 458.082 0 438.258L1.26782e-05 222.894C1.40786e-05 203.07 16.0703 187 35.894 187C55.7177 187 71.788 203.07 71.788 222.894L71.788 366.47ZM581.142 482.698C607.573 482.698 629 461.271 629 434.84C629 408.408 607.573 386.981 581.142 386.981C554.71 386.981 533.283 408.408 533.283 434.84C533.283 461.271 554.71 482.698 581.142 482.698Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_131_142">
<rect width="629" height="629" fill="currentColor"/>
</clipPath>
</defs>
</svg>
</file>

<file path="site/public/logo-dark.svg">
<svg width="561" height="132" viewBox="0 0 561 132" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M561 12C561 18.6274 555.627 24 549 24C542.373 24 537 18.6274 537 12C537 5.37259 542.373 0 549 0C555.627 0 561 5.37259 561 12Z" fill="#ffffff"/>
<path d="M414 105C418.971 105 423 100.971 423 96V60C423 55.0294 427.029 51 432 51H450C454.971 51 459 55.0294 459 60V96C459 100.971 463.029 105 468 105C472.971 105 477 100.971 477 96V60C477 55.0294 481.029 51 486 51H504C508.971 51 513 55.0294 513 60V96C513 100.971 517.029 105 522 105H549C553.971 105 558 100.971 558 96V42C558 37.0294 553.971 33 549 33C544.029 33 540 37.0294 540 42V82.5C540 84.9853 537.985 87 535.5 87C533.015 87 531 84.9853 531 82.5V42C531 37.0294 526.971 33 522 33H414C409.029 33 405 37.0294 405 42V96C405 100.971 409.029 105 414 105Z" fill="#ffffff"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M27 87C22.0294 87 18 82.9706 18 78V42C18 37.0294 13.9706 33 9 33C4.02943 33 0 37.0294 0 42V96C0 100.971 4.02943 105 9 105H117C121.971 105 126 100.971 126 96V60C126 55.0294 130.029 51 135 51H238.5C240.985 51 243 53.0147 243 55.5C243 57.9853 240.985 60 238.5 60H144C139.029 60 135 64.0294 135 69V96C135 100.971 139.029 105 144 105H252C256.971 105 261 100.971 261 96V42C261 37.0294 256.971 33 252 33H117C112.029 33 108 37.0294 108 42V78C108 82.9706 103.971 87 99 87H81C76.0294 87 72 82.9706 72 78V42C72 37.0294 67.9706 33 63 33C58.0294 33 54 37.0294 54 42V78C54 82.9706 49.9706 87 45 87H27ZM243 82.5C243 84.9853 240.985 87 238.5 87H157.5C155.015 87 153 84.9853 153 82.5C153 80.0147 155.015 78 157.5 78H238.5C240.985 78 243 80.0147 243 82.5Z" fill="#ffffff"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M270 96C270 100.971 274.029 105 279 105H373.5C375.985 105 378 107.015 378 109.5C378 111.985 375.985 114 373.5 114H279C274.029 114 270 118.029 270 123C270 127.971 274.029 132 279 132H387C391.971 132 396 127.971 396 123V42C396 37.0294 391.971 33 387 33H279C274.029 33 270 37.0294 270 42V96ZM297 51C292.029 51 288 55.0294 288 60V78C288 82.9706 292.029 87 297 87H369C373.971 87 378 82.9706 378 78V60C378 55.0294 373.971 51 369 51H297Z" fill="#ffffff"/>
</svg>
</file>

<file path="site/public/logo-light.svg">
<svg width="561" height="132" viewBox="0 0 561 132" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M561 12C561 18.6274 555.627 24 549 24C542.373 24 537 18.6274 537 12C537 5.37259 542.373 0 549 0C555.627 0 561 5.37259 561 12Z" fill="#1B1B1B"/>
<path d="M414 105C418.971 105 423 100.971 423 96V60C423 55.0294 427.029 51 432 51H450C454.971 51 459 55.0294 459 60V96C459 100.971 463.029 105 468 105C472.971 105 477 100.971 477 96V60C477 55.0294 481.029 51 486 51H504C508.971 51 513 55.0294 513 60V96C513 100.971 517.029 105 522 105H549C553.971 105 558 100.971 558 96V42C558 37.0294 553.971 33 549 33C544.029 33 540 37.0294 540 42V82.5C540 84.9853 537.985 87 535.5 87C533.015 87 531 84.9853 531 82.5V42C531 37.0294 526.971 33 522 33H414C409.029 33 405 37.0294 405 42V96C405 100.971 409.029 105 414 105Z" fill="#1B1B1B"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M27 87C22.0294 87 18 82.9706 18 78V42C18 37.0294 13.9706 33 9 33C4.02943 33 0 37.0294 0 42V96C0 100.971 4.02943 105 9 105H117C121.971 105 126 100.971 126 96V60C126 55.0294 130.029 51 135 51H238.5C240.985 51 243 53.0147 243 55.5C243 57.9853 240.985 60 238.5 60H144C139.029 60 135 64.0294 135 69V96C135 100.971 139.029 105 144 105H252C256.971 105 261 100.971 261 96V42C261 37.0294 256.971 33 252 33H117C112.029 33 108 37.0294 108 42V78C108 82.9706 103.971 87 99 87H81C76.0294 87 72 82.9706 72 78V42C72 37.0294 67.9706 33 63 33C58.0294 33 54 37.0294 54 42V78C54 82.9706 49.9706 87 45 87H27ZM243 82.5C243 84.9853 240.985 87 238.5 87H157.5C155.015 87 153 84.9853 153 82.5C153 80.0147 155.015 78 157.5 78H238.5C240.985 78 243 80.0147 243 82.5Z" fill="#1B1B1B"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M270 96C270 100.971 274.029 105 279 105H373.5C375.985 105 378 107.015 378 109.5C378 111.985 375.985 114 373.5 114H279C274.029 114 270 118.029 270 123C270 127.971 274.029 132 279 132H387C391.971 132 396 127.971 396 123V42C396 37.0294 391.971 33 387 33H279C274.029 33 270 37.0294 270 42V96ZM297 51C292.029 51 288 55.0294 288 60V78C288 82.9706 292.029 87 297 87H369C373.971 87 378 82.9706 378 78V60C378 55.0294 373.971 51 369 51H297Z" fill="#1B1B1B"/>
</svg>
</file>

<file path="site/react/api/connectors/coinbaseWallet.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/coinbaseWallet.md -->
</file>

<file path="site/react/api/connectors/injected.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/injected.md -->
</file>

<file path="site/react/api/connectors/metaMask.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/metaMask.md -->
</file>

<file path="site/react/api/connectors/mock.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/mock.md -->
</file>

<file path="site/react/api/connectors/safe.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/safe.md -->
</file>

<file path="site/react/api/connectors/walletConnect.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/walletConnect.md -->
</file>

<file path="site/react/api/hooks/useAccount.md">
---
title: useAccount
description: Hook for getting current account.
---

# useAccount

Hook for getting current account.

## Import

```ts
import { useAccount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useAccount } from 'wagmi'

function App() {
  const account = useAccount()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseAccountParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useAccount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const account = useAccount({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseAccountReturnType } from 'wagmi'
```

<!--@include: @shared/getAccount-return-type.md-->

## Action

- [`getAccount`](/core/api/actions/getAccount)
</file>

<file path="site/react/api/hooks/useAccountEffect.md">
---
title: useAccountEffect
description: Hook for listening to account lifecycle events.
---

# useAccountEffect

Hook for listening to account lifecycle events.

## Import

```ts
import { useAccountEffect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'

function App() {
  useAccountEffect({
    onConnect(data) {
      console.log('Connected!', data)
    },
    onDisconnect() {
      console.log('Disconnected!')
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseAccountEffectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  useAccountEffect({
    config, // [!code focus]
    onConnect(data) {
      console.log('Connected!', data)
    },
    onDisconnect() {
      console.log('Disconnected!')
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onConnect

`` ((data: { address: `0x${string}`; addresses: readonly [`0x${string}`, ...`0x${string}`[]]; chain: Chain | undefined chainId: number; connector: Connector; isReconnected: boolean }) => void) | undefined ``

Callback that is called when accounts are connected.

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'

function App() {
  useAccountEffect({
    onConnect(data) { // [!code focus]
      console.log('Connected!', data) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onDisconnect

`(() => void) | undefined`

Callback that is called when no more accounts are connected.

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'

function App() {
  useAccountEffect({
    onDisconnect() { // [!code focus]
      console.log('Disconnected!') // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Action

- [`getAccount`](/core/api/actions/getAccount)
- [`watchAccount`](/core/api/actions/watchAccount)
</file>

<file path="site/react/api/hooks/useBalance.md">
---
title: useBalance
description: Hook for fetching native currency or token balance.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBalance'
const typeName = 'GetBalance'
const TData = '{ decimals: number; formatted: string; symbol: string; value: bigint; }'
const TError = 'GetBalanceErrorType'
</script>

# useBalance

Hook for fetching native currency or token balance.

## Import

```ts
import { useBalance } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBalanceParameters } from 'wagmi'
```

### address

`Address | undefined`

Address to get balance for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get balance at.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### token <Badge type="warning">[deprecated](/react/guides/migrate-from-v1-to-v2#deprecated-usebalance-token-parameter)</Badge>

`Address | undefined`

ERC-20 token address to get balance for.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### unit <Badge type="warning">[deprecated](/react/guides/migrate-from-v1-to-v2#deprecated-usebalance-unit-parameter-and-formatted-return-value)</Badge>

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    unit: 'ether', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBalanceReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBalance`](/core/api/actions/getBalance)
</file>

<file path="site/react/api/hooks/useBlock.md">
---
title: useBlock
description: Hook for fetching information about a block at a block number, hash or tag.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBlock'
const typeName = 'GetBlock'
const TData = 'GetBlockData'
const TError = 'GetBlockErrorType'
</script>

# useBlock

Hook for fetching information about a block at a block number, hash or tag.

## Import

```ts
import { useBlock } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockParameters } from 'wagmi'
```

### blockHash

`` `0x${string}` ``

Information at a given block hash.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`` bigint ``

Information at a given block number.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockNumber: 42069n // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`` 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' ``

Information at a given block tag. Defaults to `'latest'`.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockTag: 'pending' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBlock({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlock({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### includeTransactions

`boolean`

Whether or not to include transactions as objects.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config'

function App() {
  const result = useBlock({
    includeTransactions: true // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config'

function App() {
  const result = useBlock({
    scopeKey: 'foo' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### watch

`boolean | UseWatchBlockParameters | undefined`

- Enables/disables listening for block changes.
- Can pass a subset of [`UseWatchBlocksParameters`](/react/api/hooks/useWatchBlocks#parameters) directly to [`useWatchBlocks`](/react/api/hooks/useWatchBlocks).

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    watch: true, // [!code focus]
  })
}
```

```tsx [index-2.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    watch: { // [!code focus]
      pollingInterval: 4_000, // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlock`](/core/api/actions/getBlock)
- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="site/react/api/hooks/useBlockNumber.md">
---
title: useBlockNumber
description: Hook for fetching the number of the most recent block seen.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBlockNumber'
const typeName = 'GetBlockNumber'
const TData = 'bigint'
const TError = 'GetBlockNumberErrorType'
</script>

# useBlockNumber

Hook for fetching the number of the most recent block seen.

## Import

```ts
import { useBlockNumber } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockNumberParameters } from 'wagmi'
```

### cacheTime

`number | undefined`

Time in milliseconds that cached block number will remain in memory.

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber({
    cacheTime: 4_000, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBlockNumber({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockNumber({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockNumber({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### watch

`boolean | UseWatchBlockNumberParameters | undefined`

- Enables/disables listening for block number changes.
- Can pass a subset of [`UseWatchBlockNumberParameters`](/react/api/hooks/useWatchBlockNumber#parameters)directly to [`useWatchBlockNumber`](/react/api/hooks/useWatchBlockNumber).

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber({
    watch: true, // [!code focus]
  })
}
```

```tsx [index-2.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber({
    watch: { // [!code focus]
      pollingInterval: 4_000, // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockNumberReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlockNumber`](/core/api/actions/getBlockNumber)
- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="site/react/api/hooks/useBlockTransactionCount.md">
---
title: useBlockTransactionCount
description: Hook for fetching the number of Transactions at a block number, hash or tag.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBlockTransactionCount'
const typeName = 'GetBlockTransactionCount'
const TData = 'bigint'
const TError = 'GetBlockTransactionCountErrorType'
</script>

# useBlockTransactionCount

Hook for fetching the number of Transactions at a block number, hash or tag.

## Import

```ts
import { useBlockTransactionCount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBlockTransactionCount } from 'wagmi'

function App() {
  const result = useBlockTransactionCount()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockTransactionCountParameters } from 'wagmi'
```

### blockHash

`` `0x${string}` ``

Transaction count at a given block hash.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`` bigint ``

Transaction count at a given block number.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockNumber: 42069n // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`` 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' ``

Transaction count at a given block tag. Defaults to `'latest'`.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockTag: 'pending' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBlock({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBlockTransactionCount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockTransactionCount({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlockTransactionCount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockTransactionCount({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockTransactionCountReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlockTransactionCount`](/core/api/actions/getBlockTransactionCount)
</file>

<file path="site/react/api/hooks/useBytecode.md">
---
title: useBytecode
description: Hook for retrieving the bytecode at an address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBytecode'
const typeName = 'GetBytecode'
const TData = 'GetBytecodeData'
const TError = 'GetBytecodeErrorType'
</script>

# useBytecode

Hook for retrieving the bytecode at an address.

## Import

```ts
import { useBytecode } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBytecodeParameters } from 'wagmi'
```

### address

`Address | undefined`

The contract address.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the bytecode at.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockNumber: 16280770n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockTag: 'safe', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useBytecode({
    chainId: mainnet.id, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBytecode({
    config, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'
import { config } from './config'

function App() {
  const result = useBytecode({
    scopeKey: 'foo' // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBytecodeReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBytecode`](/core/api/actions/getBytecode)
</file>

<file path="site/react/api/hooks/useCall.md">
---
title: useCall
description: Hook for executing a new message call immediately without submitting a transaction to the network.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'call'
const typeName = 'Call'
const TData = 'CallData'
const TError = 'CallErrorType'
</script>

# useCall

Hook for executing a new message call immediately without submitting a transaction to the network.

## Import

```ts
import { useCall } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseCallParameters } from 'wagmi'
```

### account

`Account | Address | undefined`

The Account to call from.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### data

`0x${string} | undefined`

A contract hashed method call with encoded args.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### to

`Address | undefined`

The contract address or recipient.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    accessList: [ // [!code focus:6] 
      {
        address: '0x1',
        storageKeys: ['0x1'],
      },
    ],
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gas

`bigint | undefined`

The gas provided for transaction execution.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    gas: 1_000_000n, // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    gasPrice: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    maxFeePerGas: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    nonce: 420, // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value (in wei) sent with this transaction.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number | undefined`

The block number to perform the call against.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    blockNumber: 15121123n, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to perform the call against.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    blockTag: 'safe', // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The block tag to perform the call against.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'

function App() {
  const result = useCall({
    chainId: mainnet.id, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useCall({
    config, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'
import { config } from './config'

function App() {
  const result = useCall({
    scopeKey: 'foo' // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseCallReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`call`](/core/api/actions/call)
</file>

<file path="site/react/api/hooks/useCallsStatus.md">
---
title: useCallsStatus
description: Hook for fetching the number of the most recent block seen.
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'getCallsStatus'
const typeName = 'GetCallsStatus'
const TData = 'GetCallsStatusReturnType'
const TError = 'GetCallsStatusErrorType'
</script>

# useCallsStatus

Hook to fetch the status and receipts of a call batch that was sent via [`useSendCalls`](/react/api/hooks/useSendCalls).

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useCallsStatus } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useCallsStatus } from 'wagmi/experimental'

function App() {
  const result = useCallsStatus({
    id: '0x...', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseCallsStatusParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCallsStatus({
    config, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```tsx [index.tsx]
import { useCallsStatus, useConnections } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections()
  const result = useCallsStatus({
    connector: connections[0]?.connector, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { useCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useCallsStatus({
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCallsStatus({
    id: '0x...',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseCallsStatusReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getCallsStatus`](https://viem.sh/experimental/eip5792/getCallsStatus)
</file>

<file path="site/react/api/hooks/useCapabilities.md">
---
title: useCapabilities
description: Hook for fetching the number of the most recent block seen.
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'getCapabilities'
const typeName = 'GetCapabilities'
const TData = 'GetCapabilitiesReturnType'
const TError = 'GetCapabilitiesErrorType'
</script>

# useCapabilities

Hook to extract capabilities (grouped by chain ID) that a connected wallet supports (e.g. paymasters, session keys, etc).

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_getcapabilities)

::: warning
This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useCapabilities } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useCapabilities } from 'wagmi/experimental'

function App() {
  const result = useCapabilities()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseCapabilitiesParameters } from 'wagmi/experimental'
```

### account

`Account | Address | undefined`

Fetch capabilities for the provided account.

::: code-group
```ts [index.ts]
import { useCapabilities } from '@wagmi/core'
import { config } from './config'

const status = await useCapabilities({
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useCapabilities } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCapabilities({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```tsx [index.tsx]
import { useCapabilities, useConnections } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections()
  const result = useCapabilities({
    connector: connections[0]?.connector, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useCapabilities } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCapabilities({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseCapabilitiesReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getCapabilities`](https://viem.sh/experimental/eip5792/getCapabilities)
</file>

<file path="site/react/api/hooks/useChainId.md">
---
title: useChainId
description: Hook for getting current chain ID.
---

# useChainId

Hook for getting current chain ID.

## Import

```ts
import { useChainId } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useChainId } from 'wagmi'

function App() {
  const chainId = useChainId()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseChainIdParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useChainId } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const chainId = useChainId({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseChainIdReturnType } from 'wagmi'
```

`number`

Current chain ID from [`config.state.chainId`](/react/api/createConfig#chainid).

::: info
Only returns chain IDs for chains configured via `createConfig`'s [`chains`](/react/api/createConfig#chains) parameter.

If the active [connection](/react/api/createConfig#connection) [`chainId`](/react/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `useChainId` will return the last configured chain ID.
:::

## Action

- [`getChainId`](/core/api/actions/getChainId)
- [`watchChainId`](/core/api/actions/watchChainId)
</file>

<file path="site/react/api/hooks/useChains.md">
---
title: useChains
description: Hook for getting configured chains
---

# useChains

Hook for getting configured chains

## Import

```ts
import { useChains } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useChains } from 'wagmi'

function App() {
  const chains = useChains()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseChainsParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useChains } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const chains = useChains({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseChainsReturnType } from 'wagmi'
```

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](/react/api/createConfig#chains).

## Action

- [`getChains`](/core/api/actions/getChains)
</file>

<file path="site/react/api/hooks/useClient.md">
---
title: useClient
description: Hook for getting Viem `Client` instance.
---

# useClient

Hook for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Import

```ts
import { useClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useClient } from 'wagmi'

function App() {
  const client = useClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseClientParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

::: code-group
```ts [index.ts]
import { useClient } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { config } from './config'

function App() {
  const client = useClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const client = useClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseClientReturnType } from 'wagmi'
```

`Client | undefined`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Action

- [`getClient`](/core/api/actions/getClient)
- [`watchClient`](/core/api/actions/watchClient)
</file>

<file path="site/react/api/hooks/useConfig.md">
---
title: useConfig
description: Hook for getting `Config` from nearest `WagmiProvider`.
---

# useConfig

Hook for getting [`Config`](/react/api/createConfig#config) from nearest [`WagmiProvider`](/react/api/WagmiProvider).

## Import

```ts
import { useConfig } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConfig } from 'wagmi'

function App() {
  const config = useConfig()
}
```

:::

## Return Type

```ts
import { type UseConfigReturnType } from 'wagmi'
```

If you use TypeScript and [register your `Config`](/react/typescript#register-config), the return type will be inferred.

::: code-group
```ts twoslash [index.tsx]
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' {
  interface Register {
    config: Config<readonly [typeof mainnet, typeof sepolia]>
  }
}
// ---cut---
import { useConfig } from 'wagmi'

function App() {
  const config = useConfig()
  //    ^?
}
```

```ts [config.ts]
import { createConfig, http } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

:::
</file>

<file path="site/react/api/hooks/useConnect.md">
---
title: useConnect
description: Hook for connecting accounts with connectors.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'connect'
const typeName = 'Connect'
const mutate = 'connect'
const TData = '{ accounts: readonly [Address, ...Address[]]; chainId: number; }'
const TError = 'ConnectErrorType'
const TVariables = '{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }'
</script>

# useConnect

Hook for connecting accounts with [connectors](/react/api/connectors).

## Import

```ts
import { useConnect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnect } from 'wagmi'
import { injected } from 'wagmi/connectors'

function App() {
  const { connect } = useConnect()

  return (
    <button onClick={() => connect({ connector: injected() })}>
      Connect
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useConnect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useConnect({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseConnectReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured connectors via [`createConfig`](/react/api/createConfig#connectors). Useful for rendering a list of available connectors.

::: code-group
```tsx [index.tsx]
import { useConnect } from 'wagmi'

function App() {
  const { connect, connectors } = useConnect()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => connect({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

::: tip
Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider (e.g. wallet) is connected to.
:::

<!--@include: @shared/mutation-imports.md-->

## Action

- [`connect`](/core/api/actions/connect)
</file>

<file path="site/react/api/hooks/useConnections.md">
---
title: useConnections
description: Hook for getting active connections.
---

# useConnections

Hook for getting active connections.

## Import

```ts
import { useConnections } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnections } from 'wagmi'

function App() {
  const connections = useConnections()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectionsParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useConnections } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseConnectionsReturnType } from 'wagmi'
```

## Action

- [`getConnections`](/core/api/actions/getConnections)
- [`watchConnections`](/core/api/actions/watchConnections)
</file>

<file path="site/react/api/hooks/useConnectorClient.md">
---
title: useConnectorClient
description: Hook for getting a Viem `Client` object for the current or provided connector.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getConnectorClient'
const typeName = 'GetConnectorClient'
const TData = 'Client'
const TError = 'GetConnectorClientErrorType'
const hideQueryOptions = ['gcTime', 'staleTime']
</script>

# useConnectorClient

Hook for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Import

```ts
import { useConnectorClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnectorClient } from 'wagmi'

function App() {
  const result = useConnectorClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectorClientParameters } from 'wagmi'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

```ts
import { useConnectorClient } from 'wagmi'

function App() {
  const result = useConnectorClient({
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

```ts
import { useConnectorClient } from 'wagmi'

function App() {
  const result = useConnectorClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useConnectorClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useConnectorClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

```ts
import { useConnections, useConnectorClient } from 'wagmi'

function App() {
  const connections = useConnections(config)
  const result = useConnectorClient({
    connector: connections[0]?.connector, // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseConnectorClientReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getConnectorClient`](/core/api/actions/getConnectorClient)
</file>

<file path="site/react/api/hooks/useConnectors.md">
---
title: useConnectors
description: Hook for getting configured connectors.
---

# useConnectors

Hook for getting configured connectors.

## Import

```ts
import { useConnectors } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnectors } from 'wagmi'

function App() {
  const connectors = useConnectors()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseConnectorsReturnType } from 'wagmi'
```

`readonly Connector[]`

Connectors from [`config.connectors`](/react/api/createConfig#connectors-1).

## Action

- [`getConnectors`](/core/api/actions/getConnectors)
</file>

<file path="site/react/api/hooks/useDeployContract.md">
---
title: useDeployContract
description: Hook for deploying a contract to the network, given bytecode & constructor arguments.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'deployContract'
const typeName = 'DeployContract'
const mutate = 'deployContract'
const TData = 'DeployContractData'
const TError = 'DeployContractErrorType'
const TVariables = 'DeployContractVariables'
</script>

# useDeployContract <Badge text="viem@>=2.8.18" />

Hook for deploying a contract to the network, given bytecode, and constructor arguments.

## Import

```ts
import { useDeployContract } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useDeployContract } from 'wagmi'
import { parseEther } from 'viem'
import { wagmiAbi } from './abi'

function App() {
  const { deployContract } = useDeployContract()

  return (
    <button
      onClick={() =>
        deployContract({
          abi: wagmiAbi,
          bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
        })
      }
    >
      Deploy Contract
    </button>
  )
}
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Deploying with Constructor Args

::: code-group
```tsx [index.tsx]
import { useDeployContract } from 'wagmi'
import { parseEther } from 'viem'
import { wagmiAbi } from './abi'

function App() {
  const { deployContract } = useDeployContract()

  return (
    <button
      onClick={() =>
        deployContract({
          abi: wagmiAbi,
          args: [69420],
          bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
        })
      }
    >
      Deploy Contract
    </button>
  )
}
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type useDeployContractParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useDeployContract } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useDeployContract({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type useDeployContractReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`deployContract`](/core/api/actions/deployContract)
</file>

<file path="site/react/api/hooks/useDisconnect.md">
---
title: useDisconnect
description: Hook for disconnecting connections.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'disconnect'
const typeName = 'Disconnect'
const mutate = 'disconnect'
const TData = 'void'
const TError = 'DisconnectErrorType'
const TVariables = '{ connector?: Connector | undefined; }'
</script>

# useDisconnect

Hook for disconnecting connections.

## Import

```ts
import { useDisconnect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useDisconnect } from 'wagmi'

function App() {
  const { disconnect } = useDisconnect()

  return (
    <button onClick={() => disconnect()}>
      Disconnect
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseDisconnectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useDisconnect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useDisconnect({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseDisconnectReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Connectors that are currently connected. Useful for rendering a list of connectors to disconnect.

::: code-group
```tsx [index.tsx]
import { useDisconnect } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const { connectors, disconnect } = useDisconnect()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => disconnect({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`disconnect`](/core/api/actions/disconnect)
</file>

<file path="site/react/api/hooks/useEnsAddress.md">
---
title: useEnsAddress
description: Hook for fetching ENS address for name.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsAddress'
const typeName = 'GetEnsAddress'
const TData = 'string'
const TError = 'GetEnsAddressErrorType'
</script>

# useEnsAddress

Hook for fetching ENS address for name.

## Import

```ts
import { useEnsAddress } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsAddressParameters } from 'wagmi'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS address at.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsAddress } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    chainId: mainnet.id, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### coinType

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    coinType: 60, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsAddress({
    config, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the address for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsAddressReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsAddress`](/core/api/actions/getEnsAddress)
</file>

<file path="site/react/api/hooks/useEnsAvatar.md">
---
title: useEnsAvatar
description: Hook for fetching ENS avatar for name.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsAvatar'
const typeName = 'GetEnsAvatar'
const TData = 'string | null'
const TError = 'GetEnsAvatarErrorType'
</script>

# useEnsAvatar

Hook for fetching ENS avatar for name.

## Import

```ts
import { useEnsAvatar } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsAvatarParameters } from 'wagmi'
```

---

### assetGatewayUrls <Badge text="viem@>=2.3.1" />

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

function App() {
  const result = useEnsAvatar({
    assetGatewayUrls: { // [!code focus]
      ipfs: 'https://cloudflare-ipfs.com', // [!code focus]
    }, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Block number to get ENS avatar at.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS avatar at.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsAvatar } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    chainId: mainnet.id, // [!code focus],
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsAvatar({
    config, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gatewayUrls

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    gatewayUrls: ['https://cloudflare-ipfs.com'] { // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the avatar for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsAvatarReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsAvatar`](/core/api/actions/getEnsAvatar)
</file>

<file path="site/react/api/hooks/useEnsName.md">
---
title: useEnsName
description: Hook for fetching primary ENS name for address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsName'
const typeName = 'GetEnsName'
const TData = 'string | null'
const TError = 'GetEnsNameErrorType'
</script>

# useEnsName

Hook for fetching primary ENS name for address.

## Import

```ts
import { useEnsName } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEnsNameParameters } from 'wagmi'
```

### address

`Address | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get ENS name at.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS name at.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsName } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsName } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsNameReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsName`](/core/api/actions/getEnsName)
</file>

<file path="site/react/api/hooks/useEnsResolver.md">
---
title: useEnsResolver
description: Hook for fetching ENS resolver for name.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsResolver'
const typeName = 'GetEnsResolver'
const TData = 'string | null'
const TError = 'GetEnsResolverErrorType'
</script>

# useEnsResolver

Hook for fetching ENS resolver for name.

## Import

```ts
import { useEnsResolver } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsResolver`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsResolverParameters } from 'wagmi'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS resolver at.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS resolver at.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsResolver } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    chainId: mainnet.id, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsResolver({
    config, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Resolver of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsResolverReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsResolver`](/core/api/actions/getEnsResolver)
</file>

<file path="site/react/api/hooks/useEnsText.md">
---
title: useEnsText
description: Hook for fetching a text record for a specified ENS name and key.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsText'
const typeName = 'GetEnsText'
const TData = 'string | null'
const TError = 'GetEnsTextErrorType'
</script>

# useEnsText

Hook for fetching a text record for a specified ENS name and key.

## Import

```ts
import { useEnsText } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsText`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsTextParameters } from 'wagmi'
```

---

### blockNumber

`bigint | undefined`

Block number to get the text at.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the text at.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    blockTag: 'latest', // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsText } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    chainId: mainnet.id, // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### key

`string | undefined`

ENS key to get Text for.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'),
    key: 'com.twitter', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### name

`string | undefined`

Name to get the text for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'), // [!code focus]
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsText({
    config, // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    scopeKey: 'foo', // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Resolver of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'),
    key: 'com.twitter',
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsTextReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsText`](/core/api/actions/getEnsText)
</file>

<file path="site/react/api/hooks/useEstimateFeesPerGas.md">
---
title: useEstimateFeesPerGas
description: Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'estimateFeesPerGas'
const typeName = 'EstimateFeesPerGas'
const TData = '{ formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }'
const TError = 'EstimateFeesPerGasErrorType'
</script>

# useEstimateFeesPerGas

Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { useEstimateFeesPerGas } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateFeesPerGas } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEstimateFeesPerGas } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useEstimateFeesPerGas({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEstimateFeesPerGas } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useEstimateFeesPerGas({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas({
    formatUnits: 'ether', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559'`

- Defaults to `'eip1559'`

::: code-group
```ts [index.ts]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas({
    type: 'legacy', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateFeesPerGasReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateFeesPerGas`](/core/api/actions/estimateFeesPerGas)
</file>

<file path="site/react/api/hooks/useEstimateGas.md">
---
title: useEstimateGas
description: Hook for estimating the gas necessary to complete a transaction without submitting it to the network.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'estimateGas'
const typeName = 'EstimateGas'
const TData = 'bigint'
const TError = 'EstimateGasErrorType'
</script>

# useEstimateGas

Hook for estimating the gas necessary to complete a transaction without submitting it to the network.

## Import

```ts
import { useEstimateGas } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEstimateGas } from 'wagmi'

function App() {
  const result = useEstimateGas()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateGasParameters } from 'wagmi'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    accessList: [{ // [!code focus]
      address: '0x1', // [!code focus]
      storageKeys: ['0x1'], // [!code focus]
    }], // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when estimating gas.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    chainId: mainnet.id, // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

::: code-group
```ts [index.ts]
import { getConnections, estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const connections = getConnections(config)
  const result = useEstimateGas({
    connector: connections[0]?.connector, // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded function data.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    gas: parseGwei('20'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    gasPrice: parseGwei('20'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    maxFeePerGas: parseGwei('20'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    nonce: 123, // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    scopeKey: 'foo', // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### to

`Address | undefined`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    type: 'eip1559', // [!code focus]
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    value: parseEther('0.01'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateGasReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateGas`](/core/api/actions/estimateGas)
</file>

<file path="site/react/api/hooks/useEstimateMaxPriorityFeePerGas.md">
---
title: useEstimateMaxPriorityFeePerGas
description: Hook for fetching an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'estimateMaxPriorityFeePerGas'
const typeName = 'EstimateMaxPriorityFeePerGas'
const TData = 'bigint'
const TError = 'EstimateMaxPriorityFeePerGasErrorType'
</script>

# useEstimateMaxPriorityFeePerGas

Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'

function App() {
  const result = useEstimateMaxPriorityFeePerGas()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateMaxPriorityFeePerGas } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useEstimateMaxPriorityFeePerGas({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useEstimateMaxPriorityFeePerGas({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'

function App() {
  const result = useEstimateMaxPriorityFeePerGas({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateMaxPriorityFeePerGasReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateMaxPriorityFeePerGas`](/core/api/actions/estimateMaxPriorityFeePerGas)
</file>

<file path="site/react/api/hooks/useFeeHistory.md">
---
title: useFeeHistory
description: Hook for fetching a collection of historical gas information.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getFeeHistory'
const typeName = 'GetFeeHistory'
const TData = 'bigint'
const TError = 'GetFeeHistoryErrorType'
</script>

# useFeeHistory

Hook for fetching a collection of historical gas information.

## Import

```ts
import { useFeeHistory } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75]
})
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseFeeHistoryParameters } from 'wagmi'
```

### blockCount

`number | undefined`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4, // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### rewardPercentiles

`number[] | undefined`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75] // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Highest number block of the requested range.


::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    blockNumber: 1551231n, // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag of the highest number block of the requested range.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    blockTag: 'safe', // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.


::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    chainId: mainnet.id, // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75]
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75]
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseFeeHistoryReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getFeeHistory`](/core/api/actions/getFeeHistory)
</file>

<file path="site/react/api/hooks/useGasPrice.md">
---
title: useGasPrice
description: Hook for fetching the current price of gas (in wei).
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getGasPrice'
const typeName = 'GetGasPrice'
const TData = 'bigint'
const TError = 'GetGasPriceErrorType'
</script>

# useGasPrice

Hook for fetching the current price of gas (in wei).

## Import

```ts
import { useGasPrice } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'

function App() {
  const result = useGasPrice()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseGasPriceParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useGasPrice({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useGasPrice({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useGasPrice({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseGasPriceReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getGasPrice`](/core/api/actions/getGasPrice)
</file>

<file path="site/react/api/hooks/useInfiniteReadContracts.md">
---
title: useInfiniteReadContracts
description: Hook for calling multiple read methods on a contract with "infinite scroll"/"fetch more" support.
---

<script setup>
const packageName = 'wagmi'
const includeInfiniteQueryOptions = true
const TPageParam = 'number'
const TData = 'InfiniteReadContractsData'
const TError = 'ReadContractsErrorType'
</script>

# useInfiniteReadContracts

Hook for calling multiple contract read-only methods with "infinite scrolling"/"fetch more" support. 

## Import

```ts
import { useInfiniteReadContracts } from 'wagmi'
```

## Usage

The example below shows how to demonstrate how to fetch a set of [mloot](https://etherscan.io/address/0x1dfe7ca09e99d10835bf73044a23b73fc20623df) attributes (chestwear, footwear, and handwear) with "fetch more" support.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

const mlootContractConfig = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi,
} as const

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        { ...mlootContractConfig, functionName: 'getChest', args },
        { ...mlootContractConfig, functionName: 'getFoot', args },
        { ...mlootContractConfig, functionName: 'getHand', args },
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

In the above example, we are setting a few things:

- [`cacheKey`](#cachekey): A unique key to store the data in the cache.
- [`query.initialPageParam`](#initialpageparam): An initial page parameter to use when fetching the first set of contracts.
- [`query.getNextPageParam`](#getnextpageparam): A function that returns the next page parameter to use when fetching the next set of contracts.
- [`contracts`](#contracts): A function that provides `pageParam` (derived from the above) as an argument and expects to return an array of contracts.

### Paginated Parameters

We can also leverage properties like `getNextPageParam` with a custom `limit` variable to achieve "pagination" of parameters. For example, we can fetch the first 10 contract functions, then fetch the next 10 contract functions, and so on.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function Example({ limit = 10 }: { limit?: number } = {}) {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      return [...new Array(limit)].map(
        (_, i) =>
          ({
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi,
            functionName: 'getHand',
            args: [BigInt(pageParam + i)],
          }) as const,
      )
    },
    query: {
      initialPageParam: 1,
      getNextPageParam(_lastPage, _allPages, lastPageParam) {
        return lastPageParam + limit
      },
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::


## Parameters

```ts
import { type UseInfiniteReadContractsParameters } from 'wagmi'
```

### cacheKey

`string`

A unique key to store the data in the cache.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes', // [!code hl]
    contracts(pageParam) {
      // ...
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### contracts

`(pageParam: {{TPageParam}}) => Contract[]`

A function that provides `pageParam` (derived from the above) as an argument and expects to return an array of contracts.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi, // [!code hl]
          functionName: 'getChest', 
          args 
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df', // [!code hl]
          abi,
          functionName: 'getChest', 
          args 
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi,
          functionName: 'getChest', // [!code hl]
          args 
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi,
          functionName: 'getChest', 
          args: [pageParam] // [!code hl]
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi,
          functionName: 'getChest', 
          args,
          chainId: 1 // [!code hl]
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseInfiniteReadContractsReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->
</file>

<file path="site/react/api/hooks/usePrepareTransactionRequest.md">
---
title: usePrepareTransactionRequest
description: Hook for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'prepareTransactionRequest'
const typeName = 'PrepareTransactionRequest'
const TData = 'PrepareTransactionRequestData'
const TError = 'PrepareTransactionRequestErrorType'
</script>

# usePrepareTransactionRequest

Hook for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

## Import

```ts
import { usePrepareTransactionRequest } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UsePrepareTransactionRequestParameters } from 'wagmi'
```

### account

`Account | Address | undefined`

The Account to send the transaction from. 

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### to

`` `0x${string}` | undefined ``

The transaction recipient or contract address.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',  // [!code focus]
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    accessList: [ // [!code focus:6]
      {
        address: '0x1',
        storageKeys: ['0x1'],
      },
    ],
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to prepare the transaction request for.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    chainId: mainnet.id, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther, parseGwei } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    gasPrice: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther, parseGwei } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    maxFeePerGas: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther, parseGwei } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
    nonce: 5, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### parameters

`("fees" | "gas" | "nonce" | "type")[] | undefined`

Parameters to prepare.

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    parameters: ['gas', 'nonce'], // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config' // [!code focus]

function App() {
  const result = usePrepareTransactionRequest({
    config, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = usePrepareTransactionRequest({
    scopeKey: 'foo' // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UsePrepareTransactionRequestReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`prepareTransactionRequest`](/core/api/actions/prepareTransactionRequest)
</file>

<file path="site/react/api/hooks/useProof.md">
---
title: useProof
description: Hook for return the account and storage values of the specified account including the Merkle-proof.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getProof'
const typeName = 'GetProof'
const TData = 'GetProofData'
const TError = 'GetProofErrorType'
</script>

# useProof

Hook for return the account and storage values of the specified account including the Merkle-proof.

## Import

```ts
import { useProof } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseProofParameters } from 'wagmi'
```

### address

`Address | undefined`

The account address to get the proof for.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016', // [!code focus]
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### storageKeys

`` `0x${string}`[] | undefined ``

Array of storage-keys that should be proofed and included.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [ // [!code focus:3]
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Proof at a given block number.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    blockNumber: 42069n, // [!code focus]
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Proof at a given block tag.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    blockTag: 'latest', // [!code focus]
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to get the proof for.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'
import { optimism } from 'wagmi/chains'

function App() {
  const result = useProof({
    chainId: optimism.id, // [!code focus]
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useProof({
    config, // [!code focus]
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'
import { config } from './config'

function App() {
  const result = useProof({
    scopeKey: 'foo' // [!code focus]
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseProofReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getProof`](/core/api/actions/getProof)
</file>

<file path="site/react/api/hooks/usePublicClient.md">
---
title: usePublicClient
description: Hook for getting Viem `PublicClient` instance.
---

# usePublicClient

Hook for getting Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

## Import

```ts
import { usePublicClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { usePublicClient } from 'wagmi'

function App() {
  const client = usePublicClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`useClient`](/react/api/hooks/useClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Public Client has all public actions attached directly to it.
:::

## Parameters

```ts
import { type UsePublicClientParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Public Client.

::: code-group
```ts [index.ts]
import { usePublicClient } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { config } from './config'

function App() {
  const client = usePublicClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { usePublicClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const client = usePublicClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UsePublicClientReturnType } from 'wagmi'
```

`PublicClient | undefined`

Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

## Action

- [`getPublicClient`](/core/api/actions/getPublicClient)
- [`watchPublicClient`](/core/api/actions/watchPublicClient)
</file>

<file path="site/react/api/hooks/useReadContract.md">
---
title: useReadContract
description: Hook for calling a read-only function on a contract, and returning the response.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'readContract'
const typeName = 'ReadContract'
const TData = 'ReadContractReturnType'
const TError = 'ReadContractErrorType'
</script>

# useReadContract

Hook for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

## Import

```ts
import { useReadContract } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseReadContractParameters } from 'wagmi'
```

### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi' // [!code focus]

function App() {
  const result = useReadContract({
    abi, // [!code focus]
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf',
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
    functionName: 'totalSupply',
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf',
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'], // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    blockTag: 'safe', // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config' // [!code focus]

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    config, // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf', // [!code focus]
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf',
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseReadContractReturnType } from 'wagmi'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/query-result.md-->

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/react/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { createConfig, http, useReadContract } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const result = useReadContract({
  abi: [
    {
      type: 'function',
      name: 'balanceOf',
      stateMutability: 'view',
      inputs: [{ name: 'account', type: 'address' }],
      outputs: [{ type: 'uint256' }],
    },
    {
      type: 'function',
      name: 'totalSupply',
      stateMutability: 'view',
      inputs: [],
      outputs: [{ name: 'supply', type: 'uint256' }],
    },
  ],
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  // ^?


  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  // ^?
})

result.data
//     ^?
```
```ts twoslash [Const-Asserted]
import { createConfig, http, useReadContract } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: 'supply', type: 'uint256' }],
  },
] as const

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  // ^?


  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  // ^?
})

result.data
//     ^?
```
:::

<!--@include: @shared/query-imports.md-->

## Action

- [`readContract`](/core/api/actions/readContract)
</file>

<file path="site/react/api/hooks/useReadContracts.md">
---
title: useReadContracts
description: Hook for calling multiple read methods on a contract.
---

# useReadContracts

Hook for calling multiple read methods on a contract.

## Import

```ts
import { useReadContracts } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

const wagmigotchiContract = {
  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: wagmigotchiABI,
} as const
const mlootContract = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: mlootABI,
} as const

function App() {
  const result = useReadContracts({
    contracts: [
      {
        ...wagmigotchiContract,
        functionName: 'getAlive',
      },
      {
        ...wagmigotchiContract,
        functionName: 'getBoredom',
      },
      {
        ...mlootContract,
        functionName: 'getChest',
        args: [69],
      },
      {
        ...mlootContract,
        functionName: 'getWaist',
        args: [69],
      },
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseReadContractsParameters } from 'wagmi'
```

### contracts

`readonly Contract[]`

Set of contracts to call.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI, // [!code hl]
        functionName: 'getChest',
        args: [69],
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',  // [!code hl]
        abi: mlootABI,
        functionName: 'getChest',
        args: [69],
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest', // [!code hl]
        args: [69],
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69], // [!code hl]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69],
        chainId: 1  // [!code hl]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### allowFailure

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `useReadContracts` will fail silently and its error will be logged in the results array. Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    allowFailure: false, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### batchSize

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    batchSize: 1024, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number`

The block number to perform the read against.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    blockNumber: 69420n, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    blockTag: 'safe', // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'
import { config } from './config'

function App() {
  const result = useReadContracts({
    config, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### multicallAddress

`Address`

Address of multicall contract.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
    multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11', // [!code hl]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseReadContractsReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

## Action

- [`readContracts`](/core/api/actions/readContracts)
</file>

<file path="site/react/api/hooks/useReconnect.md">
---
title: useReconnect
description: Hook for reconnecting connectors.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'reconnect'
const typeName = 'Reconnect'
const mutate = 'reconnect'
const TData = '{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }'
const TError = 'ReconnectErrorType'
const TVariables = '{ connectors?: (CreateConnectorFn | Connector)[] | undefined; }'
</script>

# useReconnect

Hook for reconnecting [connectors](/core/api/connectors).

## Import

```ts
import { useReconnect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useReconnect } from 'wagmi'
import { useEffect } from 'react'

function App() {
  const { reconnect } = useReconnect()

  useEffect(() => {
    reconnect()
  }, [])
}
```

:::

::: tip
When [`WagmiProvider['reconnectOnMount']`](/react/api/WagmiProvider#reconnectonmount) is `true`, `reconnect` is called automatically on mount.
:::

## Parameters

```ts
import { type UseReconnectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useReconnect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useReconnect({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseReconnectReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured connectors via [`createConfig`](/react/api/createConfig#connectors).

::: code-group
```tsx [index.tsx]
import { useReconnect } from 'wagmi'
import { mainnet } from 'wagmi/chains'
import { useEffect } from 'react'

function App() {
  const { reconnect, connectors } = useReconnect()

  useEffect(() => {
    reconnect({ connectors })
  }, [])
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`reconnect`](/core/api/actions/reconnect)
</file>

<file path="site/react/api/hooks/useSendCalls.md">
---
title: useSendCalls
description: Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'sendCalls'
const typeName = 'SendCalls'
const mutate = 'sendCalls'
const TData = 'SendCallsData'
const TError = 'SendCallsErrorType'
const TVariables = 'SendCallsVariables'
</script>

# useSendCalls

Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useSendCalls } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSendCalls } from 'wagmi/experimental'
import { parseEther } from 'viem'

function App() {
  const { sendCalls } = useSendCalls()

  return (
    <button
      onClick={() =>
        sendCalls({
          calls: [
            {
              to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
              value: parseEther('1')
            },
            {
              data: '0xdeadbeef',
              to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
            },
          ]
        })
      }
    >
      Send calls
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSendCallsParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSendCalls } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useSendCalls({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSendCallsReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`sendCalls`](/core/api/actions/sendCalls)
</file>

<file path="site/react/api/hooks/useSendTransaction.md">
---
title: useSendTransaction
description: Hook for creating, signing, and sending transactions to networks.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'sendTransaction'
const typeName = 'SendTransaction'
const mutate = 'sendTransaction'
const TData = 'SendTransactionData'
const TError = 'SendTransactionErrorType'
const TVariables = 'SendTransactionVariables'
</script>

# useSendTransaction

Hook for creating, signing, and sending transactions to networks.

## Import

```ts
import { useSendTransaction } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSendTransaction } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const { sendTransaction } = useSendTransaction()

  return (
    <button
      onClick={() =>
        sendTransaction({
          to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          value: parseEther('0.01'),
        })
      }
    >
      Send transaction
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSendTransactionParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSendTransaction } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSendTransaction({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSendTransactionReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`sendTransaction`](/core/api/actions/sendTransaction)
</file>

<file path="site/react/api/hooks/useShowCallsStatus.md">
---
title: useShowCallsStatus
description: Action to request for the wallet to show information about a call batch
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'showCallsStatus'
const typeName = 'ShowCallsStatus'
const mutate = 'showCallsStatus'
const TData = 'ShowCallsStatusData'
const TError = 'ShowCallsStatusErrorType'
const TVariables = 'ShowCallsStatusVariables'
</script>

# useShowCallsStatus

Action to request for the wallet to show information about a call batch that was sent via `useShowCalls`.

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_showcallsstatus)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useShowCallsStatus } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useShowCallsStatus } from 'wagmi/experimental'
import { parseEther } from 'viem'

function App() {
  const { showCallsStatus } = useShowCallsStatus()

  return (
    <button
      onClick={() =>
        showCallsStatus({
          id: '0x1234567890abcdef',
        })
      }
    >
      Show calls status
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseShowCallsStatusParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useShowCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useShowCallsStatus({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseShowCallsStatusReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`showCallsStatus`](/core/api/actions/showCallsStatus)
</file>

<file path="site/react/api/hooks/useSignMessage.md">
---
title: useSignMessage
description: Hook for signing messages.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'signMessage'
const typeName = 'SignMessage'
const mutate = 'signMessage'
const TData = 'SignMessageData'
const TError = 'SignMessageErrorType'
const TVariables = 'SignMessageVariables'
</script>

# useSignMessage

Hook for signing messages.

## Import

```ts
import { useSignMessage } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSignMessage } from 'wagmi'

function App() {
  const { signMessage } = useSignMessage()

  return (
    <button onClick={() => signMessage({ message: 'hello world' })}>
      Sign message
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSignMessageParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSignMessage } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSignMessage({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSignMessageReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`signMessage`](/core/api/actions/signMessage)
</file>

<file path="site/react/api/hooks/useSignTypedData.md">
---
title: useSignTypedData
description: Hook for signing typed data and calculating an Ethereum-specific EIP-712 signature.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'signTypedData'
const typeName = 'SignTypedData'
const mutate = 'signTypedData'
const TData = 'SignTypedDataData'
const TError = 'SignTypedDataErrorType'
const TVariables = 'SignTypedDataVariables'
</script>

# useSignTypedData

Hook for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

## Import

```ts
import { useSignTypedData } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSignTypedData } from 'wagmi'


function App() {
  const { signTypedData } = useSignTypedData()

  return (
    <button
      onClick={() =>
        signTypedData({
          types: {
            Person: [
              { name: 'name', type: 'string' },
              { name: 'wallet', type: 'address' },
            ],
            Mail: [
              { name: 'from', type: 'Person' },
              { name: 'to', type: 'Person' },
              { name: 'contents', type: 'string' },
            ],
          },
          primaryType: 'Mail',
          message: {
            from: {
              name: 'Cow',
              wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
            },
            to: {
              name: 'Bob',
              wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
            },
            contents: 'Hello, Bob!',
          },
        })
      }
    >
      Sign message
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSignTypedDataParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSignTypedData } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSignTypedData({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSignTypedDataReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

## Type Inference

With [`types`](/core/api/actions/signTypedData#types) setup correctly, TypeScript will infer the correct types for [`domain`](/core/api/actions/signTypedData#domain), [`message`](/core/api/actions/signTypedData#message), and [`primaryType`](/core/api/actions/signTypedData#primarytype). See the Wagmi [TypeScript docs](/react/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { useSignTypedData } from 'wagmi'
// ---cut---
const { signTypedData } = useSignTypedData()

signTypedData({
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
```ts twoslash [Const-Asserted]
import { useSignTypedData } from 'wagmi'
// ---cut---
const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const

const { signTypedData } = useSignTypedData()

signTypedData({
  types,
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
:::

<!--@include: @shared/mutation-imports.md-->

## Action

- [`signTypedData`](/core/api/actions/signTypedData)
</file>

<file path="site/react/api/hooks/useSimulateContract.md">
---
title: useSimulateContract
description: Hook for simulating/validating a contract interaction.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'simulateContract'
const typeName = 'SimulateContract'
const TData = 'SimulateContractReturnType'
const TError = 'SimulateContractErrorType'
</script>

# useSimulateContract

Hook for simulating/validating a contract interaction.

## Import

```ts
import { useSimulateContract } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!-- TODO: Usage for combining with useWriteContract -->

## Parameters

```ts
import { type UseSimulateContractParameters } from 'wagmi'
```

### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi' // [!code focus]

function App() {
  const result = useSimulateContract({
    abi, // [!code focus]
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    accessList: [{ // [!code focus]
      address: '0x1', // [!code focus]
      storageKeys: ['0x1'], // [!code focus]
    }], // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`). Throws if account is not found on [`connector`](#connector).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [ // [!code focus]
      '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
      123n, // [!code focus]
    ], // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    blockTag: 'safe', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    config, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/react/api/connectors) to simulate transaction with.

::: code-group
```tsx [index.ts]
import { useConnectorClient, useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const { data: connector } = useConnectorClient()
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    connector, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    dataSuffix: '0xdeadbeef', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom', // [!code focus]
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    gas: parseGwei('20'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    gasPrice: parseGwei('20'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    maxFeePerGas: parseGwei('20'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    nonce: 123, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    type: 'eip1559', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    value: parseEther('0.01'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseSimulateContractReturnType } from 'wagmi'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/query-result.md-->

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/react/typescript) for more information.

<!--@include: @shared/query-imports.md-->

## Action

- [`simulateContract`](/core/api/actions/simulateContract)
</file>

<file path="site/react/api/hooks/useStorageAt.md">
---
title: useStorageAt
description: Hook for returning the value from a storage slot at a given address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getStorageAt'
const typeName = 'GetStorageAt'
const TData = 'GetStorageAtData'
const TError = 'GetStorageAtErrorType'
</script>

# useStorageAt

Hook for for returning the value from a storage slot at a given address.

## Import

```ts
import { useStorageAt } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseStorageAtParameters } from 'wagmi'
```

### address

`Address | undefined`

The contract address.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### slot

`Hex | undefined`

The storage position (as a hex encoded value).

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## blockNumber

`bigint | undefined`

The block number to check the storage at.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockNumber: 16280770n, // [!code focus]
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the storage at.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockTag: 'safe', // [!code focus]
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the storage at.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'

function App() {
  const result = useStorageAt({
    chainId: mainnet.id, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useStorageAt({
    config, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'
import { config } from './config'

function App() {
  const result = useStorageAt({
    scopeKey: 'foo' // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseStorageAtReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getStorageAt`](/core/api/actions/getStorageAt)
</file>

<file path="site/react/api/hooks/useSwitchAccount.md">
---
title: useSwitchAccount
description: Hook for switching the current account.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'switchAccount'
const typeName = 'SwitchAccount'
const mutate = 'switchAccount'
const TData = 'SwitchAccountData'
const TError = 'SwitchAccountErrorType'
const TVariables = 'SwitchAccountVariables'
</script>

# useSwitchAccount

Hook for switching the current account.

## Import

```ts
import { useSwitchAccount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSwitchAccount } from 'wagmi'

function App() {
  const { connectors, switchAccount } = useSwitchAccount()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => switchAccount({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSwitchAccountParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSwitchAccount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSwitchAccount({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSwitchAccountReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured and actively connected connectors. Useful for rendering a list of available connectors to switch to.

::: code-group
```tsx [index.tsx]
import { useSwitchAccount } from 'wagmi'

function App() {
  const { connectors, switchAccount } = useSwitchAccount()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => switchAccount({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`switchAccount`](/core/api/actions/switchAccount)
</file>

<file path="site/react/api/hooks/useSwitchChain.md">
---
title: useSwitchChain
description: Hook for switching the target chain for a connector or the Wagmi `Config`.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'switchChain'
const typeName = 'SwitchChain'
const mutate = 'switchChain'
const TData = 'SwitchChainData'
const TError = 'SwitchChainErrorType'
const TVariables = 'SwitchChainVariables'
</script>

# useSwitchChain

Hook for switching the target chain for a connector or the Wagmi [`Config`](/react/api/createConfig#config).

## Import

```ts
import { useSwitchChain } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSwitchChain } from 'wagmi'

function App() {
  const { chains, switchChain } = useSwitchChain()

  return (
    <div>
      {chains.map((chain) => (
        <button key={chain.id} onClick={() => switchChain({ chainId: chain.id })}>
          {chain.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: tip
When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](/react/api/createConfig#config).
:::

## Parameters

```ts
import { type UseSwitchChainParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSwitchChain } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSwitchChain({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSwitchChainReturnType } from 'wagmi'
```

### chains

`readonly [Chain, ...Chain[]]`

Globally configured chains. Useful for rendering a list of available chains to switch to.

::: code-group
```tsx [index.tsx]
import { useSwitchChain } from 'wagmi'

function App() {
  const { chains, switchChain } = useSwitchChain()

  return (
    <div>
      {chains.map((chain) => (
        <button key={chain.id} onClick={() => switchChain({ chainId: chain.id })}>
          {chain.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`switchChain`](/core/api/actions/switchChain)
</file>

<file path="site/react/api/hooks/useToken.md">
---
title: useToken
description: Hook for fetching token info.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getToken'
const typeName = 'GetToken'
const TData = '{ address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }'
const TError = 'GetTokenErrorType'
</script>

# useToken <Badge type="warning">[deprecated](/react/guides/migrate-from-v1-to-v2#deprecated-usetoken)</Badge>

Hook for fetching token info. 

## Import

```ts
import { useToken } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTokenParameters } from 'wagmi'
```

### address

`Address | undefined`

Address to get token for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { useToken } from 'wagmi'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    formatUnits: 'ether', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useToken } from 'wagmi'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTokenReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getToken`](/core/api/actions/getToken)
</file>

<file path="site/react/api/hooks/useTransaction.md">
---
title: useTransaction
description: Hook for fetching transactions given hashes or block identifiers.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransaction'
const typeName = 'GetTransaction'
const TData = 'GetTransactionData'
const TError = 'GetTransactionErrorType'
</script>

# useTransaction

Hook for fetching transactions given hashes or block identifiers.

## Import

```ts
import { useTransaction } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionParameters } from 'wagmi'
```

---

### blockHash

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
    index: 0,
  })
}
```

### blockNumber

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockNumber: 17829139n, // [!code focus]
    index: 0,
  })
}
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockTag: 'safe', // [!code focus]
    index: 0,
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```ts
import { useTransaction } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useTransaction({
    chainId: mainnet.id, // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransaction } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransaction({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### hash

`` `0x${string}` | undefined ``

Hash to get transaction. [`enabled`](#enabled) set to `false` if `hash` and [`index`](#index) are `undefined`.

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
  })
}
```

### index

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)). [`enabled`](#enabled) set to `false` if `index` and [`hash`](#hash) are `undefined`.

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockTag: 'safe',
    index: 0  // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransaction`](/core/api/actions/getTransaction)
</file>

<file path="site/react/api/hooks/useTransactionConfirmations.md">
---
title: useTransactionConfirmations
description: Hook for fetching the number of blocks passed (confirmations) since the transaction was processed on a block.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransactionConfirmations'
const typeName = 'GetTransactionConfirmations'
const TData = 'GetTransactionConfirmationsData'
const TError = 'GetTransactionConfirmationsErrorType'
</script>

# useTransactionConfirmations

Hook for fetching the number of blocks passed (confirmations) since the transaction was processed on a block. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

## Import

```ts
import { useTransactionConfirmations } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransactionConfirmations } from 'wagmi'

function App() {
  const result = useTransactionConfirmations({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionConfirmationsParameters } from 'wagmi'
```

---

### hash

`` `0x${string}` | undefined ``

The hash of the transaction.

```ts
import { useTransactionConfirmations } from 'wagmi'

function App() {
  const result = useTransactionConfirmations({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
  })
}
```

### transactionReceipt

`TransactionReceipt | undefined`

The transaction receipt.

```ts
import { useTransactionConfirmations } from 'wagmi'

function App() {
  const result = useTransactionConfirmations({
    transactionReceipt: { ... }, // [!code focus]
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```ts
import { useTransactionConfirmations } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useTransactionConfirmations({
    chainId: mainnet.id, // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransactionConfirmations } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransactionConfirmations({
    config, // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config'

function App() {
  const result = useTransactionConfirmations({
    scopeKey: 'foo' // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionConfirmationsReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionConfirmations`](/core/api/actions/getTransactionConfirmations)
</file>

<file path="site/react/api/hooks/useTransactionCount.md">
---
title: useTransactionCount
description: Hook for fetching the number of transactions an Account has broadcast / sent.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransactionCount'
const typeName = 'GetTransactionCount'
const TData = 'number'
const TError = 'GetTransactionCountErrorType'
</script>

# useTransactionCount

Hook for fetching the number of transactions an Account has sent.

## Import

```ts
import { useTransactionCount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionCountParameters } from 'wagmi'
```

### address

`Address | undefined`

Address to get the transaction count for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get the transaction count at.

::: code-group
```ts [index.ts]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the transaction count at.

::: code-group
```ts [index.ts]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionCountReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionCount`](/core/api/actions/getTransactionCount)
</file>

<file path="site/react/api/hooks/useTransactionReceipt.md">
---
title: useTransactionReceipt
description: Hook for return the Transaction Receipt given a Transaction hash.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransactionReceipt'
const typeName = 'GetTransactionReceipt'
const TData = 'GetTransactionReceiptData'
const TError = 'GetTransactionReceiptErrorType'
</script>

# useTransactionReceipt

Hook for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

## Import

```ts
import { useTransactionReceipt } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'

function App() {
  const result = useTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionReceiptParameters } from 'wagmi'
```

### hash

`` `0x${string}` | undefined ``

A transaction hash.

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'

function App() {
  const result = useTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'
import { mainnet } from 'wagmi/chains'


function App() {
  const result = useTransactionReceipt({
    chainId: mainnet.id, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransactionReceipt({
    config, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'
import { config } from './config'

function App() {
  const result = useTransactionReceipt({
    scopeKey: 'foo' // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionReceiptReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionReceipt`](/core/api/actions/getTransactionReceipt)
</file>

<file path="site/react/api/hooks/useVerifyMessage.md">
---
title: useVerifyMessage
description: Hook for verify that a message was signed by the provided address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'verifyMessage'
const typeName = 'VerifyMessage'
const TData = 'VerifyMessageData'
const TError = 'VerifyMessageErrorType'
</script>

# useVerifyMessage

Hook for verify that a message was signed by the provided address. It supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { useVerifyMessage } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseVerifyMessageParameters } from 'wagmi'
```

### address

`Address | undefined`

The Ethereum address that signed the original message.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### message

`string | { raw: Hex | ByteArray } | undefined`

The message to be verified.

By default, wagmi verifies the UTF-8 representation of the message.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world', // [!code focus]
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: tip
By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

```ts
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: { raw: '0x68656c6c6f20776f726c64' } // [!code focus]
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
:::

### signature

`Hex | ByteArray | undefined`

The signature that was generated by signing the message with the address's signer.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyMessage({
    chainId: mainnet.id, // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyMessage({
    blockNumber: 12345678n, // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyMessage({
    blockTag: 'pending', // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useVerifyMessage({
    config, // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { config } from './config'

function App() {
  const result = useVerifyMessage({
    scopeKey: 'foo' // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseVerifyMessageReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`verifyMessage`](/core/api/actions/verifyMessage)
</file>

<file path="site/react/api/hooks/useVerifyTypedData.md">
---
title: useVerifyTypedData
description: Hook for verify that a typed data was signed by the provided address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'verifyTypedData'
const typeName = 'VerifyTypedData'
const TData = 'VerifyTypedDataData'
const TError = 'VerifyTypedDataErrorType'
</script>

# useVerifyTypedData

Hook for verify that a typed data was signed by the provided address. It supports verifying typed data that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { useVerifyTypedData } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseVerifyTypedDataParameters } from 'wagmi'
```

### address

`Address | undefined`

The Ethereum address that signed the original typed data.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### domain

`TypedDataDomain | undefined`

The typed data domain.

::: code-group
```tsx [index.tsx]
import { types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain: { // [!code focus:6]
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    },
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### types

The type definitions for the typed data.

::: code-group
```tsx [index.tsx]
import { domain } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types: { // [!code focus:11]
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    },
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### primaryType

`string | undefined`

The primary `type` to extract from types and use in `value`.

::: code-group
```tsx [index.tsx]
import { domain } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types: {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [ // [!code focus:5]
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    },
    primaryType: 'Mail', // [!code focus]
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### message

Type inferred from `types` & `primaryType`.

The message to be verified.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: { // [!code focus:11]
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### signature

`Hex | ByteArray | undefined`

The signature that was generated by signing the typed data with the address's signer.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyTypedData({
    chainId: mainnet.id, // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    blockNumber: 12345678n, // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    blockTag: 'latest', // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useVerifyTypedData({
    config, // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    scopeKey: 'foo' // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseVerifyTypedDataReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

## Type Inference

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/react/typescript) for more information.

<!--@include: @shared/query-imports.md-->

## Action

- [`verifyTypedData`](/core/api/actions/verifyTypedData)
</file>

<file path="site/react/api/hooks/useWaitForCallsStatus.md">
---
title: useWaitForCallsStatus
description: Waits for a call bundle to be confirmed & included on a block.
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'waitForCallsStatus'
const typeName = 'WaitForCallsStatus'
const TData = 'WaitForCallsStatusReturnType'
const TError = 'WaitForCallsStatusErrorType'
</script>

# useWaitForCallsStatus

Waits for a call bundle to be confirmed & included on a block before returning the status & receipts.

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useWaitForCallsStatus } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus } from 'wagmi/experimental'

function App() {
  const result = useWaitForCallsStatus({
    id: '0x...', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWaitForCallsStatusParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useWaitForCallsStatus({
    config, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus, useConnections } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections()
  const result = useWaitForCallsStatus({
    connector: connections[0]?.connector, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { useWaitForCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useWaitForCallsStatus({
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

Polling interval in milliseconds.

::: code-group
```ts [index.ts]
import { useWaitForCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useWaitForCallsStatus({
  id: '0x1234567890abcdef',
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useWaitForCallsStatus({
    id: '0x...',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### timeout

`number | undefined`

Timeout in milliseconds.

::: code-group
```ts [index.ts]
import { useWaitForCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useWaitForCallsStatus({
  id: '0x1234567890abcdef',
  timeout: 10_000, // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWaitForCallsStatusReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`waitForCallsStatus`](https://viem.sh/experimental/eip5792/waitForCallsStatus)
</file>

<file path="site/react/api/hooks/useWaitForTransactionReceipt.md">
---
title: useWaitForTransactionReceipt
description: Hook that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'waitForTransactionReceipt'
const typeName = 'WaitForTransactionReceipt'
const TData = 'WaitForTransactionReceiptData'
const TError = 'WaitForTransactionReceiptErrorType'
</script>

# useWaitForTransactionReceipt

Hook that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

## Import

```ts
import { useWaitForTransactionReceipt } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWaitForTransactionReceiptParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useWaitForTransactionReceipt({
    chainId: mainnet.id, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### confirmations

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    confirmations: 2, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```

### onReplaced

`
(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined
`

Optional callback to emit if the transaction has been replaced.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    onReplaced: replacement => console.log(replacement), // [!code focus]
  })
}
```

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/react/api/createConfig#pollinginterval).

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    pollingInterval: 1_000, // [!code focus]
  })
}
```

### hash

`` `0x${string}` | undefined ``

The transaction hash to wait for. [`enabled`](#enabled) set to `false` if `hash` is `undefined`.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWaitForTransactionReceiptReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`waitForTransactionReceipt`](/core/api/actions/waitForTransactionReceipt)
</file>

<file path="site/react/api/hooks/useWalletClient.md">
---
title: useWalletClient
description: Hook for getting a Viem `WalletClient` object for the current or provided connector.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getWalletClient'
const typeName = 'GetWalletClient'
const TData = 'WalletClient'
const TError = 'GetWalletClientErrorType'
const hideQueryOptions = ['gcTime', 'staleTime']
</script>

# useWalletClient

Hook for getting a Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

## Import

```ts
import { useWalletClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWalletClient } from 'wagmi'

function App() {
  const result = useWalletClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`useConnectorClient`](/react/api/hooks/useConnectorClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Wallet Client has all wallet actions attached directly to it.
:::

## Parameters

```ts
import { type UseWalletClientParameters } from 'wagmi'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

```ts
import { useWalletClient } from 'wagmi'

function App() {
  const result = useWalletClient({
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

```ts
import { useWalletClient } from 'wagmi'

function App() {
  const result = useWalletClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWalletClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWalletClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

```ts
import { useConnections, useWalletClient } from 'wagmi'

function App() {
  const connections = useConnections(config)
  const result = useWalletClient({
    connector: connections[0]?.connector, // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWalletClientReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getWalletClient`](/core/api/actions/getWalletClient)
</file>

<file path="site/react/api/hooks/useWatchAsset.md">
---
title: useWatchAsset
description: Hook for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'watchAsset'
const typeName = 'WatchAsset'
const mutate = 'watchAsset'
const TData = 'WatchAssetData'
const TError = 'WatchAssetErrorType'
const TVariables = 'WatchAssetVariables'
</script>

# useWatchAsset

Hook for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

## Import

```ts
import { useWatchAsset } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchAsset } from 'wagmi'

function App() {
  const { watchAsset } = useWatchAsset()

  return (
    <button
      onClick={() => watchAsset({
        type: 'ERC20',
        options: {
          address: '0x0000000000000000000000000000000000000000',
          symbol: 'WAGMI',
          decimals: 18,
        },
      })}
    >
      Watch asset
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchAssetParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWatchAsset } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWatchAsset({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWatchAssetReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`watchAsset`](/core/api/actions/watchAsset)
</file>

<file path="site/react/api/hooks/useWatchBlockNumber.md">
---
title: useWatchBlockNumber
description: Hook that watches for block number changes.
---

# useWatchBlockNumber

Hook that watches for block number changes.

## Import

```ts
import { useWatchBlockNumber } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) {
      console.log('Block number changed!', blockNumber)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchBlockNumberParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    chainId: 1, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'
import { config } from './config'

function App() {
  useWatchBlockNumber({
    config, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    emitMissed: true, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    emitOnBegin: true, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### enabled

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    enabled: false, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onBlockNumber

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { // [!code focus]
      console.log('New block number', blockNumber) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }, 
    onError(error) { // [!code focus]
      console.error('Block error', error) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }
    poll: true, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }
    pollingInterval: 1_000, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }
    syncConnectedChain: false, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchBlockNumberReturnType } from 'wagmi'
```

Function for cleaning up watcher.

## Action

- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="site/react/api/hooks/useWatchBlocks.md">
---
title: useWatchBlocks
description: Hook that watches for block changes.
---

# useWatchBlocks

Hook that watches for block changes.

## Import

```ts
import { useWatchBlocks } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchBlocksParameters } from 'wagmi'
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to watch blocks at.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    blockTag: 'latest', // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    chainId: 1, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'
import { config } from './config'

function App() {
  useWatchBlocks({
    config, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    emitMissed: true, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    emitOnBegin: true, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### enabled

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    enabled: false, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### includeTransactions

`boolean`

Whether or not to unwrap transactions as objects (instead of hashes) in blocks. Defaults to `false`.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    includeTransactions: true, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onBlock

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { // [!code focus]
      console.log('New block', block.number) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }, 
    onError(error) { // [!code focus]
      console.error('Block error', error) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }
    poll: true, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }
    pollingInterval: 1_000, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }
    syncConnectedChain: false, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchBlocksReturnType } from 'wagmi'
```

## Action

- [`watchBlocks`](/core/api/actions/watchBlocks)
</file>

<file path="site/react/api/hooks/useWatchContractEvent.md">
---
title: useWatchContractEvent
description: Hook that watches and returns emitted contract event logs.
---

# useWatchContractEvent

Hook that watches and returns emitted contract event logs.

## Import

```ts
import { useWatchContractEvent } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchContractEventParameters } from 'wagmi'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### args

`object | readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`eventName`](#eventname).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    args: { // [!code focus]
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B' // [!code focus]
    } // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### batch

`boolean | undefined`

- Whether or not the events should be batched on each invocation.
- Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    batch: false, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    chainId: 1, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    config, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### eventName

`string`

- Event to listen for the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer', // [!code focus]
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    onError(error) { // [!code focus]
      console.log('Error', error) // [!code focus]
    } // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### onLogs

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) { // [!code focus]
      console.log('New logs!', logs) // [!code focus]
    } // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    poll: true // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    pollingInterval: 1_000 // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### strict

`boolean | undefined`

- Defaults to `false`.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    strict: true // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    syncConnectedChain: true // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchContractEventReturnType } from 'wagmi'
```

Hook returns `void`

## Action

- [`watchContractEvent`](/core/api/actions/watchContractEvent)
</file>

<file path="site/react/api/hooks/useWatchPendingTransactions.md">
---
title: useWatchPendingTransactions
description: Hook that watches and returns pending transaction hashes.
---

# useWatchPendingTransactions

Hook that watches and returns pending transaction hashes.

## Import

```ts
import { useWatchPendingTransactions } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchPendingTransactionsParameters } from 'wagmi'
```

### batch

`boolean | undefined`

- Whether or not the transactions should be batched on each invocation.
- Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    batch: true // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    chainId: 1 // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'
import { config } from './config'

function App() {
  useWatchPendingTransactions({
    config // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from watching pending transactions.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onError(error) { // [!code focus]
      console.log('Error', error) // [!code focus]
    }, // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onTransactions

`(transactions: Hash[], prevTransactions: Hash[] | undefined) => void`

Callback when new incoming pending transactions are detected.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) { // [!code focus]
      console.log('New transactions!', transactions) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
    poll: true, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
    pollingInterval: 1_000, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
    syncConnectedChain: false, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchPendingTransactionsReturnType } from 'wagmi'
```

## Action

- [`watchPendingTransactions`](/core/api/actions/watchPendingTransactions)
</file>

<file path="site/react/api/hooks/useWriteContract.md">
---
title: useWriteContract
description: Action for executing a write function on a contract.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'writeContract'
const typeName = 'WriteContract'
const mutate = 'writeContract'
const TData = 'WriteContractReturnType'
const TError = 'WriteContractErrorType'
const TVariables = 'WriteContractVariables'
</script>

# useWriteContract

Action for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

## Import

```ts
import { useWriteContract } from 'wagmi'
```

## Usage

::: code-group

```tsx [index.tsx]
import { useWriteContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const { writeContract } = useWriteContract()

  return (
    <button 
      onClick={() => 
        writeContract({ 
          abi,
          address: '0x6b175474e89094c44da98b954eedeac495271d0f',
          functionName: 'transferFrom',
          args: [
            '0xd2135CfB216b74109775236E36d4b433F1DF507B',
            '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
            123n,
          ],
       })
      }
    >
      Transfer
    </button>
  )
}
```

<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!-- TODO: Usage for simulating before -->

<!-- TODO: Usage for estimating gas before -->

## Parameters

```ts
import { type UseWriteContractParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group

```tsx [index.tsx]
import { useWriteContract } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWriteContract({
    config, // [!code focus]
  })
}
```

<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWriteContractReturnType } from 'wagmi'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/mutation-result.md-->

## Type Inference

With [`abi`](/core/api/actions/writeContract#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](/core/api/actions/writeContract#functionname), [`args`](/core/api/actions/writeContract#args), and the [`value`](/core/api/actions/writeContract##value). See the Wagmi [TypeScript docs](/react/typescript) for more information.

<!--@include: @shared/mutation-imports.md-->

## Action

- [`writeContract`](/core/api/actions/writeContract)
</file>

<file path="site/react/api/hooks/useWriteContracts.md">
---
title: useWriteContracts
description: Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'writeContracts'
const typeName = 'WriteContracts'
const mutate = 'writeContracts'
const TData = 'WriteContractsData'
const TError = 'WriteContractsErrorType'
const TVariables = 'WriteContractsVariables'
</script>

# useWriteContracts

Hook that requests for the wallet to sign and broadcast a batch of write contract calls (transactions) to the network.

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useWriteContracts } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWriteContracts } from 'wagmi/experimental'
import { parseAbi } from 'viem'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

function App() {
  const { writeContracts } = useWriteContracts()

  return (
    <button
      onClick={() =>
        writeContracts({
          contracts: [
            {
              address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
              abi,
              functionName: 'approve',
              args: [
                '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
                100n
              ],
            },
            {
              address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
              abi,
              functionName: 'transferFrom',
              args: [
                '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
                '0x0000000000000000000000000000000000000000',
                100n
              ],
            },
          ],
        })
      }
    >
      Send calls
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWriteContractsParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWriteContracts } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useWriteContracts({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWriteContractsReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`writeContracts`](/core/api/actions/writeContracts)
</file>

<file path="site/react/api/transports/custom.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/custom.md -->
</file>

<file path="site/react/api/transports/fallback.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/fallback.md -->
</file>

<file path="site/react/api/transports/http.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/http.md -->
</file>

<file path="site/react/api/transports/unstable_connector.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/unstable_connector.md -->
</file>

<file path="site/react/api/transports/webSocket.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/webSocket.md -->
</file>

<file path="site/react/api/utilities/cookieToInitialState.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/cookieToInitialState.md-->
</file>

<file path="site/react/api/utilities/deserialize.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/deserialize.md-->
</file>

<file path="site/react/api/utilities/normalizeChainId.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/normalizeChainId.md-->
</file>

<file path="site/react/api/utilities/serialize.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/serialize.md-->
</file>

<file path="site/react/api/actions.md">
# Actions

Sometimes the declarative nature of React Hooks doesn't work for parts of your app. For those cases, you can use Wagmi Core Actions directly!

All the Wagmi Core Actions are importable using the `wagmi/actions` entrypoint. For example, you can use the `watchBlockNumber` action to watch for block number changes.

::: code-group
```ts [index.tsx]
import { useConfig } from 'wagmi'
import { watchBlockNumber } from 'wagmi/actions'
import { useEffect } from 'react'

function App() {
  const config = useConfig()

  useEffect(() => {
    return watchBlockNumber(config, {
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
  }, [])
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

See the [Wagmi Core docs](/core/api/actions) for more info on what actions are available.
</file>

<file path="site/react/api/chains.md">
<script setup>
import packageJson from '../../../package.json'
import SearchChains from '../../components/SearchChains.vue'

const viemVersion = packageJson.devDependencies.viem
</script>

# Chains

Viem `Chain` objects. More info at the [Viem docs](https://viem.sh/docs/chains/introduction).

## Import

Import via the `'wagmi/chains'` entrypoint (proxies all chains from `'viem/chains'`).

```ts
import { mainnet } from 'wagmi/chains'
```

## Available Chains

Chain definitions as of `viem@{{viemVersion}}`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

<SearchChains />

<!--@include: @shared/create-chain.md-->
</file>

<file path="site/react/api/connectors.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const connectors = getSidebar()['/react']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Connectors')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Connectors

Connectors for popular wallet providers and protocols.

## Import

Import via the `'wagmi/connectors'` entrypoint.

```ts
import { injected } from 'wagmi/connectors'
```

## Available Connectors

<ul>
  <li v-for="connector of connectors">
    <a :href="connector.link">{{ connector.text }}</a>
  </li>
</ul>
</file>

<file path="site/react/api/createConfig.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!--@include: @shared/createConfig.md-->
</file>

<file path="site/react/api/createStorage.md">
<script setup>
const docsPath = "react"
const packageName = 'wagmi'
</script>

<!--@include: @shared/createStorage.md-->
</file>

<file path="site/react/api/errors.md">
<script setup>
const docsPath = "react"
const packageName = 'wagmi'
</script>

# Errors

Error classes used by Wagmi.

<!--@include: @shared/errors.md-->

## React

### WagmiProviderNotFoundError

When a Wagmi hook is used outside of a [`WagmiProvider`](/react/api/WagmiProvider).

```ts
import { WagmiProviderNotFoundError } from 'wagmi'
```
</file>

<file path="site/react/api/hooks.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const hooks = getSidebar()['/react']
  .find(x => x.text === 'Hooks').items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Hooks

React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more.

## Import

```ts
import { useAccount } from 'wagmi'
```

## Available Hooks

<ul>
  <li v-for="hook of hooks">
    <a :href="hook.link">{{ hook.text }}</a>
  </li>
</ul>
</file>

<file path="site/react/api/transports.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const transports = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Transports')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Transports

[`createConfig`](/react/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

## Import

```ts
import { http } from 'wagmi'
```

## Built-In Transports

Available via the `'wagmi'` entrypoint.

<ul>
  <li v-for="transport of transports">
    <a :href="transport.link">{{ transport.text }}</a>
  </li>
</ul>
</file>

<file path="site/react/api/WagmiProvider.md">
# WagmiProvider

React Context Provider for Wagmi.

## Import

```ts
import { WagmiProvider } from 'wagmi'
```

## Usage

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider config={config}> 
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type WagmiProviderProps } from 'wagmi'
```

### config

[`Config`](/react/api/createConfig#config) object to inject with context.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider
      config={config} // [!code focus]
    >
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### initialState

`State | undefined`

- Initial state to hydrate into the [Wagmi Config](/react/api/createConfig). Useful for SSR.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider
      config={config}
      initialState={/* ... /*} // [!code focus]
    >
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### reconnectOnMount

`boolean | undefined`

- Whether or not to reconnect previously connected [connectors](/react/api/createConfig#connectors) on mount.
- Defaults to `true`.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider
      config={config}
      reconnectOnMount={false} // [!code focus]
    >
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Context

```ts
import { type WagmiContext } from 'wagmi'
```
</file>

<file path="site/react/guides/chain-properties.md">
# Chain Properties

Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains all support additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

<br/>

::: tip
Make sure you follow the TypeScript guide's [Config Types](/react/typescript#config-types) section before moving on. The easiest way to do this is to use [Declaration Merging](/react/typescript#declaration-merging) to "register" your `config` globally with TypeScript.

<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

## Narrowing Parameters

Once your Config is registered with TypeScript, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

::: code-group
```ts [index.tsx]
import { parseEther } from 'viem'
import { useSimulateContract } from 'wagmi'

const result = useSimulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  feeCurrency: '0x‚Ä¶', // [!code focus]
})
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

::: code-group
```ts [index.tsx]
import { parseEther } from 'viem'
import { useSimulateContract } from 'wagmi'
import { celo } from 'wagmi/chains'

const result = useSimulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  chainId: celo.id, // [!code focus]
  feeCurrency: '0x‚Ä¶', // [!code focus]
  // ^? (property) feeCurrency?: `0x${string}` | undefined // [!code focus]
})
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

## Narrowing Return Types

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

::: code-group
```ts [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'
import { zkSync } from 'wagmi/chains'

const { data } = useWaitForTransactionReceipt({
  chainId: zkSync.id,
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

data?.logs
//    ^? (property) logs: ZkSyncLog[] | undefined
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

### `chainId` Data Property

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

::: code-group
```ts [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'
import { zkSync } from 'wagmi/chains'

const { data } = useWaitForTransactionReceipt({
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

if (data?.chainId === zkSync.id) {
  data?.logs
  //    ^? (property) logs: ZkSyncLog[] | undefined
}
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

## Troubleshooting

If chain properties aren't working, make sure [TypeScript](/react/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).
</file>

<file path="site/react/guides/connect-wallet.md">
# Connect Wallet

The ability for a user to connect their wallet is a core function for any Dapp. It allows users to perform tasks such as: writing to contracts, signing messages, or sending transactions.

Wagmi contains everything you need to get started with building a Connect Wallet module. To get started, you can either use a [third-party library](#third-party-libraries) or [build your own](#build-your-own).

## Third-party Libraries

You can use a pre-built Connect Wallet module from a third-party library such as:

- [ConnectKit](https://docs.family.co/connectkit) - [Guide](https://docs.family.co/connectkit/getting-started)
- [AppKit](https://walletconnect.com/appkit) - [Guide](https://docs.walletconnect.com/appkit/next/core/installation)
- [RainbowKit](https://www.rainbowkit.com/) - [Guide](https://www.rainbowkit.com/docs/installation)
- [Dynamic](https://www.dynamic.xyz/) - [Guide](https://docs.dynamic.xyz/quickstart)
- [Privy](https://privy.io) - [Guide](https://docs.privy.io/guide/react/wallets/usage/wagmi)

The above libraries are all built on top of Wagmi, handle all the edge cases around wallet connection, and provide a seamless Connect Wallet UX that you can use in your Dapp.

## Build Your Own

Wagmi provides you with the Hooks to get started building your own Connect Wallet module. 

It takes less than five minutes to get up and running with Browser Wallets, WalletConnect, and Coinbase Wallet.

### 1. Configure Wagmi

Before we get started with building the functionality of the Connect Wallet module, we will need to set up the Wagmi configuration.

Let's create a `config.ts` file and export a `config` object.

::: code-group

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

In the above configuration, we want to set up connectors for Injected (browser), WalletConnect (browser + mobile), MetaMask, and Safe wallets. This configuration uses the **Mainnet** and **Base** chains, but you can use whatever you want.

::: warning

Make sure to replace the `projectId` with your own WalletConnect Project ID, if you wish to use WalletConnect! 

[Get your Project ID](https://cloud.walletconnect.com/)

:::

### 2. Wrap App in Context Provider

Next, we will need to wrap our React App with Context so that our application is aware of Wagmi & React Query's reactive state and in-memory caching.

::: code-group

```tsx [app.tsx]
 // 1. Import modules
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

// 2. Set up a React Query client.
const queryClient = new QueryClient()

function App() {
  // 3. Wrap app with Wagmi and React Query context.
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        {/** ... */} 
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 3. Display Wallet Options

After that, we will create a `WalletOptions` component that will display our connectors. This will allow users to select a wallet and connect.

Below, we are rendering a list of `connectors` retrieved from `useConnect`. When the user clicks on a connector, the `connect` function will connect the users' wallet.

::: code-group

```tsx [wallet-options.tsx]
import * as React from 'react'
import { Connector, useConnect } from 'wagmi'

export function WalletOptions() {
  const { connectors, connect } = useConnect()

  return connectors.map((connector) => (
    <button key={connector.uid} onClick={() => connect({ connector })}>
      {connector.name}
    </button>
  ))
}
```

```tsx [app.tsx]
 // 1. Import modules
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

// 2. Set up a React Query client.
const queryClient = new QueryClient()

function App() {
  // 3. Wrap app with Wagmi and React Query context.
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        {/* ... */}
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 4. Display Connected Account

Lastly, if an account is connected, we want to show some basic information, like the connected address and ENS name and avatar.

Below, we are using hooks like `useAccount`, `useEnsAvatar` and `useEnsName` to extract this information.

We are also utilizing `useDisconnect` to show a "Disconnect" button so a user can disconnect their wallet.

::: code-group

```tsx [account.tsx]
import { useAccount, useDisconnect, useEnsAvatar, useEnsName } from 'wagmi'

export function Account() {
  const { address } = useAccount()
  const { disconnect } = useDisconnect()
  const { data: ensName } = useEnsName({ address })
  const { data: ensAvatar } = useEnsAvatar({ name: ensName! })

  return (
    <div>
      {ensAvatar && <img alt="ENS Avatar" src={ensAvatar} />}
      {address && <div>{ensName ? `${ensName} (${address})` : address}</div>}
      <button onClick={() => disconnect()}>Disconnect</button>
    </div>
  )
}
```

```tsx [wallet-options.tsx]
import * as React from 'react'
import { Connector, useConnect } from 'wagmi'

export function WalletOptions() {
  const { connectors, connect } = useConnect()

  return connectors.map((connector) => (
    <WalletOption
      key={connector.uid}
      connector={connector}
      onClick={() => connect({ connector })}
    />
  ))
}

function WalletOption({
  connector,
  onClick,
}: {
  connector: Connector
  onClick: () => void
}) {
  const [ready, setReady] = React.useState(false)

  React.useEffect(() => {
    ;(async () => {
      const provider = await connector.getProvider()
      setReady(!!provider)
    })()
  }, [connector])

  return (
    <button disabled={!ready} onClick={onClick}>
      {connector.name}
    </button>
  )
}
```

```tsx [app.tsx]
 // 1. Import modules
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

// 2. Set up a React Query client.
const queryClient = new QueryClient()

function App() {
  // 3. Wrap app with Wagmi and React Query context.
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        {/* ... */}
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 5. Wire it up!

Finally, we can wire up our Wallet Options and Account components to our application's entrypoint.

::: code-group

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from './config'
import { Account } from './account' // [!code ++]
import { WalletOptions } from './wallet-options' // [!code ++]

const queryClient = new QueryClient()

function ConnectWallet() { // [!code ++]
  const { isConnected } = useAccount() // [!code ++]
  if (isConnected) return <Account /> // [!code ++]
  return <WalletOptions /> // [!code ++]
} // [!code ++]

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        <ConnectWallet /> // [!code ++]
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [account.tsx]
import { useAccount, useDisconnect, useEnsAvatar, useEnsName } from 'wagmi'

export function Account() {
  const { address } = useAccount()
  const { disconnect } = useDisconnect()
  const { data: ensName } = useEnsName({ address })
  const { data: ensAvatar } = useEnsAvatar({ name: ensName! })

  return (
    <div>
      {ensAvatar && <img alt="ENS Avatar" src={ensAvatar} />}
      {address && <div>{ensName ? `${ensName} (${address})` : address}</div>}
      <button onClick={() => disconnect()}>Disconnect</button>
    </div>
  )
}
```

```tsx [wallet-options.tsx]
import * as React from 'react'
import { Connector, useConnect } from 'wagmi'

export function WalletOptions() {
  const { connectors, connect } = useConnect()

  return connectors.map((connector) => (
    <WalletOption
      key={connector.uid}
      connector={connector}
      onClick={() => connect({ connector })}
    />
  ))
}

function WalletOption({
  connector,
  onClick,
}: {
  connector: Connector
  onClick: () => void
}) {
  const [ready, setReady] = React.useState(false)

  React.useEffect(() => {
    ;(async () => {
      const provider = await connector.getProvider()
      setReady(!!provider)
    })()
  }, [connector])

  return (
    <button disabled={!ready} onClick={onClick}>
      {connector.name}
    </button>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### Playground

Want to see the above steps all wired up together in an end-to-end example? Check out the below StackBlitz playground.

<br/>

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-ujbsuv?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>
</file>

<file path="site/react/guides/error-handling.md">
# Error Handling

The `error` property in Wagmi Hooks is strongly typed with it's corresponding error type. This enables you to have granular precision with handling errors in your application.

You can discriminate the error type by using the `name` property on the error object.

::: code-group
```tsx twoslash [index.tsx]
// @noErrors
import { useBlockNumber } from 'wagmi'

function App() {
  const { data, error } = useBlockNumber()
  //            ^?

  error?.name
  //     ^?






  if (error?.name === 'HttpRequestError') {
    const { status } = error
    //      ^?      


    return <div>A HTTP error occurred. Status: {status}</div>
  }
  if (error?.name === 'LimitExceededRpcError') {
    const { code } = error
    //      ^?

    
    return <div>Rate limit exceeded. Code: {code}</div>
  }
  // ...
}
```
<<< @/snippets/react/config.ts[config.ts]
:::
</file>

<file path="site/react/guides/ethers.md">
# Ethers.js Adapters

It is recommended for projects to migrate to [Viem](https://viem.sh) when using Wagmi, but there are some cases where you might still need to use [Ethers.js](https://ethers.org) in your project:

- You may want to **incrementally migrate** Ethers.js usage to Viem
- Some **third-party libraries & SDKs** may only support Ethers.js
- Personal preference

We have provided reference implementations for Viem ‚Üí Ethers.js adapters that you can copy + paste in your project.

## Client ‚Üí Provider

### Reference Implementation

Copy the following reference implementation into a file of your choice:

::: code-group

```ts [Ethers v5]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback')
    return new providers.FallbackProvider(
      (transport.transports as ReturnType<Transport>[]).map(
        ({ value }) => new providers.JsonRpcProvider(value?.url, network),
      ),
    )
  return new providers.JsonRpcProvider(transport.url, network)
}

/** Hook to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({
  chainId,
}: { chainId?: number | undefined } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

```ts [Ethers v6]
import { FallbackProvider, JsonRpcProvider } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { type Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback') {
    const providers = (transport.transports as ReturnType<Transport>[]).map(
      ({ value }) => new JsonRpcProvider(value?.url, network),
    )
    if (providers.length === 1) return providers[0]
    return new FallbackProvider(providers)
  }
  return new JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({ chainId }: { chainId?: number } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

:::

### Usage

Now you can use the `useEthersProvider` function in your components:

::: code-group

```ts [example.ts]
import { useEthersProvider } from './ethers'

function Example() {
  const provider = useEthersProvider()
  ...
}
```

```ts [ethers.ts (Ethers v5)]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback')
    return new providers.FallbackProvider(
      (transport.transports as ReturnType<Transport>[]).map(
        ({ value }) => new providers.JsonRpcProvider(value?.url, network),
      ),
    )
  return new providers.JsonRpcProvider(transport.url, network)
}

/** Hook to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({
  chainId,
}: { chainId?: number | undefined } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

```ts [ethers.ts (Ethers v6)]
import { FallbackProvider, JsonRpcProvider } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { type Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback') {
    const providers = (transport.transports as ReturnType<Transport>[]).map(
      ({ value }) => new JsonRpcProvider(value?.url, network),
    )
    if (providers.length === 1) return providers[0]
    return new FallbackProvider(providers)
  }
  return new JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({ chainId }: { chainId?: number } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

:::

## Connector Client ‚Üí Signer

### Reference Implementation

Copy the following reference implementation into a file of your choice:

::: code-group

```ts [Ethers v5]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new providers.Web3Provider(transport, network)
  const signer = provider.getSigner(account.address)
  return signer
}

/** Hook to convert a Viem Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

```ts [Ethers v6]
import { BrowserProvider, JsonRpcSigner } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { type Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new BrowserProvider(transport, network)
  const signer = new JsonRpcSigner(provider, account.address)
  return signer
}

/** Hook to convert a viem Wallet Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

:::

### Usage

Now you can use the `useEthersSigner` function in your components:

::: code-group

```ts [example.ts]
import { useEthersSigner } from './ethers'

function example() {
  const signer = useEthersSigner()
  ...
}
```

```ts [ethers.ts (Ethers v5)]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new providers.Web3Provider(transport, network)
  const signer = provider.getSigner(account.address)
  return signer
}

/** Action to convert a Viem Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

```ts [ethers.ts (Ethers v6)]
import { BrowserProvider, JsonRpcSigner } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { type Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new BrowserProvider(transport, network)
  const signer = new JsonRpcSigner(provider, account.address)
  return signer
}

/** Hook to convert a viem Wallet Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

:::
</file>

<file path="site/react/guides/faq.md">
<script setup>
const docsPath = 'react'
</script>

# FAQ / Troubleshooting

Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

<!--@include: @shared/faq.md-->

## How does Wagmi work?

Until there's a more in-depth write-up about Wagmi internals, here is the gist:

- Wagmi is essentially a wrapper around [Viem](https://viem.sh) and TanStack Query that adds connector and multichain support.
- [Connectors](/react/api/connectors) allow Wagmi and Ethereum accounts to communicate with each other.
- The Wagmi [`Config`](/react/api/createConfig#config) manages connections established between Wagmi and Connectors, as well as some global state. [Connections](/react/api/createConfig#connection) come with one or more addresses and a chain ID.
  - If there are connections, the Wagmi `Config` listens for connection changes and updates the [`chainId`](/react/api/createConfig#chainid) based on the ["current" connection](/react/api/createConfig#current). (The Wagmi `Config` can have [many connections established](/react/api/createConfig#connections) at once, but only one connection can be the "current" connection. Usually this is the connection from the last connector that is connected, but can change based on event emitted from other connectors or through the [`useSwitchAccount`](/react/api/hooks/useSwitchAccount) hook and [`switchAccount`](/core/api/actions/switchAccount) action.)
  - If there are no connections, the Wagmi `Config` defaults the global state `chainId` to the first chain it was created with or last established connection.
  - The global `chainId` can be changed directly using the [`useSwitchChain`](/react/api/hooks/useSwitchChain) hook and [`switchChain`](/core/api/actions/switchChain) action. This works when there are no connections as well as for most connectors (not all connectors support chain switching).
- Wagmi uses the global `chainId` (from the "current" connection or global state) to internally create Viem Client's, which are used by hooks and actions.
- Hooks are constructed by TanStack Query options helpers, exported by the `'@wagmi/core/query'` entrypoint, and some additional code to wire up type parameters, hook into React Context, etc.
- There are three types of hooks: query hooks, mutation hooks, and config hooks. Query hooks, like [`useCall`](/react/api/hooks/useCall), generally read blockchain state and mutation hooks, like [`useSendTransaction`](/react/api/hooks/useSendTransaction), usually change state through sending transactions via the "current" connection. Config hooks are for getting data from and managing the Wagmi `Config` instance, e.g. [`useChainId`](/react/api/hooks/useChainId) and `useSwitchAccount`. Query and mutation hooks usually have corresponding [Viem actions.](https://viem.sh)
</file>

<file path="site/react/guides/migrate-from-v1-to-v2.md">
---
title: Migrate from v1 to v2
description: Guide for migrating from Wagmi v1 to v2.
---

<script setup>
import packageJson from '../../../packages/react/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Migrate from v1 to v2

## Overview

Wagmi v2 redesigns the core APIs to mesh better with [Viem](https://viem.sh) and [TanStack Query](https://tanstack.com/query/v5/docs/react). This major version transforms Wagmi into a light wrapper around these libraries, sprinkling in multichain support and account management. As such, there are some breaking changes and deprecations to be aware of outlined in this guide.

To get started, install the latest version of Wagmi and it's required peer dependencies.

::: code-group
```bash-vue [pnpm]
pnpm add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [npm]
npm install wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [yarn]
yarn add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [bun]
bun add wagmi viem@{{viemVersion}} @tanstack/react-query
```
:::

::: info Wagmi v2 should be the last major version that will have this many actionable breaking changes. 
Moving forward after Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.
:::

::: info Not ready to migrate yet?
The Wagmi v1 docs are still available at [1.x.wagmi.sh/react](https://1.x.wagmi.sh/react).
:::

## Dependencies

### Moved TanStack Query to peer dependencies

Wagmi uses [TanStack Query](https://tanstack.com/query/v5/docs/react) to manage async state, handling requests, caching, and more. With Wagmi v1, TanStack Query was an internal implementation detail. With Wagmi v2, TanStack Query is a peer dependency. A lot of Wagmi users also use TanStack Query in their apps so making it a peer dependency gives them more control and removes some custom Wagmi code internally.

If you don't normally use TanStack Query, all you need to do is set it up and mostly forget about it (we'll provide guidance around version updates).

::: code-group
```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query' // [!code ++]
import { WagmiProvider } from 'wagmi'
import { config } from './config'

const queryClient = new QueryClient() // [!code ++]

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> // [!code ++]
        {/** ... */}
      </QueryClientProvider> // [!code ++]
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

For more information on setting up TanStack Query for Wagmi, follow the [Getting Started docs](/react/getting-started#setup-tanstack-query). If you want to set up persistence for your query cache (default behavior before Wagmi v2), check out the [TanStack Query docs](https://tanstack.com/query/v5/docs/react/plugins/persistQueryClient#usage-with-react).

### Dropped CommonJS support

Wagmi v2 no longer publishes a separate `cjs` tag since very few people use this tag and ESM is the future. See [Sindre Sorhus' guide](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c) for more info about switching to ESM.

## Hooks

### Removed mutation setup arguments

Mutation hooks are hooks that change network or application state, sign data, or perform write operations through mutation functions. With Wagmi v1, you could pass arguments directly to these hooks instead of using them with their mutation functions. For example:

```ts{3}
// Wagmi v1
const { signMessage } = useSignMessage({
  message: 'foo bar baz',
})
```

With Wagmi v2, you must pass arguments to the mutation function instead. This follows the same behavior as [TanStack Query](https://tanstack.com/query/v5/docs/react/guides/mutations) mutations and improves type-safety.

```tsx
import { useSignMessage } from 'wagmi'

const { signMessage } = useSignMessage({ message: 'foo bar baz' }) // [!code --]
const { signMessage } = useSignMessage() // [!code ++]

<button
  onClick={() => signMessage()} // [!code --]
  onClick={() => signMessage({ message: 'foo bar baz' })} // [!code ++]
>
  Sign message
</button>
```

### Moved TanStack Query parameters to `query` property

Previously, you could pass TanStack Query parameters, like `enabled` and `staleTime`, directly to hooks. In Wagmi v2, TanStack Query parameters are now moved to the `query` property. This allows Wagmi to better support TanStack Query type inference, control for future breaking changes since [TanStack Query is now a peer dependency](#moved-tanstack-query-to-peer-dependencies), and expose Wagmi-related hook property at the top-level of editor features, like autocomplete.

```tsx
useReadContract({
  enabled: false, // [!code --]
  staleTime: 1_000, // [!code --]
  query: { // [!code ++]
    enabled: false, // [!code ++]
    staleTime: 1_000, // [!code ++]
  }, // [!code ++]
})
```

### Removed watch property

The `watch` property was removed from all hooks besides [`useBlock`](/react/api/hooks/useBlock) and [`useBlockNumber`](/react/api/hooks/useBlockNumber). This property allowed hooks to internally listen for block changes and automatically refresh their data. In Wagmi v2, you can compose `useBlock` or `useBlockNumber` along with [`React.useEffect`](https://react.dev/reference/react/useEffect) to achieve the same behavior. Two different approaches are outlined for `useBalance` below.

::: code-group
```ts [invalidateQueries]
import { useQueryClient } from '@tanstack/react-query' // [!code ++]
import { useEffect } from 'react' // [!code ++]
import { useBlockNumber, useBalance } from 'wagmi' // [!code ++]

const queryClient = useQueryClient() // [!code ++]
const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code ++]
const { data: balance, queryKey } = useBalance({ // [!code ++]
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  watch: true, // [!code --]
})

useEffect(() => { // [!code ++]
  queryClient.invalidateQueries({ queryKey }) // [!code ++]
}, [blockNumber, queryClient]) // [!code ++]
```
```ts [refetch]
import { useEffect } from 'react' // [!code ++]
import { useBlockNumber, useBalance } from 'wagmi' // [!code ++]

const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code ++]
const { data: balance, refetch } = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  watch: true, // [!code --]
})

useEffect(() => { // [!code ++]
  refetch() // [!code ++]
}, [blockNumber]) // [!code ++]
```
:::

This is a bit more code, but removes a lot of internal code from hooks that can slow down your app when not used and gives you more control. For example, you can easily refresh data every five blocks instead of every block.

```ts
const { data: blockNumber } = useBlockNumber({ watch: true })
const { data: balance, queryKey } = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})

useEffect(() => {
  if (blockNumber % 5 === 0) // [!code focus]
    queryClient.invalidateQueries({ queryKey }) // [!code focus]
}, [blockNumber, queryClient])
```

### Removed suspense property

Wagmi used to support an experimental `suspense` property via TanStack Query. Since TanStack Query [removed `suspense`](https://tanstack.com/query/v5/docs/react/guides/migrating-to-v5#new-hooks-for-suspense) from its `useQuery` hook, it is no longer supported by Wagmi Hooks.

Instead, you can use `useSuspenseQuery` along with TanStack Query-related exports from the `'wagmi/query'` entrypoint.

```ts
import { useSuspenseQuery } from '@tanstack/react-query' // [!code ++]
import { useConfig } from 'wagmi' // [!code ++]
import { getBalanceQueryOptions } from 'wagmi/query' // [!code ++]
import { useBalance } from 'wagmi' // [!code --]

const config = useConfig() // [!code ++]
const options = getBalanceQueryOptions(config, { address: '0x‚Ä¶' }) // [!code ++]
const result = useSuspenseQuery(options) // [!code ++]
const result = useBalance({ // [!code --]
  address: '0x‚Ä¶', // [!code --]
  suspense: true, // [!code --]
}) // [!code --]
```

### Removed prepare hooks

`usePrepareContractWrite` and `usePrepareSendTransaction` were removed and replaced with idiomatic Viem alternatives. For `usePrepareContractWrite`, use [`useSimulateContract`](/react/api/hooks/useSimulateContract). Similar to `usePrepareContractWrite`, `useSimulateContract` composes well with `useWriteContract`

```tsx
import { usePrepareContractWrite, useWriteContract } from 'wagmi' // [!code --]
import { useSimulateContract, useWriteContract } from 'wagmi' // [!code ++]

const { config } = usePrepareContractWrite({ // [!code --]
const { data } = useSimulateContract({ // [!code ++]
  address: '0x',
  abi: [{
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'sender', type: 'address' },
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  }],
  functionName: 'transferFrom',
  args: ['0x', '0x', 123n],
})
const { write } = useWriteContract(config) // [!code --]
const { writeContract } = useWriteContract() // [!code ++]

<button
  disabled={!Boolean(write)} // [!code --]
  onClick={() => write()} // [!code --]
  disabled={!Boolean(data?.request)} // [!code ++]
  onClick={() => writeContract(data!.request)} // [!code ++]
>
  Write contract
</button>
```

Instead of `usePrepareSendTransaction`, use [`useEstimateGas`](/react/api/hooks/useEstimateGas). You can pass `useEstimateGas` `data` to `useSendTransaction` to compose the two hooks.

```tsx
import { usePrepareSendTransaction, useSendTransaction } from 'wagmi' // [!code --]
import { useEstimateGas, useSendTransaction } from 'wagmi' // [!code ++]
import { parseEther } from 'viem'

const { config } = usePrepareSendTransaction({ // [!code --]
const { data } = useEstimateGas({ // [!code ++]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
const { sendTransaction } = useSendTransaction(config) // [!code --]
const { sendTransaction } = useSendTransaction() // [!code ++]

<button
  disabled={!Boolean(sendTransaction)} // [!code --]
  onClick={() => sendTransaction()} // [!code --]
  disabled={!Boolean(data)} // [!code ++]
  onClick={() => sendTransaction({ // [!code ++]
    gas: data, // [!code ++]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code ++]
    value: parseEther('0.01'), // [!code ++]
  })} // [!code ++]
>
  Send transaction
</button>
```

This might seem like more work, but it gives you more control and is more accurate representation of what is happening under the hood.

### Removed `useNetwork` hook

The `useNetwork` hook was removed since the connected chain is typically based on the connected account. Use [`useAccount`](/react/api/hooks/useAccount) to get the connected `chain`.

```ts
import { useNetwork } from 'wagmi' // [!code --]
import { useAccount } from 'wagmi' // [!code ++]

const { chain } = useNetwork() // [!code --]
const { chain } = useAccount() // [!code ++]
```

Use `useConfig` for the list of `chains` set up with the Wagmi [`Config`](/react/api/createConfig#chains).

```ts
import { useNetwork } from 'wagmi' // [!code --]
import { useConfig } from 'wagmi' // [!code ++]

const { chains } = useNetwork() // [!code --]
const { chains } = useConfig() // [!code ++]
```

### Removed `onConnect` and `onDisconnect` callbacks from `useAccount`

The `onConnect` and `onDisconnect` callbacks were removed from the `useAccount` hook since it is frequently used without these callbacks so it made sense to extract these into a new API, [`useAccountEffect`](/react/api/hooks/useAccountEffect), rather than clutter the `useAccount` hook.

```ts
import { useAccount } from 'wagmi' // [!code --]
import { useAccountEffect } from 'wagmi' // [!code ++]

useAccount({ // [!code --]
useAccountEffect({ // [!code ++]
  onConnect(data) {
    console.log('connected', data)
  },
  onDisconnect() {
    console.log('disconnected')
  },
}) 
```

### Removed `useWebSocketPublicClient`

The Wagmi [`Config`](/react/api/createConfig) does not separate transport types anymore. Simply use Viem's [`webSocket`](https://viem.sh/docs/clients/transports/websocket.html) transport instead when setting up your Wagmi `Config`. You can get Viem `Client` instance with this transport attached by using [`useClient`](/react/api/hooks/useClient) or [`usePublicClient`](/react/api/hooks/usePublicClient).

### Removed `useInfiniteReadContracts` `paginatedIndexesConfig`

In the spirit of removing unnecessary abstractions, `paginatedIndexesConfig` was removed. Use `useInfiniteReadContracts`'s `initialPageParam` and `getNextPageParam` parameters along with `fetchNextPage`/`fetchPreviousPage` from the result instead or copy `paginatedIndexesConfig`'s implementation to your codebase.

See the [TanStack Query docs](https://tanstack.com/query/v5/docs/react/guides/infinite-queries) for more information on infinite queries.

### Updated `useSendTransaction` and `useWriteContract` return type

Updated [`useSendTransaction`](/react/api/hooks/useSendTransaction) and [`useWriteContract`](/react/api/hooks/useWriteContract) return type from `` { hash: `0x${string}` } `` to `` `0x${string}` ``.

```ts
const result = useSendTransaction()
result.data?.hash // [!code --]
result.data // [!code ++]
```

### Updated `useConnect` return type

Updated [`useConnect`](/react/api/hooks/useConnect) return type from `` { account: Address; chain: { id: number; unsupported?: boolean }; connector: Connector } `` to `` { accounts: readonly Address[]; chainId: number } ``. This better reflects the ability to have multiple accounts per connector.

### Renamed parameters and return types

All hook parameters and return types follow the naming pattern of `[PascalCaseHookName]Parameters` and `[PascalCaseHookName]ReturnType`. For example, `UseAccountParameters` and `UseAccountReturnType`.

```ts
import { UseAccountConfig, UseAccountResult } from 'wagmi' // [!code --]
import { UseAccountParameters, UseAccountReturnType } from 'wagmi' // [!code ++]
```

## Connectors

### Updated connector API

In order to maximize type-safety and ease of creating connectors, the connector API changed. Follow the [Creating Connectors guide](/dev/creating-connectors) for more info on creating new connectors and converting Wagmi v1 connectors.

### Removed individual entrypoints

Previously, each connector had it's own entrypoint to optimize tree-shaking. Since all connectors now have [`package.json#sideEffects`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) enabled, this is no longer necessary and the entrypoint is unified. Use the `'wagmi/connectors'` entrypoint instead.

```ts
import { InjectedConnector } from 'wagmi/connectors/injected' // [!code --]
import { CoinbaseWalletConnector } from 'wagmi/connectors/coinbaseWallet' // [!code --]
import { coinbaseWallet, injected } from 'wagmi/connectors' // [!code ++]
```

### Removed `MetaMaskConnector`

The `MetaMaskConnector` was removed since it was nearly the same thing as the `InjectedConnector`. Use the [`injected`](/react/api/connectors/injected) connector instead, along with the [`target`](/react/api/connectors/injected#target) parameter set to `'metaMask'`, for the same behavior.

```ts
import { MetaMaskConnector } from 'wagmi/connectors/metaMask' // [!code --]
import { injected } from 'wagmi/connectors' // [!code ++]

const connector = new MetaMaskConnector() // [!code --]
const connector = injected({ target: 'metaMask' }) // [!code ++]
```
### Renamed connectors

In Wagmi v1, connectors were classes you needed to instantiate. In Wagmi v2, connectors are functions. As a result, the API has changed. Connectors have the following new names:

- `CoinbaseWalletConnector` is now [`coinbaseWallet`](/react/api/connectors/coinbaseWallet).
- `InjectedConnector` is now [`injected`](/react/api/connectors/injected).
- `SafeConnector` is now [`safe`](/react/api/connectors/safe).
- `WalletConnectConnector` is now [`walletConnect`](/react/api/connectors/walletConnect).

To create a connector, you now call the connector function with parameters.

```ts
import { WalletConnectConnector } from 'wagmi/connectors/walletConnect' // [!code --]
import { walletConnect } from 'wagmi/connectors' // [!code ++]

const connector = new WalletConnectConnector({ // [!code --]
const connector = walletConnect({ // [!code ++]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### Removed `WalletConnectLegacyConnector`

WalletConnect v1 was sunset June 28, 2023. Use the [`walletConnect`](/react/api/connectors/walletConnect) connector instead.

```ts
import { WalletConnectLegacyConnector } from 'wagmi/connectors/walletConnectLegacy' // [!code --]
import { walletConnect } from 'wagmi/connectors' // [!code ++]

const connector = new WalletConnectLegacyConnector({ // [!code --]
const connector = walletConnect({ // [!code ++]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

## Chains

### Updated `'wagmi/chains'` entrypoint

Chains now live in the [Viem repository](https://github.com/wevm/viem). As a result, the `'wagmi/chains'` entrypoint now proxies all chains from `'viem/chains'` directly.

### Removed `mainnet` and `sepolia` from main entrypoint

Since the `'wagmi/chains'` entrypoint now proxies `'viem/chains'`, `mainnet` and `sepolia` were removed from the main entrypoint. Use the `'wagmi/chains'` entrypoint instead.

```ts
import { mainnet, sepolia } from 'wagmi' // [!code --]
import { mainnet, sepolia } from 'wagmi/chains' // [!code ++]
```

## Errors

A number of errors were renamed to better reflect their functionality or replaced by Viem errors.

## Miscellaneous

### Removed internal ENS name normalization

Before v2, Wagmi handled ENS name normalization internally for `useEnsAddress`, `useEnsAvatar`, and `useEnsResolver`, using Viem's [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function. This added extra bundle size as full normalization is quite heavy. For v2, you must normalize ENS names yourself before passing them to these hooks. You can use Viem's `normalize` function or any other function that performs [UTS-46 normalization](https://unicode.org/reports/tr46).

```ts
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens' // [!code ++]

const result = useEnsAddress({
  name: 'wevm.eth', // [!code --]
  name: normalize('wevm.eth'), // [!code ++]
})
```

By inverting control, Wagmi let's you choose how much normalization to do. For example, maybe your project only allows ENS names that are numeric so no normalization is not needed. Check out the [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) for more information on normalizing names.

### Removed `configureChains`

The Wagmi v2 `Config` now has native multichain support using the [`chains`](/react/api/createConfig) parameter so the `configureChains` function is no longer required.

```ts
import { configureChains, createConfig } from 'wagmi' // [!code --]
import { http, createConfig } from 'wagmi' // [!code ++]
import { mainnet, sepolia } from 'wagmi/chains'

const { chains, publicClient } = configureChains( // [!code --]
  [mainnet, sepolia], // [!code --]
  [publicProvider(), publicProvider()], // [!code --]
) // [!code --]

export const config = createConfig({
  publicClient, // [!code --]
  chains: [mainnet, sepolia], // [!code ++]
  transports: { // [!code ++]
    [mainnet.id]: http(), // [!code ++]
    [sepolia.id]: http(), // [!code ++]
  }, // [!code ++]
})
```

### Removed ABI exports

Import from Viem instead.

```ts
import { erc20ABI } from 'wagmi' // [!code --]
import { erc20Abi } from 'viem' // [!code ++]
```

### Removed `'wagmi/providers/*` entrypoints

It never made sense that we would have provider URLs hardcoded in the Wagmi codebase. Use [Viem transports](https://viem.sh/docs/clients/intro.html#transports) along with RPC provider URLs instead.

```ts
import { alchemyProvider } from 'wagmi/providers/alchemy' // [!code --]
import { http } from 'viem' // [!code ++]

const transport = http('https://mainnet.example.com')
```

### Updated `createConfig` parameters

- Removed `autoConnect`. The reconnecting behavior is now managed by React and not related to the Wagmi `Config`. Use `WagmiProvider` [`reconnectOnMount`](/react/api/WagmiProvider#reconnectonmount) or [`useReconnect`](/react/api/hooks/useReconnect) hook instead.
- Removed `publicClient` and `webSocketPublicClient`. Use [`transports`](/react/api/createConfig#transports) or [`client`](/react/api/createConfig#client) instead.
- Removed `logger`. Wagmi no longer logs debug information to console.

### Updated `Config` object

- Removed `config.connector`. Use `config.state.connections.get(config.state.current)?.connector` instead.
- Removed `config.data`. Use `config.state.connections.get(config.state.current)` instead.
- Removed `config.error`. Was unused and not needed.
- Removed `config.lastUsedChainId`. Use `config.state.connections.get(config.state.current)?.chainId` instead.
- Removed `config.publicClient`. Use [`config.getClient()`](/react/api/createConfig#getclient) or [`getPublicClient`](/core/api/actions/getPublicClient) instead.
- Removed `config.status`. Use [`config.state.status`](/react/api/createConfig#status) instead.
- Removed `config.webSocketClient`. Use [`config.getClient()`](/react/api/createConfig#getclient) or [`getPublicClient`](/core/api/actions/getPublicClient) instead.
- Removed `config.clearState`. Was unused and not needed.
- Removed `config.autoConnect()`. Use [`reconnect`](/core/api/actions/reconnect) action instead.
- Renamed `config.setConnectors`. Use `config._internal.setConnectors` instead.
- Removed `config.setLastUsedConnector`. Use `config.storage?.setItem('recentConnectorId', connectorId)` instead.
- Removed `getConfig`. `config` should be passed explicitly to actions instead of using global `config`.

## Deprecations

### Renamed `WagmiConfig`

`WagmiConfig` was renamed to [`WagmiProvider`](/react/api/WagmiProvider) to reduce confusion with the Wagmi [`Config`](/react/api/createConfig) type. React Context Providers usually follow the naming schema `*Provider` so this is a more idiomatic name. Now that Wagmi no longer uses Ethers.js (since Wagmi v1), the term "Provider" is less overloaded.

::: code-group
```tsx [app.tsx]
import { WagmiConfig } from 'wagmi' // [!code --]
import { WagmiProvider } from 'wagmi' // [!code ++]
import { config } from './config'

function App() {
  return (
    <WagmiConfig config={config}> // [!code --]
    <WagmiProvider config={config}> // [!code ++]
      {/** ... */}
    </WagmiProvider> // [!code ++]
    </WagmiConfig> // [!code --]
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### Deprecated `useBalance` `token` parameter

Moving forward, `useBalance` will only work for native currencies, thus the `token` parameter is no longer supported. Use [`useReadContracts`](/react/api/hooks/useReadContracts) instead.

```ts
import { useBalance } from 'wagmi' // [!code --]
import { useReadContracts } from 'wagmi' // [!code ++]
import { erc20Abi } from 'viem' // [!code ++]

const result = useBalance({ // [!code --]
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code --]
  token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code --]
}) // [!code --]
const result = useReadContracts({ // [!code ++]
  allowFailure: false, // [!code ++]
  contracts: [ // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'balanceOf', // [!code ++]
      args: ['0x4557B18E779944BFE9d78A672452331C186a9f48'], // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'decimals', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'symbol', // [!code ++]
    }, // [!code ++]
  ] // [!code ++]
}) // [!code ++]
```

### Deprecated `useBalance` `unit` parameter and `formatted` return value

Moving forward, `useBalance` will not accept the `unit` parameter or return a `formatted` value. Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

```ts
import { formatUnits } from 'viem' // [!code ++]
import { useBalance } from 'wagmi'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  unit: 'ether', // [!code --]
})
result.data!.formatted // [!code --]
formatUnits(result.data!.value, result.data!.decimals) // [!code ++]
```

### Deprecated `useToken`

Moving forward, `useToken` is no longer supported. Use [`useReadContracts`](/react/api/hooks/useReadContracts) instead.

```ts
import { useToken } from 'wagmi' // [!code --]
import { useReadContracts } from 'wagmi' // [!code ++]
import { erc20Abi } from 'viem' // [!code ++]

const result = useToken({ // [!code --]
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code --]
}) // [!code --]
const result = useReadContracts({ // [!code ++]
  allowFailure: false, // [!code ++]
  contracts: [ // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'decimals', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'name', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'symbol', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'totalSupply', // [!code ++]
    }, // [!code ++]
  ] // [!code ++]
}) // [!code ++]
```

### Deprecated `formatUnits` parameters and return values

The `formatUnits` parameter and related return values (e.g. `result.formatted`) are deprecated for the following hooks:

- [`useEstimateFeesPerGas`](/react/api/hooks/useEstimateFeesPerGas)
- [`useToken`](/react/api/hooks/useToken)

Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

```ts
import { formatUnits } from 'viem' // [!code ++]

const result = useToken({
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  formatUnits: 'ether',
})
result.data!.totalSupply.formatted  // [!code --]
formatUnits(result.data!.totalSupply.value, 18)  // [!code ++]
```

This allows us to invert control to users so they can handle number formatting however they want, taking into account precision, localization, and more.

### Renamed hooks

The following hooks were renamed to better reflect their functionality and underlying [Viem](https://viem.sh) actions:

- `useContractRead` is now [`useReadContract`](/react/api/hooks/useReadContract)
- `useContractReads` is now [`useReadContracts`](/react/api/hooks/useReadContracts)
- `useContractWrite` is now [`useWriteContract`](/react/api/hooks/useWriteContract)
- `useContractEvent` is now [`useWatchContractEvent`](/react/api/hooks/useWatchContractEvent)
- `useContractInfiniteReads` is now [`useInfiniteReadContracts`](/react/api/hooks/useInfiniteReadContracts)
- `useFeeData` is now [`useEstimateFeesPerGas`](/react/api/hooks/useEstimateFeesPerGas)
- `useSwitchNetwork` is now [`useSwitchChain`](/react/api/hooks/useSwitchChain)
- `useWaitForTransaction` is now [`useWaitForTransactionReceipt`](/react/api/hooks/useWaitForTransactionReceipt)

### Miscellaneous

- `WagmiConfigProps` renamed to [`WagmiProviderProps`](/react/api/WagmiProvider#parameters).
- `Context` renamed to [`WagmiContext`](/react/api/WagmiProvider#context).
</file>

<file path="site/react/guides/read-from-contract.md">
# Read from Contract

The [`useReadContract` Hook](/react/api/hooks/useReadContract) allows you to read data on a smart contract, from a `view` or `pure` (read-only) function. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

The component below shows how to retrieve the token balance of an address from the [Wagmi Example](https://etherscan.io/token/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2) contract

:::code-group
```tsx [read-contract.tsx]
import { useReadContract } from 'wagmi'
import { wagmiContractConfig } from './contracts'

function ReadContract() {
  const { data: balance } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
```ts [contracts.ts]
export const wagmiContractConfig = {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: [
    {
      type: 'function',
      name: 'balanceOf',
      stateMutability: 'view',
      inputs: [{ name: 'account', type: 'address' }],
      outputs: [{ type: 'uint256' }],
    },
    {
      type: 'function',
      name: 'totalSupply',
      stateMutability: 'view',
      inputs: [],
      outputs: [{ name: 'supply', type: 'uint256' }],
    },
  ],
} as const
```
:::

If `useReadContract` depends on another value (`address` in the example below), you can use the [`query.enabled`](/react/api/hooks/useReadContract#enabled) option to prevent the query from running until the dependency is ready.

```tsx
const { data: balance } = useReadContract({
  ...wagmiContractConfig,
  functionName: 'balanceOf',
  args: [address],
  query: { // [!code focus]
    enabled: !!address, // [!code focus]
  }, // [!code focus]
})
```

## Loading & Error States

The [`useReadContract` Hook](/react/api/hooks/useReadContract) also returns loading & error states, which can be used to display a loading indicator while the data is being fetched, or an error message if contract execution reverts.

:::code-group

```tsx [read-contract.tsx]
import { type BaseError, useReadContract } from 'wagmi'

function ReadContract() {
  const { 
    data: balance,
    error, // [!code ++]
    isPending // [!code ++]
  } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })

  if (isPending) return <div>Loading...</div> // [!code ++]

  if (error) // [!code ++]
    return ( // [!code ++]
      <div> // [!code ++]
        Error: {(error as BaseError).shortMessage || error.message} // [!code ++]
      </div> // [!code ++]
    )  // [!code ++]

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```

## Refetching On Blocks

The [`useBlockNumber` Hook](/react/api/hooks/useBlockNumber) can be utilized to refetch or [invalidate](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation) the contract data on a specific block interval.

:::code-group
```tsx [read-contract.tsx (refetch)]
import { useEffect } from 'react'
import { useBlockNumber, useReadContract } from 'wagmi'

function ReadContract() {
  const { data: balance, refetch } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })
  const { data: blockNumber } = useBlockNumber({ watch: true })

  useEffect(() => {
    // want to refetch every `n` block instead? use the modulo operator!
    // if (blockNumber % 5 === 0) refetch() // refetch every 5 blocks
    refetch()
  }, [blockNumber])

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
```tsx [read-contract.tsx (invalidate)]
import { useQueryClient } from '@tanstack/react-query'
import { useEffect } from 'react'
import { useBlockNumber, useReadContract } from 'wagmi'

function ReadContract() {
  const queryClient = useQueryClient()
  const { data: balance, refetch } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })
  const { data: blockNumber } = useBlockNumber({ watch: true })

  useEffect(() => {
    // if `useReadContract` is in a different hook/component,
    // you can import `readContractQueryKey` from `'wagmi/query'` and
    // construct a one-off query key to use for invalidation
    queryClient.invalidateQueries({ queryKey })
  }, [blockNumber, queryClient])

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
:::

## Calling Multiple Functions

We can use the [`useReadContract` Hook](/react/api/hooks/useReadContract) multiple times in a single component to call multiple functions on the same contract, but this ends up being hard to manage as the number of functions increases, especially when we also want to deal with loading & error states. 

Luckily, to make this easier, we can use the [`useReadContracts` Hook](/react/api/hooks/useReadContracts) to call multiple functions in a single call.

:::code-group

```tsx [read-contract.tsx]
import { type BaseError, useReadContracts } from 'wagmi'

function ReadContract() {
  const { 
    data,
    error,
    isPending
  } = useReadContracts({ 
    contracts: [{ 
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
    }, { 
      ...wagmiContractConfig, 
      functionName: 'ownerOf', 
      args: [69n], 
    }, { 
      ...wagmiContractConfig, 
      functionName: 'totalSupply', 
    }] 
  }) 
  const [balance, ownerOf, totalSupply] = data || [] 

  if (isPending) return <div>Loading...</div>

  if (error)
    return (
      <div>
        Error: {(error as BaseError).shortMessage || error.message}
      </div>
    ) 

  return (
    <>
      <div>Balance: {balance?.toString()}</div>
      <div>Owner of Token 69: {ownerOf?.toString()}</div> 
      <div>Total Supply: {totalSupply?.toString()}</div> 
    </>
  )
}
```

:::
</file>

<file path="site/react/guides/send-transaction.md">
# Send Transaction

The following guide teaches you how to send transactions in Wagmi. The example below builds on the [Connect Wallet guide](/react/guides/connect-wallet) and uses the [useSendTransaction](/react/api/hooks/useSendTransaction) & [useWaitForTransaction](/react/api/hooks/useWaitForTransactionReceipt) hooks. 

## Example

Feel free to check out the example before moving on:

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-zkzqj7?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>

## Steps

### 1. Connect Wallet

Follow the [Connect Wallet guide](/react/guides/connect-wallet) guide to get this set up.

### 2. Create a new component

Create your `SendTransaction` component that will contain the send transaction logic.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
 
export function SendTransaction() {
  return (
    <form>
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button type="submit">Send</button>
    </form>
  )
}
```

:::

### 3. Add a form handler

Next, we will need to add a handler to the form that will send the transaction when the user hits "Send". This will be a basic handler in this step.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
 
export function SendTransaction() {
  async function submit(e: React.FormEvent<HTMLFormElement>) { // [!code ++]
    e.preventDefault() // [!code ++]
    const formData = new FormData(e.target as HTMLFormElement) // [!code ++]
    const to = formData.get('address') as `0x${string}` // [!code ++]
    const value = formData.get('value') as string // [!code ++]
  } // [!code ++]

  return (
    <form> // [!code --]
    <form onSubmit={submit}> // [!code ++]
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button type="submit">Send</button>
    </form>
  )
}
```

:::

### 4. Hook up the `useSendTransaction` Hook

Now that we have the form handler, we can hook up the [`useSendTransaction` Hook](/react/api/hooks/useSendTransaction) to send the transaction.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { useSendTransaction } from 'wagmi' // [!code ++]
import { parseEther } from 'viem' // [!code ++]
 
export function SendTransaction() {
  const { data: hash, sendTransaction } = useSendTransaction() // [!code ++]

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) // [!code ++]
  } 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button type="submit">Send</button>
      {hash && <div>Transaction Hash: {hash}</div>} // [!code ++]
    </form>
  )
}
```

:::

### 5. Add loading state (optional)

We can optionally add a loading state to the "Send" button while we are waiting confirmation from the user's wallet.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { useSendTransaction } from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash, 
    isPending, // [!code ++]
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} // [!code ++]
        type="submit"
      >
        Send // [!code --]
        {isPending ? 'Confirming...' : 'Send'} // [!code ++]
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
    </form>
  )
}
```

:::

### 6. Wait for transaction receipt (optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Hook](/react/api/hooks/useWaitForTransactionReceipt). 

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { 
  useSendTransaction, 
  useWaitForTransactionReceipt // [!code ++]
} from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash, 
    isPending, 
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = // [!code ++]
    useWaitForTransactionReceipt({ // [!code ++]
      hash, // [!code ++]
    }) // [!code ++]

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Send'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
      {isConfirming && <div>Waiting for confirmation...</div>} // [!code ++]
      {isConfirmed && <div>Transaction confirmed.</div>} // [!code ++]
    </form>
  )
}
```

:::

### 7. Handle errors (optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { 
  type BaseError, // [!code ++]
  useSendTransaction, 
  useWaitForTransactionReceipt 
} from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash,
    error, // [!code ++] 
    isPending, 
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Send'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( // [!code ++]
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> // [!code ++]
      )} // [!code ++]
    </form>
  )
}
```

:::

### 8. Wire it up!

Finally, we can wire up our Send Transaction component to our application's entrypoint.

::: code-group

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from './config'
import { SendTransaction } from './send-transaction' // [!code ++]

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        <SendTransaction /> // [!code ++]
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [send-transaction.tsx]
import * as React from 'react'
import { 
  type BaseError, 
  useSendTransaction, 
  useWaitForTransactionReceipt 
} from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash,
    error, 
    isPending, 
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Send'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( 
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> 
      )} 
    </form>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

[See the Example.](#example)
</file>

<file path="site/react/guides/ssr.md">
---
outline: deep
---

# SSR

Wagmi uses client-only external stores (such as `localStorage` and `mipd`) to show the user the most relevant data as quickly as possible on first render.

However, the caveat of using these external client stores is that frameworks which incorporate SSR (such as Next.js) will throw hydration warnings on the client when it identifies mismatches between the server-rendered HTML and the client-rendered HTML.

To stop this from happening, you can toggle on the [`ssr`](/react/api/createConfig#ssr) property in the Wagmi Config.

```tsx
import { createConfig, http } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({ // [!code focus:99]
  chains: [mainnet, sepolia],
  ssr: true, // [!code ++]
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

Turning on the `ssr` property means that content from the external stores will be hydrated on the client after the initial mount.

## Persistence using Cookies

As a result of turning on the `ssr` property, external persistent stores like `localStorage` will be hydrated on the client **after the initial mount**.

This means that you will still see a flash of "empty" data on the client (e.g. a `"disconnected"` account instead of a `"reconnecting"` account, or an empty address instead of the last connected address) until after the first mount, when the store hydrates.

In order to persist data between the server and the client, you can use cookies.

### 1. Set up cookie storage

First, we will set up cookie storage in the Wagmi Config.

```tsx
import { 
  createConfig, 
  http, 
  cookieStorage, // [!code ++]
  createStorage // [!code ++]
} from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

export function getConfig() {
  return createConfig({
    chains: [mainnet, sepolia],
    ssr: true,
    storage: createStorage({  // [!code ++]
      storage: cookieStorage, // [!code ++]
    }),  // [!code ++]
    transports: {
      [mainnet.id]: http(),
      [sepolia.id]: http(),
    },
  })
}
```

### 2. Hydrate the cookie

Next, we will need to add some mechanisms to hydrate the stored cookie in Wagmi.

#### Next.js App Directory

In our `app/layout.tsx` file (a [Server Component](https://nextjs.org/docs/app/building-your-application/rendering/server-components)), we will need to extract the cookie from the `headers` function and pass it to [`cookieToInitialState`](/react/api/utilities/cookieToInitialState). 

We will need to pass this result to the [`initialState` property](/react/api/WagmiProvider#initialstate) of the `WagmiProvider`. The `WagmiProvider` **must** be in a Client Component tagged with `"use client"` (see `app/providers.tsx` tab).

::: code-group
```tsx [app/layout.tsx]
import { type ReactNode } from 'react'
import { headers } from 'next/headers' // [!code ++]
import { cookieToInitialState } from 'wagmi' // [!code ++]

import { getConfig } from './config'
import { Providers } from './providers'

export default async function Layout({ children }: { children: ReactNode }) {
  const initialState = cookieToInitialState( // [!code ++]
    getConfig(), // [!code ++]
    (await headers()).get('cookie') // [!code ++]
  ) // [!code ++]
  return (
    <html lang="en">
      <body>
        <Providers> // [!code --]
        <Providers initialState={initialState}> // [!code ++]
          {children}
        </Providers>
      </body>
    </html>
  )
}

```

```tsx [app/providers.tsx]
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { type ReactNode, useState } from 'react'
import { type State, WagmiProvider } from 'wagmi'

import { getConfig } from './config'

type Props = {
  children: ReactNode,
  initialState: State | undefined, // [!code ++]
}

export function Providers({ children }: Props) {  // [!code --]
export function Providers({ children, initialState }: Props) {  // [!code ++]
  const [config] = useState(() => getConfig())
  const [queryClient] = useState(() => new QueryClient())

  return (
    <WagmiProvider config={config}> // [!code --]
    <WagmiProvider config={config} initialState={initialState}> // [!code ++]
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </WagmiProvider>
  )
}

```

```tsx [app/config.ts]
import { 
  createConfig, 
  http, 
  cookieStorage,
  createStorage 
} from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

export function getConfig() {
  return createConfig({
    chains: [mainnet, sepolia],
    ssr: true,
    storage: createStorage({  // [!code ++]
      storage: cookieStorage, // [!code ++]
    }),  // [!code ++]
    transports: {
      [mainnet.id]: http(),
      [sepolia.id]: http(),
    },
  })
}
```
:::

#### Next.js Pages Directory

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!
<!-- TODO -->

#### Vanilla SSR

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!
<!-- TODO -->
</file>

<file path="site/react/guides/tanstack-query.md">
# TanStack Query

Wagmi Hooks are not only a wrapper around the core [Wagmi Actions](/core/api/actions), but they also utilize [TanStack Query](https://tanstack.com/query/v5) to enable trivial and intuitive fetching, caching, synchronizing, and updating of asynchronous data in your React applications.

Without an asynchronous data fetching abstraction, you would need to handle all the negative side-effects that comes as a result, such as: representing finite states (loading, error, success), handling race conditions, caching against a deterministic identifier, etc.

## Queries & Mutations

Wagmi Hooks represent either a **Query** or a **Mutation**. 

**Queries** are used for fetching data (e.g. fetching a block number, reading from a contract, etc), and are typically invoked on mount by default. All queries are coupled to a unique [Query Key](#query-keys), and can be used for further operations such as refetching, prefetching, or modifying the cached data.

**Mutations** are used for mutating data (e.g. connecting/disconnecting accounts, writing to a contract, switching chains, etc), and are typically invoked in response to a user interaction. Unlike **Queries**, they are not coupled with a query key.

## Terms

- **Query**: An asynchronous data fetching (e.g. read data) operation that is tied against a unique Query Key.
- **Mutation**: An asynchronous mutating (e.g. create/update/delete data or side-effect) operation.
- **Query Key**: A unique identifier that is used to deterministically identify a query. It is typically a tuple of the query name and the query arguments.
- **Stale Data**: Data that is unused or inactive after a certain period of time.
- **Query Fetching**: The process of invoking an async query function.
- **Query Refetching**: The process of refetching **rendered** queries.
- **[Query Invalidation](https://tanstack.com/query/v5/docs/react/guides/query-invalidation)**: The process of marking query data as stale (e.g. inactive/unused), and refetching **rendered** queries.
- **[Query Prefetching](https://tanstack.com/query/v5/docs/react/guides/prefetching)**: The process of prefetching queries and seeding the cache.

## Persistence via External Stores

By default, TanStack Query persists all query data in-memory. This means that if you refresh the page, all in-memory query data will be lost. 

If you want to persist query data to an external storage, you can utilize TanStack Query's [`createSyncStoragePersister`](https://tanstack.com/query/v5/docs/react/plugins/createSyncStoragePersister) or [`createAsyncStoragePersister`](https://tanstack.com/query/v5/docs/react/plugins/createAsyncStoragePersister) to plug external storage like `localStorage`, `sessionStorage`, [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or [`AsyncStorage`](https://reactnative.dev/docs/asyncstorage) (React Native).

### Sync Storage

Below is an example of how to set up Wagmi + TanStack Query with sync external storage like `localStorage` or `sessionStorage`.

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

```bash [npm]
npm i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

```bash [yarn]
yarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

```bash [bun]
bun i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```
:::

#### Usage

```tsx
// 1. Import modules. // [!code hl]
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister' // [!code hl]
import { QueryClient } from '@tanstack/react-query' // [!code hl]
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client' // [!code hl]
import { WagmiProvider, deserialize, serialize } from 'wagmi' // [!code hl]

// 2. Create a new Query Client with a default `gcTime`. // [!code hl]
const queryClient = new QueryClient({ // [!code hl]
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      gcTime: 1_000 * 60 * 60 * 24, // 24 hours // [!code hl]
    }, // [!code hl] 
  }, // [!code hl]
}) // [!code hl]

// 3. Set up the persister. // [!code hl]
const persister = createSyncStoragePersister({ // [!code hl]
  serialize, // [!code hl]
  storage: window.localStorage, // [!code hl]
  deserialize, // [!code hl]
}) // [!code hl]

function App() {
  return (
    <WagmiProvider config={config}>
      {/* 4. Wrap app in PersistQueryClientProvider */} // [!code hl]
      <PersistQueryClientProvider // [!code hl]
        client={queryClient} // [!code hl]
        persistOptions={{ persister }} // [!code hl]
      > // [!code hl]
        {/* ... */}
      </PersistQueryClientProvider> // [!code hl]
    </WagmiProvider>
  )
}
```

Read more about [Sync Storage Persistence](https://tanstack.com/query/v5/docs/react/plugins/createSyncStoragePersister).

### Async Storage

Below is an example of how to set up Wagmi + TanStack Query with async external storage like [`IndexedDB`](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or [`AsyncStorage`](https://reactnative.dev/docs/asyncstorage).

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

```bash [npm]
npm i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

```bash [yarn]
yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

```bash [bun]
bun i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```
:::

#### Usage

```tsx
// 1. Import modules. // [!code hl]
import AsyncStorage from '@react-native-async-storage/async-storage' // [!code hl]
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister' // [!code hl]
import { QueryClient } from '@tanstack/react-query' // [!code hl]
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client' // [!code hl]
import { WagmiProvider, deserialize, serialize } from 'wagmi' // [!code hl]

// 2. Create a new Query Client with a default `gcTime`. // [!code hl]
const queryClient = new QueryClient({ // [!code hl]
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      gcTime: 1_000 * 60 * 60 * 24, // 24 hours // [!code hl]
    }, // [!code hl] 
  }, // [!code hl]
}) // [!code hl]

// 3. Set up the persister. // [!code hl]
const persister = createAsyncStoragePersister({ // [!code hl]
  serialize, // [!code hl]
  storage: AsyncStorage, // [!code hl]
  deserialize, // [!code hl]
}) // [!code hl]

function App() {
  return (
    <WagmiProvider config={config}>
      {/* 4. Wrap app in PersistQueryClientProvider */} // [!code hl]
      <PersistQueryClientProvider // [!code hl]
        client={queryClient} // [!code hl]
        persistOptions={{ persister }} // [!code hl]
      > // [!code hl]
        {/* ... */}
      </PersistQueryClientProvider> // [!code hl]
    </WagmiProvider>
  )
}
```

Read more about [Async Storage Persistence](https://tanstack.com/query/v5/docs/react/plugins/createAsyncStoragePersister).

## Query Keys

Query Keys are typically used to perform advanced operations on the query such as: invalidation, refetching, prefetching, etc. 

Wagmi exports Query Keys for every Hook, and they can be retrieved via the [Hook (React)](#hook-react) or via an [Import (Vanilla JS)](#import-vanilla-js).

Read more about **Query Keys** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/query-keys)

### Hook (React)

Each Hook returns a `queryKey` value. You would use this approach when you want to utilize the query key in a React component as it handles reactivity for you, unlike the [Import](#import-vanilla-js) method below.

```ts 
import { useBlock } from 'wagmi' // [!code hl]

function App() {
  const { queryKey } = useBlock() // [!code hl]
}
```

### Import (Vanilla JS)

Each Hook has a corresponding `get<X>QueryOptions` function that returns a query key. You would use this method when you want to utilize the query key outside of a React component in a Vanilla JS context, like in a utility function. 

```ts 
import { getBlockQueryOptions } from 'wagmi/query' // [!code hl]
import { config } from './config'

function perform() {
  const { queryKey } = getBlockQueryOptions(config, { // [!code hl]
    chainId: config.state.chainId // [!code hl]
  }) // [!code hl]
}
```

::: warning

The caveat of this method is that it does not handle reactivity for you (e.g. active account/chain changes, argument changes, etc). You would need to handle this yourself by explicitly passing through the arguments to `get<X>QueryOptions`.

:::

## Invalidating Queries

Invalidating a query is the process of marking the query data as stale (e.g. inactive/unused), and refetching the queries that are already rendered.

Read more about **Invalidating Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/query-invalidation)

#### Example: Watching a Users' Balance

You may want to "watch" a users' balance, and invalidate the balance after each incoming block. We can invoke `invalidateQueries` inside a `useEffect` with the block number as it's only dependency ‚Äì this will refetch all rendered balance queries when the `blockNumber` changes.

```tsx
import { useQueryClient } from '@tanstack/react-query' 
import { useEffect } from 'react' 
import { useBlockNumber, useBalance } from 'wagmi' 

function App() {
  const queryClient = useQueryClient()
  const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code hl]
  const { data: balance, queryKey } = useBalance() // [!code hl]
  
  useEffect(() => { // [!code hl]
    queryClient.invalidateQueries({ queryKey }) // [!code hl]
  }, [blockNumber]) // [!code hl]

  return <div>{balance}</div>
}
```

#### Example: After User Interaction

Maybe you want to invalidate a users' balance after some interaction. This would mark the balance as stale, and consequently refetch all rendered balance queries.

```tsx
import { useBalance } from 'wagmi'

function App() {
  // 1. Extract `queryKey` from the useBalance Hook. // [!code hl]
  const { queryKey } = useBalance() // [!code hl]

  return (
    <button
      onClick={async () => {
        // 2. Invalidate the query when the user clicks "Invalidate". // [!code hl]
        await queryClient.invalidateQueries({ queryKey }) // [!code hl]
      }}
    >
      Invalidate
    </button>
  )
}

function Example() {
  // 3. Other `useBalance` Hooks in your rendered React tree will be refetched! // [!code hl]
  const { data: balance } = useBalance() // [!code hl]

  return <div>{balance}</div>
}
```

## Fetching Queries

Fetching a query is the process of invoking the query function to retrieve data. If the query exists and the data is not invalidated or older than a given `staleTime`, then the data from the cache will be returned. Otherwise, the query will fetch for the latest data.

::: code-group
```tsx [example.tsx]
import { getBlockQueryOptions } from 'wagmi'
import { queryClient } from './app'
import { config } from './config'

export async function fetchBlockData() {
  return queryClient.fetchQuery( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
    } // [!code hl]
  )) // [!code hl]
}
```
<<< @/snippets/react/app.tsx[app.tsx]
<<< @/snippets/react/config.ts[config.ts]
:::

## Retrieving & Updating Query Data

You can retrieve and update query data imperatively with `getQueryData` and `setQueryData`. This is useful for scenarios where you want to retrieve or update a query outside of a React component.

Note that these functions do not invalidate or refetch queries.

::: code-group
```tsx [example.tsx]
import { getBlockQueryOptions } from 'wagmi'
import type { Block } from 'viem'
import { queryClient } from './app'
import { config } from './config'

export function getPendingBlockData() {
  return queryClient.getQueryData( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
      tag: 'pending' // [!code hl]
    } // [!code hl]
  )) // [!code hl]
}

export function setPendingBlockData(data: Block) {
  return queryClient.setQueryData( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
      tag: 'pending' // [!code hl]
    }, // [!code hl]
    data // [!code hl]
  )) // [!code hl]
}
```
<<< @/snippets/react/app.tsx[app.tsx]
<<< @/snippets/react/config.ts[config.ts]
:::

## Prefetching Queries

Prefetching a query is the process of fetching the data ahead of time and seeding the cache with the returned data. This is useful for scenarios where you want to fetch data before the user navigates to a page, or fetching data on the server to be reused on client hydration.

Read more about **Prefetching Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/prefetching)

#### Example: Prefetching in Event Handler

```tsx
import { Link } from 'next/link'
import { getBlockQueryOptions } from 'wagmi'

function App() {
  const config = useConfig()
  const chainId = useChainId()

  // 1. Set up a function to prefetch the block data. // [!code hl]
  const prefetch = () => // [!code hl]
    queryClient.prefetchQuery(getBlockQueryOptions(config, { chainId })) // [!code hl]
  

  return (
    <Link
      // 2. Add event handlers to prefetch the block data // [!code hl] 
      // when user hovers over or focuses on the button. // [!code hl]
      onMouseEnter={prefetch} // [!code hl]
      onFocus={prefetch} // [!code hl]
      to="/block-details"
    >
      Block details
    </Link>
  )
}
```

## SSR

It is possible to utilize TanStack Query's SSR strategies with Wagmi Hooks & Query Keys. Check out the [Server Rendering & Hydration](https://tanstack.com/query/v5/docs/react/guides/ssr) & [Advanced Server Rendering](https://tanstack.com/query/v5/docs/react/guides/advanced-ssr) guides.

## Devtools

TanStack Query includes dedicated [Devtools](https://tanstack.com/query/latest/docs/framework/react/devtools) that assist in visualizing and debugging your queries, their cache states, and much more. You will have to pass a custom `queryKeyFn` to your `QueryClient` for Devtools to correctly serialize BigInt values for display. Alternatively, You can use the `hashFn` from `@wagmi/core/query`, which already handles this serialization.

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/react-query-devtools
```

```bash [npm]
npm i @tanstack/react-query-devtools
```

```bash [yarn]
yarn add @tanstack/react-query-devtools
```

```bash [bun]
bun i @tanstack/react-query-devtools
```
:::

#### Usage

```tsx
import {
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools"; // [!code hl]
import { hashFn } from "@wagmi/core/query"; // [!code hl]

const queryClient = new QueryClient({
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      queryKeyHashFn: hashFn, // [!code hl]
    }, // [!code hl]
  }, // [!code hl]
});
```
</file>

<file path="site/react/guides/testing.md">
# Testing
</file>

<file path="site/react/guides/viem.md">
# Viem

[Viem](https://viem.sh) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](/react/api/createConfig) and automatic account management via [Connectors](/react/api/connectors).

## Leveraging Viem Actions

All of the core [Wagmi Hooks](/react/api/actions) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](/react/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe a Hook doesn't exist in Wagmi yet). In these cases, you can create your own custom Wagmi Hook by importing Viem Actions directly via `viem/actions` and plugging in a Viem Client returned by the [`useClient` Hook](/react/api/hooks/useClient).

The example below demonstrates two different ways to utilize Viem Actions:

1. **Tree-shakable Actions (recommended):** Uses `useClient` (for public actions) and `useConnectorClient` (for wallet actions).
2. **Client Actions:** Uses `usePublicClient` (for public actions) and  `useWalletClient` (for wallet actions).

::: tip

It is highly recommended to use the **tree-shakable** method to ensure that you are only pulling modules you use, and keep your bundle size low.

:::

::: code-group

```tsx [Tree-shakable Actions]
// 1. Import modules. 
import { useMutation, useQuery } from '@tanstack/react-query'
import { http, createConfig, useClient, useConnectorClient } from 'wagmi' 
import { base, mainnet, optimism, zora } from 'wagmi/chains' 
import { getLogs, watchAsset } from 'viem/actions'

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

function Example() {
  // 3. Extract a Viem Client for the current active chain. // [!code hl]
  const publicClient = useClient({ config }) // [!code hl]

  // 4. Create a "custom" Query Hook that utilizes the Client. // [!code hl]
  const { data: logs } = useQuery({ // [!code hl]
    queryKey: ['logs', publicClient.uid], // [!code hl]
    queryFn: () => getLogs(publicClient, /* ... */) // [!code hl]
  }) // [!code hl]
  
  // 5. Extract a Viem Client for the current active chain & account. // [!code hl]
  const { data: walletClient } = useConnectorClient({ config }) // [!code hl]

  // 6. Create a "custom" Mutation Hook that utilizes the Client. // [!code hl]
  const { mutate } = useMutation({ // [!code hl]
    mutationFn: (asset) => watchAsset(walletClient, asset) // [!code hl]
  }) // [!code hl]

  return (
    <div>
      {/* ... */}
    </div>
  )
}
```

```tsx [Client Actions]
// 1. Import modules. 
import { useMutation, useQuery } from '@tanstack/react-query'
import { http, createConfig, useClient, useConnectorClient } from 'wagmi' 
import { base, mainnet, optimism, zora } from 'wagmi/chains' 

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

function Example() {
  // 3. Extract a Viem Client for the current active chain. // [!code hl]
  const publicClient = useClient({ config }) // [!code hl]

  // 4. Create a "custom" Query Hook that utilizes the Client. // [!code hl]
  const { data: logs } = useQuery({ // [!code hl]
    queryKey: ['logs', publicClient.uid], // [!code hl]
    queryFn: () => publicClient.getLogs(/* ... */) // [!code hl]
  }) // [!code hl]
  
  // 5. Extract a Viem Client for the current active chain & account. // [!code hl]
  const { data: walletClient } = useConnectorClient({ config }) // [!code hl]

  // 6. Create a "custom" Mutation Hook that utilizes the Client. // [!code hl]
  const { mutate } = useMutation({ // [!code hl]
    mutationFn: (asset) => walletClient.watchAsset(asset) // [!code hl]
  }) // [!code hl]

  return (
    <div>
      {/* ... */}
    </div>
  )
}
```

:::

## Private Key & Mnemonic Accounts

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

```tsx
import { http, createConfig, useSendTransaction } from 'wagmi' 
import { base, mainnet, optimism, zora } from 'wagmi/chains' 
import { parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

const account = privateKeyToAccount('0x...') // [!code hl]

function Example() {
  const { data: hash } = useSendTransaction({
    account, // [!code hl]
    to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    value: parseEther('0.001')
  })
}
```

::: info

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config ‚Äì meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open an discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).

:::
</file>

<file path="site/react/guides/write-to-contract.md">
# Write to Contract

The [`useWriteContract` Hook](/react/api/hooks/useWriteContract) allows you to mutate data on a smart contract, from a `payable` or `nonpayable` (write) function. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

In the guide below, we will teach you how to implement a "Mint NFT" form that takes in a dynamic argument (token ID) using Wagmi. The example below builds on the [Connect Wallet guide](/react/guides/connect-wallet) and uses the [useWriteContract](/react/api/hooks/useWriteContract) & [useWaitForTransaction](/react/api/hooks/useWaitForTransactionReceipt) hooks. 

If you have already completed the [Sending Transactions guide](/react/guides/send-transaction), this guide will look very similar! That's because writing to a contract internally broadcasts & sends a transaction.

## Example

Feel free to check out the example before moving on:

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-f5uwlm?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>

## Steps

### 1. Connect Wallet

Follow the [Connect Wallet guide](/react/guides/connect-wallet) guide to get this set up.

### 2. Create a new component

Create your `MintNFT` component that will contain the Mint NFT logic.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
 
export function MintNFT() {
  return (
    <form>
      <input name="tokenId" placeholder="69420" required />
      <button type="submit">Mint</button>
    </form>
  )
}
```

:::

### 3. Add a form handler

Next, we will need to add a handler to the form that will send the transaction when the user hits "Mint". This will be a basic handler in this step.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
 
export function MintNFT() {
  async function submit(e: React.FormEvent<HTMLFormElement>) { // [!code ++]
    e.preventDefault() // [!code ++]
    const formData = new FormData(e.target as HTMLFormElement) // [!code ++]
    const tokenId = formData.get('tokenId') as string // [!code ++]
  } // [!code ++]

  return (
    <form> // [!code --]
    <form onSubmit={submit}> // [!code ++]
      <input name="tokenId" placeholder="69420" required />
      <button type="submit">Mint</button>
    </form>
  )
}
```

:::

### 4. Hook up the `useWriteContract` Hook

Now that we have the form handler, we can hook up the [`useWriteContract` Hook](/react/api/hooks/useWriteContract) to send the transaction.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { useWriteContract } from 'wagmi' // [!code ++]
import { abi } from './abi' // [!code ++]
 
export function MintNFT() {
  const { data: hash, writeContract } = useWriteContract() // [!code ++]

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({ // [!code ++]
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code ++]
      abi, // [!code ++]
      functionName: 'mint', // [!code ++]
      args: [BigInt(tokenId)], // [!code ++]
    }) // [!code ++]
  } 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button type="submit">Mint</button>
      {hash && <div>Transaction Hash: {hash}</div>} // [!code ++]
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 5. Add loading state (optional)

We can optionally add a loading state to the "Mint" button while we are waiting confirmation from the user's wallet.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { useWriteContract } from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash, 
    isPending, // [!code ++]
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} // [!code ++]
        type="submit"
      >
        Mint // [!code --]
        {isPending ? 'Confirming...' : 'Mint'} // [!code ++]
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 6. Wait for transaction receipt (optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Hook](/react/api/hooks/useWaitForTransactionReceipt). 

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { 
  useWaitForTransactionReceipt, // [!code ++]
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash, 
    isPending, 
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = // [!code ++]
    useWaitForTransactionReceipt({ // [!code ++]
      hash, // [!code ++]
    }) // [!code ++]

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Mint'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && <div>Waiting for confirmation...</div>} // [!code ++]
      {isConfirmed && <div>Transaction confirmed.</div>} // [!code ++]
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 7. Handle errors (optional)

If the user rejects the transaction, or the contract reverts, we can display an error message to the user.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { 
  type BaseError, // [!code ++]
  useWaitForTransactionReceipt, 
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash,
    error, // [!code ++]  
    isPending, 
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Mint'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( // [!code ++]
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> // [!code ++]
      )} // [!code ++]
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 8. Wire it up!

Finally, we can wire up our Mint NFT component to our application's entrypoint.

::: code-group

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from './config'
import { MintNft } from './mint-nft' // [!code ++]

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        <MintNft /> // [!code ++]
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [mint-nft.tsx]
import * as React from 'react'
import { 
  type BaseError, 
  useWaitForTransactionReceipt, 
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash,
    error,   
    isPending, 
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Mint'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( 
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> 
      )} 
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

[See the Example.](#example)
</file>

<file path="site/react/comparisons.md">
# Comparison

There are multiple options when it comes to React libraries for Ethereum that help manage wallet connections, provide utility methods/hooks, etc.

::: tip
Comparisons strive to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes.
:::

## Overview

|                      | [wagmi](https://github.com/wagmi-dev/wagmi)                                                     | [web3-react](https://github.com/NoahZinsmeister/web3-react)                                             | [useDApp](https://github.com/EthWorks/useDApp)                                                     |
| -------------------- | :---------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------- |
| GitHub Stars         | ![wagmi star count](https://img.shields.io/github/stars/wagmi-dev/wagmi?colorB=27292E&label=)   | ![web3-react star count](https://img.shields.io/github/stars/Uniswap/web3-react?colorB=27292E&label=)   | ![useDApp star count](https://img.shields.io/github/stars/EthWorks/useDApp?colorB=27292E&label=)   |
| Open Issues          | ![wagmi issue count](https://img.shields.io/github/issues/wagmi-dev/wagmi?colorB=27292E&label=) | ![web3-react issue count](https://img.shields.io/github/issues/Uniswap/web3-react?colorB=27292E&label=) | ![useDApp issue count](https://img.shields.io/github/issues/EthWorks/useDApp?colorB=27292E&label=) |
| Downloads            | ![wagmi downloads](https://img.shields.io/npm/dw/wagmi?colorB=27292E&label=)                    | ![web3-react downloads](https://img.shields.io/npm/dw/@web3-react/core?colorB=27292E&label=)            | ![useDApp downloads](https://img.shields.io/npm/dw/@usedapp/core?colorB=27292E&label=)             |
| License              | ![wagmi license](https://img.shields.io/github/license/wagmi-dev/wagmi?colorB=27292E&label=)    | ![web3-react license](https://img.shields.io/github/license/Uniswap/web3-react?colorB=27292E&label=)    | ![useDApp license](https://img.shields.io/github/license/EthWorks/useDApp?colorB=27292E&label=)    |
| Their Comparison     | ‚Äì                                                                                               | none                                                                                                    | none                                                                                               |
| Supported Frameworks | React, Vanilla JS                                                                               | React                                                                                                   | React                                                                                              |
| Documentation        | ‚úÖ                                                                                              | üõë                                                                                                      | ‚úÖ                                                                                                 |
| TypeScript           | ‚úÖ                                                                                              | üî∂                                                                                                      | üî∂                                                                                                 |
| EIP-6963 Support     | ‚úÖ                                                                                              | üî¥                                                                                                      | üî¥                                                                                                 |
| Test Suite           | ‚úÖ                                                                                              | üî∂                                                                                                      | üî∂                                                                                                 |
| Examples             | ‚úÖ                                                                                              | üî∂                                                                                                      | ‚úÖ                                                                                                 |

::: details Comparison Key

1. Documentation
  - Comprehensive documentation for all library features ‚úÖ
  - No documentation üî¥
2. Typescript
  - Infer types from ABIs, EIP-712 Typed Data, etc. ‚úÖ
  - Can add types with explicit generics, type annotations, etc. üî∂
3. Test Suite
  - Runs against forked Ethereum network(s) ‚úÖ
  - Mocking functionality (i.e. RPC calls) is üî∂
4. EIP-6963 Support
  - Fully compatible with EIP-6963 ‚úÖ
  - Not compatible with EIP-6963 üî¥
5. Examples
  - Has multiple examples ‚úÖ
  - Has single example üî∂
:::

## [Wagmi](https://github.com/wagmi-dev/wagmi)

### Pros

- 20+ hooks for working with wallets, ENS, contracts, transactions, signing, etc.
- Built-in wallet connectors for injected providers (EIP-6963 support), WalletConnect, MetaMask, Coinbase Wallet
- Caching, request deduplication, and persistence powered by TanStack Query
- Auto-refresh data on wallet, block, and network changes
- Multicall support
- Test suite running against forked Ethereum networks
- TypeScript ready (infer types from ABIs and EIP-712 Typed Data)
- Extensive documentation and examples
- Used by Coinbase, Stripe, Shopify, Uniswap, Optimism, ENS, Sushi, and [many more](https://github.com/wagmi-dev/wagmi/discussions/201)
- MIT License

### Cons

- Not as many built-in connectors as `web3-react`

## [web3-react](https://github.com/Uniswap/web3-react)

### Pros

- Supports many different connectors (conceptually similar to Wagmi's connectors)
- Basic hooks for managing account

### Cons

- Need to set up connectors and method for connecting wallet on your own
- Need to install connectors separately
- Almost no tests or documentation; infrequent updates
- GPL-3.0 License

## [useDApp](https://github.com/EthWorks/useDApp)

### Pros

- Auto-refresh on new blocks and wallet changes
- Multicall support
- Transaction notifications
- Chrome extension and Firefox add-on
- MIT License

### Cons

- Non-standard hook API
</file>

<file path="site/react/getting-started.md">
<script setup>
import packageJson from '../../packages/react/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Getting Started

## Overview

Wagmi is a React Hooks library for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](/react/why) section.

## Automatic Installation

For new projects, it is recommended to set up your Wagmi app using the [`create-wagmi`](/cli/create-wagmi) command line interface (CLI). This will create a new Wagmi project using TypeScript and install the required dependencies.

::: code-group
```bash [pnpm]
pnpm create wagmi
```

```bash [npm]
npm create wagmi@latest
```

```bash [yarn]
yarn create wagmi
```

```bash [bun]
bun create wagmi
```
:::

Once the command runs, you'll see some prompts to complete.

```ansi
Project name: wagmi-project
Select a framework: React / Vanilla
...
```

After the prompts, `create-wagmi` will create a directory with your project name and install the required dependencies. Check out the `README.md` for further instructions (if required).

## Manual Installation

To manually add Wagmi to your project, install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [npm]
npm install wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [yarn]
yarn add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [bun]
bun add wagmi viem@{{viemVersion}} @tanstack/react-query
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
- [TypeScript](/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/react/typescript).

### Create Config

Create and export a new Wagmi config using `createConfig`.

::: code-group
<<< @/snippets/react/config.ts[config.ts]
:::

In this example, Wagmi is configured to use the Mainnet and Sepolia chains, and `injected` connector. Check out the [`createConfig` docs](/react/api/createConfig) for more configuration options.


::: details TypeScript Tip
If you are using TypeScript, you can "register" the Wagmi config or use the hook `config` property to get strong type-safety across React Context in places that wouldn't normally have type info.

::: code-group
```ts twoslash [register config]
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare const config: Config<readonly [typeof mainnet, typeof sepolia]>
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123 })

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
```

```ts twoslash [hook config property]
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare const config: Config<readonly [typeof mainnet, typeof sepolia]>
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123, config })
```

By registering or using the hook `config` property, `useBlockNumber`'s `chainId` is strongly typed to only allow Mainnet and Sepolia IDs. Learn more by reading the [TypeScript docs](/react/typescript#config-types).
:::

### Wrap App in Context Provider

Wrap your app in the `WagmiProvider` React Context Provider and pass the `config` you created earlier to the `value` property.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi' // [!code focus]
import { config } from './config' // [!code focus]

function App() {
  return (
    <WagmiProvider config={config}> // [!code focus]
      {/** ... */} // [!code focus]
    </WagmiProvider> // [!code focus]
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

Check out the [`WagmiProvider` docs](/react/api/WagmiProvider) to learn more about React Context in Wagmi.

### Setup TanStack Query

Inside the `WagmiProvider`, wrap your app in a TanStack Query React Context Provider, e.g. `QueryClientProvider`, and pass a new `QueryClient` instance to the `client` property.

::: code-group
```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query' // [!code focus]
import { WagmiProvider } from 'wagmi'
import { config } from './config'

const queryClient = new QueryClient() // [!code focus]

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> // [!code focus]
        {/** ... */} // [!code focus]
      </QueryClientProvider> // [!code focus]
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

Check out the [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/react) to learn about the library, APIs, and more.

### Use Wagmi

Now that everything is set up, every component inside the Wagmi and TanStack Query Providers can use Wagmi React Hooks.

::: code-group
```tsx [profile.tsx]
import { useAccount, useEnsName } from 'wagmi'

export function Profile() {
  const { address } = useAccount()
  const { data, error, status } = useEnsName({ address })
  if (status === 'pending') return <div>Loading ENS name</div>
  if (status === 'error')
    return <div>Error fetching ENS name: {error.message}</div>
  return <div>ENS name: {data}</div>
}
```

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'
import { Profile } from './profile'

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <Profile />
      </QueryClientProvider>
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Next Steps

For more information on what to do next, check out the following topics.

- [**TypeScript**](/react/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
- [**Connect Wallet**](/react/guides/connect-wallet) Learn how to enable wallets to connect to and disconnect from your apps and display information about connected accounts.
- [**React Hooks**](/react/api/hooks) Browse the collection of React Hooks and learn how to use them.
- [**Viem**](/react/guides/viem) Learn about Viem and how it works with Wagmi.
</file>

<file path="site/react/installation.md">
<script setup>
import packageJson from '../../packages/react/package.json'
import Browsers from '../components/Browsers.vue'

const docsPath = 'react'
const packageDir = 'react'
const packageName = 'wagmi'
const viemVersion = packageJson.peerDependencies.viem
</script>

# Installation

Install Wagmi via your package manager, a `<script>` tag, or build from source.

## Package Manager

Install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [npm]
npm install wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [yarn]
yarn add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [bun]
bun add wagmi viem@{{viemVersion}} @tanstack/react-query
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
- [TypeScript](/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/react/typescript).

## CDN

If you're not using a package manager, you can also use Wagmi via an ESM-compatible CDN such as [esm.sh](https://esm.sh). Simply add a `<script type="module">` tag to the bottom of your HTML file with the following content.

```html-vue
<script type="module">
  import React from 'https://esm.sh/react@18.2.0'
  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
  import { createClient } from 'https://esm.sh/viem@{{viemVersion}}'
  import { createConfig } from 'https://esm.sh/wagmi'
</script>
```

Check out the React docs for info on how to use [React without JSX](https://react.dev/reference/react/createElement#creating-an-element-without-jsx).

<!--@include: @shared/installation.md-->
</file>

<file path="site/react/typescript.md">
<script setup>
import packageJson from '../../packages/react/package.json'

const typescriptVersion = packageJson.peerDependencies.typescript
</script>

# TypeScript

## Requirements

Wagmi is designed to be as type-safe as possible! Things to keep in mind:

- Types currently require using TypeScript {{typescriptVersion}}.
- [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
- Changes to types in this repository are considered non-breaking and are usually released as patch changes (otherwise every type enhancement would be a major version!).
- It is highly recommended that you lock your `wagmi` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
- The non-type-related public API of Wagmi still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

::: code-group
```json [tsconfig.json]
{
  "compilerOptions": {
    "strict": true
  }
}
```
:::

## Config Types

By default React Context does not work well with type inference. To support strong type-safety across the React Context boundary, there are two options available:

- Declaration merging to "register" your `config` globally with TypeScript.
- `config` property to pass your `config` directly to hooks.

### Declaration Merging

[Declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) allows you to "register" your `config` globally with TypeScript. The `Register` type enables Wagmi to infer types in places that wouldn't normally have access to type info via React Context alone. 

To set this up, add the following declaration to your project. Below, we co-locate the declaration merging and the `config` set up.

```ts
import { createConfig, http } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' { // [!code focus]
  interface Register { // [!code focus]
    config: typeof config // [!code focus]
  } // [!code focus]
} // [!code focus]

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

Since the `Register` type is global, you only need to add it once in your project. Once set up, you will get strong type-safety across your entire project. For example, query hooks will type `chainId` based on your `config`'s `chains`. 

```ts twoslash
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' {
  interface Register {
    config: Config<readonly [typeof mainnet, typeof sepolia]>
  }
}
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123 })
```

You just saved yourself a runtime error and you didn't even need to pass your `config`. üéâ

### Hook `config` Property

For cases where you have more than one Wagmi `config` or don't want to use the declaration merging approach, you can pass a specific `config` directly to hooks via the `config` property.

```ts
import { createConfig, http } from 'wagmi'
import { mainnet, optimism } from 'wagmi/chains'

export const configA = createConfig({ // [!code focus]
  chains: [mainnet], // [!code focus]
  transports: { // [!code focus]
    [mainnet.id]: http(), // [!code focus]
  }, // [!code focus]
}) // [!code focus]

export const configB = createConfig({ // [!code focus]
  chains: [optimism], // [!code focus]
  transports: { // [!code focus]
    [optimism.id]: http(), // [!code focus]
  }, // [!code focus]
}) // [!code focus]
```

As you expect, `chainId` is inferred correctly for each `config`.

```ts twoslash
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, optimism } from 'wagmi/chains'

declare const configA: Config<readonly [typeof mainnet]>
declare const configB: Config<readonly [typeof optimism]>
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123, config: configA })
useBlockNumber({ chainId: 123, config: configB })
```

This approach is more explicit, but works well for advanced use-cases, if you don't want to use React Context or declaration merging, etc.

## Const-Assert ABIs & Typed Data

Wagmi can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

```ts
const { data } = useReadContract({
  abi: [‚Ä¶], // <--- defined inline // [!code focus]
})
```

```ts
const abi = [‚Ä¶] as const // <--- const assertion // [!code focus]
const { data } = useReadContract({ abi })
```

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

::: tip
Unfortunately [TypeScript doesn't support importing JSON `as const` yet](https://github.com/microsoft/TypeScript/issues/32063). Check out the [Wagmi CLI](/cli/getting-started) to help with this! It can automatically fetch ABIs from Etherscan and other block explorers, resolve ABIs from your Foundry/Hardhat projects, generate React Hooks, and more.
:::

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`useReadContract`](/react/api/hooks/useReadContract) looks like with and without a const-asserted `abi` property.

::: code-group
```ts twoslash [Const-Asserted]
const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { useReadContract } from 'wagmi'

const { data } = useReadContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

data
// ^?
```
```ts twoslash [Not Const-Asserted]
declare const erc721Abi: {
  name: string;
  type: string;
  stateMutability: string;
  inputs: {
    type: string;
    name: string;
  }[];
  outputs: {
    type: string;
  }[];
}[]
// ---cut---
import { useReadContract } from 'wagmi'

const { data } = useReadContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

data
// ^?
```
:::

<br/>
<br/>

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. üéâ

```ts twoslash
// @errors: 2820
const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { useReadContract } from 'wagmi'

useReadContract({
  abi: erc721Abi,
  functionName: 'balanecOf',
})
```

## Configure Internal Types

For advanced use-cases, you may want to configure Wagmi's internal types. Most of Wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev) for more info on how to configure types.
</file>

<file path="site/react/why.md">
# Why Wagmi

## The Problems

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi solves all these problems and more ‚Äî allowing app developers to focus on building high-quality and performant experiences for Ethereum ‚Äî by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

## Developer Experience

Wagmi delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi's APIs might seem more verbose at first, it makes Wagmi's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi is a great way to learn how to interact with Ethereum in general.

Wagmi also provides [strongly typed APIs](/react/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](/react/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20(TDD),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

## Performance

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi uses and is built by the same team behind [Viem](https://viem.sh), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times. 

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi supports caching, deduplication, persistence, and much more through [TanStack Query](/react/guides/tanstack-query).

## Feature Coverage

Wagmi supports the most popular and commonly-used Ethereum features out of the box with 40+ React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi also supports just about any wallet out there through official [connectors](/react/api/connectors), [EIP-6963 support](/react/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Wagmi Core](/core/getting-started) or [Viem](https://viem.sh), which Wagmi uses internally to perform blockchain operations. Wagmi also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi has a [CLI](/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz), [Privy](https://privy.io), and many more, so you can get started quickly without needing to build everything from scratch.

## Stability

Stability is a fundamental principle for Wagmi. Many organizations, large and small, rely heavily on Wagmi and expect it to be entirely stable for their users and applications.

Wagmi's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi follows semver so developers can upgrade between versions with confidence. Starting with Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi and [related projects](https://github.com/wevm), and is constantly improving Wagmi and keeping it up-to-date with industry trends and changes.
</file>

<file path="site/shared/connectors/coinbaseWallet.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# coinbaseWallet

Connector for the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk).

## Import

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { coinbaseWallet } from '{{connectorsPackageName}}' // [!code hl]

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [coinbaseWallet()], // [!code hl]
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

:::warning
Before going to production, it is highly recommended to set an [`appName`](#appname) and [`appLogoUrl`](#applogourl) for your application that can be displayed upon connection to the wallet.
:::

## Parameters

```ts-vue
import { type CoinbaseWalletParameters } from '{{connectorsPackageName}}'
```

Check out the [Coinbase Wallet SDK docs](https://github.com/coinbase/coinbase-wallet-sdk) for more info.

### appName

`string`

Application name.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App', // [!code focus]
})
```

### appLogoUrl

`string | null | undefined`

Application logo image URL; favicon is used if unspecified.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  appLogoUrl: 'https://example.com/myLogoUrl.png', // [!code focus]
})
```

### headlessMode <Badge type="warning" text="deprecated" />

`boolean | undefined`

- Whether or not onboarding overlay popup should be displayed.
- `headlessMode` will be removed in the next major version. Upgrade to [`version: '4'`](#version).

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  headlessMode: false, // [!code focus]
})
```

### preference <Badge text=">=2.9.0" />

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

- `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
- `'smartWalletOnly'`: Displays Smart Wallet popup.
- `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  preference: 'smartWalletOnly', // [!code focus]
})
```

::: warning
Passing `preference` as a string is deprecated and will be removed in the next major version. Instead you should use [`preference#options`](#options).
:::

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  preference: { // [!code focus]
    options: 'smartWalletOnly' // [!code focus]
  }, // [!code focus]
})
```

#### attribution <Badge text=">=2.12.33" />

`` { auto?: boolean | undefined; dataSuffix?: `0x${string}` | undefined } ``

This option only applies to Coinbase Smart Wallet. When a valid data suffix is supplied, it is appended to the `initCode` and `executeBatch` calldata. Coinbase Smart Wallet expects a 16 byte hex string. If the data suffix is not a 16 byte hex string, the Smart Wallet will ignore the property. If auto is true, the Smart Wallet will generate a 16 byte hex string from the apps origin.

#### keysUrl <Badge text=">=2.12.33" />

`string`

- The URL for the keys popup.
- By default, `https://keys.coinbase.com/connect` is used for production. Use `https://keys-dev.coinbase.com/connect` for development environments.

#### options <Badge text=">=2.12.33" />

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

- `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
- `'smartWalletOnly'`: Displays Smart Wallet popup.
- `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

### version <Badge text=">=2.13.0" />

- Coinbase Wallet SDK version
- Defaults to `'4'`. If [`headlessMode: true`](#headlessmode), defaults to `'3'`.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  version: '4', // [!code focus]
})
```
</file>

<file path="site/shared/connectors/injected.md">
<!-- <script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# injected

Connector for [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Providers.

## Import

```ts-vue
import { injected } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,7}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { injected } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type InjectedParameters } from '{{connectorsPackageName}}'
```

### shimDisconnect

`boolean | undefined`

- MetaMask and other injected providers do not support programmatic disconnect.
- This flag simulates the disconnect behavior by keeping track of connection status in storage. See [GitHub issue](https://github.com/MetaMask/metamask-extension/issues/10353) for more info.
- Defaults to `true`.

```ts-vue
import { injected } from '{{connectorsPackageName}}'

const connector = injected({
  shimDisconnect: false, // [!code focus]
})
```

### target

`TargetId | (TargetMap[TargetId] & { id: string }) | (() => (TargetMap[TargetId] & { id: string }) | undefined) | undefined`

- [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target.
- [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) supported via `createConfig`'s <a :href="`/${docsPath}/api/createConfig#multiinjectedproviderdiscovery`">`multiInjectedProviderDiscovery`</a> property.

```ts-vue
import { injected } from '{{connectorsPackageName}}'

const connector = injected({
  target() { // [!code focus]
    return { // [!code focus]
      id: 'windowProvider', // [!code focus]
      name: 'Window Provider', // [!code focus]
      provider: window.ethereum, // [!code focus]
    } // [!code focus]
  }, // [!code focus]
})
```

### unstable_shimAsyncInject

`boolean | number | undefined`

Watches for async provider injection via the `ethereum#initialized` event. When `true`, defaults to `1_000` milliseconds. Otherwise, uses a provided value of milliseconds.

```ts-vue
import { injected } from '{{connectorsPackageName}}'

const connector = injected({
  unstable_shimAsyncInject: 2_000, // [!code focus]
})
```
</file>

<file path="site/shared/connectors/metaMask.md">
<!-- <script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# metaMask

Connector for [MetaMask SDK](https://github.com/MetaMask/metamask-sdk).

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/metamask-sdk/javascript) for more information.

## Import

```ts-vue
import { metaMask } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,7}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { metaMask } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [metaMask()],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type MetaMaskParameters } from '{{connectorsPackageName}}'
```

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/3rd-party-libraries/wagmi/) for more info. A few options are omitted that Wagmi manages internally.

### dappMetadata

`DappMetadata | undefined`

Metadata is used to fill details for the UX on confirmation screens in MetaMask, including the following fields:

- `name`: `string` - The name of the dapp.
- `url`: `string` - URL of the dapp (defaults to `window.location.origin`).
- `iconUrl`: `string` - URL to the dapp's favicon or icon.

```ts-vue
import { metaMask } from '{{connectorsPackageName}}'

const connector = metaMask({
  dappMetadata: { // [!code focus]
    name: 'My Wagmi App', // [!code focus]
    url: 'https://example.com', // [!code focus]
    iconUrl: 'https://example.com/favicon.ico', // [!code focus]
  }
})
```

### logging

`SDKLoggingOptions | undefined`

Enables SDK-side logging to provide visibility into:

- RPC methods being called.
- Events received for syncing the chain or active account.
- Raw RPC responses.

In this context, this is especially useful to observe what calls are made through Wagmi hooks.

Relevant options:

```ts
{
  developerMode: boolean, // Enables developer mode logs
  sdk: boolean           // Enables SDK-specific logs
}
```

```ts
import { metaMask } from '{{connectorsPackageName}}'

const connector = metaMask({
  logging: { developerMode: true, sdk: true } // [!code focus]
})
```

### headless

`boolean | undefined`

- Enables headless mode, disabling MetaMask's built-in modal.
- Allows developers to create their own modal, such as for displaying a QR code.

This is particularly relevant for web-only setups using Wagmi, where developers want complete control over the UI.

To get the deeplink to display in the QR code, listen to the `display_uri` event.

The default is `false`.

```ts-vue
import { metaMask } from '{{connectorsPackageName}}'

const connector = metaMask({
  headless: true // [!code focus]
})
```

## Advanced

By default, if the EIP-6963 MetaMask injected provider is detected, this connector will replace it.

EIP-6963 defines a standard way for dapps to interact with multiple wallets simultaneously by injecting providers into the browser. Wallets that implement this standard can make their presence known to dapps in a consistent and predictable manner.

When MetaMask SDK detects an EIP-6963-compliant provider (such as MetaMask itself), the connector will automatically replace the default injected provider (like `window.ethereum`) with the one provided by MetaMask SDK.

See the [`rdns` property](https://wagmi.sh/dev/creating-connectors#properties) for more information.
</file>

<file path="site/shared/connectors/mock.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# mock

Connector for mocking Wagmi functionality.

## Import

```ts-vue
import { mock } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,8-14}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { mock } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [
    mock({
      accounts: [
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
      ],
    }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type MockParameters } from '{{connectorsPackageName}}'
```

### accounts

`readonly [Address, ...Address[]]`

Accounts to use with the connector.

```ts-vue
import { mock } from '{{connectorsPackageName}}'

const connector = mock({
  accounts: [ // [!code focus]
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', // [!code focus]
    '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
    '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', // [!code focus]
    '0x90F79bf6EB2c4f870365E785982E1f101E93b906', // [!code focus]
    '0x15d34aaf54267db7d7c367839aaf71a00a2c6a65', // [!code focus]
    '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', // [!code focus]
    '0x976EA74026E726554dB657fA54763abd0C3a0aa9', // [!code focus]
    '0x14dC79964da2C08b23698B3D3cc7Ca32193d9955', // [!code focus]
    '0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f', // [!code focus]
    '0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', // [!code focus]
  ], // [!code focus]
})
```

### features

`{ connectError?: boolean | Error | undefined; reconnect?: boolean | undefined; signMessageError?: boolean | Error | undefined; signTypedDataError?: boolean | Error | undefined; switchChainError?: boolean | Error | undefined; } | undefined`

Feature flags that change behavior of Wagmi internals.

```ts-vue
import { mock } from '{{connectorsPackageName}}'
import { UserRejectedRequestError } from 'viem'

const connector = mock({
  accounts: [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
  ],
  features: { // [!code focus]
    connectError: new UserRejectedRequestError(new Error('Failed to connect.')), // [!code focus]
    reconnect: false, // [!code focus]
  }, // [!code focus]
})
```
#### defaultConnected

`boolean | undefined`

Whether the connector is connected by default.

#### connectError

`boolean | Error | undefined`

Whether to throw an error when `connector.connect` is called.

#### reconnect

`boolean | undefined`

Enables reconnecting to connector.

#### signMessageError

`boolean | Error | undefined`

Whether to throw an error when `'personal_sign'` is called.

#### signTypedDataError

`boolean | Error | undefined`

Whether to throw an error when `'eth_signTypedData_v4'` is called.

#### switchChainError

`boolean | Error | undefined`

Whether to throw an error when `connector.switchChain` is called.
</file>

<file path="site/shared/connectors/safe.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# safe

Connector for [Safe Apps SDK](https://github.com/safe-global/safe-apps-sdk).

## Import

```ts-vue
import { safe } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,7}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { safe } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [safe()],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type SafeParameters } from '{{connectorsPackageName}}'
```

Check out the [Safe docs](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-sdk) for more info.
### allowedDomains

`RegExp[] | undefined`

```ts-vue
import { safe } from '{{connectorsPackageName}}'

const connector = safe({
  allowedDomains: [/app.safe.global$/], // [!code focus]
})
```

### debug

`boolean | undefined`

```ts-vue
import { safe } from '{{connectorsPackageName}}'

const connector = safe({
  debug: true, // [!code focus]
})
```

### shimDisconnect

`boolean | undefined`

- This flag simulates disconnect behavior by keeping track of connection status in storage.
- Defaults to `false`.

```ts-vue
import { safe } from '{{connectorsPackageName}}'

const connector = safe({
  shimDisconnect: true, // [!code focus]
})
```
</file>

<file path="site/shared/connectors/walletConnect.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# walletConnect

Connector for [WalletConnect](https://walletconnect.com).

## Import

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,8-10}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { walletConnect } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [
    walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type WalletConnectParameters } from '{{connectorsPackageName}}'
```

Check out the [WalletConnect docs](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/providers/ethereum-provider) for more info. A few options are omitted that Wagmi manages internally.

### customStoragePrefix <Badge :text="`${packageName === '@wagmi/core' ? '@wagmi/connectors@>=5.1.8' : `${packageName}@>=${packageName === 'wagmi' ? '2.12.8' : packageName === '@wagmi/vue' ? '0.0.40' : ''}`}`" />

`string | undefined`

Custom storage prefix for persisting provider state.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  customStoragePrefix: 'wagmi', // [!code focus]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### disableProviderPing

`boolean | undefined`

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  disableProviderPing: false, // [!code focus]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### isNewChainsStale

`boolean | undefined`

- If a new chain is added to a previously existing configured connector `chains`, this flag
will determine if that chain should be considered as stale. A stale chain is a chain that
WalletConnect has yet to establish a relationship with (e.g. the user has not approved or
rejected the chain).
- Defaults to `true`.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  isNewChainsStale: true, // [!code focus]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

::: details More info
Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires
the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when
a user tries to switch to a chain that they have not approved.

This flag mainly affects the behavior when a wallet does not support dynamic chain authorization
with WalletConnect v2.

If `true` (default), the new chain will be treated as a stale chain. If the user
has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect
session, the connector will disconnect upon the dapp auto-connecting, and the user will have to
reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.
This is the default behavior to avoid an unexpected error upon switching chains which may
be a confusing user experience (e.g. the user will not know they have to reconnect
unless the dapp handles these types of errors).

If `false`, the new chain will be treated as a validated chain. This means that if the user
has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully
auto-connect the user. This comes with the trade-off that the connector will throw an error
when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly
modifies their configured chains, and they do not want to disconnect the user upon
auto-connecting. If the user decides to switch to the unapproved chain, it is important that the
dapp handles this error and prompts the user to reconnect to the dapp in order to approve
the newly added chain.
:::

### metadata

`CoreTypes.Metadata | undefined`

Metadata related to the app requesting the connection.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  metadata: { // [!code focus]
    name: 'Example', // [!code focus]
    description: 'Example website', // [!code focus]
    url: 'https://example.com', // [!code focus]
  }, // [!code focus]
})
```

### projectId

`string`

WalletConnect Cloud project identifier. You can find your `projectId` on your [WalletConnect dashboard](https://cloud.reown.com/sign-in).

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68', // [!code focus]
})
```

### qrModalOptions

`QrModalOptions | undefined`

Options for rendering QR modal.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  qrModalOptions: { // [!code focus]
    themeMode: 'dark', // [!code focus]
  }, // [!code focus]
})
```

### relayUrl

`string | undefined`

- WalletConnect relay URL to use.
- Defaults to `'wss://relay.walletconnect.com'`.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  relayUrl: 'wss://relay.walletconnect.org', // [!code focus]
})
```

### storageOptions

`KeyValueStorageOptions | undefined`

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  storageOptions: {}, // [!code focus]
})
```

### showQrModal

`boolean | undefined`

- Whether to show the QR code modal upon calling `connector.connect()`.
- Defaults to `true`.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  showQrModal: true, // [!code focus]
})
```

::: tip
This can be disabled and you can listen for a `'message'` event with payload `{ type: 'display_uri'; data: string }` if you want to render your own QR code.
:::
</file>

<file path="site/shared/transports/custom.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# custom

The `custom` Transport connects to a JSON-RPC API via custom. Wraps Viem's [`custom` Transport](https://viem.sh/docs/clients/transports/custom.html).

## Import

```ts-vue
import { custom } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  custom // [!code hl]
} from '{{packageName}}'
import { mainnet } from '{{packageName}}/chains'
import { customRpc } from './rpc'

export const config = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  transports: {
    [mainnet.id]: custom({ // [!code hl]
      async request({ method, params }) { // [!code hl]
        const response = await customRpc.request(method, params) // [!code hl]
        return response // [!code hl]
      } // [!code hl]
    }) // [!code hl]
  },
})
```

## Parameters

### provider

`{ request({ method: string, params: unknown[] }): Promise<unknown> }`

An [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request) function.

```ts
import { customRpc } from './rpc'

const transport = custom({
  async request({ method, params }) { // [!code focus:3]
    const response = await customRpc.request(method, params)
    return response
  }
})
```

### key (optional)

`string`

A key for the Transport. Defaults to `"custom"`.

```ts
const transport = custom(
  provider,
  { 
    key: 'windowProvider', // [!code focus]
  }
)
```

### name (optional)

`string`

A name for the Transport. Defaults to `"Ethereum Provider"`.

```ts
const transport = custom(
  provider,
  { 
    name: 'Window Ethereum Provider', // [!code focus]
  }
)
```

### retryCount (optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
const transport = custom(provider, {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
const transport = custom(provider, {
  retryDelay: 100, // [!code focus]
})
```
</file>

<file path="site/shared/transports/fallback.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# fallback

The `fallback` Transport consumes **multiple** Transports. If a Transport request fails, it will fall back to the next one in the list. Wraps Viem's [`fallback` Transport](https://viem.sh/docs/clients/transports/fallback.html).

## Import

```ts-vue
import { fallback } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  fallback, // [!code hl]
  http,
} from '{{packageName}}'
import { mainnet } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  transports: {
    [mainnet.id]: fallback([ // [!code hl]
      http('https://foo-bar-baz.quiknode.pro/...'), // [!code hl]
      http('https://mainnet.infura.io/v3/...'), // [!code hl]
    ]) // [!code hl]
  },
})
```
</file>

<file path="site/shared/transports/http.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# http

The `http` Transport connects to a JSON-RPC API via HTTP. Wraps Viem's [`http` Transport](https://viem.sh/docs/clients/transports/http.html).

## Import

```ts-vue
import { http } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  http // [!code hl]
} from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()],
  transports: {
    [mainnet.id]: http('https://foo-bar-baz.quiknode.pro/...'), // [!code hl]
    [sepolia.id]: http('https://foo-bar-sep.quiknode.pro/...'), // [!code hl]
  },
})
```

::: warning
If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.
:::

### Batch JSON-RPC

The `http` Transport supports Batch JSON-RPC. This means that multiple JSON-RPC requests can be sent in a single HTTP request.

The Transport will batch up Actions over a given period and execute them in a single Batch JSON-RPC HTTP request. By default, this period is a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays) meaning that the batch request will be executed at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue). Consumers can specify a custom time period `wait` (in ms).

You can enable Batch JSON-RPC by setting the `batch` flag to `true`:

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: true // [!code hl]
})
```

## Parameters

### url

`string`

URL of the JSON-RPC API. Defaults to `chain.rpcUrls.default.http[0]`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...')
```

### batch

`boolean | BatchOptions`

Toggle to enable Batch JSON-RPC. Defaults to `false`

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: true // [!code focus]
})
```

### batch.batchSize

`number`

The maximum number of JSON-RPC requests to send in a batch. Defaults to `1_000`.

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: {
    batchSize: 2_000 // [!code focus]
  }
})
```

### batch.wait

`number`

The maximum number of milliseconds to wait before sending a batch. Defaults to `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays)).

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: {
    wait: 16 // [!code focus]
  }
})
```

### fetchOptions

[`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)

[Fetch options](https://developer.mozilla.org/en-US/docs/Web/API/fetch) to pass to the internal `fetch` function. Useful for passing auth headers or cache options.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  fetchOptions: { // [!code focus:5]
    headers: {
      'Authorization': 'Bearer ...'
    }
  }
})
```

### key

`string`

A key for the Transport. Defaults to `"http"`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  key: 'alchemy', // [!code focus]
})
```

### name

`string`

A name for the Transport. Defaults to `"HTTP JSON-RPC"`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  name: 'Alchemy HTTP Provider', // [!code focus]
})
```

### retryCount

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  retryDelay: 100, // [!code focus]
})
```

### timeout

`number`

The timeout for requests. Defaults to `10_000`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="site/shared/transports/unstable_connector.md">
<!-- <script setup>
const docsPath = 'core'
const packageName = 'wagmi'
</script> -->

# unstable_connector

The `unstable_connector` Transport connects to a JSON-RPC API via the provided <a :href="`/${docsPath}/api/connectors`">Connector</a>. 

For example, if the provided Connector is <a :href="`/${docsPath}/api/connectors/injected`">`injected`</a> and the end-user uses MetaMask, then outgoing JSON-RPC requests will be sent via the MetaMask EIP-1193 Provider (`window.ethereum`).

## Import

```ts-vue
import { unstable_connector } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  fallback,
  unstable_connector, // [!code hl]
} from '{{packageName}}'
import { mainnet } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  transports: {
    [mainnet.id]: fallback([
      unstable_connector(injected), // [!code hl]
      http('https://foo-bar-baz.quiknode.pro/...')
    ])
  },
})
```

::: warning
It is **highly recommended** to use the `unstable_connector` Transport inside of a <a :href="`/${docsPath}/api/transports/fallback`">`fallback` Transport</a>. This ensures that if the Connector request fails, the Transport will fall back to a different Transport in the fallback set. 

Some common cases for a Connector request to fail are: 

- Chain ID mismatches,
- Connector RPC not supporting the requested method and/or only supporting a subset of methods for connected accounts,
- Rate-limiting of Connector RPC.
:::

## Parameters

### connector

`Connector`

The Connector to use for the Transport.

```ts
import { unstable_connector } from 'wagmi'
import { safe } from 'wagmi/connectors'

const transport = unstable_connector(safe) // [!code focus]
```

### key (optional)

`string`

A key for the Transport. Defaults to `"connector"`.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, { 
  key: 'injected',  // [!code focus]
})
```

### name (optional)

`string`

A name for the Transport. Defaults to `"Connector"`.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, { 
  name: 'Injected',  // [!code focus]
})
```

### retryCount (optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, {
  retryDelay: 100, // [!code focus]
})
```
</file>

<file path="site/shared/transports/webSocket.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# webSocket

The `webSocket` Transport connects to a JSON-RPC API via a WebSocket. Wraps Viem's [`webSocket` Transport](https://viem.sh/docs/clients/transports/webSocket.html).

## Import

```ts-vue
import { webSocket } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  webSocket // [!code hl]
} from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()],
  transports: {
    [mainnet.id]: webSocket('wss://foo-bar-baz.quiknode.pro/...'), // [!code hl]
    [sepolia.id]: webSocket('wss://foo-bar-sep.quicknode.pro/...'), // [!code hl]
  },
})
```

::: warning
If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.
:::

## Parameters

### url

`string`

URL of the JSON-RPC API.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...')
```

### key (optional)

`string`

A key for the Transport. Defaults to `"webSocket"`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
  key: 'alchemy',  // [!code focus]
})
```

### name (optional)

`string`

A name for the Transport. Defaults to `"WebSocket JSON-RPC"`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
  name: 'Alchemy WebSocket Provider',  // [!code focus]
})
```

### retryCount (optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
  retryDelay: 100, // [!code focus]
})
```

### timeout (optional)

`number`

The timeout for async WebSocket requests. Defaults to `10_000`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="site/shared/utilities/cookieToInitialState.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# cookieToInitialState

Helper to convert a cookie string into [initial state](/react/api/WagmiProvider#initialstate).

## Import

```ts-vue
import { cookieToInitialState } from '{{packageName}}'
```

## Usage

::: code-group

```ts-vue [server.ts]
import { cookieToInitialState } from '{{packageName}}'
import config from './config'

function handler(req: Request) {
  const initialState = cookieToInitialState(config, req.headers.cookie)
  // ...
}
```

```ts-vue [config.ts]
import { 
  createConfig, 
  http, 
  cookieStorage,
  createStorage
} from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  ssr: true,
  storage: createStorage({ 
    storage: cookieStorage,
  }), 
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

:::

## Parameters

### config

`Config`

Wagmi Config


### cookie

`string | null | undefined`

The cookie string.

## Return Type

`State`

Initial state.
</file>

<file path="site/shared/utilities/deserialize.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# deserialize

Deserialize function that supports `bigint` and `Map`.

## Import

```ts-vue
import { deserialize } from '{{packageName}}'
```

## Usage

```ts-vue
import { deserialize } from '{{packageName}}'

const result = deserialize('{"foo":"wagmi","bar":{"__type":"bigint","value":"123"}}')
```

## Parameters

### value

`string`

The string to deserialize.


### reviver

`(key: string, value: any) => any`

A custom reviver function for handling standard values.

## Return Type

`unknown`

Parsed value.
</file>

<file path="site/shared/utilities/normalizeChainId.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# normalizeChainId

Normalizes a chain ID to a number.

## Import

```ts-vue
import { normalizeChainId } from '{{packageName}}'
```

## Usage

:::warning Deprecated
Use `Number` instead.

```ts-vue
import { normalizeChainId } from '{{packageName}}' // [!code --]
const chainId = normalizeChainId(123n) // [!code --]
const chainId = Number(123n) // [!code ++]
```
:::

```ts-vue
import { normalizeChainId } from '{{packageName}}'

const result = normalizeChainId('0x1')
```

## Parameters


### chainId

`bigint | number | string`

The chain ID to normalize.

```ts-vue
import { normalizeChainId } from '{{packageName}}'

normalizeChainId(1n)
normalizeChainId(1)
normalizeChainId('0x1')
```

## Return Type

`number`

The normalized chain ID.
</file>

<file path="site/shared/utilities/serialize.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# serialize

Serialize function that supports `bigint` and `Map`.

## Import

```ts-vue
import { serialize } from '{{packageName}}'
```

## Usage

```ts-vue
import { serialize } from '{{packageName}}'

const result = serialize({ foo: 'wagmi', bar: 123n })
```

## Parameters

### value

`any`

The value to stringify.

### replacer

`(key: string, value: any) => any`

A custom replacer function for handling standard values.

### indent

`number | null | undefined`

The number of spaces to indent the output by.

### circularReplacer

A custom replacer function for handling circular values.

## Return Type

`string`

Stringified value.
</file>

<file path="site/shared/create-chain.md">
## Create Chain

Import the `Chain` type from Viem and create a new object that is asserted `as const` and `satisfies` the type. You can also use the `defineChain` function from Viem.

::: code-group
```ts twoslash [as const satisfies Chain]
// @errors: 1360
import { type Chain } from 'viem'

export const mainnet = {} as const satisfies Chain
```
```ts twoslash [defineChain]
// @errors: 2345
import { defineChain } from 'viem'

export const mainnet = defineChain({})
```
:::

Now, add the missing required properties to the object until the error goes away.

::: code-group
```ts twoslash [as const satisfies Chain]
import { type Chain } from 'viem'

export const mainnet = {
  id: 1,
  name: 'Ethereum',
  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
  rpcUrls: {
    default: { http: ['https://eth.merkle.io'] },
  },
  blockExplorers: {
    default: { name: 'Etherscan', url: 'https://etherscan.io' },
  },
  contracts: {
    ensRegistry: {
      address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    },
    ensUniversalResolver: {
      address: '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
      blockCreated: 16773775,
    },
    multicall3: {
      address: '0xca11bde05977b3631167028862be2a173976ca11',
      blockCreated: 14353601,
    },
  },
} as const satisfies Chain
```
```ts twoslash [defineChain]
import { defineChain } from 'viem'

export const mainnet = defineChain({
  id: 1,
  name: 'Ethereum',
  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
  rpcUrls: {
    default: { http: ['https://eth.merkle.io'] },
  },
  blockExplorers: {
    default: { name: 'Etherscan', url: 'https://etherscan.io' },
  },
  contracts: {
    ensRegistry: {
      address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    },
    ensUniversalResolver: {
      address: '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
      blockCreated: 16773775,
    },
    multicall3: {
      address: '0xca11bde05977b3631167028862be2a173976ca11',
      blockCreated: 14353601,
    },
  },
})
```
:::

The more properties you add, the better the chain will be to use with Wagmi. Most of these attributes exist within the [`ethereum-lists/chains` repository](https://github.com/ethereum-lists/chains/tree/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains).

- `id`: The chain ID for the network. This can be found by typing the network name into [ChainList](https://chainlist.org). Example: "Ethereum Mainnet" has a Chain ID of `1`.
- `name`: Human-readable name for the chain. Example: "Ethereum Mainnet"
- `nativeCurrency`: The native currency of the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L20-L24).
- `rpcUrls`: At least one public, credible RPC URL. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L4-L18).
- `blockExplorers`: A set of block explorers for the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L30-L36).
- `contracts`: A set of deployed contracts for the chain. If you are deploying one of the following contracts yourself, make sure it is verified.
  - `multicall3` is optional, but it's address is most likely `0xca11bde05977b3631167028862be2a173976ca11` ‚Äì you can find the deployed block number on the block explorer. Check out [`mds1/multicall`](https://github.com/mds1/multicall#multicall3-contract-addresses) for more info.
  - `ensRegistry` is optional ‚Äì not all Chains have a ENS Registry. See [ENS Deployments](https://docs.ens.domains/ens-deployments) for more info.
  - `ensUniversalResolver` is optional ‚Äì not all Chains have a ENS Universal Resolver.
- `sourceId`: Source Chain ID (e.g. the L1 chain).
- `testnet`: Whether or not the chain is a testnet.
</file>

<file path="site/shared/createConfig.md">
<!--
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>
-->

# createConfig

Creates new [`Config`](#config) object.

## Import

```ts-vue
import { createConfig } from '{{packageName}}'
```

## Usage

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

::: tip Integrating a Viem Client

Instead of using [`transports`](#transports), it's possible to provide a function that returns a Viem [`Client`](https://viem.sh/docs/clients/custom.html) via the [`client`](#client) property for more fine-grained control over Wagmi's internal `Client` creation.

```ts-vue {3,7-9}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { createClient } from 'viem'

const config = createConfig({
  chains: [mainnet, sepolia],
  client({ chain }) {
    return createClient({ chain, transport: http() })
  },
})
```
:::

## Parameters

```ts-vue
import { type CreateConfigParameters } from '{{packageName}}'
```

### chains

`readonly [Chain, ...Chain[]]`

- Chains used by the `Config`.
- See <a :href="`/${docsPath}/api/chains`">Chains</a> for more details about built-in chains and the `Chain` type.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia], // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### connectors

`CreateConnectorFn[] | undefined`

<a :href="`/${docsPath}/api/connectors`">Connectors</a> used by the `Config`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { injected } from '{{connectorsPackageName}}' // [!code focus]

const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()], // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### multiInjectedProviderDiscovery

`boolean | undefined`

- Enables discovery of injected providers via [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) using the [`mipd`](https://github.com/wevm/mipd) library and converting to <a :href="`/${docsPath}/api/connectors/injected`">injected</a> connectors.
- Defaults to `true`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  multiInjectedProviderDiscovery: false, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### ssr

`boolean | undefined`

Flag to indicate if the config is being used in a server-side rendering environment. Defaults to `false`.

```ts-vue
import { createConfig, http } from '{{packageName}}' // [!code focus]
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  ssr: true, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### storage

`Storage | null | undefined`

- <a :href="`/${docsPath}/api/createStorage#storage`">`Storage`</a> used by the config. Persists `Config`'s [`State`](#state-1) between sessions.
- Defaults to `createStorage({ storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage })`.

```ts-vue
import { createConfig, createStorage, http } from '{{packageName}}' // [!code focus]
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  storage: createStorage({ storage: window.localStorage }), // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### syncConnectedChain

`boolean | undefined`

- Keep the [`State['chainId']`](#chainid) in sync with the current connection.
- Defaults to `true`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  syncConnectedChain: false, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

---

### batch

`{ multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | { [_ in chains[number]["id"]]?: { multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | undefined } | undefined`

- Batch settings. See [Viem docs](https://viem.sh/docs/clients/custom.html#batch-optional) for more info.
- Defaults to `{ multicall: true }`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  batch: { multicall: true }, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### cacheTime

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

- Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/public.html#cachetime-optional) for more info.
- Defaults to [`pollingInterval`](#pollinginterval) or `4_000`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  cacheTime: 4_000, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### pollingInterval

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

- Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/custom.html#pollinginterval-optional) for more info.
- Defaults to `4_000`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  pollingInterval: 4_000, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### transports

`Record<chains[number]['id'], Transport>`

Mapping of [chain IDs](#chains) to <a :href="`/${docsPath}/api/transports`">`Transport`</a>s. This mapping is used internally when creating chain-aware Viem [`Client`](https://viem.sh/docs/clients/custom.html) objects. See the <a :href="`/${docsPath}/api/transports`">Transport docs</a> for more info.

```ts-vue
import { createConfig, fallback, http } from '{{packageName}}' // [!code focus]
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: { // [!code focus]
    [mainnet.id]: fallback([ // [!code focus]
      http('https://...'), // [!code focus]
      http('https://...'), // [!code focus]
    ]), // [!code focus]
    [sepolia.id]: http('https://...'), // [!code focus]
  }, // [!code focus]
})
```

---

### client

`(parameters: { chain: chains[number] }) => Client<Transport, chains[number]>`

Function for creating new Viem [`Client`](https://viem.sh/docs/clients/custom.html) to be used internally. Exposes more control over the internal `Client` creation logic versus using the [`transports`](#transports) property.

```ts-vue
import { createClient, http } from 'viem' // [!code focus]
import { createConfig } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  client({ chain }) { // [!code focus]
    return createClient({ chain, transport: http('https://...') }) // [!code focus]
  }, // [!code focus]
})
```

::: warning
When using this option, you likely want to pass `parameters.chain` straight through to [`createClient`](https://viem.sh/docs/clients/custom.html#createclient) to ensure the Viem `Client` is in sync with any active connections.
:::

## Return Type

```ts-vue
import { type Config } from '{{packageName}}'
```

## Config

Object responsible for managing Wagmi state and internals.

```ts-vue
import { type Config } from '{{packageName}}'
```

### chains

`readonly [Chain, ...Chain[]]`

[`chains`](#chains) passed to `createConfig`.

### connectors

`readonly Connector[]`

Connectors set up from passing [`connectors`](#connectors) and [`multiInjectedProviderDiscovery`](#multiinjectedproviderdiscovery) to `createConfig`.

### state

`State<chains>`

The `Config` object's internal state. See [`State`](#state-1) for more info.

### storage

`Storage | null`

[`storage`](#storage) passed to `createConfig`.

### getClient

`(parameters?: { chainId?: chainId | chains[number]['id'] | undefined }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>`

Creates new Viem [`Client`](https://viem.sh/docs/clients/custom.html) object.

::: code-group
```ts-vue [index.ts]
import { config } from './config'

const client = config.getClient({ chainId: 1 })
```

```ts-vue [config.ts]
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

:::

### setState

`(value: State<chains> | ((state: State<chains>) => State<chains>)) => void`

Updates the `Config` object's internal state. See [`State`](#state-1) for more info.

::: code-group
```ts-vue [index.ts]
import { mainnet } from '{{packageName}}/chains'
import { config } from './config'

config.setState((x) => ({
  ...x,
  chainId: x.current ? x.chainId : mainnet.id,
}))
```

```ts-vue [config.ts]
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

:::

::: warning
Exercise caution when using this method. It is intended for internal and advanced use-cases only. Manually setting state can cause unexpected behavior.
:::

### subscribe

`(selector: (state: State<chains>) => state, listener: (selectedState: state, previousSelectedState: state) => void, options?: { emitImmediately?: boolean | undefined; equalityFn?: ((a: state, b: state) => boolean) | undefined } | undefined) => (() => void)`

Listens for state changes matching the `selector` function. Returns a function that can be called to unsubscribe the listener.

::: code-group
```ts-vue [index.ts]
import { config } from './config'

const unsubscribe = config.subscribe(
  (state) => state.chainId,
  (chainId) => console.log(`Chain ID changed to ${chainId}`),
)
unsubscribe()
```

```ts-vue [config.ts]
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

:::

## State

```ts-vue
import { type State } from '{{packageName}}'
```

### chainId

`chains[number]['id']`

Current chain ID. When `syncConnectedChain` is `true`, `chainId` is kept in sync with the current connection. Defaults to first chain in [`chains`](#chains).

### connections

`Map<string, Connection>`

Mapping of unique connector identifier to [`Connection`](#connection) object.

### current

`string | undefined`

Unique identifier of the current connection.

### status

`'connected' | 'connecting' | 'disconnected' | 'reconnecting'`

Current connection status.

- `'connecting'` attempting to establish connection.
- `'reconnecting'` attempting to re-establish connection to one or more connectors.
- `'connected'` at least one connector is connected.
- `'disconnected'` no connection to any connector.

## Connection

```ts-vue
import { type Connection } from '{{packageName}}'
```

### accounts

`readonly [Address, ...Address[]]`

Array of addresses associated with the connection.

### chainId

`number`

Chain ID associated with the connection.

### connector

`Connector`

Connector associated with the connection.
</file>

<file path="site/shared/createStorage.md">
<!--
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
</script>
-->

# createStorage

Creates new [`Storage`](#storage) object.

## Import

```ts-vue
import { createStorage } from '{{packageName}}'
```

## Usage

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
```

## Parameters

```ts-vue
import { type CreateStorageParameters } from '{{packageName}}'
```

### deserialize

`(<T>(value: string) => T) | undefined`

- Function to deserialize data from storage.
- Defaults to <a :href="`/${docsPath}/api/utilities/deserialize`">`deserialize`</a>.

```ts-vue
import { createStorage, deserialize } from '{{packageName}}' // [!code focus]

const storage = createStorage({
  deserialize, // [!code focus]
  storage: localStorage,
})
```

::: warning
If you use a custom `deserialize` function, make sure it can handle `bigint` and `Map` values.
:::

### key

`string | undefined`

- Key prefix to use when persisting data.
- Defaults to `'wagmi'`.

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({
  key: 'my-app', // [!code focus]
  storage: localStorage,
})
```

### serialize

`(<T>(value: T) => string) | undefined`

- Function to serialize data for storage.
- Defaults to <a :href="`/${docsPath}/api/utilities/serialize`">`serialize`</a>.

```ts-vue
import { createStorage, serialize } from '{{packageName}}' // [!code focus]

const storage = createStorage({
  serialize, // [!code focus]
  storage: localStorage,
})
```

::: warning
If you use a custom `serialize` function, make sure it can handle `bigint` and `Map` values.
:::

### storage

`{ getItem(key: string): string | null | undefined | Promise<string | null | undefined>; setItem(key: string, value: string): void | Promise<void>; removeItem(key: string): void | Promise<void>; }`

- Storage interface to use for persisting data.
- Defaults to `localStorage`.
- Supports synchronous and asynchronous storage methods.

```ts-vue
import { createStorage } from '{{packageName}}'
// Using IndexedDB via https://github.com/jakearchibald/idb-keyval // [!code focus]
import { del, get, set } from 'idb-keyval' // [!code focus]

const storage = createStorage({
  storage: { // [!code focus]
    async getItem(name) { // [!code focus]
      return get(name)// [!code focus]
    }, // [!code focus]
    async setItem(name, value) { // [!code focus]
      await set(name, value) // [!code focus]
    }, // [!code focus]
    async removeItem(name) { // [!code focus]
      await del(name) // [!code focus]
    }, // [!code focus]
  }, // [!code focus]
})
```

## Return Type

```ts-vue
import { type Storage } from '{{packageName}}'
```

## Storage

Object responsible for persisting Wagmi <a :href="`/${docsPath}/api/createConfig#state-1`">`State`</a> and other data.

```ts-vue
import { type Storage } from '{{packageName}}'
```

### getItem

`getItem(key: string, defaultValue?: value | null | undefined): value | null | Promise<value | null>`

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
const recentConnectorId = storage.getItem('recentConnectorId') // [!code focus]
```

### setItem

`setItem(key: string, value: any): void | Promise<void>`

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
storage.setItem('recentConnectorId', 'foo') // [!code focus]
```

### removeItem

`removeItem(key: string): void | Promise<void>`

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
storage.removeItem('recentConnectorId') // [!code focus]
```
</file>

<file path="site/shared/errors.md">
<!--
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
</script>
-->

## BaseError

Error class extended by all errors.

```ts-vue
import { BaseError } from '{{packageName}}'
```

## Config

### ConnectorAccountNotFoundError

When an account does not exist on the connector or is unable to be used.

```ts-vue
import { ConnectorAccountNotFoundError } from '{{packageName}}'
```

### ConnectorAlreadyConnectedError

When a connector is already connected.

```ts-vue
import { ConnectorAlreadyConnectedError } from '{{packageName}}'
```

### ConnectorChainMismatchError

When the Wagmi Config is out-of-sync with the connector's active chain ID. This is rare and likely an upstream wallet issue.

```ts-vue
import { ConnectorChainMismatchError } from '{{packageName}}'
```

### ChainNotConfiguredError

When a chain is not configured. You likely need to add the chain to <a :href="`/${docsPath}/api/createConfig#chains`">`Config['chains']`</a>.

```ts-vue
import { ChainNotConfiguredError } from '{{packageName}}'
```

### ConnectorNotConnectedError

When a connector is not connected.

```ts-vue
import { ConnectorNotConnectedError } from '{{packageName}}'
```

### ConnectorNotFoundError

When a connector is not found or able to be used.

```ts-vue
import { ConnectorNotFoundError } from '{{packageName}}'
```

### ConnectorUnavailableReconnectingError

During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.

```ts-vue
import { ConnectorUnavailableReconnectingError } from '{{packageName}}'
```

## Connector

### ProviderNotFoundError

When a connector's provider is not found or able to be used.

```ts-vue
import { ProviderNotFoundError } from '{{packageName}}'
```

### SwitchChainNotSupportedError

When switching chains is not supported by connectors.

```ts-vue
import { SwitchChainNotSupportedError } from '{{packageName}}'
```
</file>

<file path="site/shared/faq.md">
<!--
<script setup>
const docsPath = 'react'
</script>
-->

## Type inference doesn't work

- Check that you set up TypeScript correctly with `"strict": true` in your `tsconfig.json` (<a :href="`/${docsPath}/typescript#requirements`">TypeScript docs</a>)
- Check that you <a :href="`/${docsPath}/typescript#const-assert-abis-typed-data`">const-asserted any ABIs or Typed Data</a> you are using.
- Restart your language server or IDE, and check for type errors in your code.

## My wallet doesn't work

If you run into issues with a specific wallet, try another before opening up an issue. There are many different wallets and it's likely that the issue is with the wallet itself, not Wagmi. For example, if you are using Wallet X and sending a transaction doesn't work, try Wallet Y and see if it works.

## `BigInt` Serialization

Using native `BigInt` with `JSON.stringify` will raise a `TypeError` as
[`BigInt` values are not serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json). There are two techniques to mitigate this:

#### Lossless serialization

Lossless serialization means that `BigInt` will be converted to a format that can be deserialized later (e.g. `69420n` ‚Üí `"#bigint.69420"`). The trade-off is that these values are not human-readable and are not intended to be displayed to the user.

Lossless serialization can be achieved with wagmi's <a :href="`/${docsPath}/api/utilities/serialize`">`serialize`</a> and <a :href="`/${docsPath}/api/utilities/deserialize`">`deserialize`</a> utilities.

```tsx
import { serialize, deserialize } from 'wagmi'

const serialized = serialize({ value: 69420n })
// '{"value":"#bigint.69420"}'

const deserialized = deserialize(serialized)
// { value: 69420n }
```

#### Lossy serialization

Lossy serialization means that the `BigInt` will be converted to a normal display string (e.g. `69420n` ‚Üí `'69420'`).
The trade-off is that you will not be able to deserialize the `BigInt` with `JSON.parse` as it can not distinguish between a normal string and a `BigInt`.

This method can be achieved by modifying `JSON.stringify` to include a BigInt `replacer`:

```tsx
const replacer = (key, value) =>
  typeof value === 'bigint' ? value.toString() : value

JSON.stringify({ value: 69420n }, replacer)
// '{"value":"69420"}'
```

## How do I support the project?

Wagmi is an open source software project and free to use. If you enjoy using Wagmi or would like to support Wagmi development, you can:

- [Become a sponsor on GitHub](https://github.com/sponsors/wevm)
- Send us crypto
  - Mainnet: 0x4557B18E779944BFE9d78A672452331C186a9f48
  - Multichain: 0xd2135CfB216b74109775236E36d4b433F1DF507B
- [Become a supporter on Drips](https://www.drips.network/app/projects/github/wevm/wagmi)

If you use Wagmi at work, consider asking your company to sponsor Wagmi. This may not be easy, but **business sponsorships typically make a much larger impact on the sustainability of OSS projects** than individual donations, so you will help us much more if you succeed.

## Is Wagmi production ready?

Yes. Wagmi is very stable and is used in production by thousands of organizations, like [Stripe](https://stripe.com), [Shopify](https://shopify.com), [Coinbase](https://coinbase.com), [Uniswap](https://uniswap.org), [ENS](https://ens.domains), [Optimism](https://optimism.com).

## Is Wagmi strict with semver?

Yes, Wagmi is very strict with [semantic versioning](https://semver.org) and we will never introduce breaking changes to the runtime API in a minor version bump.

For exported types, we try our best to not introduce breaking changes in non-major versions, however, [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases that can cause Wagmi type issues. See the <a :href="`/${docsPath}/typescript#requirements`">TypeScript docs</a> for more information.

## How can I contribute to Wagmi?

The Wagmi team accepts all sorts of contributions. Check out the [Contributing](/dev/contributing) guide to get started. If you are interested in adding a new connector to Wagmi, check out the [Creating Connectors](/dev/creating-connectors) guide.

## Anything else you want to know?

Please create a new [GitHub Discussion thread](https://github.com/wevm/wagmi). You're also free to suggest changes to this or any other page on the site using the "Suggest changes to this page" button at the bottom of the page.
</file>

<file path="site/shared/getAccount-return-type.md">
<!--
<script setup>
const TVariables = 'TVariables'
</script>
-->

### address

`Address | undefined`

- Connected address from connector.
- Defaults to first address in [`addresses`](#addresses).

### addresses

`readonly Address[] | undefined`

Connected addresses from connector.

### chain

`Chain | undefined`

Connected chain from connector. If chain is not configured by config, it will be `undefined`.

### chainId

`number | undefined`

Connected chain id from connector.

### connector

`Connector | undefined`

Connected connector.

### isConnecting / isReconnecting / isConnected / isDisconnected

`boolean`

Boolean variables derived from [`status`](#status).

### status

`'connecting' | 'reconnecting' | 'connected' | 'disconnected'`

- `'connecting'` attempting to establish connection.
- `'reconnecting'` attempting to re-establish connection to one or more connectors.
- `'connected'` at least one connector is connected.
- `'disconnected'` no connection to any connector.

::: info You can use `status` to narrow the return type. 
For example, when `status` is `'connected'` properties like `address` are guaranteed to be defined.

```ts twoslash
import { type GetAccountReturnType } from '@wagmi/core'
const account = {} as GetAccountReturnType
// ---cut---
if (account.status === 'connected') {
  account
  // ^?















}
```

Or when status is `'disconnected'` properties like `address` are guaranteed to be `undefined`:

```ts twoslash
import { type GetAccountReturnType } from '@wagmi/core'
const account = {} as GetAccountReturnType
// ---cut---
if (account.status === 'disconnected') {
  account
  // ^?















}
```
:::
</file>

<file path="site/shared/installation.md">
<!--
<script setup>
import Browsers from '../components/Browsers.vue'
const docsPath = 'react'
const packageDir = 'react'
const packageName = 'wagmi'
</script>
-->

## Requirements

Wagmi is optimized for modern browsers. It is compatible with the latest versions of the following browsers.

<Browsers />

::: tip
Depending on your environment, you might need to add polyfills. See [Viem Platform Compatibility](https://viem.sh/docs/compatibility.html) for more info.
:::

## Using Unreleased Commits

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

::: code-group
```bash-vue [pnpm]
pnpm add {{packageName}}@canary
```

```bash-vue [npm]
npm install {{packageName}}@canary
```

```bash-vue [yarn]
yarn add {{packageName}}@canary
```

```bash-vue [bun]
bun add {{packageName}}@canary
```
:::

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

```bash-vue
gh repo clone wevm/wagmi
cd wagmi
pnpm install
pnpm build
cd packages/{{packageDir}}
pnpm link --global
```

Then go to the project where you are using Wagmi and run `pnpm link --global {{packageName}}` (or the package manager that you used to link Wagmi globally). Make sure you installed any [required peer dependencies](#package-manager) and their versions are correct.

## Security

Ethereum-related projects are often targeted in attacks to steal users' assets. Make sure you follow security best-practices for your project. Some quick things to get started.

- Pin package versions, upgrade mindfully, and inspect lockfile changes to minimize the risk of [supply-chain attacks](https://nodejs.org/en/guides/security/#supply-chain-attacks).
- Install the [Socket Security](https://socket.dev) [GitHub App](https://github.com/apps/socket-security) to help detect and block supply-chain attacks.
- Add a [Content Security Policy](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) to defend against external scripts running in your app.
- Pin [GitHub Action](https://x.com/paulmillr/status/1900948425325031448) versions to commits instead of tags.
</file>

<file path="site/shared/mutation-imports.md">
<!--
<script setup>
const packageName = 'wagmi'
const actionName = 'connect'
const typeName = 'Connect'
</script>
-->

## TanStack Query

```ts-vue
import {
  type {{typeName}}Data,
  type {{typeName}}Variables,
  type {{typeName}}Mutate,
  type {{typeName}}MutateAsync,
  {{actionName}}MutationOptions,
} from '{{packageName}}/query'
```
</file>

<file path="site/shared/mutation-options.md">
<!--
<script setup>
const mutate = 'mutationFn'
const TData = 'TData'
const TError = 'TError'
const TVariables = 'TVariables'
</script>
-->

<br />

---

### mutation

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

::: info Wagmi does not support passing all TanStack Query parameters
TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.
:::

#### gcTime

`number | Infinity | undefined`

- The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
- If set to `Infinity`, will disable garbage collection

#### meta

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`{{mutate}}`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode

`'online' | 'always' | 'offlineFirst' | undefined`

- defaults to `'online'`
- see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError

`((error: {{TError}}, variables: {{TVariables}}, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate

`((variables: {{TVariables}}) => Promise<context | void> | context | void) | undefined`

- This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
- Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
- The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess

`((data: {{TData}}, variables: {{TVariables}}, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled

`((data: {{TData}}, error: {{TError}}, variables: {{TVariables}}, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry

`boolean | number | ((failureCount: number, error: {{TError}}) => boolean) | undefined`

- Defaults to `0`.
- If `false`, failed mutations will not retry.
- If `true`, failed mutations will retry infinitely.
- If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay

`number | ((retryAttempt: number, error: {{TError}}) => number) | undefined`

- This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
- A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
- A function like `attempt => attempt * 1000` applies linear backoff.
</file>

<file path="site/shared/mutation-result.md">
<!--
<script setup>
const mutate = 'mutationFn'
const TData = 'TData'
const TError = 'TError'
const TVariables = 'TVariables'
</script>
-->

<br />

---

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### {{mutate}}

`(variables: {{TVariables}}, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

- #### variables

  `{{TVariables}}`

  The variables object to pass to the <a :href="`/core/api/actions/${mutate}#parameters`">`{{mutate}}`</a> action.

- #### onSuccess

  `(data: {{TData}}, variables: {{TVariables}}, context: TContext) => void`

  This function will fire when the mutation is successful and will be passed the mutation's result.

- #### onError

  `(error: {{TError}}, variables: {{TVariables}}, context: TContext | undefined) => void`

  This function will fire if the mutation encounters an error and will be passed the error.

- #### onSettled

  `(data: {{TData}} | undefined, error: {{TError}} | null, variables: {{TVariables}}, context: TContext | undefined) => void`

  - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
  - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### {{mutate}}Async

`(variables: {{TVariables}}, { onSuccess, onSettled, onError }) => Promise<{{TData}}>`

Similar to [`{{mutate}}`](#mutate) but returns a promise which can be awaited.

### data

`{{TData}} | undefined`

- <a :href="`/core/api/actions/${mutate}#return-type`">`{{mutate}}` return type</a>
- Defaults to `undefined`
- The last successfully resolved data for the mutation.

### error

`{{TError}} | null`

The error object for the mutation, if an error was encountered.

### failureCount

`number`

- The failure count for the mutation.
- Incremented every time the mutation fails.
- Reset to `0` when the mutation succeeds.

### failureReason

`{{TError}} | null`

- The failure reason for the mutation retry.
- Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused

`boolean`

- will be `true` if the mutation has been `paused`.
- see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status

`'idle' | 'pending' | 'error' | 'success'`

- `'idle'` initial status prior to the mutation function executing.
- `'pending'` if the mutation is currently executing.
- `'error'` if the last mutation attempt resulted in an error.
- `'success'` if the last mutation attempt was successful.

### submittedAt

`number`

- The timestamp for when the mutation was submitted.
- Defaults to `0`.

### variables

`{{TVariables}} | undefined`

- The variables object passed to [`{{mutate}}`](#mutate).
- Defaults to `undefined`.
</file>

<file path="site/shared/query-imports.md">
<!--
<script setup>
const packageName = 'wagmi'
const actionName = 'getBalance'
const typeName = 'GetBalance'
</script>
-->

## TanStack Query

```ts-vue
import {
  type {{typeName}}Data,
  type {{typeName}}Options,
  type {{typeName}}QueryFnData,
  type {{typeName}}QueryKey,
  {{actionName}}QueryKey,
  {{actionName}}QueryOptions,
} from '{{packageName}}/query'
```
</file>

<file path="site/shared/query-options.md">
<!--
<script setup>
const TData = 'TData'
const TError = 'TError'
const TPageParam = number
const hideQueryOptions = []
const includeInfiniteQueryOptions = false
</script>
-->

<br />

---

### query

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

::: info Wagmi does not support passing all TanStack Query parameters
TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.
:::

#### enabled

`boolean | undefined`

- Set this to `false` to disable this query from automatically running.
- Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

<div v-if="!hideQueryOptions?.includes('gcTime')">

#### gcTime

`number | Infinity | undefined`

- Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
- The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
- If set to `Infinity`, will disable garbage collection

</div>

#### initialData

`{{TData}} | (() => {{TData}}) | undefined`

- If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
- If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
- Initial data is considered stale by default unless a `staleTime` has been set.
- `initialData` **is persisted** to the cache

#### initialDataUpdatedAt

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

<div v-if="includeInfiniteQueryOptions">

#### initialPageParam

`{{TPageParam}}`

The initial page parameter to be passed to the query function.

#### getPreviousPageParam

This function can be set to automatically get the previous cursor for infinite queries.
The result will also be used to determine the value of `hasPreviousPage`.

`(firstPage: {{TData}}, allPages: {{TData}}[], firstPageParam: {{TPageParam}}, allPageParams: {{TPageParam}}[]) => {{TPageParam}} | undefined | null`

#### getNextPageParam

This function can be set to automatically get the previous cursor for infinite queries.
The result will also be used to determine the value of `hasPreviousPage`.

`(lastPage: {{TData}}, allPages: {{TData}}[], lastPageParam: {{TPageParam}}, allPageParams: {{TPageParam}}[]) => {{TPageParam}} | undefined | null`

</div>

#### meta

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode

`online' | 'always' | 'offlineFirst' | undefined`

- Defaults to `'online'`
- see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps

`string[] | 'all' | (() => string[] | 'all') | undefined`

- If set, the component will only re-render if any of the listed properties change.
- If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
- If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
- If set to a function, the function will be executed to compute the list of properties.
- By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData

`{{TData}} | ((previousValue: {{TData}} | undefined; previousQuery: Query | undefined) => {{TData}}) | undefined`

- If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
- `placeholderData` is **not persisted** to the cache
- If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval

`number | false | ((data: {{TData}} | undefined, query: Query) => number | false | undefined) | undefined`

- If set to a number, all queries will continuously refetch at this frequency in milliseconds
- If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

- Defaults to `true`
- If set to `true`, the query will refetch on mount if the data is stale.
- If set to `false`, the query will not refetch on mount.
- If set to `'always'`, the query will always refetch on mount.
- If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

- Defaults to `true`
- If set to `true`, the query will refetch on reconnect if the data is stale.
- If set to `false`, the query will not refetch on reconnect.
- If set to `'always'`, the query will always refetch on reconnect.
- If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

- Defaults to `true`
- If set to `true`, the query will refetch on window focus if the data is stale.
- If set to `false`, the query will not refetch on window focus.
- If set to `'always'`, the query will always refetch on window focus.
- If set to a function, the function will be executed with the query to compute the value

#### retry

`boolean | number | ((failureCount: number, error: {{TError}}) => boolean) | undefined`

- If `false`, failed queries will not retry by default.
- If `true`, failed queries will retry infinitely.
- If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
- Defaults to `3` on the client and `0` on the server

#### retryDelay

`number | ((retryAttempt: number, error: {{TError}}) => number) | undefined`

- This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
- A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
- A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select

`((data: {{TData}}) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

<div v-if="!hideQueryOptions?.includes('staleTime')">

#### staleTime

`number | Infinity | undefined`

- Defaults to `0`
- The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
- If set to `Infinity`, the data will never be considered stale

</div>

#### structuralSharing

`boolean | (((oldData: {{TData}} | undefined, newData: {{TData}}) => {{TData}})) | undefined`

- Defaults to `true`
- If set to `false`, structural sharing between query results will be disabled.
- If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.
</file>

<file path="site/shared/query-result.md">
<!--
<script setup>
const TData = 'TData'
const TError = 'TError'
const includeInfiniteQueryResult = false
</script>
-->

<br />

---

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data

`{{TData}}`

- The last successfully resolved data for the query.
- Defaults to `undefined`.

### dataUpdatedAt

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error

`null | {{TError}}`

- The error object for the query, if an error was thrown.
- Defaults to `null`

### errorUpdatedAt

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount

`number`

The sum of all errors.

### failureCount

`number`

- The failure count for the query.
- Incremented every time the query fails.
- Reset to `0` when the query succeeds.

### failureReason

`null | {{TError}}`

- The failure reason for the query retry.
- Reset to `null` when the query succeeds.

<div v-if="includeInfiniteQueryOptions">

### fetchNextPage

`(options?: FetchNextPageOptions) => Promise<InfiniteQueryObserverResult<{{TData}}, {{TError}}>>`

This function allows you to fetch the next "page" of results.

### fetchPreviousPage

`(options?: FetchPreviousPageOptions) => Promise<InfiniteQueryObserverResult<TData, TError>>`

This function allows you to fetch the previous "page" of results.

### hasNextPage

`boolean`

This will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).

### hasPreviousPage

`boolean`

This will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).

### isFetchingNextPage

`boolean`

Will be `true` while fetching the next page with `fetchNextPage`.

### isFetchingPreviousPage

`boolean`

Will be `true` while fetching the previous page with `fetchPreviousPage`.

</div>

### fetchStatus

`'fetching' | 'idle' | 'paused'`

- `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
- `paused` The query wanted to fetch, but has been `paused`.
- `idle` The query is not fetching.
- See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount

`boolean`

- Will be `true` if the query has been fetched after the component mounted.
- This property can be used to not show any previously cached data.

### isFetching / isPaused

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading

`boolean`

- Is `true` whenever the first fetch for a query is in-flight
- Is the same as `isFetching && isPending`

### isLoadingError

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching

`boolean`

- Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
- Is the same as `isFetching && !isPending`

### isStale

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<{{TData}}, {{TError}}>>`

- A function to manually refetch the query.
- `throwOnError`
  - When set to `true`, an error will be thrown if the query fails.
  - When set to `false`, an error will be logged if the query fails.
- `cancelRefetch`
  - When set to `true`, a currently running request will be cancelled before a new request is made.
  - When set to `false`, no refetch will be made if there is already a request running.
  - Defaults to `true`

### status

`'error' | 'pending' | 'success'`

- `pending` if there's no cached data and no query attempt was finished yet.
- `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
- `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.
</file>

<file path="site/snippets/core/config-chain-properties.ts">
import { http, createConfig } from '@wagmi/core'
import { base, celo, mainnet } from '@wagmi/core/chains'

export const config = createConfig({
  chains: [base, celo, mainnet],
  transports: {
    [base.id]: http(),
    [celo.id]: http(),
    [mainnet.id]: http(),
  },
})
</file>

<file path="site/snippets/core/config.ts">
import { http, createConfig } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
</file>

<file path="site/snippets/react/app.tsx">
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import * as React from 'react'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

export const queryClient = new QueryClient()

export function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        {/** ... */}
      </QueryClientProvider>
    </WagmiProvider>
  )
}
</file>

<file path="site/snippets/react/config-chain-properties.ts">
import { http, createConfig } from 'wagmi'
import { base, celo, mainnet } from 'wagmi/chains'

export const config = createConfig({
  chains: [base, celo, mainnet],
  transports: {
    [base.id]: http(),
    [celo.id]: http(),
    [mainnet.id]: http(),
  },
})

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
</file>

<file path="site/snippets/react/config.ts">
import { http, createConfig } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
</file>

<file path="site/snippets/vue/App.vue">
<script setup lang="ts">
</script>

<template>
</template>
</file>

<file path="site/snippets/vue/config-chain-properties.ts">
import { http, createConfig } from '@wagmi/vue'
import { base, celo, mainnet } from '@wagmi/vue/chains'

export const config = createConfig({
  chains: [base, celo, mainnet],
  transports: {
    [base.id]: http(),
    [celo.id]: http(),
    [mainnet.id]: http(),
  },
})

declare module '@wagmi/vue' {
  interface Register {
    config: typeof config
  }
}
</file>

<file path="site/snippets/vue/config.ts">
import { http, createConfig } from '@wagmi/vue'
import { mainnet, sepolia } from '@wagmi/vue/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
</file>

<file path="site/snippets/vue/main.ts">
import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
import { WagmiPlugin } from '@wagmi/vue'
import { createApp } from 'vue'

import App from './App.vue'
import { config } from './config'

export const queryClient = new QueryClient()

createApp(App)
  .use(WagmiPlugin, { config })
  .use(VueQueryPlugin, { queryClient })
  .mount('#app')
</file>

<file path="site/snippets/abi-event.ts">
export const abi = [
  {
    type: 'event',
    name: 'Approval',
    inputs: [
      { indexed: true, name: 'owner', type: 'address' },
      { indexed: true, name: 'spender', type: 'address' },
      { indexed: false, name: 'value', type: 'uint256' },
    ],
  },
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      { indexed: true, name: 'from', type: 'address' },
      { indexed: true, name: 'to', type: 'address' },
      { indexed: false, name: 'value', type: 'uint256' },
    ],
  },
] as const
</file>

<file path="site/snippets/abi-infinite-read.ts">
export const abi = [
  {
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    name: 'getChest',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    name: 'getFoot',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    name: 'getHand',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const
</file>

<file path="site/snippets/abi-read.ts">
export const abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: 'supply', type: 'uint256' }],
  },
] as const
</file>

<file path="site/snippets/abi-write.ts">
export const abi = [
  {
    type: 'function',
    name: 'approve',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'sender', type: 'address' },
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
] as const
</file>

<file path="site/snippets/typedData.ts">
import type { TypedData } from 'viem'

export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const satisfies TypedData
</file>

<file path="site/vue/api/composables/useAccount.md">
---
title: useAccount
description: Composable for getting current account.
---

# useAccount

Composable for getting current account.

## Import

```ts
import { useAccount } from '@wagmi/vue'
```

## Usage

::: code-group
```vue twoslash [index.vue]
<script setup lang="ts">
// ---cut-start---
// @errors: 2322
import { type Config } from '@wagmi/vue'
import { mainnet, sepolia } from '@wagmi/vue/chains'

declare module '@wagmi/vue' {
  interface Register {
    config: Config<readonly [typeof mainnet, typeof sepolia]>
  }
}
// ---cut-end---
import { useAccount } from '@wagmi/vue'

const account = useAccount()
</script>

<template>
  Address: {{ account.address }}
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts twoslash
import { type UseAccountParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useAccount } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const account = useAccount({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Return Type

```ts twoslash
import { type UseAccountReturnType } from '@wagmi/vue'
```

<!--@include: @shared/getAccount-return-type.md-->

## Action

- [`getAccount`](/core/api/actions/getAccount)
</file>

<file path="site/vue/api/composables/useAccountEffect.md">
---
title: useAccountEffect
description: Composable for listening to account lifecycle events.
---

# useAccountEffect

Composable for listening to account lifecycle events.

## Import

```ts
import { useAccountEffect } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useAccountEffect } from '@wagmi/vue'

useAccountEffect({
  onConnect(data) {
    console.log('Connected!', data)
  },
  onDisconnect() {
    console.log('Disconnected!')
  },
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type useAccountEffectParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useAccountEffect } from '@wagmi/vue'
import { config } from './config' // [!code focus]

useAccountEffect({
  config, // [!code focus]
  onConnect(data) {
    console.log('Connected!', data)
  },
  onDisconnect() {
    console.log('Disconnected!')
  },
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### onConnect

`` MaybeRef<((data: { address: `0x${string}`; addresses: readonly [`0x${string}`, ...`0x${string}`[]]; chain: Chain | undefined chainId: number; connector: Connector; isReconnected: boolean }) => void)> | undefined ``

Callback that is called when accounts are connected.

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from '@wagmi/vue'

function App() {
  useAccountEffect({
    onConnect(data) { // [!code focus]
      console.log('Connected!', data) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### onDisconnect

`MaybeRef<(() => void)> | undefined`

Callback that is called when no more accounts are connected.

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from '@wagmi/vue'

function App() {
  useAccountEffect({
    onDisconnect() { // [!code focus]
      console.log('Disconnected!') // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Action

- [`getAccount`](/core/api/actions/getAccount)
- [`watchAccount`](/core/api/actions/watchAccount)
</file>

<file path="site/vue/api/composables/useBalance.md">
---
title: useBalance
description: Composable for fetching native currency or token balance.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getBalance'
const typeName = 'GetBalance'
const TData = '{ decimals: number; formatted: string; symbol: string; value: bigint; }'
const TError = 'GetBalanceErrorType'
</script>

# useBalance

Composable for fetching native currency or token balance.

## Import

```ts
import { useBalance } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBalanceParameters } from '@wagmi/vue'
```

### address

`Address | undefined`

Address to get balance for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get balance at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockNumber: 17829139n, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockTag: 'latest', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains' // [!code focus]

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  chainId: mainnet.id, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### token

`Address | undefined`

ERC-20 token address to get balance for.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### unit

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  unit: 'ether', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBalanceReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBalance`](/core/api/actions/getBalance)
</file>

<file path="site/vue/api/composables/useBlockNumber.md">
---
title: useBlockNumber
description: Composable for fetching the number of the most recent block seen.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getBlockNumber'
const typeName = 'GetBlockNumber'
const TData = 'bigint'
const TError = 'GetBlockNumberErrorType'
</script>

# useBlockNumber

Composable for fetching the number of the most recent block seen.

## Import

```ts
import { useBlockNumber } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'

const { data: blockNumber } = useBlockNumber()
</script>

<template>
  Block Number: {{ blockNumber }}
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockNumberParameters } from '@wagmi/vue'
```

### cacheTime

`MaybeRef<number> | undefined`

Time in milliseconds that cached block number will remain in memory.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'

const { data: blockNumber } = useBlockNumber({
  cacheTime: 4_000 // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### chainId

`MaybeRef<config['chains'][number]['id']> | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains' // [!code focus]

const { data: blockNumber } = useBlockNumber({
  chainId: mainnet.id, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const { data: blockNumber } = useBlockNumber({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`MaybeRef<string> | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'

const { data: blockNumber } = useBlockNumber({
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### watch

`MaybeRef<boolean | UseWatchBlockNumberParameters> | undefined`

- Enables/disables listening for block number changes.
- Can pass a subset of [`UseWatchBlockNumberParameters`](/vue/api/composables/useWatchBlockNumber#parameters) directly to [`useWatchBlockNumber`](/vue/api/composables/useWatchBlockNumber).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'

const { data: blockNumber } = useBlockNumber({
  watch: true, // [!code focus]
})
</script>
```

```vue [index-2.vue]
<script setup lang="ts">
import { useBlockNumber } from '@wagmi/vue'

const { data: blockNumber } = useBlockNumber({
  watch: { // [!code focus]
    pollingInterval: 4_000 // [!code focus]
  }, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockNumberReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlockNumber`](/core/api/actions/getBlockNumber)
- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="site/vue/api/composables/useBytecode.md">
---
title: useBytecode
description: Composable for retrieving the bytecode at an address.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getBytecode'
const typeName = 'GetBytecode'
const TData = 'GetBytecodeData'
const TError = 'GetBytecodeErrorType'
</script>

# useBytecode

Composable for retrieving the bytecode at an address.

## Import

```ts
import { useBytecode } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBytecodeParameters } from '@wagmi/vue'
```

### address

`Address | undefined`

The contract address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the bytecode at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockNumber: 16280770n, // [!code focus]
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockTag: 'safe', // [!code focus]
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains'

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  chainId: mainnet.id, // [!code focus]
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  config, // [!code focus]
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useBytecode } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const { data: byteCode } = useBytecode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  scopeKey: 'foo', // [!code focus]
})
</script>

<template>
  Byte Code: {{ byteCode }}
</template>
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBytecodeReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBytecode`](/core/api/actions/getBytecode)
</file>

<file path="site/vue/api/composables/useChainId.md">
---
title: useChainId
description: Composable for getting current chain ID.
---

# useChainId

Composable for getting current chain ID.

## Import

```ts
import { useChainId } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useChainId } from '@wagmi/vue'

const chainId = useChainId()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseChainIdParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useChainId } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const chainId = useChainId({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseChainIdReturnType } from '@wagmi/vue'
```

`number`

Current chain ID from [`config.state.chainId`](/vue/api/createConfig#chainid).

::: info
Only returns chain IDs for chains configured via `createConfig`'s [`chains`](/vue/api/createConfig#chains) parameter.

If the active [connection](/vue/api/createConfig#connection) [`chainId`](/vue/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `useChainId` will return the last configured chain ID.
:::

## Action

- [`getChainId`](/core/api/actions/getChainId)
- [`watchChainId`](/core/api/actions/watchChainId)
</file>

<file path="site/vue/api/composables/useChains.md">
---
title: useChains
description: Composable for getting configured chains
---

# useChains

Composable for getting configured chains

## Import

```ts
import { useChains } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useChains } from '@wagmi/vue'

const chains = useChains()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseChainsParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useChains } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const chains = useChains({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseChainsReturnType } from '@wagmi/vue'
```

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](/vue/api/createConfig#chains).

## Action

- [`getChains`](/core/api/actions/getChains)
</file>

<file path="site/vue/api/composables/useClient.md">
---
title: useClient
description: Composable for getting Viem `Client` instance.
---

# useClient

Composable for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Import

```ts
import { useClient } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useClient } from '@wagmi/vue'

const client = useClient()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseClientParameters } from '@wagmi/vue'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useClient } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains' // [!code focus]
import { config } from './config'

const client = useClient({
  chainId: mainnet.id, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useClient } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const client = useClient({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseClientReturnType } from '@wagmi/vue'
```

`Client | undefined`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Action

- [`getClient`](/core/api/actions/getClient)
- [`watchClient`](/core/api/actions/watchClient)
</file>

<file path="site/vue/api/composables/useConfig.md">
---
title: useConfig
description: Composable for getting `Config` from the `WagmiPlugin`.
---

# useConfig

Composable for getting [`Config`](/vue/api/createConfig#config) from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

## Import

```ts
import { useConfig } from 'wagmi'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConfig } from 'wagmi'

const config = useConfig()
</script>
```

:::

## Return Type

```ts
import { type UseConfigReturnType } from 'wagmi'
```
</file>

<file path="site/vue/api/composables/useConnect.md">
---
title: useConnect
description: Composable for connecting accounts with connectors.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'connect'
const typeName = 'Connect'
const mutate = 'connect'
const TData = '{ accounts: readonly [Address, ...Address[]]; chainId: number; }'
const TError = 'ConnectErrorType'
const TVariables = '{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }'
</script>

# useConnect

Composable for connecting accounts with [connectors](/vue/api/connectors).

## Import

```ts
import { useConnect } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnect } from '@wagmi/vue'
import { injected } from '@wagmi/connectors'

const { connect } = useConnect()
</script>

<template>
  <button @click="connect({ connector: injected() })">
    Connect
  </button>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnect } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useConnect({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseConnectReturnType } from '@wagmi/vue'
```

### connectors

`readonly Connector[]`

Globally configured connectors via [`createConfig`](/vue/api/createConfig#connectors). Useful for rendering a list of available connectors.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnect } from '@wagmi/vue'

const { connect, connectors } = useConnect()
</script>

<template>
  <div>
    <button v-for="connector in connectors" :key="connector.id" @click="connect({ connector })">
      {{ connector.name }}
    </button>
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

::: tip
Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider (e.g. wallet) is connected to.
:::

<!--@include: @shared/mutation-imports.md-->

## Action

- [`connect`](/core/api/actions/connect)
</file>

<file path="site/vue/api/composables/useConnections.md">
---
title: useConnections
description: Composable for getting active connections.
---

# useConnections

Composable for getting active connections.

## Import

```ts
import { useConnections } from 'wagmi'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnections } from 'wagmi'

const connections = useConnections()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectionsParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnections } from 'wagmi'
import { config } from './config' // [!code focus]

const connections = useConnections({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseConnectionsReturnType } from 'wagmi'
```

## Action

- [`getConnections`](/core/api/actions/getConnections)
- [`watchConnections`](/core/api/actions/watchConnections)
</file>

<file path="site/vue/api/composables/useConnectorClient.md">
---
title: useConnectorClient
description: Composable for getting a Viem `Client` object for the current or provided connector.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getConnectorClient'
const typeName = 'GetConnectorClient'
const TData = 'Client'
const TError = 'GetConnectorClientErrorType'
const hideQueryOptions = ['gcTime', 'staleTime']
</script>

# useConnectorClient

Composable for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Import

```ts
import { useConnectorClient } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnectorClient } from '@wagmi/vue'

const result = useConnectorClient()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectorClientParameters } from '@wagmi/vue'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

```vue
<script setup lang="ts">
import { useConnectorClient } from '@wagmi/vue'

const result = useConnectorClient({
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
</script>
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

```vue
<script setup lang="ts">
import { useConnectorClient } from '@wagmi/vue'

const result = useConnectorClient({
  chainId: mainnet.id, // [!code focus]
})
</script>
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnectorClient } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useConnectorClient({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

```vue
<script setup lang="ts">
import { useConnections, useConnectorClient } from '@wagmi/vue'

const connections = useConnections(config)
const result = useConnectorClient({
  connector: connections[0]?.connector, // [!code focus]
})
</script>
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseConnectorClientReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getConnectorClient`](/core/api/actions/getConnectorClient)
</file>

<file path="site/vue/api/composables/useConnectors.md">
---
title: useConnectors
description: Composable for getting configured connectors.
---

# useConnectors

Composable for getting configured connectors.

## Import

```ts
import { useConnectors } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnectors } from '@wagmi/vue'

const connectors = useConnectors()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseConnectorsReturnType } from '@wagmi/vue'
```

`readonly Connector[]`

Connectors from [`config.connectors`](/vue/api/createConfig#connectors-1).

## Action

- [`getConnectors`](/core/api/actions/getConnectors)
</file>

<file path="site/vue/api/composables/useDisconnect.md">
---
title: useDisconnect
description: Composable for disconnecting connections.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'disconnect'
const typeName = 'Disconnect'
const mutate = 'disconnect'
const TData = 'void'
const TError = 'DisconnectErrorType'
const TVariables = '{ connector?: Connector | undefined; }'
</script>

# useDisconnect

Composable for disconnecting connections.

## Import

```ts
import { useDisconnect } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useDisconnect } from '@wagmi/vue'

const { disconnect } = useDisconnect()
</script>

<template>
  <button @click="disconnect()">
    Disconnect
  </button>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseDisconnectParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useDisconnect } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useDisconnect({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseDisconnectReturnType } from '@wagmi/vue'
```

### connectors

`readonly Connector[]`

Connectors that are currently connected. Useful for rendering a list of connectors to disconnect.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useDisconnect } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains'

const { connectors, disconnect } = useDisconnect()
</script>

<template>
  <div>
    <button v-for="connector in connectors" :key="connector.id" @click="disconnect({ connector })">
      {{ connector.name }}
    </button>
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`disconnect`](/core/api/actions/connect)
</file>

<file path="site/vue/api/composables/useEnsAddress.md">
---
title: useEnsAddress
description: Composable for fetching ENS address for name.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getEnsAddress'
const typeName = 'GetEnsAddress'
const TData = 'string'
const TError = 'GetEnsAddressErrorType'
</script>

# useEnsAddress

Composable for fetching ENS address for name.

## Import

```ts
import { useEnsAddress } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsAddressParameters } from '@wagmi/vue'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS address at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  name: normalize('wevm.eth'),
  blockTag: 'latest', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains' // [!code focus]
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### coinType

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  coinType: 60, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

const result = useEnsAddress({
  config, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the address for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  name: normalize('wevm.eth'), // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  name: normalize('wevm.eth'),
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAddress } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAddress({
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsAddressReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsAddress`](/core/api/actions/getEnsAddress)
</file>

<file path="site/vue/api/composables/useEnsAvatar.md">
---
title: useEnsAvatar
description: Composable for fetching ENS avatar for name.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getEnsAvatar'
const typeName = 'GetEnsAvatar'
const TData = 'string | null'
const TError = 'GetEnsAvatarErrorType'
</script>

# useEnsAvatar

Composable for fetching ENS avatar for name.

## Import

```ts
import { useEnsAvatar } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsAvatarParameters } from '@wagmi/vue'
```

---

### assetGatewayUrls <Badge text="viem@>=2.3.1" />

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const result = useEnsAvatar({
  assetGatewayUrls: { // [!code focus]
    ipfs: 'https://cloudflare-ipfs.com', // [!code focus]
  }, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Block number to get ENS avatar at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS avatar at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  name: normalize('wevm.eth'),
  blockTag: 'latest', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  chainId: mainnet.id, // [!code focus],
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

const result = useEnsAvatar({
  config, // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### gatewayUrls

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  gatewayUrls: ['https://cloudflare-ipfs.com'], // [!code focus]
  name: normalize('wevm.eth'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the avatar for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  name: normalize('wevm.eth'), // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  name: normalize('wevm.eth'),
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsAvatar } from '@wagmi/vue'
import { normalize } from 'viem/ens'

const result = useEnsAvatar({
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsAvatarReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsAvatar`](/core/api/actions/getEnsAvatar)
</file>

<file path="site/vue/api/composables/useEnsName.md">
---
title: useEnsName
description: Composable for fetching primary ENS name for address.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getEnsName'
const typeName = 'GetEnsName'
const TData = 'string | null'
const TError = 'GetEnsNameErrorType'
</script>

# useEnsName

Composable for fetching primary ENS name for address.

## Import

```ts
import { useEnsName } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEnsNameParameters } from '@wagmi/vue'
```

### address

`Address | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get ENS name at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockNumber: 17829139n, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS name at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockTag: 'latest', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains' // [!code focus]

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  chainId: mainnet.id, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEnsName } from '@wagmi/vue'

const result = useEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsNameReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsName`](/core/api/actions/getEnsName)
</file>

<file path="site/vue/api/composables/useEstimateGas.md">
---
title: useEstimateGas
description: Composable for estimating the gas necessary to complete a transaction without submitting it to the network.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'estimateGas'
const typeName = 'EstimateGas'
const TData = 'bigint'
const TError = 'EstimateGasErrorType'
</script>

# useEstimateGas

Composable for estimating the gas necessary to complete a transaction without submitting it to the network.

## Import

```ts
import { useEstimateGas } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'

const result = useEstimateGas()
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateGasParameters } from '@wagmi/vue'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when estimating gas.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  chainId: mainnet.id, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useConnections, useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const connections = useConnections()
const result = useEstimateGas({
  connector: connections[0]?.connector, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded function data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  gas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  nonce: 123, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  scopeKey: 'foo', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### to

`Address | undefined`

The transaction recipient or contract address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  type: 'eip1559', // [!code focus]
  value: parseEther('0.01'),
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useEstimateGas } from '@wagmi/vue'
import { parseEther } from 'viem'
import { config } from './config'

const result = useEstimateGas({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
  value: parseEther('0.01'), // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateGasReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateGas`](/core/api/actions/estimateGas)
</file>

<file path="site/vue/api/composables/useReadContract.md">
---
title: useReadContract
description: Composable for calling a read-only function on a contract, and returning the response.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'readContract'
const typeName = 'ReadContract'
const TData = 'ReadContractReturnType'
const TError = 'ReadContractErrorType'
</script>

# useReadContract

Composable for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

## Import

```ts
import { useReadContract } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseReadContractParameters } from '@wagmi/vue'
```

### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/vue/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi' // [!code focus]

const result = useReadContract({
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'totalSupply',
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'], // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  blockNumber: 17829139n, // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  blockTag: 'safe', // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  chainId: mainnet.id, // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config' // [!code focus]

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  config, // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf', // [!code focus]
  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReadContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseReadContractReturnType } from '@wagmi/vue'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/vue/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/query-result.md-->

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/vue/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { createConfig, http, useReadContract } from '@wagmi/vue'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const result = useReadContract({
  abi: [
    {
      type: 'function',
      name: 'balanceOf',
      stateMutability: 'view',
      inputs: [{ name: 'account', type: 'address' }],
      outputs: [{ type: 'uint256' }],
    },
    {
      type: 'function',
      name: 'totalSupply',
      stateMutability: 'view',
      inputs: [],
      outputs: [{ name: 'supply', type: 'uint256' }],
    },
  ],
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  // ^?


  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  // ^?



})

result.data
//     ^?
```

```ts twoslash [Const-Asserted]
import { createConfig, http, useReadContract } from '@wagmi/vue'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: 'supply', type: 'uint256' }],
  },
] as const

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  // ^?


  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  // ^?
})

result.data
//     ^?
```
:::

<!--@include: @shared/query-imports.md-->

## Action

- [`readContract`](/core/api/actions/readContract)
</file>

<file path="site/vue/api/composables/useReconnect.md">
---
title: useReconnect
description: Composable for reconnecting connectors.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'reconnect'
const typeName = 'Reconnect'
const mutate = 'reconnect'
const TData = '{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }'
const TError = 'ReconnectErrorType'
const TVariables = '{ connectors?: (CreateConnectorFn | Connector)[] | undefined; }'
</script>

# useReconnect

Composable for reconnecting [connectors](/core/api/connectors).

## Import

```ts
import { useReconnect } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReconnect } from '@wagmi/vue'
import { useEffect } from 'react'

const { reconnect } = useReconnect()

reconnect()
</script>
```

:::

::: tip
When [`WagmiPlugin['reconnectOnMount']`](/vue/api/WagmiPlugin#reconnectonmount) is `true`, `reconnect` is called automatically on mount.
:::

## Parameters

```ts
import { type UseReconnectParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReconnect } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useReconnect({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseReconnectReturnType } from '@wagmi/vue'
```

### connectors

`readonly Connector[]`

Globally configured connectors via [`createConfig`](/vue/api/createConfig#connectors).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useReconnect } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains'

const { reconnect, connectors } = useReconnect()

reconnect({ connectors })
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`reconnect`](/core/api/actions/reconnect)
</file>

<file path="site/vue/api/composables/useSendTransaction.md">
---
title: useSendTransaction
description: Composable for creating, signing, and sending transactions to networks.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'sendTransaction'
const typeName = 'SendTransaction'
const mutate = 'sendTransaction'
const TData = 'SendTransactionData'
const TError = 'SendTransactionErrorType'
const TVariables = 'SendTransactionVariables'
</script>

# useSendTransaction

Composable for creating, signing, and sending transactions to networks.

## Import

```ts
import { useSendTransaction } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSendTransaction } from '@wagmi/vue'
import { parseEther } from 'viem'

const { sendTransaction } = useSendTransaction()
</script>

<template>
  <button
    @click="sendTransaction({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01')
    })"
  >
    Send transaction
  </button>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSendTransactionParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSendTransaction } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useSendTransaction({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSendTransactionReturnType } from '@wagmi/vue'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`sendTransaction`](/core/api/actions/sendTransaction)
</file>

<file path="site/vue/api/composables/useSignMessage.md">
---
title: useSignMessage
description: Composable for signing messages.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'signMessage'
const typeName = 'SignMessage'
const mutate = 'signMessage'
const TData = 'SignMessageData'
const TError = 'SignMessageErrorType'
const TVariables = 'SignMessageVariables'
</script>

# useSignMessage

Composable for signing messages.

## Import

```ts
import { useSignMessage } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSignMessage } from '@wagmi/vue'

const { signMessage } = useSignMessage()
</script>

<template>
  <button @click="signMessage({ message: 'hello world' })">
    Sign message
  </button>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSignMessageParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSignMessage } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const { signMessage } = useSignMessage({
  config // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSignMessageReturnType } from '@wagmi/vue'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`signMessage`](/core/api/actions/signMessage)
</file>

<file path="site/vue/api/composables/useSignTypedData.md">
---
title: useSignTypedData
description: Composable for signing typed data and calculating an Ethereum-specific EIP-712 signature.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'signTypedData'
const typeName = 'SignTypedData'
const mutate = 'signTypedData'
const TData = 'SignTypedDataData'
const TError = 'SignTypedDataErrorType'
const TVariables = 'SignTypedDataVariables'
</script>

# useSignTypedData

Composable for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

## Import

```ts
import { useSignTypedData } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSignTypedData } from '@wagmi/vue'

const { signTypedData } = useSignTypedData()
</script>

<template>
  <button
    @click="signTypedData({
      types: {
        Person: [
          { name: 'name', type: 'string' },
          { name: 'wallet', type: 'address' },
        ],
        Mail: [
          { name: 'from', type: 'Person' },
          { name: 'to', type: 'Person' },
          { name: 'contents', type: 'string' },
        ],
      },
      primaryType: 'Mail',
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })"
  >
    Sign message
  </button>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSignTypedDataParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSignTypedData } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useSignTypedData({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSignTypedDataReturnType } from '@wagmi/vue'
```

<!--@include: @shared/mutation-result.md-->

## Type Inference

With [`types`](/core/api/actions/signTypedData#types) setup correctly, TypeScript will infer the correct types for [`domain`](/core/api/actions/signTypedData#domain), [`message`](/core/api/actions/signTypedData#message), and [`primaryType`](/core/api/actions/signTypedData#primarytype). See the Wagmi [TypeScript docs](/vue/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { useSignTypedData } from '@wagmi/vue'
// ---cut---
const { signTypedData } = useSignTypedData()

signTypedData({
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
```ts twoslash [Const-Asserted]
import { useSignTypedData } from '@wagmi/vue'
// ---cut---
const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const

const { signTypedData } = useSignTypedData()

signTypedData({
  types,
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
:::

<!--@include: @shared/mutation-imports.md-->

## Action

- [`signTypedData`](/core/api/actions/signTypedData)
</file>

<file path="site/vue/api/composables/useSimulateContract.md">
---
title: useSimulateContract
description: Composable for simulating/validating a contract interaction.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'simulateContract'
const typeName = 'SimulateContract'
const TData = 'SimulateContractReturnType'
const TError = 'SimulateContractErrorType'
</script>

# useSimulateContract

Composable for simulating/validating a contract interaction.

## Import

```ts
import { useSimulateContract } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

<!-- TODO: Usage for combining with useWriteContract -->

## Parameters

```ts
import { type UseSimulateContractParameters } from '@wagmi/vue'
```

### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/vue/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi' // [!code focus]

const result = useSimulateContract({
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`). Throws if account is not found on [`connector`](#connector).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
  functionName: 'transferFrom',
  args: [ // [!code focus]
    '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    123n, // [!code focus]
  ], // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  blockNumber: 17829139n, // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  blockTag: 'safe', // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  chainId: mainnet.id, // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config' // [!code focus]

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  config, // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/vue/api/connectors) to simulate transaction with.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useConnectorClient, useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config'

const { data: connector } = useConnectorClient()
const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  connector, // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  dataSuffix: '0xdeadbeef', // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
  functionName: 'transferFrom', // [!code focus]
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gas: parseGwei('20'), // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gasPrice: parseGwei('20'), // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'), // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  nonce: 123, // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  type: 'eip1559', // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  value: parseEther('0.01'), // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.ts]
<script setup lang="ts">
import { useSimulateContract } from '@wagmi/vue'
import { abi } from './abi'
import { config } from './config'

const result = useSimulateContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  scopeKey: 'foo', // [!code focus]
})
</script>
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseSimulateContractReturnType } from '@wagmi/vue'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/vue/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/query-result.md-->

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/vue/typescript) for more information.

<!--@include: @shared/query-imports.md-->

## Action

- [`simulateContract`](/core/api/actions/simulateContract)
</file>

<file path="site/vue/api/composables/useSwitchAccount.md">
---
title: useSwitchAccount
description: Composable for switching the current account.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'switchAccount'
const typeName = 'SwitchAccount'
const mutate = 'switchAccount'
const TData = 'SwitchAccountData'
const TError = 'SwitchAccountErrorType'
const TVariables = 'SwitchAccountVariables'
</script>

# useSwitchAccount

Composable for switching the current account.

## Import

```ts
import { useSwitchAccount } from 'wagmi'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSwitchAccount } from 'wagmi'

const { connectors, switchAccount } = useSwitchAccount()
</script>

<template>
  <div>
    <button 
      v-for="connector in connectors" 
      :key="connector.id" 
      @click="switchAccount({ connector })"
    >
      {{ connector.name }}
    </button>
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSwitchAccountParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSwitchAccount } from 'wagmi'
import { config } from './config' // [!code focus]

const result = useSwitchAccount({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSwitchAccountReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured and actively connected connectors. Useful for rendering a list of available connectors to switch to.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSwitchAccount } from 'wagmi'

const { connectors, switchAccount } = useSwitchAccount()
</script>

<template>
  <div>
    <button 
      v-for="connector in connectors" 
      :key="connector.id" 
      @click="switchAccount({ connector })"
    >
      {{ connector.name }}
    </button>
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`switchAccount`](/core/api/actions/switchAccount)
</file>

<file path="site/vue/api/composables/useSwitchChain.md">
---
title: useSwitchChain
description: Composable for switching the target chain for a connector or the Wagmi `Config`.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'switchChain'
const typeName = 'SwitchChain'
const mutate = 'switchChain'
const TData = 'SwitchChainData'
const TError = 'SwitchChainErrorType'
const TVariables = 'SwitchChainVariables'
</script>

# useSwitchChain

Composable for switching the target chain for a connector or the Wagmi [`Config`](/vue/api/createConfig#config).

## Import

```ts
import { useSwitchChain } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSwitchChain } from '@wagmi/vue'

const { chains, switchChain } = useSwitchChain()
</script>

<template>
  <div>
    <button 
      v-for="chain in chains" 
      :key="chain.id" 
      @click="switchChain({ chainId: chain.id })"
    >
      {{ chain.name }}
    </button>
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

::: tip
When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](/vue/api/createConfig#config).
:::

## Parameters

```ts
import { type UseSwitchChainParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSwitchChain } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useSwitchChain({
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSwitchChainReturnType } from '@wagmi/vue'
```

### chains

`readonly [Chain, ...Chain[]]`

Globally configured chains. Useful for rendering a list of available chains to switch to.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useSwitchChain } from '@wagmi/vue'

const { chains, switchChain } = useSwitchChain()
</script>

<template>
  <div>
    <button 
      v-for="chain in chains" 
      :key="chain.id" 
      @click="switchChain({ chainId: chain.id })"
    >
      {{ chain.name }}
    </button>
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`switchChain`](/core/api/actions/switchChain)
</file>

<file path="site/vue/api/composables/useTransaction.md">
---
title: useTransaction
description: Composable for fetching transactions given hashes or block identifiers.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getTransaction'
const typeName = 'GetTransaction'
const TData = 'GetTransactionData'
const TError = 'GetTransactionErrorType'
</script>

# useTransaction

Composable for fetching transactions given hashes or block identifiers.

## Import

```ts
import { useTransaction } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'

const result = useTransaction({
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionParameters } from '@wagmi/vue'
```

---

### blockHash

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

```vue
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'

const result = useTransaction({
  blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  index: 0,
})
</script>
```

### blockNumber

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

```vue
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'

const result = useTransaction({
  blockNumber: 17829139n, // [!code focus]
  index: 0,
})
</script>
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

```vue
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'

const result = useTransaction({
  blockTag: 'safe', // [!code focus]
  index: 0,
})
</script>
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```vue
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains'

const result = useTransaction({
  chainId: mainnet.id, // [!code focus]
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
</script>
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useTransaction({
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### hash

`` `0x${string}` | undefined ``

Hash to get transaction. [`enabled`](#enabled) set to `false` if `hash` and [`index`](#index) are `undefined`.

```vue
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'

const result = useTransaction({
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
})
</script>
```

### index

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)). [`enabled`](#enabled) set to `false` if `index` and [`hash`](#hash) are `undefined`.

```vue
<script setup lang="ts">
import { useTransaction } from '@wagmi/vue'

const result = useTransaction({
  blockTag: 'safe',
  index: 0  // [!code focus]
})
</script>
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransaction`](/core/api/actions/getTransaction)
</file>

<file path="site/vue/api/composables/useTransactionReceipt.md">
---
title: useTransactionReceipt
description: Composable for return the Transaction Receipt given a Transaction hash.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'getTransactionReceipt'
const typeName = 'GetTransactionReceipt'
const TData = 'GetTransactionReceiptData'
const TError = 'GetTransactionReceiptErrorType'
</script>

# useTransactionReceipt

Composable for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

## Import

```ts
import { useTransactionReceipt } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransactionReceipt } from '@wagmi/vue'

const result = useTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionReceiptParameters } from '@wagmi/vue'
```

### hash

`` `0x${string}` | undefined ``

A transaction hash.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransactionReceipt } from '@wagmi/vue'

const result = useTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransactionReceipt } from '@wagmi/vue'
import { mainnet } from 'wagmi/chains'

const result = useTransactionReceipt({
  chainId: mainnet.id, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransactionReceipt } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useTransactionReceipt({
  config, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useTransactionReceipt } from '@wagmi/vue'
import { config } from './config'

const result = useTransactionReceipt({
  scopeKey: 'foo' // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionReceiptReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionReceipt`](/core/api/actions/getTransactionReceipt)
</file>

<file path="site/vue/api/composables/useWaitForTransactionReceipt.md">
---
title: useWaitForTransactionReceipt
description: Composable that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'waitForTransactionReceipt'
const typeName = 'WaitForTransactionReceipt'
const TData = 'WaitForTransactionReceiptData'
const TError = 'WaitForTransactionReceiptErrorType'
</script>

# useWaitForTransactionReceipt

Composable that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

## Import

```ts
import { useWaitForTransactionReceipt } from '@wagmi/vue'
```

## Usage

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'

const result = useWaitForTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type WaitForTransactionReceiptParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'
import { mainnet } from '@wagmi/vue/chains'

const result = useWaitForTransactionReceipt({
  chainId: mainnet.id, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useWaitForTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  config, // [!code focus]
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### confirmations

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'

const result = useWaitForTransactionReceipt({
  confirmations: 2, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
</script>
```

### onReplaced

`
(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined
`

Optional callback to emit if the transaction has been replaced.

```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'

const result = useWaitForTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  onReplaced: replacement => console.log(replacement), // [!code focus]
})
</script>
```

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/vue/api/createConfig#pollinginterval).

```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'

const result = useWaitForTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  pollingInterval: 1_000, // [!code focus]
})
</script>
```

### hash

`` `0x${string}` | undefined ``

The transaction hash to wait for. [`enabled`](#enabled) set to `false` if `hash` is `undefined`.

```vue [index.vue]
<script setup lang="ts">
import { useWaitForTransactionReceipt } from '@wagmi/vue'

const result = useWaitForTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
})
</script>
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWaitForTransactionReceiptReturnType } from '@wagmi/vue'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`waitForTransactionReceipt`](/core/api/actions/waitForTransactionReceipt)
</file>

<file path="site/vue/api/composables/useWatchBlockNumber.md">
# useWatchBlockNumber

Composable that watches for block number changes.

## Import

```ts
import { useWatchBlockNumber } from '@wagmi/vue'
```

## Usage

::: code-group
```ts [index.vue]
<script setup lang="ts">
import { useWatchBlockNumber } from '@wagmi/vue'

useWatchBlockNumber({
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
</script>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchBlockNumberParameters } from '@wagmi/vue'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

### enabled

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

### onBlockNumber

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

## Return Type

```ts
import { type UseWatchBlockNumberReturnType } from '@wagmi/vue'
```

Function for cleaning up watcher.

## Action

- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="site/vue/api/composables/useWatchContractEvent.md">
# useWatchContractEvent

Composable that watches and returns emitted contract event logs.

## Import

```ts
import { useWatchContractEvent } from '@wagmi/vue'
```

## Usage

::: code-group
```ts [index.vue]
<script setup lang="ts">
import { useWatchContractEvent } from '@wagmi/vue'
import { abi } from './abi'

useWatchContractEvent({
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  abi,
  eventName: 'Transfer',
  onLogs(logs) {
    console.log('New logs!', logs)
  },
})
</script>
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchContractEventParameters } from '@wagmi/vue'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/vue/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

### address

`Address | undefined`

The contract's address.

### args

`object | readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`eventName`](#eventname).

### batch

`boolean | undefined`

- Whether or not the events should be batched on each invocation.
- Defaults to `true`.

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

### eventName

`string`

- Event to listen for the contract.
- Inferred from [`abi`](#abi).

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

### onLogs

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

### strict

`boolean | undefined`

- Defaults to `false`.

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

## Return Type

```ts
import { type UseWatchContractEventReturnType } from '@wagmi/vue'
```

Hook returns `void`

## Action

- [`watchContractEvent`](/core/api/actions/watchContractEvent)
</file>

<file path="site/vue/api/composables/useWriteContract.md">
---
title: useWriteContract
description: Composable for executing a write function on a contract.
---

<script setup>
const packageName = '@wagmi/vue'
const actionName = 'writeContract'
const typeName = 'WriteContract'
const mutate = 'writeContract'
const TData = 'WriteContractReturnType'
const TError = 'WriteContractErrorType'
const TVariables = 'WriteContractVariables'
</script>

# useWriteContract

Composable for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

## Import

```ts
import { useWriteContract } from '@wagmi/vue'
```

## Usage

::: code-group

```vue [index.vue]
<script setup lang="ts">
import { useWriteContract } from '@wagmi/vue'
import { abi } from './abi'

const { writeContract } = useWriteContract()
</script>

<template>
  <button @click="writeContract({ 
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })">
    Transfer
  </button>
</template>
```

<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

<!-- TODO: Usage for simulating before -->

<!-- TODO: Usage for estimating gas before -->

## Parameters

```ts
import { type UseWriteContractParameters } from '@wagmi/vue'
```

### config

`Config | undefined`

[`Config`](/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](/vue/api/WagmiPlugin).

::: code-group

```vue [index.vue]
<script setup lang="ts">
import { useWriteContract } from '@wagmi/vue'
import { config } from './config' // [!code focus]

const result = useWriteContract({
  config, // [!code focus]
})
</script>
```

<<< @/snippets/vue/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWriteContractReturnType } from '@wagmi/vue'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/vue/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/mutation-result.md-->

## Type Inference

With [`abi`](/core/api/actions/writeContract#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](/core/api/actions/writeContract#functionname), [`args`](/core/api/actions/writeContract#args), and the [`value`](/core/api/actions/writeContract##value). See the Wagmi [TypeScript docs](/vue/typescript) for more information.

<!--@include: @shared/mutation-imports.md-->

## Action

- [`writeContract`](/core/api/actions/writeContract)
</file>

<file path="site/vue/api/connectors/coinbaseWallet.md">
<script setup>
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!-- @include: @shared/connectors/coinbaseWallet.md -->
</file>

<file path="site/vue/api/connectors/injected.md">
<script setup>
const docsPath = 'vue'
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!-- @include: @shared/connectors/injected.md -->
</file>

<file path="site/vue/api/connectors/metaMask.md">
<script setup>
const docsPath = 'vue'
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!-- @include: @shared/connectors/metaMask.md -->
</file>

<file path="site/vue/api/connectors/mock.md">
<script setup>
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!-- @include: @shared/connectors/mock.md -->
</file>

<file path="site/vue/api/connectors/safe.md">
<script setup>
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!-- @include: @shared/connectors/safe.md -->
</file>

<file path="site/vue/api/connectors/walletConnect.md">
<script setup>
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!-- @include: @shared/connectors/walletConnect.md -->
</file>

<file path="site/vue/api/transports/custom.md">
<script setup>
const packageName = '@wagmi/vue'
</script>

<!-- @include: @shared/transports/custom.md -->
</file>

<file path="site/vue/api/transports/fallback.md">
<script setup>
const packageName = '@wagmi/vue'
</script>

<!-- @include: @shared/transports/fallback.md -->
</file>

<file path="site/vue/api/transports/http.md">
<script setup>
const packageName = '@wagmi/vue'
</script>

<!-- @include: @shared/transports/http.md -->
</file>

<file path="site/vue/api/transports/unstable_connector.md">
<script setup>
const docsPath = 'vue'
const packageName = '@wagmi/vue'
</script>

<!-- @include: @shared/transports/unstable_connector.md -->
</file>

<file path="site/vue/api/transports/webSocket.md">
<script setup>
const packageName = '@wagmi/vue'
</script>

<!-- @include: @shared/transports/webSocket.md -->
</file>

<file path="site/vue/api/utilities/deserialize.md">
<script setup>
const packageName = '@wagmi/vue'
</script>

<!--@include: @shared/utilities/deserialize.md-->
</file>

<file path="site/vue/api/utilities/serialize.md">
<script setup>
const packageName = '@wagmi/vue'
</script>

<!--@include: @shared/utilities/serialize.md-->
</file>

<file path="site/vue/api/actions.md">
# Actions

Sometimes the declarative nature of Vue Composables doesn't work for parts of your app. For those cases, you can use Wagmi Core Actions directly!

All the Wagmi Core Actions are importable using the `@wagmi/vue/actions` entrypoint. For example, you can use the `watchBlockNumber` action to watch for block number changes.

::: code-group
```vue [index.vue]
<script setup lang="ts">
import { watchEffect } from 'vue'
import { useConfig } from '@wagmi/vue'
import { watchBlockNumber } from '@wagmi/vue/actions'

const config = useConfig()

watchEffect((onCleanup) => {
  const unwatch = watchBlockNumber(config, {
    onBlockNumber(blockNumber) {
      console.log('Block number changed!', blockNumber)
    },
  })

  onCleanup(unwatch)
})
</script>
```
<<< @/snippets/react/config.ts[config.ts]
:::

See the [Wagmi Core docs](/core/api/actions) for more info on what actions are available.
</file>

<file path="site/vue/api/chains.md">
<script setup>
import packageJson from '../../../package.json'
import SearchChains from '../../components/SearchChains.vue'

const viemVersion = packageJson.devDependencies.viem
</script>

# Chains

Viem `Chain` objects. More info at the [Viem docs](https://viem.sh/docs/chains/introduction).

## Import

Import via the `'@wagmi/vue/chains'` entrypoint (proxies all chains from `'viem/chains'`).

```ts
import { mainnet } from '@wagmi/vue/chains'
```

## Available Chains

Chain definitions as of `viem@{{viemVersion}}`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

<SearchChains />

<!--@include: @shared/create-chain.md-->
</file>

<file path="site/vue/api/composables.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const composables = getSidebar()['/vue']
  .find(x => x.text === 'Composables').items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Composables

Vue Composables for accounts, wallets, contracts, transactions, signing, ENS, and more.

## Import

```ts
import { useAccount } from '@wagmi/vue'
```

## Available Composables

<ul>
  <li v-for="composable of composables">
    <a :href="composable.link">{{ composable.text }}</a>
  </li>
</ul>
</file>

<file path="site/vue/api/connectors.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const connectors = getSidebar()['/react']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Connectors')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Connectors

Connectors for popular wallet providers and protocols.

## Import

Import via the `'@wagmi/vue/connectors'` entrypoint.

```ts
import { injected } from '@wagmi/vue/connectors'
```

## Available Connectors

<ul>
  <li v-for="connector of connectors">
    <a :href="connector.link">{{ connector.text }}</a>
  </li>
</ul>
</file>

<file path="site/vue/api/createConfig.md">
<script setup>
const docsPath = 'vue'
const packageName = '@wagmi/vue'
const connectorsPackageName = '@wagmi/vue/connectors'
</script>

<!--@include: @shared/createConfig.md-->
</file>

<file path="site/vue/api/createStorage.md">
<script setup>
const docsPath = "vue"
const packageName = '@wagmi/vue'
</script>

<!--@include: @shared/createStorage.md-->
</file>

<file path="site/vue/api/errors.md">
<script setup>
const docsPath = "vue"
const packageName = '@wagmi/vue'
</script>

# Errors

Error classes used by Wagmi.

<!--@include: @shared/errors.md-->
</file>

<file path="site/vue/api/Nuxt.md">
# Nuxt

[Nuxt Module](https://nuxt.com/docs/guide/concepts/modules) for Wagmi. Adds all [Composables](/vue/api/composables) as [auto-imports](https://nuxt.com/docs/guide/concepts/auto-imports).

## Usage

::: code-group
```ts twoslash [nuxt.config.ts]
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  modules: ['@wagmi/vue/nuxt'],
})
```
```vue [index.vue]
<script setup lang="ts">
// No need to import `useAccount`! // [!code focus]
const account = useAccount() // [!code focus]
</script>

<template>
  Address: {{ account.address }}
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::
</file>

<file path="site/vue/api/transports.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const transports = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Transports')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Transports

[`createConfig`](/vue/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

## Import

```ts
import { http } from '@wagmi/vue'
```

## Built-In Transports

Available via the `'@wagmi/vue'` entrypoint.

<ul>
  <li v-for="transport of transports">
    <a :href="transport.link">{{ transport.text }}</a>
  </li>
</ul>
</file>

<file path="site/vue/api/WagmiPlugin.md">
# WagmiPlugin

[Vue Plugin](https://vuejs.org/guide/reusability/plugins.html#plugins) for Wagmi.

## Import

```ts
import { WagmiPlugin } from '@wagmi/vue'
```

## Usage

::: code-group
```ts [main.ts]
import { createApp } from 'vue'
import { WagmiPlugin } from '@wagmi/vue'

import App from './App.vue'
import { config } from './config' 

createApp(App)
  .use(WagmiPlugin, { config })
  .mount('#app')
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## Parameters

```ts
import { type WagmiPluginProps } from '@wagmi/vue'
```

### config

[`Config`](/vue/api/createConfig#config) object to inject with context.

::: code-group
```ts [main.ts]
import { createApp } from 'vue'
import { WagmiPlugin } from '@wagmi/vue'

import App from './App.vue'
import { config } from './config' 

createApp(App)
  .use(WagmiPlugin, { 
    config // [!code focus]
  })
  .mount('#app')
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### initialState

`State | undefined`

- Initial state to hydrate into the [Wagmi Config](/vue/api/createConfig). Useful for SSR.

::: code-group
```ts [main.ts]
import { createApp } from 'vue'
import { WagmiPlugin } from '@wagmi/vue'

import App from './App.vue'
import { config } from './config' 

createApp(App)
  .use(WagmiPlugin, { 
    config,
    initialState: /* ... */ // [!code focus]
  })
  .mount('#app')
```
<<< @/snippets/vue/config.ts[config.ts]
:::

### reconnectOnMount

`boolean | undefined`

- Whether or not to reconnect previously connected [connectors](/vue/api/createConfig#connectors) on mount.
- Defaults to `true`.

::: code-group
```ts [main.ts]
import { createApp } from 'vue'
import { WagmiPlugin } from '@wagmi/vue'

import App from './App.vue'
import { config } from './config' 

createApp(App)
  .use(WagmiPlugin, { 
    config,
    reconnectOnMount: false // [!code focus]
  })
  .mount('#app')
```
<<< @/snippets/vue/config.ts[config.ts]
:::

## configKey

Key to use to provide/inject `Config` via `WagmiPlugin`.

```ts
import { configKey, type Config } from '@wagmi/vue'
import { inject } from 'vue'

inject<Config | undefined>(configKey)
```
</file>

<file path="site/vue/guides/chain-properties.md">
# Chain Properties

Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains support all support additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

<br/>

::: tip
Make sure you follow the TypeScript guide's [Config Types](/vue/typescript#config-types) section before moving on. The easiest way to do this is to use [Declaration Merging](/vue/typescript#declaration-merging) to "register" your `config` globally with TypeScript.

<<< @/snippets/vue/config-chain-properties.ts[config.ts]
:::

## Narrowing Parameters

Once your Config is registered with TypeScript, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

::: code-group
```ts [index.tsx]
import { parseEther } from 'viem'
import { useSimulateContract } from '@wagmi/vue'

const result = useSimulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  feeCurrency: '0x‚Ä¶', // [!code focus]
})
```
<<< @/snippets/vue/config-chain-properties.ts[config.ts]
:::

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

::: code-group
```ts [index.tsx]
import { parseEther } from 'viem'
import { useSimulateContract } from '@wagmi/vue'
import { celo } from '@wagmi/vue/chains'

const result = useSimulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  chainId: celo.id, // [!code focus]
  feeCurrency: '0x‚Ä¶', // [!code focus]
  // ^? (property) feeCurrency?: `0x${string}` | undefined // [!code focus]
})
```
<<< @/snippets/vue/config-chain-properties.ts[config.ts]
:::

## Narrowing Return Types

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

::: code-group
```ts [index.tsx]
import { useWaitForTransactionReceipt } from '@wagmi/vue'
import { zkSync } from '@wagmi/vue/chains'

const { data } = useWaitForTransactionReceipt({
  chainId: zkSync.id,
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

data?.logs
//    ^? (property) logs: ZkSyncLog[] | undefined
```
<<< @/snippets/vue/config-chain-properties.ts[config.ts]
:::

### `chainId` Data Property

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

::: code-group
```ts [index.tsx]
import { useWaitForTransactionReceipt } from '@wagmi/vue'
import { zkSync } from '@wagmi/vue/chains'

const { data } = useWaitForTransactionReceipt({
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

if (data?.chainId === zkSync.id) {
  data?.logs
  //    ^? (property) logs: ZkSyncLog[] | undefined
}
```
<<< @/snippets/vue/config-chain-properties.ts[config.ts]
:::

## Troubleshooting

If chain properties aren't working, make sure [TypeScript](/vue/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).
</file>

<file path="site/vue/guides/connect-wallet.md">
# Connect Wallet

The ability for a user to connect their wallet is a core function for any Dapp. It allows users to perform tasks such as: writing to contracts, signing messages, or sending transactions.

Wagmi contains everything you need to get started with building a Connect Wallet module. To get started, you can either use a [third-party library](#third-party-libraries) or [build your own](#build-your-own).

## Third-party Libraries

You can use a pre-built Connect Wallet module from a third-party library such as:

- [AppKit](https://walletconnect.com/appkit) - [Guide](https://docs.walletconnect.com/appkit/vue/core/installation)

The above libraries are all built on top of Wagmi, handle all the edge cases around wallet connection, and provide a seamless Connect Wallet UX that you can use in your Dapp.

## Build Your Own

Wagmi provides you with the Composables to get started building your own Connect Wallet module. 

It takes less than five minutes to get up and running with Browser Wallets, WalletConnect, and Coinbase Wallet.

### 1. Configure Wagmi

Before we get started with building the functionality of the Connect Wallet module, we will need to set up the Wagmi configuration.

Let's create a `config.ts` file and export a `config` object.

::: code-group

```tsx [config.ts]
import { http, createConfig } from '@wagmi/vue'
import { base, mainnet, optimism } from '@wagmi/vue/chains'
import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

In the above configuration, we want to set up connectors for Injected (browser), WalletConnect (browser + mobile), MetaMask, and Safe wallets. This configuration uses the **Mainnet** and **Base** chains, but you can use whatever you want.

::: warning

Make sure to replace the `projectId` with your own WalletConnect Project ID, if you wish to use WalletConnect! 

[Get your Project ID](https://cloud.walletconnect.com/)

:::

### 2. Inject the WagmiPlugin onto your App

Next, we will need to inject our App with plugins so that our application is aware of Wagmi & Vue Query's reactive state and in-memory caching.

::: code-group

```ts [main.ts]
// 1. Import modules.
import { VueQueryPlugin } from '@tanstack/vue-query';
import { WagmiPlugin } from '@wagmi/vue';
import { createApp } from 'vue';

import App from './App.vue';
import { config } from './wagmi';

createApp(App)
  // 2. Inject the Wagmi plugin.
  .use(WagmiPlugin, { config })
  // 3. Inject the Vue Query plugin.
  .use(VueQueryPlugin, {})
  .mount('#app');
```

```vue [App.vue]
<script setup lang="ts">
</script>

<template>
</template>
```

```ts [config.ts]
import { http, createConfig } from '@wagmi/vue'
import { base, mainnet, optimism } from '@wagmi/vue/chains'
import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 3. Display Wallet Options

After that, we will create a `Connect` component that will display our connectors. This will allow users to select a wallet and connect.

Below, we are rendering a list of `connectors` retrieved from `useConnect`. When the user clicks on a connector, the `connect` function will connect the users' wallet.

::: code-group

```vue [Connect.vue]
<script setup lang="ts">
import { useConnect, useChainId } from '@wagmi/vue';

const chainId = useChainId();
const { connectors, connect } = useConnect();
</script>

<template>
  <button
    v-for="connector in connectors"
    @click="connect({ connector, chainId })"
  >
    {{ connector.name }}
  </button>
</template>
```

```vue [App.vue]
<script setup lang="ts">
</script>

<template>
</template>
```

```ts [main.ts]
// 1. Import modules.
import { VueQueryPlugin } from '@tanstack/vue-query';
import { WagmiPlugin } from '@wagmi/vue';
import { createApp } from 'vue';

import App from './App.vue';
import { config } from './wagmi';

createApp(App)
  // 2. Inject the Wagmi plugin.
  .use(WagmiPlugin, { config })
  // 3. Inject the Vue Query plugin.
  .use(VueQueryPlugin, {})
  .mount('#app');
```

```ts [config.ts]
import { http, createConfig } from '@wagmi/vue'
import { base, mainnet, optimism } from '@wagmi/vue/chains'
import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 4. Display Connected Account

Lastly, if an account is connected, we want to show some basic information, like the connected address and ENS name and avatar.

Below, we are using hooks like `useAccount`, `useEnsAvatar` and `useEnsName` to extract this information.

We are also utilizing `useDisconnect` to show a "Disconnect" button so a user can disconnect their wallet.

::: code-group

```vue [Account.vue]
<script setup lang="ts">
import { useAccount, useDisconnect } from '@wagmi/vue';

const { address, connector } = useAccount();
const { disconnect } = useDisconnect();
</script>

<template>
  <div>Address: {{ address }}</div>
  <div>Connected to {{ connector?.name }} Connector.</div>
  <button @click="disconnect()">Disconnect</button>
</template>
```

```vue [Connect.vue]
<script setup lang="ts">
import { useConnect, useChainId } from '@wagmi/vue';

const chainId = useChainId();
const { connectors, connect } = useConnect();
</script>

<template>
  <button
    v-for="connector in connectors"
    @click="connect({ connector, chainId })"
  >
    {{ connector.name }}
  </button>
</template>
```

```vue [App.vue]
<script setup lang="ts">
</script>

<template>
</template>
```

```ts [main.ts]
// 1. Import modules.
import { VueQueryPlugin } from '@tanstack/vue-query';
import { WagmiPlugin } from '@wagmi/vue';
import { createApp } from 'vue';

import App from './App.vue';
import { config } from './wagmi';

createApp(App)
  // 2. Inject the Wagmi plugin.
  .use(WagmiPlugin, { config })
  // 3. Inject the Vue Query plugin.
  .use(VueQueryPlugin, {})
  .mount('#app');
```

```ts [config.ts]
import { http, createConfig } from '@wagmi/vue'
import { base, mainnet, optimism } from '@wagmi/vue/chains'
import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 5. Wire it up!

Finally, we can wire up our Connect and Account components to our application's entrypoint.

::: code-group

```vue [App.vue]
<script setup lang="ts">
import { useAccount } from '@wagmi/vue';
import Account from './Account.vue'; // [!code ++]
import Connect from './Connect.vue'; // [!code ++]

const { isConnected } = useAccount();
</script>

<template>
  <Account v-if="isConnected" /> // [!code ++]
  <Connect v-else /> // [!code ++]
</template>

```

```vue [Account.vue]
<script setup lang="ts">
import { useAccount, useDisconnect } from '@wagmi/vue';

const { address, connector } = useAccount();
const { disconnect } = useDisconnect();
</script>

<template>
  <div>Address: {{ address }}</div>
  <div>Connected to {{ connector?.name }} Connector.</div>
  <button @click="disconnect()">Disconnect</button>
</template>
```

```vue [Connect.vue]
<script setup lang="ts">
import { useConnect, useChainId } from '@wagmi/vue';

const chainId = useChainId();
const { connectors, connect } = useConnect();
</script>

<template>
  <button
    v-for="connector in connectors"
    @click="connect({ connector, chainId })"
  >
    {{ connector.name }}
  </button>
</template>
```

```ts [main.ts]
// 1. Import modules.
import { VueQueryPlugin } from '@tanstack/vue-query';
import { WagmiPlugin } from '@wagmi/vue';
import { createApp } from 'vue';

import App from './App.vue';
import { config } from './wagmi';

createApp(App)
  // 2. Inject the Wagmi plugin.
  .use(WagmiPlugin, { config })
  // 3. Inject the Vue Query plugin.
  .use(VueQueryPlugin, {})
  .mount('#app');
```

```ts [config.ts]
import { http, createConfig } from '@wagmi/vue'
import { base, mainnet, optimism } from '@wagmi/vue/chains'
import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### Playground

Want to see the above steps all wired up together in an end-to-end example? Check out the below StackBlitz playground.

<br/>

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-mf6dgb?embed=1&file=src%2FApp.vue&hideExplorer=1&view=preview"></iframe>
</file>

<file path="site/vue/guides/error-handling.md">
# Error Handling

The `error` property in Wagmi Composables is strongly typed with it's corresponding error type. This enables you to have granular precision with handling errors in your application.

You can discriminate the error type by using the `name` property on the error object.

::: code-group
```vue twoslash [index.vue]
<script setup lang="ts">
// @noErrors
import { useBlockNumber } from 'wagmi'

const { data, error } = useBlockNumber()
//            ^?


error?.name
//     ^?





</script>

<template>
  <div v-if="error?.name === 'HttpRequestError'">
    A HTTP error occurred. Status: {{ error.status }}
//                                          ^?
  </div>

  <div v-else-if="error?.name === 'LimitExceededRpcError'">
    Rate limit exceeded. Code: {{ error.code }}
//                                      ^?
  </div>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::
</file>

<file path="site/vue/guides/faq.md">
<script setup>
const docsPath = 'vue'
</script>

# FAQ / Troubleshooting

Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

<!--@include: @shared/faq.md-->
</file>

<file path="site/vue/guides/read-from-contract.md">
# Read from Contract

## Overview

The [`useReadContract` Composable](/vue/api/composables/useReadContract) allows you to read data on a smart contract, from a `view` or `pure` (read-only) function. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

The component below shows how to retrieve the token balance of an address from the [Wagmi Example](https://etherscan.io/token/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2) contract

:::code-group

```vue [ReadContract.vue]
<script setup lang="ts">
import { useReadContract } from 'wagmi'
import { wagmiContractConfig } from './contracts'

const { data: balance } = useReadContract({
  ...wagmiContractConfig,
  functionName: 'balanceOf',
  args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
})
</script>

<template>
  <div>Balance: {{ balance?.toString() }}</div>
</template>
```
```ts [contracts.ts]
export const wagmiContractConfig = {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: [
    {
      type: 'function',
      name: 'balanceOf',
      stateMutability: 'view',
      inputs: [{ name: 'account', type: 'address' }],
      outputs: [{ type: 'uint256' }],
    },
    {
      type: 'function',
      name: 'totalSupply',
      stateMutability: 'view',
      inputs: [],
      outputs: [{ name: 'supply', type: 'uint256' }],
    },
  ],
} as const
```
:::


If `useReadContract` depends on another value (`address` in the example below), you can use the [`query.enabled`](/vue/api/composables/useReadContract#enabled) option to prevent the query from running until the dependency is ready.

```tsx
const { data: balance } = useReadContract({
  ...wagmiContractConfig,
  functionName: 'balanceOf',
  args: [address],
  query: { // [!code focus]
    enabled: !!address, // [!code focus]
  }, // [!code focus]
})
```


## Loading & Error States

The [`useReadContract` Composable](/vue/api/composables/useReadContract) also returns loading & error states, which can be used to display a loading indicator while the data is being fetched, or an error message if contract execution reverts.

:::code-group

```vue [ReadContract.vue]
<script setup lang="ts">
import { useReadContract } from 'wagmi'

const { 
  data: balance,
  error, // [!code ++]
  isPending // [!code ++]
} = useReadContract({
  ...wagmiContractConfig,
  functionName: 'balanceOf',
  args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
})
</script>

<template>
  <div v-if="isPending">Loading...</div> // [!code ++]

  <div v-else-if="error"> // [!code ++]
    Error: {{ (error as BaseError).shortMessage || error.message }} // [!code ++]
  </div> // [!code ++]

  <div v-else>Balance: {{ balance?.toString() }}</div>
</template>
```

:::

<!-- TODO: ## Refetching On Blocks

The [`useBlockNumber` Hook](/react/api/hooks/useBlockNumber) can be utilized to refetch or [invalidate](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation) the contract data on a specific block interval.

:::code-group
```tsx [read-contract.tsx (refetch)]
import { useEffect } from 'react'
import { useBlockNumber, useReadContract } from 'wagmi'

function ReadContract() {
  const { data: balance, refetch } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })
  const { data: blockNumber } = useBlockNumber({ watch: true })

  useEffect(() => {
    // want to refetch every `n` block instead? use the modulo operator!
    // if (blockNumber % 5 === 0) refetch() // refetch every 5 blocks
    refetch()
  }, [blockNumber])

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
```tsx [read-contract.tsx (invalidate)]
import { useQueryClient } from '@tanstack/react-query'
import { useEffect } from 'react'
import { useBlockNumber, useReadContract } from 'wagmi'

function ReadContract() {
  const queryClient = useQueryClient()
  const { data: balance, refetch } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })
  const { data: blockNumber } = useBlockNumber({ watch: true })

  useEffect(() => {
    // if `useReadContract` is in a different hook/component,
    // you can import `readContractQueryKey` from `'wagmi/query'` and
    // construct a one-off query key to use for invalidation
    queryClient.invalidateQueries({ queryKey })
  }, [blockNumber, queryClient])

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
::: -->

<!-- TODO: ## Calling Multiple Functions

We can use the [`useReadContract` Hook](/react/api/hooks/useReadContract) multiple times in a single component to call multiple functions on the same contract, but this ends up being hard to manage as the number of functions increases, especially when we also want to deal with loading & error states. 

Luckily, to make this easier, we can use the [`useReadContracts` Hook](/react/api/hooks/useReadContracts) to call multiple functions in a single call.

:::code-group

```tsx [read-contract.tsx]
import { type BaseError, useReadContracts } from 'wagmi'

function ReadContract() {
  const { 
    data,
    error,
    isPending
  } = useReadContracts({ 
    contracts: [{ 
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
    }, { 
      ...wagmiContractConfig, 
      functionName: 'ownerOf', 
      args: [69n], 
    }, { 
      ...wagmiContractConfig, 
      functionName: 'totalSupply', 
    }] 
  }) 
  const [balance, ownerOf, totalSupply] = data || [] 

  if (isPending) return <div>Loading...</div>

  if (error)
    return (
      <div>
        Error: {(error as BaseError).shortMessage || error.message}
      </div>
    ) 

  return (
    <>
      <div>Balance: {balance?.toString()}</div>
      <div>Owner of Token 69: {ownerOf?.toString()}</div> 
      <div>Total Supply: {totalSupply?.toString()}</div> 
    </>
  )
}
```

::: -->
</file>

<file path="site/vue/guides/send-transaction.md">
# Send Transaction

The following guide teaches you how to send transactions in Wagmi. The example below builds on the [Connect Wallet guide](/vue/guides/connect-wallet) and uses the [useSendTransaction](/vue/api/composables/useSendTransaction) & [useWaitForTransaction](/vue/api/composables/useWaitForTransactionReceipt) composables. 

## Example

Feel free to check out the example before moving on:

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-wkaruk?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>

## Steps

### 1. Connect Wallet 

Follow the [Connect Wallet guide](/vue/guides/connect-wallet) guide to get this set up.

### 2. Create a new component

Create your `SendTransaction` component that will contain the send transaction logic.

::: code-group

```tsx [SendTransaction.vue]
<script setup lang="ts">
</script>

<template>
  <form>
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button type="submit">Send</button>
  </form>
</template>
```

:::

### 3. Add a form handler

Next, we will need to add a handler to the form that will send the transaction when the user hits "Send". This will be a basic handler in this step.

::: code-group

```vue [SendTransaction.vue]
<script setup lang="ts">
  function submit(event: Event) { // [!code ++]
    const formData = new FormData(event.target as HTMLFormElement) // [!code ++]
    const to = formData.get('address') as `0x${string}` // [!code ++]
    const value = formData.get('value') as string // [!code ++]
    sendTransaction({ to, value: parseEther(value) }) // [!code ++]
  } // [!code ++]
</script>

<template>
  <form> // [!code --]
  <form @submit.prevent="submit"> // [!code ++]
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button type="submit">Send</button>
  </form>
</template>
```

:::

### 4. Hook up the `useSendTransaction` Composable

Now that we have the form handler, we can hook up the [`useSendTransaction` Composable](/vue/api/composables/useSendTransaction) to send the transaction.

::: code-group

```vue [SendTransaction.vue]
<script setup lang="ts">
  import { useSendTransaction } from 'wagmi' // [!code ++]
  import { parseEther } from 'viem' // [!code ++]

  const { data: hash, sendTransaction } = useSendTransaction() // [!code ++]

  function submit(event: Event) {
    const formData = new FormData(event.target as HTMLFormElement)
    const to = formData.get('address') as `0x${string}`
    const value = formData.get('value') as string
    sendTransaction({ to, value: parseEther(value) }) // [!code ++]
  }
</script>

<template>
  <form @submit.prevent="submit">
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button type="submit">Send</button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div> // [!code ++]
  </form>
</template>
```

:::

### 5. Add loading state (optional)

We can optionally add a loading state to the "Send" button while we are waiting confirmation from the user's wallet.

::: code-group

```vue [SendTransaction.vue]
<script setup lang="ts">
  import { useSendTransaction } from 'wagmi'
  import { parseEther } from 'viem'

  const { 
    data: hash, 
    isPending, // [!code ++]
    sendTransaction 
  } = useSendTransaction()

  function submit(event: Event) {
    const formData = new FormData(event.target as HTMLFormElement)
    const to = formData.get('address') as `0x${string}`
    const value = formData.get('value') as string
    sendTransaction({ to, value: parseEther(value) })
  }
</script>

<template>
  <form @submit.prevent="submit">
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button :disabled="isPending" type="submit"> // [!code ++]
      <span v-if="isPending">Sending...</span> // [!code ++]
      <span v-else>Send</span> // [!code ++]
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
  </form>
</template>
```

:::

### 6. Wait for transaction receipt (optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Composable](/vue/api/composables/useWaitForTransactionReceipt). 

::: code-group

```vue [SendTransaction.vue]
<script setup lang="ts">
  import { 
    useSendTransaction,
    useWaitForTransactionReceipt, // [!code ++]
  } from 'wagmi'
  import { parseEther } from 'viem'

  const { 
    data: hash, 
    isPending,
    sendTransaction 
  } = useSendTransaction()

  function submit(event: Event) {
    const formData = new FormData(event.target as HTMLFormElement)
    const to = formData.get('address') as `0x${string}`
    const value = formData.get('value') as string
    sendTransaction({ to, value: parseEther(value) })
  }

  const { isLoading: isConfirming, isSuccess: isConfirmed } = // [!code ++]
    useWaitForTransactionReceipt({ // [!code ++]
      hash, // [!code ++]
    }) // [!code ++]
</script>

<template>
  <form @submit.prevent="submit">
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button :disabled="isPending" type="submit">
      <span v-if="isPending">Sending...</span>
      <span v-else>Send</span>
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
    <div v-if="isConfirming">Waiting for confirmation...</div> // [!code ++]
    <div v-if="isConfirmed">Transaction Confirmed!</div> // [!code ++]
  </form>
</template>
```

:::

### 7. Handle errors (optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

::: code-group

```vue [SendTransaction.vue]
<script setup lang="ts">
  import { 
    useSendTransaction,
    useWaitForTransactionReceipt,
  } from 'wagmi'
  import { parseEther } from 'viem'

  const { 
    data: hash, 
    error, // [!code ++]
    isPending,
    sendTransaction 
  } = useSendTransaction()

  function submit(event: Event) {
    const formData = new FormData(event.target as HTMLFormElement)
    const to = formData.get('address') as `0x${string}`
    const value = formData.get('value') as string
    sendTransaction({ to, value: parseEther(value) })
  }

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 
</script>

<template>
  <form @submit.prevent="submit">
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button :disabled="isPending" type="submit">
      <span v-if="isPending">Sending...</span>
      <span v-else>Send</span>
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
    <div v-if="isConfirming">Waiting for confirmation...</div> 
    <div v-if="isConfirmed">Transaction Confirmed!</div> 
    <div v-if="error"> // [!code ++]
      Error: {{ (error as BaseError).shortMessage || error.message }} // [!code ++]
    </div> // [!code ++]
  </form>
</template>
```

:::

### 8. Wire it up!

Finally, we can wire up our Send Transaction component to our application's entrypoint.

:::code-group
```vue [App.vue]
<script setup lang="ts">
import { useAccount } from '@wagmi/vue';
import Account from './Account.vue';
import Connect from './Connect.vue';
import SendTransaction from './SendTransaction.vue'; // [!code ++]

const { isConnected } = useAccount();
</script>

<template>
  <Account v-if="isConnected" />
  <Connect v-else />
  <SendTransaction v-if="isConnected" /> // [!code ++]
</template>
```
```vue [SendTransaction.vue]
<script setup lang="ts">
  import { 
    useSendTransaction,
    useWaitForTransactionReceipt,
  } from 'wagmi'
  import { parseEther } from 'viem'

  const { 
    data: hash, 
    error,
    isPending,
    sendTransaction 
  } = useSendTransaction()

  function submit(event: Event) {
    const formData = new FormData(event.target as HTMLFormElement)
    const to = formData.get('address') as `0x${string}`
    const value = formData.get('value') as string
    sendTransaction({ to, value: parseEther(value) })
  }

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 
</script>

<template>
  <form @submit.prevent="submit">
    <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
    <input name="value" placeholder="0.05" required />
    <button :disabled="isPending" type="submit">
      <span v-if="isPending">Sending...</span>
      <span v-else>Send</span>
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
    <div v-if="isConfirming">Waiting for confirmation...</div> 
    <div v-if="isConfirmed">Transaction Confirmed!</div> 
    <div v-if="error">
      Error: {{ (error as BaseError).shortMessage || error.message }}
    </div>
  </form>
</template>
```
:::

[See the Example.](#example)
</file>

<file path="site/vue/guides/ssr.md">
---
outline: deep
---

# SSR

Wagmi uses client-only external stores (such as `localStorage` and `mipd`) to show the user the most relevant data as quickly as possible on first render.

However, the caveat of using these external client stores is that frameworks which incorporate SSR (such as Next.js) will throw hydration warnings on the client when it identifies mismatches between the server-rendered HTML and the client-rendered HTML.

To stop this from happening, you can toggle on the [`ssr`](/vue/api/createConfig#ssr) property in the Wagmi Config.

```tsx
import { createConfig, http } from '@wagmi/vue'
import { mainnet, sepolia } from '@wagmi/vue/chains'

const config = createConfig({ // [!code focus:99]
  chains: [mainnet, sepolia],
  ssr: true, // [!code ++]
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

Turning on the `ssr` property means that content from the external stores will be hydrated on the client after the initial mount.

## Persistence using Cookies

As a result of turning on the `ssr` property, external persistent stores like `localStorage` will be hydrated on the client **after the initial mount**.

This means that you will still see a flash of "empty" data on the client (e.g. a `"disconnected"` account instead of a `"reconnecting"` account, or an empty address instead of the last connected address) until after the first mount, when the store hydrates.

In order to persist data between the server and the client, you can use cookies.

### 1. Set up cookie storage

First, we will set up cookie storage in the Wagmi Config.

```tsx
import { 
  createConfig, 
  http, 
  cookieStorage, // [!code ++]
  createStorage // [!code ++]
} from '@wagmi/vue'
import { mainnet, sepolia } from '@wagmi/vue/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  ssr: true,
  storage: createStorage({  // [!code ++]
    storage: cookieStorage, // [!code ++]
  }),  // [!code ++]
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

### 2. Hydrate the cookie

Next, we will need to add some mechanisms to hydrate the stored cookie in Wagmi.

#### Nuxt.js

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!
<!-- TODO -->

#### Vanilla SSR

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!
<!-- TODO -->
</file>

<file path="site/vue/guides/tanstack-query.md">
# TanStack Query

Wagmi Composables are not only a wrapper around the core [Wagmi Actions](/core/api/actions), but they also utilize [TanStack Query](https://tanstack.com/query/v5) to enable trivial and intuitive fetching, caching, synchronizing, and updating of asynchronous data in your Vue applications.

Without an asynchronous data fetching abstraction, you would need to handle all the negative side-effects that comes as a result, such as: representing finite states (loading, error, success), handling race conditions, caching against a deterministic identifier, etc.

## Queries & Mutations

Wagmi Composables represent either a **Query** or a **Mutation**. 

**Queries** are used for fetching data (e.g. fetching a block number, reading from a contract, etc), and are typically invoked on mount by default. All queries are coupled to a unique [Query Key](#query-keys), and can be used for further operations such as refetching, prefetching, or modifying the cached data.

**Mutations** are used for mutating data (e.g. connecting/disconnecting accounts, writing to a contract, switching chains, etc), and are typically invoked in response to a user interaction. Unlike **Queries**, they are not coupled with a query key.

## Terms

- **Query**: An asynchronous data fetching (e.g. read data) operation that is tied against a unique Query Key.
- **Mutation**: An asynchronous mutating (e.g. create/update/delete data or side-effect) operation.
- **Query Key**: A unique identifier that is used to deterministically identify a query. It is typically a tuple of the query name and the query arguments.
- **Stale Data**: Data that is unused or inactive after a certain period of time.
- **Query Fetching**: The process of invoking an async query function.
- **Query Refetching**: The process of refetching **rendered** queries.
- **[Query Invalidation](https://tanstack.com/query/v5/docs/vue/guides/query-invalidation)**: The process of marking query data as stale (e.g. inactive/unused), and refetching **rendered** queries.
- **[Query Prefetching](https://tanstack.com/query/v5/docs/vue/guides/prefetching)**: The process of prefetching queries and seeding the cache.

<!-- TODO: ## Persistence via External Stores -->

## Query Keys

Query Keys are typically used to perform advanced operations on the query such as: invalidation, refetching, prefetching, etc. 

Wagmi exports Query Keys for every Composable, and they can be retrieved via the [Composable (Vue)](#composable-vue) or via an [Import (Vanilla JS)](#import-vanilla-js).

Read more about **Query Keys** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/vue/guides/query-keys)

### Composable (Vue)

Each Composable returns a `queryKey` value. You would use this approach when you want to utilize the query key in a Vue component as it handles reactivity for you, unlike the [Import](#import-vanilla-js) method below.

```vue [index.vue]
<script setup lang="ts">
import { useBalance } from '@wagmi/vue' // [!code hl]

const { data: balance } = useBalance() // [!code hl]
</script>

<template>
  <div>{{ balance }}</div>
</template>
```

### Import (Vanilla JS)

Each Hook has a corresponding `get<X>QueryOptions` function that returns a query key. You would use this method when you want to utilize the query key outside of a Vue component in a Vanilla JS context, like in a utility function. 

```ts 
import { getBalanceQueryOptions } from '@wagmi/vue/query' // [!code hl]
import { config } from './config'

function perform() {
  const { queryKey } = getBalanceQueryOptions(config, { // [!code hl]
    chainId: config.state.chainId // [!code hl]
  }) // [!code hl]
}
```

::: warning

The caveat of this method is that it does not handle reactivity for you (e.g. active account/chain changes, argument changes, etc). You would need to handle this yourself by explicitly passing through the arguments to `get<X>QueryOptions`.

:::

## Invalidating Queries

Invalidating a query is the process of marking the query data as stale (e.g. inactive/unused), and refetching the queries that are already rendered.

Read more about **Invalidating Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/vue/guides/query-invalidation)

#### Example: Watching a Users' Balance

You may want to "watch" a users' balance, and invalidate the balance after each incoming block. We can invoke `invalidateQueries` inside a `watchEffect` ‚Äì this will refetch all rendered balance queries when the `blockNumber` changes.

```vue
<script setup lang="ts">
import { useQueryClient } from '@tanstack/vue-query' 
import { useBlockNumber, useBalance } from '@wagmi/vue' 
import { watchEffect } from 'vue' 

const queryClient = useQueryClient()
const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code hl]
const { data: balance, queryKey } = useBalance() // [!code hl]
  
watchEffect(() => { // [!code hl]
  queryClient.invalidateQueries({ queryKey }) // [!code hl]
}) // [!code hl]
</script>

<template>
  <div>Block Number: {{ blockNumber }}</div>
  <div>Balance: {{ balance }}</div>
</template>
```

#### Example: After User Interaction

Maybe you want to invalidate a users' balance after some interaction. This would mark the balance as stale, and consequently refetch all rendered balance queries.

```vue
<script setup lang="ts">
import { useBalance } from '@wagmi/vue'

// 1. Extract `queryKey` from the useBalance Hook. // [!code hl]
const { queryKey } = useBalance() // [!code hl]
</script>

<template>
  // 2. Add a button that invalidates the balance query. // [!code hl]
  <button @click="queryClient.invalidateQueries({ queryKey })"> // [!code hl]
    Invalidate // [!code hl]
  </button> // [!code hl]
</template>
```

```vue
<script setup lang="ts">
// 3. Other `useBalance` Hooks in your rendered Vue tree will be refetched! // [!code hl]
const { data: balance } = useBalance() // [!code hl]
</script>

<template>
  <div>{{ balance }}</div>
</template>
```

## Fetching Queries

Fetching a query is the process of invoking the query function to retrieve data. If the query exists and the data is not invalidated or older than a given `staleTime`, then the data from the cache will be returned. Otherwise, the query will fetch for the latest data.

::: code-group
```tsx [example.tsx]
import { getBlockQueryOptions } from '@wagmi/vue/query'
import { queryClient } from './main'
import { config } from './config'

export async function fetchBlockData() {
  return queryClient.fetchQuery( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
    } // [!code hl]
  )) // [!code hl]
}
```
<<< @/snippets/vue/main.ts[main.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

## Retrieving & Updating Query Data

You can retrieve and update query data imperatively with `getQueryData` and `setQueryData`. This is useful for scenarios where you want to retrieve or update a query outside of a Vue component.

Note that these functions do not invalidate or refetch queries.

::: code-group
```tsx [example.tsx]
import type { GetBalanceReturnType } from '@wagmi/vue/actions'
import { getBalanceQueryOptions } from '@wagmi/vue/query'
import { queryClient } from './app'
import { config } from './config'

export function getBalanceData() {
  return queryClient.getQueryData( // [!code hl]
    getBalanceQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
    } // [!code hl]
  )) // [!code hl]
}

export function setBalanceData(parameters: Partial<GetBalanceReturnType>) {
  return queryClient.setQueryData( // [!code hl]
    getBalanceQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
    }, // [!code hl]
    data => ({ ...data, ...parameters }) // [!code hl]
  )) // [!code hl]
}
```
<<< @/snippets/vue/main.ts[main.ts]
<<< @/snippets/vue/config.ts[config.ts]
:::

## Prefetching Queries

Prefetching a query is the process of fetching the data ahead of time and seeding the cache with the returned data. This is useful for scenarios where you want to fetch data before the user navigates to a page, or fetching data on the server to be reused on client hydration.

Read more about **Prefetching Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/vue/guides/prefetching)

#### Example: Prefetching in Event Handler

```vue
<script setup lang="ts">
import { useConfig, useChainId, useQueryClient } from '@wagmi/vue'
import { getBlockQueryOptions } from '@wagmi/vue/query'

const config = useConfig()
const chainId = useChainId()
const queryClient = useQueryClient()

const prefetch = () => 
  queryClient.prefetchQuery(getBlockQueryOptions(config, { chainId })) 
</script>

<template>
  <a
    @mouseenter="prefetch" 
    @focus="prefetch" 
    href="..."
  >
    Block details
  </a>
</template>
```

## SSR

It is possible to utilize TanStack Query's SSR strategies with Wagmi Composables & Query Keys. Check out the [SSR guide](https://tanstack.com/query/latest/docs/framework/vue/guides/ssr).

## Devtools

TanStack Query includes dedicated [Devtools](https://tanstack.com/query/latest/docs/framework/vue/devtools) that assist in visualizing and debugging your queries, their cache states, and much more. You will have to pass a custom `queryKeyFn` to your `QueryClient` for Devtools to correctly serialize BigInt values for display. Alternatively, You can use the `hashFn` from `@wagmi/core/query`, which already handles this serialization.

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/vue-query-devtools
```

```bash [npm]
npm i @tanstack/vue-query-devtools
```

```bash [yarn]
yarn add @tanstack/vue-query-devtools
```

```bash [bun]
bun i @tanstack/vue-query-devtools
```
:::

#### Usage

::: code-group
```vue [App.vue]
<script setup>
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
</script>

<template>
  <VueQueryDevtools />
</template>
```

```vue [main.vue]
<script setup lang="ts">
import { createApp } from 'vue'
import { WagmiPlugin } from '@wagmi/vue'
import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'

import App from './App.vue'
import { config } from './config' 

const queryClient = new QueryClient({ // [!code hl]
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      queryKeyHashFn: hashFn, // [!code hl]
    }, // [!code hl]
  }, // [!code hl]
}); // [!code hl]

createApp(App)
  .use(WagmiPlugin, { config })
  .use(VueQueryPlugin, { queryClient }) // [!code hl]
  .mount('#app')
</script>
```
:::
</file>

<file path="site/vue/guides/viem.md">
# Viem

[Viem](https://viem.sh) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](/react/api/createConfig) and automatic account management via [Connectors](/react/api/connectors).

## Leveraging Viem Actions

All of the core [Wagmi Composables](/vue/api/composables) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](/vue/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe a Composable doesn't exist in Wagmi yet). In these cases, you can create your own custom Wagmi Composable by importing Viem Actions directly via `viem/actions` and plugging in a Viem Client returned by the [`useClient` Composable](/vue/api/composables/useClient).

There are two categories of Viem Actions:

- **[Public Actions](https://viem.sh/docs/actions/public/introduction):** Actions that are "read-only" and do not require a wallet connection.
- **[Wallet Actions](https://viem.sh/docs/actions/wallet/introduction):** Actions that interface with a Wallet and require a wallet connection.

While it is not mandatory, it is also recommended to pair Actions with either `useQuery` or `useMutation` to effectively leverage the reactivity and caching capabilities of [Tanstack Query](/vue/guides/tanstack-query).

### Public Actions

The example below demonstrates how to utilize Viem's `getLogs` Action with a `useQuery` Composable to create your own abstraction akin to a `useLogs` Composable.

```vue
<script setup lang="ts">
// 1. Import modules. 
import { useClient, useConnectorClient } from '@wagmi/vue' 
import { useMutation, useQuery } from '@wagmi/vue/query'
import { getLogs, watchAsset } from 'viem/actions'

// 2. Extract a Viem Client for the current active chain. 
const client = useClient() 

// 3. Create a "custom" Query Composable that utilizes the Client. 
const { data: logs } = useQuery( 
  computed(() => ({ 
    queryKey: ['logs', client.value.uid], 
    queryFn: () => getLogs(client.value) 
  })) 
) 
</script>
```

### Wallet Actions

The example below demonstrates how to utilize Viem's `watchAsset` Action with a `useMutation` Composable to create your own abstraction akin to a `useWatchAsset` Composable.

```vue
<script setup lang="ts">
// 1. Import modules. 
import { useConnectorClient } from '@wagmi/vue' 
import { useMutation } from '@wagmi/vue/query'
import { watchAsset } from 'viem/actions'

// 2. Extract a Viem Client for the current active chain. 
const { data: connectorClient } = useConnectorClient()

// 3. Create a "custom" Mutation Composable that utilizes the Client. 
const { mutate } = useMutation({
  mutationFn: (asset) => watchAsset(connectorClient, asset)
})
</script>
```

## Private Key & Mnemonic Accounts

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

```vue
<script setup lang="ts">
import { privateKeyToAccount } from 'viem/accounts'
import { useConfig } from '@wagmi/vue'
import { sendTransactionMutationOptions, useMutation } from '@wagmi/vue/query'

const config = useConfig()
const { mutate: sendTransaction } = useMutation(
  sendTransactionMutationOptions(config)
)

const account = privateKeyToAccount('0x...') // [!code hl]

sendTransaction({
  account, // [!code hl]
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
</script>
```

::: info

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config ‚Äì meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open an discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).

:::
</file>

<file path="site/vue/guides/write-to-contract.md">
# Write to Contract

The [`useWriteContract` Composable](/vue/api/composables/useWriteContract) allows you to mutate data on a smart contract, from a `payable` or `nonpayable` (write) function. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

In the guide below, we will teach you how to implement a "Mint NFT" form that takes in a dynamic argument (token ID) using Wagmi. The example below builds on the [Connect Wallet guide](/vue/guides/connect-wallet) and uses the [useWriteContract](/vue/api/composables/useWriteContract) & [useWaitForTransaction](/vue/api/composables/useWaitForTransactionReceipt) composables. 

If you have already completed the [Sending Transactions guide](/vue/guides/send-transaction), this guide will look very similar! That's because writing to a contract internally broadcasts & sends a transaction.

## Example

Feel free to check out the example before moving on:

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-knyxah?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>

## Steps

### 1. Connect Wallet

Follow the [Connect Wallet guide](/vue/guides/connect-wallet) guide to get this set up.

### 2. Create a new component

Create your `MintNft` component that will contain the Mint NFT logic.

::: code-group

```vue [MintNft.vue]
<script setup lang="ts">
</script>
 
<template>
  <form>
    <input name="tokenId" placeholder="69420" required />
    <button type="submit">Mint</button>
  </form>
</template>
```

:::

### 3. Add a form handler

Next, we will need to add a handler to the form that will send the transaction when the user hits "Mint". This will be a basic handler in this step.

::: code-group

```vue [MintNft.vue]
<script setup lang="ts">
function submit(event: Event) { // [!code ++]
  const formData = new FormData(e.target as HTMLFormElement) // [!code ++]
  const tokenId = formData.get('tokenId') as string // [!code ++]
} // [!code ++]
</script>

<template
  <form> // [!code --]
  <form @submit.prevent="submit"> // [!code ++]
    <input name="tokenId" placeholder="69420" required />
    <button type="submit">Mint</button>
  </form>
</template>
```

:::

### 4. Hook up the `useWriteContract` Composable

Now that we have the form handler, we can hook up the [`useWriteContract` Composable](/vue/api/composables/useWriteContract) to send the transaction.

::: code-group

```vue [MintNft.vue]
<script setup lang="ts">
import { useWriteContract } from 'wagmi' // [!code ++]
import { abi } from './abi' // [!code ++]

const { data: hash, writeContract } = useWriteContract() // [!code ++]

function submit(event: Event) { 
  const formData = new FormData(e.target as HTMLFormElement) 
  const tokenId = formData.get('tokenId') as string 
  writeContract({ // [!code ++]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code ++]
    abi, // [!code ++]
    functionName: 'mint', // [!code ++]
    args: [BigInt(tokenId)], // [!code ++]
  }) // [!code ++]
} 
</script>

<template
  <form @submit.prevent="submit"> 
    <input name="tokenId" placeholder="69420" required />
    <button type="submit">Mint</button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div> // [!code ++]
  </form>
</template>
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 5. Add loading state (optional)

We can optionally add a loading state to the "Mint" button while we are waiting confirmation from the user's wallet.

::: code-group

```vue [MintNft.vue]
<script setup lang="ts">
import { useWriteContract } from 'wagmi'
import { abi } from './abi'

const { 
  data: hash, 
  isPending, // [!code ++]
  writeContract 
} = useWriteContract()

function submit(event: Event) { 
  const formData = new FormData(e.target as HTMLFormElement) 
  const tokenId = formData.get('tokenId') as string 
  writeContract({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    abi,
    functionName: 'mint',
    args: [BigInt(tokenId)],
  })
} 
</script>

<template
  <form @submit.prevent="submit"> 
    <input name="tokenId" placeholder="69420" required />
    <button :disabled="isPending" type="submit"> // [!code ++]
      <span v-if="isPending">Sending...</span> // [!code ++]
      <span v-else>Send</span> // [!code ++]
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
  </form>
</template>
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 6. Wait for transaction receipt (optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Composable](/vue/api/composables/useWaitForTransactionReceipt). 

::: code-group

```vue [MintNft.vue]
<script setup lang="ts">
import { 
  useWaitForTransactionReceipt, // [!code ++]
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'

const { 
  data: hash, 
  isPending,
  writeContract 
} = useWriteContract()

function submit(event: Event) { 
  const formData = new FormData(e.target as HTMLFormElement) 
  const tokenId = formData.get('tokenId') as string 
  writeContract({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    abi,
    functionName: 'mint',
    args: [BigInt(tokenId)],
  })
} 

const { isLoading: isConfirming, isSuccess: isConfirmed } = // [!code ++]
  useWaitForTransactionReceipt({ // [!code ++]
    hash, // [!code ++]
  }) // [!code ++]
</script>

<template
  <form @submit.prevent="submit"> 
    <input name="tokenId" placeholder="69420" required />
    <button :disabled="isPending" type="submit">
      <span v-if="isPending">Sending...</span>
      <span v-else>Send</span>
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
    <div v-if="isConfirming">Waiting for confirmation...</div> // [!code ++]
    <div v-if="isConfirmed">Transaction Confirmed!</div> // [!code ++]
  </form>
</template>
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 7. Handle errors (optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

::: code-group

```vue [MintNft.vue]
<script setup lang="ts">
import { 
  useWaitForTransactionReceipt,
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'

const { 
  data: hash,
  error, // [!code ++] 
  isPending,
  writeContract 
} = useWriteContract()

function submit(event: Event) { 
  const formData = new FormData(e.target as HTMLFormElement) 
  const tokenId = formData.get('tokenId') as string 
  writeContract({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    abi,
    functionName: 'mint',
    args: [BigInt(tokenId)],
  })
} 

const { isLoading: isConfirming, isSuccess: isConfirmed } =
  useWaitForTransactionReceipt({
    hash,
  })
</script>

<template
  <form @submit.prevent="submit"> 
    <input name="tokenId" placeholder="69420" required />
    <button :disabled="isPending" type="submit">
      <span v-if="isPending">Sending...</span>
      <span v-else>Send</span>
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
    <div v-if="isConfirming">Waiting for confirmation...</div>
    <div v-if="isConfirmed">Transaction Confirmed!</div>
    <div v-if="error"> // [!code ++]
      Error: {{ (error as BaseError).shortMessage || error.message }} // [!code ++]
    </div> // [!code ++]
  </form>
</template>
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 8. Wire it up!

Finally, we can wire up our Send Transaction component to our application's entrypoint.

:::code-group
```vue [App.vue]
<script setup lang="ts">
import { useAccount } from '@wagmi/vue';
import Account from './Account.vue';
import Connect from './Connect.vue';
import MintNft from './MintNft.vue'; // [!code ++]

const { isConnected } = useAccount();
</script>

<template>
  <Account v-if="isConnected" />
  <Connect v-else />
  <MintNft v-if="isConnected" /> // [!code ++]
</template>
```

```vue [MintNft.vue]
<script setup lang="ts">
import { 
  useWaitForTransactionReceipt,
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'

const { 
  data: hash,
  error, 
  isPending,
  writeContract 
} = useWriteContract()

function submit(event: Event) { 
  const formData = new FormData(e.target as HTMLFormElement) 
  const tokenId = formData.get('tokenId') as string 
  writeContract({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    abi,
    functionName: 'mint',
    args: [BigInt(tokenId)],
  })
} 

const { isLoading: isConfirming, isSuccess: isConfirmed } =
  useWaitForTransactionReceipt({
    hash,
  })
</script>

<template
  <form @submit.prevent="submit"> 
    <input name="tokenId" placeholder="69420" required />
    <button :disabled="isPending" type="submit">
      <span v-if="isPending">Sending...</span>
      <span v-else>Send</span>
    </button>
    <div v-if="hash">Transaction Hash: {{ hash }}</div>
    <div v-if="isConfirming">Waiting for confirmation...</div>
    <div v-if="isConfirmed">Transaction Confirmed!</div>
    <div v-if="error">
      Error: {{ (error as BaseError).shortMessage || error.message }}
    </div>
  </form>
</template>
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```
:::

[See the Example.](#example)
</file>

<file path="site/vue/getting-started.md">
<script setup>
import packageJson from '../../packages/vue/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Getting Started

## Overview

Wagmi is a collection of Vue composition utilities for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](/vue/why) section.

## Automatic Installation

For new projects, it is recommended to set up your Wagmi app using the [`create-wagmi`](/cli/create-wagmi) command line interface (CLI). This will create a new Wagmi project using TypeScript and install the required dependencies.

::: code-group
```bash [pnpm]
pnpm create wagmi
```

```bash [npm]
npm create wagmi@latest
```

```bash [yarn]
yarn create wagmi
```

```bash [bun]
bun create wagmi
```
:::

Once the command runs, you'll see some prompts to complete.

```ansi
Project name: wagmi-project
Select a framework: Vue / Vanilla
...
```

After the prompts, `create-wagmi` will create a directory with your project name and install the required dependencies. Check out the `README.md` for further instructions (if required).

## Manual Installation

To manually add Wagmi to your project, install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```

```bash-vue [npm]
npm install @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```

```bash-vue [yarn]
yarn add @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```

```bash-vue [bun]
bun add @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
- [TypeScript](/vue/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/vue/typescript).

### Create Config

Create and export a new Wagmi config using `createConfig`.

::: code-group
<<< @/snippets/vue/config.ts[config.ts]
:::

In this example, Wagmi is configured to use the Mainnet and Sepolia chains, and `injected` connector. Check out the [`createConfig` docs](/vue/api/createConfig) for more configuration options.

::: details TypeScript Tip
If you are using TypeScript, you can "register" the Wagmi config or use the hook `config` property to get strong type-safety in places that wouldn't normally have type info.

::: code-group
```ts twoslash [register config]
// @errors: 2322
import { type Config } from '@wagmi/vue'
import { mainnet, sepolia } from '@wagmi/vue/chains'

declare const config: Config<readonly [typeof mainnet, typeof sepolia]>
// ---cut---
import { useBlockNumber } from '@wagmi/vue'

useBlockNumber({ chainId: 123 })

declare module '@wagmi/vue' {
  interface Register {
    config: typeof config
  }
}
```

```ts twoslash [hook config property]
// @errors: 2322
import { type Config } from '@wagmi/vue'
import { mainnet, sepolia } from '@wagmi/vue/chains'

declare const config: Config<readonly [typeof mainnet, typeof sepolia]>
// ---cut---
import { useBlockNumber } from '@wagmi/vue'

useBlockNumber({ chainId: 123, config })
```

By registering or using the hook `config` property, `useBlockNumber`'s `chainId` is strongly typed to only allow Mainnet and Sepolia IDs. Learn more by reading the [TypeScript docs](/vue/typescript#config-types).
:::

### Add Plugin to App

Add the `WagmiPlugin` to your app instance and pass the `config` you created earlier to the plugin options.

::: code-group
```tsx [main.ts]
import { WagmiPlugin } from '@wagmi/vue' // [!code focus]
import { createApp } from 'vue'
import { config } from './config' // [!code focus]
import App from './App.vue'

createApp(App)
  .use(WagmiPlugin, { config }) // [!code focus]
  .mount('#app')
```
```vue [App.vue]
<template>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

Check out the [`WagmiPlugin` docs](/vue/api/WagmiPlugin) to learn more about the plugin API.

### Setup TanStack Query

After the `WagmiPlugin`, attach the `VueQueryPlugin` to your app, and pass a new `QueryClient` instance to the `queryClient` property.

::: code-group
```tsx [main.ts]
import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query' // [!code focus]
import { WagmiPlugin } from '@wagmi/vue'
import { createApp } from 'vue'
import { config } from './config'
import App from './App.vue'

const queryClient = new QueryClient() // [!code focus]

createApp(App)
  .use(WagmiPlugin, { config })
  .use(VueQueryPlugin, { queryClient }) // [!code focus]
  .mount('#app')
```
```vue [App.vue]
<template>
</template>
```
<<< @/snippets/vue/config.ts[config.ts]
:::

Check out the [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/vue) to learn about the library, APIs, and more.

### Use Wagmi

Now that everything is set up, every component inside your app can use Wagmi Vue Composables.

::: code-group
```vue [App.vue]
<script setup lang="ts">
import { useAccount, useEnsName } from '@wagmi/vue'

const { address } = useAccount()
const { data, error, status } = useEnsName({ address })
</script>

<template>
  <div v-if="status === 'pending'">Loading ENS name</div>
  <div v-else-if="status === 'error'">
    Error fetching ENS name: {{error.message}}
  </div>
  <div v-else>ENS name: {{data}}</div>
</template>
```
```tsx [main.ts]
import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
import { WagmiPlugin } from '@wagmi/vue'
import { createApp } from 'vue'
import { config } from './config'
import App from './App.vue'

const queryClient = new QueryClient()

createApp(App)
  .use(WagmiPlugin, { config })
  .use(VueQueryPlugin, { queryClient })
  .mount('#app')
```
<<< @/snippets/vue/config.ts[config.ts]
:::


## Next Steps

For more information on what to do next, check out the following topics.

- [**TypeScript**](/vue/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
- [**Connect Wallet**](/vue/guides/connect-wallet) Learn how to enable wallets to connect to and disconnect from your apps and display information about connected accounts.
- [**Vue Composables**](/vue/api/composables) Browse the collection of Vue Composables and learn how to use them.
- [**Viem**](/vue/guides/viem) Learn about Viem and how it works with Wagmi.
</file>

<file path="site/vue/installation.md">
<script setup>
import packageJson from '../../packages/vue/package.json'
import Browsers from '../components/Browsers.vue'

const docsPath = 'vue'
const packageDir = 'vue'
const packageName = '@wagmi/vue'
const viemVersion = packageJson.peerDependencies.viem
</script>

# Installation

Install Wagmi via your package manager, a `<script>` tag, or build from source.

## Package Manager

Install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```

```bash-vue [npm]
npm install @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```

```bash-vue [yarn]
yarn add @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```

```bash-vue [bun]
bun add @wagmi/vue viem@{{viemVersion}} @tanstack/vue-query
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
- [TypeScript](/vue/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/vue/typescript).

<!--@include: @shared/installation.md-->
</file>

<file path="site/vue/typescript.md">
<script setup>
import packageJson from '../../packages/vue/package.json'

const typescriptVersion = packageJson.peerDependencies.typescript
</script>

# TypeScript

## Requirements

Wagmi is designed to be as type-safe as possible! Things to keep in mind:

- Types currently require using TypeScript {{typescriptVersion}}.
- [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
- Changes to types in this repository are considered non-breaking and are usually released as patch changes (otherwise every type enhancement would be a major version!).
- It is highly recommended that you lock your `wagmi` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
- The non-type-related public API of Wagmi still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

::: code-group
```json [tsconfig.json]
{
  "compilerOptions": {
    "strict": true
  }
}
```
:::

## Config Types

By default Vue Plugins does not work well with type inference. To support strong type-safety across the Vue Plugins boundary, there are two options available:

- Declaration merging to "register" your `config` globally with TypeScript.
- `config` property to pass your `config` directly to composables.

### Declaration Merging

[Declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) allows you to "register" your `config` globally with TypeScript. The `Register` type enables Wagmi to infer types in places that wouldn't normally have access to type info via a Vue Plugin alone. 

To set this up, add the following declaration to your project. Below, we co-locate the declaration merging and the `config` set up.

```ts
import { createConfig, http } from '@wagmi/vue'
import { mainnet, sepolia } from 'wagmi/chains'

declare module '@wagmi/vue' { // [!code focus]
  interface Register { // [!code focus]
    config: typeof config // [!code focus]
  } // [!code focus]
} // [!code focus]

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

Since the `Register` type is global, you only need to add it once in your project. Once set up, you will get strong type-safety across your entire project. For example, query composables will type `chainId` based on your `config`'s `chains`. 

```ts twoslash
// @errors: 2322
import { type Config } from '@wagmi/vue'
import { mainnet, sepolia } from 'wagmi/chains'

declare module '@wagmi/vue' {
  interface Register {
    config: Config<readonly [typeof mainnet, typeof sepolia]>
  }
}
// ---cut---
import { useBlockNumber } from '@wagmi/vue'

useBlockNumber({ chainId: 123 })
```

You just saved yourself a runtime error and you didn't even need to pass your `config`. üéâ

### Hook `config` Property

For cases where you have more than one Wagmi `config` or don't want to use the declaration merging approach, you can pass a specific `config` directly to composables via the `config` property.

```ts
import { createConfig, http } from '@wagmi/vue'
import { mainnet, optimism } from '@wagmi/vue/chains'

export const configA = createConfig({ // [!code focus]
  chains: [mainnet], // [!code focus]
  transports: { // [!code focus]
    [mainnet.id]: http(), // [!code focus]
  }, // [!code focus]
}) // [!code focus]

export const configB = createConfig({ // [!code focus]
  chains: [optimism], // [!code focus]
  transports: { // [!code focus]
    [optimism.id]: http(), // [!code focus]
  }, // [!code focus]
}) // [!code focus]
```

As you expect, `chainId` is inferred correctly for each `config`.

```ts twoslash
// @errors: 2322
import { type Config } from '@wagmi/vue'
import { mainnet, optimism } from '@wagmi/vue/chains'

declare const configA: Config<readonly [typeof mainnet]>
declare const configB: Config<readonly [typeof optimism]>
// ---cut---
import { useBlockNumber } from '@wagmi/vue'

useBlockNumber({ chainId: 123, config: configA })
useBlockNumber({ chainId: 123, config: configB })
```

This approach is more explicit, but works well for advanced use-cases, if you don't want to use a Vue Plugin or declaration merging, etc.

## Const-Assert ABIs & Typed Data

Wagmi can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

```ts
const { data } = useReadContract({
  abi: [‚Ä¶], // <--- defined inline // [!code focus]
})
```

```ts
const abi = [‚Ä¶] as const // <--- const assertion // [!code focus]
const { data } = useReadContract({ abi })
```

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

::: tip
Unfortunately [TypeScript doesn't support importing JSON `as const` yet](https://github.com/microsoft/TypeScript/issues/32063). Check out the [Wagmi CLI](/cli/getting-started) to help with this! It can automatically fetch ABIs from Etherscan and other block explorers, resolve ABIs from your Foundry/Hardhat projects, generate Vue Composables, and more.
:::

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`useReadContract`](/vue/api/composables/useReadContract) looks like with and without a const-asserted `abi` property.

::: code-group
```ts twoslash [Const-Asserted]
const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { useReadContract } from '@wagmi/vue'

const { data } = useReadContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

data
// ^?
```
```ts twoslash [Not Const-Asserted]
declare const erc721Abi: {
  name: string;
  type: string;
  stateMutability: string;
  inputs: {
    type: string;
    name: string;
  }[];
  outputs: {
    type: string;
  }[];
}[]
// ---cut---
import { useReadContract } from '@wagmi/vue'

const { data } = useReadContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

data
// ^?
```
:::

<br/>
<br/>

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. üéâ

```ts twoslash
// @errors: 2820
const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { useReadContract } from '@wagmi/vue'

useReadContract({
  abi: erc721Abi,
  functionName: 'balanecOf',
})
```

## Configure Internal Types

For advanced use-cases, you may want to configure Wagmi's internal types. Most of Wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev) for more info on how to configure types.
</file>

<file path="site/vue/why.md">
# Why Wagmi

## The Problems

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi solves all these problems and more ‚Äî allowing app developers to focus on building high-quality and performant experiences for Ethereum ‚Äî by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

## Developer Experience

Wagmi delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi's APIs might seem more verbose at first, it makes Wagmi's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi is a great way to learn how to interact with Ethereum in general.

Wagmi also provides [strongly typed APIs](/vue/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](/vue/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20(TDD),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

## Performance

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi uses and is built by the same team behind [Viem](https://viem.sh), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times. 

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi supports caching, deduplication, persistence, and much more through [TanStack Query](/vue/guides/tanstack-query).

## Feature Coverage

Wagmi supports the most popular and commonly-used Ethereum features out of the box with 40+ Vue Composables for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi also supports just about any wallet out there through it's official [connectors](/vue/api/connectors), [EIP-6963 support](/vue/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Wagmi Core](/core/getting-started) or [Viem](https://viem.sh), which Wagmi uses internally to perform blockchain operations. Wagmi also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi has a [CLI](/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz), [Privy](https://privy.io), and many more, so you can get started quickly without needing to build everything from scratch.

## Stability

Stability is a fundamental principle for Wagmi. Many organizations, large and small, rely heavily on Wagmi and expect it to be entirely stable for their users and applications.

Wagmi's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi follows semver so developers can upgrade between versions with confidence. Starting with Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi and [related projects](https://github.com/wevm), and is constantly improving Wagmi and keeping it up-to-date with industry trends and changes.
</file>

<file path="site/index.md">
---
# https://vitepress.dev/reference/default-theme-home-page
layout: home

description: Type Safe, Extensible, and Modular by design. Build high-performance blockchain frontends.
title: 'Wagmi | Reactivity for Ethereum apps'
titleTemplate: false

hero:
  name: Wagmi
  text: Reactivity for Ethereum apps
  tagline: Type Safe, Extensible, and Modular by design. Build high-performance blockchain frontends.
  actions:
    - theme: brand
      text: Get Started
      link: /react/getting-started
    - theme: alt
      text: Why Wagmi
      link: /react/why
    - theme: alt
      text: View on GitHub
      link: https://github.com/wevm/wagmi
  image:
    src: /logo-dark.svg
    alt: Wagmi Logo

features:
  - icon: üöÄ
    title: 20+ React Hooks
    details: React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more.
    link: /react/api/hooks
    linkText: See all hooks
  - icon: ü¶Ñ
    title: TypeScript Ready
    details: Infer types from ABIs and EIP-712 Typed Data and autocomplete your way to productivity.
    link: /react/typescript
    linkText: Learn about TypeScript support
  - icon: üíº
    title: Connect Wallet
    details: Official connectors for MetaMask, EIP-6963, WalletConnect, Coinbase Wallet, and more.
    link: /react/api/connectors
    linkText: See all connectors
  - icon: üëü
    title: Caching. Deduplication. Persistence.
    details: Built-in caching, deduplication, persistence powered by TanStack Query.
    link: /react/guides/tanstack-query
    linkText: How to use TanStack Query
  - icon: üå≥
    title: Modular By Design
    details: Don't use React or Vue? Use VanillaJS or build an adapter for your favorite framework.
    link: /core/getting-started
    linkText: Learn about Wagmi Core
  - icon: ‚úåÔ∏è
    title: Built on Viem
    details: The modern, low-level TypeScript interface for Ethereum that performs blockchain operations.
    link: https://viem.sh
    linkText: Check out Viem
---
</file>

<file path="site/package.json">
{
  "name": "site",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vitepress dev",
    "build": "vitepress build",
    "preview": "vitepress preview"
  },
  "devDependencies": {
    "@shikijs/vitepress-twoslash": "1.22.2",
    "@tanstack/query-core": "catalog:",
    "@tanstack/react-query": "catalog:",
    "@tanstack/vue-query": "catalog:",
    "@types/react": "catalog:",
    "@wagmi/connectors": "workspace:*",
    "@wagmi/core": "workspace:*",
    "@wagmi/vue": "workspace:*",
    "abitype": "*",
    "nuxt": "^3.11.2",
    "react": "catalog:",
    "unocss": "^0.59.4",
    "viem": "2.*",
    "vitepress": "1.5.0",
    "vue": "catalog:",
    "wagmi": "workspace:*"
  }
}
</file>

<file path="site/tsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "preserve",
    "lib": ["DOM", "ESNext"],
    "module": "ESNext",
    "moduleResolution": "node",
    "noUnusedLocals": true,
    "paths": {
      "~/*": ["src/*"]
    },
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "strictNullChecks": true,
    "target": "esnext",
    "types": ["vite/client", "vitepress"]
  },
  "include": ["./*.ts", "./.vitepress/**/*.ts", "./.vitepress/**/*.vue"],
  "exclude": ["dist", "node_modules", "snippets"]
}
</file>

<file path="site/vercel.json">
{
  "cleanUrls": true,
  "redirects": [
    {
      "source": "/cli",
      "destination": "/cli/getting-started",
      "permanent": true
    },

    {
      "source": "/core",
      "destination": "/core/getting-started",
      "permanent": true
    },
    {
      "source": "/core/migration-guide",
      "destination": "/core/guides/migrate-from-v1-to-v2",
      "permanent": true
    },
    {
      "source": "/core/:name(faq)",
      "destination": "/core/guides/:name",
      "permanent": true
    },
    {
      "source": "/core/ethers-adapters",
      "destination": "/core/guides/ethers-web3",
      "permanent": true
    },
    {
      "source": "/core/:section(chains)",
      "destination": "/core/api/:section",
      "permanent": true
    },
    {
      "source": "/core/:section(actions|connectors)/:name",
      "destination": "/core/api/:section/:name",
      "permanent": true
    },
    {
      "source": "/core/config",
      "destination": "/core/api/createConfig",
      "permanent": true
    },

    {
      "source": "/react",
      "destination": "/react/getting-started",
      "permanent": true
    },
    {
      "source": "/react/comparison",
      "destination": "/react/comparisons",
      "permanent": true
    },
    {
      "source": "/react/migration-guide",
      "destination": "/react/guides/migrate-from-v1-to-v2",
      "permanent": true
    },
    {
      "source": "/react/:name(faq)",
      "destination": "/react/guides/:name",
      "permanent": true
    },
    {
      "source": "/react/ethers-adapters",
      "destination": "/react/guides/ethers",
      "permanent": true
    },
    {
      "source": "/react/:section(actions|chains)",
      "destination": "/react/api/:section",
      "permanent": true
    },
    {
      "source": "/react/:section(connectors|hooks)/:name",
      "destination": "/react/api/:section/:name",
      "permanent": true
    },
    {
      "source": "/react/config",
      "destination": "/react/api/createConfig",
      "permanent": true
    },
    {
      "source": "/react/WagmiConfig",
      "destination": "/react/api/WagmiProvider",
      "permanent": true
    },
    {
      "source": "/react/prepare-hooks/usePrepareContractWrite",
      "destination": "/react/api/hooks/useSimulateContract",
      "permanent": true
    },
    {
      "source": "/react/prepare-hooks/usePrepareSendTransaction",
      "destination": "/react/api/hooks/useEstimateFeesPerGas",
      "permanent": true
    },

    {
      "source": "/examples/connect-wallet",
      "destination": "/react/guides/connect-wallet",
      "permanent": true
    },
    {
      "source": "/examples/send-transaction",
      "destination": "/react/guides/send-transaction",
      "permanent": true
    },
    {
      "source": "/react/guides/sending-transactions",
      "destination": "/react/guides/send-transaction",
      "permanent": true
    },
    {
      "source": "/react/guides/reading-contracts",
      "destination": "/react/guides/read-from-contract",
      "permanent": true
    },
    {
      "source": "/examples/contract-write(-dynamic)?",
      "destination": "/react/guides/write-to-contract",
      "permanent": true
    },
    {
      "source": "/react/guides/writing-to-contracts",
      "destination": "/react/guides/write-to-contract",
      "permanent": true
    },
    {
      "source": "/examples/custom-connector",
      "destination": "/dev/creating-connectors",
      "permanent": true
    },
    {
      "source": "/examples/sign-message",
      "destination": "https://1.x.wagmi.sh/examples/sign-message",
      "permanent": false
    },
    {
      "source": "/examples/sign-in-with-ethereum",
      "destination": "https://1.x.wagmi.sh/examples/sign-in-with-ethereum",
      "permanent": false
    }
  ]
}
</file>

</files>
