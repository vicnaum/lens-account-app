This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: packages/test, packages/vue, **/CHANGELOG.md, **/*.test.*, site, packages/cli, .changeset, .github, packages/create-wagmi, packages/register-tests, playgrounds, scripts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  connectors/
    src/
      exports/
        index.ts
      coinbaseWallet.ts
      metaMask.ts
      safe.ts
      version.ts
      walletConnect.ts
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  core/
    src/
      actions/
        codegen/
          createReadContract.test-d.ts
          createReadContract.ts
          createSimulateContract.test-d.ts
          createSimulateContract.ts
          createWatchContractEvent.test-d.ts
          createWatchContractEvent.ts
          createWriteContract.test-d.ts
          createWriteContract.ts
        call.ts
        connect.test-d.ts
        connect.ts
        deployContract.test-d.ts
        deployContract.ts
        disconnect.ts
        estimateFeesPerGas.test-d.ts
        estimateFeesPerGas.ts
        estimateGas.test-d.ts
        estimateGas.ts
        estimateMaxPriorityFeePerGas.ts
        getAccount.test-d.ts
        getAccount.ts
        getBalance.ts
        getBlock.test-d.ts
        getBlock.ts
        getBlockNumber.ts
        getBlockTransactionCount.ts
        getBytecode.ts
        getCallsStatus.ts
        getCapabilities.ts
        getChainId.ts
        getChains.test-d.ts
        getChains.ts
        getClient.test-d.ts
        getClient.ts
        getConnections.ts
        getConnectorClient.test-d.ts
        getConnectorClient.ts
        getConnectors.ts
        getEnsAddress.ts
        getEnsAvatar.ts
        getEnsName.ts
        getEnsResolver.ts
        getEnsText.ts
        getFeeHistory.ts
        getGasPrice.ts
        getProof.ts
        getPublicClient.test-d.ts
        getPublicClient.ts
        getStorageAt.ts
        getToken.ts
        getTransaction.test-d.ts
        getTransaction.ts
        getTransactionConfirmations.test-d.ts
        getTransactionConfirmations.ts
        getTransactionCount.ts
        getTransactionReceipt.test-d.ts
        getTransactionReceipt.ts
        getWalletClient.test-d.ts
        getWalletClient.ts
        multicall.test-d.ts
        multicall.ts
        prepareTransactionRequest.test-d.ts
        prepareTransactionRequest.ts
        readContract.test-d.ts
        readContract.ts
        readContracts.test-d.ts
        readContracts.ts
        reconnect.ts
        sendCalls.ts
        sendTransaction.test-d.ts
        sendTransaction.ts
        showCallsStatus.ts
        signMessage.ts
        signTypedData.test-d.ts
        signTypedData.ts
        simulateContract.test-d.ts
        simulateContract.ts
        switchAccount.ts
        switchChain.ts
        verifyMessage.ts
        verifyTypedData.ts
        waitForCallsStatus.ts
        waitForTransactionReceipt.test-d.ts
        waitForTransactionReceipt.ts
        watchAccount.ts
        watchAsset.ts
        watchBlockNumber.test-d.ts
        watchBlockNumber.ts
        watchBlocks.test-d.ts
        watchBlocks.ts
        watchChainId.ts
        watchChains.ts
        watchClient.test-d.ts
        watchClient.ts
        watchConnections.ts
        watchConnectors.ts
        watchContractEvent.test-d.ts
        watchContractEvent.ts
        watchPendingTransactions.test-d.ts
        watchPendingTransactions.ts
        watchPublicClient.test-d.ts
        watchPublicClient.ts
        writeContract.test-d.ts
        writeContract.ts
      connectors/
        createConnector.ts
        injected.ts
        mock.ts
      errors/
        base.ts
        config.ts
        connector.ts
      experimental/
        actions/
          writeContracts.ts
        query/
          writeContracts.ts
      exports/
        actions.ts
        chains.ts
        codegen.ts
        experimental.ts
        index.ts
        internal.ts
        query.ts
      query/
        call.ts
        connect.ts
        deployContract.ts
        disconnect.ts
        estimateFeesPerGas.ts
        estimateGas.test-d.ts
        estimateGas.ts
        estimateMaxPriorityFeePerGas.ts
        getBalance.ts
        getBlock.ts
        getBlockNumber.ts
        getBlockTransactionCount.ts
        getBytecode.ts
        getCallsStatus.ts
        getCapabilities.ts
        getConnectorClient.ts
        getEnsAddress.ts
        getEnsAvatar.ts
        getEnsName.ts
        getEnsResolver.ts
        getEnsText.ts
        getFeeHistory.ts
        getGasPrice.ts
        getProof.ts
        getStorageAt.ts
        getToken.ts
        getTransaction.ts
        getTransactionConfirmations.ts
        getTransactionCount.ts
        getTransactionReceipt.ts
        getWalletClient.ts
        infiniteReadContracts.test-d.ts
        infiniteReadContracts.ts
        prepareTransactionRequest.ts
        readContract.test-d.ts
        readContract.ts
        readContracts.test-d.ts
        readContracts.ts
        reconnect.ts
        sendCalls.ts
        sendTransaction.ts
        showCallsStatus.ts
        signMessage.ts
        signTypedData.ts
        simulateContract.test-d.ts
        simulateContract.ts
        switchAccount.ts
        switchChain.ts
        types.ts
        utils.ts
        verifyMessage.ts
        verifyTypedData.ts
        waitForCallsStatus.ts
        waitForTransactionReceipt.ts
        watchAsset.ts
        writeContract.test-d.ts
        writeContract.ts
      transports/
        connector.ts
        fallback.ts
      types/
        chain.test-d.ts
        chain.ts
        properties.ts
        register.ts
        unit.ts
        utils.test-d.ts
        utils.ts
      utils/
        cookie.ts
        deepEqual.ts
        deserialize.ts
        extractRpcUrls.ts
        getAction.ts
        getUnit.ts
        getVersion.ts
        normalizeChainId.ts
        serialize.ts
        uid.ts
      createConfig.test-d.ts
      createConfig.ts
      createEmitter.ts
      createStorage.test-d.ts
      createStorage.ts
      hydrate.ts
      version.ts
    test/
      setup.ts
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  react/
    src/
      errors/
        base.ts
        context.ts
      experimental/
        hooks/
          useWriteContracts.ts
      exports/
        actions/
          experimental.ts
        actions.ts
        chains.ts
        codegen.ts
        connectors.ts
        experimental.ts
        index.ts
        query.ts
      hooks/
        codegen/
          createUseReadContract.test-d.ts
          createUseReadContract.ts
          createUseSimulateContract.test-d.ts
          createUseSimulateContract.ts
          createUseWatchContractEvent.test-d.ts
          createUseWatchContractEvent.ts
          createUseWriteContract.test-d.ts
          createUseWriteContract.ts
        useAccount.test-d.ts
        useAccount.ts
        useAccountEffect.ts
        useBalance.test-d.ts
        useBalance.ts
        useBlock.test-d.ts
        useBlock.ts
        useBlockNumber.test-d.ts
        useBlockNumber.ts
        useBlockTransactionCount.test-d.ts
        useBlockTransactionCount.ts
        useBytecode.test-d.ts
        useBytecode.ts
        useCall.test-d.ts
        useCall.ts
        useCallsStatus.ts
        useCapabilities.ts
        useChainId.test-d.ts
        useChainId.ts
        useChains.ts
        useClient.test-d.ts
        useClient.ts
        useConfig.test-d.ts
        useConfig.ts
        useConnect.test-d.ts
        useConnect.ts
        useConnections.ts
        useConnectorClient.test-d.ts
        useConnectorClient.ts
        useConnectors.ts
        useDeployContract.test-d.ts
        useDeployContract.ts
        useDisconnect.test-d.ts
        useDisconnect.ts
        useEnsAddress.ts
        useEnsAvatar.ts
        useEnsName.ts
        useEnsResolver.ts
        useEnsText.ts
        useEstimateFeesPerGas.test-d.ts
        useEstimateFeesPerGas.ts
        useEstimateGas.test-d.ts
        useEstimateGas.ts
        useEstimateMaxPriorityFeePerGas.test-d.ts
        useEstimateMaxPriorityFeePerGas.ts
        useFeeHistory.test-d.ts
        useFeeHistory.ts
        useGasPrice.test-d.ts
        useGasPrice.ts
        useInfiniteReadContracts.test-d.ts
        useInfiniteReadContracts.ts
        usePrepareTransactionRequest.test-d.ts
        usePrepareTransactionRequest.ts
        useProof.test-d.ts
        useProof.ts
        usePublicClient.test-d.ts
        usePublicClient.ts
        useReadContract.test-d.ts
        useReadContract.ts
        useReadContracts.test-d.ts
        useReadContracts.ts
        useReconnect.test-d.ts
        useReconnect.ts
        useSendCalls.ts
        useSendTransaction.test-d.ts
        useSendTransaction.ts
        useShowCallsStatus.ts
        useSignMessage.test-d.ts
        useSignMessage.ts
        useSignTypedData.test-d.ts
        useSignTypedData.ts
        useSimulateContract.test-d.ts
        useSimulateContract.ts
        useStorageAt.test-d.ts
        useStorageAt.ts
        useSwitchAccount.test-d.ts
        useSwitchAccount.ts
        useSwitchChain.test-d.ts
        useSwitchChain.ts
        useSyncExternalStoreWithTracked.ts
        useToken.test-d.ts
        useToken.ts
        useTransaction.test-d.ts
        useTransaction.ts
        useTransactionConfirmations.test-d.ts
        useTransactionConfirmations.ts
        useTransactionCount.test-d.ts
        useTransactionCount.ts
        useTransactionReceipt.test-d.ts
        useTransactionReceipt.ts
        useVerifyMessage.test-d.ts
        useVerifyMessage.ts
        useVerifyTypedData.test-d.ts
        useVerifyTypedData.ts
        useWaitForCallsStatus.ts
        useWaitForTransactionReceipt.test-d.ts
        useWaitForTransactionReceipt.ts
        useWalletClient.test-d.ts
        useWalletClient.ts
        useWatchAsset.test-d.ts
        useWatchAsset.ts
        useWatchBlockNumber.test-d.ts
        useWatchBlockNumber.ts
        useWatchBlocks.test-d.ts
        useWatchBlocks.ts
        useWatchContractEvent.test-d.ts
        useWatchContractEvent.ts
        useWatchPendingTransactions.test-d.ts
        useWatchPendingTransactions.ts
        useWriteContract.test-d.ts
        useWriteContract.ts
      types/
        properties.ts
      utils/
        getVersion.ts
        query.ts
      context.ts
      hydrate.ts
      version.ts
    test/
      setup.ts
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
.gitignore
.npmrc
biome.json
FUNDING.json
LICENSE
package.json
pnpm-workspace.yaml
tsconfig.base.json
tsconfig.json
vitest.config.ts
vitest.workspace.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/connectors/src/exports/index.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type InjectedParameters,
  injected,
  type MockParameters,
  mock,
} from '@wagmi/core'

export {
  type CoinbaseWalletParameters,
  coinbaseWallet,
} from '../coinbaseWallet.js'

export { type MetaMaskParameters, metaMask } from '../metaMask.js'

export { type SafeParameters, safe } from '../safe.js'

export {
  type WalletConnectParameters,
  walletConnect,
} from '../walletConnect.js'

export { version } from '../version.js'
</file>

<file path="packages/connectors/src/coinbaseWallet.ts">
import type {
  Preference,
  ProviderInterface,
  createCoinbaseWalletSDK,
} from '@coinbase/wallet-sdk'
import {
  ChainNotConfiguredError,
  type Connector,
  createConnector,
} from '@wagmi/core'
import type { Compute, Mutable, Omit } from '@wagmi/core/internal'
import type {
  CoinbaseWalletProvider as CBW_Provider,
  CoinbaseWalletSDK as CBW_SDK,
} from 'cbw-sdk'
import {
  type AddEthereumChainParameter,
  type Address,
  type Hex,
  type ProviderRpcError,
  SwitchChainError,
  UserRejectedRequestError,
  getAddress,
  numberToHex,
} from 'viem'

type Version = '3' | '4'

export type CoinbaseWalletParameters<version extends Version = '3'> =
  version extends '4'
    ? Compute<
        {
          headlessMode?: false | undefined
          /** Coinbase Wallet SDK version */
          version?: version | '3' | undefined
        } & Version4Parameters
      >
    : Compute<
        {
          /**
           * @deprecated `headlessMode` will be removed in the next major version. Upgrade to `version: '4'`.
           */
          headlessMode?: true | undefined
          /**
           * Coinbase Wallet SDK version
           * @deprecated Version 3 will be removed in the next major version. Upgrade to `version: '4'`.
           * @default '4'
           */
          version?: version | '4' | undefined
        } & Version3Parameters
      >

coinbaseWallet.type = 'coinbaseWallet' as const
export function coinbaseWallet<version extends Version>(
  parameters: CoinbaseWalletParameters<version> = {} as any,
): version extends '4'
  ? ReturnType<typeof version4>
  : ReturnType<typeof version3> {
  if (parameters.version === '3' || parameters.headlessMode)
    return version3(parameters as Version3Parameters) as any
  return version4(parameters as Version4Parameters) as any
}

type Version4Parameters = Mutable<
  Omit<
    Parameters<typeof createCoinbaseWalletSDK>[0],
    | 'appChainIds' // set via wagmi config
    | 'preference'
  > & {
    // TODO(v3): Remove `Preference['options']`
    /**
     * Preference for the type of wallet to display.
     * @default 'all'
     */
    preference?: Preference['options'] | Compute<Preference> | undefined
  }
>

function version4(parameters: Version4Parameters) {
  type Provider = ProviderInterface & {
    // for backwards compatibility
    close?(): void
  }
  type Properties = {
    connect(parameters?: {
      chainId?: number | undefined
      instantOnboarding?: boolean | undefined
      isReconnecting?: boolean | undefined
    }): Promise<{
      accounts: readonly Address[]
      chainId: number
    }>
  }

  let walletProvider: Provider | undefined

  let accountsChanged: Connector['onAccountsChanged'] | undefined
  let chainChanged: Connector['onChainChanged'] | undefined
  let disconnect: Connector['onDisconnect'] | undefined

  return createConnector<Provider, Properties>((config) => ({
    id: 'coinbaseWalletSDK',
    name: 'Coinbase Wallet',
    rdns: 'com.coinbase.wallet',
    type: coinbaseWallet.type,
    async connect({ chainId, ...rest } = {}) {
      try {
        const provider = await this.getProvider()
        const accounts = (
          (await provider.request({
            method: 'eth_requestAccounts',
            params:
              'instantOnboarding' in rest && rest.instantOnboarding
                ? [{ onboarding: 'instant' }]
                : [],
          })) as string[]
        ).map((x) => getAddress(x))

        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged)
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this)
          provider.on('chainChanged', chainChanged)
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this)
          provider.on('disconnect', disconnect)
        }

        // Switch to chain if provided
        let currentChainId = await this.getChainId()
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain!({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code) throw error
            return { id: currentChainId }
          })
          currentChainId = chain?.id ?? currentChainId
        }

        return { accounts, chainId: currentChainId }
      } catch (error) {
        if (
          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(
            (error as Error).message,
          )
        )
          throw new UserRejectedRequestError(error as Error)
        throw error
      }
    },
    async disconnect() {
      const provider = await this.getProvider()

      if (accountsChanged) {
        provider.removeListener('accountsChanged', accountsChanged)
        accountsChanged = undefined
      }
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }

      provider.disconnect()
      provider.close?.()
    },
    async getAccounts() {
      const provider = await this.getProvider()
      return (
        (await provider.request({
          method: 'eth_accounts',
        })) as string[]
      ).map((x) => getAddress(x))
    },
    async getChainId() {
      const provider = await this.getProvider()
      const chainId = (await provider.request({
        method: 'eth_chainId',
      })) as Hex
      return Number(chainId)
    },
    async getProvider() {
      if (!walletProvider) {
        const preference = (() => {
          if (typeof parameters.preference === 'string')
            return { options: parameters.preference }
          return {
            ...parameters.preference,
            options: parameters.preference?.options ?? 'all',
          }
        })()

        const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk')
        const sdk = createCoinbaseWalletSDK({
          ...parameters,
          appChainIds: config.chains.map((x) => x.id),
          preference,
        })

        walletProvider = sdk.getProvider()
      }

      return walletProvider
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts()
        return !!accounts.length
      } catch {
        return false
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const chain = config.chains.find((chain) => chain.id === chainId)
      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())

      const provider = await this.getProvider()

      try {
        await provider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: numberToHex(chain.id) }],
        })
        return chain
      } catch (error) {
        // Indicates chain is not added to provider
        if ((error as ProviderRpcError).code === 4902) {
          try {
            let blockExplorerUrls: string[] | undefined
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls
            else
              blockExplorerUrls = chain.blockExplorers?.default.url
                ? [chain.blockExplorers?.default.url]
                : []

            let rpcUrls: readonly string[]
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls
            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']

            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency:
                addEthereumChainParameter?.nativeCurrency ??
                chain.nativeCurrency,
              rpcUrls,
            } satisfies AddEthereumChainParameter

            await provider.request({
              method: 'wallet_addEthereumChain',
              params: [addEthereumChain],
            })

            return chain
          } catch (error) {
            throw new UserRejectedRequestError(error as Error)
          }
        }

        throw new SwitchChainError(error as Error)
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) this.onDisconnect()
      else
        config.emitter.emit('change', {
          accounts: accounts.map((x) => getAddress(x)),
        })
    },
    onChainChanged(chain) {
      const chainId = Number(chain)
      config.emitter.emit('change', { chainId })
    },
    async onDisconnect(_error) {
      config.emitter.emit('disconnect')

      const provider = await this.getProvider()
      if (accountsChanged) {
        provider.removeListener('accountsChanged', accountsChanged)
        accountsChanged = undefined
      }
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }
    },
  }))
}

type Version3Parameters = Mutable<
  Omit<
    ConstructorParameters<typeof CBW_SDK>[0],
    'reloadOnDisconnect' // remove property since TSDoc says default is `true`
  >
> & {
  /**
   * Fallback Ethereum JSON RPC URL
   * @default ""
   */
  jsonRpcUrl?: string | undefined
  /**
   * Fallback Ethereum Chain ID
   * @default 1
   */
  chainId?: number | undefined
  /**
   * Whether or not to reload dapp automatically after disconnect.
   * @default false
   */
  reloadOnDisconnect?: boolean | undefined
}

function version3(parameters: Version3Parameters) {
  const reloadOnDisconnect = false

  type Provider = CBW_Provider

  let sdk: CBW_SDK | undefined
  let walletProvider: Provider | undefined

  let accountsChanged: Connector['onAccountsChanged'] | undefined
  let chainChanged: Connector['onChainChanged'] | undefined
  let disconnect: Connector['onDisconnect'] | undefined

  return createConnector<Provider>((config) => ({
    id: 'coinbaseWalletSDK',
    name: 'Coinbase Wallet',
    rdns: 'com.coinbase.wallet',
    type: coinbaseWallet.type,
    async connect({ chainId } = {}) {
      try {
        const provider = await this.getProvider()
        const accounts = (
          (await provider.request({
            method: 'eth_requestAccounts',
          })) as string[]
        ).map((x) => getAddress(x))

        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged)
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this)
          provider.on('chainChanged', chainChanged)
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this)
          provider.on('disconnect', disconnect)
        }

        // Switch to chain if provided
        let currentChainId = await this.getChainId()
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain!({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code) throw error
            return { id: currentChainId }
          })
          currentChainId = chain?.id ?? currentChainId
        }

        return { accounts, chainId: currentChainId }
      } catch (error) {
        if (
          /(user closed modal|accounts received is empty|user denied account)/i.test(
            (error as Error).message,
          )
        )
          throw new UserRejectedRequestError(error as Error)
        throw error
      }
    },
    async disconnect() {
      const provider = await this.getProvider()

      if (accountsChanged) {
        provider.removeListener('accountsChanged', accountsChanged)
        accountsChanged = undefined
      }
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }

      provider.disconnect()
      provider.close()
    },
    async getAccounts() {
      const provider = await this.getProvider()
      return (
        await provider.request<string[]>({
          method: 'eth_accounts',
        })
      ).map((x) => getAddress(x))
    },
    async getChainId() {
      const provider = await this.getProvider()
      const chainId = await provider.request<Hex>({
        method: 'eth_chainId',
      })
      return Number(chainId)
    },
    async getProvider() {
      if (!walletProvider) {
        // Unwrapping import for Vite compatibility.
        // See: https://github.com/vitejs/vite/issues/9703
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await import('cbw-sdk')
          if (typeof SDK !== 'function' && typeof SDK.default === 'function')
            return SDK.default
          return SDK as unknown as typeof SDK.default
        })()

        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect })

        // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.
        const walletExtensionChainId = (
          sdk as unknown as {
            get walletExtension(): { getChainId(): number } | undefined
          }
        ).walletExtension?.getChainId()

        const chain =
          config.chains.find((chain) =>
            parameters.chainId
              ? chain.id === parameters.chainId
              : chain.id === walletExtensionChainId,
          ) || config.chains[0]
        const chainId = parameters.chainId || chain?.id
        const jsonRpcUrl =
          parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0]

        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId)
      }

      return walletProvider
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts()
        return !!accounts.length
      } catch {
        return false
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const chain = config.chains.find((chain) => chain.id === chainId)
      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())

      const provider = await this.getProvider()

      try {
        await provider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: numberToHex(chain.id) }],
        })
        return chain
      } catch (error) {
        // Indicates chain is not added to provider
        if ((error as ProviderRpcError).code === 4902) {
          try {
            let blockExplorerUrls: string[] | undefined
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls
            else
              blockExplorerUrls = chain.blockExplorers?.default.url
                ? [chain.blockExplorers?.default.url]
                : []

            let rpcUrls: readonly string[]
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls
            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']

            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency:
                addEthereumChainParameter?.nativeCurrency ??
                chain.nativeCurrency,
              rpcUrls,
            } satisfies AddEthereumChainParameter

            await provider.request({
              method: 'wallet_addEthereumChain',
              params: [addEthereumChain],
            })

            return chain
          } catch (error) {
            throw new UserRejectedRequestError(error as Error)
          }
        }

        throw new SwitchChainError(error as Error)
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) this.onDisconnect()
      else
        config.emitter.emit('change', {
          accounts: accounts.map((x) => getAddress(x)),
        })
    },
    onChainChanged(chain) {
      const chainId = Number(chain)
      config.emitter.emit('change', { chainId })
    },
    async onDisconnect(_error) {
      config.emitter.emit('disconnect')

      const provider = await this.getProvider()
      if (accountsChanged) {
        provider.removeListener('accountsChanged', accountsChanged)
        accountsChanged = undefined
      }
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }
    },
  }))
}
</file>

<file path="packages/connectors/src/metaMask.ts">
import type {
  MetaMaskSDK,
  MetaMaskSDKOptions,
  RPC_URLS_MAP,
  SDKProvider,
} from '@metamask/sdk'
import {
  ChainNotConfiguredError,
  type Connector,
  ProviderNotFoundError,
  createConnector,
  extractRpcUrls,
} from '@wagmi/core'
import type {
  Compute,
  ExactPartial,
  OneOf,
  RemoveUndefined,
  UnionCompute,
} from '@wagmi/core/internal'
import {
  type AddEthereumChainParameter,
  type Address,
  type Hex,
  type ProviderConnectInfo,
  type ProviderRpcError,
  ResourceUnavailableRpcError,
  type RpcError,
  SwitchChainError,
  UserRejectedRequestError,
  getAddress,
  hexToNumber,
  numberToHex,
  withRetry,
  withTimeout,
} from 'viem'

export type MetaMaskParameters = UnionCompute<
  WagmiMetaMaskSDKOptions &
    OneOf<
      | {
          /* Shortcut to connect and sign a message */
          connectAndSign?: string | undefined
        }
      | {
          // TODO: Strongly type `method` and `params`
          /* Allow `connectWith` any rpc method */
          connectWith?: { method: string; params: unknown[] } | undefined
        }
    >
>

type WagmiMetaMaskSDKOptions = Compute<
  ExactPartial<
    Omit<
      MetaMaskSDKOptions,
      | '_source'
      | 'forceDeleteProvider'
      | 'forceInjectProvider'
      | 'injectProvider'
      | 'useDeeplink'
      | 'readonlyRPCMap'
    >
  > & {
    /** @deprecated */
    forceDeleteProvider?: MetaMaskSDKOptions['forceDeleteProvider']
    /** @deprecated */
    forceInjectProvider?: MetaMaskSDKOptions['forceInjectProvider']
    /** @deprecated */
    injectProvider?: MetaMaskSDKOptions['injectProvider']
    /** @deprecated */
    useDeeplink?: MetaMaskSDKOptions['useDeeplink']
  }
>

metaMask.type = 'metaMask' as const
export function metaMask(parameters: MetaMaskParameters = {}) {
  type Provider = SDKProvider
  type Properties = {
    onConnect(connectInfo: ProviderConnectInfo): void
    onDisplayUri(uri: string): void
  }
  type Listener = Parameters<Provider['on']>[1]

  let sdk: MetaMaskSDK
  let provider: Provider | undefined
  let providerPromise: Promise<typeof provider>

  let accountsChanged: Connector['onAccountsChanged'] | undefined
  let chainChanged: Connector['onChainChanged'] | undefined
  let connect: Connector['onConnect'] | undefined
  let displayUri: ((uri: string) => void) | undefined
  let disconnect: Connector['onDisconnect'] | undefined

  return createConnector<Provider, Properties>((config) => ({
    id: 'metaMaskSDK',
    name: 'MetaMask',
    rdns: ['io.metamask', 'io.metamask.mobile'],
    type: metaMask.type,
    async setup() {
      const provider = await this.getProvider()
      if (provider?.on) {
        if (!connect) {
          connect = this.onConnect.bind(this)
          provider.on('connect', connect as Listener)
        }

        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).
        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged as Listener)
        }
      }
    },
    async connect({ chainId, isReconnecting } = {}) {
      const provider = await this.getProvider()
      if (!displayUri) {
        displayUri = this.onDisplayUri
        provider.on('display_uri', displayUri as Listener)
      }

      let accounts: readonly Address[] = []
      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])

      try {
        let signResponse: string | undefined
        let connectWithResponse: unknown | undefined
        if (!accounts?.length) {
          if (parameters.connectAndSign || parameters.connectWith) {
            if (parameters.connectAndSign)
              signResponse = await sdk.connectAndSign({
                msg: parameters.connectAndSign,
              })
            else if (parameters.connectWith)
              connectWithResponse = await sdk.connectWith({
                method: parameters.connectWith.method,
                params: parameters.connectWith.params,
              })

            accounts = await this.getAccounts()
          } else {
            const requestedAccounts = (await sdk.connect()) as string[]
            accounts = requestedAccounts.map((x) => getAddress(x))
          }
        }
        // Switch to chain if provided
        let currentChainId = (await this.getChainId()) as number
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain!({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code) throw error
            return { id: currentChainId }
          })
          currentChainId = chain?.id ?? currentChainId
        }

        if (displayUri) {
          provider.removeListener('display_uri', displayUri)
          displayUri = undefined
        }

        if (signResponse)
          provider.emit('connectAndSign', {
            accounts,
            chainId: currentChainId,
            signResponse,
          })
        else if (connectWithResponse)
          provider.emit('connectWith', {
            accounts,
            chainId: currentChainId,
            connectWithResponse,
          })

        // Manage EIP-1193 event listeners
        // https://eips.ethereum.org/EIPS/eip-1193#events
        if (connect) {
          provider.removeListener('connect', connect)
          connect = undefined
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged as Listener)
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this)
          provider.on('chainChanged', chainChanged as Listener)
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this)
          provider.on('disconnect', disconnect as Listener)
        }

        return { accounts, chainId: currentChainId }
      } catch (err) {
        const error = err as RpcError
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error)
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error)
        throw error
      }
    },
    async disconnect() {
      const provider = await this.getProvider()

      // Manage EIP-1193 event listeners
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }
      if (!connect) {
        connect = this.onConnect.bind(this)
        provider.on('connect', connect as Listener)
      }

      await sdk.terminate()
    },
    async getAccounts() {
      const provider = await this.getProvider()
      const accounts = (await provider.request({
        method: 'eth_accounts',
      })) as string[]
      return accounts.map((x) => getAddress(x))
    },
    async getChainId() {
      const provider = await this.getProvider()
      const chainId =
        provider.getChainId() ||
        (await provider?.request({ method: 'eth_chainId' }))
      return Number(chainId)
    },
    async getProvider() {
      async function initProvider() {
        // Unwrapping import for Vite compatibility.
        // See: https://github.com/vitejs/vite/issues/9703
        const MetaMaskSDK = await (async () => {
          const { default: SDK } = await import('@metamask/sdk')
          if (typeof SDK !== 'function' && typeof SDK.default === 'function')
            return SDK.default
          return SDK as unknown as typeof SDK.default
        })()

        const readonlyRPCMap: RPC_URLS_MAP = {}
        for (const chain of config.chains)
          readonlyRPCMap[numberToHex(chain.id)] = extractRpcUrls({
            chain,
            transports: config.transports,
          })?.[0]

        sdk = new MetaMaskSDK({
          _source: 'wagmi',
          forceDeleteProvider: false,
          forceInjectProvider: false,
          injectProvider: false,
          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
          ...(parameters as RemoveUndefined<typeof parameters>),
          readonlyRPCMap,
          dappMetadata: {
            ...parameters.dappMetadata,
            // Test if name and url are set AND not empty
            name: parameters.dappMetadata?.name
              ? parameters.dappMetadata?.name
              : 'wagmi',
            url: parameters.dappMetadata?.url
              ? parameters.dappMetadata?.url
              : typeof window !== 'undefined'
                ? window.location.origin
                : 'https://wagmi.sh',
          },
          useDeeplink: parameters.useDeeplink ?? true,
        })
        const result = await sdk.init()
        // On initial load, sometimes `sdk.getProvider` does not return provider.
        // https://github.com/wevm/wagmi/issues/4367
        // Use result of `init` call if available.
        const provider = (() => {
          if (result?.activeProvider) return result.activeProvider
          return sdk.getProvider()
        })()
        if (!provider) throw new ProviderNotFoundError()
        return provider
      }

      if (!provider) {
        if (!providerPromise) providerPromise = initProvider()
        provider = await providerPromise
      }
      return provider!
    },
    async isAuthorized() {
      try {
        // MetaMask mobile provider sometimes fails to immediately resolve
        // JSON-RPC requests on page load
        const timeout = 200
        const accounts = await withRetry(
          () => withTimeout(() => this.getAccounts(), { timeout }),
          {
            delay: timeout + 1,
            retryCount: 3,
          },
        )
        return !!accounts.length
      } catch {
        return false
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider()

      const chain = config.chains.find((x) => x.id === chainId)
      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())

      try {
        await provider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: numberToHex(chainId) }],
        })

        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.
        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.
        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via
        // this callback or an externally emitted `'chainChanged'` event.
        // https://github.com/MetaMask/metamask-extension/issues/24247
        await waitForChainIdToSync()
        await sendAndWaitForChangeEvent(chainId)

        return chain
      } catch (err) {
        const error = err as RpcError

        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error)

        // Indicates chain is not added to provider
        if (
          error.code === 4902 ||
          // Unwrapping for MetaMask Mobile
          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
          (error as ProviderRpcError<{ originalError?: { code: number } }>)
            ?.data?.originalError?.code === 4902
        ) {
          try {
            await provider.request({
              method: 'wallet_addEthereumChain',
              params: [
                {
                  blockExplorerUrls: (() => {
                    const { default: blockExplorer, ...blockExplorers } =
                      chain.blockExplorers ?? {}
                    if (addEthereumChainParameter?.blockExplorerUrls)
                      return addEthereumChainParameter.blockExplorerUrls
                    if (blockExplorer)
                      return [
                        blockExplorer.url,
                        ...Object.values(blockExplorers).map((x) => x.url),
                      ]
                    return
                  })(),
                  chainId: numberToHex(chainId),
                  chainName: addEthereumChainParameter?.chainName ?? chain.name,
                  iconUrls: addEthereumChainParameter?.iconUrls,
                  nativeCurrency:
                    addEthereumChainParameter?.nativeCurrency ??
                    chain.nativeCurrency,
                  rpcUrls: (() => {
                    if (addEthereumChainParameter?.rpcUrls?.length)
                      return addEthereumChainParameter.rpcUrls
                    return [chain.rpcUrls.default?.http[0] ?? '']
                  })(),
                } satisfies AddEthereumChainParameter,
              ],
            })

            await waitForChainIdToSync()
            await sendAndWaitForChangeEvent(chainId)

            return chain
          } catch (err) {
            const error = err as RpcError
            if (error.code === UserRejectedRequestError.code)
              throw new UserRejectedRequestError(error)
            throw new SwitchChainError(error)
          }
        }

        throw new SwitchChainError(error)
      }

      async function waitForChainIdToSync() {
        // On mobile, there is a race condition between the result of `'wallet_addEthereumChain'` and `'eth_chainId'`.
        // To avoid this, we wait for `'eth_chainId'` to return the expected chain ID with a retry loop.
        await withRetry(
          async () => {
            const value = hexToNumber(
              // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks
              (await provider.request({ method: 'eth_chainId' })) as Hex,
            )
            // `value` doesn't match expected `chainId`, throw to trigger retry
            if (value !== chainId)
              throw new Error('User rejected switch after adding network.')
            return value
          },
          {
            delay: 50,
            retryCount: 20, // android device encryption is slower
          },
        )
      }

      async function sendAndWaitForChangeEvent(chainId: number) {
        await new Promise<void>((resolve) => {
          const listener = ((data) => {
            if ('chainId' in data && data.chainId === chainId) {
              config.emitter.off('change', listener)
              resolve()
            }
          }) satisfies Parameters<typeof config.emitter.on>[1]
          config.emitter.on('change', listener)
          config.emitter.emit('change', { chainId })
        })
      }
    },
    async onAccountsChanged(accounts) {
      // Disconnect if there are no accounts
      if (accounts.length === 0) {
        // ... and using browser extension
        if (sdk.isExtensionActive()) this.onDisconnect()
        // FIXME(upstream): Mobile app sometimes emits invalid `accountsChanged` event with empty accounts array
        else return
      }
      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)
      else if (config.emitter.listenerCount('connect')) {
        const chainId = (await this.getChainId()).toString()
        this.onConnect({ chainId })
      }
      // Regular change event
      else
        config.emitter.emit('change', {
          accounts: accounts.map((x) => getAddress(x)),
        })
    },
    onChainChanged(chain) {
      const chainId = Number(chain)
      config.emitter.emit('change', { chainId })
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts()
      if (accounts.length === 0) return

      const chainId = Number(connectInfo.chainId)
      config.emitter.emit('connect', { accounts, chainId })

      const provider = await this.getProvider()
      if (connect) {
        provider.removeListener('connect', connect)
        connect = undefined
      }
      if (!accountsChanged) {
        accountsChanged = this.onAccountsChanged.bind(this)
        provider.on('accountsChanged', accountsChanged as Listener)
      }
      if (!chainChanged) {
        chainChanged = this.onChainChanged.bind(this)
        provider.on('chainChanged', chainChanged as Listener)
      }
      if (!disconnect) {
        disconnect = this.onDisconnect.bind(this)
        provider.on('disconnect', disconnect as Listener)
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider()

      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
      // https://github.com/MetaMask/providers/pull/120
      if (error && (error as RpcError<1013>).code === 1013) {
        if (provider && !!(await this.getAccounts()).length) return
      }

      config.emitter.emit('disconnect')

      // Manage EIP-1193 event listeners
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }
      if (!connect) {
        connect = this.onConnect.bind(this)
        provider.on('connect', connect as Listener)
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit('message', { type: 'display_uri', data: uri })
    },
  }))
}
</file>

<file path="packages/connectors/src/safe.ts">
import type { SafeAppProvider } from '@safe-global/safe-apps-provider'
import type { Opts } from '@safe-global/safe-apps-sdk'
import {
  type Connector,
  ProviderNotFoundError,
  createConnector,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import { getAddress, withTimeout } from 'viem'

export type SafeParameters = Compute<
  Opts & {
    /**
     * Connector automatically connects when used as Safe App.
     *
     * This flag simulates the disconnect behavior by keeping track of connection status in storage
     * and only autoconnecting when previously connected by user action (e.g. explicitly choosing to connect).
     *
     * @default false
     */
    shimDisconnect?: boolean | undefined
    /**
     * Timeout in milliseconds for `getInfo` (from the Safe SDK) to resolve.
     *
     * `getInfo` does not resolve when not used in Safe App iFrame. This allows the connector to force a timeout.
     * @default 10
     */
    unstable_getInfoTimeout?: number | undefined
  }
>

safe.type = 'safe' as const
export function safe(parameters: SafeParameters = {}) {
  const { shimDisconnect = false } = parameters

  type Provider = SafeAppProvider | undefined
  type Properties = Record<string, unknown>
  type StorageItem = { 'safe.disconnected': true }

  let provider_: Provider | undefined

  let disconnect: Connector['onDisconnect'] | undefined

  return createConnector<Provider, Properties, StorageItem>((config) => ({
    id: 'safe',
    name: 'Safe',
    type: safe.type,
    async connect() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()

      const accounts = await this.getAccounts()
      const chainId = await this.getChainId()

      if (!disconnect) {
        disconnect = this.onDisconnect.bind(this)
        provider.on('disconnect', disconnect)
      }

      // Remove disconnected shim if it exists
      if (shimDisconnect) await config.storage?.removeItem('safe.disconnected')

      return { accounts, chainId }
    },
    async disconnect() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()

      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }

      // Add shim signalling connector is disconnected
      if (shimDisconnect)
        await config.storage?.setItem('safe.disconnected', true)
    },
    async getAccounts() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()
      return (await provider.request({ method: 'eth_accounts' })).map(
        getAddress,
      )
    },
    async getProvider() {
      // Only allowed in iframe context
      const isIframe =
        typeof window !== 'undefined' && window?.parent !== window
      if (!isIframe) return

      if (!provider_) {
        const { default: SDK } = await import('@safe-global/safe-apps-sdk')
        const sdk = new SDK(parameters)

        // `getInfo` hangs when not used in Safe App iFrame
        // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840
        const safe = await withTimeout(() => sdk.safe.getInfo(), {
          timeout: parameters.unstable_getInfoTimeout ?? 10,
        })
        if (!safe) throw new Error('Could not load Safe information')
        // Unwrapping import for Vite compatibility.
        // See: https://github.com/vitejs/vite/issues/9703
        const SafeAppProvider = await (async () => {
          const Provider = await import('@safe-global/safe-apps-provider')
          if (
            typeof Provider.SafeAppProvider !== 'function' &&
            typeof Provider.default.SafeAppProvider === 'function'
          )
            return Provider.default.SafeAppProvider
          return Provider.SafeAppProvider
        })()
        provider_ = new SafeAppProvider(safe, sdk)
      }
      return provider_
    },
    async getChainId() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()
      return Number(provider.chainId)
    },
    async isAuthorized() {
      try {
        const isDisconnected =
          shimDisconnect &&
          // If shim exists in storage, connector is disconnected
          (await config.storage?.getItem('safe.disconnected'))
        if (isDisconnected) return false

        const accounts = await this.getAccounts()
        return !!accounts.length
      } catch {
        return false
      }
    },
    onAccountsChanged() {
      // Not relevant for Safe because changing account requires app reload.
    },
    onChainChanged() {
      // Not relevant for Safe because Safe smart contract wallets only exist on single chain.
    },
    onDisconnect() {
      config.emitter.emit('disconnect')
    },
  }))
}
</file>

<file path="packages/connectors/src/version.ts">
export const version = '5.8.1'
</file>

<file path="packages/connectors/src/walletConnect.ts">
import {
  ChainNotConfiguredError,
  type Connector,
  ProviderNotFoundError,
  createConnector,
  extractRpcUrls,
} from '@wagmi/core'
import type { Compute, ExactPartial, Omit } from '@wagmi/core/internal'
import type { EthereumProvider } from '@walletconnect/ethereum-provider'
import {
  type AddEthereumChainParameter,
  type Address,
  type ProviderConnectInfo,
  type ProviderRpcError,
  type RpcError,
  SwitchChainError,
  UserRejectedRequestError,
  getAddress,
  numberToHex,
} from 'viem'

type WalletConnectConnector = Connector & {
  onDisplayUri(uri: string): void
  onSessionDelete(data: { topic: string }): void
}

type EthereumProviderOptions = Parameters<(typeof EthereumProvider)['init']>[0]

export type WalletConnectParameters = Compute<
  {
    /**
     * If a new chain is added to a previously existing configured connector `chains`, this flag
     * will determine if that chain should be considered as stale. A stale chain is a chain that
     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or
     * rejected the chain).
     *
     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization
     * with WalletConnect v2.
     *
     * If `true` (default), the new chain will be treated as a stale chain. If the user
     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect
     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to
     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.
     * This is the default behavior to avoid an unexpected error upon switching chains which may
     * be a confusing user experience (e.g. the user will not know they have to reconnect
     * unless the dapp handles these types of errors).
     *
     * If `false`, the new chain will be treated as a potentially valid chain. This means that if the user
     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully
     * auto-connect the user. This comes with the trade-off that the connector will throw an error
     * when attempting to switch to the unapproved chain if the wallet does not support dynamic session updates.
     * This may be useful in cases where a dapp constantly
     * modifies their configured chains, and they do not want to disconnect the user upon
     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the
     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve
     * the newly added chain.
     *
     * @default true
     */
    isNewChainsStale?: boolean
  } & Omit<
    EthereumProviderOptions,
    | 'chains'
    | 'events'
    | 'optionalChains'
    | 'optionalEvents'
    | 'optionalMethods'
    | 'methods'
    | 'rpcMap'
    | 'showQrModal'
  > &
    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>
>

walletConnect.type = 'walletConnect' as const
export function walletConnect(parameters: WalletConnectParameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true

  type Provider = Awaited<ReturnType<(typeof EthereumProvider)['init']>>
  type Properties = {
    connect(parameters?: {
      chainId?: number | undefined
      isReconnecting?: boolean | undefined
      pairingTopic?: string | undefined
    }): Promise<{
      accounts: readonly Address[]
      chainId: number
    }>
    getNamespaceChainsIds(): number[]
    getRequestedChainsIds(): Promise<number[]>
    isChainsStale(): Promise<boolean>
    onConnect(connectInfo: ProviderConnectInfo): void
    onDisplayUri(uri: string): void
    onSessionDelete(data: { topic: string }): void
    setRequestedChainsIds(chains: number[]): void
    requestedChainsStorageKey: `${string}.requestedChains`
  }
  type StorageItem = {
    [_ in Properties['requestedChainsStorageKey']]: number[]
  }

  let provider_: Provider | undefined
  let providerPromise: Promise<typeof provider_>
  const NAMESPACE = 'eip155'

  let accountsChanged: WalletConnectConnector['onAccountsChanged'] | undefined
  let chainChanged: WalletConnectConnector['onChainChanged'] | undefined
  let connect: WalletConnectConnector['onConnect'] | undefined
  let displayUri: WalletConnectConnector['onDisplayUri'] | undefined
  let sessionDelete: WalletConnectConnector['onSessionDelete'] | undefined
  let disconnect: WalletConnectConnector['onDisconnect'] | undefined

  return createConnector<Provider, Properties, StorageItem>((config) => ({
    id: 'walletConnect',
    name: 'WalletConnect',
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null)
      if (!provider) return
      if (!connect) {
        connect = this.onConnect.bind(this)
        provider.on('connect', connect)
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this)
        provider.on('session_delete', sessionDelete)
      }
    },
    async connect({ chainId, ...rest } = {}) {
      try {
        const provider = await this.getProvider()
        if (!provider) throw new ProviderNotFoundError()
        if (!displayUri) {
          displayUri = this.onDisplayUri
          provider.on('display_uri', displayUri)
        }

        let targetChainId = chainId
        if (!targetChainId) {
          const state = (await config.storage?.getItem('state')) ?? {}
          const isChainSupported = config.chains.some(
            (x) => x.id === state.chainId,
          )
          if (isChainSupported) targetChainId = state.chainId
          else targetChainId = config.chains[0]?.id
        }
        if (!targetChainId) throw new Error('No chains found on connector.')

        const isChainsStale = await this.isChainsStale()
        // If there is an active session with stale chains, disconnect current session.
        if (provider.session && isChainsStale) await provider.disconnect()

        // If there isn't an active session or chains are stale, connect.
        if (!provider.session || isChainsStale) {
          const optionalChains = config.chains
            .filter((chain) => chain.id !== targetChainId)
            .map((optionalChain) => optionalChain.id)
          await provider.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ...('pairingTopic' in rest
              ? { pairingTopic: rest.pairingTopic }
              : {}),
          })

          this.setRequestedChainsIds(config.chains.map((x) => x.id))
        }

        // If session exists and chains are authorized, enable provider for required chain
        const accounts = (await provider.enable()).map((x) => getAddress(x))
        const currentChainId = await this.getChainId()

        if (displayUri) {
          provider.removeListener('display_uri', displayUri)
          displayUri = undefined
        }
        if (connect) {
          provider.removeListener('connect', connect)
          connect = undefined
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged)
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this)
          provider.on('chainChanged', chainChanged)
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this)
          provider.on('disconnect', disconnect)
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this)
          provider.on('session_delete', sessionDelete)
        }

        return { accounts, chainId: currentChainId }
      } catch (error) {
        if (
          /(user rejected|connection request reset)/i.test(
            (error as ProviderRpcError)?.message,
          )
        ) {
          throw new UserRejectedRequestError(error as Error)
        }
        throw error
      }
    },
    async disconnect() {
      const provider = await this.getProvider()
      try {
        await provider?.disconnect()
      } catch (error) {
        if (!/No matching key/i.test((error as Error).message)) throw error
      } finally {
        if (chainChanged) {
          provider?.removeListener('chainChanged', chainChanged)
          chainChanged = undefined
        }
        if (disconnect) {
          provider?.removeListener('disconnect', disconnect)
          disconnect = undefined
        }
        if (!connect) {
          connect = this.onConnect.bind(this)
          provider?.on('connect', connect)
        }
        if (accountsChanged) {
          provider?.removeListener('accountsChanged', accountsChanged)
          accountsChanged = undefined
        }
        if (sessionDelete) {
          provider?.removeListener('session_delete', sessionDelete)
          sessionDelete = undefined
        }

        this.setRequestedChainsIds([])
      }
    },
    async getAccounts() {
      const provider = await this.getProvider()
      return provider.accounts.map((x) => getAddress(x))
    },
    async getProvider({ chainId } = {}) {
      async function initProvider() {
        const optionalChains = config.chains.map((x) => x.id) as [number]
        if (!optionalChains.length) return
        const { EthereumProvider } = await import(
          '@walletconnect/ethereum-provider'
        )
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(
            config.chains.map((chain) => {
              const [url] = extractRpcUrls({
                chain,
                transports: config.transports,
              })
              return [chain.id, url]
            }),
          ),
          showQrModal: parameters.showQrModal ?? true,
        })
      }

      if (!provider_) {
        if (!providerPromise) providerPromise = initProvider()
        provider_ = await providerPromise
        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY)
      }
      if (chainId) await this.switchChain?.({ chainId })
      return provider_!
    },
    async getChainId() {
      const provider = await this.getProvider()
      return provider.chainId
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([
          this.getAccounts(),
          this.getProvider(),
        ])

        // If an account does not exist on the session, then the connector is unauthorized.
        if (!accounts.length) return false

        // If the chains are stale on the session, then the connector is unauthorized.
        const isChainsStale = await this.isChainsStale()
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {})
          return false
        }
        return true
      } catch {
        return false
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()

      const chain = config.chains.find((x) => x.id === chainId)
      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())

      try {
        await Promise.all([
          new Promise<void>((resolve) => {
            const listener = ({
              chainId: currentChainId,
            }: { chainId?: number | undefined }) => {
              if (currentChainId === chainId) {
                config.emitter.off('change', listener)
                resolve()
              }
            }
            config.emitter.on('change', listener)
          }),
          provider.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: numberToHex(chainId) }],
          }),
        ])

        const requestedChains = await this.getRequestedChainsIds()
        this.setRequestedChainsIds([...requestedChains, chainId])

        return chain
      } catch (err) {
        const error = err as RpcError

        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error)

        // Indicates chain is not added to provider
        try {
          let blockExplorerUrls: string[] | undefined
          if (addEthereumChainParameter?.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls
          else
            blockExplorerUrls = chain.blockExplorers?.default.url
              ? [chain.blockExplorers?.default.url]
              : []

          let rpcUrls: readonly string[]
          if (addEthereumChainParameter?.rpcUrls?.length)
            rpcUrls = addEthereumChainParameter.rpcUrls
          else rpcUrls = [...chain.rpcUrls.default.http]

          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: addEthereumChainParameter?.chainName ?? chain.name,
            iconUrls: addEthereumChainParameter?.iconUrls,
            nativeCurrency:
              addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
            rpcUrls,
          } satisfies AddEthereumChainParameter

          await provider.request({
            method: 'wallet_addEthereumChain',
            params: [addEthereumChain],
          })

          const requestedChains = await this.getRequestedChainsIds()
          this.setRequestedChainsIds([...requestedChains, chainId])
          return chain
        } catch (error) {
          throw new UserRejectedRequestError(error as Error)
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) this.onDisconnect()
      else
        config.emitter.emit('change', {
          accounts: accounts.map((x) => getAddress(x)),
        })
    },
    onChainChanged(chain) {
      const chainId = Number(chain)
      config.emitter.emit('change', { chainId })
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId)
      const accounts = await this.getAccounts()
      config.emitter.emit('connect', { accounts, chainId })
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([])
      config.emitter.emit('disconnect')

      const provider = await this.getProvider()
      if (accountsChanged) {
        provider.removeListener('accountsChanged', accountsChanged)
        accountsChanged = undefined
      }
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }
      if (sessionDelete) {
        provider.removeListener('session_delete', sessionDelete)
        sessionDelete = undefined
      }
      if (!connect) {
        connect = this.onConnect.bind(this)
        provider.on('connect', connect)
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit('message', { type: 'display_uri', data: uri })
    },
    onSessionDelete() {
      this.onDisconnect()
    },
    getNamespaceChainsIds() {
      if (!provider_) return []
      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map(
        (account) => Number.parseInt(account.split(':')[1] || ''),
      )
      return chainIds ?? []
    },
    async getRequestedChainsIds() {
      return (
        (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []
      )
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale) return false

      const connectorChains = config.chains.map((x) => x.id)
      const namespaceChains = this.getNamespaceChainsIds()
      if (
        namespaceChains.length &&
        !namespaceChains.some((id) => connectorChains.includes(id))
      )
        return false

      const requestedChains = await this.getRequestedChainsIds()
      return !connectorChains.every((id) => requestedChains.includes(id))
    },
    async setRequestedChainsIds(chains) {
      await config.storage?.setItem(this.requestedChainsStorageKey, chains)
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey']
    },
  }))
}
</file>

<file path="packages/connectors/package.json">
{
  "name": "@wagmi/connectors",
  "description": "Collection of connectors for Wagmi",
  "version": "5.8.1",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/wevm/wagmi.git",
    "directory": "packages/connectors"
  },
  "scripts": {
    "build": "pnpm run clean && pnpm run build:esm+types",
    "build:esm+types": "tsc --project tsconfig.build.json --outDir ./dist/esm --declaration --declarationMap --declarationDir ./dist/types",
    "check:types": "tsc --noEmit",
    "clean": "rm -rf dist tsconfig.tsbuildinfo",
    "test:build": "publint --strict && attw --pack --ignore-rules cjs-resolves-to-esm"
  },
  "files": [
    "dist/**",
    "!dist/**/*.tsbuildinfo",
    "src/**/*.ts",
    "!src/**/*.test.ts",
    "!src/**/*.test-d.ts"
  ],
  "sideEffects": false,
  "type": "module",
  "main": "./dist/esm/exports/index.js",
  "types": "./dist/types/exports/index.d.ts",
  "typings": "./dist/types/exports/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/types/exports/index.d.ts",
      "default": "./dist/esm/exports/index.js"
    },
    "./package.json": "./package.json"
  },
  "peerDependencies": {
    "@wagmi/core": "workspace:*",
    "typescript": ">=5.0.4",
    "viem": "2.x"
  },
  "peerDependenciesMeta": {
    "typescript": {
      "optional": true
    }
  },
  "dependencies": {
    "@coinbase/wallet-sdk": "4.3.0",
    "@metamask/sdk": "0.32.0",
    "@safe-global/safe-apps-provider": "0.18.6",
    "@safe-global/safe-apps-sdk": "9.1.0",
    "@walletconnect/ethereum-provider": "2.20.0",
    "cbw-sdk": "npm:@coinbase/wallet-sdk@3.9.3"
  },
  "devDependencies": {
    "@wagmi/core": "workspace:*",
    "msw": "^2.4.9"
  },
  "contributors": ["awkweb.eth <t@wevm.dev>", "jxom.eth <j@wevm.dev>"],
  "funding": "https://github.com/sponsors/wevm",
  "keywords": [
    "react",
    "hooks",
    "eth",
    "ethereum",
    "dapps",
    "wallet",
    "web3",
    "abi"
  ]
}
</file>

<file path="packages/connectors/README.md">
# @wagmi/connectors

Collection of connectors for Wagmi

## Installation

```bash
pnpm add @wagmi/connectors @wagmi/core viem
```

## Documentation

For documentation and guides, visit [wagmi.sh](https://wagmi.sh).
</file>

<file path="packages/connectors/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/*.test.ts", "src/**/*.test-d.ts"],
  "compilerOptions": {
    "sourceMap": true
  }
}
</file>

<file path="packages/connectors/tsconfig.json">
{
  "extends": "./tsconfig.build.json",
  "include": ["src/**/*.ts"],
  "exclude": []
}
</file>

<file path="packages/core/src/actions/codegen/createReadContract.test-d.ts">
import { abi, config, mainnet, optimism } from '@wagmi/test'
import { assertType, expectTypeOf, test } from 'vitest'

import { createReadContract } from './createReadContract.js'

test('default', async () => {
  const readErc20 = createReadContract({
    abi: abi.erc20,
    address: '0x',
  })

  const result = await readErc20(config, {
    functionName: 'balanceOf',
    args: ['0x'],
    chainId: 1,
  })
  expectTypeOf(result).toEqualTypeOf<bigint>()
})

test('multichain address', async () => {
  const readErc20 = createReadContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const result = await readErc20(config, {
    functionName: 'balanceOf',
    args: ['0x'],
    chainId: mainnet.id,
    // ^?
  })
  assertType<bigint>(result)

  readErc20(config, {
    functionName: 'balanceOf',
    args: ['0x'],
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  readErc20(config, {
    functionName: 'balanceOf',
    args: ['0x'],
    // @ts-expect-error address not allowed
    address: '0x',
  })
})

test('overloads', async () => {
  const readViewOverloads = createReadContract({
    abi: abi.viewOverloads,
    address: '0x',
  })

  const result1 = await readViewOverloads(config, {
    functionName: 'foo',
  })
  assertType<number>(result1)

  const result2 = await readViewOverloads(config, {
    functionName: 'foo',
    args: [],
  })
  assertType<number>(result2)

  const result3 = await readViewOverloads(config, {
    functionName: 'foo',
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string>(result3)

  const result4 = await readViewOverloads(config, {
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  assertType<{
    foo: `0x${string}`
    bar: `0x${string}`
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  }>(result4)
})

test('functionName', async () => {
  const readErc20BalanceOf = createReadContract({
    abi: abi.erc20,
    address: '0x',
    functionName: 'balanceOf',
  })

  const result = await readErc20BalanceOf(config, {
    args: ['0x'],
    chainId: 1,
  })
  expectTypeOf(result).toEqualTypeOf<bigint>()
})

test('functionName with overloads', async () => {
  const readViewOverloads = createReadContract({
    abi: abi.viewOverloads,
    address: '0x',
    functionName: 'foo',
  })

  const result1 = await readViewOverloads(config, {})
  assertType<number>(result1)

  const result2 = await readViewOverloads(config, {
    args: [],
  })
  assertType<number>(result2)

  const result3 = await readViewOverloads(config, {
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string>(result3)

  const result4 = await readViewOverloads(config, {
    args: ['0x', '0x'],
  })
  assertType<{
    foo: `0x${string}`
    bar: `0x${string}`
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  }>(result4)
})
</file>

<file path="packages/core/src/actions/codegen/createReadContract.ts">
import type {
  Abi,
  Address,
  ContractFunctionArgs,
  ContractFunctionName,
} from 'viem'

import type { Config } from '../../createConfig.js'
import type { UnionCompute, UnionStrictOmit } from '../../types/utils.js'
import { getAccount } from '../getAccount.js'
import { getChainId } from '../getChainId.js'
import {
  type ReadContractParameters,
  type ReadContractReturnType,
  readContract,
} from '../readContract.js'

type stateMutability = 'pure' | 'view'

export type CreateReadContractParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  functionName?:
    | functionName
    | ContractFunctionName<abi, stateMutability>
    | undefined
}

export type CreateReadContractReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
  ///
  omittedProperties extends 'abi' | 'address' | 'chainId' | 'functionName' =
    | 'abi'
    | (address extends undefined ? never : 'address')
    | (address extends Record<number, Address> ? 'chainId' : never)
    | (functionName extends undefined ? never : 'functionName'),
> = <
  config extends Config,
  name extends functionName extends ContractFunctionName<abi, stateMutability>
    ? functionName
    : ContractFunctionName<abi, stateMutability>,
  args extends ContractFunctionArgs<abi, stateMutability, name>,
>(
  config: config,
  parameters: UnionCompute<
    UnionStrictOmit<
      ReadContractParameters<abi, name, args, config>,
      omittedProperties
    >
  > &
    (address extends Record<number, Address>
      ? { chainId?: keyof address | undefined }
      : unknown),
) => Promise<ReadContractReturnType<abi, name, args>>

export function createReadContract<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
>(
  c: CreateReadContractParameters<abi, address, functionName>,
): CreateReadContractReturnType<abi, address, functionName> {
  if (c.address !== undefined && typeof c.address === 'object')
    return (config, parameters) => {
      const configChainId = getChainId(config)
      const account = getAccount(config)
      const chainId =
        (parameters as { chainId?: number })?.chainId ??
        account.chainId ??
        configChainId
      return readContract(config, {
        ...(parameters as any),
        ...(c.functionName ? { functionName: c.functionName } : {}),
        address: c.address?.[chainId],
        abi: c.abi,
      })
    }

  return (config, parameters) => {
    return readContract(config, {
      ...(parameters as any),
      ...(c.address ? { address: c.address } : {}),
      ...(c.functionName ? { functionName: c.functionName } : {}),
      abi: c.abi,
    })
  }
}
</file>

<file path="packages/core/src/actions/codegen/createSimulateContract.test-d.ts">
import { abi, config, mainnet, optimism } from '@wagmi/test'
import { http, type Address } from 'viem'
import { celo } from 'viem/chains'
import { assertType, expectTypeOf, test } from 'vitest'

import { createConfig } from '../../createConfig.js'
import { createSimulateContract } from './createSimulateContract.js'

test('default', async () => {
  const simulateErc20 = createSimulateContract({
    abi: abi.erc20,
    address: '0x',
  })

  const result = await simulateErc20(config, {
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })

  expectTypeOf(result).toMatchTypeOf<{
    result: boolean
    request: {
      chainId: 1
      abi: readonly [
        {
          readonly name: 'transferFrom'
          readonly type: 'function'
          readonly stateMutability: 'nonpayable'
          readonly inputs: readonly [
            { readonly type: 'address'; readonly name: 'sender' },
            { readonly type: 'address'; readonly name: 'recipient' },
            { readonly type: 'uint256'; readonly name: 'amount' },
          ]
          readonly outputs: readonly [{ type: 'bool' }]
        },
      ]
      functionName: 'transferFrom'
      args: readonly [Address, Address, bigint]
    }
  }>()
})

test('multichain address', async () => {
  const simulateErc20 = createSimulateContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const result = await simulateErc20(config, {
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: optimism.id,
  })
  expectTypeOf(result.result).toEqualTypeOf<boolean>()

  simulateErc20(config, {
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  simulateErc20(config, {
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error address not allowed
    address: '0x',
  })
})

test('overloads', async () => {
  const simulateWriteOverloads = createSimulateContract({
    abi: abi.writeOverloads,
    address: '0x',
  })

  const result1 = await simulateWriteOverloads(config, {
    functionName: 'foo',
  })
  assertType<number | undefined>(result1.result)

  const result2 = await simulateWriteOverloads(config, {
    functionName: 'foo',
    args: [],
  })
  assertType<number | undefined>(result2.result)

  const result3 = await simulateWriteOverloads(config, {
    functionName: 'foo',
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.result)

  const result4 = await simulateWriteOverloads(config, {
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.result)
})

test('functionName', async () => {
  const simulateErc20 = createSimulateContract({
    abi: abi.erc20,
    address: '0x',
    functionName: 'transferFrom',
  })

  const result = await simulateErc20(config, {
    args: ['0x', '0x', 123n],
    chainId: 1,
  })

  expectTypeOf(result).toMatchTypeOf<{
    result: boolean
    request: {
      chainId: 1
      abi: readonly [
        {
          readonly name: 'transferFrom'
          readonly type: 'function'
          readonly stateMutability: 'nonpayable'
          readonly inputs: readonly [
            { readonly type: 'address'; readonly name: 'sender' },
            { readonly type: 'address'; readonly name: 'recipient' },
            { readonly type: 'uint256'; readonly name: 'amount' },
          ]
          readonly outputs: readonly [{ type: 'bool' }]
        },
      ]
      functionName: 'transferFrom'
      args: readonly [Address, Address, bigint]
    }
  }>()
})

test('functionName with overloads', async () => {
  const simulateWriteOverloads = createSimulateContract({
    abi: abi.writeOverloads,
    address: '0x',
    functionName: 'foo',
  })

  const result1 = await simulateWriteOverloads(config, {})
  assertType<number | undefined>(result1.result)

  const result2 = await simulateWriteOverloads(config, {
    args: [],
  })
  assertType<number | undefined>(result2.result)

  const result3 = await simulateWriteOverloads(config, {
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.result)

  const result4 = await simulateWriteOverloads(config, {
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.result)
})

test('chain formatters', async () => {
  const simulateErc20 = createSimulateContract({
    abi: abi.erc20,
    address: '0x',
  })

  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  const response = await simulateErc20(config, {
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
  })
  if (response.chainId === celo.id) {
    expectTypeOf(response.request.feeCurrency).toEqualTypeOf<
      `0x${string}` | undefined
    >()
  }

  const response2 = await simulateErc20(config, {
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: celo.id,
  })
  expectTypeOf(response2.request.feeCurrency).toEqualTypeOf<
    `0x${string}` | undefined
  >()
})
</file>

<file path="packages/core/src/actions/codegen/createSimulateContract.ts">
import type {
  Abi,
  Account,
  Address,
  Chain,
  ContractFunctionArgs,
  ContractFunctionName,
  SimulateContractParameters as viem_SimulateContractParameters,
} from 'viem'

import type { Config } from '../../createConfig.js'
import type { SelectChains } from '../../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../../types/properties.js'
import type { UnionCompute, UnionStrictOmit } from '../../types/utils.js'
import { getAccount } from '../getAccount.js'
import { getChainId } from '../getChainId.js'
import {
  type SimulateContractReturnType,
  simulateContract,
} from '../simulateContract.js'

type stateMutability = 'nonpayable' | 'payable'

export type CreateSimulateContractParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  functionName?:
    | functionName
    | ContractFunctionName<abi, stateMutability>
    | undefined
}

export type CreateSimulateContractReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
> = <
  config extends Config,
  name extends functionName extends ContractFunctionName<abi, stateMutability>
    ? functionName
    : ContractFunctionName<abi, stateMutability>,
  args extends ContractFunctionArgs<abi, stateMutability, name>,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
>(
  config: config,
  parameters: {
    [key in keyof chains]: UnionCompute<
      UnionStrictOmit<
        viem_SimulateContractParameters<
          abi,
          name,
          args,
          chains[key],
          chains[key],
          Account | Address
        >,
        | 'abi'
        | 'chain'
        | (address extends undefined ? never : 'address')
        | (functionName extends undefined ? never : 'functionName')
      >
    > &
      ChainIdParameter<config, chainId> &
      ConnectorParameter & {
        chainId?: address extends Record<number, Address>
          ?
              | keyof address
              | (chainId extends keyof address ? chainId : never)
              | undefined
          : chainId | number | undefined
      }
  }[number],
) => Promise<SimulateContractReturnType<abi, name, args, config, chainId>>

export function createSimulateContract<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
>(
  c: CreateSimulateContractParameters<abi, address, functionName>,
): CreateSimulateContractReturnType<abi, address, functionName> {
  if (c.address !== undefined && typeof c.address === 'object')
    return (config, parameters) => {
      const configChainId = getChainId(config)
      const account = getAccount(config)
      const chainId =
        (parameters as { chainId?: number })?.chainId ??
        account.chainId ??
        configChainId
      return simulateContract(config, {
        ...(parameters as any),
        ...(c.functionName ? { functionName: c.functionName } : {}),
        address: c.address?.[chainId],
        abi: c.abi,
      })
    }

  return (config, parameters) => {
    return simulateContract(config, {
      ...(parameters as any),
      ...(c.address ? { address: c.address } : {}),
      ...(c.functionName ? { functionName: c.functionName } : {}),
      abi: c.abi,
    })
  }
}
</file>

<file path="packages/core/src/actions/codegen/createWatchContractEvent.test-d.ts">
import { abi, config, mainnet, optimism } from '@wagmi/test'
import { http, webSocket } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../../createConfig.js'
import { createWatchContractEvent } from './createWatchContractEvent.js'

test('default', () => {
  const watchErc20Event = createWatchContractEvent({
    abi: abi.erc20,
  })

  watchErc20Event(config, {
    eventName: 'Transfer',
    chainId: 1,
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<{
        from?: `0x${string}` | undefined
        to?: `0x${string}` | undefined
        value?: bigint | undefined
      }>()
    },
  })
})

test('multichain address', () => {
  const watchErc20Event = createWatchContractEvent({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  watchErc20Event(config, {
    eventName: 'Transfer',
    chainId: mainnet.id,
    // ^?
    onLogs() {},
  })

  watchErc20Event(config, {
    eventName: 'Transfer',
    // @ts-expect-error chain id must match address keys
    chainId: 420,
    onLogs() {},
  })

  watchErc20Event(config, {
    eventName: 'Transfer',
    // @ts-expect-error chain id must match address keys
    address: '0x',
    onLogs() {},
  })
})

test('differing transports', () => {
  const watchErc20Event = createWatchContractEvent({
    abi: abi.erc20,
  })

  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  watchErc20Event(config, {
    poll: false,
    address: '0x',
    onLogs() {},
  })

  watchErc20Event(config, {
    chainId: mainnet.id,
    poll: true,
    address: '0x',
    onLogs() {},
  })
  watchErc20Event(config, {
    config,
    chainId: mainnet.id,
    // @ts-expect-error poll required since http transport
    poll: false,
    address: '0x',
    onLogs() {},
  })

  watchErc20Event(config, {
    chainId: optimism.id,
    poll: true,
    address: '0x',
    onLogs() {},
  })
  watchErc20Event(config, {
    chainId: optimism.id,
    poll: false,
    address: '0x',
    onLogs() {},
  })
})

test('eventName', () => {
  const watchErc20Event = createWatchContractEvent({
    abi: abi.erc20,
    eventName: 'Transfer',
  })

  watchErc20Event(config, {
    chainId: 1,
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<{
        from?: `0x${string}` | undefined
        to?: `0x${string}` | undefined
        value?: bigint | undefined
      }>()
    },
  })
})
</file>

<file path="packages/core/src/actions/codegen/createWatchContractEvent.ts">
import type { Abi, Address, ContractEventName } from 'viem'

import type { Config } from '../../createConfig.js'
import type { UnionCompute, UnionStrictOmit } from '../../types/utils.js'
import { getAccount } from '../getAccount.js'
import { getChainId } from '../getChainId.js'
import {
  type WatchContractEventParameters,
  type WatchContractEventReturnType,
  watchContractEvent,
} from '../watchContractEvent.js'

export type CreateWatchContractEventParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  eventName extends ContractEventName<abi> | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  eventName?: eventName | ContractEventName<abi> | undefined
}

export type CreateWatchContractEventReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  eventName extends ContractEventName<abi> | undefined,
  ///
  omittedProperties extends 'abi' | 'address' | 'chainId' | 'eventName' =
    | 'abi'
    | (address extends undefined ? never : 'address')
    | (address extends Record<number, Address> ? 'chainId' : never)
    | (eventName extends undefined ? never : 'eventName'),
> = <
  config extends Config,
  name extends eventName extends ContractEventName<abi>
    ? eventName
    : ContractEventName<abi>,
  strict extends boolean | undefined = undefined,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: UnionCompute<
    UnionStrictOmit<
      WatchContractEventParameters<abi, name, strict, config, chainId>,
      omittedProperties
    >
  > &
    (address extends Record<number, Address>
      ? { chainId?: keyof address | undefined }
      : unknown),
) => WatchContractEventReturnType

export function createWatchContractEvent<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  eventName extends ContractEventName<abi> | undefined = undefined,
>(
  c: CreateWatchContractEventParameters<abi, address, eventName>,
): CreateWatchContractEventReturnType<abi, address, eventName> {
  if (c.address !== undefined && typeof c.address === 'object')
    return (config, parameters) => {
      const configChainId = getChainId(config)
      const account = getAccount(config)
      const chainId =
        (parameters as { chainId?: number })?.chainId ??
        account.chainId ??
        configChainId
      return watchContractEvent(config, {
        ...(parameters as any),
        ...(c.eventName ? { eventName: c.eventName } : {}),
        address: c.address?.[chainId],
        abi: c.abi,
      })
    }

  return (config, parameters) => {
    return watchContractEvent(config, {
      ...(parameters as any),
      ...(c.address ? { address: c.address } : {}),
      ...(c.eventName ? { eventName: c.eventName } : {}),
      abi: c.abi,
    })
  }
}
</file>

<file path="packages/core/src/actions/codegen/createWriteContract.test-d.ts">
import { abi, config, mainnet, optimism } from '@wagmi/test'
import { test } from 'vitest'

import { simulateContract } from '../simulateContract.js'
import { createWriteContract } from './createWriteContract.js'

test('default', () => {
  const writeErc20 = createWriteContract({
    abi: abi.erc20,
    address: '0x',
  })

  writeErc20(config, {
    functionName: 'transfer',
    args: ['0x', 123n],
  })
})

test('multichain address', () => {
  const writeErc20 = createWriteContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  writeErc20(config, {
    functionName: 'transfer',
    args: ['0x', 123n],
    chainId: mainnet.id,
    // ^?
  })

  writeErc20(config, {
    functionName: 'transfer',
    args: ['0x', 123n],
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  writeErc20(config, {
    // @ts-expect-error address not allowed
    address: '0x',
    functionName: 'transfer',
    args: ['0x', 123n],
  })
})

test('overloads', () => {
  const writeOverloads = createWriteContract({
    abi: abi.writeOverloads,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  writeOverloads(config, {
    functionName: 'foo',
    args: [],
  })

  writeOverloads(config, {
    functionName: 'foo',
    args: ['0x'],
  })

  writeOverloads(config, {
    functionName: 'foo',
    args: ['0x', '0x'],
  })
})

test('useSimulateContract', async () => {
  const writeErc20 = createWriteContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const { request } = await simulateContract(config, {
    account: '0x',
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })

  writeErc20(config, request)
})

test('functionName', () => {
  const writeErc20 = createWriteContract({
    abi: abi.erc20,
    address: '0x',
    functionName: 'transfer',
  })

  writeErc20(config, {
    args: ['0x', 123n],
  })
})

test('functionName with overloads', () => {
  const writeOverloads = createWriteContract({
    abi: abi.writeOverloads,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
    functionName: 'foo',
  })

  writeOverloads(config, {
    args: [],
  })

  writeOverloads(config, {
    args: ['0x'],
  })

  writeOverloads(config, {
    args: ['0x', '0x'],
  })
})
</file>

<file path="packages/core/src/actions/codegen/createWriteContract.ts">
import type {
  Abi,
  Account,
  Address,
  Chain,
  ContractFunctionArgs,
  ContractFunctionName,
  WriteContractParameters as viem_WriteContractParameters,
} from 'viem'

import type { Config } from '../../createConfig.js'
import type { SelectChains } from '../../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../../types/properties.js'
import type {
  Compute,
  UnionCompute,
  UnionStrictOmit,
} from '../../types/utils.js'
import { getAccount } from '../getAccount.js'
import { getChainId } from '../getChainId.js'
import {
  type WriteContractReturnType,
  writeContract,
} from '../writeContract.js'

type stateMutability = 'nonpayable' | 'payable'

export type CreateWriteContractParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  functionName?:
    | functionName
    | ContractFunctionName<abi, stateMutability>
    | undefined
}

export type CreateWriteContractReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
> = <
  config extends Config,
  name extends functionName extends ContractFunctionName<abi, stateMutability>
    ? functionName
    : ContractFunctionName<abi, stateMutability>,
  args extends ContractFunctionArgs<abi, stateMutability, name>,
  chainId extends config['chains'][number]['id'],
  ///
  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  chains extends readonly Chain[] = SelectChains<config, chainId>,
  omittedProperties extends 'abi' | 'address' | 'functionName' =
    | 'abi'
    | (address extends undefined ? never : 'address')
    | (functionName extends undefined ? never : 'functionName'),
>(
  config: config,
  parameters: UnionCompute<
    {
      [key in keyof chains]: UnionStrictOmit<
        viem_WriteContractParameters<
          abi,
          name,
          args,
          chains[key],
          Account,
          chains[key],
          allFunctionNames
        >,
        omittedProperties | 'chain'
      >
    }[number] &
      (address extends Record<number, Address>
        ? {
            chainId?:
              | keyof address
              | (chainId extends keyof address ? chainId : never)
              | undefined
          }
        : Compute<ChainIdParameter<config, chainId>>) &
      ConnectorParameter & {
        /** @deprecated */
        __mode?: 'prepared'
      }
  >,
) => Promise<WriteContractReturnType>

export function createWriteContract<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
>(
  c: CreateWriteContractParameters<abi, address, functionName>,
): CreateWriteContractReturnType<abi, address, functionName> {
  if (c.address !== undefined && typeof c.address === 'object')
    return (config, parameters) => {
      const configChainId = getChainId(config)
      const account = getAccount(config)

      let chainId: number | undefined
      if (parameters.chainId) chainId = parameters.chainId
      else if (
        (parameters as unknown as { account: Address | Account | undefined })
          .account &&
        (parameters as unknown as { account: Address | Account | undefined })
          .account === account.address
      )
        chainId = account.chainId
      else if (
        (parameters as unknown as { account: Address | Account | undefined })
          .account === undefined
      )
        chainId = account.chainId
      else chainId = configChainId

      return writeContract(config, {
        ...(parameters as any),
        ...(c.functionName ? { functionName: c.functionName } : {}),
        address: chainId ? c.address?.[chainId] : undefined,
        abi: c.abi,
      })
    }

  return (config, parameters) => {
    return writeContract(config, {
      ...(parameters as any),
      ...(c.address ? { address: c.address } : {}),
      ...(c.functionName ? { functionName: c.functionName } : {}),
      abi: c.abi,
    })
  }
}
</file>

<file path="packages/core/src/actions/call.ts">
import type {
  CallErrorType as viem_CallErrorType,
  CallParameters as viem_CallParameters,
  CallReturnType as viem_CallReturnType,
} from 'viem'
import { call as viem_call } from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import { getAction } from '../utils/getAction.js'

export type CallParameters<config extends Config = Config> =
  viem_CallParameters & ChainIdParameter<config>

export type CallReturnType = viem_CallReturnType

export type CallErrorType = viem_CallErrorType

export async function call<config extends Config>(
  config: config,
  parameters: CallParameters<config>,
): Promise<CallReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_call, 'call')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/connect.test-d.ts">
import { accounts } from '@wagmi/test'
import { http } from 'viem'
import { mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import type { CreateConnectorFn } from '../connectors/createConnector.js'
import { mock } from '../connectors/mock.js'
import { type Connector, createConfig } from '../createConfig.js'
import { connect } from './connect.js'

const config = createConfig({
  chains: [mainnet],
  transports: { [mainnet.id]: http() },
})

test('parameters: connector (ConnectorFn)', () => {
  const connectorFn = mock({ accounts })

  connect(config, {
    connector: connectorFn,
    foo: 'bar',
  })
  expectTypeOf<
    typeof connectorFn extends CreateConnectorFn ? true : false
  >().toEqualTypeOf<true>()

  type Result = NonNullable<
    Parameters<typeof connect<typeof config, typeof connectorFn>>[1]
  >
  expectTypeOf<Result['foo']>().toEqualTypeOf<string | undefined>()
})

test('parameters: connector (Connector)', () => {
  const connector = config._internal.connectors.setup(mock({ accounts }))

  connect(config, {
    connector,
    foo: 'bar',
  })
  expectTypeOf<
    typeof connector extends Connector ? true : false
  >().toEqualTypeOf<true>()

  type Result = NonNullable<
    Parameters<typeof connect<typeof config, typeof connector>>[1]
  >
  expectTypeOf<Result['foo']>().toEqualTypeOf<string | undefined>()
})
</file>

<file path="packages/core/src/actions/connect.ts">
import type {
  Address,
  ResourceUnavailableRpcErrorType,
  UserRejectedRequestErrorType,
} from 'viem'

import type { CreateConnectorFn } from '../connectors/createConnector.js'
import type { Config, Connector } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import {
  ConnectorAlreadyConnectedError,
  type ConnectorAlreadyConnectedErrorType,
} from '../errors/config.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'

export type ConnectParameters<
  config extends Config = Config,
  connector extends Connector | CreateConnectorFn =
    | Connector
    | CreateConnectorFn,
  ///
  parameters extends unknown | undefined =
    | (connector extends CreateConnectorFn
        ? Omit<
            NonNullable<Parameters<ReturnType<connector>['connect']>[0]>,
            'isReconnecting'
          >
        : never)
    | (connector extends Connector
        ? Omit<
            NonNullable<Parameters<connector['connect']>[0]>,
            'isReconnecting'
          >
        : never),
> = Compute<
  ChainIdParameter<config> & {
    connector: connector | CreateConnectorFn
  }
> &
  parameters

export type ConnectReturnType<config extends Config = Config> = {
  accounts: readonly [Address, ...Address[]]
  chainId:
    | config['chains'][number]['id']
    | (number extends config['chains'][number]['id'] ? number : number & {})
}

export type ConnectErrorType =
  | ConnectorAlreadyConnectedErrorType
  // connector.connect()
  | UserRejectedRequestErrorType
  | ResourceUnavailableRpcErrorType
  // base
  | BaseErrorType
  | ErrorType

/** https://wagmi.sh/core/api/actions/connect */
export async function connect<
  config extends Config,
  connector extends Connector | CreateConnectorFn,
>(
  config: config,
  parameters: ConnectParameters<config, connector>,
): Promise<ConnectReturnType<config>> {
  // "Register" connector if not already created
  let connector: Connector
  if (typeof parameters.connector === 'function') {
    connector = config._internal.connectors.setup(parameters.connector)
  } else connector = parameters.connector

  // Check if connector is already connected
  if (connector.uid === config.state.current)
    throw new ConnectorAlreadyConnectedError()

  try {
    config.setState((x) => ({ ...x, status: 'connecting' }))
    connector.emitter.emit('message', { type: 'connecting' })

    const { connector: _, ...rest } = parameters
    const data = await connector.connect(rest)
    const accounts = data.accounts as readonly [Address, ...Address[]]

    connector.emitter.off('connect', config._internal.events.connect)
    connector.emitter.on('change', config._internal.events.change)
    connector.emitter.on('disconnect', config._internal.events.disconnect)

    await config.storage?.setItem('recentConnectorId', connector.id)
    config.setState((x) => ({
      ...x,
      connections: new Map(x.connections).set(connector.uid, {
        accounts,
        chainId: data.chainId,
        connector: connector,
      }),
      current: connector.uid,
      status: 'connected',
    }))

    return { accounts, chainId: data.chainId }
  } catch (error) {
    config.setState((x) => ({
      ...x,
      // Keep existing connector connected in case of error
      status: x.current ? 'connected' : 'disconnected',
    }))
    throw error
  }
}
</file>

<file path="packages/core/src/actions/deployContract.test-d.ts">
import { abi, bytecode, config } from '@wagmi/test'
import { http } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type DeployContractParameters,
  deployContract,
} from './deployContract.js'

test('default', async () => {
  await deployContract(config, {
    abi: abi.bayc,
    bytecode: bytecode.bayc,
    args: ['Bored Ape Wagmi Club', 'BAYC', 69420n, 0n],
    chainId: mainnet.id,
  })
})

test('chain formatters', () => {
  const config = createConfig({
    chains: [mainnet, celo],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = DeployContractParameters<typeof abi.bayc, typeof config>
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  deployContract(config, {
    abi: abi.bayc,
    bytecode: bytecode.bayc,
    args: ['Bored Ape Wagmi Club', 'BAYC', 69420n, 0n],
    feeCurrency: '0x',
  })

  type Result2 = DeployContractParameters<
    typeof abi.bayc,
    typeof config,
    typeof celo.id
  >
  expectTypeOf<Result2>().toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  deployContract(config, {
    chainId: celo.id,
    abi: abi.bayc,
    bytecode: bytecode.bayc,
    args: ['Bored Ape Wagmi Club', 'BAYC', 69420n, 0n],
    feeCurrency: '0x',
  })

  type Result3 = DeployContractParameters<
    typeof abi.bayc,
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  deployContract(config, {
    chainId: mainnet.id,
    abi: abi.bayc,
    bytecode: bytecode.bayc,
    args: ['Bored Ape Wagmi Club', 'BAYC', 69420n, 0n],
    // @ts-expect-error
    feeCurrency: '0x',
  })
})
</file>

<file path="packages/core/src/actions/deployContract.ts">
import type { Abi, Account, Chain, Client, ContractConstructorArgs } from 'viem'
import {
  type DeployContractErrorType as viem_DeployContractErrorType,
  type DeployContractParameters as viem_DeployContractParameters,
  type DeployContractReturnType as viem_DeployContractReturnType,
  deployContract as viem_deployContract,
} from 'viem/actions'
import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type DeployContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  allArgs = ContractConstructorArgs<abi>,
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: Compute<
    Omit<
      viem_DeployContractParameters<
        abi,
        chains[key],
        Account,
        chains[key],
        allArgs
      >,
      'chain'
    > &
      ChainIdParameter<config, chainId> &
      ConnectorParameter
  >
}[number]

export type DeployContractReturnType = viem_DeployContractReturnType

export type DeployContractErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_DeployContractErrorType

/** https://wagmi.sh/core/api/actions/deployContract */
export async function deployContract<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: DeployContractParameters<abi, config, chainId>,
): Promise<DeployContractReturnType> {
  const { account, chainId, connector, ...rest } = parameters

  let client: Client
  if (typeof account === 'object' && account?.type === 'local')
    client = config.getClient({ chainId })
  else
    client = await getConnectorClient(config, {
      account: account ?? undefined,
      chainId,
      connector,
    })

  const action = getAction(client, viem_deployContract, 'deployContract')
  const hash = await action({
    ...(rest as any),
    ...(account ? { account } : {}),
    chain: chainId ? { id: chainId } : null,
  })

  return hash
}
</file>

<file path="packages/core/src/actions/disconnect.ts">
import type { Config, Connection, Connector } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type {
  ConnectorNotConnectedErrorType,
  ConnectorNotFoundErrorType,
} from '../errors/config.js'
import type { ConnectorParameter } from '../types/properties.js'

export type DisconnectParameters = ConnectorParameter

export type DisconnectReturnType = void

export type DisconnectErrorType =
  | ConnectorNotFoundErrorType
  | ConnectorNotConnectedErrorType
  // base
  | BaseErrorType
  | ErrorType

/** https://wagmi.sh/core/api/actions/disconnect */
export async function disconnect(
  config: Config,
  parameters: DisconnectParameters = {},
): Promise<DisconnectReturnType> {
  let connector: Connector | undefined
  if (parameters.connector) connector = parameters.connector
  else {
    const { connections, current } = config.state
    const connection = connections.get(current!)
    connector = connection?.connector
  }

  const connections = config.state.connections

  if (connector) {
    await connector.disconnect()
    connector.emitter.off('change', config._internal.events.change)
    connector.emitter.off('disconnect', config._internal.events.disconnect)
    connector.emitter.on('connect', config._internal.events.connect)

    connections.delete(connector.uid)
  }

  config.setState((x) => {
    // if no connections exist, move to disconnected state
    if (connections.size === 0)
      return {
        ...x,
        connections: new Map(),
        current: null,
        status: 'disconnected',
      }

    // switch over to another connection
    const nextConnection = connections.values().next().value as Connection
    return {
      ...x,
      connections: new Map(connections),
      current: nextConnection.connector.uid,
    }
  })

  // Set recent connector if exists
  {
    const current = config.state.current
    if (!current) return
    const connector = config.state.connections.get(current)?.connector
    if (!connector) return
    await config.storage?.setItem('recentConnectorId', connector.id)
  }
}
</file>

<file path="packages/core/src/actions/estimateFeesPerGas.test-d.ts">
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'
import { estimateFeesPerGas } from './estimateFeesPerGas.js'

test('types', async () => {
  const default_ = await estimateFeesPerGas(config)
  expectTypeOf(default_).toMatchTypeOf<{
    gasPrice?: undefined
    maxFeePerGas: bigint
    maxPriorityFeePerGas: bigint
    formatted: {
      gasPrice?: undefined
      maxFeePerGas: string
      maxPriorityFeePerGas: string
    }
  }>()

  const legacy = await estimateFeesPerGas(config, { type: 'legacy' })
  expectTypeOf(legacy).toMatchTypeOf<{
    gasPrice: bigint
    maxFeePerGas?: undefined
    maxPriorityFeePerGas?: undefined
    formatted: {
      gasPrice: string
      maxFeePerGas?: undefined
      maxPriorityFeePerGas?: undefined
    }
  }>()

  const eip1559 = await estimateFeesPerGas(config, { type: 'eip1559' })
  expectTypeOf(eip1559).toMatchTypeOf<{
    gasPrice?: undefined
    maxFeePerGas: bigint
    maxPriorityFeePerGas: bigint
    formatted: {
      gasPrice?: undefined
      maxFeePerGas: string
      maxPriorityFeePerGas: string
    }
  }>()
})
</file>

<file path="packages/core/src/actions/estimateFeesPerGas.ts">
import {
  type Chain,
  type FeeValuesEIP1559,
  type FeeValuesLegacy,
  type FeeValuesType,
  formatUnits,
} from 'viem'
import {
  type EstimateFeesPerGasErrorType as viem_EstimateFeesPerGasErrorType,
  type EstimateFeesPerGasParameters as viem_EstimateFeesPerGasParameters,
  type EstimateFeesPerGasReturnType as viem_EstimateFeesPerGasReturnType,
  estimateFeesPerGas as viem_estimateFeesPerGas,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Unit } from '../types/unit.js'
import type { Compute } from '../types/utils.js'
import type { UnionCompute, UnionLooseOmit } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import { getUnit } from '../utils/getUnit.js'

export type EstimateFeesPerGasParameters<
  type extends FeeValuesType = FeeValuesType,
  config extends Config = Config,
> = UnionCompute<
  UnionLooseOmit<
    viem_EstimateFeesPerGasParameters<Chain, Chain, type>,
    'chain'
  > &
    ChainIdParameter<config> & {
      /** @deprecated */
      formatUnits?: Unit | undefined
    }
>

export type EstimateFeesPerGasReturnType<
  type extends FeeValuesType = FeeValuesType,
> = Compute<
  viem_EstimateFeesPerGasReturnType<type> & {
    /** @deprecated */
    formatted: UnionCompute<
      | (type extends 'legacy' ? FeeValuesLegacy<string> : never)
      | (type extends 'eip1559' ? FeeValuesEIP1559<string> : never)
    >
  }
>

export type EstimateFeesPerGasErrorType = viem_EstimateFeesPerGasErrorType

export async function estimateFeesPerGas<
  config extends Config,
  type extends FeeValuesType = 'eip1559',
>(
  config: config,
  parameters: EstimateFeesPerGasParameters<type, config> = {},
): Promise<EstimateFeesPerGasReturnType<type>> {
  const { chainId, formatUnits: units = 'gwei', ...rest } = parameters

  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_estimateFeesPerGas,
    'estimateFeesPerGas',
  )

  const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = await action({
    ...rest,
    chain: client.chain,
  })

  const unit = getUnit(units)
  const formatted = {
    gasPrice: gasPrice ? formatUnits(gasPrice, unit) : undefined,
    maxFeePerGas: maxFeePerGas ? formatUnits(maxFeePerGas, unit) : undefined,
    maxPriorityFeePerGas: maxPriorityFeePerGas
      ? formatUnits(maxPriorityFeePerGas, unit)
      : undefined,
  }

  return {
    formatted,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
  } as EstimateFeesPerGasReturnType<type>
}
</file>

<file path="packages/core/src/actions/estimateGas.test-d.ts">
import { http, parseEther } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { type EstimateGasParameters, estimateGas } from './estimateGas.js'

test('chain formatters', () => {
  const config = createConfig({
    chains: [mainnet, celo],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = EstimateGasParameters<typeof config>
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  estimateGas(config, {
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })

  type Result2 = EstimateGasParameters<typeof config, typeof celo.id>
  expectTypeOf<Result2>().toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  estimateGas(config, {
    chainId: celo.id,
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })

  type Result3 = EstimateGasParameters<typeof config, typeof mainnet.id>
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  estimateGas(config, {
    chainId: mainnet.id,
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    // @ts-expect-error
    feeCurrency: '0x',
  })
})
</file>

<file path="packages/core/src/actions/estimateGas.ts">
import type { Account, Address, Chain } from 'viem'
import {
  type EstimateGasErrorType as viem_EstimateGasErrorType,
  type EstimateGasParameters as viem_EstimateGasParameters,
  type EstimateGasReturnType as viem_EstimateGasReturnType,
  estimateGas as viem_estimateGas,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type { UnionCompute, UnionLooseOmit } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type EstimateGasParameters<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    UnionLooseOmit<viem_EstimateGasParameters<chains[key]>, 'chain'> &
      ChainIdParameter<config, chainId> &
      ConnectorParameter
  >
}[number]

export type EstimateGasReturnType = viem_EstimateGasReturnType

export type EstimateGasErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_EstimateGasErrorType

/** https://wagmi.sh/core/api/actions/estimateGas */
export async function estimateGas<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
>(
  config: config,
  parameters: EstimateGasParameters<config, chainId>,
): Promise<EstimateGasReturnType> {
  const { chainId, connector, ...rest } = parameters

  let account: Address | Account
  if (parameters.account) account = parameters.account
  else {
    const connectorClient = await getConnectorClient(config, {
      account: parameters.account,
      chainId,
      connector,
    })
    account = connectorClient.account
  }

  const client = config.getClient({ chainId })
  const action = getAction(client, viem_estimateGas, 'estimateGas')
  return action({ ...(rest as viem_EstimateGasParameters), account })
}
</file>

<file path="packages/core/src/actions/estimateMaxPriorityFeePerGas.ts">
import type { Chain } from 'viem'
import {
  type EstimateMaxPriorityFeePerGasErrorType as viem_EstimateMaxPriorityFeePerGasErrorType,
  type EstimateMaxPriorityFeePerGasParameters as viem_EstimateMaxPriorityFeePerGasParameters,
  type EstimateMaxPriorityFeePerGasReturnType as viem_EstimateMaxPriorityFeePerGasReturnType,
  estimateMaxPriorityFeePerGas as viem_estimateMaxPriorityFeePerGas,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, UnionLooseOmit } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type EstimateMaxPriorityFeePerGasParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  UnionLooseOmit<
    viem_EstimateMaxPriorityFeePerGasParameters<Chain, Chain> &
      ChainIdParameter<config, chainId>,
    'chain'
  >
>

export type EstimateMaxPriorityFeePerGasReturnType =
  viem_EstimateMaxPriorityFeePerGasReturnType

export type EstimateMaxPriorityFeePerGasErrorType =
  viem_EstimateMaxPriorityFeePerGasErrorType

/** https://wagmi.sh/core/api/actions/estimateMaxPriorityFeePerGas */
export async function estimateMaxPriorityFeePerGas<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: EstimateMaxPriorityFeePerGasParameters<config, chainId> = {},
): Promise<EstimateMaxPriorityFeePerGasReturnType> {
  const { chainId } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_estimateMaxPriorityFeePerGas,
    'estimateMaxPriorityFeePerGas',
  )
  return action({ chain: client.chain })
}
</file>

<file path="packages/core/src/actions/getAccount.test-d.ts">
import { config } from '@wagmi/test'
import type { Address } from 'viem'
import { expectTypeOf, test } from 'vitest'

import type { Connector } from '../createConfig.js'
import { getAccount } from './getAccount.js'

test('states', () => {
  const result = getAccount(config)

  switch (result.status) {
    case 'reconnecting': {
      expectTypeOf(result).toMatchTypeOf<{
        address: Address | undefined
        chain: (typeof config)['chains'][number] | undefined
        chainId: number | undefined
        connector: Connector | undefined
        isConnected: boolean
        isConnecting: false
        isDisconnected: false
        isReconnecting: true
        status: 'reconnecting'
      }>()
      break
    }
    case 'connecting': {
      expectTypeOf(result).toMatchTypeOf<{
        address: Address | undefined
        chain: (typeof config)['chains'][number] | undefined
        chainId: number | undefined
        connector: Connector | undefined
        isConnected: false
        isReconnecting: false
        isConnecting: true
        isDisconnected: false
        status: 'connecting'
      }>()
      break
    }
    case 'connected': {
      expectTypeOf(result).toMatchTypeOf<{
        address: Address
        chain: (typeof config)['chains'][number] | undefined
        chainId: number
        connector: Connector
        isConnected: true
        isConnecting: false
        isDisconnected: false
        isReconnecting: false
        status: 'connected'
      }>()
      break
    }
    case 'disconnected': {
      expectTypeOf(result).toMatchTypeOf<{
        address: undefined
        chain: undefined
        chainId: undefined
        connector: undefined
        isConnected: false
        isReconnecting: false
        isConnecting: false
        isDisconnected: true
        status: 'disconnected'
      }>()
      break
    }
  }
})
</file>

<file path="packages/core/src/actions/getAccount.ts">
import type { Address, Chain } from 'viem'

import type { Config, Connector } from '../createConfig.js'

export type GetAccountReturnType<
  config extends Config = Config,
  ///
  chain = Config extends config ? Chain : config['chains'][number],
> =
  | {
      address: Address
      addresses: readonly [Address, ...Address[]]
      chain: chain | undefined
      chainId: number
      connector: Connector
      isConnected: true
      isConnecting: false
      isDisconnected: false
      isReconnecting: false
      status: 'connected'
    }
  | {
      address: Address | undefined
      addresses: readonly Address[] | undefined
      chain: chain | undefined
      chainId: number | undefined
      connector: Connector | undefined
      isConnected: boolean
      isConnecting: false
      isDisconnected: false
      isReconnecting: true
      status: 'reconnecting'
    }
  | {
      address: Address | undefined
      addresses: readonly Address[] | undefined
      chain: chain | undefined
      chainId: number | undefined
      connector: Connector | undefined
      isConnected: false
      isReconnecting: false
      isConnecting: true
      isDisconnected: false
      status: 'connecting'
    }
  | {
      address: undefined
      addresses: undefined
      chain: undefined
      chainId: undefined
      connector: undefined
      isConnected: false
      isReconnecting: false
      isConnecting: false
      isDisconnected: true
      status: 'disconnected'
    }

/** https://wagmi.sh/core/api/actions/getAccount */
export function getAccount<config extends Config>(
  config: config,
): GetAccountReturnType<config> {
  const uid = config.state.current!
  const connection = config.state.connections.get(uid)
  const addresses = connection?.accounts
  const address = addresses?.[0]
  const chain = config.chains.find(
    (chain) => chain.id === connection?.chainId,
  ) as GetAccountReturnType<config>['chain']
  const status = config.state.status

  switch (status) {
    case 'connected':
      return {
        address: address!,
        addresses: addresses!,
        chain,
        chainId: connection?.chainId!,
        connector: connection?.connector!,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status,
      }
    case 'reconnecting':
      return {
        address,
        addresses,
        chain,
        chainId: connection?.chainId,
        connector: connection?.connector,
        isConnected: !!address,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status,
      }
    case 'connecting':
      return {
        address,
        addresses,
        chain,
        chainId: connection?.chainId,
        connector: connection?.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status,
      }
    case 'disconnected':
      return {
        address: undefined,
        addresses: undefined,
        chain: undefined,
        chainId: undefined,
        connector: undefined,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status,
      }
  }
}
</file>

<file path="packages/core/src/actions/getBalance.ts">
import { type Address, type Hex, formatUnits, hexToString, trim } from 'viem'
import {
  type GetBalanceErrorType as viem_GetBalanceErrorType,
  type GetBalanceParameters as viem_GetBalanceParameters,
  getBalance as viem_getBalance,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Unit } from '../types/unit.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import { getUnit } from '../utils/getUnit.js'
import { type ReadContractsErrorType, readContracts } from './readContracts.js'

export type GetBalanceParameters<config extends Config = Config> = Compute<
  ChainIdParameter<config> &
    viem_GetBalanceParameters & {
      /** @deprecated */
      token?: Address | undefined
      /** @deprecated */
      unit?: Unit | undefined
    }
>

export type GetBalanceReturnType = {
  decimals: number
  /** @deprecated */
  formatted: string
  symbol: string
  value: bigint
}

export type GetBalanceErrorType = viem_GetBalanceErrorType

/** https://wagmi.sh/core/api/actions/getBalance */
export async function getBalance<config extends Config>(
  config: config,
  parameters: GetBalanceParameters<config>,
): Promise<GetBalanceReturnType> {
  const {
    address,
    blockNumber,
    blockTag,
    chainId,
    token: tokenAddress,
    unit = 'ether',
  } = parameters

  if (tokenAddress) {
    try {
      return await getTokenBalance(config, {
        balanceAddress: address,
        chainId,
        symbolType: 'string',
        tokenAddress,
      })
    } catch (error) {
      // In the chance that there is an error upon decoding the contract result,
      // it could be likely that the contract data is represented as bytes32 instead
      // of a string.
      if (
        (error as ReadContractsErrorType).name ===
        'ContractFunctionExecutionError'
      ) {
        const balance = await getTokenBalance(config, {
          balanceAddress: address,
          chainId,
          symbolType: 'bytes32',
          tokenAddress,
        })
        const symbol = hexToString(
          trim(balance.symbol as Hex, { dir: 'right' }),
        )
        return { ...balance, symbol }
      }
      throw error
    }
  }

  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getBalance, 'getBalance')
  const value = await action(
    blockNumber ? { address, blockNumber } : { address, blockTag },
  )
  const chain = config.chains.find((x) => x.id === chainId) ?? client.chain!
  return {
    decimals: chain.nativeCurrency.decimals,
    formatted: formatUnits(value, getUnit(unit)),
    symbol: chain.nativeCurrency.symbol,
    value,
  }
}

type GetTokenBalanceParameters = {
  balanceAddress: Address
  chainId?: number | undefined
  symbolType: 'bytes32' | 'string'
  tokenAddress: Address
  unit?: Unit | undefined
}

async function getTokenBalance(
  config: Config,
  parameters: GetTokenBalanceParameters,
) {
  const { balanceAddress, chainId, symbolType, tokenAddress, unit } = parameters
  const contract = {
    abi: [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type: 'uint8' }],
      },
      {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type: symbolType }],
      },
    ],
    address: tokenAddress,
  } as const
  const [value, decimals, symbol] = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        ...contract,
        functionName: 'balanceOf',
        args: [balanceAddress],
        chainId,
      },
      { ...contract, functionName: 'decimals', chainId },
      { ...contract, functionName: 'symbol', chainId },
    ] as const,
  })
  const formatted = formatUnits(value ?? '0', getUnit(unit ?? decimals))
  return { decimals, formatted, symbol, value }
}
</file>

<file path="packages/core/src/actions/getBlock.test-d.ts">
import { http } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { getBlock } from './getBlock.js'

test('chain formatters', async () => {
  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })
  const result = await getBlock(config)
  if (result.chainId === celo.id) {
    expectTypeOf(result.difficulty).toEqualTypeOf<bigint | undefined>()
    expectTypeOf(result.gasLimit).toEqualTypeOf<bigint | undefined>()
    expectTypeOf(result.mixHash).toEqualTypeOf<undefined>()
    expectTypeOf(result.nonce).toEqualTypeOf<`0x${string}`>()
    expectTypeOf(result.uncles).toEqualTypeOf<undefined>()
    expectTypeOf(result.randomness).toEqualTypeOf<
      | {
          committed: `0x${string}`
          revealed: `0x${string}`
        }
      | undefined
    >()
  }
})

test('chainId', async () => {
  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })
  const result = await getBlock(config, {
    chainId: celo.id,
  })
  expectTypeOf(result.difficulty).toEqualTypeOf<bigint | undefined>()
  expectTypeOf(result.gasLimit).toEqualTypeOf<bigint | undefined>()
  expectTypeOf(result.mixHash).toEqualTypeOf<undefined>()
  expectTypeOf(result.nonce).toEqualTypeOf<`0x${string}`>()
  expectTypeOf(result.uncles).toEqualTypeOf<undefined>()
  expectTypeOf(result.randomness).toEqualTypeOf<
    | {
        committed: `0x${string}`
        revealed: `0x${string}`
      }
    | undefined
  >()
})
</file>

<file path="packages/core/src/actions/getBlock.ts">
import type { BlockTag, Chain } from 'viem'
import {
  type GetBlockErrorType as viem_GetBlockErrorType,
  type GetBlockParameters as viem_GetBlockParameters,
  type GetBlockReturnType as viem_GetBlockReturnType,
  getBlock as viem_getBlock,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, IsNarrowable } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetBlockParameters<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  viem_GetBlockParameters<includeTransactions, blockTag> &
    ChainIdParameter<config, chainId>
>

export type GetBlockReturnType<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = Compute<
  {
    [key in keyof chains]: viem_GetBlockReturnType<
      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined,
      includeTransactions,
      blockTag
    > & { chainId: chains[key]['id'] }
  }[number]
>

export type GetBlockErrorType = viem_GetBlockErrorType

/** https://wagmi.sh/core/actions/getBlock */
export async function getBlock<
  config extends Config,
  chainId extends config['chains'][number]['id'],
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
>(
  config: config,
  parameters: GetBlockParameters<
    includeTransactions,
    blockTag,
    config,
    chainId
  > = {},
): Promise<GetBlockReturnType<includeTransactions, blockTag, config, chainId>> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getBlock, 'getBlock')
  const block = await action(rest)
  return {
    ...(block as unknown as GetBlockReturnType<
      includeTransactions,
      blockTag,
      config,
      chainId
    >),
    chainId: client.chain.id,
  }
}
</file>

<file path="packages/core/src/actions/getBlockNumber.ts">
import {
  type GetBlockNumberErrorType as viem_GetBlockNumberErrorType,
  type GetBlockNumberParameters as viem_GetBlockNumberParameters,
  type GetBlockNumberReturnType as viem_GetBlockNumberReturnType,
  getBlockNumber as viem_getBlockNumber,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetBlockNumberParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<viem_GetBlockNumberParameters & ChainIdParameter<config, chainId>>

export type GetBlockNumberReturnType = viem_GetBlockNumberReturnType

export type GetBlockNumberErrorType = viem_GetBlockNumberErrorType

/** https://wagmi.sh/core/api/actions/getBlockNumber */
export function getBlockNumber<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: GetBlockNumberParameters<config, chainId> = {},
): Promise<GetBlockNumberReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getBlockNumber, 'getBlockNumber')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getBlockTransactionCount.ts">
import {
  type GetBlockTransactionCountErrorType as viem_GetBlockTransactionCountErrorType,
  type GetBlockTransactionCountParameters as viem_GetBlockTransactionCountParameters,
  type GetBlockTransactionCountReturnType as viem_GetBlockTransactionCountReturnType,
  getBlockTransactionCount as viem_getBlockTransactionCount,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetBlockTransactionCountParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = UnionCompute<
  viem_GetBlockTransactionCountParameters & ChainIdParameter<config, chainId>
>

export type GetBlockTransactionCountReturnType =
  viem_GetBlockTransactionCountReturnType

export type GetBlockTransactionCountErrorType =
  viem_GetBlockTransactionCountErrorType

/** https://wagmi.sh/core/api/actions/getBlockTransactionCount */
export function getBlockTransactionCount<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: GetBlockTransactionCountParameters<config, chainId> = {},
): Promise<GetBlockTransactionCountReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_getBlockTransactionCount,
    'getBlockTransactionCount',
  )
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getBytecode.ts">
import {
  type GetBytecodeErrorType as viem_GetBytecodeErrorType,
  type GetBytecodeParameters as viem_GetBytecodeParameters,
  type GetBytecodeReturnType as viem_GetBytecodeReturnType,
  getBytecode as viem_getBytecode,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetBytecodeParameters<config extends Config = Config> = Compute<
  viem_GetBytecodeParameters & ChainIdParameter<config>
>

export type GetBytecodeReturnType = viem_GetBytecodeReturnType

export type GetBytecodeErrorType = viem_GetBytecodeErrorType

/** https://wagmi.sh/core/api/actions/getBytecode */
export async function getBytecode<config extends Config>(
  config: config,
  parameters: GetBytecodeParameters<config>,
): Promise<GetBytecodeReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getBytecode, 'getBytecode')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getCallsStatus.ts">
import {
  type GetCallsStatusErrorType as viem_GetCallsStatusErrorType,
  type GetCallsStatusParameters as viem_GetCallsStatusParameters,
  type GetCallsStatusReturnType as viem_GetCallsStatusReturnType,
  getCallsStatus as viem_getCallsStatus,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ConnectorParameter } from '../types/properties.js'
import { getConnectorClient } from './getConnectorClient.js'

export type GetCallsStatusParameters = viem_GetCallsStatusParameters &
  ConnectorParameter

export type GetCallsStatusReturnType = viem_GetCallsStatusReturnType

export type GetCallsStatusErrorType = viem_GetCallsStatusErrorType

/** https://wagmi.sh/core/api/actions/getCallsStatus */
export async function getCallsStatus<config extends Config>(
  config: config,
  parameters: GetCallsStatusParameters,
): Promise<GetCallsStatusReturnType> {
  const { connector, id } = parameters
  const client = await getConnectorClient(config, { connector })
  return viem_getCallsStatus(client, { id })
}
</file>

<file path="packages/core/src/actions/getCapabilities.ts">
import type { Account } from 'viem'
import {
  type GetCapabilitiesErrorType as viem_GetCapabilitiesErrorType,
  type GetCapabilitiesParameters as viem_GetCapabilitiesParameters,
  type GetCapabilitiesReturnType as viem_GetCapabilitiesReturnType,
  getCapabilities as viem_getCapabilities,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ConnectorParameter } from '../types/properties.js'
import { getConnectorClient } from './getConnectorClient.js'

export type GetCapabilitiesParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = viem_GetCapabilitiesParameters<chainId> & ConnectorParameter

export type GetCapabilitiesReturnType<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = viem_GetCapabilitiesReturnType<chainId>

export type GetCapabilitiesErrorType = viem_GetCapabilitiesErrorType

/** https://wagmi.sh/core/api/actions/getCapabilities */
export async function getCapabilities<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
>(
  config: config,
  parameters: GetCapabilitiesParameters<config, chainId> = {},
): Promise<GetCapabilitiesReturnType<config, chainId>> {
  const { account, chainId, connector } = parameters
  const client = await getConnectorClient(config, { account, connector })
  return viem_getCapabilities(client as any, {
    account: account as Account,
    chainId,
  })
}
</file>

<file path="packages/core/src/actions/getChainId.ts">
import type { Config } from '../createConfig.js'

export type GetChainIdReturnType<config extends Config = Config> =
  config['chains'][number]['id']

/** https://wagmi.sh/core/api/actions/getChainId */
export function getChainId<config extends Config>(
  config: config,
): GetChainIdReturnType<config> {
  return config.state.chainId
}
</file>

<file path="packages/core/src/actions/getChains.test-d.ts">
import { type chain, config } from '@wagmi/test'
import type { Chain } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { getChains } from './getChains.js'

test('default', async () => {
  const chains = getChains(config)
  expectTypeOf(chains[0]).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(chains[2]).toEqualTypeOf<typeof chain.optimism>()
  expectTypeOf(chains[3]).toEqualTypeOf<Chain | undefined>()
})
</file>

<file path="packages/core/src/actions/getChains.ts">
import type { Chain } from 'viem'
import type { Config } from '../createConfig.js'
import { deepEqual } from '../utils/deepEqual.js'

export type GetChainsReturnType<config extends Config = Config> = readonly [
  ...config['chains'],
  ...Chain[],
]

let previousChains: readonly Chain[] = []

/** https://wagmi.sh/core/api/actions/getChains */
export function getChains<config extends Config>(
  config: config,
): GetChainsReturnType<config> {
  const chains = config.chains
  if (deepEqual(previousChains, chains))
    return previousChains as GetChainsReturnType<config>
  previousChains = chains
  return chains as unknown as GetChainsReturnType<config>
}
</file>

<file path="packages/core/src/actions/getClient.test-d.ts">
import { chain, config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { getClient } from './getClient.js'

test('default', () => {
  const client = getClient(config)
  expectTypeOf(client.chain).toEqualTypeOf<(typeof config)['chains'][number]>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('parameters: chainId', () => {
  const client = getClient(config, {
    chainId: chain.mainnet.id,
  })
  expectTypeOf(client.chain).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(client.chain).not.toEqualTypeOf<typeof chain.mainnet2>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('behavior: unconfigured chain', () => {
  const client = getClient(config, {
    // @ts-expect-error
    chainId: 123456,
  })
  expectTypeOf(client).toEqualTypeOf<undefined>()
})
</file>

<file path="packages/core/src/actions/getClient.ts">
import type { Client } from 'viem'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, IsNarrowable } from '../types/utils.js'

export type GetClientParameters<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | number
    | undefined = config['chains'][number]['id'],
> = ChainIdParameter<config, chainId>

export type GetClientReturnType<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  ///
  resolvedChainId extends
    | config['chains'][number]['id']
    | undefined = IsNarrowable<
    config['chains'][number]['id'],
    number
  > extends true
    ? IsNarrowable<chainId, number> extends true
      ? chainId
      : config['chains'][number]['id']
    : config['chains'][number]['id'] | undefined,
> = resolvedChainId extends config['chains'][number]['id']
  ? Compute<
      Client<
        config['_internal']['transports'][resolvedChainId],
        Extract<config['chains'][number], { id: resolvedChainId }>
      >
    >
  : undefined

export function getClient<
  config extends Config,
  chainId extends config['chains'][number]['id'] | number | undefined,
>(
  config: config,
  parameters: GetClientParameters<config, chainId> = {},
): GetClientReturnType<config, chainId> {
  let client = undefined
  try {
    client = config.getClient(parameters)
  } catch {}
  return client as GetClientReturnType<config, chainId>
}
</file>

<file path="packages/core/src/actions/getConnections.ts">
import type { Config, Connection } from '../createConfig.js'
import type { Compute } from '../types/utils.js'
import { deepEqual } from '../utils/deepEqual.js'

export type GetConnectionsReturnType = Compute<Connection>[]

let previousConnections: Connection[] = []

/** https://wagmi.sh/core/api/actions/getConnections */
export function getConnections(config: Config): GetConnectionsReturnType {
  const connections = [...config.state.connections.values()]
  if (config.state.status === 'reconnecting') return previousConnections
  if (deepEqual(previousConnections, connections)) return previousConnections
  previousConnections = connections
  return connections
}
</file>

<file path="packages/core/src/actions/getConnectorClient.test-d.ts">
import { chain, config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { getConnectorClient } from './getConnectorClient.js'

test('default', async () => {
  const client = await getConnectorClient(config)
  expectTypeOf(client.chain).toEqualTypeOf<(typeof config)['chains'][number]>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('parameters: chainId', async () => {
  const client = await getConnectorClient(config, {
    chainId: chain.mainnet.id,
  })
  expectTypeOf(client.chain).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(client.chain).not.toEqualTypeOf<typeof chain.mainnet2>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})
</file>

<file path="packages/core/src/actions/getConnectorClient.ts">
import {
  type Account,
  type Address,
  type BaseErrorType,
  type Client,
  createClient,
  custom,
} from 'viem'
import { getAddress, parseAccount } from 'viem/utils'

import type { Config, Connection } from '../createConfig.js'
import type { ErrorType } from '../errors/base.js'
import {
  ConnectorAccountNotFoundError,
  type ConnectorAccountNotFoundErrorType,
  ConnectorChainMismatchError,
  type ConnectorChainMismatchErrorType,
  ConnectorNotConnectedError,
  type ConnectorNotConnectedErrorType,
  ConnectorUnavailableReconnectingError,
  type ConnectorUnavailableReconnectingErrorType,
} from '../errors/config.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type { Compute } from '../types/utils.js'

export type GetConnectorClientParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  ChainIdParameter<config, chainId> &
    ConnectorParameter & {
      /**
       * Account to use for the client.
       *
       * - `Account | Address`: An Account MUST exist on the connector.
       * - `null`: Account MAY NOT exist on the connector. This is useful for
       *   actions that can infer the account from the connector (e.g. sending a
       *   call without a connected account  the user will be prompted to select
       *   an account within the wallet).
       */
      account?: Address | Account | null | undefined
    }
>

export type GetConnectorClientReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  Client<
    config['_internal']['transports'][chainId],
    Extract<config['chains'][number], { id: chainId }>,
    Account
  >
>

export type GetConnectorClientErrorType =
  | ConnectorAccountNotFoundErrorType
  | ConnectorChainMismatchErrorType
  | ConnectorNotConnectedErrorType
  | ConnectorUnavailableReconnectingErrorType
  // base
  | BaseErrorType
  | ErrorType

/** https://wagmi.sh/core/api/actions/getConnectorClient */
export async function getConnectorClient<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: GetConnectorClientParameters<config, chainId> = {},
): Promise<GetConnectorClientReturnType<config, chainId>> {
  // Get connection
  let connection: Connection | undefined
  if (parameters.connector) {
    const { connector } = parameters
    if (
      config.state.status === 'reconnecting' &&
      !connector.getAccounts &&
      !connector.getChainId
    )
      throw new ConnectorUnavailableReconnectingError({ connector })

    const [accounts, chainId] = await Promise.all([
      connector.getAccounts().catch((e) => {
        if (parameters.account === null) return []
        throw e
      }),
      connector.getChainId(),
    ])
    connection = {
      accounts: accounts as readonly [Address, ...Address[]],
      chainId,
      connector,
    }
  } else connection = config.state.connections.get(config.state.current!)
  if (!connection) throw new ConnectorNotConnectedError()

  const chainId = parameters.chainId ?? connection.chainId

  // Check connector using same chainId as connection
  const connectorChainId = await connection.connector.getChainId()
  if (connectorChainId !== connection.chainId)
    throw new ConnectorChainMismatchError({
      connectionChainId: connection.chainId,
      connectorChainId,
    })

  // If connector has custom `getClient` implementation
  type Return = GetConnectorClientReturnType<config, chainId>
  const connector = connection.connector
  if (connector.getClient)
    return connector.getClient({ chainId }) as unknown as Return

  // Default using `custom` transport
  const account = parseAccount(parameters.account ?? connection.accounts[0]!)
  if (account) account.address = getAddress(account.address) // TODO: Checksum address as part of `parseAccount`?

  // If account was provided, check that it exists on the connector
  if (
    parameters.account &&
    !connection.accounts.some(
      (x) => x.toLowerCase() === account.address.toLowerCase(),
    )
  )
    throw new ConnectorAccountNotFoundError({
      address: account.address,
      connector,
    })

  const chain = config.chains.find((chain) => chain.id === chainId)
  const provider = (await connection.connector.getProvider({ chainId })) as {
    request(...args: any): Promise<any>
  }

  return createClient({
    account,
    chain,
    name: 'Connector Client',
    transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),
  }) as Return
}
</file>

<file path="packages/core/src/actions/getConnectors.ts">
import type { Config, Connector } from '../createConfig.js'
import { deepEqual } from '../utils/deepEqual.js'

export type GetConnectorsReturnType<config extends Config = Config> =
  config['connectors']

let previousConnectors: readonly Connector[] = []

/** https://wagmi.sh/core/api/actions/getConnectors */
export function getConnectors<config extends Config>(
  config: config,
): GetConnectorsReturnType<config> {
  const connectors = config.connectors
  if (deepEqual(previousConnectors, connectors)) return previousConnectors
  previousConnectors = connectors
  return connectors
}
</file>

<file path="packages/core/src/actions/getEnsAddress.ts">
import {
  type GetEnsAddressErrorType as viem_GetEnsAddressErrorType,
  type GetEnsAddressParameters as viem_GetEnsAddressParameters,
  type GetEnsAddressReturnType as viem_GetEnsAddressReturnType,
  getEnsAddress as viem_getEnsAddress,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetEnsAddressParameters<config extends Config = Config> = Compute<
  viem_GetEnsAddressParameters & ChainIdParameter<config>
>

export type GetEnsAddressReturnType = viem_GetEnsAddressReturnType

export type GetEnsAddressErrorType = viem_GetEnsAddressErrorType

/** https://wagmi.sh/core/api/actions/getEnsAddress */
export function getEnsAddress<config extends Config>(
  config: config,
  parameters: GetEnsAddressParameters<config>,
): Promise<GetEnsAddressReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getEnsAddress, 'getEnsAddress')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getEnsAvatar.ts">
import {
  type GetEnsAvatarErrorType as viem_GetEnsAvatarErrorType,
  type GetEnsAvatarParameters as viem_GetEnsAvatarParameters,
  type GetEnsAvatarReturnType as viem_GetEnsAvatarReturnType,
  getEnsAvatar as viem_getEnsAvatar,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetEnsAvatarParameters<config extends Config = Config> = Compute<
  viem_GetEnsAvatarParameters & ChainIdParameter<config>
>

export type GetEnsAvatarReturnType = viem_GetEnsAvatarReturnType

export type GetEnsAvatarErrorType = viem_GetEnsAvatarErrorType

/** https://wagmi.sh/core/api/actions/getEnsAvatar */
export function getEnsAvatar<config extends Config>(
  config: config,
  parameters: GetEnsAvatarParameters<config>,
): Promise<GetEnsAvatarReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getEnsAvatar, 'getEnsAvatar')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getEnsName.ts">
import {
  type GetEnsNameErrorType as viem_GetEnsNameErrorType,
  type GetEnsNameParameters as viem_GetEnsNameParameters,
  type GetEnsNameReturnType as viem_GetEnsNameReturnType,
  getEnsName as viem_getEnsName,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetEnsNameParameters<config extends Config = Config> = Compute<
  viem_GetEnsNameParameters & ChainIdParameter<config>
>

export type GetEnsNameReturnType = viem_GetEnsNameReturnType

export type GetEnsNameErrorType = viem_GetEnsNameErrorType

/** https://wagmi.sh/core/api/actions/getEnsName */
export function getEnsName<config extends Config>(
  config: config,
  parameters: GetEnsNameParameters<config>,
): Promise<GetEnsNameReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getEnsName, 'getEnsName')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getEnsResolver.ts">
import {
  type GetEnsResolverErrorType as viem_GetEnsResolverErrorType,
  type GetEnsResolverParameters as viem_GetEnsResolverParameters,
  type GetEnsResolverReturnType as viem_GetEnsResolverReturnType,
  getEnsResolver as viem_getEnsResolver,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetEnsResolverParameters<config extends Config = Config> = Compute<
  viem_GetEnsResolverParameters & ChainIdParameter<config>
>

export type GetEnsResolverReturnType = viem_GetEnsResolverReturnType

export type GetEnsResolverErrorType = viem_GetEnsResolverErrorType

/** https://wagmi.sh/core/api/actions/getEnsResolver */
export function getEnsResolver<config extends Config>(
  config: config,
  parameters: GetEnsResolverParameters<config>,
): Promise<GetEnsResolverReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getEnsResolver, 'getEnsResolver')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getEnsText.ts">
import {
  type GetEnsTextErrorType as viem_GetEnsTextErrorType,
  type GetEnsTextParameters as viem_GetEnsTextParameters,
  type GetEnsTextReturnType as viem_GetEnsTextReturnType,
  getEnsText as viem_getEnsText,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetEnsTextParameters<config extends Config = Config> = Compute<
  viem_GetEnsTextParameters & ChainIdParameter<config>
>

export type GetEnsTextReturnType = viem_GetEnsTextReturnType

export type GetEnsTextErrorType = viem_GetEnsTextErrorType

/** https://wagmi.sh/core/api/actions/getEnsText */
export function getEnsText<config extends Config>(
  config: config,
  parameters: GetEnsTextParameters<config>,
): Promise<GetEnsTextReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getEnsText, 'getEnsText')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getFeeHistory.ts">
import {
  type GetFeeHistoryErrorType as viem_GetFeeHistoryErrorType,
  type GetFeeHistoryParameters as viem_GetFeeHistoryParameters,
  type GetFeeHistoryReturnType as viem_GetFeeHistoryReturnType,
  getFeeHistory as viem_getFeeHistory,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetFeeHistoryParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<viem_GetFeeHistoryParameters & ChainIdParameter<config, chainId>>

export type GetFeeHistoryReturnType = viem_GetFeeHistoryReturnType

export type GetFeeHistoryErrorType = viem_GetFeeHistoryErrorType

/** https://wagmi.sh/core/api/actions/getFeeHistory */
export function getFeeHistory<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: GetFeeHistoryParameters<config, chainId>,
): Promise<GetFeeHistoryReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getFeeHistory, 'getFeeHistory')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getGasPrice.ts">
import {
  type GetGasPriceErrorType as viem_GetGasPriceErrorType,
  type GetGasPriceReturnType as viem_GetGasPriceReturnType,
  getGasPrice as viem_getGasPrice,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetGasPriceParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<ChainIdParameter<config, chainId>>

export type GetGasPriceReturnType = viem_GetGasPriceReturnType

export type GetGasPriceErrorType = viem_GetGasPriceErrorType

/** https://wagmi.sh/core/api/actions/getGasPrice */
export function getGasPrice<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: GetGasPriceParameters<config, chainId> = {},
): Promise<GetGasPriceReturnType> {
  const { chainId } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getGasPrice, 'getGasPrice')
  return action({})
}
</file>

<file path="packages/core/src/actions/getProof.ts">
import {
  type GetProofErrorType as viem_GetProofErrorType,
  type GetProofParameters as viem_GetProofParameters,
  type GetProofReturnType as viem_GetProofReturnType,
  getProof as viem_getProof,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetProofParameters<config extends Config = Config> = Compute<
  viem_GetProofParameters & ChainIdParameter<config>
>

export type GetProofReturnType = viem_GetProofReturnType

export type GetProofErrorType = viem_GetProofErrorType

/** https://wagmi.sh/core/api/actions/getProof */
export async function getProof<config extends Config>(
  config: config,
  parameters: GetProofParameters<config>,
): Promise<GetProofReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getProof, 'getProof')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getPublicClient.test-d.ts">
import { chain, config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { getPublicClient } from './getPublicClient.js'

test('default', () => {
  const client = getPublicClient(config)
  expectTypeOf(client.chain).toEqualTypeOf<(typeof config)['chains'][number]>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('parameters: chainId', () => {
  const client = getPublicClient(config, {
    chainId: chain.mainnet.id,
  })
  expectTypeOf(client.chain).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(client.chain).not.toEqualTypeOf<typeof chain.mainnet2>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('behavior: unconfigured chain', () => {
  const client = getPublicClient(config, {
    // @ts-expect-error
    chainId: 123456,
  })
  expectTypeOf(client).toEqualTypeOf<undefined>()
})
</file>

<file path="packages/core/src/actions/getPublicClient.ts">
import { type Client, type PublicClient, publicActions } from 'viem'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, IsNarrowable } from '../types/utils.js'
import { getClient } from './getClient.js'

export type GetPublicClientParameters<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
> = ChainIdParameter<config, chainId>

export type GetPublicClientReturnType<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  ///
  resolvedChainId extends
    | config['chains'][number]['id']
    | undefined = IsNarrowable<
    config['chains'][number]['id'],
    number
  > extends true
    ? IsNarrowable<chainId, number> extends true
      ? chainId
      : config['chains'][number]['id']
    : config['chains'][number]['id'] | undefined,
> = resolvedChainId extends config['chains'][number]['id']
  ? Compute<
      PublicClient<
        config['_internal']['transports'][resolvedChainId],
        Extract<config['chains'][number], { id: resolvedChainId }>
      >
    >
  : undefined

export function getPublicClient<
  config extends Config,
  chainId extends config['chains'][number]['id'] | number | undefined,
>(
  config: config,
  parameters: GetPublicClientParameters<config, chainId> = {},
): GetPublicClientReturnType<config, chainId> {
  const client = getClient(config, parameters)
  return (client as Client)?.extend(publicActions) as GetPublicClientReturnType<
    config,
    chainId
  >
}
</file>

<file path="packages/core/src/actions/getStorageAt.ts">
import {
  type GetStorageAtErrorType as viem_GetStorageAtErrorType,
  type GetStorageAtParameters as viem_GetStorageAtParameters,
  type GetStorageAtReturnType as viem_GetStorageAtReturnType,
  getStorageAt as viem_getStorageAt,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetStorageAtParameters<config extends Config = Config> = Compute<
  viem_GetStorageAtParameters & ChainIdParameter<config>
>

export type GetStorageAtReturnType = viem_GetStorageAtReturnType

export type GetStorageAtErrorType = viem_GetStorageAtErrorType

/** https://wagmi.sh/core/api/actions/getStorageAt */
export async function getStorageAt<config extends Config>(
  config: config,
  parameters: GetStorageAtParameters<config>,
): Promise<GetStorageAtReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getStorageAt, 'getStorageAt')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/getToken.ts">
import type { Address, Hex } from 'viem'
import {
  ContractFunctionExecutionError,
  formatUnits,
  hexToString,
  trim,
} from 'viem'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Unit } from '../types/unit.js'
import type { Compute } from '../types/utils.js'
import { getUnit } from '../utils/getUnit.js'
import { type ReadContractsErrorType, readContracts } from './readContracts.js'

export type GetTokenParameters<config extends Config = Config> = Compute<
  ChainIdParameter<config> & {
    address: Address
    formatUnits?: Unit | undefined
  }
>

export type GetTokenReturnType = {
  address: Address
  decimals: number
  name: string | undefined
  symbol: string | undefined
  totalSupply: {
    formatted: string
    value: bigint
  }
}

export type GetTokenErrorType = ReadContractsErrorType

/** @deprecated */
export async function getToken<config extends Config>(
  config: config,
  parameters: GetTokenParameters<config>,
): Promise<GetTokenReturnType> {
  const { address, chainId, formatUnits: unit = 18 } = parameters

  function getAbi<type extends 'bytes32' | 'string'>(type: type) {
    return [
      {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type: 'uint8' }],
      },
      {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type }],
      },
      {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type: 'uint256' }],
      },
    ] as const
  }

  try {
    const abi = getAbi('string')
    const contractConfig = { address, abi, chainId } as const
    const [decimals, name, symbol, totalSupply] = await readContracts(config, {
      allowFailure: true,
      contracts: [
        { ...contractConfig, functionName: 'decimals' },
        { ...contractConfig, functionName: 'name' },
        { ...contractConfig, functionName: 'symbol' },
        { ...contractConfig, functionName: 'totalSupply' },
      ] as const,
    })

    // throw if `name` or `symbol` failed
    if (name.error instanceof ContractFunctionExecutionError) throw name.error
    if (symbol.error instanceof ContractFunctionExecutionError)
      throw symbol.error

    // `decimals` and `totalSupply` are required
    if (decimals.error) throw decimals.error
    if (totalSupply.error) throw totalSupply.error

    return {
      address,
      decimals: decimals.result,
      name: name.result,
      symbol: symbol.result,
      totalSupply: {
        formatted: formatUnits(totalSupply.result!, getUnit(unit)),
        value: totalSupply.result,
      },
    }
  } catch (error) {
    // In the chance that there is an error upon decoding the contract result,
    // it could be likely that the contract data is represented as bytes32 instead
    // of a string.
    if (error instanceof ContractFunctionExecutionError) {
      const abi = getAbi('bytes32')
      const contractConfig = { address, abi, chainId } as const
      const [decimals, name, symbol, totalSupply] = await readContracts(
        config,
        {
          allowFailure: false,
          contracts: [
            { ...contractConfig, functionName: 'decimals' },
            { ...contractConfig, functionName: 'name' },
            { ...contractConfig, functionName: 'symbol' },
            { ...contractConfig, functionName: 'totalSupply' },
          ] as const,
        },
      )
      return {
        address,
        decimals,
        name: hexToString(trim(name as Hex, { dir: 'right' })),
        symbol: hexToString(trim(symbol as Hex, { dir: 'right' })),
        totalSupply: {
          formatted: formatUnits(totalSupply, getUnit(unit)),
          value: totalSupply,
        },
      }
    }

    throw error
  }
}
</file>

<file path="packages/core/src/actions/getTransaction.test-d.ts">
import { http } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { getTransaction } from './getTransaction.js'

test('chain formatters', async () => {
  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })
  const result = await getTransaction(config, { hash: '0x123' })
  if (result.chainId === celo.id) {
    expectTypeOf(result.feeCurrency).toEqualTypeOf<`0x${string}` | null>()
  }
})

test('chainId', async () => {
  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })
  const result = await getTransaction(config, {
    hash: '0x123',
    chainId: celo.id,
  })
  expectTypeOf(result.feeCurrency).toEqualTypeOf<`0x${string}` | null>()
})
</file>

<file path="packages/core/src/actions/getTransaction.ts">
import type { Chain } from 'viem'
import {
  type GetTransactionErrorType as viem_GetTransactionErrorType,
  type GetTransactionParameters as viem_GetTransactionParameters,
  type GetTransactionReturnType as viem_GetTransactionReturnType,
  getTransaction as viem_getTransaction,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, IsNarrowable } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetTransactionParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<viem_GetTransactionParameters & ChainIdParameter<config, chainId>>

export type GetTransactionReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = Compute<
  {
    [key in keyof chains]: viem_GetTransactionReturnType<
      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined
    > & { chainId: chains[key]['id'] }
  }[number]
>

export type GetTransactionErrorType = viem_GetTransactionErrorType

/** https://wagmi.sh/core/api/actions/getTransaction */
export function getTransaction<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: GetTransactionParameters<config, chainId>,
): Promise<GetTransactionReturnType<config, chainId>> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_getTransaction, 'getTransaction')
  return action(rest) as unknown as Promise<
    GetTransactionReturnType<config, chainId>
  >
}
</file>

<file path="packages/core/src/actions/getTransactionConfirmations.test-d.ts">
import { config } from '@wagmi/test'
import { mainnet, zkSync } from 'viem/chains'
import { test } from 'vitest'

import { http } from 'viem'
import { createConfig } from '../createConfig.js'
import { getTransactionConfirmations } from './getTransactionConfirmations.js'

test('default', async () => {
  getTransactionConfirmations(config, {
    transactionReceipt: {
      blockHash: '0x',
      blockNumber: 1n,
      contractAddress: '0x',
      cumulativeGasUsed: 1n,
      effectiveGasPrice: 1n,
      from: '0x',
      gasUsed: 1n,
      l1Fee: 1n,
      logs: [],
      logsBloom: '0x',
      status: 'success',
      to: '0x',
      transactionHash: '0x',
      transactionIndex: 1,
      type: 'eip1559',
    },
  })
})

test('chain formatters', async () => {
  const config = createConfig({
    chains: [mainnet, zkSync],
    transports: { [mainnet.id]: http(), [zkSync.id]: http() },
  })

  const transactionReceipt = {
    blockHash: '0x',
    blockNumber: 1n,
    contractAddress: '0x',
    cumulativeGasUsed: 1n,
    effectiveGasPrice: 1n,
    from: '0x',
    gasUsed: 1n,
    logsBloom: '0x',
    status: 'success',
    to: '0x',
    transactionHash: '0x',
    transactionIndex: 1,
    type: 'eip1559',
  } as const

  getTransactionConfirmations(config, {
    transactionReceipt: {
      ...transactionReceipt,
      l1BatchNumber: 1n,
      l1BatchTxIndex: 1n,
      logs: [],
      l2ToL1Logs: [],
    },
  })

  getTransactionConfirmations(config, {
    chainId: zkSync.id,
    transactionReceipt: {
      ...transactionReceipt,
      l1BatchNumber: 1n,
      l1BatchTxIndex: 1n,
      logs: [],
      l2ToL1Logs: [],
    },
  })

  getTransactionConfirmations(config, {
    chainId: mainnet.id,
    transactionReceipt: {
      ...transactionReceipt,
      // @ts-expect-error
      l1BatchNumber: 1n,
      l1BatchTxIndex: 1n,
      logs: [],
      l2ToL1Logs: [],
    },
  })
})
</file>

<file path="packages/core/src/actions/getTransactionConfirmations.ts">
import type { Chain } from 'viem'
import {
  type GetTransactionConfirmationsErrorType as viem_GetTransactionConfirmationsErrorType,
  type GetTransactionConfirmationsParameters as viem_GetTransactionConfirmationsParameters,
  type GetTransactionConfirmationsReturnType as viem_GetTransactionConfirmationsReturnType,
  getTransactionConfirmations as viem_getTransactionConfirmations,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ChainIdParameter } from '../types/properties.js'
import { getAction } from '../utils/getAction.js'

export type GetTransactionConfirmationsParameters<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: viem_GetTransactionConfirmationsParameters<
    chains[key]
  > &
    ChainIdParameter<config, chainId>
}[number]

export type GetTransactionConfirmationsReturnType =
  viem_GetTransactionConfirmationsReturnType

export type GetTransactionConfirmationsErrorType =
  viem_GetTransactionConfirmationsErrorType

/** https://wagmi.sh/core/api/actions/getTransactionConfirmations */
export function getTransactionConfirmations<
  config extends Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
>(
  config: config,
  parameters: GetTransactionConfirmationsParameters<config, chainId>,
): Promise<GetTransactionConfirmationsReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_getTransactionConfirmations,
    'getTransactionConfirmations',
  )
  return action(rest as viem_GetTransactionConfirmationsParameters)
}
</file>

<file path="packages/core/src/actions/getTransactionCount.ts">
import {
  type GetTransactionCountErrorType as viem_GetTransactionCountErrorType,
  type GetTransactionCountParameters as viem_GetTransactionCountParameters,
  type GetTransactionCountReturnType as viem_GetTransactionCountReturnType,
  getTransactionCount as viem_getTransactionCount,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetTransactionCountParameters<config extends Config = Config> =
  Compute<ChainIdParameter<config> & viem_GetTransactionCountParameters>

export type GetTransactionCountReturnType = viem_GetTransactionCountReturnType

export type GetTransactionCountErrorType = viem_GetTransactionCountErrorType

/** https://wagmi.sh/core/api/actions/getTransactionCount */
export async function getTransactionCount<config extends Config>(
  config: config,
  parameters: GetTransactionCountParameters<config>,
): Promise<GetTransactionCountReturnType> {
  const { address, blockNumber, blockTag, chainId } = parameters

  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_getTransactionCount,
    'getTransactionCount',
  )
  return action(blockNumber ? { address, blockNumber } : { address, blockTag })
}
</file>

<file path="packages/core/src/actions/getTransactionReceipt.test-d.ts">
import { http } from 'viem'
import { mainnet, zkSync } from 'viem/chains'
import type { ZkSyncL2ToL1Log, ZkSyncLog } from 'viem/zksync'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { getTransactionReceipt } from './getTransactionReceipt.js'

test('chain formatters', async () => {
  const config = createConfig({
    chains: [mainnet, zkSync],
    transports: { [mainnet.id]: http(), [zkSync.id]: http() },
  })
  const result = await getTransactionReceipt(config, { hash: '0x123' })
  if (result.chainId === zkSync.id) {
    expectTypeOf(result.l1BatchNumber).toEqualTypeOf<bigint | null>()
    expectTypeOf(result.l1BatchTxIndex).toEqualTypeOf<bigint | null>()
    expectTypeOf(result.logs).toEqualTypeOf<ZkSyncLog[]>()
    expectTypeOf(result.l2ToL1Logs).toEqualTypeOf<ZkSyncL2ToL1Log[]>()
  }
})

test('chainId', async () => {
  const config = createConfig({
    chains: [zkSync],
    transports: { [zkSync.id]: http() },
  })
  const result = await getTransactionReceipt(config, {
    hash: '0x123',
    chainId: zkSync.id,
  })
  expectTypeOf(result.l1BatchNumber).toEqualTypeOf<bigint | null>()
  expectTypeOf(result.l1BatchTxIndex).toEqualTypeOf<bigint | null>()
  expectTypeOf(result.logs).toEqualTypeOf<ZkSyncLog[]>()
  expectTypeOf(result.l2ToL1Logs).toEqualTypeOf<ZkSyncL2ToL1Log[]>()
})
</file>

<file path="packages/core/src/actions/getTransactionReceipt.ts">
import type { Chain } from 'viem'
import {
  type GetTransactionReceiptErrorType as viem_GetTransactionReceiptErrorType,
  type GetTransactionReceiptParameters as viem_GetTransactionReceiptParameters,
  type GetTransactionReceiptReturnType as viem_GetTransactionReceiptReturnType,
  getTransactionReceipt as viem_getTransactionReceipt,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, IsNarrowable } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type GetTransactionReceiptParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  viem_GetTransactionReceiptParameters & ChainIdParameter<config, chainId>
>

export type GetTransactionReceiptReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = Compute<
  {
    [key in keyof chains]: viem_GetTransactionReceiptReturnType<
      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined
    > & { chainId: chains[key]['id'] }
  }[number]
>

export type GetTransactionReceiptErrorType = viem_GetTransactionReceiptErrorType

/** https://wagmi.sh/core/api/actions/getTransactionReceipt */
export async function getTransactionReceipt<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: GetTransactionReceiptParameters<config>,
): Promise<GetTransactionReceiptReturnType<config, chainId>> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_getTransactionReceipt,
    'getTransactionReceipt',
  )
  return action(rest) as unknown as Promise<
    GetTransactionReceiptReturnType<config, chainId>
  >
}
</file>

<file path="packages/core/src/actions/getWalletClient.test-d.ts">
import { chain, config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import type { Account } from 'viem'
import { getWalletClient } from './getWalletClient.js'

test('default', async () => {
  const client = await getWalletClient(config)
  expectTypeOf(client.chain).toEqualTypeOf<(typeof config)['chains'][number]>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
  expectTypeOf(client.account).toEqualTypeOf<Account>()
})

test('parameters: chainId', async () => {
  const client = await getWalletClient(config, {
    chainId: chain.mainnet.id,
  })
  expectTypeOf(client.chain).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(client.chain).not.toEqualTypeOf<typeof chain.mainnet2>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
  expectTypeOf(client.account).toEqualTypeOf<Account>()
})
</file>

<file path="packages/core/src/actions/getWalletClient.ts">
import { type Account, type WalletClient, walletActions } from 'viem'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { Compute } from '../types/utils.js'
import {
  type GetConnectorClientErrorType,
  type GetConnectorClientParameters,
  getConnectorClient,
} from './getConnectorClient.js'

export type GetWalletClientParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = GetConnectorClientParameters<Config, chainId>

export type GetWalletClientReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  WalletClient<
    config['_internal']['transports'][chainId],
    Extract<config['chains'][number], { id: chainId }>,
    Account
  >
>

export type GetWalletClientErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType

export async function getWalletClient<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: GetWalletClientParameters<config, chainId> = {},
): Promise<GetWalletClientReturnType<config, chainId>> {
  const client = await getConnectorClient(config, parameters)
  // @ts-ignore
  return client.extend(walletActions) as unknown as GetWalletClientReturnType<
    config,
    chainId
  >
}
</file>

<file path="packages/core/src/actions/multicall.test-d.ts">
import { abi, config } from '@wagmi/test'
import type { Address } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { multicall } from './multicall.js'

test('default', async () => {
  const result = await multicall(config, {
    chainId: 1,
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
  })
  expectTypeOf(result).toEqualTypeOf<
    [
      (
        | { error: Error; result?: undefined; status: 'failure' }
        | { error?: undefined; result: bigint; status: 'success' }
      ),
      (
        | { error: Error; result?: undefined; status: 'failure' }
        | { error?: undefined; result: string; status: 'success' }
      ),
    ]
  >()
})

test('allowFailure', async () => {
  const result = await multicall(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
  })
  expectTypeOf(result).toEqualTypeOf<[bigint, string]>()
})

test('MulticallParameters', async () => {
  type Result = Parameters<
    typeof multicall<
      typeof config,
      [
        {
          address: '0x'
          abi: typeof abi.viewOverloads
          functionName: 'foo'
        },
      ]
    >
  >[1]['contracts'][0]
  expectTypeOf<Result['functionName']>().toEqualTypeOf<'foo' | 'bar'>()
  expectTypeOf<Result['args']>().toEqualTypeOf<
    readonly [] | readonly [Address] | readonly [Address, Address] | undefined
  >()
})

test('overloads', async () => {
  const res = await multicall(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
      },
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: ['0x', '0x'],
      },
    ],
  })

  expectTypeOf(res).toEqualTypeOf<
    [number, string, { foo: Address; bar: Address }]
  >()
})
</file>

<file path="packages/core/src/actions/multicall.ts">
import type {
  ContractFunctionParameters,
  MulticallErrorType as viem_MulticallErrorType,
  MulticallParameters as viem_MulticallParameters,
  MulticallReturnType as viem_MulticallReturnType,
} from 'viem'
import { multicall as viem_multicall } from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import { getAction } from '../utils/getAction.js'

export type MulticallParameters<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  config extends Config = Config,
> = viem_MulticallParameters<contracts, allowFailure> & ChainIdParameter<config>

export type MulticallReturnType<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
> = viem_MulticallReturnType<contracts, allowFailure>

export type MulticallErrorType = viem_MulticallErrorType

export async function multicall<
  config extends Config,
  const contracts extends readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
>(
  config: config,
  parameters: MulticallParameters<contracts, allowFailure, config>,
): Promise<MulticallReturnType<contracts, allowFailure>> {
  const { allowFailure = true, chainId, contracts, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_multicall, 'multicall')
  return action({
    allowFailure,
    contracts,
    ...rest,
  }) as Promise<MulticallReturnType<contracts, allowFailure>>
}
</file>

<file path="packages/core/src/actions/prepareTransactionRequest.test-d.ts">
import { accounts, config } from '@wagmi/test'
import { http, parseEther } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type PrepareTransactionRequestParameters,
  prepareTransactionRequest,
} from './prepareTransactionRequest.js'

const targetAccount = accounts[1]

test('default', async () => {
  const response = await prepareTransactionRequest(config, {
    chainId: 1,
    to: '0x',
    value: parseEther('1'),
  })
  const { nonce: _nonce, ...request } = response
  request.to
  request.chainId

  expectTypeOf(response).toMatchTypeOf<{
    chainId: 1
  }>()
})

test('chain formatters', async () => {
  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = PrepareTransactionRequestParameters<typeof config>
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  const request = await prepareTransactionRequest(config, {
    to: targetAccount,
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })
  if (request.chainId === celo.id) {
    expectTypeOf(request.chainId).toEqualTypeOf(celo.id)
    expectTypeOf(request.feeCurrency).toEqualTypeOf<`0x${string}` | undefined>()
  }

  type Result2 = PrepareTransactionRequestParameters<
    typeof config,
    typeof celo.id
  >
  expectTypeOf<Result2>().toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  const request2 = await prepareTransactionRequest(config, {
    chainId: celo.id,
    to: targetAccount,
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })
  expectTypeOf(request2.chainId).toEqualTypeOf(celo.id)
  expectTypeOf(request2.feeCurrency).toEqualTypeOf<`0x${string}` | undefined>()

  type Result3 = PrepareTransactionRequestParameters<
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  prepareTransactionRequest(config, {
    chainId: mainnet.id,
    to: targetAccount,
    value: parseEther('0.01'),
    // @ts-expect-error
    feeCurrency: '0x',
  })
})
</file>

<file path="packages/core/src/actions/prepareTransactionRequest.ts">
import type {
  Account,
  Address,
  Chain,
  PrepareTransactionRequestErrorType as viem_PrepareTransactionRequestErrorType,
  PrepareTransactionRequestParameters as viem_PrepareTransactionRequestParameters,
  PrepareTransactionRequestRequest as viem_PrepareTransactionRequestRequest,
  PrepareTransactionRequestReturnType as viem_PrepareTransactionRequestReturnType,
} from 'viem'
import { prepareTransactionRequest as viem_prepareTransactionRequest } from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ChainIdParameter } from '../types/properties.js'
import type {
  Compute,
  IsNarrowable,
  UnionCompute,
  UnionStrictOmit,
} from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import { getAccount } from './getAccount.js'

export type PrepareTransactionRequestParameters<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  > = viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    UnionStrictOmit<
      viem_PrepareTransactionRequestParameters<
        chains[key],
        Account,
        chains[key],
        Account | Address,
        request extends viem_PrepareTransactionRequestRequest<
          chains[key],
          chains[key]
        >
          ? request
          : never
      >,
      'chain'
    > &
      ChainIdParameter<config, chainId> & {
        to: Address
      }
  >
}[number]

export type PrepareTransactionRequestReturnType<
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  > = viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: Compute<
    viem_PrepareTransactionRequestReturnType<
      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined,
      Account,
      chains[key],
      Account,
      request extends viem_PrepareTransactionRequestRequest<
        IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined,
        chains[key]
      >
        ? request
        : never
    >
  > & {
    chainId: chains[key]['id']
  }
}[number]

export type PrepareTransactionRequestErrorType =
  viem_PrepareTransactionRequestErrorType

/** https://wagmi.sh/core/api/actions/prepareTransactionRequest */
export async function prepareTransactionRequest<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  const request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>['0'],
    SelectChains<config, chainId>['0']
  >,
>(
  config: config,
  parameters: PrepareTransactionRequestParameters<config, chainId, request>,
): Promise<PrepareTransactionRequestReturnType<config, chainId, request>> {
  const { account: account_, chainId, ...rest } = parameters

  const account = account_ ?? getAccount(config).address
  const client = config.getClient({ chainId })

  const action = getAction(
    client,
    viem_prepareTransactionRequest,
    'prepareTransactionRequest',
  )
  return action({
    ...rest,
    ...(account ? { account } : {}),
  } as unknown as viem_PrepareTransactionRequestParameters) as unknown as Promise<
    PrepareTransactionRequestReturnType<config, chainId, request>
  >
}
</file>

<file path="packages/core/src/actions/readContract.test-d.ts">
import { abi, config } from '@wagmi/test'
import { assertType, expectTypeOf, test } from 'vitest'

import { readContract } from './readContract.js'

test('default', async () => {
  const result = await readContract(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'balanceOf',
    args: ['0x'],
  })
  expectTypeOf(result).toEqualTypeOf<bigint>()
})

test('overloads', async () => {
  const result1 = await readContract(config, {
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
  })
  assertType<number>(result1)

  const result2 = await readContract(config, {
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
    args: [],
  })
  assertType<number>(result2)

  const result3 = await readContract(config, {
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string>(result3)

  const result4 = await readContract(config, {
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  assertType<{
    foo: `0x${string}`
    bar: `0x${string}`
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  }>(result4)
})

test('deployless read (bytecode)', async () => {
  const result = await readContract(config, {
    code: '0x',
    abi: abi.erc20,
    functionName: 'balanceOf',
    args: ['0x'],
  })
  expectTypeOf(result).toEqualTypeOf<bigint>()
})

test('deployless read (factory)', async () => {
  const result = await readContract(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'balanceOf',
    args: ['0x'],
    factory: '0x',
    factoryData: '0x',
  })
  expectTypeOf(result).toEqualTypeOf<bigint>()
})
</file>

<file path="packages/core/src/actions/readContract.ts">
import type { Abi } from 'viem'
import type { ContractFunctionArgs, ContractFunctionName } from 'viem'
import {
  type ReadContractErrorType as viem_ReadContractErrorType,
  type ReadContractParameters as viem_ReadContractParameters,
  type ReadContractReturnType as viem_ReadContractReturnType,
  readContract as viem_readContract,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import { getAction } from '../utils/getAction.js'

export type ReadContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'pure' | 'view'
  > = ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<
    abi,
    'pure' | 'view',
    functionName
  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  config extends Config = Config,
> = viem_ReadContractParameters<abi, functionName, args> &
  ChainIdParameter<config>

export type ReadContractReturnType<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'pure' | 'view'
  > = ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<
    abi,
    'pure' | 'view',
    functionName
  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
> = viem_ReadContractReturnType<abi, functionName, args>

export type ReadContractErrorType = viem_ReadContractErrorType

/** https://wagmi.sh/core/api/actions/readContract */
export function readContract<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
>(
  config: config,
  parameters: ReadContractParameters<abi, functionName, args, config>,
): Promise<ReadContractReturnType<abi, functionName, args>> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_readContract, 'readContract')
  return action(rest as any)
}
</file>

<file path="packages/core/src/actions/readContracts.test-d.ts">
import { abi, config } from '@wagmi/test'
import { assertType, expectTypeOf, test } from 'vitest'

import { readContracts } from './readContracts.js'

test('default', async () => {
  const result = await readContracts(config, {
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        args: ['0x'],
        chainId: 1,
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
  })
  expectTypeOf(result).toEqualTypeOf<
    [
      (
        | { error: Error; result?: undefined; status: 'failure' }
        | { error?: undefined; result: bigint; status: 'success' }
      ),
      (
        | { error: Error; result?: undefined; status: 'failure' }
        | { error?: undefined; result: string; status: 'success' }
      ),
    ]
  >()
})

test('allowFailure', async () => {
  const result = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
  })
  expectTypeOf(result).toEqualTypeOf<[bigint, string]>()
})

test('overloads', async () => {
  const result1 = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
      },
    ],
  })
  assertType<[number] | undefined>(result1)

  const result2 = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: [],
      },
    ],
  })
  assertType<[number] | undefined>(result2)

  const result3 = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: ['0x'],
      },
    ],
  })
  assertType<[string] | undefined>(result3)

  const result4 = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: ['0x', '0x'],
      },
    ],
  })
  assertType<
    | [
        {
          foo: `0x${string}`
          bar: `0x${string}`
        },
      ]
    | undefined
  >(result4)
})
</file>

<file path="packages/core/src/actions/readContracts.ts">
import type {
  ContractFunctionParameters,
  MulticallParameters as viem_MulticallParameters,
  MulticallReturnType as viem_MulticallReturnType,
} from 'viem'
import { ContractFunctionExecutionError } from 'viem'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import { type MulticallErrorType, multicall } from './multicall.js'
import { type ReadContractErrorType, readContract } from './readContract.js'

export type ReadContractsParameters<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  config extends Config = Config,
> = viem_MulticallParameters<
  contracts,
  allowFailure,
  { properties: ChainIdParameter<config> }
>

export type ReadContractsReturnType<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
> = viem_MulticallReturnType<contracts, allowFailure>

export type ReadContractsErrorType = MulticallErrorType | ReadContractErrorType

export async function readContracts<
  config extends Config,
  const contracts extends readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
>(
  config: config,
  parameters: ReadContractsParameters<contracts, allowFailure, config>,
): Promise<ReadContractsReturnType<contracts, allowFailure>> {
  const { allowFailure = true, blockNumber, blockTag, ...rest } = parameters
  const contracts = parameters.contracts as (ContractFunctionParameters & {
    chainId?: number | undefined
  })[]

  try {
    const contractsByChainId: {
      [chainId: number]: {
        contract: ContractFunctionParameters
        index: number
      }[]
    } = {}
    for (const [index, contract] of contracts.entries()) {
      const chainId = contract.chainId ?? config.state.chainId
      if (!contractsByChainId[chainId]) contractsByChainId[chainId] = []
      contractsByChainId[chainId]?.push({ contract, index })
    }
    const promises = () =>
      Object.entries(contractsByChainId).map(([chainId, contracts]) =>
        multicall(config, {
          ...rest,
          allowFailure,
          blockNumber,
          blockTag,
          chainId: Number.parseInt(chainId),
          contracts: contracts.map(({ contract }) => contract),
        }),
      )

    const multicallResults = (await Promise.all(promises())).flat()
    // Reorder the contract results back to the order they were
    // provided in.
    const resultIndexes = Object.values(contractsByChainId).flatMap(
      (contracts) => contracts.map(({ index }) => index),
    )
    return multicallResults.reduce((results, result, index) => {
      if (results) (results as unknown[])[resultIndexes[index]!] = result
      return results
    }, [] as unknown[]) as ReadContractsReturnType<contracts, allowFailure>
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError) throw error

    const promises = () =>
      contracts.map((contract) =>
        readContract(config, { ...contract, blockNumber, blockTag }),
      )
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result) => {
        if (result.status === 'fulfilled')
          return { result: result.value, status: 'success' }
        return { error: result.reason, result: undefined, status: 'failure' }
      }) as ReadContractsReturnType<contracts, allowFailure>

    return (await Promise.all(promises())) as ReadContractsReturnType<
      contracts,
      allowFailure
    >
  }
}
</file>

<file path="packages/core/src/actions/reconnect.ts">
import type { Address } from 'viem'

import type { CreateConnectorFn } from '../connectors/createConnector.js'
import type { Config, Connection, Connector } from '../createConfig.js'
import type { ErrorType } from '../errors/base.js'
import type { Compute } from '../types/utils.js'

export type ReconnectParameters = {
  /** Connectors to attempt reconnect with */
  connectors?: readonly (CreateConnectorFn | Connector)[] | undefined
}

export type ReconnectReturnType = Compute<Connection>[]

export type ReconnectErrorType = ErrorType

let isReconnecting = false

/** https://wagmi.sh/core/api/actions/reconnect */
export async function reconnect(
  config: Config,
  parameters: ReconnectParameters = {},
): Promise<ReconnectReturnType> {
  // If already reconnecting, do nothing
  if (isReconnecting) return []
  isReconnecting = true

  config.setState((x) => ({
    ...x,
    status: x.current ? 'reconnecting' : 'connecting',
  }))

  const connectors: Connector[] = []
  if (parameters.connectors?.length) {
    for (const connector_ of parameters.connectors) {
      let connector: Connector
      // "Register" connector if not already created
      if (typeof connector_ === 'function')
        connector = config._internal.connectors.setup(connector_)
      else connector = connector_
      connectors.push(connector)
    }
  } else connectors.push(...config.connectors)

  // Try recently-used connectors first
  let recentConnectorId: string | null | undefined
  try {
    recentConnectorId = await config.storage?.getItem('recentConnectorId')
  } catch {}
  const scores: Record<string, number> = {}
  for (const [, connection] of config.state.connections) {
    scores[connection.connector.id] = 1
  }
  if (recentConnectorId) scores[recentConnectorId] = 0
  const sorted =
    Object.keys(scores).length > 0
      ? // .toSorted()
        [...connectors].sort(
          (a, b) => (scores[a.id] ?? 10) - (scores[b.id] ?? 10),
        )
      : connectors

  // Iterate through each connector and try to connect
  let connected = false
  const connections: Connection[] = []
  const providers: unknown[] = []
  for (const connector of sorted) {
    const provider = await connector.getProvider().catch(() => undefined)
    if (!provider) continue

    // If we already have an instance of this connector's provider,
    // then we have already checked it (ie. injected connectors can
    // share the same `window.ethereum` instance, so we don't want to
    // connect to it again).
    if (providers.some((x) => x === provider)) continue

    const isAuthorized = await connector.isAuthorized()
    if (!isAuthorized) continue

    const data = await connector
      .connect({ isReconnecting: true })
      .catch(() => null)
    if (!data) continue

    connector.emitter.off('connect', config._internal.events.connect)
    connector.emitter.on('change', config._internal.events.change)
    connector.emitter.on('disconnect', config._internal.events.disconnect)

    config.setState((x) => {
      const connections = new Map(connected ? x.connections : new Map()).set(
        connector.uid,
        { accounts: data.accounts, chainId: data.chainId, connector },
      )
      return {
        ...x,
        current: connected ? x.current : connector.uid,
        connections,
      }
    })
    connections.push({
      accounts: data.accounts as readonly [Address, ...Address[]],
      chainId: data.chainId,
      connector,
    })
    providers.push(provider)
    connected = true
  }

  // Prevent overwriting connected status from race condition
  if (
    config.state.status === 'reconnecting' ||
    config.state.status === 'connecting'
  ) {
    // If connecting didn't succeed, set to disconnected
    if (!connected)
      config.setState((x) => ({
        ...x,
        connections: new Map(),
        current: null,
        status: 'disconnected',
      }))
    else config.setState((x) => ({ ...x, status: 'connected' }))
  }

  isReconnecting = false
  return connections
}
</file>

<file path="packages/core/src/actions/sendCalls.ts">
import type { Account, Chain } from 'viem'
import {
  type SendCallsErrorType as viem_SendCallsErrorType,
  type SendCallsParameters as viem_SendCallsParameters,
  type SendCallsReturnType as viem_SendCallsReturnType,
  sendCalls as viem_sendCalls,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type SendCallsParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: Compute<
    Omit<viem_SendCallsParameters<chains[key], Account, chains[key]>, 'chain'> &
      ChainIdParameter<config, chainId> &
      ConnectorParameter
  >
}[number]

export type SendCallsReturnType = viem_SendCallsReturnType

export type SendCallsErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_SendCallsErrorType

/** https://wagmi.sh/core/api/actions/sendCalls */
export async function sendCalls<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: SendCallsParameters<config, chainId>,
): Promise<SendCallsReturnType> {
  const { account, chainId, connector, calls, ...rest } = parameters

  const client = await getConnectorClient(config, {
    account,
    chainId,
    connector,
  })

  return viem_sendCalls(client, {
    ...(rest as any),
    ...(typeof account !== 'undefined' ? { account } : {}),
    calls,
    chain: chainId ? { id: chainId } : undefined,
  })
}
</file>

<file path="packages/core/src/actions/sendTransaction.test-d.ts">
import { http, parseEther } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type SendTransactionParameters,
  sendTransaction,
} from './sendTransaction.js'

test('chain formatters', () => {
  const config = createConfig({
    chains: [mainnet, celo],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = SendTransactionParameters<typeof config>
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  sendTransaction(config, {
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })

  type Result2 = SendTransactionParameters<typeof config, typeof celo.id>
  expectTypeOf<Result2>().toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  sendTransaction(config, {
    chainId: celo.id,
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })

  type Result3 = SendTransactionParameters<typeof config, typeof mainnet.id>
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  sendTransaction(config, {
    chainId: mainnet.id,
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    // @ts-expect-error
    feeCurrency: '0x',
  })
})
</file>

<file path="packages/core/src/actions/sendTransaction.ts">
import type {
  Account,
  Chain,
  Client,
  TransactionRequest,
  SendTransactionErrorType as viem_SendTransactionErrorType,
  SendTransactionParameters as viem_SendTransactionParameters,
  SendTransactionReturnType as viem_SendTransactionReturnType,
} from 'viem'
import { sendTransaction as viem_sendTransaction } from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type SendTransactionParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: Compute<
    Omit<
      viem_SendTransactionParameters<chains[key], Account, chains[key]>,
      'chain' | 'gas'
    > &
      ChainIdParameter<config, chainId> &
      ConnectorParameter
  >
}[number] & {
  /** Gas provided for transaction execution. */
  gas?: TransactionRequest['gas'] | null
}

export type SendTransactionReturnType = viem_SendTransactionReturnType

export type SendTransactionErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_SendTransactionErrorType

/** https://wagmi.sh/core/api/actions/sendTransaction */
export async function sendTransaction<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: SendTransactionParameters<config, chainId>,
): Promise<SendTransactionReturnType> {
  const { account, chainId, connector, ...rest } = parameters

  let client: Client
  if (typeof account === 'object' && account?.type === 'local')
    client = config.getClient({ chainId })
  else
    client = await getConnectorClient(config, {
      account: account ?? undefined,
      chainId,
      connector,
    })

  const action = getAction(client, viem_sendTransaction, 'sendTransaction')
  const hash = await action({
    ...(rest as any),
    ...(account ? { account } : {}),
    chain: chainId ? { id: chainId } : null,
    gas: rest.gas ?? undefined,
  })

  return hash
}
</file>

<file path="packages/core/src/actions/showCallsStatus.ts">
import {
  type ShowCallsStatusErrorType as viem_ShowCallsStatusErrorType,
  type ShowCallsStatusParameters as viem_ShowCallsStatusParameters,
  type ShowCallsStatusReturnType as viem_ShowCallsStatusReturnType,
  showCallsStatus as viem_showCallsStatus,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ConnectorParameter } from '../types/properties.js'
import { getConnectorClient } from './getConnectorClient.js'

export type ShowCallsStatusParameters = viem_ShowCallsStatusParameters &
  ConnectorParameter

export type ShowCallsStatusReturnType = viem_ShowCallsStatusReturnType

export type ShowCallsStatusErrorType = viem_ShowCallsStatusErrorType

/** https://wagmi.sh/core/api/actions/showCallsStatus */
export async function showCallsStatus<config extends Config>(
  config: config,
  parameters: ShowCallsStatusParameters,
): Promise<ShowCallsStatusReturnType> {
  const { connector, id } = parameters
  const client = await getConnectorClient(config, { connector })
  return viem_showCallsStatus(client, { id })
}
</file>

<file path="packages/core/src/actions/signMessage.ts">
import type { Account, Client } from 'viem'
import {
  type SignMessageErrorType as viem_SignMessageErrorType,
  type SignMessageParameters as viem_SignMessageParameters,
  type SignMessageReturnType as viem_SignMessageReturnType,
  signMessage as viem_signMessage,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { ConnectorParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type SignMessageParameters = Compute<
  viem_SignMessageParameters<Account> & ConnectorParameter
>

export type SignMessageReturnType = viem_SignMessageReturnType

export type SignMessageErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_SignMessageErrorType

/** https://wagmi.sh/core/api/actions/signMessage */
export async function signMessage(
  config: Config,
  parameters: SignMessageParameters,
): Promise<SignMessageReturnType> {
  const { account, connector, ...rest } = parameters

  let client: Client
  if (typeof account === 'object' && account.type === 'local')
    client = config.getClient()
  else client = await getConnectorClient(config, { account, connector })

  const action = getAction(client, viem_signMessage, 'signMessage')
  return action({
    ...rest,
    ...(account ? { account } : {}),
  } as viem_SignMessageParameters<Account>)
}
</file>

<file path="packages/core/src/actions/signTypedData.test-d.ts">
import { config, typedData } from '@wagmi/test'
import { test } from 'vitest'

import { signTypedData } from './signTypedData.js'

test('default', async () => {
  signTypedData(config, {
    types: typedData.basic.types,
    primaryType: 'Mail',
    message: typedData.basic.message,
  })
})

test('domain', async () => {
  signTypedData(config, {
    primaryType: 'EIP712Domain',
    domain: {},
  })
})

test('custom domain', async () => {
  signTypedData(config, {
    types: {
      EIP712Domain: [{ type: 'uint256', name: 'chainId' }],
    },
    primaryType: 'EIP712Domain',
    domain: {
      chainId: 123n,
    },
  })
})
</file>

<file path="packages/core/src/actions/signTypedData.ts">
import type { Account, Client, TypedData } from 'viem'
import {
  type SignMessageErrorType as viem_SignMessageErrorType,
  type SignTypedDataParameters as viem_SignTypedDataParameters,
  type SignTypedDataReturnType as viem_SignTypedDataReturnType,
  signTypedData as viem_signTypedData,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { ConnectorParameter } from '../types/properties.js'
import type { UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type SignTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  ///
  primaryTypes = typedData extends TypedData ? keyof typedData : string,
> = UnionCompute<
  viem_SignTypedDataParameters<typedData, primaryType, Account, primaryTypes> &
    ConnectorParameter
>

export type SignTypedDataReturnType = viem_SignTypedDataReturnType

export type SignTypedDataErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_SignMessageErrorType

/** https://wagmi.sh/core/api/actions/signTypedData */
export async function signTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  config: Config,
  parameters: SignTypedDataParameters<typedData, primaryType>,
): Promise<SignTypedDataReturnType> {
  const { account, connector, ...rest } = parameters

  let client: Client
  if (typeof account === 'object' && account.type === 'local')
    client = config.getClient()
  else client = await getConnectorClient(config, { account, connector })

  const action = getAction(client, viem_signTypedData, 'signTypedData')
  return action({
    ...rest,
    ...(account ? { account } : {}),
  } as unknown as viem_SignTypedDataParameters)
}
</file>

<file path="packages/core/src/actions/simulateContract.test-d.ts">
import { abi, config } from '@wagmi/test'
import { http, type Address } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from './simulateContract.js'

test('default', async () => {
  const response = await simulateContract(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })

  expectTypeOf(response).toMatchTypeOf<{
    result: boolean
    request: {
      chainId: 1
      abi: readonly [
        {
          readonly name: 'transferFrom'
          readonly type: 'function'
          readonly stateMutability: 'nonpayable'
          readonly inputs: readonly [
            { readonly type: 'address'; readonly name: 'sender' },
            { readonly type: 'address'; readonly name: 'recipient' },
            { readonly type: 'uint256'; readonly name: 'amount' },
          ]
          readonly outputs: readonly [{ type: 'bool' }]
        },
      ]
      functionName: 'transferFrom'
      args: readonly [Address, Address, bigint]
    }
  }>()
})

test('chain formatters', async () => {
  const config = createConfig({
    chains: [celo, mainnet],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = SimulateContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config
  >
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  const response = await simulateContract(config, {
    account: '0x',
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    feeCurrency: '0x',
  })

  if (response.chainId === celo.id) {
    expectTypeOf(response.chainId).toEqualTypeOf(celo.id)
    expectTypeOf(response.request.feeCurrency).toEqualTypeOf<
      `0x${string}` | undefined
    >()
  }

  type Result2 = SimulateContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    typeof celo.id
  >
  expectTypeOf<Result2>().toMatchTypeOf<{
    functionName: 'approve' | 'transfer' | 'transferFrom'
    args: readonly [Address, Address, bigint]
    feeCurrency?: `0x${string}` | undefined
  }>()
  const response2 = await simulateContract(config, {
    chainId: celo.id,
    account: '0x',
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    feeCurrency: '0x',
  })
  expectTypeOf(response2.chainId).toEqualTypeOf(celo.id)
  expectTypeOf(response2.request.feeCurrency).toEqualTypeOf<
    `0x${string}` | undefined
  >()

  type Result3 = SimulateContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result3>().toMatchTypeOf<{
    functionName: 'approve' | 'transfer' | 'transferFrom'
    args: readonly [Address, Address, bigint]
  }>()
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  simulateContract(config, {
    chainId: mainnet.id,
    account: '0x',
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error
    feeCurrency: '0x',
  })
})

test('SimulateContractParameters', () => {
  type Result = SimulateContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    (typeof config)['chains'][number]['id']
  >
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: (typeof config)['chains'][number]['id'] | undefined
    functionName: 'approve' | 'transfer' | 'transferFrom'
    args: readonly [Address, Address, bigint]
  }>()
})

test('SimulateContractReturnType', () => {
  type Result = SimulateContractReturnType<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    (typeof config)['chains'][number]['id']
  >
  expectTypeOf<Result>().toMatchTypeOf<{
    result: boolean
    request: {
      functionName: 'transferFrom'
      args: readonly [Address, Address, bigint]
      chainId: (typeof config)['chains'][number]['id']
    }
  }>()
})
</file>

<file path="packages/core/src/actions/simulateContract.ts">
import type {
  Abi,
  Account,
  Address,
  Chain,
  ContractFunctionArgs,
  ContractFunctionName,
} from 'viem'
import {
  type SimulateContractErrorType as viem_SimulateContractErrorType,
  type SimulateContractParameters as viem_SimulateContractParameters,
  type SimulateContractReturnType as viem_SimulateContractReturnType,
  simulateContract as viem_simulateContract,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type {
  Compute,
  PartialBy,
  UnionCompute,
  UnionStrictOmit,
} from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type SimulateContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'nonpayable' | 'payable'
  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    UnionStrictOmit<
      viem_SimulateContractParameters<
        abi,
        functionName,
        args,
        chains[key],
        chains[key],
        Account | Address
      >,
      'chain'
    >
  > &
    ChainIdParameter<config, chainId> &
    ConnectorParameter
}[number]

export type SimulateContractReturnType<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'nonpayable' | 'payable'
  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  config extends Config = Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: viem_SimulateContractReturnType<
    abi,
    functionName,
    args,
    chains[key],
    Account,
    chains[key]
  > & {
    chainId: chains[key]['id']
    request: Compute<
      PartialBy<
        { chainId: chainId; chain: chains[key] },
        chainId extends config['chains'][number]['id'] ? never : 'chainId'
      >
    >
  }
}[number]

export type SimulateContractErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_SimulateContractErrorType

/** https://wagmi.sh/core/api/actions/simulateContract */
export async function simulateContract<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
>(
  config: config,
  parameters: SimulateContractParameters<
    abi,
    functionName,
    args,
    config,
    chainId
  >,
): Promise<
  SimulateContractReturnType<abi, functionName, args, config, chainId>
> {
  const { abi, chainId, connector, ...rest } =
    parameters as SimulateContractParameters

  let account: Address | Account
  if (parameters.account) account = parameters.account
  else {
    const connectorClient = await getConnectorClient(config, {
      chainId,
      connector,
    })
    account = connectorClient.account
  }

  const client = config.getClient({ chainId })
  const action = getAction(client, viem_simulateContract, 'simulateContract')
  const { result, request } = await action({ ...rest, abi, account })

  return {
    chainId: client.chain.id,
    result,
    request: { ...request, chainId },
  } as unknown as SimulateContractReturnType<
    abi,
    functionName,
    args,
    config,
    chainId
  >
}
</file>

<file path="packages/core/src/actions/switchAccount.ts">
import type { Address } from 'viem'

import type { Config, Connector } from '../createConfig.js'
import type { BaseError, ErrorType } from '../errors/base.js'
import {
  ConnectorNotConnectedError,
  type ConnectorNotConnectedErrorType,
} from '../errors/config.js'

export type SwitchAccountParameters = {
  connector: Connector
}

export type SwitchAccountReturnType<config extends Config = Config> = {
  accounts: readonly [Address, ...Address[]]
  chainId:
    | config['chains'][number]['id']
    | (number extends config['chains'][number]['id'] ? number : number & {})
}

export type SwitchAccountErrorType =
  | ConnectorNotConnectedErrorType
  | BaseError
  | ErrorType

/** https://wagmi.sh/core/api/actions/switchAccount */
export async function switchAccount<config extends Config>(
  config: config,
  parameters: SwitchAccountParameters,
): Promise<SwitchAccountReturnType<config>> {
  const { connector } = parameters

  const connection = config.state.connections.get(connector.uid)
  if (!connection) throw new ConnectorNotConnectedError()

  await config.storage?.setItem('recentConnectorId', connector.id)
  config.setState((x) => ({
    ...x,
    current: connector.uid,
  }))
  return {
    accounts: connection.accounts,
    chainId: connection.chainId,
  }
}
</file>

<file path="packages/core/src/actions/switchChain.ts">
import type {
  AddEthereumChainParameter,
  UserRejectedRequestErrorType,
  SwitchChainErrorType as viem_SwitchChainErrorType,
} from 'viem'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import {
  ChainNotConfiguredError,
  type ChainNotConfiguredErrorType,
} from '../errors/config.js'
import {
  type ProviderNotFoundErrorType,
  SwitchChainNotSupportedError,
  type SwitchChainNotSupportedErrorType,
} from '../errors/connector.js'
import type { ConnectorParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'

export type SwitchChainParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  ConnectorParameter & {
    chainId: chainId | config['chains'][number]['id']
    addEthereumChainParameter?:
      | Compute<ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>>
      | undefined
  }
>

export type SwitchChainReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Extract<
  config['chains'][number],
  { id: Config extends config ? number : chainId }
>

export type SwitchChainErrorType =
  | SwitchChainNotSupportedErrorType
  | ChainNotConfiguredErrorType
  // connector.switchChain()
  | ProviderNotFoundErrorType
  | UserRejectedRequestErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_SwitchChainErrorType

/** https://wagmi.sh/core/api/actions/switchChain */
export async function switchChain<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: SwitchChainParameters<config, chainId>,
): Promise<SwitchChainReturnType<config, chainId>> {
  const { addEthereumChainParameter, chainId } = parameters

  const connection = config.state.connections.get(
    parameters.connector?.uid ?? config.state.current!,
  )
  if (connection) {
    const connector = connection.connector
    if (!connector.switchChain)
      throw new SwitchChainNotSupportedError({ connector })
    const chain = await connector.switchChain({
      addEthereumChainParameter,
      chainId,
    })
    return chain as SwitchChainReturnType<config, chainId>
  }

  const chain = config.chains.find((x) => x.id === chainId)
  if (!chain) throw new ChainNotConfiguredError()
  config.setState((x) => ({ ...x, chainId }))
  return chain as SwitchChainReturnType<config, chainId>
}
</file>

<file path="packages/core/src/actions/verifyMessage.ts">
import {
  type VerifyMessageErrorType as viem_VerifyMessageErrorType,
  type VerifyMessageParameters as viem_VerifyMessageParameters,
  type VerifyMessageReturnType as viem_VerifyMessageReturnType,
  verifyMessage as viem_verifyMessage,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type VerifyMessageParameters<config extends Config = Config> = Compute<
  viem_VerifyMessageParameters & ChainIdParameter<config>
>

export type VerifyMessageReturnType = viem_VerifyMessageReturnType

export type VerifyMessageErrorType = viem_VerifyMessageErrorType

/** https://wagmi.sh/core/api/actions/verifyMessage */
export async function verifyMessage<config extends Config>(
  config: config,
  parameters: VerifyMessageParameters<config>,
): Promise<VerifyMessageReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_verifyMessage, 'verifyMessage')
  return action(rest)
}
</file>

<file path="packages/core/src/actions/verifyTypedData.ts">
import type { TypedData } from 'viem'
import {
  type VerifyTypedDataErrorType as viem_VerifyTypedDataErrorType,
  type VerifyTypedDataParameters as viem_VerifyTypedDataParameters,
  type VerifyTypedDataReturnType as viem_VerifyTypedDataReturnType,
  verifyTypedData as viem_verifyTypedData,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type VerifyTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  config extends Config = Config,
> = Compute<
  viem_VerifyTypedDataParameters<typedData, primaryType> &
    ChainIdParameter<config>
>

export type VerifyTypedDataReturnType = viem_VerifyTypedDataReturnType

export type VerifyTypedDataErrorType = viem_VerifyTypedDataErrorType

/** https://wagmi.sh/core/api/actions/verifyTypedData */
export async function verifyTypedData<
  config extends Config,
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  config: config,
  parameters: VerifyTypedDataParameters<typedData, primaryType, config>,
): Promise<VerifyTypedDataReturnType> {
  const { chainId, ...rest } = parameters
  const client = config.getClient({ chainId })
  const action = getAction(client, viem_verifyTypedData, 'verifyTypedData')
  return action(rest as viem_VerifyTypedDataParameters)
}
</file>

<file path="packages/core/src/actions/waitForCallsStatus.ts">
import {
  type WaitForCallsStatusErrorType as viem_WaitForCallsStatusErrorType,
  type WaitForCallsStatusParameters as viem_WaitForCallsStatusParameters,
  type WaitForCallsStatusReturnType as viem_WaitForCallsStatusReturnType,
  waitForCallsStatus as viem_waitForCallsStatus,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { ConnectorParameter } from '../types/properties.js'
import { getConnectorClient } from './getConnectorClient.js'

export type WaitForCallsStatusParameters = viem_WaitForCallsStatusParameters &
  ConnectorParameter

export type WaitForCallsStatusReturnType = viem_WaitForCallsStatusReturnType

export type WaitForCallsStatusErrorType = viem_WaitForCallsStatusErrorType

/** https://wagmi.sh/core/api/actions/waitForCallsStatus */
export async function waitForCallsStatus<config extends Config>(
  config: config,
  parameters: WaitForCallsStatusParameters,
): Promise<WaitForCallsStatusReturnType> {
  const { connector, id } = parameters
  const client = await getConnectorClient(config, { connector })
  return viem_waitForCallsStatus(client, { id })
}
</file>

<file path="packages/core/src/actions/waitForTransactionReceipt.test-d.ts">
import { http } from 'viem'
import { mainnet, zkSync } from 'viem/chains'
import type { ZkSyncL2ToL1Log, ZkSyncLog } from 'viem/zksync'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { waitForTransactionReceipt } from './waitForTransactionReceipt.js'

test('chain formatters', async () => {
  const config = createConfig({
    chains: [mainnet, zkSync],
    transports: { [mainnet.id]: http(), [zkSync.id]: http() },
  })
  const result = await waitForTransactionReceipt(config, { hash: '0x123' })
  if (result.chainId === zkSync.id) {
    expectTypeOf(result.l1BatchNumber).toEqualTypeOf<bigint | null>()
    expectTypeOf(result.l1BatchTxIndex).toEqualTypeOf<bigint | null>()
    expectTypeOf(result.logs).toEqualTypeOf<ZkSyncLog[]>()
    expectTypeOf(result.l2ToL1Logs).toEqualTypeOf<ZkSyncL2ToL1Log[]>()
  }
})

test('chainId', async () => {
  const config = createConfig({
    chains: [zkSync],
    transports: { [zkSync.id]: http() },
  })
  const result = await waitForTransactionReceipt(config, {
    hash: '0x123',
    chainId: zkSync.id,
  })
  expectTypeOf(result.l1BatchNumber).toEqualTypeOf<bigint | null>()
  expectTypeOf(result.l1BatchTxIndex).toEqualTypeOf<bigint | null>()
  expectTypeOf(result.logs).toEqualTypeOf<ZkSyncLog[]>()
  expectTypeOf(result.l2ToL1Logs).toEqualTypeOf<ZkSyncL2ToL1Log[]>()
})
</file>

<file path="packages/core/src/actions/waitForTransactionReceipt.ts">
import type { Chain } from 'viem'
import { hexToString } from 'viem'
import {
  call,
  getTransaction,
  type WaitForTransactionReceiptErrorType as viem_WaitForTransactionReceiptErrorType,
  type WaitForTransactionReceiptParameters as viem_WaitForTransactionReceiptParameters,
  type WaitForTransactionReceiptReturnType as viem_WaitForTransactionReceiptReturnType,
  waitForTransactionReceipt as viem_waitForTransactionReceipt,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { Compute, IsNarrowable } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type WaitForTransactionReceiptParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  viem_WaitForTransactionReceiptParameters & ChainIdParameter<config, chainId>
>

export type WaitForTransactionReceiptReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = Compute<
  {
    [key in keyof chains]: viem_WaitForTransactionReceiptReturnType<
      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined
    > & { chainId: chains[key]['id'] }
  }[number]
>

export type WaitForTransactionReceiptErrorType =
  viem_WaitForTransactionReceiptErrorType

export async function waitForTransactionReceipt<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: WaitForTransactionReceiptParameters<config, chainId>,
): Promise<WaitForTransactionReceiptReturnType<config, chainId>> {
  const { chainId, timeout = 0, ...rest } = parameters

  const client = config.getClient({ chainId })
  const action = getAction(
    client,
    viem_waitForTransactionReceipt,
    'waitForTransactionReceipt',
  )
  const receipt = await action({ ...rest, timeout })

  if (receipt.status === 'reverted') {
    const action_getTransaction = getAction(
      client,
      getTransaction,
      'getTransaction',
    )
    const txn = await action_getTransaction({ hash: receipt.transactionHash })
    const action_call = getAction(client, call, 'call')
    const code = await action_call({
      ...(txn as any),
      data: txn.input,
      gasPrice: txn.type !== 'eip1559' ? txn.gasPrice : undefined,
      maxFeePerGas: txn.type === 'eip1559' ? txn.maxFeePerGas : undefined,
      maxPriorityFeePerGas:
        txn.type === 'eip1559' ? txn.maxPriorityFeePerGas : undefined,
    })
    const reason = code?.data
      ? hexToString(`0x${code.data.substring(138)}`)
      : 'unknown reason'
    throw new Error(reason)
  }

  return {
    ...receipt,
    chainId: client.chain.id,
  } as WaitForTransactionReceiptReturnType<config, chainId>
}
</file>

<file path="packages/core/src/actions/watchAccount.ts">
import type { Config } from '../createConfig.js'
import { deepEqual } from '../utils/deepEqual.js'
import { type GetAccountReturnType, getAccount } from './getAccount.js'

export type WatchAccountParameters<config extends Config = Config> = {
  onChange(
    account: GetAccountReturnType<config>,
    prevAccount: GetAccountReturnType<config>,
  ): void
}

export type WatchAccountReturnType = () => void

/** https://wagmi.sh/core/api/actions/watchAccount */
export function watchAccount<config extends Config>(
  config: config,
  parameters: WatchAccountParameters<config>,
): WatchAccountReturnType {
  const { onChange } = parameters

  return config.subscribe(() => getAccount(config), onChange, {
    equalityFn(a, b) {
      const { connector: aConnector, ...aRest } = a
      const { connector: bConnector, ...bRest } = b
      return (
        deepEqual(aRest, bRest) &&
        // check connector separately
        aConnector?.id === bConnector?.id &&
        aConnector?.uid === bConnector?.uid
      )
    },
  })
}
</file>

<file path="packages/core/src/actions/watchAsset.ts">
import {
  type WatchAssetErrorType as viem_WatchAssetErrorType,
  type WatchAssetParameters as viem_WatchAssetParameters,
  type WatchAssetReturnType as viem_WatchAssetReturnType,
  watchAsset as viem_watchAsset,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { ConnectorParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type WatchAssetParameters = Compute<
  viem_WatchAssetParameters & ConnectorParameter
>

export type WatchAssetReturnType = viem_WatchAssetReturnType

export type WatchAssetErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_WatchAssetErrorType

/** https://wagmi.sh/core/api/actions/watchAsset */
export async function watchAsset(
  config: Config,
  parameters: WatchAssetParameters,
): Promise<WatchAssetReturnType> {
  const { connector, ...rest } = parameters

  const client = await getConnectorClient(config, { connector })

  const action = getAction(client, viem_watchAsset, 'watchAsset')
  return action(rest as viem_WatchAssetParameters)
}
</file>

<file path="packages/core/src/actions/watchBlockNumber.test-d.ts">
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type WatchBlockNumberParameters,
  watchBlockNumber,
} from './watchBlockNumber.js'

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = WatchBlockNumberParameters<
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  watchBlockNumber(config, {
    poll: false,
    onBlockNumber() {},
  })

  type Result2 = WatchBlockNumberParameters<typeof config, typeof mainnet.id>
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  watchBlockNumber(config, {
    chainId: mainnet.id,
    poll: true,
    onBlockNumber() {},
  })
  watchBlockNumber(config, {
    chainId: mainnet.id,
    // @ts-expect-error
    poll: false,
    onBlockNumber() {},
  })

  type Result3 = WatchBlockNumberParameters<typeof config, typeof optimism.id>
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  watchBlockNumber(config, {
    chainId: optimism.id,
    poll: true,
    onBlockNumber() {},
  })
  watchBlockNumber(config, {
    chainId: optimism.id,
    poll: false,
    onBlockNumber() {},
  })
})
</file>

<file path="packages/core/src/actions/watchBlockNumber.ts">
import {
  type WatchBlockNumberParameters as viem_WatchBlockNumberParameters,
  type WatchBlockNumberReturnType as viem_WatchBlockNumberReturnType,
  watchBlockNumber as viem_watchBlockNumber,
} from 'viem/actions'

import type { Chain, Transport, WebSocketTransport } from 'viem'
import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  SyncConnectedChainParameter,
} from '../types/properties.js'
import type { UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type WatchBlockNumberParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    viem_WatchBlockNumberParameters<
      config['_internal']['transports'][chains[key]['id']] extends infer transport extends
        Transport
        ? Transport extends transport
          ? WebSocketTransport
          : transport
        : WebSocketTransport
    > &
      ChainIdParameter<config, chainId> &
      SyncConnectedChainParameter
  >
}[number]

export type WatchBlockNumberReturnType = viem_WatchBlockNumberReturnType

// TODO: wrap in viem's `observe` to avoid duplicate invocations.
/** https://wagmi.sh/core/api/actions/watchBlockNumber */
export function watchBlockNumber<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  config: config,
  parameters: WatchBlockNumberParameters<config, chainId>,
): WatchBlockNumberReturnType {
  const { syncConnectedChain = config._internal.syncConnectedChain, ...rest } =
    parameters as WatchBlockNumberParameters

  let unwatch: WatchBlockNumberReturnType | undefined
  const listener = (chainId: number | undefined) => {
    if (unwatch) unwatch()

    const client = config.getClient({ chainId })
    const action = getAction(client, viem_watchBlockNumber, 'watchBlockNumber')
    unwatch = action(rest as viem_WatchBlockNumberParameters)
    return unwatch
  }

  // set up listener for block number changes
  const unlisten = listener(parameters.chainId)

  // set up subscriber for connected chain changes
  let unsubscribe: (() => void) | undefined
  if (syncConnectedChain && !parameters.chainId)
    unsubscribe = config.subscribe(
      ({ chainId }) => chainId,
      async (chainId) => listener(chainId),
    )

  return () => {
    unlisten?.()
    unsubscribe?.()
  }
}
</file>

<file path="packages/core/src/actions/watchBlocks.test-d.ts">
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { type WatchBlocksParameters, watchBlocks } from './watchBlocks.js'

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = WatchBlocksParameters<
    false,
    'latest',
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  watchBlocks(config, {
    poll: false,
    onBlock() {},
  })

  type Result2 = WatchBlocksParameters<
    false,
    'latest',
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  watchBlocks(config, {
    chainId: mainnet.id,
    poll: true,
    onBlock() {},
  })

  type Result3 = WatchBlocksParameters<
    false,
    'latest',
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  watchBlocks(config, {
    chainId: optimism.id,
    poll: true,
    onBlock() {},
  })
  watchBlocks(config, {
    chainId: optimism.id,
    poll: false,
    onBlock() {},
  })
})
</file>

<file path="packages/core/src/actions/watchBlocks.ts">
import {
  type WatchBlocksParameters as viem_WatchBlocksParameters,
  type WatchBlocksReturnType as viem_WatchBlocksReturnType,
  watchBlocks as viem_watchBlocks,
} from 'viem/actions'

import type { BlockTag, Chain, Transport, WebSocketTransport } from 'viem'
import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  SyncConnectedChainParameter,
} from '../types/properties.js'
import type { IsNarrowable, UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type WatchBlocksParameters<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    viem_WatchBlocksParameters<
      config['_internal']['transports'][chains[key]['id']] extends infer transport extends
        Transport
        ? Transport extends transport
          ? WebSocketTransport
          : transport
        : WebSocketTransport,
      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined,
      includeTransactions,
      blockTag
    > &
      ChainIdParameter<config, chainId> &
      SyncConnectedChainParameter
  >
}[number]

export type WatchBlocksReturnType = viem_WatchBlocksReturnType

// TODO: wrap in viem's `observe` to avoid duplicate invocations.
/** https://wagmi.sh/core/actions/watchBlocks */
export function watchBlocks<
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
>(
  config: config,
  parameters: WatchBlocksParameters<
    includeTransactions,
    blockTag,
    config,
    chainId
  >,
): WatchBlocksReturnType {
  const { syncConnectedChain = config._internal.syncConnectedChain, ...rest } =
    parameters as WatchBlocksParameters

  let unwatch: WatchBlocksReturnType | undefined
  const listener = (chainId: number | undefined) => {
    if (unwatch) unwatch()

    const client = config.getClient({ chainId })
    const action = getAction(client, viem_watchBlocks, 'watchBlocks')
    unwatch = action(rest as viem_WatchBlocksParameters)
    return unwatch
  }

  // set up listener for block number changes
  const unlisten = listener(parameters.chainId)

  // set up subscriber for connected chain changes
  let unsubscribe: (() => void) | undefined
  if (syncConnectedChain && !parameters.chainId)
    unsubscribe = config.subscribe(
      ({ chainId }) => chainId,
      async (chainId) => listener(chainId),
    )

  return () => {
    unlisten?.()
    unsubscribe?.()
  }
}
</file>

<file path="packages/core/src/actions/watchChainId.ts">
import type { Config } from '../createConfig.js'
import type { GetChainIdReturnType } from './getChainId.js'

export type WatchChainIdParameters<config extends Config = Config> = {
  onChange(
    chainId: GetChainIdReturnType<config>,
    prevChainId: GetChainIdReturnType<config>,
  ): void
}

export type WatchChainIdReturnType = () => void

/** https://wagmi.sh/core/api/actions/watchChainId */
export function watchChainId<config extends Config>(
  config: config,
  parameters: WatchChainIdParameters<config>,
): WatchChainIdReturnType {
  const { onChange } = parameters
  return config.subscribe((state) => state.chainId, onChange)
}
</file>

<file path="packages/core/src/actions/watchChains.ts">
import type { Config } from '../createConfig.js'
import type { GetChainsReturnType } from './getChains.js'

export type WatchChainsParameters<config extends Config = Config> = {
  onChange(
    chains: GetChainsReturnType<config>,
    prevChains: GetChainsReturnType<config>,
  ): void
}

export type WatchChainsReturnType = () => void

/**
 * @internal
 * We don't expose this because as far as consumers know, you can't chainge (lol) `config.chains` at runtime.
 * Setting `config.chains` via `config._internal.chains.setState(...)` is an extremely advanced use case that's not worth documenting or supporting in the public API at this time.
 */
export function watchChains<config extends Config>(
  config: config,
  parameters: WatchChainsParameters<config>,
): WatchChainsReturnType {
  const { onChange } = parameters
  return config._internal.chains.subscribe((chains, prevChains) => {
    onChange(
      chains as unknown as GetChainsReturnType<config>,
      prevChains as unknown as GetChainsReturnType<config>,
    )
  })
}
</file>

<file path="packages/core/src/actions/watchClient.test-d.ts">
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { watchClient } from './watchClient.js'

test('default', () => {
  watchClient(config, {
    onChange(client) {
      expectTypeOf(client.chain).toEqualTypeOf<
        (typeof config)['chains'][number]
      >()
      expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
    },
  })
})
</file>

<file path="packages/core/src/actions/watchClient.ts">
import type { Config } from '../createConfig.js'
import { type GetClientReturnType, getClient } from './getClient.js'

export type WatchClientParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = {
  onChange(
    publicClient: GetClientReturnType<config, chainId>,
    prevClient: GetClientReturnType<config, chainId>,
  ): void
}

export type WatchClientReturnType = () => void

/** https://wagmi.sh/core/api/actions/watchClient */
export function watchClient<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: WatchClientParameters<config, chainId>,
): WatchClientReturnType {
  const { onChange } = parameters
  return config.subscribe(
    () => getClient(config) as GetClientReturnType<config, chainId>,
    onChange,
    {
      equalityFn(a, b) {
        return a?.uid === b?.uid
      },
    },
  )
}
</file>

<file path="packages/core/src/actions/watchConnections.ts">
import type { Config } from '../createConfig.js'
import { deepEqual } from '../utils/deepEqual.js'
import {
  type GetConnectionsReturnType,
  getConnections,
} from './getConnections.js'

export type WatchConnectionsParameters = {
  onChange(
    connections: GetConnectionsReturnType,
    prevConnections: GetConnectionsReturnType,
  ): void
}

export type WatchConnectionsReturnType = () => void

/** https://wagmi.sh/core/api/actions/watchConnections */
export function watchConnections(
  config: Config,
  parameters: WatchConnectionsParameters,
): WatchConnectionsReturnType {
  const { onChange } = parameters
  return config.subscribe(() => getConnections(config), onChange, {
    equalityFn: deepEqual,
  })
}
</file>

<file path="packages/core/src/actions/watchConnectors.ts">
import type { Config } from '../createConfig.js'
import type { GetConnectorsReturnType } from './getConnectors.js'

export type WatchConnectorsParameters<config extends Config = Config> = {
  onChange(
    connections: GetConnectorsReturnType<config>,
    prevConnectors: GetConnectorsReturnType<config>,
  ): void
}

export type WatchConnectorsReturnType = () => void

/** https://wagmi.sh/core/api/actions/watchConnectors */
export function watchConnectors<config extends Config>(
  config: config,
  parameters: WatchConnectorsParameters<config>,
): WatchConnectorsReturnType {
  const { onChange } = parameters
  return config._internal.connectors.subscribe((connectors, prevConnectors) => {
    onChange(Object.values(connectors), prevConnectors)
  })
}
</file>

<file path="packages/core/src/actions/watchContractEvent.test-d.ts">
import { abi, config } from '@wagmi/test'
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type WatchContractEventParameters,
  watchContractEvent,
} from './watchContractEvent.js'

test('default', () => {
  watchContractEvent(config, {
    address: '0x',
    abi: abi.erc20,
    eventName: 'Transfer',
    args: {
      from: '0x',
      to: '0x',
    },
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<{
        from?: `0x${string}` | undefined
        to?: `0x${string}` | undefined
        value?: bigint | undefined
      }>()
    },
  })
})

test('behavior: no eventName', () => {
  type Result = WatchContractEventParameters<
    typeof abi.erc20,
    undefined,
    true,
    typeof config
  >
  expectTypeOf<Result['args']>().toEqualTypeOf<
    | {
        from?: `0x${string}` | `0x${string}`[] | null | undefined
        to?: `0x${string}` | `0x${string}`[] | null | undefined
      }
    | {
        owner?: `0x${string}` | `0x${string}`[] | null | undefined
        spender?: `0x${string}` | `0x${string}`[] | null | undefined
      }
    | undefined
  >()

  watchContractEvent(config, {
    address: '0x',
    abi: abi.erc20,
    args: {
      // TODO: Figure out why this is not working
      // @ts-ignore
      from: '0x',
      to: '0x',
    },
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer' | 'Approval'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<
        | Record<string, unknown>
        | readonly unknown[]
        | {
            from?: `0x${string}` | undefined
            to?: `0x${string}` | undefined
            value?: bigint | undefined
          }
        | {
            owner?: `0x${string}` | undefined
            spender?: `0x${string}` | undefined
            value?: bigint | undefined
          }
      >()
    },
  })
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = WatchContractEventParameters<
    typeof abi.erc20,
    'Transfer' | 'Approval',
    true,
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  watchContractEvent(config, {
    poll: false,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })

  type Result2 = WatchContractEventParameters<
    typeof abi.erc20,
    'Transfer' | 'Approval',
    true,
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  watchContractEvent(config, {
    chainId: mainnet.id,
    poll: true,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })

  type Result3 = WatchContractEventParameters<
    typeof abi.erc20,
    'Transfer' | 'Approval',
    true,
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  watchContractEvent(config, {
    chainId: optimism.id,
    poll: true,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })
  watchContractEvent(config, {
    chainId: optimism.id,
    poll: false,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })
})
</file>

<file path="packages/core/src/actions/watchContractEvent.ts">
import type {
  Abi,
  Chain,
  ContractEventName,
  Transport,
  WebSocketTransport,
} from 'viem'
import {
  type WatchContractEventParameters as viem_WatchContractEventParameters,
  type WatchContractEventReturnType as viem_WatchContractEventReturnType,
  watchContractEvent as viem_watchContractEvent,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  SyncConnectedChainParameter,
} from '../types/properties.js'
import type { UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type WatchContractEventParameters<
  abi extends Abi | readonly unknown[] = Abi,
  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,
  strict extends boolean | undefined = undefined,
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    viem_WatchContractEventParameters<
      abi,
      eventName,
      strict,
      config['_internal']['transports'][chains[key]['id']] extends infer transport extends
        Transport
        ? Transport extends transport
          ? WebSocketTransport
          : transport
        : WebSocketTransport
    > &
      ChainIdParameter<config, chainId> &
      SyncConnectedChainParameter
  >
}[number]

export type WatchContractEventReturnType = viem_WatchContractEventReturnType

// TODO: wrap in viem's `observe` to avoid duplicate invocations.
/** https://wagmi.sh/core/api/actions/watchContractEvent */
export function watchContractEvent<
  config extends Config,
  chainId extends config['chains'][number]['id'],
  const abi extends Abi | readonly unknown[],
  eventName extends ContractEventName<abi> | undefined,
  strict extends boolean | undefined = undefined,
>(
  config: config,
  parameters: WatchContractEventParameters<
    abi,
    eventName,
    strict,
    config,
    chainId
  >,
) {
  const { syncConnectedChain = config._internal.syncConnectedChain, ...rest } =
    parameters

  let unwatch: WatchContractEventReturnType | undefined
  const listener = (chainId: number | undefined) => {
    if (unwatch) unwatch()

    const client = config.getClient({ chainId })
    const action = getAction(
      client,
      viem_watchContractEvent,
      'watchContractEvent',
    )
    unwatch = action(rest as unknown as viem_WatchContractEventParameters)
    return unwatch
  }

  // set up listener for transaction changes
  const unlisten = listener(parameters.chainId)

  // set up subscriber for connected chain changes
  let unsubscribe: (() => void) | undefined
  if (syncConnectedChain && !parameters.chainId)
    unsubscribe = config.subscribe(
      ({ chainId }) => chainId,
      async (chainId) => listener(chainId),
    )

  return () => {
    unlisten?.()
    unsubscribe?.()
  }
}
</file>

<file path="packages/core/src/actions/watchPendingTransactions.test-d.ts">
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type WatchPendingTransactionsParameters,
  watchPendingTransactions,
} from './watchPendingTransactions.js'

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = WatchPendingTransactionsParameters<
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  watchPendingTransactions(config, {
    poll: false,
    onTransactions() {},
  })

  type Result2 = WatchPendingTransactionsParameters<
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  watchPendingTransactions(config, {
    chainId: mainnet.id,
    poll: true,
    onTransactions() {},
  })

  type Result3 = WatchPendingTransactionsParameters<
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  watchPendingTransactions(config, {
    chainId: optimism.id,
    poll: true,
    onTransactions() {},
  })
  watchPendingTransactions(config, {
    chainId: optimism.id,
    poll: false,
    onTransactions() {},
  })
})
</file>

<file path="packages/core/src/actions/watchPendingTransactions.ts">
import type { Chain, Transport, WebSocketTransport } from 'viem'
import {
  type WatchPendingTransactionsParameters as viem_WatchPendingTransactionsParameters,
  type WatchPendingTransactionsReturnType as viem_WatchPendingTransactionsReturnType,
  watchPendingTransactions as viem_watchPendingTransactions,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  SyncConnectedChainParameter,
} from '../types/properties.js'
import type { UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'

export type WatchPendingTransactionsParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: UnionCompute<
    viem_WatchPendingTransactionsParameters<
      config['_internal']['transports'][chains[key]['id']] extends infer transport extends
        Transport
        ? Transport extends transport
          ? WebSocketTransport
          : transport
        : WebSocketTransport
    > &
      ChainIdParameter<config, chainId> &
      SyncConnectedChainParameter
  >
}[number]

export type WatchPendingTransactionsReturnType =
  viem_WatchPendingTransactionsReturnType

// TODO: wrap in viem's `observe` to avoid duplicate invocations.
/** https://wagmi.sh/core/api/actions/watchPendingTransactions */
export function watchPendingTransactions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: WatchPendingTransactionsParameters<config, chainId>,
) {
  const { syncConnectedChain = config._internal.syncConnectedChain, ...rest } =
    parameters

  let unwatch: WatchPendingTransactionsReturnType | undefined
  const listener = (chainId: number | undefined) => {
    if (unwatch) unwatch()

    const client = config.getClient({ chainId })
    const action = getAction(
      client,
      viem_watchPendingTransactions,
      'watchPendingTransactions',
    )
    unwatch = action(rest as viem_WatchPendingTransactionsParameters)
    return unwatch
  }

  // set up listener for transaction changes
  const unlisten = listener(parameters.chainId)

  // set up subscriber for connected chain changes
  let unsubscribe: (() => void) | undefined
  if (syncConnectedChain && !parameters.chainId)
    unsubscribe = config.subscribe(
      ({ chainId }) => chainId,
      async (chainId) => listener(chainId),
    )

  return () => {
    unlisten?.()
    unsubscribe?.()
  }
}
</file>

<file path="packages/core/src/actions/watchPublicClient.test-d.ts">
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { watchPublicClient } from './watchPublicClient.js'

test('default', () => {
  watchPublicClient(config, {
    onChange(client) {
      expectTypeOf(client.chain).toEqualTypeOf<
        (typeof config)['chains'][number]
      >()
      expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
    },
  })
})
</file>

<file path="packages/core/src/actions/watchPublicClient.ts">
import type { Config } from '../createConfig.js'
import {
  type GetPublicClientReturnType,
  getPublicClient,
} from './getPublicClient.js'

export type WatchPublicClientParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = {
  onChange(
    publicClient: GetPublicClientReturnType<config, chainId>,
    prevPublicClient: GetPublicClientReturnType<config, chainId>,
  ): void
}

export type WatchPublicClientReturnType = () => void

/** https://wagmi.sh/core/api/actions/watchPublicClient */
export function watchPublicClient<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: WatchPublicClientParameters<config, chainId>,
): WatchPublicClientReturnType {
  const { onChange } = parameters
  return config.subscribe(
    () => getPublicClient(config) as GetPublicClientReturnType<config, chainId>,
    onChange,
    {
      equalityFn(a, b) {
        return a?.uid === b?.uid
      },
    },
  )
}
</file>

<file path="packages/core/src/actions/writeContract.test-d.ts">
import { abi, config } from '@wagmi/test'
import { http, type Address, parseAbi } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import { simulateContract } from './simulateContract.js'
import { type WriteContractParameters, writeContract } from './writeContract.js'

test('default', async () => {
  await writeContract(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })
})

test('simulateContract', async () => {
  const { request } = await simulateContract(config, {
    account: '0x',
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })
  await writeContract(config, request)
  await writeContract(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
  })
})

test('chain formatters', () => {
  const config = createConfig({
    chains: [mainnet, celo],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = WriteContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config
  >
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  writeContract(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    feeCurrency: '0x',
  })

  type Result2 = WriteContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    typeof celo.id
  >
  expectTypeOf<Result2>().toMatchTypeOf<{
    functionName: 'approve' | 'transfer' | 'transferFrom'
    args: readonly [Address, Address, bigint]
    feeCurrency?: `0x${string}` | undefined
  }>()
  writeContract(config, {
    chainId: celo.id,
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    feeCurrency: '0x',
  })

  type Result3 = WriteContractParameters<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result3>().toMatchTypeOf<{
    functionName: 'approve' | 'transfer' | 'transferFrom'
    args: readonly [Address, Address, bigint]
  }>()
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  writeContract(config, {
    chainId: mainnet.id,
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error
    feeCurrency: '0x',
  })
})

test('overloads', async () => {
  const abi = parseAbi([
    'function foo() returns (int8)',
    'function foo(address) returns (string)',
    'function foo(address, address) returns ((address foo, address bar))',
    'function bar(uint256) returns (int8)',
  ])

  type Result = WriteContractParameters<typeof abi, 'foo'>
  expectTypeOf<Result['functionName']>().toEqualTypeOf<'foo' | 'bar'>()
  expectTypeOf<Result['args']>().toEqualTypeOf<
    | readonly []
    | readonly [`0x${string}`]
    | readonly [`0x${string}`, `0x${string}`]
    | undefined
  >()
  writeContract(config, {
    address: '0x',
    abi,
    functionName: 'foo',
  })
  writeContract(config, {
    address: '0x',
    abi,
    functionName: 'foo',
    args: ['0x'],
  })
  writeContract(config, {
    address: '0x',
    abi,
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  writeContract(config, {
    address: '0x',
    abi,
    functionName: 'foo',
    // @ts-expect-error
    args: ['0x', 123n],
  })

  type Result2 = WriteContractParameters<typeof abi, 'bar'>
  expectTypeOf<Result2['functionName']>().toEqualTypeOf<'foo' | 'bar'>()
  expectTypeOf<Result2['args']>().toEqualTypeOf<readonly [bigint]>()
})
</file>

<file path="packages/core/src/actions/writeContract.ts">
import type {
  Abi,
  Account,
  Chain,
  Client,
  ContractFunctionArgs,
  ContractFunctionName,
} from 'viem'
import {
  type WriteContractErrorType as viem_WriteContractErrorType,
  type WriteContractParameters as viem_WriteContractParameters,
  type WriteContractReturnType as viem_WriteContractReturnType,
  writeContract as viem_writeContract,
} from 'viem/actions'

import type { Config } from '../createConfig.js'
import type { BaseErrorType, ErrorType } from '../errors/base.js'
import type { SelectChains } from '../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../types/properties.js'
import type { Compute, UnionCompute } from '../types/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from './getConnectorClient.js'

export type WriteContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'nonpayable' | 'payable'
  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = UnionCompute<
  {
    // TODO: Should use `UnionStrictOmit<..., 'chain'>` on `viem_WriteContractParameters` result instead
    // temp workaround that doesn't affect runtime behavior for for https://github.com/wevm/wagmi/issues/3981
    [key in keyof chains]: viem_WriteContractParameters<
      abi,
      functionName,
      args,
      chains[key],
      Account,
      chains[key],
      allFunctionNames
    >
  }[number] &
    Compute<ChainIdParameter<config, chainId>> &
    ConnectorParameter & {
      /** @deprecated */
      __mode?: 'prepared'
    }
>

export type WriteContractReturnType = viem_WriteContractReturnType

export type WriteContractErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_WriteContractErrorType

/** https://wagmi.sh/core/api/actions/writeContract */
export async function writeContract<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: WriteContractParameters<abi, functionName, args, config, chainId>,
): Promise<WriteContractReturnType> {
  const { account, chainId, connector, ...request } = parameters

  let client: Client
  if (typeof account === 'object' && account?.type === 'local')
    client = config.getClient({ chainId })
  else
    client = await getConnectorClient(config, {
      account: account ?? undefined,
      chainId,
      connector,
    })

  const action = getAction(client, viem_writeContract, 'writeContract')
  const hash = await action({
    ...(request as any),
    ...(account ? { account } : {}),
    chain: chainId ? { id: chainId } : null,
  })

  return hash
}
</file>

<file path="packages/core/src/connectors/createConnector.ts">
import type {
  AddEthereumChainParameter,
  Address,
  Chain,
  Client,
  ProviderConnectInfo,
  ProviderMessage,
} from 'viem'

import type { Transport } from '../createConfig.js'
import type { Emitter } from '../createEmitter.js'
import type { Storage } from '../createStorage.js'
import type { Compute, ExactPartial, StrictOmit } from '../types/utils.js'

export type ConnectorEventMap = {
  change: {
    accounts?: readonly Address[] | undefined
    chainId?: number | undefined
  }
  connect: { accounts: readonly Address[]; chainId: number }
  disconnect: never
  error: { error: Error }
  message: { type: string; data?: unknown | undefined }
}

export type CreateConnectorFn<
  provider = unknown,
  properties extends Record<string, unknown> = Record<string, unknown>,
  storageItem extends Record<string, unknown> = Record<string, unknown>,
> = (config: {
  chains: readonly [Chain, ...Chain[]]
  emitter: Emitter<ConnectorEventMap>
  storage?: Compute<Storage<storageItem>> | null | undefined
  transports?: Record<number, Transport> | undefined
}) => Compute<
  {
    readonly icon?: string | undefined
    readonly id: string
    readonly name: string
    readonly rdns?: string | readonly string[] | undefined
    /** @deprecated */
    readonly supportsSimulation?: boolean | undefined
    readonly type: string

    setup?(): Promise<void>
    connect(
      parameters?:
        | { chainId?: number | undefined; isReconnecting?: boolean | undefined }
        | undefined,
    ): Promise<{
      accounts: readonly Address[]
      chainId: number
    }>
    disconnect(): Promise<void>
    getAccounts(): Promise<readonly Address[]>
    getChainId(): Promise<number>
    getProvider(
      parameters?: { chainId?: number | undefined } | undefined,
    ): Promise<provider>
    getClient?(
      parameters?: { chainId?: number | undefined } | undefined,
    ): Promise<Client>
    isAuthorized(): Promise<boolean>
    switchChain?(
      parameters: Compute<{
        addEthereumChainParameter?:
          | ExactPartial<StrictOmit<AddEthereumChainParameter, 'chainId'>>
          | undefined
        chainId: number
      }>,
    ): Promise<Chain>

    onAccountsChanged(accounts: string[]): void
    onChainChanged(chainId: string): void
    onConnect?(connectInfo: ProviderConnectInfo): void
    onDisconnect(error?: Error | undefined): void
    onMessage?(message: ProviderMessage): void
  } & properties
>

export function createConnector<
  provider,
  properties extends Record<string, unknown> = Record<string, unknown>,
  storageItem extends Record<string, unknown> = Record<string, unknown>,
  ///
  createConnectorFn extends CreateConnectorFn<
    provider,
    properties,
    storageItem
  > = CreateConnectorFn<provider, properties, storageItem>,
>(createConnectorFn: createConnectorFn) {
  return createConnectorFn
}
</file>

<file path="packages/core/src/connectors/injected.ts">
import {
  type AddEthereumChainParameter,
  type Address,
  type EIP1193Provider,
  type ProviderConnectInfo,
  type ProviderRpcError,
  ResourceUnavailableRpcError,
  type RpcError,
  SwitchChainError,
  UserRejectedRequestError,
  getAddress,
  numberToHex,
  withRetry,
  withTimeout,
} from 'viem'

import type { Connector } from '../createConfig.js'
import { ChainNotConfiguredError } from '../errors/config.js'
import { ProviderNotFoundError } from '../errors/connector.js'
import type { Compute } from '../types/utils.js'
import { createConnector } from './createConnector.js'

export type InjectedParameters = {
  /**
   * Some injected providers do not support programmatic disconnect.
   * This flag simulates the disconnect behavior by keeping track of connection status in storage.
   * @default true
   */
  shimDisconnect?: boolean | undefined
  /**
   * [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target
   */
  target?: TargetId | Target | (() => Target | undefined) | undefined
  unstable_shimAsyncInject?: boolean | number | undefined
}

injected.type = 'injected' as const
export function injected(parameters: InjectedParameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters

  function getTarget(): Compute<Target & { id: string }> {
    const target = parameters.target
    if (typeof target === 'function') {
      const result = target()
      if (result) return result
    }

    if (typeof target === 'object') return target

    if (typeof target === 'string')
      return {
        ...(targetMap[target as keyof typeof targetMap] ?? {
          id: target,
          name: `${target[0]!.toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0]!.toUpperCase()}${target.slice(1)}`,
        }),
      }

    return {
      id: 'injected',
      name: 'Injected',
      provider(window) {
        return window?.ethereum
      },
    }
  }

  type Provider = WalletProvider | undefined
  type Properties = {
    onConnect(connectInfo: ProviderConnectInfo): void
  }
  type StorageItem = {
    [_ in 'injected.connected' | `${string}.disconnected`]: true
  }

  let accountsChanged: Connector['onAccountsChanged'] | undefined
  let chainChanged: Connector['onChainChanged'] | undefined
  let connect: Connector['onConnect'] | undefined
  let disconnect: Connector['onDisconnect'] | undefined

  return createConnector<Provider, Properties, StorageItem>((config) => ({
    get icon() {
      return getTarget().icon
    },
    get id() {
      return getTarget().id
    },
    get name() {
      return getTarget().name
    },
    /** @deprecated */
    get supportsSimulation() {
      return true
    },
    type: injected.type,
    async setup() {
      const provider = await this.getProvider()
      // Only start listening for events if `target` is set, otherwise `injected()` will also receive events
      if (provider?.on && parameters.target) {
        if (!connect) {
          connect = this.onConnect.bind(this)
          provider.on('connect', connect)
        }

        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).
        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged)
        }
      }
    },
    async connect({ chainId, isReconnecting } = {}) {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()

      let accounts: readonly Address[] = []
      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])
      else if (shimDisconnect) {
        // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled
        try {
          const permissions = await provider.request({
            method: 'wallet_requestPermissions',
            params: [{ eth_accounts: {} }],
          })
          accounts = (permissions[0]?.caveats?.[0]?.value as string[])?.map(
            (x) => getAddress(x),
          )
          // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`
          // switch to `'eth_accounts'` ordering if more than one account is connected
          // https://github.com/wevm/wagmi/issues/4140
          if (accounts.length > 0) {
            const sortedAccounts = await this.getAccounts()
            accounts = sortedAccounts
          }
        } catch (err) {
          const error = err as RpcError
          // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).
          // Only bubble up error if user rejects request
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error)
          // Or prompt is already open
          if (error.code === ResourceUnavailableRpcError.code) throw error
        }
      }

      try {
        if (!accounts?.length && !isReconnecting) {
          const requestedAccounts = await provider.request({
            method: 'eth_requestAccounts',
          })
          accounts = requestedAccounts.map((x) => getAddress(x))
        }

        // Manage EIP-1193 event listeners
        // https://eips.ethereum.org/EIPS/eip-1193#events
        if (connect) {
          provider.removeListener('connect', connect)
          connect = undefined
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged)
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this)
          provider.on('chainChanged', chainChanged)
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this)
          provider.on('disconnect', disconnect)
        }

        // Switch to chain if provided
        let currentChainId = await this.getChainId()
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain!({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code) throw error
            return { id: currentChainId }
          })
          currentChainId = chain?.id ?? currentChainId
        }

        // Remove disconnected shim if it exists
        if (shimDisconnect)
          await config.storage?.removeItem(`${this.id}.disconnected`)

        // Add connected shim if no target exists
        if (!parameters.target)
          await config.storage?.setItem('injected.connected', true)

        return { accounts, chainId: currentChainId }
      } catch (err) {
        const error = err as RpcError
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error)
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error)
        throw error
      }
    },
    async disconnect() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()

      // Manage EIP-1193 event listeners
      if (chainChanged) {
        provider.removeListener('chainChanged', chainChanged)
        chainChanged = undefined
      }
      if (disconnect) {
        provider.removeListener('disconnect', disconnect)
        disconnect = undefined
      }
      if (!connect) {
        connect = this.onConnect.bind(this)
        provider.on('connect', connect)
      }

      // Experimental support for MetaMask disconnect
      // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md
      try {
        // Adding timeout as not all wallets support this method and can hang
        // https://github.com/wevm/wagmi/issues/4064
        await withTimeout(
          () =>
            // TODO: Remove explicit type for viem@3
            provider.request<{
              Method: 'wallet_revokePermissions'
              Parameters: [permissions: { eth_accounts: Record<string, any> }]
              ReturnType: null
            }>({
              // `'wallet_revokePermissions'` added in `viem@2.10.3`
              method: 'wallet_revokePermissions',
              params: [{ eth_accounts: {} }],
            }),
          { timeout: 100 },
        )
      } catch {}

      // Add shim signalling connector is disconnected
      if (shimDisconnect) {
        await config.storage?.setItem(`${this.id}.disconnected`, true)
      }

      if (!parameters.target)
        await config.storage?.removeItem('injected.connected')
    },
    async getAccounts() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()
      const accounts = await provider.request({ method: 'eth_accounts' })
      return accounts.map((x) => getAddress(x))
    },
    async getChainId() {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()
      const hexChainId = await provider.request({ method: 'eth_chainId' })
      return Number(hexChainId)
    },
    async getProvider() {
      if (typeof window === 'undefined') return undefined

      let provider: Provider
      const target = getTarget()
      if (typeof target.provider === 'function')
        provider = target.provider(window as Window | undefined)
      else if (typeof target.provider === 'string')
        provider = findProvider(window, target.provider)
      else provider = target.provider

      // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)
      // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002
      if (provider && !provider.removeListener) {
        // Try using `off` handler if it exists, otherwise noop
        if ('off' in provider && typeof provider.off === 'function')
          provider.removeListener =
            provider.off as typeof provider.removeListener
        else provider.removeListener = () => {}
      }

      return provider
    },
    async isAuthorized() {
      try {
        const isDisconnected =
          shimDisconnect &&
          // If shim exists in storage, connector is disconnected
          (await config.storage?.getItem(`${this.id}.disconnected`))
        if (isDisconnected) return false

        // Don't allow injected connector to connect if no target is set and it hasn't already connected
        // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting
        // automatically whenever there is a targeted connector configured.
        if (!parameters.target) {
          const connected = await config.storage?.getItem('injected.connected')
          if (!connected) return false
        }

        const provider = await this.getProvider()
        if (!provider) {
          if (
            unstable_shimAsyncInject !== undefined &&
            unstable_shimAsyncInject !== false
          ) {
            // If no provider is found, check for async injection
            // https://github.com/wevm/references/issues/167
            // https://github.com/MetaMask/detect-provider
            const handleEthereum = async () => {
              if (typeof window !== 'undefined')
                window.removeEventListener(
                  'ethereum#initialized',
                  handleEthereum,
                )
              const provider = await this.getProvider()
              return !!provider
            }
            const timeout =
              typeof unstable_shimAsyncInject === 'number'
                ? unstable_shimAsyncInject
                : 1_000
            const res = await Promise.race([
              ...(typeof window !== 'undefined'
                ? [
                    new Promise<boolean>((resolve) =>
                      window.addEventListener(
                        'ethereum#initialized',
                        () => resolve(handleEthereum()),
                        { once: true },
                      ),
                    ),
                  ]
                : []),
              new Promise<boolean>((resolve) =>
                setTimeout(() => resolve(handleEthereum()), timeout),
              ),
            ])
            if (res) return true
          }

          throw new ProviderNotFoundError()
        }

        // Use retry strategy as some injected wallets (e.g. MetaMask) fail to
        // immediately resolve JSON-RPC requests on page load.
        const accounts = await withRetry(() => this.getAccounts())
        return !!accounts.length
      } catch {
        return false
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider()
      if (!provider) throw new ProviderNotFoundError()

      const chain = config.chains.find((x) => x.id === chainId)
      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())

      const promise = new Promise<void>((resolve) => {
        const listener = ((data) => {
          if ('chainId' in data && data.chainId === chainId) {
            config.emitter.off('change', listener)
            resolve()
          }
        }) satisfies Parameters<typeof config.emitter.on>[1]
        config.emitter.on('change', listener)
      })

      try {
        await Promise.all([
          provider
            .request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: numberToHex(chainId) }],
            })
            // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.
            // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.
            // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via
            // this callback or an externally emitted `'chainChanged'` event.
            // https://github.com/MetaMask/metamask-extension/issues/24247
            .then(async () => {
              const currentChainId = await this.getChainId()
              if (currentChainId === chainId)
                config.emitter.emit('change', { chainId })
            }),
          promise,
        ])
        return chain
      } catch (err) {
        const error = err as RpcError

        // Indicates chain is not added to provider
        if (
          error.code === 4902 ||
          // Unwrapping for MetaMask Mobile
          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
          (error as ProviderRpcError<{ originalError?: { code: number } }>)
            ?.data?.originalError?.code === 4902
        ) {
          try {
            const { default: blockExplorer, ...blockExplorers } =
              chain.blockExplorers ?? {}
            let blockExplorerUrls: string[] | undefined
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x) => x.url),
              ]

            let rpcUrls: readonly string[]
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls
            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']

            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency:
                addEthereumChainParameter?.nativeCurrency ??
                chain.nativeCurrency,
              rpcUrls,
            } satisfies AddEthereumChainParameter

            await Promise.all([
              provider
                .request({
                  method: 'wallet_addEthereumChain',
                  params: [addEthereumChain],
                })
                .then(async () => {
                  const currentChainId = await this.getChainId()
                  if (currentChainId === chainId)
                    config.emitter.emit('change', { chainId })
                  else
                    throw new UserRejectedRequestError(
                      new Error('User rejected switch after adding network.'),
                    )
                }),
              promise,
            ])

            return chain
          } catch (error) {
            throw new UserRejectedRequestError(error as Error)
          }
        }

        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error)
        throw new SwitchChainError(error)
      }
    },
    async onAccountsChanged(accounts) {
      // Disconnect if there are no accounts
      if (accounts.length === 0) this.onDisconnect()
      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)
      else if (config.emitter.listenerCount('connect')) {
        const chainId = (await this.getChainId()).toString()
        this.onConnect({ chainId })
        // Remove disconnected shim if it exists
        if (shimDisconnect)
          await config.storage?.removeItem(`${this.id}.disconnected`)
      }
      // Regular change event
      else
        config.emitter.emit('change', {
          accounts: accounts.map((x) => getAddress(x)),
        })
    },
    onChainChanged(chain) {
      const chainId = Number(chain)
      config.emitter.emit('change', { chainId })
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts()
      if (accounts.length === 0) return

      const chainId = Number(connectInfo.chainId)
      config.emitter.emit('connect', { accounts, chainId })

      // Manage EIP-1193 event listeners
      const provider = await this.getProvider()
      if (provider) {
        if (connect) {
          provider.removeListener('connect', connect)
          connect = undefined
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this)
          provider.on('accountsChanged', accountsChanged)
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this)
          provider.on('chainChanged', chainChanged)
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this)
          provider.on('disconnect', disconnect)
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider()

      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
      // https://github.com/MetaMask/providers/pull/120
      if (error && (error as RpcError<1013>).code === 1013) {
        if (provider && !!(await this.getAccounts()).length) return
      }

      // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
      // actually disconnected and we don't need to simulate it.
      config.emitter.emit('disconnect')

      // Manage EIP-1193 event listeners
      if (provider) {
        if (chainChanged) {
          provider.removeListener('chainChanged', chainChanged)
          chainChanged = undefined
        }
        if (disconnect) {
          provider.removeListener('disconnect', disconnect)
          disconnect = undefined
        }
        if (!connect) {
          connect = this.onConnect.bind(this)
          provider.on('connect', connect)
        }
      }
    },
  }))
}

const targetMap = {
  coinbaseWallet: {
    id: 'coinbaseWallet',
    name: 'Coinbase Wallet',
    provider(window) {
      if (window?.coinbaseWalletExtension) return window.coinbaseWalletExtension
      return findProvider(window, 'isCoinbaseWallet')
    },
  },
  metaMask: {
    id: 'metaMask',
    name: 'MetaMask',
    provider(window) {
      return findProvider(window, (provider) => {
        if (!provider.isMetaMask) return false
        // Brave tries to make itself look like MetaMask
        // Could also try RPC `web3_clientVersion` if following is unreliable
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false
        // Other wallets that try to look like MetaMask
        const flags = [
          'isApexWallet',
          'isAvalanche',
          'isBitKeep',
          'isBlockWallet',
          'isKuCoinWallet',
          'isMathWallet',
          'isOkxWallet',
          'isOKExWallet',
          'isOneInchIOSWallet',
          'isOneInchAndroidWallet',
          'isOpera',
          'isPhantom',
          'isPortal',
          'isRabby',
          'isTokenPocket',
          'isTokenary',
          'isUniswapWallet',
          'isZerion',
        ] satisfies WalletProviderFlags[]
        for (const flag of flags) if (provider[flag]) return false
        return true
      })
    },
  },
  phantom: {
    id: 'phantom',
    name: 'Phantom',
    provider(window) {
      if (window?.phantom?.ethereum) return window.phantom?.ethereum
      return findProvider(window, 'isPhantom')
    },
  },
} as const satisfies TargetMap

type TargetMap = { [_ in TargetId]?: Target | undefined }

type Target = {
  icon?: string | undefined
  id: string
  name: string
  provider:
    | WalletProviderFlags
    | WalletProvider
    | ((window?: Window | undefined) => WalletProvider | undefined)
}

/** @deprecated */
type TargetId = Compute<WalletProviderFlags> extends `is${infer name}`
  ? name extends `${infer char}${infer rest}`
    ? `${Lowercase<char>}${rest}`
    : never
  : never

/**
 * @deprecated As of 2024/10/16, we are no longer accepting new provider flags as EIP-6963 should be used instead.
 */
type WalletProviderFlags =
  | 'isApexWallet'
  | 'isAvalanche'
  | 'isBackpack'
  | 'isBifrost'
  | 'isBitKeep'
  | 'isBitski'
  | 'isBlockWallet'
  | 'isBraveWallet'
  | 'isCoinbaseWallet'
  | 'isDawn'
  | 'isEnkrypt'
  | 'isExodus'
  | 'isFrame'
  | 'isFrontier'
  | 'isGamestop'
  | 'isHyperPay'
  | 'isImToken'
  | 'isKuCoinWallet'
  | 'isMathWallet'
  | 'isMetaMask'
  | 'isOkxWallet'
  | 'isOKExWallet'
  | 'isOneInchAndroidWallet'
  | 'isOneInchIOSWallet'
  | 'isOpera'
  | 'isPhantom'
  | 'isPortal'
  | 'isRabby'
  | 'isRainbow'
  | 'isStatus'
  | 'isTally'
  | 'isTokenPocket'
  | 'isTokenary'
  | 'isTrust'
  | 'isTrustWallet'
  | 'isUniswapWallet'
  | 'isXDEFI'
  | 'isZerion'

type WalletProvider = Compute<
  EIP1193Provider & {
    [key in WalletProviderFlags]?: true | undefined
  } & {
    providers?: WalletProvider[] | undefined
    /** Only exists in MetaMask as of 2022/04/03 */
    _events?: { connect?: (() => void) | undefined } | undefined
    /** Only exists in MetaMask as of 2022/04/03 */
    _state?:
      | {
          accounts?: string[]
          initialized?: boolean
          isConnected?: boolean
          isPermanentlyDisconnected?: boolean
          isUnlocked?: boolean
        }
      | undefined
  }
>

type Window = {
  coinbaseWalletExtension?: WalletProvider | undefined
  ethereum?: WalletProvider | undefined
  phantom?: { ethereum: WalletProvider } | undefined
}

function findProvider(
  window: globalThis.Window | Window | undefined,
  select?: WalletProviderFlags | ((provider: WalletProvider) => boolean),
) {
  function isProvider(provider: WalletProvider) {
    if (typeof select === 'function') return select(provider)
    if (typeof select === 'string') return provider[select]
    return true
  }

  const ethereum = (window as Window).ethereum
  if (ethereum?.providers)
    return ethereum.providers.find((provider) => isProvider(provider))
  if (ethereum && isProvider(ethereum)) return ethereum
  return undefined
}
</file>

<file path="packages/core/src/connectors/mock.ts">
import {
  type Address,
  type EIP1193RequestFn,
  type Hex,
  RpcRequestError,
  SwitchChainError,
  type Transport,
  UserRejectedRequestError,
  type WalletCallReceipt,
  type WalletGetCallsStatusReturnType,
  type WalletRpcSchema,
  custom,
  fromHex,
  getAddress,
  keccak256,
  numberToHex,
  stringToHex,
} from 'viem'
import { rpc } from 'viem/utils'

import {
  ChainNotConfiguredError,
  ConnectorNotConnectedError,
} from '../errors/config.js'
import { createConnector } from './createConnector.js'

export type MockParameters = {
  accounts: readonly [Address, ...Address[]]
  features?:
    | {
        defaultConnected?: boolean | undefined
        connectError?: boolean | Error | undefined
        switchChainError?: boolean | Error | undefined
        signMessageError?: boolean | Error | undefined
        signTypedDataError?: boolean | Error | undefined
        reconnect?: boolean | undefined
        watchAssetError?: boolean | Error | undefined
      }
    | undefined
}

mock.type = 'mock' as const
export function mock(parameters: MockParameters) {
  const transactionCache = new Map<Hex, Hex[]>()
  const features =
    parameters.features ??
    ({ defaultConnected: false } satisfies MockParameters['features'])

  type Provider = ReturnType<
    Transport<'custom', unknown, EIP1193RequestFn<WalletRpcSchema>>
  >
  type Properties = {
    connect(parameters?: {
      chainId?: number | undefined
      isReconnecting?: boolean | undefined
      foo?: string | undefined
    }): Promise<{
      accounts: readonly Address[]
      chainId: number
    }>
  }
  let connected = features.defaultConnected
  let connectedChainId: number

  return createConnector<Provider, Properties>((config) => ({
    id: 'mock',
    name: 'Mock Connector',
    type: mock.type,
    async setup() {
      connectedChainId = config.chains[0].id
    },
    async connect({ chainId } = {}) {
      if (features.connectError) {
        if (typeof features.connectError === 'boolean')
          throw new UserRejectedRequestError(new Error('Failed to connect.'))
        throw features.connectError
      }

      const provider = await this.getProvider()
      const accounts = await provider.request({
        method: 'eth_requestAccounts',
      })

      let currentChainId = await this.getChainId()
      if (chainId && currentChainId !== chainId) {
        const chain = await this.switchChain!({ chainId })
        currentChainId = chain.id
      }

      connected = true

      return {
        accounts: accounts.map((x) => getAddress(x)),
        chainId: currentChainId,
      }
    },
    async disconnect() {
      connected = false
    },
    async getAccounts() {
      if (!connected) throw new ConnectorNotConnectedError()
      const provider = await this.getProvider()
      const accounts = await provider.request({ method: 'eth_accounts' })
      return accounts.map((x) => getAddress(x))
    },
    async getChainId() {
      const provider = await this.getProvider()
      const hexChainId = await provider.request({ method: 'eth_chainId' })
      return fromHex(hexChainId, 'number')
    },
    async isAuthorized() {
      if (!features.reconnect) return false
      if (!connected) return false
      const accounts = await this.getAccounts()
      return !!accounts.length
    },
    async switchChain({ chainId }) {
      const provider = await this.getProvider()
      const chain = config.chains.find((x) => x.id === chainId)
      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())

      await provider.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: numberToHex(chainId) }],
      })
      return chain
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) this.onDisconnect()
      else
        config.emitter.emit('change', {
          accounts: accounts.map((x) => getAddress(x)),
        })
    },
    onChainChanged(chain) {
      const chainId = Number(chain)
      config.emitter.emit('change', { chainId })
    },
    async onDisconnect(_error) {
      config.emitter.emit('disconnect')
      connected = false
    },
    async getProvider({ chainId } = {}) {
      const chain =
        config.chains.find((x) => x.id === chainId) ?? config.chains[0]
      const url = chain.rpcUrls.default.http[0]!

      const request: EIP1193RequestFn = async ({ method, params }) => {
        // eth methods
        if (method === 'eth_chainId') return numberToHex(connectedChainId)
        if (method === 'eth_requestAccounts') return parameters.accounts
        if (method === 'eth_signTypedData_v4')
          if (features.signTypedDataError) {
            if (typeof features.signTypedDataError === 'boolean')
              throw new UserRejectedRequestError(
                new Error('Failed to sign typed data.'),
              )
            throw features.signTypedDataError
          }

        // wallet methods
        if (method === 'wallet_switchEthereumChain') {
          if (features.switchChainError) {
            if (typeof features.switchChainError === 'boolean')
              throw new UserRejectedRequestError(
                new Error('Failed to switch chain.'),
              )
            throw features.switchChainError
          }
          type Params = [{ chainId: Hex }]
          connectedChainId = fromHex((params as Params)[0].chainId, 'number')
          this.onChainChanged(connectedChainId.toString())
          return
        }

        if (method === 'wallet_watchAsset') {
          if (features.watchAssetError) {
            if (typeof features.watchAssetError === 'boolean')
              throw new UserRejectedRequestError(
                new Error('Failed to switch chain.'),
              )
            throw features.watchAssetError
          }
          return connected
        }

        if (method === 'wallet_getCapabilities')
          return {
            '0x2105': {
              paymasterService: {
                supported:
                  (params as [Hex])[0] ===
                  '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
              },
              sessionKeys: {
                supported: true,
              },
            },
            '0x14A34': {
              paymasterService: {
                supported:
                  (params as [Hex])[0] ===
                  '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
              },
            },
          }

        if (method === 'wallet_sendCalls') {
          const hashes = []
          const calls = (params as any)[0].calls
          for (const call of calls) {
            const { result, error } = await rpc.http(url, {
              body: {
                method: 'eth_sendTransaction',
                params: [call],
              },
            })
            if (error)
              throw new RpcRequestError({
                body: { method, params },
                error,
                url,
              })
            hashes.push(result)
          }
          const id = keccak256(stringToHex(JSON.stringify(calls)))
          transactionCache.set(id, hashes)
          return { id }
        }

        if (method === 'wallet_getCallsStatus') {
          const hashes = transactionCache.get((params as any)[0])
          if (!hashes)
            return {
              atomic: false,
              chainId: '0x1',
              id: (params as any)[0],
              status: 100,
              receipts: [],
              version: '2.0.0',
            } satisfies WalletGetCallsStatusReturnType

          const receipts = await Promise.all(
            hashes.map(async (hash) => {
              const { result, error } = await rpc.http(url, {
                body: {
                  method: 'eth_getTransactionReceipt',
                  params: [hash],
                  id: 0,
                },
              })
              if (error)
                throw new RpcRequestError({
                  body: { method, params },
                  error,
                  url,
                })
              if (!result) return null
              return {
                blockHash: result.blockHash,
                blockNumber: result.blockNumber,
                gasUsed: result.gasUsed,
                logs: result.logs,
                status: result.status,
                transactionHash: result.transactionHash,
              } satisfies WalletCallReceipt
            }),
          )
          const receipts_ = receipts.filter((x) => x !== null)
          if (receipts_.length === 0)
            return {
              atomic: false,
              chainId: '0x1',
              id: (params as any)[0],
              status: 100,
              receipts: [],
              version: '2.0.0',
            } satisfies WalletGetCallsStatusReturnType
          return {
            atomic: false,
            chainId: '0x1',
            id: (params as any)[0],
            status: 200,
            receipts: receipts_,
            version: '2.0.0',
          } satisfies WalletGetCallsStatusReturnType
        }

        if (method === 'wallet_showCallsStatus') return

        // other methods
        if (method === 'personal_sign') {
          if (features.signMessageError) {
            if (typeof features.signMessageError === 'boolean')
              throw new UserRejectedRequestError(
                new Error('Failed to sign message.'),
              )
            throw features.signMessageError
          }
          // Change `personal_sign` to `eth_sign` and swap params
          method = 'eth_sign'
          type Params = [data: Hex, address: Address]
          params = [(params as Params)[1], (params as Params)[0]]
        }

        const body = { method, params }
        const { error, result } = await rpc.http(url, { body })
        if (error) throw new RpcRequestError({ body, error, url })

        return result
      }
      return custom({ request })({ retryCount: 0 })
    },
  }))
}
</file>

<file path="packages/core/src/errors/base.ts">
import type { Compute, OneOf } from '../types/utils.js'
import { getVersion } from '../utils/getVersion.js'

export type ErrorType<name extends string = 'Error'> = Error & { name: name }

type BaseErrorOptions = Compute<
  OneOf<{ details?: string | undefined } | { cause: BaseError | Error }> & {
    docsPath?: string | undefined
    docsSlug?: string | undefined
    metaMessages?: string[] | undefined
  }
>

export type BaseErrorType = BaseError & { name: 'WagmiCoreError' }
export class BaseError extends Error {
  details: string
  docsPath?: string | undefined
  metaMessages?: string[] | undefined
  shortMessage: string

  override name = 'WagmiCoreError'
  get docsBaseUrl() {
    return 'https://wagmi.sh/core'
  }
  get version() {
    return getVersion()
  }

  constructor(shortMessage: string, options: BaseErrorOptions = {}) {
    super()

    const details =
      options.cause instanceof BaseError
        ? options.cause.details
        : options.cause?.message
          ? options.cause.message
          : options.details!
    const docsPath =
      options.cause instanceof BaseError
        ? options.cause.docsPath || options.docsPath
        : options.docsPath

    this.message = [
      shortMessage || 'An error occurred.',
      '',
      ...(options.metaMessages ? [...options.metaMessages, ''] : []),
      ...(docsPath
        ? [
            `Docs: ${this.docsBaseUrl}${docsPath}.html${
              options.docsSlug ? `#${options.docsSlug}` : ''
            }`,
          ]
        : []),
      ...(details ? [`Details: ${details}`] : []),
      `Version: ${this.version}`,
    ].join('\n')

    if (options.cause) this.cause = options.cause
    this.details = details
    this.docsPath = docsPath
    this.metaMessages = options.metaMessages
    this.shortMessage = shortMessage
  }

  walk(fn?: (err: unknown) => boolean) {
    return this.#walk(this, fn)
  }

  #walk(err: unknown, fn?: (err: unknown) => boolean): unknown {
    if (fn?.(err)) return err
    if ((err as Error).cause) return this.#walk((err as Error).cause, fn)
    return err
  }
}
</file>

<file path="packages/core/src/errors/config.ts">
import type { Address } from 'viem'

import type { Connector } from '../createConfig.js'
import { BaseError } from './base.js'

export type ChainNotConfiguredErrorType = ChainNotConfiguredError & {
  name: 'ChainNotConfiguredError'
}
export class ChainNotConfiguredError extends BaseError {
  override name = 'ChainNotConfiguredError'
  constructor() {
    super('Chain not configured.')
  }
}

export type ConnectorAlreadyConnectedErrorType =
  ConnectorAlreadyConnectedError & {
    name: 'ConnectorAlreadyConnectedError'
  }
export class ConnectorAlreadyConnectedError extends BaseError {
  override name = 'ConnectorAlreadyConnectedError'
  constructor() {
    super('Connector already connected.')
  }
}

export type ConnectorNotConnectedErrorType = ConnectorNotConnectedError & {
  name: 'ConnectorNotConnectedError'
}
export class ConnectorNotConnectedError extends BaseError {
  override name = 'ConnectorNotConnectedError'
  constructor() {
    super('Connector not connected.')
  }
}

export type ConnectorNotFoundErrorType = ConnectorNotFoundError & {
  name: 'ConnectorNotFoundError'
}
export class ConnectorNotFoundError extends BaseError {
  override name = 'ConnectorNotFoundError'
  constructor() {
    super('Connector not found.')
  }
}

export type ConnectorAccountNotFoundErrorType =
  ConnectorAccountNotFoundError & {
    name: 'ConnectorAccountNotFoundError'
  }
export class ConnectorAccountNotFoundError extends BaseError {
  override name = 'ConnectorAccountNotFoundError'
  constructor({
    address,
    connector,
  }: {
    address: Address
    connector: Connector
  }) {
    super(`Account "${address}" not found for connector "${connector.name}".`)
  }
}

export type ConnectorChainMismatchErrorType = ConnectorAccountNotFoundError & {
  name: 'ConnectorChainMismatchError'
}
export class ConnectorChainMismatchError extends BaseError {
  override name = 'ConnectorChainMismatchError'
  constructor({
    connectionChainId,
    connectorChainId,
  }: {
    connectionChainId: number
    connectorChainId: number
  }) {
    super(
      `The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`,
      {
        metaMessages: [
          `Current Chain ID:  ${connectorChainId}`,
          `Expected Chain ID: ${connectionChainId}`,
        ],
      },
    )
  }
}

export type ConnectorUnavailableReconnectingErrorType =
  ConnectorUnavailableReconnectingError & {
    name: 'ConnectorUnavailableReconnectingError'
  }
export class ConnectorUnavailableReconnectingError extends BaseError {
  override name = 'ConnectorUnavailableReconnectingError'
  constructor({ connector }: { connector: { name: string } }) {
    super(`Connector "${connector.name}" unavailable while reconnecting.`, {
      details: [
        'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.',
        'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',
        'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.',
      ].join(' '),
    })
  }
}
</file>

<file path="packages/core/src/errors/connector.ts">
import type { Connector } from '../createConfig.js'
import { BaseError } from './base.js'

export type ProviderNotFoundErrorType = ProviderNotFoundError & {
  name: 'ProviderNotFoundError'
}
export class ProviderNotFoundError extends BaseError {
  override name = 'ProviderNotFoundError'
  constructor() {
    super('Provider not found.')
  }
}

export type SwitchChainNotSupportedErrorType = SwitchChainNotSupportedError & {
  name: 'SwitchChainNotSupportedError'
}
export class SwitchChainNotSupportedError extends BaseError {
  override name = 'SwitchChainNotSupportedError'

  constructor({ connector }: { connector: Connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`)
  }
}
</file>

<file path="packages/core/src/experimental/actions/writeContracts.ts">
import type { Account, Chain, ContractFunctionParameters } from 'viem'
import {
  type WriteContractsErrorType as viem_WriteContractsErrorType,
  type WriteContractsParameters as viem_WriteContractsParameters,
  type WriteContractsReturnType as viem_WriteContractsReturnType,
  writeContracts as viem_writeContracts,
} from 'viem/experimental'

import {
  type GetConnectorClientErrorType,
  getConnectorClient,
} from '../../actions/getConnectorClient.js'
import type { Config } from '../../createConfig.js'
import type { BaseErrorType, ErrorType } from '../../errors/base.js'
import type { SelectChains } from '../../types/chain.js'
import type {
  ChainIdParameter,
  ConnectorParameter,
} from '../../types/properties.js'
import type { Compute } from '../../types/utils.js'

export type WriteContractsParameters<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  ///
  chains extends readonly Chain[] = SelectChains<config, chainId>,
> = {
  [key in keyof chains]: Compute<
    Omit<
      viem_WriteContractsParameters<
        contracts,
        chains[key],
        Account,
        chains[key]
      >,
      'chain'
    > &
      ChainIdParameter<config, chainId> &
      ConnectorParameter
  >
}[number]

export type WriteContractsReturnType = viem_WriteContractsReturnType

export type WriteContractsErrorType =
  // getConnectorClient()
  | GetConnectorClientErrorType
  // base
  | BaseErrorType
  | ErrorType
  // viem
  | viem_WriteContractsErrorType

/** https://wagmi.sh/core/api/actions/writeContracts */
export async function writeContracts<
  const contracts extends readonly unknown[],
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  parameters: WriteContractsParameters<contracts, config, chainId>,
): Promise<WriteContractsReturnType> {
  const { account, chainId, connector, ...rest } = parameters

  const client = await getConnectorClient(config, {
    account,
    chainId,
    connector,
  })

  return viem_writeContracts(client, {
    ...(rest as any),
    ...(account ? { account } : {}),
    chain: chainId ? { id: chainId } : undefined,
  })
}
</file>

<file path="packages/core/src/experimental/query/writeContracts.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import type { Config } from '../../createConfig.js'
import type { Compute } from '../../types/utils.js'
import {
  type WriteContractsErrorType,
  type WriteContractsParameters,
  type WriteContractsReturnType,
  writeContracts,
} from '../actions/writeContracts.js'

export function writeContractsMutationOptions<
  const contracts extends readonly unknown[],
  config extends Config,
>(config: config) {
  return {
    mutationFn(variables) {
      return writeContracts(config, variables as any) as any
    },
    mutationKey: ['writeContracts'],
  } as const satisfies MutationOptions<
    WriteContractsData,
    WriteContractsErrorType,
    WriteContractsVariables<contracts, config, config['chains'][number]['id']>
  >
}

export type WriteContractsData = Compute<WriteContractsReturnType>

export type WriteContractsVariables<
  contracts extends readonly unknown[],
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = WriteContractsParameters<contracts, config, chainId>

export type WriteContractsMutate<
  contracts extends readonly unknown[],
  config extends Config,
  context = unknown,
> = <chainId extends config['chains'][number]['id']>(
  variables: WriteContractsVariables<contracts, config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          WriteContractsData,
          WriteContractsErrorType,
          Compute<WriteContractsVariables<contracts, config, chainId>>,
          context
        >
      >
    | undefined,
) => void

export type WriteContractsMutateAsync<
  contracts extends readonly unknown[],
  config extends Config,
  context = unknown,
> = <chainId extends config['chains'][number]['id']>(
  variables: WriteContractsVariables<contracts, config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          WriteContractsData,
          WriteContractsErrorType,
          Compute<WriteContractsVariables<contracts, config, chainId>>,
          context
        >
      >
    | undefined,
) => Promise<WriteContractsData>
</file>

<file path="packages/core/src/exports/actions.ts">
////////////////////////////////////////////////////////////////////////////////
// Actions
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type CallErrorType,
  type CallParameters,
  type CallReturnType,
  call,
} from '../actions/call.js'

export {
  type ConnectErrorType,
  type ConnectParameters,
  type ConnectReturnType,
  connect,
} from '../actions/connect.js'

export {
  type DeployContractErrorType,
  type DeployContractParameters,
  type DeployContractReturnType,
  deployContract,
} from '../actions/deployContract.js'

export {
  type DisconnectErrorType,
  type DisconnectParameters,
  type DisconnectReturnType,
  disconnect,
} from '../actions/disconnect.js'

export {
  type EstimateGasErrorType,
  type EstimateGasParameters,
  type EstimateGasReturnType,
  estimateGas,
} from '../actions/estimateGas.js'

export {
  type EstimateFeesPerGasErrorType,
  type EstimateFeesPerGasParameters,
  type EstimateFeesPerGasReturnType,
  estimateFeesPerGas,
} from '../actions/estimateFeesPerGas.js'

export {
  type EstimateMaxPriorityFeePerGasErrorType,
  type EstimateMaxPriorityFeePerGasParameters,
  type EstimateMaxPriorityFeePerGasReturnType,
  estimateMaxPriorityFeePerGas,
} from '../actions/estimateMaxPriorityFeePerGas.js'

export {
  type GetAccountReturnType,
  getAccount,
} from '../actions/getAccount.js'

export {
  type GetBalanceParameters,
  type GetBalanceReturnType,
  type GetBalanceErrorType,
  getBalance,
  /** @deprecated use `getBalance` instead */
  getBalance as fetchBalance,
} from '../actions/getBalance.js'

export {
  type GetBlockErrorType,
  type GetBlockParameters,
  type GetBlockReturnType,
  getBlock,
} from '../actions/getBlock.js'

export {
  type GetBlockNumberErrorType,
  type GetBlockNumberParameters,
  type GetBlockNumberReturnType,
  getBlockNumber,
  /** @deprecated use `getBlockNumber` instead */
  getBlockNumber as fetchBlockNumber,
} from '../actions/getBlockNumber.js'

export {
  type GetBlockTransactionCountErrorType,
  type GetBlockTransactionCountParameters,
  type GetBlockTransactionCountReturnType,
  getBlockTransactionCount,
} from '../actions/getBlockTransactionCount.js'

export {
  type GetBytecodeErrorType,
  type GetBytecodeParameters,
  type GetBytecodeReturnType,
  getBytecode,
} from '../actions/getBytecode.js'

export {
  type GetCallsStatusErrorType,
  type GetCallsStatusParameters,
  type GetCallsStatusReturnType,
  getCallsStatus,
} from '../actions/getCallsStatus.js'

export {
  type GetCapabilitiesErrorType,
  type GetCapabilitiesParameters,
  type GetCapabilitiesReturnType,
  getCapabilities,
} from '../actions/getCapabilities.js'

export {
  type GetChainIdReturnType,
  getChainId,
} from '../actions/getChainId.js'

export {
  type GetChainsReturnType,
  getChains,
} from '../actions/getChains.js'

export {
  type GetClientParameters,
  type GetClientReturnType,
  getClient,
} from '../actions/getClient.js'

export {
  type GetConnectionsReturnType,
  getConnections,
} from '../actions/getConnections.js'

export {
  type GetConnectorsReturnType,
  getConnectors,
} from '../actions/getConnectors.js'

export {
  type GetConnectorClientErrorType,
  type GetConnectorClientParameters,
  type GetConnectorClientReturnType,
  getConnectorClient,
} from '../actions/getConnectorClient.js'

export {
  type GetEnsAddressErrorType,
  type GetEnsAddressParameters,
  type GetEnsAddressReturnType,
  getEnsAddress,
  /** @deprecated use `getEnsAddress` instead */
  getEnsAddress as fetchEnsAddress,
} from '../actions/getEnsAddress.js'

export {
  type GetEnsAvatarErrorType,
  type GetEnsAvatarParameters,
  type GetEnsAvatarReturnType,
  getEnsAvatar,
  /** @deprecated use `getEnsAvatar` instead */
  getEnsAvatar as fetchEnsAvatar,
} from '../actions/getEnsAvatar.js'

export {
  type GetEnsNameErrorType,
  type GetEnsNameParameters,
  type GetEnsNameReturnType,
  getEnsName,
  /** @deprecated */
  getEnsName as fetchEnsName,
} from '../actions/getEnsName.js'

export {
  type GetEnsResolverErrorType,
  type GetEnsResolverParameters,
  type GetEnsResolverReturnType,
  getEnsResolver,
  /** @deprecated use `getEnsResolver` instead */
  getEnsResolver as fetchEnsResolver,
} from '../actions/getEnsResolver.js'

export {
  type GetEnsTextErrorType,
  type GetEnsTextParameters,
  type GetEnsTextReturnType,
  getEnsText,
} from '../actions/getEnsText.js'

export {
  type GetFeeHistoryErrorType,
  type GetFeeHistoryParameters,
  type GetFeeHistoryReturnType,
  getFeeHistory,
} from '../actions/getFeeHistory.js'

export {
  type GetGasPriceErrorType,
  type GetGasPriceParameters,
  type GetGasPriceReturnType,
  getGasPrice,
} from '../actions/getGasPrice.js'

export {
  type GetProofErrorType,
  type GetProofParameters,
  type GetProofReturnType,
  getProof,
} from '../actions/getProof.js'

export {
  type GetPublicClientParameters,
  type GetPublicClientReturnType,
  getPublicClient,
} from '../actions/getPublicClient.js'

export {
  type GetStorageAtErrorType,
  type GetStorageAtParameters,
  type GetStorageAtReturnType,
  getStorageAt,
} from '../actions/getStorageAt.js'

export {
  type GetTokenErrorType,
  type GetTokenParameters,
  type GetTokenReturnType,
  getToken,
  /** @deprecated use `getToken` instead */
  getToken as fetchToken,
} from '../actions/getToken.js'

export {
  type GetTransactionErrorType,
  type GetTransactionParameters,
  type GetTransactionReturnType,
  getTransaction,
  /** @deprecated use `getTransaction` instead */
  getTransaction as fetchTransaction,
} from '../actions/getTransaction.js'

export {
  type GetTransactionConfirmationsErrorType,
  type GetTransactionConfirmationsParameters,
  type GetTransactionConfirmationsReturnType,
  getTransactionConfirmations,
} from '../actions/getTransactionConfirmations.js'

export {
  type GetTransactionCountErrorType,
  type GetTransactionCountParameters,
  type GetTransactionCountReturnType,
  getTransactionCount,
} from '../actions/getTransactionCount.js'

export {
  type GetTransactionReceiptErrorType,
  type GetTransactionReceiptParameters,
  type GetTransactionReceiptReturnType,
  getTransactionReceipt,
} from '../actions/getTransactionReceipt.js'

export {
  type GetWalletClientErrorType,
  type GetWalletClientParameters,
  type GetWalletClientReturnType,
  getWalletClient,
} from '../actions/getWalletClient.js'

export {
  type MulticallParameters,
  type MulticallReturnType,
  multicall,
} from '../actions/multicall.js'

export {
  type PrepareTransactionRequestParameters,
  type PrepareTransactionRequestReturnType,
  type PrepareTransactionRequestErrorType,
  prepareTransactionRequest,
} from '../actions/prepareTransactionRequest.js'

export {
  type ReadContractParameters,
  type ReadContractReturnType,
  type ReadContractErrorType,
  readContract,
} from '../actions/readContract.js'

export {
  type ReadContractsParameters,
  type ReadContractsReturnType,
  type ReadContractsErrorType,
  readContracts,
} from '../actions/readContracts.js'

export {
  type ReconnectErrorType,
  type ReconnectParameters,
  type ReconnectReturnType,
  reconnect,
} from '../actions/reconnect.js'

export {
  type SendCallsErrorType,
  type SendCallsParameters,
  type SendCallsReturnType,
  sendCalls,
} from '../actions/sendCalls.js'

export {
  type SendTransactionErrorType,
  type SendTransactionParameters,
  type SendTransactionReturnType,
  sendTransaction,
} from '../actions/sendTransaction.js'

export {
  type ShowCallsStatusErrorType,
  type ShowCallsStatusParameters,
  type ShowCallsStatusReturnType,
  showCallsStatus,
} from '../actions/showCallsStatus.js'

export {
  type SignMessageErrorType,
  type SignMessageParameters,
  type SignMessageReturnType,
  signMessage,
} from '../actions/signMessage.js'

export {
  type SignTypedDataErrorType,
  type SignTypedDataParameters,
  type SignTypedDataReturnType,
  signTypedData,
} from '../actions/signTypedData.js'

export {
  type SimulateContractErrorType,
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from '../actions/simulateContract.js'

export {
  type SwitchAccountErrorType,
  type SwitchAccountParameters,
  type SwitchAccountReturnType,
  switchAccount,
} from '../actions/switchAccount.js'

export {
  type SwitchChainErrorType,
  type SwitchChainParameters,
  type SwitchChainReturnType,
  switchChain,
  /** @deprecated use `switchChain` instead */
  switchChain as switchNetwork,
} from '../actions/switchChain.js'

export {
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from '../actions/verifyMessage.js'

export {
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from '../actions/verifyTypedData.js'

export {
  type WaitForCallsStatusErrorType,
  type WaitForCallsStatusParameters,
  type WaitForCallsStatusReturnType,
  waitForCallsStatus,
} from '../actions/waitForCallsStatus.js'

export {
  type WatchAccountParameters,
  type WatchAccountReturnType,
  watchAccount,
} from '../actions/watchAccount.js'

export {
  type WatchAssetParameters,
  type WatchAssetReturnType,
  watchAsset,
} from '../actions/watchAsset.js'

export {
  type WatchBlocksParameters,
  type WatchBlocksReturnType,
  watchBlocks,
} from '../actions/watchBlocks.js'

export {
  type WatchBlockNumberParameters,
  type WatchBlockNumberReturnType,
  watchBlockNumber,
} from '../actions/watchBlockNumber.js'

export {
  type WatchChainIdParameters,
  type WatchChainIdReturnType,
  watchChainId,
} from '../actions/watchChainId.js'

export {
  type WatchClientParameters,
  type WatchClientReturnType,
  watchClient,
} from '../actions/watchClient.js'

export {
  type WatchConnectionsParameters,
  type WatchConnectionsReturnType,
  watchConnections,
} from '../actions/watchConnections.js'

export {
  type WatchConnectorsParameters,
  type WatchConnectorsReturnType,
  watchConnectors,
} from '../actions/watchConnectors.js'

export {
  type WatchContractEventParameters,
  type WatchContractEventReturnType,
  watchContractEvent,
} from '../actions/watchContractEvent.js'

export {
  type WatchPendingTransactionsParameters,
  type WatchPendingTransactionsReturnType,
  watchPendingTransactions,
} from '../actions/watchPendingTransactions.js'

export {
  type WatchPublicClientParameters,
  type WatchPublicClientReturnType,
  watchPublicClient,
} from '../actions/watchPublicClient.js'

export {
  type WaitForTransactionReceiptErrorType,
  type WaitForTransactionReceiptParameters,
  type WaitForTransactionReceiptReturnType,
  waitForTransactionReceipt,
  /** @deprecated use `waitForTransactionReceipt` instead */
  waitForTransactionReceipt as waitForTransaction,
} from '../actions/waitForTransactionReceipt.js'

export {
  type WriteContractErrorType,
  type WriteContractParameters,
  type WriteContractReturnType,
  writeContract,
} from '../actions/writeContract.js'
</file>

<file path="packages/core/src/exports/chains.ts">
////////////////////////////////////////////////////////////////////////////////
// viem/chains
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from 'viem/chains'
</file>

<file path="packages/core/src/exports/codegen.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type CreateSimulateContractParameters,
  type CreateSimulateContractReturnType,
  createSimulateContract,
} from '../actions/codegen/createSimulateContract.js'

export {
  type CreateReadContractParameters,
  type CreateReadContractReturnType,
  createReadContract,
} from '../actions/codegen/createReadContract.js'

export {
  type CreateWatchContractEventParameters,
  type CreateWatchContractEventReturnType,
  createWatchContractEvent,
} from '../actions/codegen/createWatchContractEvent.js'

export {
  type CreateWriteContractParameters,
  type CreateWriteContractReturnType,
  createWriteContract,
} from '../actions/codegen/createWriteContract.js'
</file>

<file path="packages/core/src/exports/experimental.ts">
////////////////////////////////////////////////////////////////////////////////
// Actions
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusErrorType } from '@wagmi/core'` instead. */
  type GetCallsStatusErrorType,
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusParameters } from '@wagmi/core'` instead. */
  type GetCallsStatusParameters,
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusReturnType } from '@wagmi/core'` instead. */
  type GetCallsStatusReturnType,
  /** @deprecated This is no longer experimental  use `import { getCallsStatus } from '@wagmi/core'` instead. */
  getCallsStatus,
} from '../actions/getCallsStatus.js'

export {
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesErrorType } from '@wagmi/core'` instead. */
  type GetCapabilitiesErrorType,
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesParameters } from '@wagmi/core'` instead. */
  type GetCapabilitiesParameters,
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesReturnType } from '@wagmi/core'` instead. */
  type GetCapabilitiesReturnType,
  /** @deprecated This is no longer experimental  use `import { getCapabilities } from '@wagmi/core'` instead. */
  getCapabilities,
} from '../actions/getCapabilities.js'

export {
  /** @deprecated This is no longer experimental  use `import type { SendCallsErrorType } from '@wagmi/core'` instead. */
  type SendCallsErrorType,
  /** @deprecated This is no longer experimental  use `import type { SendCallsParameters } from '@wagmi/core'` instead. */
  type SendCallsParameters,
  /** @deprecated This is no longer experimental  use `import type { SendCallsReturnType } from '@wagmi/core'` instead. */
  type SendCallsReturnType,
  /** @deprecated This is no longer experimental  use `import { sendCalls } from '@wagmi/core'` instead. */
  sendCalls,
} from '../actions/sendCalls.js'

export {
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusErrorType } from '@wagmi/core'` instead. */
  type ShowCallsStatusErrorType,
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusParameters } from '@wagmi/core'` instead. */
  type ShowCallsStatusParameters,
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusReturnType } from '@wagmi/core'` instead. */
  type ShowCallsStatusReturnType,
  /** @deprecated This is no longer experimental  use `import { showCallsStatus } from '@wagmi/core'` instead. */
  showCallsStatus,
} from '../actions/showCallsStatus.js'

export {
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusErrorType } from '@wagmi/core'` instead. */
  type WaitForCallsStatusErrorType,
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusParameters } from '@wagmi/core'` instead. */
  type WaitForCallsStatusParameters,
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusReturnType } from '@wagmi/core'` instead. */
  type WaitForCallsStatusReturnType,
  /** @deprecated This is no longer experimental  use `import { waitForCallsStatus } from '@wagmi/core'` instead. */
  waitForCallsStatus,
} from '../actions/waitForCallsStatus.js'

export {
  /** @deprecated Use `SendCallsErrorType` instead. */
  type WriteContractsErrorType,
  /** @deprecated Use `SendCallsParameters` instead. */
  type WriteContractsParameters,
  /** @deprecated Use `SendCallsReturnType` instead. */
  type WriteContractsReturnType,
  /** @deprecated Use `sendCalls` instead. */
  writeContracts,
} from '../experimental/actions/writeContracts.js'

////////////////////////////////////////////////////////////////////////////////
// Tanstack Query
////////////////////////////////////////////////////////////////////////////////

export {
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusData } from '@wagmi/core/query'` instead. */
  type GetCallsStatusData,
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusOptions } from '@wagmi/core/query'` instead. */
  type GetCallsStatusOptions,
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusQueryFnData } from '@wagmi/core/query'` instead. */
  type GetCallsStatusQueryFnData,
  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusQueryKey } from '@wagmi/core/query'` instead. */
  type GetCallsStatusQueryKey,
  /** @deprecated This is no longer experimental  use `import { getCallsStatusQueryOptions } from '@wagmi/core/query'` instead. */
  getCallsStatusQueryOptions,
  /** @deprecated This is no longer experimental  use `import { getCallsStatusQueryKey } from '@wagmi/core/query'` instead. */
  getCallsStatusQueryKey,
} from '../query/getCallsStatus.js'

export {
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesData } from '@wagmi/core/query'` instead. */
  type GetCapabilitiesData,
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesOptions } from '@wagmi/core/query'` instead. */
  type GetCapabilitiesOptions,
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesQueryFnData } from '@wagmi/core/query'` instead. */
  type GetCapabilitiesQueryFnData,
  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesQueryKey } from '@wagmi/core/query'` instead. */
  type GetCapabilitiesQueryKey,
  /** @deprecated This is no longer experimental  use `import { getCapabilitiesQueryOptions } from '@wagmi/core/query'` instead. */
  getCapabilitiesQueryOptions,
  /** @deprecated This is no longer experimental  use `import { getCapabilitiesQueryKey } from '@wagmi/core/query'` instead. */
  getCapabilitiesQueryKey,
} from '../query/getCapabilities.js'

export {
  /** @deprecated This is no longer experimental  use `import type { SendCallsData } from '@wagmi/core/query'` instead. */
  type SendCallsData,
  /** @deprecated This is no longer experimental  use `import type { SendCallsMutate } from '@wagmi/core/query'` instead. */
  type SendCallsMutate,
  /** @deprecated This is no longer experimental  use `import type { SendCallsMutateAsync } from '@wagmi/core/query'` instead. */
  type SendCallsMutateAsync,
  /** @deprecated This is no longer experimental  use `import type { SendCallsVariables } from '@wagmi/core/query'` instead. */
  type SendCallsVariables,
  /** @deprecated This is no longer experimental  use `import { sendCallsMutationOptions } from '@wagmi/core/query'` instead. */
  sendCallsMutationOptions,
} from '../query/sendCalls.js'

export {
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusData } from '@wagmi/core/query'` instead. */
  type ShowCallsStatusData,
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusMutate } from '@wagmi/core/query'` instead. */
  type ShowCallsStatusMutate,
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusMutateAsync } from '@wagmi/core/query'` instead. */
  type ShowCallsStatusMutateAsync,
  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusVariables } from '@wagmi/core/query'` instead. */
  type ShowCallsStatusVariables,
  /** @deprecated This is no longer experimental  use `import { showCallsStatusMutationOptions } from '@wagmi/core/query'` instead. */
  showCallsStatusMutationOptions,
} from '../query/showCallsStatus.js'

export {
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusData } from '@wagmi/core/query'` instead. */
  type WaitForCallsStatusData,
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusOptions } from '@wagmi/core/query'` instead. */
  type WaitForCallsStatusOptions,
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusQueryFnData } from '@wagmi/core/query'` instead. */
  type WaitForCallsStatusQueryFnData,
  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusQueryKey } from '@wagmi/core/query'` instead. */
  type WaitForCallsStatusQueryKey,
  /** @deprecated This is no longer experimental  use `import { waitForCallsStatusQueryKey } from '@wagmi/core/query'` instead. */
  waitForCallsStatusQueryKey,
  /** @deprecated This is no longer experimental  use `import { waitForCallsStatusQueryOptions } from '@wagmi/core/query'` instead. */
  waitForCallsStatusQueryOptions,
} from '../query/waitForCallsStatus.js'

export {
  /** @deprecated Use `SendCallsData` instead. */
  type WriteContractsData,
  /** @deprecated Use `SendCallsMutate` instead. */
  type WriteContractsMutate,
  /** @deprecated Use `SendCallsMutateAsync` instead. */
  type WriteContractsMutateAsync,
  /** @deprecated Use `SendCallsVariables` instead. */
  type WriteContractsVariables,
  /** @deprecated Use `sendCallsMutationOptions` instead. */
  writeContractsMutationOptions,
} from '../experimental/query/writeContracts.js'
</file>

<file path="packages/core/src/exports/index.ts">
////////////////////////////////////////////////////////////////////////////////
// Actions
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type CallErrorType,
  type CallParameters,
  type CallReturnType,
  call,
} from '../actions/call.js'

export {
  type ConnectErrorType,
  type ConnectParameters,
  type ConnectReturnType,
  connect,
} from '../actions/connect.js'

export {
  type DeployContractErrorType,
  type DeployContractParameters,
  type DeployContractReturnType,
  deployContract,
} from '../actions/deployContract.js'

export {
  type DisconnectErrorType,
  type DisconnectParameters,
  type DisconnectReturnType,
  disconnect,
} from '../actions/disconnect.js'

export {
  type EstimateGasErrorType,
  type EstimateGasParameters,
  type EstimateGasReturnType,
  estimateGas,
} from '../actions/estimateGas.js'

export {
  type EstimateFeesPerGasErrorType,
  type EstimateFeesPerGasParameters,
  type EstimateFeesPerGasReturnType,
  estimateFeesPerGas,
} from '../actions/estimateFeesPerGas.js'

export {
  type EstimateMaxPriorityFeePerGasErrorType,
  type EstimateMaxPriorityFeePerGasParameters,
  type EstimateMaxPriorityFeePerGasReturnType,
  estimateMaxPriorityFeePerGas,
} from '../actions/estimateMaxPriorityFeePerGas.js'

export {
  type GetAccountReturnType,
  getAccount,
} from '../actions/getAccount.js'

export {
  type GetBalanceParameters,
  type GetBalanceReturnType,
  type GetBalanceErrorType,
  getBalance,
  /** @deprecated use `getBalance` instead */
  getBalance as fetchBalance,
} from '../actions/getBalance.js'

export {
  type GetBlockErrorType,
  type GetBlockParameters,
  type GetBlockReturnType,
  getBlock,
} from '../actions/getBlock.js'

export {
  type GetBlockNumberErrorType,
  type GetBlockNumberParameters,
  type GetBlockNumberReturnType,
  getBlockNumber,
  /** @deprecated use `getBlockNumber` instead */
  getBlockNumber as fetchBlockNumber,
} from '../actions/getBlockNumber.js'

export {
  type GetBlockTransactionCountErrorType,
  type GetBlockTransactionCountParameters,
  type GetBlockTransactionCountReturnType,
  getBlockTransactionCount,
} from '../actions/getBlockTransactionCount.js'

export {
  type GetBytecodeErrorType,
  type GetBytecodeParameters,
  type GetBytecodeReturnType,
  getBytecode,
} from '../actions/getBytecode.js'

export {
  type GetCallsStatusErrorType,
  type GetCallsStatusParameters,
  type GetCallsStatusReturnType,
  getCallsStatus,
} from '../actions/getCallsStatus.js'

export {
  type GetCapabilitiesErrorType,
  type GetCapabilitiesParameters,
  type GetCapabilitiesReturnType,
  getCapabilities,
} from '../actions/getCapabilities.js'

export {
  type GetChainIdReturnType,
  getChainId,
} from '../actions/getChainId.js'

export {
  type GetChainsReturnType,
  getChains,
} from '../actions/getChains.js'

export {
  type GetClientParameters,
  type GetClientReturnType,
  getClient,
} from '../actions/getClient.js'

export {
  type GetConnectionsReturnType,
  getConnections,
} from '../actions/getConnections.js'

export {
  type GetConnectorsReturnType,
  getConnectors,
} from '../actions/getConnectors.js'

export {
  type GetConnectorClientErrorType,
  type GetConnectorClientParameters,
  type GetConnectorClientReturnType,
  getConnectorClient,
} from '../actions/getConnectorClient.js'

export {
  type GetEnsAddressErrorType,
  type GetEnsAddressParameters,
  type GetEnsAddressReturnType,
  getEnsAddress,
  /** @deprecated use `getEnsAddress` instead */
  getEnsAddress as fetchEnsAddress,
} from '../actions/getEnsAddress.js'

export {
  type GetEnsAvatarErrorType,
  type GetEnsAvatarParameters,
  type GetEnsAvatarReturnType,
  getEnsAvatar,
  /** @deprecated use `getEnsAvatar` instead */
  getEnsAvatar as fetchEnsAvatar,
} from '../actions/getEnsAvatar.js'

export {
  type GetEnsNameErrorType,
  type GetEnsNameParameters,
  type GetEnsNameReturnType,
  getEnsName,
  /** @deprecated */
  getEnsName as fetchEnsName,
} from '../actions/getEnsName.js'

export {
  type GetEnsResolverErrorType,
  type GetEnsResolverParameters,
  type GetEnsResolverReturnType,
  getEnsResolver,
  /** @deprecated use `getEnsResolver` instead */
  getEnsResolver as fetchEnsResolver,
} from '../actions/getEnsResolver.js'

export {
  type GetEnsTextErrorType,
  type GetEnsTextParameters,
  type GetEnsTextReturnType,
  getEnsText,
} from '../actions/getEnsText.js'

export {
  type GetFeeHistoryErrorType,
  type GetFeeHistoryParameters,
  type GetFeeHistoryReturnType,
  getFeeHistory,
} from '../actions/getFeeHistory.js'

export {
  type GetGasPriceErrorType,
  type GetGasPriceParameters,
  type GetGasPriceReturnType,
  getGasPrice,
} from '../actions/getGasPrice.js'

export {
  type GetProofErrorType,
  type GetProofParameters,
  type GetProofReturnType,
  getProof,
} from '../actions/getProof.js'

export {
  type GetPublicClientParameters,
  type GetPublicClientReturnType,
  getPublicClient,
} from '../actions/getPublicClient.js'

export {
  type GetStorageAtErrorType,
  type GetStorageAtParameters,
  type GetStorageAtReturnType,
  getStorageAt,
} from '../actions/getStorageAt.js'

export {
  type GetTokenErrorType,
  type GetTokenParameters,
  type GetTokenReturnType,
  getToken,
  /** @deprecated use `getToken` instead */
  getToken as fetchToken,
} from '../actions/getToken.js'

export {
  type GetTransactionErrorType,
  type GetTransactionParameters,
  type GetTransactionReturnType,
  getTransaction,
  /** @deprecated use `getTransaction` instead */
  getTransaction as fetchTransaction,
} from '../actions/getTransaction.js'

export {
  type GetTransactionConfirmationsErrorType,
  type GetTransactionConfirmationsParameters,
  type GetTransactionConfirmationsReturnType,
  getTransactionConfirmations,
} from '../actions/getTransactionConfirmations.js'

export {
  type GetTransactionCountErrorType,
  type GetTransactionCountParameters,
  type GetTransactionCountReturnType,
  getTransactionCount,
} from '../actions/getTransactionCount.js'

export {
  type GetTransactionReceiptErrorType,
  type GetTransactionReceiptParameters,
  type GetTransactionReceiptReturnType,
  getTransactionReceipt,
} from '../actions/getTransactionReceipt.js'

export {
  type GetWalletClientErrorType,
  type GetWalletClientParameters,
  type GetWalletClientReturnType,
  getWalletClient,
} from '../actions/getWalletClient.js'

export {
  type MulticallParameters,
  type MulticallReturnType,
  multicall,
} from '../actions/multicall.js'

export {
  type PrepareTransactionRequestErrorType,
  type PrepareTransactionRequestParameters,
  type PrepareTransactionRequestReturnType,
  prepareTransactionRequest,
} from '../actions/prepareTransactionRequest.js'

export {
  type ReadContractParameters,
  type ReadContractReturnType,
  type ReadContractErrorType,
  readContract,
} from '../actions/readContract.js'

export {
  type ReadContractsParameters,
  type ReadContractsReturnType,
  type ReadContractsErrorType,
  readContracts,
} from '../actions/readContracts.js'

export {
  type ReconnectErrorType,
  type ReconnectParameters,
  type ReconnectReturnType,
  reconnect,
} from '../actions/reconnect.js'

export {
  type SendCallsErrorType,
  type SendCallsParameters,
  type SendCallsReturnType,
  sendCalls,
} from '../actions/sendCalls.js'

export {
  type SendTransactionErrorType,
  type SendTransactionParameters,
  type SendTransactionReturnType,
  sendTransaction,
} from '../actions/sendTransaction.js'

export {
  type ShowCallsStatusErrorType,
  type ShowCallsStatusParameters,
  type ShowCallsStatusReturnType,
  showCallsStatus,
} from '../actions/showCallsStatus.js'

export {
  type SignMessageErrorType,
  type SignMessageParameters,
  type SignMessageReturnType,
  signMessage,
} from '../actions/signMessage.js'

export {
  type SignTypedDataErrorType,
  type SignTypedDataParameters,
  type SignTypedDataReturnType,
  signTypedData,
} from '../actions/signTypedData.js'

export {
  type SimulateContractErrorType,
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from '../actions/simulateContract.js'

export {
  type SwitchAccountErrorType,
  type SwitchAccountParameters,
  type SwitchAccountReturnType,
  switchAccount,
} from '../actions/switchAccount.js'

export {
  type SwitchChainErrorType,
  type SwitchChainParameters,
  type SwitchChainReturnType,
  switchChain,
  /** @deprecated use `switchChain` instead */
  switchChain as switchNetwork,
} from '../actions/switchChain.js'

export {
  type VerifyMessageErrorType,
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from '../actions/verifyMessage.js'

export {
  type VerifyTypedDataErrorType,
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from '../actions/verifyTypedData.js'

export {
  type WaitForCallsStatusErrorType,
  type WaitForCallsStatusParameters,
  type WaitForCallsStatusReturnType,
  waitForCallsStatus,
} from '../actions/waitForCallsStatus.js'

export {
  type WatchAccountParameters,
  type WatchAccountReturnType,
  watchAccount,
} from '../actions/watchAccount.js'

export {
  type WatchAssetParameters,
  type WatchAssetErrorType,
  type WatchAssetReturnType,
  watchAsset,
} from '../actions/watchAsset.js'

export {
  type WatchBlocksParameters,
  type WatchBlocksReturnType,
  watchBlocks,
} from '../actions/watchBlocks.js'

export {
  type WatchBlockNumberParameters,
  type WatchBlockNumberReturnType,
  watchBlockNumber,
} from '../actions/watchBlockNumber.js'

export {
  type WatchChainIdParameters,
  type WatchChainIdReturnType,
  watchChainId,
} from '../actions/watchChainId.js'

export {
  type WatchClientParameters,
  type WatchClientReturnType,
  watchClient,
} from '../actions/watchClient.js'

export {
  type WatchConnectionsParameters,
  type WatchConnectionsReturnType,
  watchConnections,
} from '../actions/watchConnections.js'

export {
  type WatchConnectorsParameters,
  type WatchConnectorsReturnType,
  watchConnectors,
} from '../actions/watchConnectors.js'

export {
  type WatchContractEventParameters,
  type WatchContractEventReturnType,
  watchContractEvent,
} from '../actions/watchContractEvent.js'

export {
  type WatchPendingTransactionsParameters,
  type WatchPendingTransactionsReturnType,
  watchPendingTransactions,
} from '../actions/watchPendingTransactions.js'

export {
  type WatchPublicClientParameters,
  type WatchPublicClientReturnType,
  watchPublicClient,
} from '../actions/watchPublicClient.js'

export {
  type WaitForTransactionReceiptErrorType,
  type WaitForTransactionReceiptParameters,
  type WaitForTransactionReceiptReturnType,
  waitForTransactionReceipt,
  /** @deprecated use `waitForTransactionReceipt` instead */
  waitForTransactionReceipt as waitForTransaction,
} from '../actions/waitForTransactionReceipt.js'

export {
  type WriteContractErrorType,
  type WriteContractParameters,
  type WriteContractReturnType,
  writeContract,
} from '../actions/writeContract.js'

////////////////////////////////////////////////////////////////////////////////
// Connectors
////////////////////////////////////////////////////////////////////////////////

export {
  type ConnectorEventMap,
  type CreateConnectorFn,
  createConnector,
} from '../connectors/createConnector.js'

export {
  type InjectedParameters,
  injected,
} from '../connectors/injected.js'

export {
  type MockParameters,
  mock,
} from '../connectors/mock.js'

////////////////////////////////////////////////////////////////////////////////
// createConfig
////////////////////////////////////////////////////////////////////////////////

export {
  type Connection,
  type Connector,
  type Config,
  type CreateConfigParameters,
  type PartializedState,
  type State,
  type Transport,
  createConfig,
} from '../createConfig.js'

////////////////////////////////////////////////////////////////////////////////
// createStorage
////////////////////////////////////////////////////////////////////////////////

export {
  type CreateStorageParameters,
  type Storage,
  type StorageItemMap,
  createStorage,
  noopStorage,
} from '../createStorage.js'

////////////////////////////////////////////////////////////////////////////////
// Hydrate
////////////////////////////////////////////////////////////////////////////////

export { hydrate } from '../hydrate.js'

////////////////////////////////////////////////////////////////////////////////
// Errors
////////////////////////////////////////////////////////////////////////////////

export { BaseError } from '../errors/base.js'

export {
  type ChainNotConfiguredErrorType,
  ChainNotConfiguredError,
  type ConnectorNotConnectedErrorType,
  ConnectorNotConnectedError,
  type ConnectorAlreadyConnectedErrorType,
  ConnectorAlreadyConnectedError,
  type ConnectorNotFoundErrorType,
  ConnectorNotFoundError,
  type ConnectorAccountNotFoundErrorType,
  ConnectorAccountNotFoundError,
  type ConnectorChainMismatchErrorType,
  ConnectorChainMismatchError,
  type ConnectorUnavailableReconnectingErrorType,
  ConnectorUnavailableReconnectingError,
} from '../errors/config.js'

export {
  type ProviderNotFoundErrorType,
  ProviderNotFoundError,
  type SwitchChainNotSupportedErrorType,
  SwitchChainNotSupportedError,
} from '../errors/connector.js'

////////////////////////////////////////////////////////////////////////////////
// Transports
////////////////////////////////////////////////////////////////////////////////

export { custom, http, webSocket } from 'viem'

export {
  type ConnectorTransportConfig,
  type ConnectorTransport,
  unstable_connector,
} from '../transports/connector.js'

export { fallback } from '../transports/fallback.js'

////////////////////////////////////////////////////////////////////////////////
// Types
////////////////////////////////////////////////////////////////////////////////

export type { SelectChains } from '../types/chain.js'

export type { Register, ResolvedRegister } from '../types/register.js'

////////////////////////////////////////////////////////////////////////////////
// Utilities
////////////////////////////////////////////////////////////////////////////////

export {
  cookieStorage,
  cookieToInitialState,
  parseCookie,
} from '../utils/cookie.js'

export { deepEqual } from '../utils/deepEqual.js'

export { deserialize } from '../utils/deserialize.js'

export { extractRpcUrls } from '../utils/extractRpcUrls.js'

export { normalizeChainId } from '../utils/normalizeChainId.js'

export { serialize } from '../utils/serialize.js'

////////////////////////////////////////////////////////////////////////////////
// Version
////////////////////////////////////////////////////////////////////////////////

export { version } from '../version.js'
</file>

<file path="packages/core/src/exports/internal.ts">
////////////////////////////////////////////////////////////////////////////////
// Actions
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type WatchChainsParameters,
  type WatchChainsReturnType,
  watchChains,
} from '../actions/watchChains.js'

////////////////////////////////////////////////////////////////////////////////
// Emitter
////////////////////////////////////////////////////////////////////////////////

export {
  type EventData,
  Emitter,
  createEmitter,
} from '../createEmitter.js'

////////////////////////////////////////////////////////////////////////////////
// Types
////////////////////////////////////////////////////////////////////////////////

export type { SelectChains } from '../types/chain.js'

export type {
  ChainIdParameter,
  ConnectorParameter,
  ScopeKeyParameter,
} from '../types/properties.js'

export type {
  Compute,
  ExactPartial,
  Mutable,
  StrictOmit as Omit,
  OneOf,
  RemoveUndefined,
  UnionCompute,
  UnionStrictOmit,
  UnionExactPartial,
} from '../types/utils.js'

////////////////////////////////////////////////////////////////////////////////
// Utilities
////////////////////////////////////////////////////////////////////////////////

export { deepEqual } from '../utils/deepEqual.js'

export { uid } from '../utils/uid.js'
</file>

<file path="packages/core/src/exports/query.ts">
////////////////////////////////////////////////////////////////////////////////
// Tanstack Query
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type CallData,
  type CallOptions,
  type CallQueryFnData,
  type CallQueryKey,
  callQueryKey,
  callQueryOptions,
} from '../query/call.js'

export {
  type ConnectData,
  type ConnectVariables,
  type ConnectMutate,
  type ConnectMutateAsync,
  connectMutationOptions,
} from '../query/connect.js'

export {
  type DeployContractData,
  type DeployContractVariables,
  type DeployContractMutate,
  type DeployContractMutateAsync,
  deployContractMutationOptions,
} from '../query/deployContract.js'

export {
  type DisconnectData,
  type DisconnectVariables,
  type DisconnectMutate,
  type DisconnectMutateAsync,
  disconnectMutationOptions,
} from '../query/disconnect.js'

export {
  type EstimateFeesPerGasData,
  type EstimateFeesPerGasOptions,
  type EstimateFeesPerGasQueryFnData,
  type EstimateFeesPerGasQueryKey,
  estimateFeesPerGasQueryKey,
  estimateFeesPerGasQueryOptions,
} from '../query/estimateFeesPerGas.js'

export {
  type EstimateGasData,
  type EstimateGasOptions,
  type EstimateGasQueryFnData,
  type EstimateGasQueryKey,
  estimateGasQueryKey,
  estimateGasQueryOptions,
} from '../query/estimateGas.js'

export {
  type EstimateMaxPriorityFeePerGasData,
  type EstimateMaxPriorityFeePerGasOptions,
  type EstimateMaxPriorityFeePerGasQueryFnData,
  type EstimateMaxPriorityFeePerGasQueryKey,
  estimateMaxPriorityFeePerGasQueryKey,
  estimateMaxPriorityFeePerGasQueryOptions,
} from '../query/estimateMaxPriorityFeePerGas.js'

export {
  type GetBalanceData,
  type GetBalanceOptions,
  type GetBalanceQueryFnData,
  type GetBalanceQueryKey,
  getBalanceQueryKey,
  getBalanceQueryOptions,
} from '../query/getBalance.js'

export {
  type GetBlockData,
  type GetBlockOptions,
  type GetBlockQueryFnData,
  type GetBlockQueryKey,
  getBlockQueryKey,
  getBlockQueryOptions,
} from '../query/getBlock.js'

export {
  type GetBlockNumberData,
  type GetBlockNumberOptions,
  type GetBlockNumberQueryFnData,
  type GetBlockNumberQueryKey,
  getBlockNumberQueryKey,
  getBlockNumberQueryOptions,
} from '../query/getBlockNumber.js'

export {
  type GetBlockTransactionCountData,
  type GetBlockTransactionCountOptions,
  type GetBlockTransactionCountQueryFnData,
  type GetBlockTransactionCountQueryKey,
  getBlockTransactionCountQueryKey,
  getBlockTransactionCountQueryOptions,
} from '../query/getBlockTransactionCount.js'

export {
  type GetBytecodeData,
  type GetBytecodeOptions,
  type GetBytecodeQueryFnData,
  type GetBytecodeQueryKey,
  getBytecodeQueryKey,
  getBytecodeQueryOptions,
} from '../query/getBytecode.js'

export {
  type GetCallsStatusData,
  type GetCallsStatusOptions,
  type GetCallsStatusQueryFnData,
  type GetCallsStatusQueryKey,
  getCallsStatusQueryKey,
  getCallsStatusQueryOptions,
} from '../query/getCallsStatus.js'

export {
  type GetCapabilitiesData,
  type GetCapabilitiesOptions,
  type GetCapabilitiesQueryFnData,
  type GetCapabilitiesQueryKey,
  getCapabilitiesQueryKey,
  getCapabilitiesQueryOptions,
} from '../query/getCapabilities.js'

export {
  type GetConnectorClientData,
  type GetConnectorClientOptions,
  type GetConnectorClientQueryFnData,
  type GetConnectorClientQueryKey,
  getConnectorClientQueryKey,
  getConnectorClientQueryOptions,
} from '../query/getConnectorClient.js'

export {
  type GetEnsAddressData,
  type GetEnsAddressOptions,
  type GetEnsAddressQueryFnData,
  type GetEnsAddressQueryKey,
  getEnsAddressQueryKey,
  getEnsAddressQueryOptions,
} from '../query/getEnsAddress.js'

export {
  type GetEnsAvatarData,
  type GetEnsAvatarOptions,
  type GetEnsAvatarQueryFnData,
  type GetEnsAvatarQueryKey,
  getEnsAvatarQueryKey,
  getEnsAvatarQueryOptions,
} from '../query/getEnsAvatar.js'

export {
  type GetEnsNameData,
  type GetEnsNameOptions,
  type GetEnsNameQueryFnData,
  type GetEnsNameQueryKey,
  getEnsNameQueryKey,
  getEnsNameQueryOptions,
} from '../query/getEnsName.js'

export {
  type GetEnsResolverData,
  type GetEnsResolverOptions,
  type GetEnsResolverQueryFnData,
  type GetEnsResolverQueryKey,
  getEnsResolverQueryKey,
  getEnsResolverQueryOptions,
} from '../query/getEnsResolver.js'

export {
  type GetEnsTextData,
  type GetEnsTextOptions,
  type GetEnsTextQueryFnData,
  type GetEnsTextQueryKey,
  getEnsTextQueryKey,
  getEnsTextQueryOptions,
} from '../query/getEnsText.js'

export {
  type GetFeeHistoryData,
  type GetFeeHistoryOptions,
  type GetFeeHistoryQueryFnData,
  type GetFeeHistoryQueryKey,
  getFeeHistoryQueryKey,
  getFeeHistoryQueryOptions,
} from '../query/getFeeHistory.js'

export {
  type GetGasPriceData,
  type GetGasPriceOptions,
  type GetGasPriceQueryFnData,
  type GetGasPriceQueryKey,
  getGasPriceQueryKey,
  getGasPriceQueryOptions,
} from '../query/getGasPrice.js'

export {
  type GetProofData,
  type GetProofOptions,
  type GetProofQueryFnData,
  type GetProofQueryKey,
  getProofQueryKey,
  getProofQueryOptions,
} from '../query/getProof.js'

export {
  type GetStorageAtData,
  type GetStorageAtOptions,
  type GetStorageAtQueryFnData,
  type GetStorageAtQueryKey,
  getStorageAtQueryKey,
  getStorageAtQueryOptions,
} from '../query/getStorageAt.js'

export {
  type GetTokenData,
  type GetTokenOptions,
  type GetTokenQueryFnData,
  type GetTokenQueryKey,
  getTokenQueryKey,
  getTokenQueryOptions,
} from '../query/getToken.js'

export {
  type GetTransactionData,
  type GetTransactionOptions,
  type GetTransactionQueryFnData,
  type GetTransactionQueryKey,
  getTransactionQueryKey,
  getTransactionQueryOptions,
} from '../query/getTransaction.js'

export {
  type GetTransactionConfirmationsData,
  type GetTransactionConfirmationsOptions,
  type GetTransactionConfirmationsQueryFnData,
  type GetTransactionConfirmationsQueryKey,
  getTransactionConfirmationsQueryKey,
  getTransactionConfirmationsQueryOptions,
} from '../query/getTransactionConfirmations.js'

export {
  type GetTransactionCountData,
  type GetTransactionCountOptions,
  type GetTransactionCountQueryFnData,
  type GetTransactionCountQueryKey,
  getTransactionCountQueryKey,
  getTransactionCountQueryOptions,
} from '../query/getTransactionCount.js'

export {
  type GetTransactionReceiptData,
  type GetTransactionReceiptOptions,
  type GetTransactionReceiptQueryFnData,
  type GetTransactionReceiptQueryKey,
  getTransactionReceiptQueryKey,
  getTransactionReceiptQueryOptions,
} from '../query/getTransactionReceipt.js'

export {
  type GetWalletClientData,
  type GetWalletClientOptions,
  type GetWalletClientQueryFnData,
  type GetWalletClientQueryKey,
  getWalletClientQueryKey,
  getWalletClientQueryOptions,
} from '../query/getWalletClient.js'

export {
  type InfiniteReadContractsData,
  type InfiniteReadContractsOptions,
  type InfiniteReadContractsQueryFnData,
  type InfiniteReadContractsQueryKey,
  infiniteReadContractsQueryKey,
  infiniteReadContractsQueryOptions,
} from '../query/infiniteReadContracts.js'

export {
  type PrepareTransactionRequestData,
  type PrepareTransactionRequestOptions,
  type PrepareTransactionRequestQueryFnData,
  type PrepareTransactionRequestQueryKey,
  prepareTransactionRequestQueryKey,
  prepareTransactionRequestQueryOptions,
} from '../query/prepareTransactionRequest.js'

export {
  type ReadContractData,
  type ReadContractOptions,
  type ReadContractQueryFnData,
  type ReadContractQueryKey,
  readContractQueryKey,
  readContractQueryOptions,
} from '../query/readContract.js'

export {
  type ReadContractsData,
  type ReadContractsOptions,
  type ReadContractsQueryFnData,
  type ReadContractsQueryKey,
  readContractsQueryKey,
  readContractsQueryOptions,
} from '../query/readContracts.js'

export {
  type ReconnectData,
  type ReconnectVariables,
  type ReconnectMutate,
  type ReconnectMutateAsync,
  reconnectMutationOptions,
} from '../query/reconnect.js'

export {
  type SendCallsData,
  type SendCallsVariables,
  type SendCallsMutate,
  type SendCallsMutateAsync,
  sendCallsMutationOptions,
} from '../query/sendCalls.js'

export {
  type ShowCallsStatusData,
  type ShowCallsStatusVariables,
  type ShowCallsStatusMutate,
  type ShowCallsStatusMutateAsync,
  showCallsStatusMutationOptions,
} from '../query/showCallsStatus.js'

export {
  type SendTransactionData,
  type SendTransactionVariables,
  type SendTransactionMutate,
  type SendTransactionMutateAsync,
  sendTransactionMutationOptions,
} from '../query/sendTransaction.js'

export {
  type SignMessageData,
  type SignMessageVariables,
  type SignMessageMutate,
  type SignMessageMutateAsync,
  signMessageMutationOptions,
} from '../query/signMessage.js'

export {
  type SignTypedDataData,
  type SignTypedDataVariables,
  type SignTypedDataMutate,
  type SignTypedDataMutateAsync,
  signTypedDataMutationOptions,
} from '../query/signTypedData.js'

export {
  type SwitchAccountData,
  type SwitchAccountVariables,
  type SwitchAccountMutate,
  type SwitchAccountMutateAsync,
  switchAccountMutationOptions,
} from '../query/switchAccount.js'

export {
  type SimulateContractData,
  type SimulateContractOptions,
  type SimulateContractQueryFnData,
  type SimulateContractQueryKey,
  simulateContractQueryKey,
  simulateContractQueryOptions,
} from '../query/simulateContract.js'

export {
  type SwitchChainData,
  type SwitchChainVariables,
  type SwitchChainMutate,
  type SwitchChainMutateAsync,
  switchChainMutationOptions,
} from '../query/switchChain.js'

export {
  type VerifyMessageData,
  type VerifyMessageOptions,
  type VerifyMessageQueryFnData,
  type VerifyMessageQueryKey,
  verifyMessageQueryKey,
  verifyMessageQueryOptions,
} from '../query/verifyMessage.js'

export {
  type VerifyTypedDataData,
  type VerifyTypedDataOptions,
  type VerifyTypedDataQueryFnData,
  type VerifyTypedDataQueryKey,
  verifyTypedDataQueryKey,
  verifyTypedDataQueryOptions,
} from '../query/verifyTypedData.js'

export {
  type WaitForCallsStatusData,
  type WaitForCallsStatusOptions,
  type WaitForCallsStatusQueryFnData,
  type WaitForCallsStatusQueryKey,
  waitForCallsStatusQueryKey,
  waitForCallsStatusQueryOptions,
} from '../query/waitForCallsStatus.js'

export {
  type WaitForTransactionReceiptData,
  type WaitForTransactionReceiptOptions,
  type WaitForTransactionReceiptQueryFnData,
  type WaitForTransactionReceiptQueryKey,
  waitForTransactionReceiptQueryKey,
  waitForTransactionReceiptQueryOptions,
} from '../query/waitForTransactionReceipt.js'

export {
  type WatchAssetData,
  type WatchAssetVariables,
  type WatchAssetMutate,
  type WatchAssetMutateAsync,
  watchAssetMutationOptions,
} from '../query/watchAsset.js'

export {
  type WriteContractData,
  type WriteContractVariables,
  type WriteContractMutate,
  type WriteContractMutateAsync,
  writeContractMutationOptions,
} from '../query/writeContract.js'

export { hashFn, structuralSharing } from '../query/utils.js'
</file>

<file path="packages/core/src/query/call.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type CallErrorType,
  type CallParameters,
  type CallReturnType,
  call,
} from '../actions/call.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type CallOptions<config extends Config> = Compute<
  ExactPartial<CallParameters<config>> & ScopeKeyParameter
>

export function callQueryOptions<config extends Config>(
  config: config,
  options: CallOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const data = await call(config, {
        ...parameters,
      } as CallParameters)
      return data ?? null
    },
    queryKey: callQueryKey(options),
  } as const satisfies QueryOptions<
    CallQueryFnData,
    CallErrorType,
    CallData,
    CallQueryKey<config>
  >
}

export type CallQueryFnData = CallReturnType

export type CallData = CallQueryFnData

export function callQueryKey<config extends Config>(
  options: CallOptions<config>,
) {
  return ['call', filterQueryOptions(options)] as const
}

export type CallQueryKey<config extends Config> = ReturnType<
  typeof callQueryKey<config>
>
</file>

<file path="packages/core/src/query/connect.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import {
  type ConnectErrorType,
  type ConnectParameters,
  type ConnectReturnType,
  connect,
} from '../actions/connect.js'
import type { Config, Connector } from '../createConfig.js'

import type { CreateConnectorFn } from '../connectors/createConnector.js'
import type { Compute } from '../types/utils.js'

export function connectMutationOptions<config extends Config>(config: config) {
  return {
    mutationFn(variables) {
      return connect(config, variables)
    },
    mutationKey: ['connect'],
  } as const satisfies MutationOptions<
    ConnectData<config>,
    ConnectErrorType,
    ConnectVariables<config, Connector | CreateConnectorFn>
  >
}

export type ConnectData<config extends Config> = ConnectReturnType<config>

export type ConnectVariables<
  config extends Config,
  connector extends Connector | CreateConnectorFn,
> = ConnectParameters<config, connector>

export type ConnectMutate<config extends Config, context = unknown> = <
  connector extends
    | config['connectors'][number]
    | Connector
    | CreateConnectorFn,
>(
  variables: ConnectVariables<config, connector>,
  options?:
    | Compute<
        MutateOptions<
          ConnectData<config>,
          ConnectErrorType,
          Compute<ConnectVariables<config, connector>>,
          context
        >
      >
    | undefined,
) => void

export type ConnectMutateAsync<config extends Config, context = unknown> = <
  connector extends
    | config['connectors'][number]
    | Connector
    | CreateConnectorFn,
>(
  variables: ConnectVariables<config, connector>,
  options?:
    | Compute<
        MutateOptions<
          ConnectData<config>,
          ConnectErrorType,
          Compute<ConnectVariables<config, connector>>,
          context
        >
      >
    | undefined,
) => Promise<ConnectData<config>>
</file>

<file path="packages/core/src/query/deployContract.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'
import type { Abi, ContractConstructorArgs } from 'viem'

import {
  type DeployContractErrorType,
  type DeployContractParameters,
  type DeployContractReturnType,
  deployContract,
} from '../actions/deployContract.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function deployContractMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return deployContract(config, variables)
    },
    mutationKey: ['deployContract'],
  } as const satisfies MutationOptions<
    DeployContractData,
    DeployContractErrorType,
    DeployContractVariables<Abi, config, config['chains'][number]['id']>
  >
}

export type DeployContractData = Compute<DeployContractReturnType>

export type DeployContractVariables<
  abi extends Abi | readonly unknown[],
  config extends Config,
  chainId extends config['chains'][number]['id'],
  ///
  allArgs = ContractConstructorArgs<abi>,
> = DeployContractParameters<abi, config, chainId, allArgs>

export type DeployContractMutate<config extends Config, context = unknown> = <
  abi extends Abi | readonly unknown[],
  chainId extends config['chains'][number]['id'],
>(
  variables: DeployContractVariables<abi, config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          DeployContractData,
          DeployContractErrorType,
          Compute<DeployContractVariables<abi, config, chainId>>,
          context
        >
      >
    | undefined,
) => void

export type DeployContractMutateAsync<
  config extends Config,
  context = unknown,
> = <
  abi extends Abi | readonly unknown[],
  chainId extends config['chains'][number]['id'],
>(
  variables: DeployContractVariables<abi, config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          DeployContractData,
          DeployContractErrorType,
          Compute<DeployContractVariables<abi, config, chainId>>,
          context
        >
      >
    | undefined,
) => Promise<DeployContractData>
</file>

<file path="packages/core/src/query/disconnect.ts">
import type { MutationOptions } from '@tanstack/query-core'

import {
  type DisconnectErrorType,
  type DisconnectParameters,
  type DisconnectReturnType,
  disconnect,
} from '../actions/disconnect.js'
import type { Config } from '../createConfig.js'
import type { Mutate, MutateAsync } from './types.js'

export function disconnectMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return disconnect(config, variables)
    },
    mutationKey: ['disconnect'],
  } as const satisfies MutationOptions<
    DisconnectData,
    DisconnectErrorType,
    DisconnectVariables
  >
}

export type DisconnectData = DisconnectReturnType

export type DisconnectVariables = DisconnectParameters | undefined

export type DisconnectMutate<context = unknown> = Mutate<
  DisconnectData,
  DisconnectErrorType,
  DisconnectVariables,
  context
>

export type DisconnectMutateAsync<context = unknown> = MutateAsync<
  DisconnectData,
  DisconnectErrorType,
  DisconnectVariables,
  context
>
</file>

<file path="packages/core/src/query/estimateFeesPerGas.ts">
import type { QueryOptions } from '@tanstack/query-core'
import type { FeeValuesType } from 'viem'

import {
  type EstimateFeesPerGasErrorType,
  type EstimateFeesPerGasParameters,
  type EstimateFeesPerGasReturnType,
  estimateFeesPerGas,
} from '../actions/estimateFeesPerGas.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type EstimateFeesPerGasOptions<
  type extends FeeValuesType,
  config extends Config,
> = Compute<
  ExactPartial<EstimateFeesPerGasParameters<type, config>> & ScopeKeyParameter
>

export function estimateFeesPerGasQueryOptions<
  config extends Config,
  type extends FeeValuesType = 'eip1559',
>(config: config, options: EstimateFeesPerGasOptions<type, config> = {}) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      return estimateFeesPerGas(config, parameters)
    },
    queryKey: estimateFeesPerGasQueryKey(options),
  } as const satisfies QueryOptions<
    EstimateFeesPerGasQueryFnData<type>,
    EstimateFeesPerGasErrorType,
    EstimateFeesPerGasData<type>,
    EstimateFeesPerGasQueryKey<config, type>
  >
}

export type EstimateFeesPerGasQueryFnData<type extends FeeValuesType> =
  EstimateFeesPerGasReturnType<type>

export type EstimateFeesPerGasData<type extends FeeValuesType> =
  EstimateFeesPerGasQueryFnData<type>

export function estimateFeesPerGasQueryKey<
  config extends Config,
  type extends FeeValuesType = 'eip1559',
>(options: EstimateFeesPerGasOptions<type, config> = {}) {
  return ['estimateFeesPerGas', filterQueryOptions(options)] as const
}

export type EstimateFeesPerGasQueryKey<
  config extends Config,
  type extends FeeValuesType,
> = ReturnType<typeof estimateFeesPerGasQueryKey<config, type>>
</file>

<file path="packages/core/src/query/estimateGas.test-d.ts">
import { http, type Address, parseEther } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type EstimateGasOptions,
  estimateGasQueryOptions,
} from './estimateGas.js'

test('chain formatters', () => {
  const config = createConfig({
    chains: [mainnet, celo],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = EstimateGasOptions<
    typeof config,
    (typeof config)['chains'][number]['id']
  >
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  estimateGasQueryOptions(config, {
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })

  type Result2 = EstimateGasOptions<typeof config, typeof celo.id>
  expectTypeOf<Result2>().toMatchTypeOf<{
    functionName?: 'approve' | 'transfer' | 'transferFrom' | undefined
    args?: readonly [Address, Address, bigint] | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  estimateGasQueryOptions(config, {
    chainId: celo.id,
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    feeCurrency: '0x',
  })

  type Result3 = EstimateGasOptions<typeof config, typeof mainnet.id>
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  estimateGasQueryOptions(config, {
    chainId: mainnet.id,
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
    // @ts-expect-error
    feeCurrency: '0x',
  })
})
</file>

<file path="packages/core/src/query/estimateGas.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type EstimateGasErrorType,
  type EstimateGasParameters,
  type EstimateGasReturnType,
  estimateGas,
} from '../actions/estimateGas.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { UnionExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type EstimateGasOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
> = UnionExactPartial<EstimateGasParameters<config, chainId>> &
  ScopeKeyParameter

export function estimateGasQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: EstimateGasOptions<config, chainId> = {} as any) {
  return {
    async queryFn({ queryKey }) {
      const { connector } = options
      const { account, scopeKey: _, ...parameters } = queryKey[1]
      if (!account && !connector)
        throw new Error('account or connector is required')
      return estimateGas(config, { account, connector, ...(parameters as any) })
    },
    queryKey: estimateGasQueryKey(options),
  } as const satisfies QueryOptions<
    EstimateGasQueryFnData,
    EstimateGasErrorType,
    EstimateGasData,
    EstimateGasQueryKey<config, chainId>
  >
}

export type EstimateGasQueryFnData = EstimateGasReturnType

export type EstimateGasData = EstimateGasQueryFnData

export function estimateGasQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
>(options: EstimateGasOptions<config, chainId> = {} as any) {
  const { connector: _, ...rest } = options
  return ['estimateGas', filterQueryOptions(rest)] as const
}

export type EstimateGasQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
> = ReturnType<typeof estimateGasQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/estimateMaxPriorityFeePerGas.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type EstimateMaxPriorityFeePerGasErrorType,
  type EstimateMaxPriorityFeePerGasParameters,
  type EstimateMaxPriorityFeePerGasReturnType,
  estimateMaxPriorityFeePerGas,
} from '../actions/estimateMaxPriorityFeePerGas.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type EstimateMaxPriorityFeePerGasOptions<config extends Config> =
  Compute<
    ExactPartial<EstimateMaxPriorityFeePerGasParameters<config>> &
      ScopeKeyParameter
  >

export function estimateMaxPriorityFeePerGasQueryOptions<config extends Config>(
  config: config,
  options: EstimateMaxPriorityFeePerGasOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      return estimateMaxPriorityFeePerGas(config, parameters)
    },
    queryKey: estimateMaxPriorityFeePerGasQueryKey(options),
  } as const satisfies QueryOptions<
    EstimateMaxPriorityFeePerGasQueryFnData,
    EstimateMaxPriorityFeePerGasErrorType,
    EstimateMaxPriorityFeePerGasData,
    EstimateMaxPriorityFeePerGasQueryKey<config>
  >
}

export type EstimateMaxPriorityFeePerGasQueryFnData =
  EstimateMaxPriorityFeePerGasReturnType

export type EstimateMaxPriorityFeePerGasData =
  EstimateMaxPriorityFeePerGasQueryFnData

export function estimateMaxPriorityFeePerGasQueryKey<config extends Config>(
  options: EstimateMaxPriorityFeePerGasOptions<config> = {},
) {
  return ['estimateMaxPriorityFeePerGas', filterQueryOptions(options)] as const
}

export type EstimateMaxPriorityFeePerGasQueryKey<config extends Config> =
  ReturnType<typeof estimateMaxPriorityFeePerGasQueryKey<config>>
</file>

<file path="packages/core/src/query/getBalance.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetBalanceErrorType,
  type GetBalanceParameters,
  type GetBalanceReturnType,
  getBalance,
} from '../actions/getBalance.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, PartialBy } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetBalanceOptions<config extends Config> = Compute<
  PartialBy<GetBalanceParameters<config>, 'address'> & ScopeKeyParameter
>

export function getBalanceQueryOptions<config extends Config>(
  config: config,
  options: GetBalanceOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _, ...parameters } = queryKey[1]
      if (!address) throw new Error('address is required')
      const balance = await getBalance(config, {
        ...(parameters as GetBalanceParameters),
        address,
      })
      return balance ?? null
    },
    queryKey: getBalanceQueryKey(options),
  } as const satisfies QueryOptions<
    GetBalanceQueryFnData,
    GetBalanceErrorType,
    GetBalanceData,
    GetBalanceQueryKey<config>
  >
}

export type GetBalanceQueryFnData = Compute<GetBalanceReturnType>

export type GetBalanceData = GetBalanceQueryFnData

export function getBalanceQueryKey<config extends Config>(
  options: GetBalanceOptions<config> = {},
) {
  return ['balance', filterQueryOptions(options)] as const
}

export type GetBalanceQueryKey<config extends Config> = ReturnType<
  typeof getBalanceQueryKey<config>
>
</file>

<file path="packages/core/src/query/getBlock.ts">
import type { QueryOptions } from '@tanstack/query-core'
import type { BlockTag } from 'viem'

import {
  type GetBlockErrorType,
  type GetBlockParameters,
  type GetBlockReturnType,
  getBlock,
} from '../actions/getBlock.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetBlockOptions<
  includeTransactions extends boolean,
  blockTag extends BlockTag,
  config extends Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = Compute<
  ExactPartial<
    GetBlockParameters<includeTransactions, blockTag, config, chainId>
  > &
    ScopeKeyParameter
>

export function getBlockQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
  includeTransactions extends boolean,
  blockTag extends BlockTag,
>(
  config: config,
  options: GetBlockOptions<includeTransactions, blockTag, config, chainId> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const block = await getBlock(config, parameters)
      return (block ?? null) as any
    },
    queryKey: getBlockQueryKey(options),
  } as const satisfies QueryOptions<
    GetBlockQueryFnData<includeTransactions, blockTag, config, chainId>,
    GetBlockErrorType,
    GetBlockData<includeTransactions, blockTag, config, chainId>,
    GetBlockQueryKey<includeTransactions, blockTag, config, chainId>
  >
}

export type GetBlockQueryFnData<
  includeTransactions extends boolean,
  blockTag extends BlockTag,
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetBlockReturnType<includeTransactions, blockTag, config, chainId>

export type GetBlockData<
  includeTransactions extends boolean,
  blockTag extends BlockTag,
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetBlockQueryFnData<includeTransactions, blockTag, config, chainId>

export function getBlockQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
>(
  options: GetBlockOptions<includeTransactions, blockTag, config, chainId> = {},
) {
  return ['block', filterQueryOptions(options)] as const
}

export type GetBlockQueryKey<
  includeTransactions extends boolean,
  blockTag extends BlockTag,
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<
  typeof getBlockQueryKey<config, chainId, includeTransactions, blockTag>
>
</file>

<file path="packages/core/src/query/getBlockNumber.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetBlockNumberErrorType,
  type GetBlockNumberParameters,
  type GetBlockNumberReturnType,
  getBlockNumber,
} from '../actions/getBlockNumber.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetBlockNumberOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<GetBlockNumberParameters<config, chainId>> & ScopeKeyParameter
>

export function getBlockNumberQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetBlockNumberOptions<config, chainId> = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const blockNumber = await getBlockNumber(config, parameters)
      return blockNumber ?? null
    },
    queryKey: getBlockNumberQueryKey(options),
  } as const satisfies QueryOptions<
    GetBlockNumberQueryFnData,
    GetBlockNumberErrorType,
    GetBlockNumberData,
    GetBlockNumberQueryKey<config, chainId>
  >
}

export type GetBlockNumberQueryFnData = GetBlockNumberReturnType

export type GetBlockNumberData = GetBlockNumberQueryFnData

export function getBlockNumberQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetBlockNumberOptions<config, chainId> = {}) {
  return ['blockNumber', filterQueryOptions(options)] as const
}

export type GetBlockNumberQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getBlockNumberQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getBlockTransactionCount.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetBlockTransactionCountErrorType,
  type GetBlockTransactionCountParameters,
  type GetBlockTransactionCountReturnType,
  getBlockTransactionCount,
} from '../actions/getBlockTransactionCount.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { ExactPartial, UnionCompute } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetBlockTransactionCountOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = UnionCompute<
  ExactPartial<GetBlockTransactionCountParameters<config, chainId>> &
    ScopeKeyParameter
>

export function getBlockTransactionCountQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  options: GetBlockTransactionCountOptions<config, chainId> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const blockTransactionCount = await getBlockTransactionCount(
        config,
        parameters,
      )
      return blockTransactionCount ?? null
    },
    queryKey: getBlockTransactionCountQueryKey(options),
  } as const satisfies QueryOptions<
    GetBlockTransactionCountQueryFnData,
    GetBlockTransactionCountErrorType,
    GetBlockTransactionCountData,
    GetBlockTransactionCountQueryKey<config, chainId>
  >
}

export type GetBlockTransactionCountQueryFnData =
  GetBlockTransactionCountReturnType

export type GetBlockTransactionCountData = GetBlockTransactionCountQueryFnData

export function getBlockTransactionCountQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetBlockTransactionCountOptions<config, chainId> = {}) {
  return ['blockTransactionCount', filterQueryOptions(options)] as const
}

export type GetBlockTransactionCountQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getBlockTransactionCountQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getBytecode.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetBytecodeErrorType,
  type GetBytecodeParameters,
  type GetBytecodeReturnType,
  getBytecode,
} from '../actions/getBytecode.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetBytecodeOptions<config extends Config> = Compute<
  ExactPartial<GetBytecodeParameters<config>> & ScopeKeyParameter
>

export function getBytecodeQueryOptions<config extends Config>(
  config: config,
  options: GetBytecodeOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _, ...parameters } = queryKey[1]
      if (!address) throw new Error('address is required')
      const bytecode = await getBytecode(config, { ...parameters, address })
      return (bytecode ?? null) as any
    },
    queryKey: getBytecodeQueryKey(options),
  } as const satisfies QueryOptions<
    GetBytecodeQueryFnData,
    GetBytecodeErrorType,
    GetBytecodeData,
    GetBytecodeQueryKey<config>
  >
}
export type GetBytecodeQueryFnData = GetBytecodeReturnType

export type GetBytecodeData = GetBytecodeQueryFnData

export function getBytecodeQueryKey<config extends Config>(
  options: GetBytecodeOptions<config>,
) {
  return ['getBytecode', filterQueryOptions(options)] as const
}

export type GetBytecodeQueryKey<config extends Config> = ReturnType<
  typeof getBytecodeQueryKey<config>
>
</file>

<file path="packages/core/src/query/getCallsStatus.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetCallsStatusErrorType,
  type GetCallsStatusParameters,
  type GetCallsStatusReturnType,
  getCallsStatus,
} from '../actions/getCallsStatus.js'
import type { Config } from '../createConfig.js'
import { ConnectorNotConnectedError } from '../errors/config.js'
import { filterQueryOptions } from '../query/utils.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute } from '../types/utils.js'

export type GetCallsStatusOptions = Compute<
  GetCallsStatusParameters & ScopeKeyParameter
>

export function getCallsStatusQueryOptions<config extends Config>(
  config: config,
  options: GetCallsStatusOptions,
) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const status = await getCallsStatus(config, parameters)
      return status
    },
    queryKey: getCallsStatusQueryKey(options),
    retry(failureCount, error) {
      if (error instanceof ConnectorNotConnectedError) return false
      return failureCount < 3
    },
  } as const satisfies QueryOptions<
    GetCallsStatusQueryFnData,
    GetCallsStatusErrorType,
    GetCallsStatusData,
    GetCallsStatusQueryKey
  >
}

export type GetCallsStatusQueryFnData = GetCallsStatusReturnType

export type GetCallsStatusData = GetCallsStatusQueryFnData

export function getCallsStatusQueryKey(options: GetCallsStatusOptions) {
  return ['callsStatus', filterQueryOptions(options)] as const
}

export type GetCallsStatusQueryKey = ReturnType<typeof getCallsStatusQueryKey>
</file>

<file path="packages/core/src/query/getCapabilities.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetCapabilitiesErrorType,
  type GetCapabilitiesParameters,
  type GetCapabilitiesReturnType,
  getCapabilities,
} from '../actions/getCapabilities.js'
import type { Config } from '../createConfig.js'
import { ConnectorNotConnectedError } from '../errors/config.js'
import { filterQueryOptions } from '../query/utils.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'

export type GetCapabilitiesOptions<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = Compute<
  ExactPartial<GetCapabilitiesParameters<config, chainId>> & ScopeKeyParameter
>

export function getCapabilitiesQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
>(config: config, options: GetCapabilitiesOptions<config, chainId> = {}) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const capabilities = await getCapabilities(config, parameters)
      return capabilities
    },
    queryKey: getCapabilitiesQueryKey(options),
    retry(failureCount, error) {
      if (error instanceof ConnectorNotConnectedError) return false
      return failureCount < 3
    },
  } as const satisfies QueryOptions<
    GetCapabilitiesQueryFnData<config, chainId>,
    GetCapabilitiesErrorType,
    GetCapabilitiesData<config, chainId>,
    GetCapabilitiesQueryKey<config, chainId>
  >
}

export type GetCapabilitiesQueryFnData<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = GetCapabilitiesReturnType<config, chainId>

export type GetCapabilitiesData<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = GetCapabilitiesQueryFnData<config, chainId>

export function getCapabilitiesQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
>(options: GetCapabilitiesOptions<config, chainId> = {}) {
  return ['capabilities', filterQueryOptions(options)] as const
}

export type GetCapabilitiesQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = ReturnType<typeof getCapabilitiesQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getConnectorClient.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetConnectorClientErrorType,
  type GetConnectorClientParameters,
  type GetConnectorClientReturnType,
  getConnectorClient,
} from '../actions/getConnectorClient.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetConnectorClientOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<GetConnectorClientParameters<config, chainId>> &
    ScopeKeyParameter
>

export function getConnectorClientQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetConnectorClientOptions<config, chainId> = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey }) {
      const { connector } = options
      const { connectorUid: _, scopeKey: _s, ...parameters } = queryKey[1]
      return getConnectorClient(config, {
        ...parameters,
        connector,
      }) as unknown as Promise<GetConnectorClientReturnType<config, chainId>>
    },
    queryKey: getConnectorClientQueryKey(options),
  } as const satisfies QueryOptions<
    GetConnectorClientQueryFnData<config, chainId>,
    GetConnectorClientErrorType,
    GetConnectorClientData<config, chainId>,
    GetConnectorClientQueryKey<config, chainId>
  >
}

export type GetConnectorClientQueryFnData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetConnectorClientReturnType<config, chainId>

export type GetConnectorClientData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetConnectorClientQueryFnData<config, chainId>

export function getConnectorClientQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetConnectorClientOptions<config, chainId> = {}) {
  const { connector, ...parameters } = options
  return [
    'connectorClient',
    { ...filterQueryOptions(parameters), connectorUid: connector?.uid },
  ] as const
}

export type GetConnectorClientQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getConnectorClientQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getEnsAddress.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetEnsAddressErrorType,
  type GetEnsAddressParameters,
  type GetEnsAddressReturnType,
  getEnsAddress,
} from '../actions/getEnsAddress.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetEnsAddressOptions<config extends Config> = Compute<
  ExactPartial<GetEnsAddressParameters<config>> & ScopeKeyParameter
>

export function getEnsAddressQueryOptions<config extends Config>(
  config: config,
  options: GetEnsAddressOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { name, scopeKey: _, ...parameters } = queryKey[1]
      if (!name) throw new Error('name is required')
      return getEnsAddress(config, { ...parameters, name })
    },
    queryKey: getEnsAddressQueryKey(options),
  } as const satisfies QueryOptions<
    GetEnsAddressQueryFnData,
    GetEnsAddressErrorType,
    GetEnsAddressData,
    GetEnsAddressQueryKey<config>
  >
}

export type GetEnsAddressQueryFnData = GetEnsAddressReturnType

export type GetEnsAddressData = GetEnsAddressQueryFnData

export function getEnsAddressQueryKey<config extends Config>(
  options: GetEnsAddressOptions<config> = {},
) {
  return ['ensAddress', filterQueryOptions(options)] as const
}

export type GetEnsAddressQueryKey<config extends Config> = ReturnType<
  typeof getEnsAddressQueryKey<config>
>
</file>

<file path="packages/core/src/query/getEnsAvatar.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetEnsAvatarErrorType,
  type GetEnsAvatarParameters,
  type GetEnsAvatarReturnType,
  getEnsAvatar,
} from '../actions/getEnsAvatar.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetEnsAvatarOptions<config extends Config> = Compute<
  ExactPartial<GetEnsAvatarParameters<config>> & ScopeKeyParameter
>

export function getEnsAvatarQueryOptions<config extends Config>(
  config: config,
  options: GetEnsAvatarOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { name, scopeKey: _, ...parameters } = queryKey[1]
      if (!name) throw new Error('name is required')
      return getEnsAvatar(config, { ...parameters, name })
    },
    queryKey: getEnsAvatarQueryKey(options),
  } as const satisfies QueryOptions<
    GetEnsAvatarQueryFnData,
    GetEnsAvatarErrorType,
    GetEnsAvatarData,
    GetEnsAvatarQueryKey<config>
  >
}

export type GetEnsAvatarQueryFnData = GetEnsAvatarReturnType

export type GetEnsAvatarData = GetEnsAvatarQueryFnData

export function getEnsAvatarQueryKey<config extends Config>(
  options: GetEnsAvatarOptions<config> = {},
) {
  return ['ensAvatar', filterQueryOptions(options)] as const
}

export type GetEnsAvatarQueryKey<config extends Config> = ReturnType<
  typeof getEnsAvatarQueryKey<config>
>
</file>

<file path="packages/core/src/query/getEnsName.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetEnsNameErrorType,
  type GetEnsNameParameters,
  type GetEnsNameReturnType,
  getEnsName,
} from '../actions/getEnsName.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetEnsNameOptions<config extends Config> = Compute<
  ExactPartial<GetEnsNameParameters<config>> & ScopeKeyParameter
>

export function getEnsNameQueryOptions<config extends Config>(
  config: config,
  options: GetEnsNameOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _, ...parameters } = queryKey[1]
      if (!address) throw new Error('address is required')
      return getEnsName(config, { ...parameters, address })
    },
    queryKey: getEnsNameQueryKey(options),
  } as const satisfies QueryOptions<
    GetEnsNameQueryFnData,
    GetEnsNameErrorType,
    GetEnsNameData,
    GetEnsNameQueryKey<config>
  >
}

export type GetEnsNameQueryFnData = GetEnsNameReturnType

export type GetEnsNameData = GetEnsNameQueryFnData

export function getEnsNameQueryKey<config extends Config>(
  options: GetEnsNameOptions<config> = {},
) {
  return ['ensName', filterQueryOptions(options)] as const
}

export type GetEnsNameQueryKey<config extends Config> = ReturnType<
  typeof getEnsNameQueryKey<config>
>
</file>

<file path="packages/core/src/query/getEnsResolver.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetEnsResolverErrorType,
  type GetEnsResolverParameters,
  type GetEnsResolverReturnType,
  getEnsResolver,
} from '../actions/getEnsResolver.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetEnsResolverOptions<config extends Config> = Compute<
  ExactPartial<GetEnsResolverParameters<config>> & ScopeKeyParameter
>

export function getEnsResolverQueryOptions<config extends Config>(
  config: config,
  options: GetEnsResolverOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { name, scopeKey: _, ...parameters } = queryKey[1]
      if (!name) throw new Error('name is required')
      return getEnsResolver(config, { ...parameters, name })
    },
    queryKey: getEnsResolverQueryKey(options),
  } as const satisfies QueryOptions<
    GetEnsResolverQueryFnData,
    GetEnsResolverErrorType,
    GetEnsResolverData,
    GetEnsResolverQueryKey<config>
  >
}

export type GetEnsResolverQueryFnData = GetEnsResolverReturnType

export type GetEnsResolverData = GetEnsResolverQueryFnData

export function getEnsResolverQueryKey<config extends Config>(
  options: GetEnsResolverOptions<config> = {},
) {
  return ['ensResolver', filterQueryOptions(options)] as const
}

export type GetEnsResolverQueryKey<config extends Config> = ReturnType<
  typeof getEnsResolverQueryKey<config>
>
</file>

<file path="packages/core/src/query/getEnsText.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetEnsTextErrorType,
  type GetEnsTextParameters,
  type GetEnsTextReturnType,
  getEnsText,
} from '../actions/getEnsText.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetEnsTextOptions<config extends Config> = Compute<
  ExactPartial<GetEnsTextParameters<config>> & ScopeKeyParameter
>

export function getEnsTextQueryOptions<config extends Config>(
  config: config,
  options: GetEnsTextOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { key, name, scopeKey: _, ...parameters } = queryKey[1]
      if (!key || !name) throw new Error('key and name are required')
      return getEnsText(config, { ...parameters, key, name })
    },
    queryKey: getEnsTextQueryKey(options),
  } as const satisfies QueryOptions<
    GetEnsTextQueryFnData,
    GetEnsTextErrorType,
    GetEnsTextData,
    GetEnsTextQueryKey<config>
  >
}

export type GetEnsTextQueryFnData = GetEnsTextReturnType

export type GetEnsTextData = GetEnsTextQueryFnData

export function getEnsTextQueryKey<config extends Config>(
  options: GetEnsTextOptions<config> = {},
) {
  return ['ensText', filterQueryOptions(options)] as const
}

export type GetEnsTextQueryKey<config extends Config> = ReturnType<
  typeof getEnsTextQueryKey<config>
>
</file>

<file path="packages/core/src/query/getFeeHistory.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetFeeHistoryErrorType,
  type GetFeeHistoryParameters,
  type GetFeeHistoryReturnType,
  getFeeHistory,
} from '../actions/getFeeHistory.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, PartialBy } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetFeeHistoryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  PartialBy<
    GetFeeHistoryParameters<config, chainId>,
    'blockCount' | 'rewardPercentiles'
  > &
    ScopeKeyParameter
>

export function getFeeHistoryQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetFeeHistoryOptions<config, chainId> = {}) {
  return {
    async queryFn({ queryKey }) {
      const {
        blockCount,
        rewardPercentiles,
        scopeKey: _,
        ...parameters
      } = queryKey[1]
      if (!blockCount) throw new Error('blockCount is required')
      if (!rewardPercentiles) throw new Error('rewardPercentiles is required')
      const feeHistory = await getFeeHistory(config, {
        ...(parameters as GetFeeHistoryParameters),
        blockCount,
        rewardPercentiles,
      })
      return feeHistory ?? null
    },
    queryKey: getFeeHistoryQueryKey(options),
  } as const satisfies QueryOptions<
    GetFeeHistoryQueryFnData,
    GetFeeHistoryErrorType,
    GetFeeHistoryData,
    GetFeeHistoryQueryKey<config, chainId>
  >
}

export type GetFeeHistoryQueryFnData = GetFeeHistoryReturnType

export type GetFeeHistoryData = GetFeeHistoryQueryFnData

export function getFeeHistoryQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetFeeHistoryOptions<config, chainId> = {}) {
  return ['feeHistory', filterQueryOptions(options)] as const
}

export type GetFeeHistoryQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getFeeHistoryQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getGasPrice.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetGasPriceErrorType,
  type GetGasPriceParameters,
  type GetGasPriceReturnType,
  getGasPrice,
} from '../actions/getGasPrice.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetGasPriceOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<GetGasPriceParameters<config, chainId>> & ScopeKeyParameter
>

export function getGasPriceQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetGasPriceOptions<config, chainId> = {}) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, ...parameters } = queryKey[1]
      const gasPrice = await getGasPrice(config, parameters)
      return gasPrice ?? null
    },
    queryKey: getGasPriceQueryKey(options),
  } as const satisfies QueryOptions<
    GetGasPriceQueryFnData,
    GetGasPriceErrorType,
    GetGasPriceData,
    GetGasPriceQueryKey<config, chainId>
  >
}

export type GetGasPriceQueryFnData = GetGasPriceReturnType

export type GetGasPriceData = GetGasPriceQueryFnData

export function getGasPriceQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetGasPriceOptions<config, chainId> = {}) {
  return ['gasPrice', filterQueryOptions(options)] as const
}

export type GetGasPriceQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getGasPriceQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getProof.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetProofErrorType,
  type GetProofParameters,
  type GetProofReturnType,
  getProof,
} from '../actions/getProof.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetProofOptions<config extends Config> = Compute<
  ExactPartial<GetProofParameters<config>> & ScopeKeyParameter
>

export function getProofQueryOptions<config extends Config>(
  config: config,
  options: GetProofOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _, storageKeys, ...parameters } = queryKey[1]
      if (!address || !storageKeys)
        throw new Error('address and storageKeys are required')
      return getProof(config, { ...parameters, address, storageKeys })
    },
    queryKey: getProofQueryKey(options),
  } as const satisfies QueryOptions<
    GetProofQueryFnData,
    GetProofErrorType,
    GetProofData,
    GetProofQueryKey<config>
  >
}

export type GetProofQueryFnData = GetProofReturnType

export type GetProofData = GetProofQueryFnData

export function getProofQueryKey<config extends Config>(
  options: GetProofOptions<config>,
) {
  return ['getProof', filterQueryOptions(options)] as const
}

export type GetProofQueryKey<config extends Config> = ReturnType<
  typeof getProofQueryKey<config>
>
</file>

<file path="packages/core/src/query/getStorageAt.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetStorageAtErrorType,
  type GetStorageAtParameters,
  type GetStorageAtReturnType,
  getStorageAt,
} from '../actions/getStorageAt.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetStorageAtOptions<config extends Config> = Compute<
  ExactPartial<GetStorageAtParameters<config>> & ScopeKeyParameter
>

export function getStorageAtQueryOptions<config extends Config>(
  config: config,
  options: GetStorageAtOptions<config> = {},
) {
  return {
    queryFn({ queryKey }) {
      const { address, slot, scopeKey: _, ...parameters } = queryKey[1]
      if (!address || !slot) throw new Error('address and slot are required')
      return getStorageAt(config, { ...parameters, address, slot })
    },
    queryKey: getStorageAtQueryKey(options),
  } as const satisfies QueryOptions<
    GetStorageAtQueryFnData,
    GetStorageAtErrorType,
    GetStorageAtData,
    GetStorageAtQueryKey<config>
  >
}

export type GetStorageAtQueryFnData = GetStorageAtReturnType

export type GetStorageAtData = GetStorageAtQueryFnData

export function getStorageAtQueryKey<config extends Config>(
  options: GetStorageAtOptions<config>,
) {
  return ['getStorageAt', filterQueryOptions(options)] as const
}

export type GetStorageAtQueryKey<config extends Config> = ReturnType<
  typeof getStorageAtQueryKey<config>
>
</file>

<file path="packages/core/src/query/getToken.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetTokenErrorType,
  type GetTokenParameters,
  type GetTokenReturnType,
  getToken,
} from '../actions/getToken.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetTokenOptions<config extends Config> = Compute<
  ExactPartial<GetTokenParameters<config>> & ScopeKeyParameter
>

export function getTokenQueryOptions<config extends Config>(
  config: config,
  options: GetTokenOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _, ...parameters } = queryKey[1]
      if (!address) throw new Error('address is required')
      return getToken(config, { ...parameters, address })
    },
    queryKey: getTokenQueryKey(options),
  } as const satisfies QueryOptions<
    GetTokenQueryFnData,
    GetTokenErrorType,
    GetTokenData,
    GetTokenQueryKey<config>
  >
}

export type GetTokenQueryFnData = GetTokenReturnType

export type GetTokenData = GetTokenQueryFnData

export function getTokenQueryKey<config extends Config>(
  options: GetTokenOptions<config> = {},
) {
  return ['token', filterQueryOptions(options)] as const
}

export type GetTokenQueryKey<config extends Config> = ReturnType<
  typeof getTokenQueryKey<config>
>
</file>

<file path="packages/core/src/query/getTransaction.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetTransactionErrorType,
  type GetTransactionParameters,
  type GetTransactionReturnType,
  getTransaction,
} from '../actions/getTransaction.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetTransactionOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<GetTransactionParameters<config, chainId>> & ScopeKeyParameter
>

export function getTransactionQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetTransactionOptions<config, chainId> = {}) {
  return {
    async queryFn({ queryKey }) {
      const { blockHash, blockNumber, blockTag, hash, index } = queryKey[1]
      if (!blockHash && !blockNumber && !blockTag && !hash)
        throw new Error('blockHash, blockNumber, blockTag, or hash is required')
      if (!hash && !index)
        throw new Error(
          'index is required for blockHash, blockNumber, or blockTag',
        )
      const { scopeKey: _, ...rest } = queryKey[1]
      return getTransaction(
        config,
        rest as GetTransactionParameters,
      ) as unknown as Promise<GetTransactionQueryFnData<config, chainId>>
    },
    queryKey: getTransactionQueryKey(options),
  } as const satisfies QueryOptions<
    GetTransactionQueryFnData<config, chainId>,
    GetTransactionErrorType,
    GetTransactionData<config, chainId>,
    GetTransactionQueryKey<config, chainId>
  >
}

export type GetTransactionQueryFnData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetTransactionReturnType<config, chainId>

export type GetTransactionData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetTransactionQueryFnData<config, chainId>

export function getTransactionQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetTransactionOptions<config, chainId> = {}) {
  return ['transaction', filterQueryOptions(options)] as const
}

export type GetTransactionQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getTransactionQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getTransactionConfirmations.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetTransactionConfirmationsErrorType,
  type GetTransactionConfirmationsParameters,
  type GetTransactionConfirmationsReturnType,
  getTransactionConfirmations,
} from '../actions/getTransactionConfirmations.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { UnionExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetTransactionConfirmationsOptions<
  config extends Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
> = UnionExactPartial<GetTransactionConfirmationsParameters<config, chainId>> &
  ScopeKeyParameter

export function getTransactionConfirmationsQueryOptions<
  config extends Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
>(
  config: config,
  options: GetTransactionConfirmationsOptions<config, chainId> = {} as any,
) {
  return {
    async queryFn({ queryKey }) {
      const {
        hash,
        transactionReceipt,
        scopeKey: _,
        ...parameters
      } = queryKey[1]
      if (!hash && !transactionReceipt)
        throw new Error('hash or transactionReceipt is required')

      const confirmations = await getTransactionConfirmations(config, {
        hash,
        transactionReceipt,
        ...(parameters as any),
      })
      return confirmations ?? null
    },
    queryKey: getTransactionConfirmationsQueryKey(options),
  } as const satisfies QueryOptions<
    GetTransactionConfirmationsQueryFnData,
    GetTransactionConfirmationsErrorType,
    GetTransactionConfirmationsData,
    GetTransactionConfirmationsQueryKey<config, chainId>
  >
}

export type GetTransactionConfirmationsQueryFnData =
  GetTransactionConfirmationsReturnType

export type GetTransactionConfirmationsData =
  GetTransactionConfirmationsQueryFnData

export function getTransactionConfirmationsQueryKey<
  config extends Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
>(options: GetTransactionConfirmationsOptions<config, chainId> = {} as any) {
  return ['transactionConfirmations', filterQueryOptions(options)] as const
}

export type GetTransactionConfirmationsQueryKey<
  config extends Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
> = ReturnType<typeof getTransactionConfirmationsQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getTransactionCount.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetTransactionCountErrorType,
  type GetTransactionCountParameters,
  type GetTransactionCountReturnType,
  getTransactionCount,
} from '../actions/getTransactionCount.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, PartialBy } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetTransactionCountOptions<config extends Config> = Compute<
  PartialBy<GetTransactionCountParameters<config>, 'address'> &
    ScopeKeyParameter
>

export function getTransactionCountQueryOptions<config extends Config>(
  config: config,
  options: GetTransactionCountOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _, ...parameters } = queryKey[1]
      if (!address) throw new Error('address is required')
      const transactionCount = await getTransactionCount(config, {
        ...(parameters as GetTransactionCountParameters),
        address,
      })
      return transactionCount ?? null
    },
    queryKey: getTransactionCountQueryKey(options),
  } as const satisfies QueryOptions<
    GetTransactionCountQueryFnData,
    GetTransactionCountErrorType,
    GetTransactionCountData,
    GetTransactionCountQueryKey<config>
  >
}

export type GetTransactionCountQueryFnData =
  Compute<GetTransactionCountReturnType>

export type GetTransactionCountData = GetTransactionCountQueryFnData

export function getTransactionCountQueryKey<config extends Config>(
  options: GetTransactionCountOptions<config> = {},
) {
  return ['transactionCount', filterQueryOptions(options)] as const
}

export type GetTransactionCountQueryKey<config extends Config> = ReturnType<
  typeof getTransactionCountQueryKey<config>
>
</file>

<file path="packages/core/src/query/getTransactionReceipt.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetTransactionReceiptErrorType,
  type GetTransactionReceiptParameters,
  getTransactionReceipt,
} from '../actions/getTransactionReceipt.js'
import type { GetTransactionReceiptReturnType } from '../actions/getTransactionReceipt.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetTransactionReceiptOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<GetTransactionReceiptParameters<config, chainId>> &
    ScopeKeyParameter
>

export function getTransactionReceiptQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetTransactionReceiptOptions<config, chainId> = {}) {
  return {
    queryFn({ queryKey }) {
      const { hash, scopeKey: _, ...parameters } = queryKey[1]
      if (!hash) throw new Error('hash is required')
      return getTransactionReceipt(config, { ...parameters, hash })
    },
    queryKey: getTransactionReceiptQueryKey(options),
  } as const satisfies QueryOptions<
    GetTransactionReceiptQueryFnData<config, chainId>,
    GetTransactionReceiptErrorType,
    GetTransactionReceiptData<config, chainId>,
    GetTransactionReceiptQueryKey<config, chainId>
  >
}
export type GetTransactionReceiptQueryFnData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetTransactionReceiptReturnType<config, chainId>

export type GetTransactionReceiptData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetTransactionReceiptQueryFnData<config, chainId>

export function getTransactionReceiptQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetTransactionReceiptOptions<config, chainId>) {
  return ['getTransactionReceipt', filterQueryOptions(options)] as const
}

export type GetTransactionReceiptQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getTransactionReceiptQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/getWalletClient.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type GetWalletClientErrorType,
  type GetWalletClientParameters,
  type GetWalletClientReturnType,
  getWalletClient,
} from '../actions/getWalletClient.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type GetWalletClientOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<GetWalletClientParameters<config, chainId>> & ScopeKeyParameter
>

export function getWalletClientQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(config: config, options: GetWalletClientOptions<config, chainId> = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey }) {
      const { connector } = options
      const { connectorUid: _, scopeKey: _s, ...parameters } = queryKey[1]
      return getWalletClient(config, { ...parameters, connector })
    },
    queryKey: getWalletClientQueryKey(options),
  } as const satisfies QueryOptions<
    GetWalletClientQueryFnData<config, chainId>,
    GetWalletClientErrorType,
    GetWalletClientData<config, chainId>,
    GetWalletClientQueryKey<config, chainId>
  >
}

export type GetWalletClientQueryFnData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetWalletClientReturnType<config, chainId>

export type GetWalletClientData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = GetWalletClientQueryFnData<config, chainId>

export function getWalletClientQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: GetWalletClientOptions<config, chainId> = {}) {
  const { connector, ...parameters } = options
  return [
    'walletClient',
    { ...filterQueryOptions(parameters), connectorUid: connector?.uid },
  ] as const
}

export type GetWalletClientQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof getWalletClientQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/infiniteReadContracts.test-d.ts">
import { abi, config } from '@wagmi/test'
import type { MulticallResponse } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { infiniteReadContractsQueryOptions } from './infiniteReadContracts.js'

test('default', async () => {
  const options = infiniteReadContractsQueryOptions(config, {
    cacheKey: 'foo',
    contracts(pageParam) {
      expectTypeOf(pageParam).toEqualTypeOf(options.initialPageParam)
      return [
        {
          address: '0x',
          abi: abi.erc20,
          functionName: 'balanceOf',
          args: ['0x'],
        },
        {
          address: '0x',
          abi: abi.wagmiMintExample,
          functionName: 'tokenURI',
          args: [123n],
        },
      ]
    },
    query: {
      initialPageParam: 0,
      getNextPageParam(lastPage, allPages, lastPageParam, allPageParams) {
        expectTypeOf(lastPage).toEqualTypeOf<
          [MulticallResponse<bigint>, MulticallResponse<string>]
        >()
        expectTypeOf(allPages).toEqualTypeOf<
          [MulticallResponse<bigint>, MulticallResponse<string>][]
        >()
        expectTypeOf(lastPageParam).toEqualTypeOf(options.initialPageParam)
        expectTypeOf(allPageParams).toEqualTypeOf([options.initialPageParam])
        return lastPageParam + 1
      },
    },
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<
    [MulticallResponse<bigint>, MulticallResponse<string>]
  >()
})

test('allowFailure: false', async () => {
  const options = infiniteReadContractsQueryOptions(config, {
    allowFailure: false,
    cacheKey: 'foo',
    contracts(pageParam) {
      expectTypeOf(pageParam).toEqualTypeOf(options.initialPageParam)
      return [
        {
          address: '0x',
          abi: abi.erc20,
          functionName: 'balanceOf',
          args: ['0x'],
        },
        {
          address: '0x',
          abi: abi.wagmiMintExample,
          functionName: 'tokenURI',
          args: [123n],
        },
      ]
    },
    query: {
      initialPageParam: 0,
      getNextPageParam(lastPage, allPages, lastPageParam, allPageParams) {
        expectTypeOf(lastPage).toEqualTypeOf<[bigint, string]>()
        expectTypeOf(allPages).toEqualTypeOf<[bigint, string][]>()
        expectTypeOf(lastPageParam).toEqualTypeOf(options.initialPageParam)
        expectTypeOf(allPageParams).toEqualTypeOf([options.initialPageParam])
        return lastPageParam + 1
      },
    },
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<[bigint, string]>()
})

test('initialPageParam', async () => {
  const options = infiniteReadContractsQueryOptions(config, {
    allowFailure: false,
    cacheKey: 'foo',
    contracts(pageParam) {
      expectTypeOf(pageParam).toEqualTypeOf(options.initialPageParam)
      return [
        {
          address: '0x',
          abi: abi.erc20,
          functionName: 'balanceOf',
          args: ['0x'],
        },
        {
          address: '0x',
          abi: abi.wagmiMintExample,
          functionName: 'tokenURI',
          args: [123n],
        },
      ]
    },
    query: {
      initialPageParam: 'bar',
      getNextPageParam(lastPage, allPages, lastPageParam, allPageParams) {
        expectTypeOf(lastPage).toEqualTypeOf<[bigint, string]>()
        expectTypeOf(allPages).toEqualTypeOf<[bigint, string][]>()
        expectTypeOf(lastPageParam).toEqualTypeOf(options.initialPageParam)
        expectTypeOf(allPageParams).toEqualTypeOf([options.initialPageParam])
        return lastPageParam + 1
      },
    },
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<[bigint, string]>()
})

test('behavior: `contracts` after `getNextPageParam`', async () => {
  const options = infiniteReadContractsQueryOptions(config, {
    allowFailure: false,
    cacheKey: 'foo',
    query: {
      initialPageParam: 0,
      getNextPageParam(lastPage, allPages, lastPageParam, allPageParams) {
        expectTypeOf(lastPage).toEqualTypeOf<unknown[]>()
        expectTypeOf(allPages).toEqualTypeOf<unknown[][]>()
        expectTypeOf(lastPageParam).toEqualTypeOf(options.initialPageParam)
        expectTypeOf(allPageParams).toEqualTypeOf([options.initialPageParam])
        return lastPageParam + 1
      },
    },
    contracts(pageParam) {
      expectTypeOf(pageParam).toEqualTypeOf(options.initialPageParam)
      return [
        {
          address: '0x',
          abi: abi.erc20,
          functionName: 'balanceOf',
          args: ['0x'],
        },
        {
          address: '0x',
          abi: abi.wagmiMintExample,
          functionName: 'tokenURI',
          args: [123n],
        },
      ]
    },
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<unknown[]>()
})

test('overloads', async () => {
  const options = infiniteReadContractsQueryOptions(config, {
    allowFailure: false,
    cacheKey: 'foo',
    contracts(pageParam) {
      expectTypeOf(pageParam).toEqualTypeOf<number>()
      return [
        {
          address: '0x',
          abi: abi.viewOverloads,
          functionName: 'foo',
        },
        {
          address: '0x',
          abi: abi.viewOverloads,
          functionName: 'foo',
          args: ['0x'],
        },
        {
          address: '0x',
          abi: abi.viewOverloads,
          functionName: 'foo',
          args: ['0x', '0x'],
        },
      ]
    },
    query: {
      initialPageParam: 0,
      getNextPageParam(_, allPages) {
        return allPages.length + 1
      },
    },
  })

  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<
    [
      number,
      string,
      {
        foo: `0x${string}`
        bar: `0x${string}`
      },
    ]
  >()
})
</file>

<file path="packages/core/src/query/infiniteReadContracts.ts">
import type { ContractFunctionParameters } from 'viem'
import {
  type ReadContractsErrorType,
  type ReadContractsParameters,
  type ReadContractsReturnType,
  readContracts,
} from '../actions/readContracts.js'
import type { Config } from '../createConfig.js'
import type {
  ChainIdParameter,
  ScopeKeyParameter,
} from '../types/properties.js'
import type { StrictOmit } from '../types/utils.js'
import type { InfiniteQueryOptions } from './types.js'
import { filterQueryOptions } from './utils.js'

export type InfiniteReadContractsOptions<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
  pageParam,
  config extends Config,
> = {
  cacheKey: string
  contracts(
    pageParam: pageParam,
  ): ReadContractsParameters<contracts, allowFailure, config>['contracts']
} & StrictOmit<
  ReadContractsParameters<contracts, allowFailure, config>,
  'contracts'
> &
  ScopeKeyParameter

export function infiniteReadContractsQueryOptions<
  config extends Config,
  const contracts extends readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  pageParam = unknown,
>(
  config: config,
  options: InfiniteReadContractsOptions<
    contracts,
    allowFailure,
    pageParam,
    config
  > &
    ChainIdParameter<config> &
    RequiredPageParamsParameters<contracts, allowFailure, pageParam>,
) {
  return {
    ...options.query,
    async queryFn({ pageParam, queryKey }) {
      const { contracts } = options
      const { cacheKey: _, scopeKey: _s, ...parameters } = queryKey[1]
      return (await readContracts(config, {
        ...parameters,
        contracts: contracts(pageParam as any),
      })) as ReadContractsReturnType<contracts, allowFailure>
    },
    queryKey: infiniteReadContractsQueryKey(options),
  } as const satisfies InfiniteQueryOptions<
    InfiniteReadContractsQueryFnData<contracts, allowFailure>,
    ReadContractsErrorType,
    InfiniteReadContractsData<contracts, allowFailure>,
    InfiniteReadContractsData<contracts, allowFailure>,
    InfiniteReadContractsQueryKey<contracts, allowFailure, pageParam, config>,
    pageParam
  >
}

type RequiredPageParamsParameters<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
  pageParam,
> = {
  query: {
    initialPageParam: pageParam
    getNextPageParam(
      lastPage: InfiniteReadContractsQueryFnData<contracts, allowFailure>,
      allPages: InfiniteReadContractsQueryFnData<contracts, allowFailure>[],
      lastPageParam: pageParam,
      allPageParams: pageParam[],
    ): pageParam | undefined | null
  }
}

export type InfiniteReadContractsQueryFnData<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
> = ReadContractsReturnType<contracts, allowFailure>

export type InfiniteReadContractsData<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
> = InfiniteReadContractsQueryFnData<contracts, allowFailure>

export function infiniteReadContractsQueryKey<
  config extends Config,
  const contracts extends readonly unknown[],
  allowFailure extends boolean,
  pageParam,
>(
  options: InfiniteReadContractsOptions<
    contracts,
    allowFailure,
    pageParam,
    config
  > &
    ChainIdParameter<config> &
    RequiredPageParamsParameters<contracts, allowFailure, pageParam>,
) {
  const { contracts: _, query: _q, ...parameters } = options
  return ['infiniteReadContracts', filterQueryOptions(parameters)] as const
}

export type InfiniteReadContractsQueryKey<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
  pageParam,
  config extends Config,
> = ReturnType<
  typeof infiniteReadContractsQueryKey<
    config,
    contracts,
    allowFailure,
    pageParam
  >
>
</file>

<file path="packages/core/src/query/prepareTransactionRequest.ts">
import type { QueryOptions } from '@tanstack/query-core'

import type { PrepareTransactionRequestRequest as viem_PrepareTransactionRequestRequest } from 'viem'

import {
  type PrepareTransactionRequestErrorType,
  type PrepareTransactionRequestParameters,
  type PrepareTransactionRequestReturnType,
  prepareTransactionRequest,
} from '../actions/prepareTransactionRequest.js'
import type { Config } from '../createConfig.js'
import type { SelectChains } from '../types/chain.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { UnionExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type PrepareTransactionRequestOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
> = UnionExactPartial<
  PrepareTransactionRequestParameters<config, chainId, request>
> &
  ScopeKeyParameter

export function prepareTransactionRequestQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
>(
  config: config,
  options: PrepareTransactionRequestOptions<
    config,
    chainId,
    request
  > = {} as any,
) {
  return {
    queryFn({ queryKey }) {
      const { scopeKey: _, to, ...parameters } = queryKey[1]
      if (!to) throw new Error('to is required')
      return prepareTransactionRequest(config, {
        to,
        ...(parameters as any),
      }) as unknown as Promise<
        PrepareTransactionRequestQueryFnData<config, chainId, request>
      >
    },
    queryKey: prepareTransactionRequestQueryKey(options),
  } as const satisfies QueryOptions<
    PrepareTransactionRequestQueryFnData<config, chainId, request>,
    PrepareTransactionRequestErrorType,
    PrepareTransactionRequestData<config, chainId, request>,
    PrepareTransactionRequestQueryKey<config, chainId, request>
  >
}
export type PrepareTransactionRequestQueryFnData<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
> = PrepareTransactionRequestReturnType<config, chainId, request>

export type PrepareTransactionRequestData<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
> = PrepareTransactionRequestQueryFnData<config, chainId, request>

export function prepareTransactionRequestQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
>(options: PrepareTransactionRequestOptions<config, chainId, request>) {
  return ['prepareTransactionRequest', filterQueryOptions(options)] as const
}

export type PrepareTransactionRequestQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
> = ReturnType<
  typeof prepareTransactionRequestQueryKey<config, chainId, request>
>
</file>

<file path="packages/core/src/query/readContract.test-d.ts">
import { abi, config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { readContractQueryOptions } from './readContract.js'

test('default', async () => {
  const options = readContractQueryOptions(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'balanceOf',
    args: ['0x'],
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<bigint>()
})
</file>

<file path="packages/core/src/query/readContract.ts">
import type { QueryOptions } from '@tanstack/query-core'
import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'

import {
  type ReadContractErrorType,
  type ReadContractParameters,
  type ReadContractReturnType,
  readContract,
} from '../actions/readContract.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { UnionExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type ReadContractOptions<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  config extends Config,
> = UnionExactPartial<ReadContractParameters<abi, functionName, args, config>> &
  ScopeKeyParameter

export function readContractQueryOptions<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
>(
  config: config,
  options: ReadContractOptions<abi, functionName, args, config> = {} as any,
) {
  return {
    // TODO: Support `signal` once Viem actions allow passthrough
    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation
    async queryFn({ queryKey }) {
      const abi = options.abi as Abi
      if (!abi) throw new Error('abi is required')

      const { functionName, scopeKey: _, ...parameters } = queryKey[1]
      const addressOrCodeParams = (() => {
        const params = queryKey[1] as unknown as ReadContractParameters
        if (params.address) return { address: params.address }
        if (params.code) return { code: params.code }
        throw new Error('address or code is required')
      })()

      if (!functionName) throw new Error('functionName is required')

      return readContract(config, {
        abi,
        functionName,
        args: parameters.args as readonly unknown[],
        ...addressOrCodeParams,
        ...parameters,
      }) as Promise<ReadContractData<abi, functionName, args>>
    },
    queryKey: readContractQueryKey(options as any) as any,
  } as const satisfies QueryOptions<
    ReadContractQueryFnData<abi, functionName, args>,
    ReadContractErrorType,
    ReadContractData<abi, functionName, args>,
    ReadContractQueryKey<abi, functionName, args, config>
  >
}

export type ReadContractQueryFnData<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
> = ReadContractReturnType<abi, functionName, args>

export type ReadContractData<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
> = ReadContractQueryFnData<abi, functionName, args>

export function readContractQueryKey<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
>(options: ReadContractOptions<abi, functionName, args, config> = {} as any) {
  const { abi: _, ...rest } = options
  return ['readContract', filterQueryOptions(rest)] as const
}

export type ReadContractQueryKey<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  config extends Config,
> = ReturnType<typeof readContractQueryKey<config, abi, functionName, args>>
</file>

<file path="packages/core/src/query/readContracts.test-d.ts">
import { abi, config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { readContractsQueryOptions } from './readContracts.js'

test('default', async () => {
  const options = readContractsQueryOptions(config, {
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<
    [
      (
        | { error: Error; result?: undefined; status: 'failure' }
        | { error?: undefined; result: bigint; status: 'success' }
      ),
      (
        | { error: Error; result?: undefined; status: 'failure' }
        | { error?: undefined; result: string; status: 'success' }
      ),
    ]
  >()
})

test('allowFailure: false', async () => {
  const options = readContractsQueryOptions(config, {
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
  })
  const result = await options.queryFn({} as any)
  expectTypeOf(result).toEqualTypeOf<[bigint, string]>()
})
</file>

<file path="packages/core/src/query/readContracts.ts">
import type { QueryOptions } from '@tanstack/query-core'
import type {
  ContractFunctionParameters,
  MulticallParameters as viem_MulticallParameters,
} from 'viem'

import {
  type ReadContractsErrorType,
  type ReadContractsReturnType,
  readContracts,
} from '../actions/readContracts.js'
import type { Config } from '../createConfig.js'
import type { ChainIdParameter } from '../types/properties.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type ReadContractsOptions<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
  config extends Config,
> = ExactPartial<
  viem_MulticallParameters<
    contracts,
    allowFailure,
    { optional: true; properties: ChainIdParameter<config> }
  >
> &
  ScopeKeyParameter

export function readContractsQueryOptions<
  config extends Config,
  const contracts extends readonly unknown[],
  allowFailure extends boolean = true,
>(
  config: config,
  options: ReadContractsOptions<contracts, allowFailure, config> &
    ChainIdParameter<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const contracts: ContractFunctionParameters[] = []
      const length = queryKey[1].contracts.length
      for (let i = 0; i < length; i++) {
        const contract = queryKey[1].contracts[i]!
        const abi = (options.contracts?.[i] as ContractFunctionParameters).abi
        contracts.push({ ...contract, abi })
      }
      const { scopeKey: _, ...parameters } = queryKey[1]
      return readContracts(config, {
        ...parameters,
        contracts,
      }) as Promise<ReadContractsReturnType<contracts, allowFailure>>
    },
    queryKey: readContractsQueryKey(options),
  } as const satisfies QueryOptions<
    ReadContractsQueryFnData<contracts, allowFailure>,
    ReadContractsErrorType,
    ReadContractsData<contracts, allowFailure>,
    ReadContractsQueryKey<contracts, allowFailure, config>
  >
}

export type ReadContractsQueryFnData<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
> = ReadContractsReturnType<contracts, allowFailure>

export type ReadContractsData<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
> = ReadContractsQueryFnData<contracts, allowFailure>

export function readContractsQueryKey<
  config extends Config,
  const contracts extends readonly unknown[],
  allowFailure extends boolean,
>(
  options: ReadContractsOptions<contracts, allowFailure, config> &
    ChainIdParameter<config> = {},
) {
  const contracts = []
  for (const contract of (options.contracts ??
    []) as (ContractFunctionParameters & { chainId: number })[]) {
    const { abi: _, ...rest } = contract
    contracts.push({ ...rest, chainId: rest.chainId ?? options.chainId })
  }
  return [
    'readContracts',
    filterQueryOptions({ ...options, contracts }),
  ] as const
}

export type ReadContractsQueryKey<
  contracts extends readonly unknown[],
  allowFailure extends boolean,
  config extends Config,
> = ReturnType<typeof readContractsQueryKey<config, contracts, allowFailure>>
</file>

<file path="packages/core/src/query/reconnect.ts">
import type { MutationOptions } from '@tanstack/query-core'

import {
  type ReconnectErrorType,
  type ReconnectParameters,
  type ReconnectReturnType,
  reconnect,
} from '../actions/reconnect.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'
import type { Mutate, MutateAsync } from './types.js'

export function reconnectMutationOptions(config: Config) {
  return {
    mutationFn(variables) {
      return reconnect(config, variables)
    },
    mutationKey: ['reconnect'],
  } as const satisfies MutationOptions<
    ReconnectData,
    ReconnectErrorType,
    ReconnectVariables
  >
}

export type ReconnectData = Compute<ReconnectReturnType>

export type ReconnectVariables = ReconnectParameters | undefined

export type ReconnectMutate<context = unknown> = Mutate<
  ReconnectData,
  ReconnectErrorType,
  ReconnectVariables,
  context
>

export type ReconnectMutateAsync<context = unknown> = MutateAsync<
  ReconnectData,
  ReconnectErrorType,
  ReconnectVariables,
  context
>
</file>

<file path="packages/core/src/query/sendCalls.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import {
  type SendCallsErrorType,
  type SendCallsParameters,
  type SendCallsReturnType,
  sendCalls,
} from '../actions/sendCalls.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function sendCallsMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return sendCalls(config, variables)
    },
    mutationKey: ['sendCalls'],
  } as const satisfies MutationOptions<
    SendCallsData,
    SendCallsErrorType,
    SendCallsVariables<config, config['chains'][number]['id']>
  >
}

export type SendCallsData = Compute<SendCallsReturnType>

export type SendCallsVariables<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = SendCallsParameters<config, chainId>

export type SendCallsMutate<config extends Config, context = unknown> = <
  chainId extends config['chains'][number]['id'],
>(
  variables: SendCallsVariables<config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          SendCallsData,
          SendCallsErrorType,
          Compute<SendCallsVariables<config, chainId>>,
          context
        >
      >
    | undefined,
) => void

export type SendCallsMutateAsync<config extends Config, context = unknown> = <
  chainId extends config['chains'][number]['id'],
>(
  variables: SendCallsVariables<config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          SendCallsData,
          SendCallsErrorType,
          Compute<SendCallsVariables<config, chainId>>,
          context
        >
      >
    | undefined,
) => Promise<SendCallsData>
</file>

<file path="packages/core/src/query/sendTransaction.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import {
  type SendTransactionErrorType,
  type SendTransactionParameters,
  type SendTransactionReturnType,
  sendTransaction,
} from '../actions/sendTransaction.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function sendTransactionMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return sendTransaction(config, variables)
    },
    mutationKey: ['sendTransaction'],
  } as const satisfies MutationOptions<
    SendTransactionData,
    SendTransactionErrorType,
    SendTransactionVariables<config, config['chains'][number]['id']>
  >
}

export type SendTransactionData = Compute<SendTransactionReturnType>

export type SendTransactionVariables<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = SendTransactionParameters<config, chainId>

export type SendTransactionMutate<config extends Config, context = unknown> = <
  chainId extends config['chains'][number]['id'],
>(
  variables: SendTransactionVariables<config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          SendTransactionData,
          SendTransactionErrorType,
          Compute<SendTransactionVariables<config, chainId>>,
          context
        >
      >
    | undefined,
) => void

export type SendTransactionMutateAsync<
  config extends Config,
  context = unknown,
> = <chainId extends config['chains'][number]['id']>(
  variables: SendTransactionVariables<config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          SendTransactionData,
          SendTransactionErrorType,
          Compute<SendTransactionVariables<config, chainId>>,
          context
        >
      >
    | undefined,
) => Promise<SendTransactionData>
</file>

<file path="packages/core/src/query/showCallsStatus.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import {
  type ShowCallsStatusErrorType,
  type ShowCallsStatusParameters,
  type ShowCallsStatusReturnType,
  showCallsStatus,
} from '../actions/showCallsStatus.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function showCallsStatusMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return showCallsStatus(config, variables)
    },
    mutationKey: ['showCallsStatus'],
  } as const satisfies MutationOptions<
    ShowCallsStatusData,
    ShowCallsStatusErrorType,
    ShowCallsStatusVariables
  >
}

export type ShowCallsStatusData = Compute<ShowCallsStatusReturnType>

export type ShowCallsStatusVariables = ShowCallsStatusParameters

export type ShowCallsStatusMutate<context = unknown> = (
  variables: ShowCallsStatusVariables,
  options?:
    | Compute<
        MutateOptions<
          ShowCallsStatusData,
          ShowCallsStatusErrorType,
          Compute<ShowCallsStatusVariables>,
          context
        >
      >
    | undefined,
) => void

export type ShowCallsStatusMutateAsync<context = unknown> = (
  variables: ShowCallsStatusVariables,
  options?:
    | Compute<
        MutateOptions<
          ShowCallsStatusData,
          ShowCallsStatusErrorType,
          Compute<ShowCallsStatusVariables>,
          context
        >
      >
    | undefined,
) => Promise<ShowCallsStatusData>
</file>

<file path="packages/core/src/query/signMessage.ts">
import type { MutationOptions } from '@tanstack/query-core'

import {
  type SignMessageErrorType,
  type SignMessageParameters,
  type SignMessageReturnType,
  signMessage,
} from '../actions/signMessage.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'
import type { Mutate, MutateAsync } from './types.js'

export function signMessageMutationOptions(config: Config) {
  return {
    mutationFn(variables) {
      return signMessage(config, variables)
    },
    mutationKey: ['signMessage'],
  } as const satisfies MutationOptions<
    SignMessageData,
    SignMessageErrorType,
    SignMessageVariables
  >
}

export type SignMessageData = SignMessageReturnType

export type SignMessageVariables = Compute<SignMessageParameters>

export type SignMessageMutate<context = unknown> = Mutate<
  SignMessageData,
  SignMessageErrorType,
  SignMessageVariables,
  context
>

export type SignMessageMutateAsync<context = unknown> = MutateAsync<
  SignMessageData,
  SignMessageErrorType,
  SignMessageVariables,
  context
>
</file>

<file path="packages/core/src/query/signTypedData.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import type { TypedData } from 'viem'
import {
  type SignTypedDataErrorType,
  type SignTypedDataParameters,
  type SignTypedDataReturnType,
  signTypedData,
} from '../actions/signTypedData.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function signTypedDataMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return signTypedData(config, variables)
    },
    mutationKey: ['signTypedData'],
  } as const satisfies MutationOptions<
    SignTypedDataData,
    SignTypedDataErrorType,
    SignTypedDataVariables
  >
}

export type SignTypedDataData = Compute<SignTypedDataReturnType>

export type SignTypedDataVariables<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  ///
  primaryTypes = typedData extends TypedData ? keyof typedData : string,
> = SignTypedDataParameters<typedData, primaryType, primaryTypes>

export type SignTypedDataMutate<context = unknown> = <
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  variables: SignTypedDataVariables<typedData, primaryType>,
  options?:
    | MutateOptions<
        SignTypedDataData,
        SignTypedDataErrorType,
        SignTypedDataVariables<
          typedData,
          primaryType,
          // use `primaryType` to make sure it's not union of all possible primary types
          primaryType
        >,
        context
      >
    | undefined,
) => void

export type SignTypedDataMutateAsync<context = unknown> = <
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  variables: SignTypedDataVariables<typedData, primaryType>,
  options?:
    | MutateOptions<
        SignTypedDataData,
        SignTypedDataErrorType,
        SignTypedDataVariables<
          typedData,
          primaryType,
          // use `primaryType` to make sure it's not union of all possible primary types
          primaryType
        >,
        context
      >
    | undefined,
) => Promise<SignTypedDataData>
</file>

<file path="packages/core/src/query/simulateContract.test-d.ts">
import { abi } from '@wagmi/test'
import { http, type Address } from 'viem'
import { celo, mainnet } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { createConfig } from '../createConfig.js'
import {
  type SimulateContractOptions,
  simulateContractQueryOptions,
} from './simulateContract.js'

test('chain formatters', () => {
  const config = createConfig({
    chains: [mainnet, celo],
    transports: { [celo.id]: http(), [mainnet.id]: http() },
  })

  type Result = SimulateContractOptions<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    (typeof config)['chains'][number]['id']
  >
  expectTypeOf<Result>().toMatchTypeOf<{
    chainId?: typeof celo.id | typeof mainnet.id | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  simulateContractQueryOptions(config, {
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    feeCurrency: '0x',
  })

  type Result2 = SimulateContractOptions<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    typeof celo.id
  >
  expectTypeOf<Result2>().toMatchTypeOf<{
    functionName?: 'approve' | 'transfer' | 'transferFrom' | undefined
    args?: readonly [Address, Address, bigint] | undefined
    feeCurrency?: `0x${string}` | undefined
  }>()
  simulateContractQueryOptions(config, {
    chainId: celo.id,
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    feeCurrency: '0x',
  })

  type Result3 = SimulateContractOptions<
    typeof abi.erc20,
    'transferFrom',
    [Address, Address, bigint],
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result3>().toMatchTypeOf<{
    functionName?: 'approve' | 'transfer' | 'transferFrom' | undefined
    args?: readonly [Address, Address, bigint] | undefined
  }>()
  expectTypeOf<Result3>().not.toMatchTypeOf<{
    feeCurrency?: `0x${string}` | undefined
  }>()
  simulateContractQueryOptions(config, {
    chainId: mainnet.id,
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error
    feeCurrency: '0x',
  })
})
</file>

<file path="packages/core/src/query/simulateContract.ts">
import type { QueryOptions } from '@tanstack/query-core'
import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'

import {
  type SimulateContractErrorType,
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from '../actions/simulateContract.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { UnionExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type SimulateContractOptions<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
> = UnionExactPartial<
  SimulateContractParameters<abi, functionName, args, config, chainId>
> &
  ScopeKeyParameter

export function simulateContractQueryOptions<
  config extends Config,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainId extends config['chains'][number]['id'] | undefined,
>(
  config: config,
  options: SimulateContractOptions<
    abi,
    functionName,
    args,
    config,
    chainId
  > = {} as any,
) {
  return {
    async queryFn({ queryKey }) {
      const { abi, connector } = options
      if (!abi) throw new Error('abi is required')
      const { scopeKey: _, ...parameters } = queryKey[1]
      const { address, functionName } = parameters
      if (!address) throw new Error('address is required')
      if (!functionName) throw new Error('functionName is required')
      return simulateContract(config, {
        abi,
        connector,
        ...(parameters as any),
      })
    },
    queryKey: simulateContractQueryKey(options),
  } as const satisfies QueryOptions<
    SimulateContractQueryFnData<abi, functionName, args, config, chainId>,
    SimulateContractErrorType,
    SimulateContractData<abi, functionName, args, config, chainId>,
    SimulateContractQueryKey<abi, functionName, args, config, chainId>
  >
}

export type SimulateContractQueryFnData<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
> = SimulateContractReturnType<abi, functionName, args, config, chainId>

export type SimulateContractData<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
> = SimulateContractQueryFnData<abi, functionName, args, config, chainId>

export function simulateContractQueryKey<
  config extends Config,
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainId extends config['chains'][number]['id'] | undefined,
>(
  options: SimulateContractOptions<
    abi,
    functionName,
    args,
    config,
    chainId
  > = {} as any,
) {
  const { abi: _, connector: _c, ...rest } = options
  return ['simulateContract', filterQueryOptions(rest)] as const
}

export type SimulateContractQueryKey<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined,
> = ReturnType<
  typeof simulateContractQueryKey<config, abi, functionName, args, chainId>
>
</file>

<file path="packages/core/src/query/switchAccount.ts">
import type { MutationOptions } from '@tanstack/query-core'

import {
  type SwitchAccountErrorType,
  type SwitchAccountParameters,
  type SwitchAccountReturnType,
  switchAccount,
} from '../actions/switchAccount.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'
import type { Mutate, MutateAsync } from './types.js'

export function switchAccountMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return switchAccount(config, variables)
    },
    mutationKey: ['switchAccount'],
  } as const satisfies MutationOptions<
    SwitchAccountData<config>,
    SwitchAccountErrorType,
    SwitchAccountVariables
  >
}

export type SwitchAccountData<config extends Config> = Compute<
  SwitchAccountReturnType<config>
>

export type SwitchAccountVariables = Compute<SwitchAccountParameters>

export type SwitchAccountMutate<
  config extends Config,
  context = unknown,
> = Mutate<
  SwitchAccountData<config>,
  SwitchAccountErrorType,
  SwitchAccountVariables,
  context
>

export type SwitchAccountMutateAsync<
  config extends Config,
  context = unknown,
> = MutateAsync<
  SwitchAccountData<config>,
  SwitchAccountErrorType,
  SwitchAccountVariables,
  context
>
</file>

<file path="packages/core/src/query/switchChain.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'

import {
  type SwitchChainErrorType,
  type SwitchChainParameters,
  type SwitchChainReturnType,
  switchChain,
} from '../actions/switchChain.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function switchChainMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return switchChain(config, variables)
    },
    mutationKey: ['switchChain'],
  } as const satisfies MutationOptions<
    SwitchChainData<config, config['chains'][number]['id']>,
    SwitchChainErrorType,
    SwitchChainVariables<config, config['chains'][number]['id']>
  >
}

export type SwitchChainData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<SwitchChainReturnType<config, chainId>>

export type SwitchChainVariables<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<SwitchChainParameters<config, chainId>>

export type SwitchChainMutate<config extends Config, context = unknown> = <
  chainId extends config['chains'][number]['id'],
>(
  variables: SwitchChainVariables<config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          SwitchChainData<config, chainId>,
          SwitchChainErrorType,
          Compute<SwitchChainVariables<config, chainId>>,
          context
        >
      >
    | undefined,
) => void

export type SwitchChainMutateAsync<config extends Config, context = unknown> = <
  chainId extends config['chains'][number]['id'],
>(
  variables: SwitchChainVariables<config, chainId>,
  options?:
    | Compute<
        MutateOptions<
          SwitchChainData<config, chainId>,
          SwitchChainErrorType,
          Compute<SwitchChainVariables<config, chainId>>,
          context
        >
      >
    | undefined,
) => Promise<SwitchChainData<config, chainId>>
</file>

<file path="packages/core/src/query/types.ts">
import type {
  DefaultError,
  InfiniteQueryObserverOptions,
  MutateOptions,
  QueryFunction,
  QueryKey,
} from '@tanstack/query-core'

import type { Compute, StrictOmit } from '../types/utils.js'

export type InfiniteQueryOptions<
  queryFnData = unknown,
  error = DefaultError,
  data = queryFnData,
  queryData = queryFnData,
  queryKey extends QueryKey = QueryKey,
  pageParam = unknown,
  ///
  options extends InfiniteQueryObserverOptions<
    queryFnData,
    error,
    data,
    queryData,
    queryKey,
    pageParam
  > = InfiniteQueryObserverOptions<
    queryFnData,
    error,
    data,
    queryData,
    queryKey,
    pageParam
  >,
> = Compute<
  // `queryFn` doesn't pass through `pageParam` correctly
  StrictOmit<options, 'queryFn'> & {
    queryFn?(
      context: QueryFunctionContext<queryKey, pageParam>,
    ): options['queryFn'] extends (...args: any) => any
      ? ReturnType<NonNullable<options['queryFn']>>
      : unknown
  }
>

// `QueryFunctionContext` not exported resulting in TS2742 error so grabbing from `QueryFunction`
type QueryFunctionContext<
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = never,
> = Parameters<QueryFunction<unknown, TQueryKey, TPageParam>>[0]

export type Mutate<
  data = unknown,
  error = unknown,
  variables = void,
  context = unknown,
> = (
  ...args: Parameters<MutateFn<data, error, Compute<variables>, context>>
) => void

export type MutateAsync<
  data = unknown,
  error = unknown,
  variables = void,
  context = unknown,
> = MutateFn<data, error, Compute<variables>, context>

type MutateFn<
  data = unknown,
  error = unknown,
  variables = void,
  context = unknown,
> = undefined extends variables
  ? (
      variables?: variables,
      options?:
        | Compute<MutateOptions<data, error, variables, context>>
        | undefined,
    ) => Promise<data>
  : (
      variables: variables,
      options?:
        | Compute<MutateOptions<data, error, variables, context>>
        | undefined,
    ) => Promise<data>
</file>

<file path="packages/core/src/query/utils.ts">
import { type QueryKey, replaceEqualDeep } from '@tanstack/query-core'

export function structuralSharing<data>(
  oldData: data | undefined,
  newData: data,
): data {
  return replaceEqualDeep(oldData, newData)
}

export function hashFn(queryKey: QueryKey): string {
  return JSON.stringify(queryKey, (_, value) => {
    if (isPlainObject(value))
      return Object.keys(value)
        .sort()
        .reduce((result, key) => {
          result[key] = value[key]
          return result
        }, {} as any)
    if (typeof value === 'bigint') return value.toString()
    return value
  })
}

// biome-ignore lint/complexity/noBannedTypes:
function isPlainObject(value: any): value is Object {
  if (!hasObjectPrototype(value)) {
    return false
  }

  // If has modified constructor
  const ctor = value.constructor
  if (typeof ctor === 'undefined') return true

  // If has modified prototype
  const prot = ctor.prototype
  if (!hasObjectPrototype(prot)) return false

  // If constructor does not have an Object-specific method
  // biome-ignore lint/suspicious/noPrototypeBuiltins: <explanation>
  if (!prot.hasOwnProperty('isPrototypeOf')) return false

  // Most likely a plain Object
  return true
}

function hasObjectPrototype(o: any): boolean {
  return Object.prototype.toString.call(o) === '[object Object]'
}

export function filterQueryOptions<type extends Record<string, unknown>>(
  options: type,
): type {
  // destructuring is super fast
  // biome-ignore format: no formatting
  const {
    // import('@tanstack/query-core').QueryOptions
    _defaulted, behavior, gcTime, initialData, initialDataUpdatedAt, maxPages, meta, networkMode, queryFn, queryHash, queryKey, queryKeyHashFn, retry, retryDelay, structuralSharing,

    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    getPreviousPageParam, getNextPageParam, initialPageParam,

    // import('@tanstack/react-query').UseQueryOptions
    _optimisticResults, enabled, notifyOnChangeProps, placeholderData, refetchInterval, refetchIntervalInBackground, refetchOnMount, refetchOnReconnect, refetchOnWindowFocus, retryOnMount, select, staleTime, suspense, throwOnError,

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    config, connector, query,
    ...rest
  } = options

  return rest as type
}
</file>

<file path="packages/core/src/query/verifyMessage.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type VerifyMessageErrorType,
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from '../actions/verifyMessage.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type VerifyMessageOptions<config extends Config> = Compute<
  ExactPartial<VerifyMessageParameters<config>> & ScopeKeyParameter
>

export function verifyMessageQueryOptions<config extends Config>(
  config: config,
  options: VerifyMessageOptions<config> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { address, message, signature } = queryKey[1]
      if (!address || !message || !signature)
        throw new Error('address, message, and signature are required')

      const { scopeKey: _, ...parameters } = queryKey[1]

      const verified = await verifyMessage(
        config,
        parameters as VerifyMessageParameters,
      )
      return verified ?? null
    },
    queryKey: verifyMessageQueryKey(options),
  } as const satisfies QueryOptions<
    VerifyMessageQueryFnData,
    VerifyMessageErrorType,
    VerifyMessageData,
    VerifyMessageQueryKey<config>
  >
}
export type VerifyMessageQueryFnData = VerifyMessageReturnType

export type VerifyMessageData = VerifyMessageQueryFnData

export function verifyMessageQueryKey<config extends Config>(
  options: VerifyMessageOptions<config>,
) {
  return ['verifyMessage', filterQueryOptions(options)] as const
}

export type VerifyMessageQueryKey<config extends Config> = ReturnType<
  typeof verifyMessageQueryKey<config>
>
</file>

<file path="packages/core/src/query/verifyTypedData.ts">
import type { QueryOptions } from '@tanstack/query-core'
import type { TypedData } from 'viem'

import {
  type VerifyTypedDataErrorType,
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from '../actions/verifyTypedData.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type VerifyTypedDataOptions<
  typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
  config extends Config,
> = ExactPartial<VerifyTypedDataParameters<typedData, primaryType, config>> &
  ScopeKeyParameter

export function verifyTypedDataQueryOptions<
  config extends Config,
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  config: config,
  options: VerifyTypedDataOptions<typedData, primaryType, config> = {} as any,
) {
  return {
    async queryFn({ queryKey }) {
      const {
        address,
        message,
        primaryType,
        signature,
        types,
        scopeKey: _,
        ...parameters
      } = queryKey[1]
      if (!address) throw new Error('address is required')
      if (!message) throw new Error('message is required')
      if (!primaryType) throw new Error('primaryType is required')
      if (!signature) throw new Error('signature is required')
      if (!types) throw new Error('types is required')

      const verified = await verifyTypedData(config, {
        ...parameters,
        address,
        message,
        primaryType,
        signature,
        types,
      } as VerifyTypedDataParameters)
      return verified ?? null
    },
    queryKey: verifyTypedDataQueryKey(options),
  } as const satisfies QueryOptions<
    VerifyTypedDataQueryFnData,
    VerifyTypedDataErrorType,
    VerifyTypedDataData,
    VerifyTypedDataQueryKey<typedData, primaryType, config>
  >
}

export type VerifyTypedDataQueryFnData = VerifyTypedDataReturnType

export type VerifyTypedDataData = VerifyTypedDataQueryFnData

export function verifyTypedDataQueryKey<
  config extends Config,
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(options: VerifyTypedDataOptions<typedData, primaryType, config>) {
  return ['verifyTypedData', filterQueryOptions(options)] as const
}

export type VerifyTypedDataQueryKey<
  typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
  config extends Config,
> = ReturnType<typeof verifyTypedDataQueryKey<config, typedData, primaryType>>
</file>

<file path="packages/core/src/query/waitForCallsStatus.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type WaitForCallsStatusErrorType,
  type WaitForCallsStatusParameters,
  type WaitForCallsStatusReturnType,
  waitForCallsStatus,
} from '../actions/waitForCallsStatus.js'
import type { Config } from '../createConfig.js'
import { ConnectorNotConnectedError } from '../errors/config.js'
import { filterQueryOptions } from '../query/utils.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, PartialBy } from '../types/utils.js'

export type WaitForCallsStatusOptions = Compute<
  PartialBy<WaitForCallsStatusParameters, 'id'> & ScopeKeyParameter
>

export function waitForCallsStatusQueryOptions<config extends Config>(
  config: config,
  options: WaitForCallsStatusOptions,
) {
  return {
    async queryFn({ queryKey }) {
      const { scopeKey: _, id, ...parameters } = queryKey[1]
      if (!id) throw new Error('id is required')
      const status = await waitForCallsStatus(config, { ...parameters, id })
      return status
    },
    queryKey: waitForCallsStatusQueryKey(options),
    retry(failureCount, error) {
      if (error instanceof ConnectorNotConnectedError) return false
      return failureCount < 3
    },
  } as const satisfies QueryOptions<
    WaitForCallsStatusQueryFnData,
    WaitForCallsStatusErrorType,
    WaitForCallsStatusData,
    WaitForCallsStatusQueryKey
  >
}

export type WaitForCallsStatusQueryFnData = WaitForCallsStatusReturnType

export type WaitForCallsStatusData = WaitForCallsStatusQueryFnData

export function waitForCallsStatusQueryKey(options: WaitForCallsStatusOptions) {
  return ['callsStatus', filterQueryOptions(options)] as const
}

export type WaitForCallsStatusQueryKey = ReturnType<
  typeof waitForCallsStatusQueryKey
>
</file>

<file path="packages/core/src/query/waitForTransactionReceipt.ts">
import type { QueryOptions } from '@tanstack/query-core'

import {
  type WaitForTransactionReceiptErrorType,
  type WaitForTransactionReceiptParameters,
  type WaitForTransactionReceiptReturnType,
  waitForTransactionReceipt,
} from '../actions/waitForTransactionReceipt.js'
import type { Config } from '../createConfig.js'
import type { ScopeKeyParameter } from '../types/properties.js'
import type { Compute, ExactPartial } from '../types/utils.js'
import { filterQueryOptions } from './utils.js'

export type WaitForTransactionReceiptOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = Compute<
  ExactPartial<WaitForTransactionReceiptParameters<config, chainId>> &
    ScopeKeyParameter
>

export function waitForTransactionReceiptQueryOptions<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(
  config: config,
  options: WaitForTransactionReceiptOptions<config, chainId> = {},
) {
  return {
    async queryFn({ queryKey }) {
      const { hash, ...parameters } = queryKey[1]
      if (!hash) throw new Error('hash is required')
      return waitForTransactionReceipt(config, {
        ...parameters,
        onReplaced: options.onReplaced,
        hash,
      }) as unknown as Promise<
        WaitForTransactionReceiptReturnType<config, chainId>
      >
    },
    queryKey: waitForTransactionReceiptQueryKey(options),
  } as const satisfies QueryOptions<
    WaitForTransactionReceiptQueryFnData<config, chainId>,
    WaitForTransactionReceiptErrorType,
    WaitForTransactionReceiptData<config, chainId>,
    WaitForTransactionReceiptQueryKey<config, chainId>
  >
}

export type WaitForTransactionReceiptQueryFnData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = WaitForTransactionReceiptReturnType<config, chainId>

export type WaitForTransactionReceiptData<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = WaitForTransactionReceiptQueryFnData<config, chainId>

export function waitForTransactionReceiptQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
>(options: WaitForTransactionReceiptOptions<config, chainId> = {}) {
  const { onReplaced: _, ...rest } = options
  return ['waitForTransactionReceipt', filterQueryOptions(rest)] as const
}

export type WaitForTransactionReceiptQueryKey<
  config extends Config,
  chainId extends config['chains'][number]['id'],
> = ReturnType<typeof waitForTransactionReceiptQueryKey<config, chainId>>
</file>

<file path="packages/core/src/query/watchAsset.ts">
import type { MutationOptions } from '@tanstack/query-core'

import {
  type WatchAssetErrorType,
  type WatchAssetParameters,
  type WatchAssetReturnType,
  watchAsset,
} from '../actions/watchAsset.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'
import type { Mutate, MutateAsync } from './types.js'

export function watchAssetMutationOptions(config: Config) {
  return {
    mutationFn(variables) {
      return watchAsset(config, variables)
    },
    mutationKey: ['watchAsset'],
  } as const satisfies MutationOptions<
    WatchAssetData,
    WatchAssetErrorType,
    WatchAssetVariables
  >
}

export type WatchAssetData = WatchAssetReturnType

export type WatchAssetVariables = Compute<WatchAssetParameters>

export type WatchAssetMutate<context = unknown> = Mutate<
  WatchAssetData,
  WatchAssetErrorType,
  WatchAssetVariables,
  context
>

export type WatchAssetMutateAsync<context = unknown> = MutateAsync<
  WatchAssetData,
  WatchAssetErrorType,
  WatchAssetVariables,
  context
>
</file>

<file path="packages/core/src/query/writeContract.test-d.ts">
import { http } from 'viem'
import { writeContract } from 'viem/actions'
import { base } from 'viem/chains'
import { test } from 'vitest'

import { createConfig } from '../createConfig.js'
import type { WriteContractMutate } from './writeContract.js'

// https://github.com/wevm/wagmi/issues/3981
test('gh#3981', () => {
  const config = createConfig({
    chains: [base],
    transports: {
      [base.id]: http(),
    },
  })

  const abi = [
    {
      type: 'function',
      name: 'example1',
      inputs: [
        { name: 'exampleName', type: 'address', internalType: 'address' },
      ],
      outputs: [],
      stateMutability: 'payable',
    },
    {
      type: 'function',
      name: 'example2',
      inputs: [
        { name: 'exampleName', type: 'address', internalType: 'address' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
  ] as const

  const write: WriteContractMutate<typeof config> = () => {}
  write({
    abi,
    address: '0x...',
    functionName: 'example1',
    args: ['0x...'],
    value: 123n,
  })
  write({
    abi: [
      {
        type: 'function',
        name: 'example1',
        inputs: [
          { name: 'exampleName', type: 'address', internalType: 'address' },
        ],
        outputs: [],
        stateMutability: 'payable',
      },
      {
        type: 'function',
        name: 'example2',
        inputs: [
          { name: 'exampleName', type: 'address', internalType: 'address' },
        ],
        outputs: [],
        stateMutability: 'nonpayable',
      },
    ] as const,
    address: '0x...',
    functionName: 'example1',
    args: ['0x...'],
    value: 123n,
  })

  write({
    abi,
    address: '0x...',
    functionName: 'example2',
    args: ['0x...'],
    // @ts-expect-error
    value: 123n,
  })
  write({
    abi: [
      {
        type: 'function',
        name: 'example1',
        inputs: [
          { name: 'exampleName', type: 'address', internalType: 'address' },
        ],
        outputs: [],
        stateMutability: 'payable',
      },
      {
        type: 'function',
        name: 'example2',
        inputs: [
          { name: 'exampleName', type: 'address', internalType: 'address' },
        ],
        outputs: [],
        stateMutability: 'nonpayable',
      },
    ],
    address: '0x...',
    functionName: 'example1',
    args: ['0x...'],
    value: 123n,
  })

  const client = config.getClient({ chainId: base.id })
  writeContract(client, {
    abi,
    address: '0x...',
    account: '0x...',
    functionName: 'example1',
    args: ['0x...'],
    value: 123n,
  })
  writeContract(client, {
    abi: [
      {
        type: 'function',
        name: 'example1',
        inputs: [
          { name: 'exampleName', type: 'address', internalType: 'address' },
        ],
        outputs: [],
        stateMutability: 'payable',
      },
      {
        type: 'function',
        name: 'example2',
        inputs: [
          { name: 'exampleName', type: 'address', internalType: 'address' },
        ],
        outputs: [],
        stateMutability: 'nonpayable',
      },
    ] as const,
    address: '0x...',
    account: '0x...',
    functionName: 'example1',
    args: ['0x...'],
    value: 123n,
  })
})
</file>

<file path="packages/core/src/query/writeContract.ts">
import type { MutateOptions, MutationOptions } from '@tanstack/query-core'
import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'

import {
  type WriteContractErrorType,
  type WriteContractParameters,
  type WriteContractReturnType,
  writeContract,
} from '../actions/writeContract.js'
import type { Config } from '../createConfig.js'
import type { Compute } from '../types/utils.js'

export function writeContractMutationOptions<config extends Config>(
  config: config,
) {
  return {
    mutationFn(variables) {
      return writeContract(config, variables)
    },
    mutationKey: ['writeContract'],
  } as const satisfies MutationOptions<
    WriteContractData,
    WriteContractErrorType,
    WriteContractVariables<
      Abi,
      string,
      readonly unknown[],
      config,
      config['chains'][number]['id']
    >
  >
}

export type WriteContractData = Compute<WriteContractReturnType>

export type WriteContractVariables<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  config extends Config,
  chainId extends config['chains'][number]['id'],
  ///
  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
> = WriteContractParameters<
  abi,
  functionName,
  args,
  config,
  chainId,
  allFunctionNames
>

export type WriteContractMutate<config extends Config, context = unknown> = <
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainId extends config['chains'][number]['id'],
>(
  variables: WriteContractVariables<abi, functionName, args, config, chainId>,
  options?:
    | MutateOptions<
        WriteContractData,
        WriteContractErrorType,
        WriteContractVariables<
          abi,
          functionName,
          args,
          config,
          chainId,
          // use `functionName` to make sure it's not union of all possible function names
          functionName
        >,
        context
      >
    | undefined,
) => void

export type WriteContractMutateAsync<
  config extends Config,
  context = unknown,
> = <
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainId extends config['chains'][number]['id'],
>(
  variables: WriteContractVariables<abi, functionName, args, config, chainId>,
  options?:
    | MutateOptions<
        WriteContractData,
        WriteContractErrorType,
        WriteContractVariables<
          abi,
          functionName,
          args,
          config,
          chainId,
          // use `functionName` to make sure it's not union of all possible function names
          functionName
        >,
        context
      >
    | undefined,
) => Promise<WriteContractData>
</file>

<file path="packages/core/src/transports/connector.ts">
import {
  ChainDisconnectedError,
  type EIP1193Parameters,
  type EIP1193Provider,
  type EIP1193RequestFn,
  ProviderDisconnectedError,
  type TransportConfig,
  type WalletRpcSchema,
  createTransport,
  hexToNumber,
  withRetry,
  withTimeout,
} from 'viem'

import type { Connector, Transport } from '../createConfig.js'

export type ConnectorTransportConfig = {
  /** The key of the transport. */
  key?: TransportConfig['key'] | undefined
  /** The name of the transport. */
  name?: TransportConfig['name'] | undefined
  /** The max number of times to retry. */
  retryCount?: TransportConfig['retryCount'] | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: TransportConfig['retryDelay'] | undefined
}

export type ConnectorTransport = Transport

export function unstable_connector(
  connector: Pick<Connector, 'type'>,
  config: ConnectorTransportConfig = {},
): Transport<'connector'> {
  const { type } = connector
  const { key = 'connector', name = 'Connector', retryDelay } = config

  return (parameters) => {
    const { chain, connectors } = parameters
    const retryCount = config.retryCount ?? parameters.retryCount

    const request: EIP1193RequestFn = async ({ method, params }) => {
      const connector = connectors?.getState().find((c) => c.type === type)
      if (!connector)
        throw new ProviderDisconnectedError(
          new Error(
            `Could not find connector of type "${type}" in \`connectors\` passed to \`createConfig\`.`,
          ),
        )

      const provider = (await connector.getProvider({
        chainId: chain?.id,
      })) as EIP1193Provider | undefined
      if (!provider)
        throw new ProviderDisconnectedError(
          new Error('Provider is disconnected.'),
        )

      // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to
      // immediately resolve a JSON-RPC request on page load.
      const chainId = hexToNumber(
        await withRetry(() =>
          withTimeout(() => provider.request({ method: 'eth_chainId' }), {
            timeout: 100,
          }),
        ),
      )
      if (chain && chainId !== chain.id)
        throw new ChainDisconnectedError(
          new Error(
            `The current chain of the connector (id: ${chainId}) does not match the target chain for the request (id: ${chain.id}  ${chain.name}).`,
          ),
        )

      const body = { method, params } as EIP1193Parameters<WalletRpcSchema>
      return provider.request(body)
    }

    return createTransport({
      key,
      name,
      request,
      retryCount,
      retryDelay,
      type: 'connector',
    })
  }
}
</file>

<file path="packages/core/src/transports/fallback.ts">
import { fallback as viem_fallback } from 'viem'

import type { Transport } from '../createConfig.js'

export function fallback(
  transports: Transport[],
  config?: Parameters<typeof viem_fallback>[1],
) {
  return viem_fallback(transports, config)
}
</file>

<file path="packages/core/src/types/chain.test-d.ts">
import type { Chain, mainnet, optimism, sepolia } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import type { Config } from '../createConfig.js'
import type { SelectChains } from './chain.js'
import type { Merge } from './utils.js'

test('not narrowable', () => {
  type Result = SelectChains<Config, number>
  expectTypeOf<Result>().toEqualTypeOf<readonly [Chain]>()
})

test('chainId', () => {
  type Result = SelectChains<
    Config<readonly [typeof mainnet, typeof optimism]>,
    1
  >
  expectTypeOf<Result>().toEqualTypeOf<readonly [typeof mainnet]>()
})

test('at least one chain has formatters', () => {
  type Result = SelectChains<Config<readonly [typeof mainnet, typeof optimism]>>
  expectTypeOf<Result>().toEqualTypeOf<
    readonly [typeof mainnet, typeof optimism]
  >()
})

test('no formatters', () => {
  type Result = SelectChains<Config<readonly [typeof mainnet, typeof sepolia]>>
  expectTypeOf<Result>().toEqualTypeOf<
    readonly [Merge<Chain, { id: typeof mainnet.id | typeof sepolia.id }>]
  >()
})
</file>

<file path="packages/core/src/types/chain.ts">
import type { Chain, ChainFormatters } from 'viem'

import type { Config } from '../createConfig.js'
import type { IsNarrowable, Merge } from './utils.js'

/** Filters {@link Config} chains by {@link chainId} or simplifies if no `ChainFormatters` are present. */
export type SelectChains<
  config extends Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
> = Config extends config
  ? readonly [Chain] // chains not inferrable, return default
  : IsNarrowable<chainId, config['chains'][number]['id']> extends true
    ? readonly [Extract<config['chains'][number], { id: chainId }>] // select specific chain
    : HasFormatter<config['chains']> extends true
      ? config['chains'] // return all chains since one has formatter
      : // return default chain with ID set to union (allows for more simple type since the only thing that is different is the chain ID for each chain)
        readonly [Merge<Chain, { id: config['chains'][number]['id'] }>]

type HasFormatter<chains extends readonly Chain[]> = chains extends readonly [
  infer head extends Chain,
  ...infer tail extends readonly Chain[],
]
  ? IsNarrowable<head['formatters'], ChainFormatters | undefined> extends true
    ? true
    : HasFormatter<tail>
  : false
</file>

<file path="packages/core/src/types/properties.ts">
import type { Config, Connector } from '../createConfig.js'

export type ChainIdParameter<
  config extends Config,
  chainId extends
    | config['chains'][number]['id']
    | undefined = config['chains'][number]['id'],
> = {
  chainId?:
    | (chainId extends config['chains'][number]['id'] ? chainId : undefined)
    | config['chains'][number]['id']
    | undefined
}

export type ConnectorParameter = {
  connector?: Connector | undefined
}

export type ScopeKeyParameter = { scopeKey?: string | undefined }

export type SyncConnectedChainParameter = {
  syncConnectedChain?: boolean | undefined
}
</file>

<file path="packages/core/src/types/register.ts">
import type { Config } from '../createConfig.js'

// biome-ignore lint/suspicious/noEmptyInterface: <explanation>
export interface Register {}
export type ResolvedRegister = {
  config: Register extends { config: infer config extends Config }
    ? config
    : Config
}
</file>

<file path="packages/core/src/types/unit.ts">
export type Unit = 'ether' | 'gwei' | 'wei' | number
</file>

<file path="packages/core/src/types/utils.test-d.ts">
import { assertType, expectTypeOf, test } from 'vitest'

import type {
  Compute,
  ExactPartial,
  IsNever,
  Mutable,
  OneOf,
  PartialBy,
} from './utils.js'

test('ExactPartial', () => {
  expectTypeOf<ExactPartial<{ foo: boolean; bar: boolean }>>().toEqualTypeOf<{
    foo?: boolean | undefined
    bar?: boolean | undefined
  }>()
})

test('IsNever', () => {
  expectTypeOf<IsNever<never>>().toEqualTypeOf<true>()
})

test('Mutable', () => {
  expectTypeOf<
    Mutable<{ foo: boolean; readonly bar: boolean }>
  >().toEqualTypeOf<{ foo: boolean; bar: boolean }>()
})

test('OneOf', () => {
  assertType<OneOf<{ foo: boolean } | { bar: boolean }>>({ foo: false })
  assertType<OneOf<{ foo: boolean } | { bar: boolean }>>({ bar: false })
})

test('PartialBy', () => {
  type Result = Compute<PartialBy<{ foo: string; bar: number }, 'foo'>>
  expectTypeOf<Result>().toEqualTypeOf<{
    foo?: string | undefined
    bar: number
  }>()
})
</file>

<file path="packages/core/src/types/utils.ts">
/** Combines members of an intersection into a readable type. */
// https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg
export type Compute<type> = { [key in keyof type]: type[key] } & unknown

/**
 * Makes all properties of an object optional.
 *
 * Compatible with [`exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig#exactOptionalPropertyTypes).
 */
export type ExactPartial<type> = {
  [key in keyof type]?: type[key] | undefined
}

/** Checks if {@link type} can be narrowed further than {@link type2} */
export type IsNarrowable<type, type2> = IsUnknown<type> extends true
  ? false
  : undefined extends type
    ? false
    : IsNever<
          (type extends type2 ? true : false) &
            (type2 extends type ? false : true)
        > extends true
      ? false
      : true

/**
 * @internal
 * Checks if {@link type} is `never`
 */
export type IsNever<type> = [type] extends [never] ? true : false

/**
 * @internal
 * Checks if {@link type} is `unknown`
 */
export type IsUnknown<type> = unknown extends type ? true : false

/** Merges two object types into new type  */
export type Merge<obj1, obj2> = Compute<
  LooseOmit<obj1, keyof obj2 extends infer key extends string ? key : never> &
    obj2
>

/** Removes `readonly` from all properties of an object. */
export type Mutable<type extends object> = {
  -readonly [key in keyof type]: type[key]
}

/** Strict version of built-in Omit type */
export type StrictOmit<type, keys extends keyof type> = Pick<
  type,
  Exclude<keyof type, keys>
>

/** Makes objects destructurable. */
export type OneOf<
  union extends object,
  ///
  keys extends KeyofUnion<union> = KeyofUnion<union>,
> = union extends infer Item
  ? Compute<Item & { [K in Exclude<keys, keyof Item>]?: undefined }>
  : never
type KeyofUnion<type> = type extends type ? keyof type : never

/** Makes {@link key} optional in {@link type} while preserving type inference. */
// s/o trpc (https://github.com/trpc/trpc/blob/main/packages/server/src/types.ts#L6)
export type PartialBy<type, key extends keyof type> = ExactPartial<
  Pick<type, key>
> &
  StrictOmit<type, key>

/* Removes `undefined` from object property */
export type RemoveUndefined<type> = {
  [key in keyof type]: NonNullable<type[key]>
}

///////////////////////////////////////////////////////////////////////////
// Loose types

/** Loose version of {@link StrictOmit} */
export type LooseOmit<type, keys extends string> = Pick<
  type,
  Exclude<keyof type, keys>
>

///////////////////////////////////////////////////////////////////////////
// Union types

export type UnionCompute<type> = type extends object ? Compute<type> : type

export type UnionLooseOmit<type, keys extends string> = type extends any
  ? LooseOmit<type, keys>
  : never

export type UnionStrictOmit<type, keys extends keyof type> = type extends any
  ? StrictOmit<type, keys>
  : never

export type UnionExactPartial<type> = type extends object
  ? ExactPartial<type>
  : type
</file>

<file path="packages/core/src/utils/cookie.ts">
import type { Config, State } from '../createConfig.js'
import type { BaseStorage } from '../createStorage.js'
import { deserialize } from './deserialize.js'

export const cookieStorage = {
  getItem(key) {
    if (typeof window === 'undefined') return null
    const value = parseCookie(document.cookie, key)
    return value ?? null
  },
  setItem(key, value) {
    if (typeof window === 'undefined') return
    document.cookie = `${key}=${value};path=/;samesite=Lax`
  },
  removeItem(key) {
    if (typeof window === 'undefined') return
    document.cookie = `${key}=;max-age=-1;path=/`
  },
} satisfies BaseStorage

export function cookieToInitialState(config: Config, cookie?: string | null) {
  if (!cookie) return undefined
  const key = `${config.storage?.key}.store`
  const parsed = parseCookie(cookie, key)
  if (!parsed) return undefined
  return deserialize<{ state: State }>(parsed).state
}

export function parseCookie(cookie: string, key: string) {
  const keyValue = cookie.split('; ').find((x) => x.startsWith(`${key}=`))
  if (!keyValue) return undefined
  return keyValue.substring(key.length + 1)
}
</file>

<file path="packages/core/src/utils/deepEqual.ts">
/** Forked from https://github.com/epoberezkin/fast-deep-equal */

export function deepEqual(a: any, b: any) {
  if (a === b) return true

  if (a && b && typeof a === 'object' && typeof b === 'object') {
    if (a.constructor !== b.constructor) return false

    let length: number
    let i: number

    if (Array.isArray(a) && Array.isArray(b)) {
      length = a.length
      if (length !== b.length) return false
      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false
      return true
    }

    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf()
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString()

    const keys = Object.keys(a)
    length = keys.length
    if (length !== Object.keys(b).length) return false

    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]!)) return false

    for (i = length; i-- !== 0; ) {
      const key = keys[i]

      if (key && !deepEqual(a[key], b[key])) return false
    }

    return true
  }

  // true if both NaN, false otherwise
  // biome-ignore lint/suspicious/noSelfCompare: <explanation>
  return a !== a && b !== b
}
</file>

<file path="packages/core/src/utils/deserialize.ts">
type Reviver = (key: string, value: any) => any

export function deserialize<type>(value: string, reviver?: Reviver): type {
  return JSON.parse(value, (key, value_) => {
    let value = value_
    if (value?.__type === 'bigint') value = BigInt(value.value)
    if (value?.__type === 'Map') value = new Map(value.value)
    return reviver?.(key, value) ?? value
  })
}
</file>

<file path="packages/core/src/utils/extractRpcUrls.ts">
import type { Chain, Transport } from 'viem'

type ExtractRpcUrlsParameters = {
  transports?: Record<string, Transport> | undefined
  chain: Chain
}

export function extractRpcUrls(parameters: ExtractRpcUrlsParameters) {
  const { chain } = parameters
  const fallbackUrl = chain.rpcUrls.default.http[0]

  if (!parameters.transports) return [fallbackUrl]

  const transport = parameters.transports?.[chain.id]?.({ chain })
  const transports = (transport?.value?.transports as NonNullable<
    typeof transport
  >[]) || [transport]
  return transports.map(({ value }) => value?.url || fallbackUrl)
}
</file>

<file path="packages/core/src/utils/getAction.ts">
import type {
  Account,
  Chain,
  Client,
  PublicActions,
  RpcSchema,
  Transport,
  WalletActions,
} from 'viem'

/**
 * Retrieves and returns an action from the client (if exists), and falls
 * back to the tree-shakable action.
 *
 * Useful for extracting overridden actions from a client (ie. if a consumer
 * wants to override the `sendTransaction` implementation).
 */
export function getAction<
  transport extends Transport,
  chain extends Chain | undefined,
  account extends Account | undefined,
  rpcSchema extends RpcSchema | undefined,
  extended extends { [key: string]: unknown },
  client extends Client<transport, chain, account, rpcSchema, extended>,
  parameters,
  returnType,
>(
  client: client,
  actionFn: (_: any, parameters: parameters) => returnType,
  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,
  // meaning that `actionFn.name` will not always work. For that case, the consumer
  // needs to pass the name explicitly.
  name: keyof PublicActions | keyof WalletActions,
): (parameters: parameters) => returnType {
  const action_implicit = client[actionFn.name]
  if (typeof action_implicit === 'function')
    return action_implicit as (params: parameters) => returnType

  const action_explicit = client[name]
  if (typeof action_explicit === 'function')
    return action_explicit as (params: parameters) => returnType

  return (params) => actionFn(client, params)
}
</file>

<file path="packages/core/src/utils/getUnit.ts">
import { weiUnits } from 'viem'

import type { Unit } from '../types/unit.js'

export function getUnit(unit: Unit) {
  if (typeof unit === 'number') return unit
  if (unit === 'wei') return 0
  return Math.abs(weiUnits[unit])
}
</file>

<file path="packages/core/src/utils/getVersion.ts">
import { version } from '../version.js'

export const getVersion = () => `@wagmi/core@${version}`
</file>

<file path="packages/core/src/utils/normalizeChainId.ts">
/** @deprecated use `Number` instead */
export function normalizeChainId(chainId: bigint | number | string | unknown) {
  if (typeof chainId === 'string')
    return Number.parseInt(
      chainId,
      chainId.trim().substring(0, 2) === '0x' ? 16 : 10,
    )
  if (typeof chainId === 'bigint') return Number(chainId)
  if (typeof chainId === 'number') return chainId
  throw new Error(
    `Cannot normalize chainId "${chainId}" of type "${typeof chainId}"`,
  )
}
</file>

<file path="packages/core/src/utils/serialize.ts">
/**
 * Get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys: string[], cutoff: number) {
  return keys.slice(0, cutoff).join('.') || '.'
}

/**
 * Faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */
function getCutoff(array: any[], value: any) {
  const { length } = array

  for (let index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1
    }
  }

  return 0
}

type StandardReplacer = (key: string, value: any) => any
type CircularReplacer = (key: string, value: any, referenceKey: string) => any

/**
 * Create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */
function createReplacer(
  replacer?: StandardReplacer | null | undefined,
  circularReplacer?: CircularReplacer | null | undefined,
): StandardReplacer {
  const hasReplacer = typeof replacer === 'function'
  const hasCircularReplacer = typeof circularReplacer === 'function'

  const cache: any[] = []
  const keys: string[] = []

  return function replace(this: any, key: string, value: any) {
    if (typeof value === 'object') {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this)

        if (thisCutoff === 0) {
          cache[cache.length] = this
        } else {
          cache.splice(thisCutoff)
          keys.splice(thisCutoff)
        }

        keys[keys.length] = key

        const valueCutoff = getCutoff(cache, value)

        if (valueCutoff !== 0) {
          return hasCircularReplacer
            ? circularReplacer.call(
                this,
                key,
                value,
                getReferenceKey(keys, valueCutoff),
              )
            : `[ref=${getReferenceKey(keys, valueCutoff)}]`
        }
      } else {
        cache[0] = value
        keys[0] = key
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value
  }
}

/**
 * Stringifier that handles circular values
 *
 * Forked from https://github.com/planttheidea/fast-stringify
 *
 * @param value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */
export function serialize(
  value: any,
  replacer?: StandardReplacer | null | undefined,
  indent?: number | null | undefined,
  circularReplacer?: CircularReplacer | null | undefined,
) {
  return JSON.stringify(
    value,
    createReplacer((key, value_) => {
      let value = value_
      if (typeof value === 'bigint')
        value = { __type: 'bigint', value: value_.toString() }
      if (value instanceof Map)
        value = { __type: 'Map', value: Array.from(value_.entries()) }
      return replacer?.(key, value) ?? value
    }, circularReplacer),
    indent ?? undefined,
  )
}
</file>

<file path="packages/core/src/utils/uid.ts">
const size = 256
let index = size
let buffer: string

export function uid(length = 11) {
  if (!buffer || index + length > size * 2) {
    buffer = ''
    index = 0
    for (let i = 0; i < size; i++) {
      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1)
    }
  }
  return buffer.substring(index, index++ + length)
}
</file>

<file path="packages/core/src/createConfig.test-d.ts">
import { accounts } from '@wagmi/test'
import { http, createClient, webSocket } from 'viem'
import { mainnet, sepolia } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { mock } from './connectors/mock.js'
import { type CreateConfigParameters, createConfig } from './createConfig.js'

test('high-level config', () => {
  // Create config without needing to import viem modules.
  const config = createConfig({
    cacheTime: 100,
    chains: [mainnet, sepolia],
    connectors: [mock({ accounts })],
    batch: { multicall: true },
    pollingInterval: { [mainnet.id]: 100 },
    transports: {
      [mainnet.id]: webSocket(),
      [sepolia.id]: http(),
    },
  })
  const client = config.getClient({ chainId: mainnet.id })
  expectTypeOf(client.chain).toEqualTypeOf(mainnet)
  expectTypeOf(client.transport.type).toEqualTypeOf<'webSocket'>()
})

test('low-level config', () => {
  // Create a "multi chain" config using viem modules.
  const config = createConfig({
    chains: [mainnet, sepolia],
    connectors: [mock({ accounts })],
    client({ chain }) {
      return createClient({ chain, transport: http() })
    },
  })
  const client = config.getClient({ chainId: mainnet.id })
  expectTypeOf(client.chain).toEqualTypeOf(mainnet)
})

test('behavior: `chains` must have at least one chain', () => {
  createConfig({
    // @ts-expect-error
    chains: [],
    connectors: [mock({ accounts })],
    transports: {
      [mainnet.id]: http(),
    },
  })
  createConfig({
    // @ts-expect-error
    chains: [],
    connectors: [mock({ accounts })],
    client: ({ chain }) =>
      createClient({
        chain,
        transport: http(),
      }),
  })
})

test('behavior: missing transport for chain', () => {
  createConfig({
    chains: [mainnet, sepolia],
    connectors: [mock({ accounts })],
    // @ts-expect-error
    transports: {
      [mainnet.id]: http(),
    },
  })
  createConfig({
    chains: [mainnet, sepolia],
    connectors: [mock({ accounts })],
    transports: {
      [mainnet.id]: http(),
      // @ts-expect-error
      [123]: http(),
    },
  })
})

test('behavior: parameters should not include certain client config properties', () => {
  type Result = keyof CreateConfigParameters
  expectTypeOf<'account' extends Result ? true : false>().toEqualTypeOf<false>()
  expectTypeOf<'chain' extends Result ? true : false>().toEqualTypeOf<false>()
  expectTypeOf<
    'transport' extends Result ? true : false
  >().toEqualTypeOf<false>()
})

test('infer connectors', () => {
  const connectorFn = mock({ accounts })
  const config = createConfig({
    chains: [mainnet, sepolia],
    connectors: [connectorFn],
    transports: {
      [mainnet.id]: webSocket(),
      [sepolia.id]: http(),
    },
  })

  const connector = config.connectors[0]!
  expectTypeOf(connector).toEqualTypeOf(
    config._internal.connectors.setup(connectorFn),
  )

  type ConnectFnParameters = NonNullable<
    Parameters<(typeof connector)['connect']>[0]
  >
  expectTypeOf<ConnectFnParameters['foo']>().toMatchTypeOf<string | undefined>()
})
</file>

<file path="packages/core/src/createConfig.ts">
import {
  type EIP6963ProviderDetail,
  type Store as MipdStore,
  createStore as createMipd,
} from 'mipd'
import {
  type Address,
  type Chain,
  type Client,
  type EIP1193RequestFn,
  createClient,
  type ClientConfig as viem_ClientConfig,
  type Transport as viem_Transport,
} from 'viem'
import { persist, subscribeWithSelector } from 'zustand/middleware'
import { type Mutate, type StoreApi, createStore } from 'zustand/vanilla'

import type {
  ConnectorEventMap,
  CreateConnectorFn,
} from './connectors/createConnector.js'
import { injected } from './connectors/injected.js'
import { type Emitter, type EventData, createEmitter } from './createEmitter.js'
import {
  type Storage,
  createStorage,
  getDefaultStorage,
} from './createStorage.js'
import { ChainNotConfiguredError } from './errors/config.js'
import type {
  Compute,
  ExactPartial,
  LooseOmit,
  OneOf,
  RemoveUndefined,
} from './types/utils.js'
import { uid } from './utils/uid.js'
import { version } from './version.js'

export function createConfig<
  const chains extends readonly [Chain, ...Chain[]],
  transports extends Record<chains[number]['id'], Transport>,
  const connectorFns extends readonly CreateConnectorFn[],
>(
  parameters: CreateConfigParameters<chains, transports, connectorFns>,
): Config<chains, transports, connectorFns> {
  const {
    multiInjectedProviderDiscovery = true,
    storage = createStorage({
      storage: getDefaultStorage(),
    }),
    syncConnectedChain = true,
    ssr = false,
    ...rest
  } = parameters

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Set up connectors, clients, etc.
  /////////////////////////////////////////////////////////////////////////////////////////////////

  const mipd =
    typeof window !== 'undefined' && multiInjectedProviderDiscovery
      ? createMipd()
      : undefined

  const chains = createStore(() => rest.chains)
  const connectors = createStore(() => {
    const collection = []
    const rdnsSet = new Set<string>()
    for (const connectorFns of rest.connectors ?? []) {
      const connector = setup(connectorFns)
      collection.push(connector)
      if (!ssr && connector.rdns) {
        const rdnsValues =
          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns
        for (const rdns of rdnsValues) {
          rdnsSet.add(rdns)
        }
      }
    }
    if (!ssr && mipd) {
      const providers = mipd.getProviders()
      for (const provider of providers) {
        if (rdnsSet.has(provider.info.rdns)) continue
        collection.push(setup(providerDetailToConnector(provider)))
      }
    }
    return collection
  })
  function setup(connectorFn: CreateConnectorFn): Connector {
    // Set up emitter with uid and add to connector so they are "linked" together.
    const emitter = createEmitter<ConnectorEventMap>(uid())
    const connector = {
      ...connectorFn({
        emitter,
        chains: chains.getState(),
        storage,
        transports: rest.transports,
      }),
      emitter,
      uid: emitter.uid,
    }

    // Start listening for `connect` events on connector setup
    // This allows connectors to "connect" themselves without user interaction (e.g. MetaMask's "Manually connect to current site")
    emitter.on('connect', connect)
    connector.setup?.()

    return connector
  }
  function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {
    const { info } = providerDetail
    const provider = providerDetail.provider as any
    return injected({ target: { ...info, id: info.rdns, provider } })
  }

  const clients = new Map<number, Client<Transport, chains[number]>>()
  function getClient<chainId extends chains[number]['id']>(
    config: { chainId?: chainId | chains[number]['id'] | undefined } = {},
  ): Client<Transport, Extract<chains[number], { id: chainId }>> {
    const chainId = config.chainId ?? store.getState().chainId
    const chain = chains.getState().find((x) => x.id === chainId)

    // chainId specified and not configured
    if (config.chainId && !chain) throw new ChainNotConfiguredError()

    // If the target chain is not configured, use the client of the current chain.
    type Return = Client<Transport, Extract<chains[number], { id: chainId }>>
    {
      const client = clients.get(store.getState().chainId)
      if (client && !chain) return client as Return
      if (!chain) throw new ChainNotConfiguredError()
    }

    // If a memoized client exists for a chain id, use that.
    {
      const client = clients.get(chainId)
      if (client) return client as Return
    }

    let client: Client<Transport, chains[number]>
    if (rest.client) client = rest.client({ chain })
    else {
      const chainId = chain.id as chains[number]['id']
      const chainIds = chains.getState().map((x) => x.id)
      // Grab all properties off `rest` and resolve for use in `createClient`
      const properties: Partial<viem_ClientConfig> = {}
      const entries = Object.entries(rest) as [keyof typeof rest, any][]

      for (const [key, value] of entries) {
        if (
          key === 'chains' ||
          key === 'client' ||
          key === 'connectors' ||
          key === 'transports'
        )
          continue

        if (typeof value === 'object') {
          // check if value is chainId-specific since some values can be objects
          // e.g. { batch: { multicall: { batchSize: 1024 } } }
          if (chainId in value) properties[key] = value[chainId]
          else {
            // check if value is chainId-specific, but does not have value for current chainId
            const hasChainSpecificValue = chainIds.some((x) => x in value)
            if (hasChainSpecificValue) continue
            properties[key] = value
          }
        } else properties[key] = value
      }

      client = createClient({
        ...properties,
        chain,
        batch: properties.batch ?? { multicall: true },
        transport: (parameters) =>
          rest.transports[chainId]({ ...parameters, connectors }),
      })
    }

    clients.set(chainId, client)
    return client as Return
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Create store
  /////////////////////////////////////////////////////////////////////////////////////////////////

  function getInitialState(): State {
    return {
      chainId: chains.getState()[0].id,
      connections: new Map<string, Connection>(),
      current: null,
      status: 'disconnected',
    }
  }

  let currentVersion: number
  const prefix = '0.0.0-canary-'
  if (version.startsWith(prefix))
    currentVersion = Number.parseInt(version.replace(prefix, ''))
  // use package major version to version store
  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0')

  const store = createStore(
    subscribeWithSelector(
      // only use persist middleware if storage exists
      storage
        ? persist(getInitialState, {
            migrate(persistedState, version) {
              if (version === currentVersion) return persistedState as State

              const initialState = getInitialState()
              const chainId = validatePersistedChainId(
                persistedState,
                initialState.chainId,
              )
              return { ...initialState, chainId }
            },
            name: 'store',
            partialize(state) {
              // Only persist "critical" store properties to preserve storage size.
              return {
                connections: {
                  __type: 'Map',
                  value: Array.from(state.connections.entries()).map(
                    ([key, connection]) => {
                      const { id, name, type, uid } = connection.connector
                      const connector = { id, name, type, uid }
                      return [key, { ...connection, connector }]
                    },
                  ),
                } as unknown as PartializedState['connections'],
                chainId: state.chainId,
                current: state.current,
              } satisfies PartializedState
            },
            merge(persistedState, currentState) {
              // `status` should not be persisted as it messes with reconnection
              if (
                typeof persistedState === 'object' &&
                persistedState &&
                'status' in persistedState
              )
                delete persistedState.status
              // Make sure persisted `chainId` is valid
              const chainId = validatePersistedChainId(
                persistedState,
                currentState.chainId,
              )
              return {
                ...currentState,
                ...(persistedState as object),
                chainId,
              }
            },
            skipHydration: ssr,
            storage: storage as Storage<Record<string, unknown>>,
            version: currentVersion,
          })
        : getInitialState,
    ),
  )
  store.setState(getInitialState())

  function validatePersistedChainId(
    persistedState: unknown,
    defaultChainId: number,
  ) {
    return persistedState &&
      typeof persistedState === 'object' &&
      'chainId' in persistedState &&
      typeof persistedState.chainId === 'number' &&
      chains.getState().some((x) => x.id === persistedState.chainId)
      ? persistedState.chainId
      : defaultChainId
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Subscribe to changes
  /////////////////////////////////////////////////////////////////////////////////////////////////

  // Update default chain when connector chain changes
  if (syncConnectedChain)
    store.subscribe(
      ({ connections, current }) =>
        current ? connections.get(current)?.chainId : undefined,
      (chainId) => {
        // If chain is not configured, then don't switch over to it.
        const isChainConfigured = chains
          .getState()
          .some((x) => x.id === chainId)
        if (!isChainConfigured) return

        return store.setState((x) => ({
          ...x,
          chainId: chainId ?? x.chainId,
        }))
      },
    )

  // EIP-6963 subscribe for new wallet providers
  mipd?.subscribe((providerDetails) => {
    const connectorIdSet = new Set<string>()
    const connectorRdnsSet = new Set<string>()
    for (const connector of connectors.getState()) {
      connectorIdSet.add(connector.id)
      if (connector.rdns) {
        const rdnsValues =
          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns
        for (const rdns of rdnsValues) {
          connectorRdnsSet.add(rdns)
        }
      }
    }

    const newConnectors: Connector[] = []
    for (const providerDetail of providerDetails) {
      if (connectorRdnsSet.has(providerDetail.info.rdns)) continue
      const connector = setup(providerDetailToConnector(providerDetail))
      if (connectorIdSet.has(connector.id)) continue
      newConnectors.push(connector)
    }

    if (storage && !store.persist.hasHydrated()) return
    connectors.setState((x) => [...x, ...newConnectors], true)
  })

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Emitter listeners
  /////////////////////////////////////////////////////////////////////////////////////////////////

  function change(data: EventData<ConnectorEventMap, 'change'>) {
    store.setState((x) => {
      const connection = x.connections.get(data.uid)
      if (!connection) return x
      return {
        ...x,
        connections: new Map(x.connections).set(data.uid, {
          accounts:
            (data.accounts as readonly [Address, ...Address[]]) ??
            connection.accounts,
          chainId: data.chainId ?? connection.chainId,
          connector: connection.connector,
        }),
      }
    })
  }
  function connect(data: EventData<ConnectorEventMap, 'connect'>) {
    // Disable handling if reconnecting/connecting
    if (
      store.getState().status === 'connecting' ||
      store.getState().status === 'reconnecting'
    )
      return

    store.setState((x) => {
      const connector = connectors.getState().find((x) => x.uid === data.uid)
      if (!connector) return x

      if (connector.emitter.listenerCount('connect'))
        connector.emitter.off('connect', change)
      if (!connector.emitter.listenerCount('change'))
        connector.emitter.on('change', change)
      if (!connector.emitter.listenerCount('disconnect'))
        connector.emitter.on('disconnect', disconnect)

      return {
        ...x,
        connections: new Map(x.connections).set(data.uid, {
          accounts: data.accounts as readonly [Address, ...Address[]],
          chainId: data.chainId,
          connector: connector,
        }),
        current: data.uid,
        status: 'connected',
      }
    })
  }
  function disconnect(data: EventData<ConnectorEventMap, 'disconnect'>) {
    store.setState((x) => {
      const connection = x.connections.get(data.uid)
      if (connection) {
        const connector = connection.connector
        if (connector.emitter.listenerCount('change'))
          connection.connector.emitter.off('change', change)
        if (connector.emitter.listenerCount('disconnect'))
          connection.connector.emitter.off('disconnect', disconnect)
        if (!connector.emitter.listenerCount('connect'))
          connection.connector.emitter.on('connect', connect)
      }

      x.connections.delete(data.uid)

      if (x.connections.size === 0)
        return {
          ...x,
          connections: new Map(),
          current: null,
          status: 'disconnected',
        }

      const nextConnection = x.connections.values().next().value as Connection
      return {
        ...x,
        connections: new Map(x.connections),
        current: nextConnection.connector.uid,
      }
    })
  }

  return {
    get chains() {
      return chains.getState() as chains
    },
    get connectors() {
      return connectors.getState() as Connector<connectorFns[number]>[]
    },
    storage,

    getClient,
    get state() {
      return store.getState() as unknown as State<chains>
    },
    setState(value) {
      let newState: State
      if (typeof value === 'function') newState = value(store.getState() as any)
      else newState = value

      // Reset state if it got set to something not matching the base state
      const initialState = getInitialState()
      if (typeof newState !== 'object') newState = initialState
      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState))
      if (isCorrupt) newState = initialState

      store.setState(newState, true)
    },
    subscribe(selector, listener, options) {
      return store.subscribe(
        selector as unknown as (state: State) => any,
        listener,
        options
          ? ({
              ...options,
              fireImmediately: options.emitImmediately,
              // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
            } as RemoveUndefined<typeof options>)
          : undefined,
      )
    },

    _internal: {
      mipd,
      store,
      ssr: Boolean(ssr),
      syncConnectedChain,
      transports: rest.transports as transports,
      chains: {
        setState(value) {
          const nextChains = (
            typeof value === 'function' ? value(chains.getState()) : value
          ) as chains
          if (nextChains.length === 0) return
          return chains.setState(nextChains, true)
        },
        subscribe(listener) {
          return chains.subscribe(listener)
        },
      },
      connectors: {
        providerDetailToConnector,
        setup: setup as <connectorFn extends CreateConnectorFn>(
          connectorFn: connectorFn,
        ) => Connector<connectorFn>,
        setState(value) {
          return connectors.setState(
            typeof value === 'function' ? value(connectors.getState()) : value,
            true,
          )
        },
        subscribe(listener) {
          return connectors.subscribe(listener)
        },
      },
      events: { change, connect, disconnect },
    },
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Types
/////////////////////////////////////////////////////////////////////////////////////////////////

export type CreateConfigParameters<
  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],
  transports extends Record<chains[number]['id'], Transport> = Record<
    chains[number]['id'],
    Transport
  >,
  connectorFns extends
    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],
> = Compute<
  {
    chains: chains
    connectors?: connectorFns | undefined
    multiInjectedProviderDiscovery?: boolean | undefined
    storage?: Storage | null | undefined
    ssr?: boolean | undefined
    syncConnectedChain?: boolean | undefined
  } & OneOf<
    | ({ transports: transports } & {
        [key in keyof ClientConfig]?:
          | ClientConfig[key]
          | { [_ in chains[number]['id']]?: ClientConfig[key] | undefined }
          | undefined
      })
    | {
        client(parameters: { chain: chains[number] }): Client<
          transports[chains[number]['id']],
          chains[number]
        >
      }
  >
>

export type Config<
  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],
  transports extends Record<chains[number]['id'], Transport> = Record<
    chains[number]['id'],
    Transport
  >,
  connectorFns extends
    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],
> = {
  readonly chains: chains
  readonly connectors: readonly Connector<connectorFns[number]>[]
  readonly storage: Storage | null

  readonly state: State<chains>
  setState<tchains extends readonly [Chain, ...Chain[]] = chains>(
    value: State<tchains> | ((state: State<tchains>) => State<tchains>),
  ): void
  subscribe<state>(
    selector: (state: State<chains>) => state,
    listener: (state: state, previousState: state) => void,
    options?:
      | {
          emitImmediately?: boolean | undefined
          equalityFn?: ((a: state, b: state) => boolean) | undefined
        }
      | undefined,
  ): () => void

  getClient<chainId extends chains[number]['id']>(parameters?: {
    chainId?: chainId | chains[number]['id'] | undefined
  }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>

  /**
   * Not part of versioned API, proceed with caution.
   * @internal
   */
  _internal: Internal<chains, transports>
}

type Internal<
  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],
  transports extends Record<chains[number]['id'], Transport> = Record<
    chains[number]['id'],
    Transport
  >,
> = {
  readonly mipd: MipdStore | undefined
  readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>
  readonly ssr: boolean
  readonly syncConnectedChain: boolean
  readonly transports: transports

  chains: {
    setState(
      value:
        | readonly [Chain, ...Chain[]]
        | ((
            state: readonly [Chain, ...Chain[]],
          ) => readonly [Chain, ...Chain[]]),
    ): void
    subscribe(
      listener: (
        state: readonly [Chain, ...Chain[]],
        prevState: readonly [Chain, ...Chain[]],
      ) => void,
    ): () => void
  }
  connectors: {
    providerDetailToConnector(
      providerDetail: EIP6963ProviderDetail,
    ): CreateConnectorFn
    setup<connectorFn extends CreateConnectorFn>(
      connectorFn: connectorFn,
    ): Connector<connectorFn>
    setState(value: Connector[] | ((state: Connector[]) => Connector[])): void
    subscribe(
      listener: (state: Connector[], prevState: Connector[]) => void,
    ): () => void
  }
  events: {
    change(data: EventData<ConnectorEventMap, 'change'>): void
    connect(data: EventData<ConnectorEventMap, 'connect'>): void
    disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void
  }
}

export type State<
  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],
> = {
  chainId: chains[number]['id']
  connections: Map<string, Connection>
  current: string | null
  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting'
}

export type PartializedState = Compute<
  ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>
>

export type Connection = {
  accounts: readonly [Address, ...Address[]]
  chainId: number
  connector: Connector
}

export type Connector<
  createConnectorFn extends CreateConnectorFn = CreateConnectorFn,
> = ReturnType<createConnectorFn> & {
  emitter: Emitter<ConnectorEventMap>
  uid: string
}

export type Transport<
  type extends string = string,
  rpcAttributes = Record<string, any>,
  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,
> = (
  params: Parameters<
    viem_Transport<type, rpcAttributes, eip1193RequestFn>
  >[0] & {
    connectors?: StoreApi<Connector[]> | undefined
  },
) => ReturnType<viem_Transport<type, rpcAttributes, eip1193RequestFn>>

type ClientConfig = LooseOmit<
  viem_ClientConfig,
  'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'
>
</file>

<file path="packages/core/src/createEmitter.ts">
import { EventEmitter } from 'eventemitter3'

type EventMap = Record<string, object | never>
type EventKey<eventMap extends EventMap> = string & keyof eventMap
type EventFn<parameters extends unknown[] = any[]> = (
  ...parameters: parameters
) => void
export type EventData<
  eventMap extends EventMap,
  eventName extends keyof eventMap,
> = (eventMap[eventName] extends [never] ? unknown : eventMap[eventName]) & {
  uid: string
}

export class Emitter<eventMap extends EventMap> {
  _emitter = new EventEmitter()

  constructor(public uid: string) {}

  on<key extends EventKey<eventMap>>(
    eventName: key,
    fn: EventFn<
      eventMap[key] extends [never]
        ? [{ uid: string }]
        : [data: eventMap[key] & { uid: string }]
    >,
  ) {
    this._emitter.on(eventName, fn as EventFn)
  }

  once<key extends EventKey<eventMap>>(
    eventName: key,
    fn: EventFn<
      eventMap[key] extends [never]
        ? [{ uid: string }]
        : [data: eventMap[key] & { uid: string }]
    >,
  ) {
    this._emitter.once(eventName, fn as EventFn)
  }

  off<key extends EventKey<eventMap>>(
    eventName: key,
    fn: EventFn<
      eventMap[key] extends [never]
        ? [{ uid: string }]
        : [data: eventMap[key] & { uid: string }]
    >,
  ) {
    this._emitter.off(eventName, fn as EventFn)
  }

  emit<key extends EventKey<eventMap>>(
    eventName: key,
    ...params: eventMap[key] extends [never] ? [] : [data: eventMap[key]]
  ) {
    const data = params[0]
    this._emitter.emit(eventName, { uid: this.uid, ...data })
  }

  listenerCount<key extends EventKey<eventMap>>(eventName: key) {
    return this._emitter.listenerCount(eventName)
  }
}

export function createEmitter<eventMap extends EventMap>(uid: string) {
  return new Emitter<eventMap>(uid)
}
</file>

<file path="packages/core/src/createStorage.test-d.ts">
import { expectTypeOf, test } from 'vitest'
import { createStorage } from './createStorage.js'

import type { Connection } from './createConfig.js'

test('getItem', () => {
  const storage = createStorage({ storage: localStorage })

  expectTypeOf(storage.getItem('recentConnectorId')).toEqualTypeOf<
    string | null | Promise<string | null>
  >()
  expectTypeOf(storage.getItem('recentConnectorId', 'foo')).toEqualTypeOf<
    string | Promise<string>
  >()
  expectTypeOf(storage.getItem('foo')).toEqualTypeOf<unknown>()
  // @ts-expect-error incorrect argument type
  storage.getItem('recentConnectorId', 1n)

  expectTypeOf(storage.getItem('state')).toEqualTypeOf<
    | {
        chainId?: number | undefined
        connections?: Map<string, Connection> | undefined
        current?: string | null | undefined
        status?:
          | 'connected'
          | 'connecting'
          | 'reconnecting'
          | 'disconnected'
          | undefined
      }
    | null
    | Promise<{
        chainId?: number | undefined
        connections?: Map<string, Connection> | undefined
        current?: string | null | undefined
        status?:
          | 'connected'
          | 'connecting'
          | 'reconnecting'
          | 'disconnected'
          | undefined
      } | null>
  >()

  const customStorage = createStorage<{ foo: number }>({
    storage: localStorage,
  })
  expectTypeOf(customStorage.getItem('foo')).toEqualTypeOf<
    number | null | Promise<number | null>
  >()
  expectTypeOf(customStorage.getItem('foo', 1)).toEqualTypeOf<
    number | Promise<number>
  >()
})

test('setItem', () => {
  const storage = createStorage({ storage: localStorage })

  storage.setItem('recentConnectorId', 'foo')
  // @ts-expect-error incorrect argument type
  storage.setItem('recentConnectorId', 1n)
})

test('serialize/deserialize types', () => {
  createStorage({
    deserialize(value) {
      return value
    },
    serialize(value) {
      return value
    },
    storage: localStorage,
  })
})
</file>

<file path="packages/core/src/createStorage.ts">
import type { PartializedState } from './createConfig.js'
import type { Compute } from './types/utils.js'
import { deserialize as deserialize_ } from './utils/deserialize.js'
import { serialize as serialize_ } from './utils/serialize.js'

// key-values for loose autocomplete and typing
export type StorageItemMap = {
  recentConnectorId: string
  state: PartializedState
}

export type Storage<
  itemMap extends Record<string, unknown> = Record<string, unknown>,
  ///
  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,
> = {
  key: string
  getItem<
    key extends keyof storageItemMap,
    value extends storageItemMap[key],
    defaultValue extends value | null | undefined,
  >(
    key: key,
    defaultValue?: defaultValue | undefined,
  ):
    | (defaultValue extends null ? value | null : value)
    | Promise<defaultValue extends null ? value | null : value>
  setItem<
    key extends keyof storageItemMap,
    value extends storageItemMap[key] | null,
  >(key: key, value: value): void | Promise<void>
  removeItem(key: keyof storageItemMap): void | Promise<void>
}

export type BaseStorage = {
  getItem(
    key: string,
  ): string | null | undefined | Promise<string | null | undefined>
  setItem(key: string, value: string): void | Promise<void>
  removeItem(key: string): void | Promise<void>
}

export type CreateStorageParameters = {
  deserialize?: (<type>(value: string) => type | unknown) | undefined
  key?: string | undefined
  serialize?: (<type>(value: type | any) => string) | undefined
  storage?: Compute<BaseStorage> | undefined
}

export function createStorage<
  itemMap extends Record<string, unknown> = Record<string, unknown>,
  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,
>(parameters: CreateStorageParameters): Compute<Storage<storageItemMap>> {
  const {
    deserialize = deserialize_,
    key: prefix = 'wagmi',
    serialize = serialize_,
    storage = noopStorage,
  } = parameters

  function unwrap<type>(value: type): type | Promise<type> {
    if (value instanceof Promise) return value.then((x) => x).catch(() => null)
    return value
  }

  return {
    ...storage,
    key: prefix,
    async getItem(key, defaultValue) {
      const value = storage.getItem(`${prefix}.${key as string}`)
      const unwrapped = await unwrap(value)
      if (unwrapped) return deserialize(unwrapped) ?? null
      return (defaultValue ?? null) as any
    },
    async setItem(key, value) {
      const storageKey = `${prefix}.${key as string}`
      if (value === null) await unwrap(storage.removeItem(storageKey))
      else await unwrap(storage.setItem(storageKey, serialize(value)))
    },
    async removeItem(key) {
      await unwrap(storage.removeItem(`${prefix}.${key as string}`))
    },
  }
}

export const noopStorage = {
  getItem: () => null,
  setItem: () => {},
  removeItem: () => {},
} satisfies BaseStorage

export function getDefaultStorage() {
  const storage = (() => {
    if (typeof window !== 'undefined' && window.localStorage)
      return window.localStorage
    return noopStorage
  })()
  return {
    getItem(key) {
      return storage.getItem(key)
    },
    removeItem(key) {
      storage.removeItem(key)
    },
    setItem(key, value) {
      try {
        storage.setItem(key, value)
        // silence errors by default (QuotaExceededError, SecurityError, etc.)
      } catch {}
    },
  } satisfies BaseStorage
}
</file>

<file path="packages/core/src/hydrate.ts">
import { reconnect } from './actions/reconnect.js'
import type { Config, State } from './createConfig.js'

type HydrateParameters = {
  initialState?: State | undefined
  reconnectOnMount?: boolean | undefined
}

export function hydrate(config: Config, parameters: HydrateParameters) {
  const { initialState, reconnectOnMount } = parameters

  if (initialState && !config._internal.store.persist.hasHydrated())
    config.setState({
      ...initialState,
      chainId: config.chains.some((x) => x.id === initialState.chainId)
        ? initialState.chainId
        : config.chains[0].id,
      connections: reconnectOnMount ? initialState.connections : new Map(),
      status: reconnectOnMount ? 'reconnecting' : 'disconnected',
    })

  return {
    async onMount() {
      if (config._internal.ssr) {
        await config._internal.store.persist.rehydrate()
        if (config._internal.mipd) {
          config._internal.connectors.setState((connectors) => {
            const rdnsSet = new Set<string>()
            for (const connector of connectors ?? []) {
              if (connector.rdns) {
                const rdnsValues = Array.isArray(connector.rdns)
                  ? connector.rdns
                  : [connector.rdns]
                for (const rdns of rdnsValues) {
                  rdnsSet.add(rdns)
                }
              }
            }
            const mipdConnectors = []
            const providers = config._internal.mipd?.getProviders() ?? []
            for (const provider of providers) {
              if (rdnsSet.has(provider.info.rdns)) continue
              const connectorFn =
                config._internal.connectors.providerDetailToConnector(provider)
              const connector = config._internal.connectors.setup(connectorFn)
              mipdConnectors.push(connector)
            }
            return [...connectors, ...mipdConnectors]
          })
        }
      }

      if (reconnectOnMount) reconnect(config)
      else if (config.storage)
        // Reset connections that may have been hydrated from storage.
        config.setState((x) => ({
          ...x,
          connections: new Map(),
        }))
    },
  }
}
</file>

<file path="packages/core/src/version.ts">
export const version = '2.17.1'
</file>

<file path="packages/core/test/setup.ts">
import { vi } from 'vitest'

vi.mock('../src/version.ts', () => {
  return { version: 'x.y.z' }
})
</file>

<file path="packages/core/package.json">
{
  "name": "@wagmi/core",
  "description": "VanillaJS library for Ethereum",
  "version": "2.17.1",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/wevm/wagmi.git",
    "directory": "packages/core"
  },
  "scripts": {
    "build": "pnpm run clean && pnpm run build:esm+types",
    "build:esm+types": "tsc --project tsconfig.build.json --outDir ./dist/esm --declaration --declarationMap --declarationDir ./dist/types",
    "check:types": "tsc --noEmit",
    "clean": "rm -rf dist tsconfig.tsbuildinfo actions chains codegen experimental internal query",
    "test:build": "publint --strict && attw --pack --ignore-rules cjs-resolves-to-esm"
  },
  "files": [
    "dist/**",
    "!dist/**/*.tsbuildinfo",
    "src/**/*.ts",
    "!src/**/*.test.ts",
    "!src/**/*.test-d.ts",
    "/actions",
    "/chains",
    "/experimental",
    "/internal",
    "/query"
  ],
  "sideEffects": false,
  "type": "module",
  "main": "./dist/esm/exports/index.js",
  "types": "./dist/types/exports/index.d.ts",
  "typings": "./dist/types/exports/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/types/exports/index.d.ts",
      "default": "./dist/esm/exports/index.js"
    },
    "./actions": {
      "types": "./dist/types/exports/actions.d.ts",
      "default": "./dist/esm/exports/actions.js"
    },
    "./chains": {
      "types": "./dist/types/exports/chains.d.ts",
      "default": "./dist/esm/exports/chains.js"
    },
    "./codegen": {
      "types": "./dist/types/exports/codegen.d.ts",
      "default": "./dist/esm/exports/codegen.js"
    },
    "./experimental": {
      "types": "./dist/types/exports/experimental.d.ts",
      "default": "./dist/esm/exports/experimental.js"
    },
    "./internal": {
      "types": "./dist/types/exports/internal.d.ts",
      "default": "./dist/esm/exports/internal.js"
    },
    "./query": {
      "types": "./dist/types/exports/query.d.ts",
      "default": "./dist/esm/exports/query.js"
    },
    "./package.json": "./package.json"
  },
  "typesVersions": {
    "*": {
      "actions": ["./dist/types/exports/actions.d.ts"],
      "chains": ["./dist/types/exports/chains.d.ts"],
      "codegen": ["./dist/types/exports/codegen.d.ts"],
      "experimental": ["./dist/types/exports/experimental.d.ts"],
      "internal": ["./dist/types/exports/internal.d.ts"],
      "query": ["./dist/types/exports/query.d.ts"]
    }
  },
  "peerDependencies": {
    "@tanstack/query-core": ">=5.0.0",
    "typescript": ">=5.0.4",
    "viem": "2.x"
  },
  "peerDependenciesMeta": {
    "@tanstack/query-core": {
      "optional": true
    },
    "typescript": {
      "optional": true
    }
  },
  "dependencies": {
    "eventemitter3": "5.0.1",
    "mipd": "0.0.7",
    "zustand": "5.0.0"
  },
  "devDependencies": {
    "@tanstack/query-core": "catalog:"
  },
  "contributors": ["awkweb.eth <t@wevm.dev>", "jxom.eth <j@wevm.dev>"],
  "funding": "https://github.com/sponsors/wevm",
  "keywords": ["wagmi", "eth", "ethereum", "dapps", "wallet", "web3"]
}
</file>

<file path="packages/core/README.md">
# @wagmi/core

VanillaJS library for Ethereum

## Installation

```bash
pnpm add @wagmi/core viem
```

## Documentation

For documentation and guides, visit [wagmi.sh](https://wagmi.sh).
</file>

<file path="packages/core/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/*.test.ts", "src/**/*.test-d.ts"],
  "compilerOptions": {
    "sourceMap": true
  }
}
</file>

<file path="packages/core/tsconfig.json">
{
  "extends": "./tsconfig.build.json",
  "include": ["src/**/*.ts", "test/**/*.ts"],
  "exclude": []
}
</file>

<file path="packages/react/src/errors/base.ts">
import { BaseError as CoreError } from '@wagmi/core'

import { getVersion } from '../utils/getVersion.js'

export type BaseErrorType = BaseError & { name: 'WagmiError' }
export class BaseError extends CoreError {
  override name = 'WagmiError'
  override get docsBaseUrl() {
    return 'https://wagmi.sh/react'
  }
  override get version() {
    return getVersion()
  }
}
</file>

<file path="packages/react/src/errors/context.ts">
import { BaseError } from './base.js'

export type WagmiProviderNotFoundErrorType = WagmiProviderNotFoundError & {
  name: 'WagmiProviderNotFoundError'
}
export class WagmiProviderNotFoundError extends BaseError {
  override name = 'WagmiProviderNotFoundError'
  constructor() {
    super('`useConfig` must be used within `WagmiProvider`.', {
      docsPath: '/api/WagmiProvider',
    })
  }
}
</file>

<file path="packages/react/src/experimental/hooks/useWriteContracts.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { Config, ResolvedRegister } from '@wagmi/core'
import {
  type WriteContractsData,
  type WriteContractsErrorType,
  type WriteContractsMutate,
  type WriteContractsMutateAsync,
  type WriteContractsVariables,
  writeContractsMutationOptions,
} from '@wagmi/core/experimental'
import type { Compute } from '@wagmi/core/internal'
import type { ContractFunctionParameters } from 'viem'

import { useConfig } from '../../hooks/useConfig.js'
import type { ConfigParameter } from '../../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../../utils/query.js'

export type UseWriteContractsParameters<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          WriteContractsData,
          WriteContractsErrorType,
          WriteContractsVariables<
            contracts,
            config,
            config['chains'][number]['id']
          >,
          context
        >
      | undefined
  }
>

export type UseWriteContractsReturnType<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  config extends Config = Config,
  context = unknown,
> = Compute<
  UseMutationReturnType<
    WriteContractsData,
    WriteContractsErrorType,
    WriteContractsVariables<contracts, config, config['chains'][number]['id']>,
    context
  > & {
    writeContracts: WriteContractsMutate<contracts, config, context>
    writeContractsAsync: WriteContractsMutateAsync<contracts, config, context>
  }
>

/** https://wagmi.sh/react/api/hooks/useWriteContracts */
export function useWriteContracts<
  const contracts extends
    readonly unknown[] = readonly ContractFunctionParameters[],
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseWriteContractsParameters<contracts, config, context> = {},
): UseWriteContractsReturnType<contracts, config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = writeContractsMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseWriteContractsReturnType<contracts, config, context>
  return {
    ...result,
    writeContracts: mutate as Return['writeContracts'],
    writeContractsAsync: mutateAsync as Return['writeContractsAsync'],
  }
}
</file>

<file path="packages/react/src/exports/actions/experimental.ts">
////////////////////////////////////////////////////////////////////////////////
// @wagmi/core/experimental
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from '@wagmi/core/experimental'
</file>

<file path="packages/react/src/exports/actions.ts">
////////////////////////////////////////////////////////////////////////////////
// @wagmi/core/actions
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from '@wagmi/core/actions'
</file>

<file path="packages/react/src/exports/chains.ts">
////////////////////////////////////////////////////////////////////////////////
// viem/chains
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from 'viem/chains'
</file>

<file path="packages/react/src/exports/codegen.ts">
////////////////////////////////////////////////////////////////////////////////
// @wagmi/core/codegen
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from '@wagmi/core/codegen'

////////////////////////////////////////////////////////////////////////////////
// Hooks
////////////////////////////////////////////////////////////////////////////////

export {
  type CreateUseSimulateContractParameters,
  type CreateUseSimulateContractReturnType,
  createUseSimulateContract,
} from '../hooks/codegen/createUseSimulateContract.js'

export {
  type CreateUseReadContractParameters,
  type CreateUseReadContractReturnType,
  createUseReadContract,
} from '../hooks/codegen/createUseReadContract.js'

export {
  type CreateUseWatchContractEventParameters,
  type CreateUseWatchContractEventReturnType,
  createUseWatchContractEvent,
} from '../hooks/codegen/createUseWatchContractEvent.js'

export {
  type CreateUseWriteContractParameters,
  type CreateUseWriteContractReturnType,
  createUseWriteContract,
} from '../hooks/codegen/createUseWriteContract.js'
</file>

<file path="packages/react/src/exports/connectors.ts">
////////////////////////////////////////////////////////////////////////////////
// @wagmi/connectors
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from '@wagmi/connectors'
</file>

<file path="packages/react/src/exports/experimental.ts">
////////////////////////////////////////////////////////////////////////////////
// Hooks
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  /** @deprecated This is no longer experimental  use `import type { UseCallsStatusParameters } from 'wagmi'` instead. */
  type UseCallsStatusParameters,
  /** @deprecated This is no longer experimental  use `import type { UseCallsStatusReturnType } from 'wagmi'` instead. */
  type UseCallsStatusReturnType,
  /** @deprecated This is no longer experimental  use `import { useCallsStatus } from 'wagmi'` instead. */
  useCallsStatus,
} from '../hooks/useCallsStatus.js'

export {
  /** @deprecated This is no longer experimental  use `import type { UseCapabilitiesParameters } from 'wagmi'` instead. */
  type UseCapabilitiesParameters,
  /** @deprecated This is no longer experimental  use `import type { UseCapabilitiesReturnType } from 'wagmi'` instead. */
  type UseCapabilitiesReturnType,
  /** @deprecated This is no longer experimental  use `import { useCapabilities } from 'wagmi'` instead. */
  useCapabilities,
} from '../hooks/useCapabilities.js'

export {
  /** @deprecated This is no longer experimental  use `import type { UseSendCallsParameters } from 'wagmi'` instead. */
  type UseSendCallsParameters,
  /** @deprecated This is no longer experimental  use `import type { UseSendCallsReturnType } from 'wagmi'` instead. */
  type UseSendCallsReturnType,
  /** @deprecated This is no longer experimental  use `import { useSendCalls } from 'wagmi'` instead. */
  useSendCalls,
} from '../hooks/useSendCalls.js'

export {
  /** @deprecated This is no longer experimental  use `import type { UseShowCallsStatusParameters } from 'wagmi'` instead. */
  type UseShowCallsStatusParameters,
  /** @deprecated This is no longer experimental  use `import type { UseShowCallsStatusReturnType } from 'wagmi'` instead. */
  type UseShowCallsStatusReturnType,
  /** @deprecated This is no longer experimental  use `import { useShowCallsStatus } from 'wagmi'` instead. */
  useShowCallsStatus,
} from '../hooks/useShowCallsStatus.js'

export {
  /** @deprecated This is no longer experimental  use `import type { UseWaitForCallsStatusParameters } from 'wagmi'` instead. */
  type UseWaitForCallsStatusParameters,
  /** @deprecated This is no longer experimental  use `import type { UseWaitForCallsStatusReturnType } from 'wagmi'` instead. */
  type UseWaitForCallsStatusReturnType,
  /** @deprecated This is no longer experimental  use `import { useWaitForCallsStatus } from 'wagmi'` instead. */
  useWaitForCallsStatus,
} from '../hooks/useWaitForCallsStatus.js'

export {
  /** @deprecated Use `UseSendCallsParameters` instead. */
  type UseWriteContractsParameters,
  /** @deprecated Use `UseSendCallsReturnType` instead. */
  type UseWriteContractsReturnType,
  /** @deprecated Use `useSendCalls` instead. */
  useWriteContracts,
} from '../experimental/hooks/useWriteContracts.js'
</file>

<file path="packages/react/src/exports/index.ts">
////////////////////////////////////////////////////////////////////////////////
// Context
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type WagmiProviderProps,
  WagmiContext,
  WagmiProvider,
  /** @deprecated Use `WagmiContext` instead */
  WagmiContext as Context,
  /** @deprecated Use `WagmiProvider` instead */
  WagmiProvider as WagmiConfig,
} from '../context.js'

////////////////////////////////////////////////////////////////////////////////
// Errors
////////////////////////////////////////////////////////////////////////////////

export { type BaseErrorType, BaseError } from '../errors/base.js'

export {
  type WagmiProviderNotFoundErrorType,
  WagmiProviderNotFoundError,
} from '../errors/context.js'

////////////////////////////////////////////////////////////////////////////////
// Hooks
////////////////////////////////////////////////////////////////////////////////

export {
  type UseAccountParameters,
  type UseAccountReturnType,
  useAccount,
} from '../hooks/useAccount.js'

export {
  type UseAccountEffectParameters,
  useAccountEffect,
} from '../hooks/useAccountEffect.js'

export {
  type UseBalanceParameters,
  type UseBalanceReturnType,
  useBalance,
} from '../hooks/useBalance.js'

export {
  type UseBlockParameters,
  type UseBlockReturnType,
  useBlock,
} from '../hooks/useBlock.js'

export {
  type UseBlockNumberParameters,
  type UseBlockNumberReturnType,
  useBlockNumber,
} from '../hooks/useBlockNumber.js'

export {
  type UseBlockTransactionCountParameters,
  type UseBlockTransactionCountReturnType,
  useBlockTransactionCount,
} from '../hooks/useBlockTransactionCount.js'

export {
  type UseBytecodeParameters,
  type UseBytecodeReturnType,
  useBytecode,
} from '../hooks/useBytecode.js'

export {
  type UseCallsStatusParameters,
  type UseCallsStatusReturnType,
  useCallsStatus,
} from '../hooks/useCallsStatus.js'

export {
  type UseCapabilitiesParameters,
  type UseCapabilitiesReturnType,
  useCapabilities,
} from '../hooks/useCapabilities.js'

export {
  type UseCallParameters,
  type UseCallReturnType,
  useCall,
} from '../hooks/useCall.js'

export {
  type UseChainIdParameters,
  type UseChainIdReturnType,
  useChainId,
} from '../hooks/useChainId.js'

export {
  type UseChainsParameters,
  type UseChainsReturnType,
  useChains,
} from '../hooks/useChains.js'

export {
  type UseClientParameters,
  type UseClientReturnType,
  useClient,
} from '../hooks/useClient.js'

export {
  type UseConfigParameters,
  type UseConfigReturnType,
  useConfig,
} from '../hooks/useConfig.js'

export {
  type UseConnectParameters,
  type UseConnectReturnType,
  useConnect,
} from '../hooks/useConnect.js'

export {
  type UseConnectionsParameters,
  type UseConnectionsReturnType,
  useConnections,
} from '../hooks/useConnections.js'

export {
  type UseConnectorsParameters,
  type UseConnectorsReturnType,
  useConnectors,
} from '../hooks/useConnectors.js'

export {
  type UseConnectorClientParameters,
  type UseConnectorClientReturnType,
  useConnectorClient,
} from '../hooks/useConnectorClient.js'

export {
  type UseDeployContractParameters,
  type UseDeployContractReturnType,
  useDeployContract,
} from '../hooks/useDeployContract.js'

export {
  type UseDisconnectParameters,
  type UseDisconnectReturnType,
  useDisconnect,
} from '../hooks/useDisconnect.js'

export {
  type UseEnsAddressParameters,
  type UseEnsAddressReturnType,
  useEnsAddress,
} from '../hooks/useEnsAddress.js'

export {
  type UseEnsAvatarParameters,
  type UseEnsAvatarReturnType,
  useEnsAvatar,
} from '../hooks/useEnsAvatar.js'

export {
  type UseEnsNameParameters,
  type UseEnsNameReturnType,
  useEnsName,
} from '../hooks/useEnsName.js'

export {
  type UseEnsResolverParameters,
  type UseEnsResolverReturnType,
  useEnsResolver,
} from '../hooks/useEnsResolver.js'

export {
  type UseEnsTextParameters,
  type UseEnsTextReturnType,
  useEnsText,
} from '../hooks/useEnsText.js'

export {
  type UseEstimateFeesPerGasParameters,
  type UseEstimateFeesPerGasReturnType,
  useEstimateFeesPerGas,
  /** @deprecated Use `useEstimateFeesPerGas` instead */
  useEstimateFeesPerGas as useFeeData,
} from '../hooks/useEstimateFeesPerGas.js'

export {
  type UseEstimateGasParameters,
  type UseEstimateGasReturnType,
  useEstimateGas,
} from '../hooks/useEstimateGas.js'

export {
  type UseEstimateMaxPriorityFeePerGasParameters,
  type UseEstimateMaxPriorityFeePerGasReturnType,
  useEstimateMaxPriorityFeePerGas,
} from '../hooks/useEstimateMaxPriorityFeePerGas.js'

export {
  type UseFeeHistoryParameters,
  type UseFeeHistoryReturnType,
  useFeeHistory,
} from '../hooks/useFeeHistory.js'

export {
  type UseGasPriceParameters,
  type UseGasPriceReturnType,
  useGasPrice,
} from '../hooks/useGasPrice.js'

export {
  type UseInfiniteContractReadsParameters,
  type UseInfiniteContractReadsReturnType,
  useInfiniteReadContracts,
  /** @deprecated Use `useInfiniteReadContracts` instead */
  useInfiniteReadContracts as useContractInfiniteReads,
} from '../hooks/useInfiniteReadContracts.js'

export {
  type UsePrepareTransactionRequestParameters,
  type UsePrepareTransactionRequestReturnType,
  usePrepareTransactionRequest,
} from '../hooks/usePrepareTransactionRequest.js'

export {
  type UseProofParameters,
  type UseProofReturnType,
  useProof,
} from '../hooks/useProof.js'

export {
  type UsePublicClientParameters,
  type UsePublicClientReturnType,
  usePublicClient,
} from '../hooks/usePublicClient.js'

export {
  type UseReadContractParameters,
  type UseReadContractReturnType,
  useReadContract,
  /** @deprecated Use `useWriteContract` instead */
  useReadContract as useContractRead,
} from '../hooks/useReadContract.js'

export {
  type UseReadContractsParameters,
  type UseReadContractsReturnType,
  useReadContracts,
  /** @deprecated Use `useWriteContract` instead */
  useReadContracts as useContractReads,
} from '../hooks/useReadContracts.js'

export {
  type UseReconnectParameters,
  type UseReconnectReturnType,
  useReconnect,
} from '../hooks/useReconnect.js'

export {
  type UseSendCallsParameters,
  type UseSendCallsReturnType,
  useSendCalls,
} from '../hooks/useSendCalls.js'

export {
  type UseSendTransactionParameters,
  type UseSendTransactionReturnType,
  useSendTransaction,
} from '../hooks/useSendTransaction.js'

export {
  type UseShowCallsStatusParameters,
  type UseShowCallsStatusReturnType,
  useShowCallsStatus,
} from '../hooks/useShowCallsStatus.js'

export {
  type UseSignMessageParameters,
  type UseSignMessageReturnType,
  useSignMessage,
} from '../hooks/useSignMessage.js'

export {
  type UseSignTypedDataParameters,
  type UseSignTypedDataReturnType,
  useSignTypedData,
} from '../hooks/useSignTypedData.js'

export {
  type UseSimulateContractParameters,
  type UseSimulateContractReturnType,
  useSimulateContract,
} from '../hooks/useSimulateContract.js'

export {
  type UseStorageAtParameters,
  type UseStorageAtReturnType,
  useStorageAt,
} from '../hooks/useStorageAt.js'

export {
  type UseSwitchAccountParameters,
  type UseSwitchAccountReturnType,
  useSwitchAccount,
} from '../hooks/useSwitchAccount.js'

export {
  type UseSwitchChainParameters,
  type UseSwitchChainReturnType,
  useSwitchChain,
} from '../hooks/useSwitchChain.js'

export {
  type UseTokenParameters,
  type UseTokenReturnType,
  /** @deprecated Use `useReadContracts` instead */
  useToken,
} from '../hooks/useToken.js'

export {
  type UseTransactionParameters,
  type UseTransactionReturnType,
  useTransaction,
} from '../hooks/useTransaction.js'

export {
  type UseTransactionConfirmationsParameters,
  type UseTransactionConfirmationsReturnType,
  useTransactionConfirmations,
} from '../hooks/useTransactionConfirmations.js'

export {
  type UseTransactionCountParameters,
  type UseTransactionCountReturnType,
  useTransactionCount,
} from '../hooks/useTransactionCount.js'

export {
  type UseTransactionReceiptParameters,
  type UseTransactionReceiptReturnType,
  useTransactionReceipt,
} from '../hooks/useTransactionReceipt.js'

export {
  type UseVerifyMessageParameters,
  type UseVerifyMessageReturnType,
  useVerifyMessage,
} from '../hooks/useVerifyMessage.js'

export {
  type UseVerifyTypedDataParameters,
  type UseVerifyTypedDataReturnType,
  useVerifyTypedData,
} from '../hooks/useVerifyTypedData.js'

export {
  type UseWalletClientParameters,
  type UseWalletClientReturnType,
  useWalletClient,
} from '../hooks/useWalletClient.js'

export {
  type UseWaitForCallsStatusParameters,
  type UseWaitForCallsStatusReturnType,
  useWaitForCallsStatus,
} from '../hooks/useWaitForCallsStatus.js'

export {
  type UseWaitForTransactionReceiptParameters,
  type UseWaitForTransactionReceiptReturnType,
  useWaitForTransactionReceipt,
} from '../hooks/useWaitForTransactionReceipt.js'

export {
  type UseWatchAssetParameters,
  type UseWatchAssetReturnType,
  useWatchAsset,
} from '../hooks/useWatchAsset.js'

export {
  type UseWatchBlocksParameters,
  type UseWatchBlocksReturnType,
  useWatchBlocks,
} from '../hooks/useWatchBlocks.js'

export {
  type UseWatchBlockNumberParameters,
  type UseWatchBlockNumberReturnType,
  useWatchBlockNumber,
} from '../hooks/useWatchBlockNumber.js'

export {
  type UseWatchContractEventParameters,
  type UseWatchContractEventReturnType,
  useWatchContractEvent,
} from '../hooks/useWatchContractEvent.js'

export {
  type UseWatchPendingTransactionsParameters,
  type UseWatchPendingTransactionsReturnType,
  useWatchPendingTransactions,
} from '../hooks/useWatchPendingTransactions.js'

export {
  type UseWriteContractParameters,
  type UseWriteContractReturnType,
  useWriteContract,
  /** @deprecated Use `useWriteContract` instead */
  useWriteContract as useContractWrite,
} from '../hooks/useWriteContract.js'

////////////////////////////////////////////////////////////////////////////////
// Hydrate
////////////////////////////////////////////////////////////////////////////////

export {
  type HydrateProps,
  Hydrate,
} from '../hydrate.js'

////////////////////////////////////////////////////////////////////////////////
// @wagmi/core
////////////////////////////////////////////////////////////////////////////////

export {
  // Config
  type Connection,
  type Connector,
  type Config,
  type CreateConfigParameters,
  type PartializedState,
  type State,
  createConfig,
  // Connector
  type ConnectorEventMap,
  type CreateConnectorFn,
  createConnector,
  injected,
  mock,
  // Errors
  type ChainNotConfiguredErrorType,
  ChainNotConfiguredError,
  type ConnectorAlreadyConnectedErrorType,
  ConnectorAlreadyConnectedError,
  type ConnectorNotFoundErrorType,
  ConnectorNotFoundError,
  type ConnectorAccountNotFoundErrorType,
  ConnectorAccountNotFoundError,
  type ConnectorChainMismatchErrorType,
  ConnectorChainMismatchError,
  type ConnectorUnavailableReconnectingErrorType,
  ConnectorUnavailableReconnectingError,
  type ProviderNotFoundErrorType,
  ProviderNotFoundError,
  type SwitchChainNotSupportedErrorType,
  SwitchChainNotSupportedError,
  // Storage
  type CreateStorageParameters,
  type Storage,
  createStorage,
  noopStorage,
  // Transports
  custom,
  fallback,
  http,
  webSocket,
  unstable_connector,
  type Transport,
  // Types
  type Register,
  type ResolvedRegister,
  // Utilities
  cookieStorage,
  cookieToInitialState,
  deepEqual,
  deserialize,
  normalizeChainId,
  parseCookie,
  serialize,
} from '@wagmi/core'

////////////////////////////////////////////////////////////////////////////////
// Version
////////////////////////////////////////////////////////////////////////////////

export { version } from '../version.js'
</file>

<file path="packages/react/src/exports/query.ts">
////////////////////////////////////////////////////////////////////////////////
// @wagmi/core/query
////////////////////////////////////////////////////////////////////////////////

// biome-ignore lint/performance/noBarrelFile: entrypoint module
// biome-ignore lint/performance/noReExportAll: entrypoint module
export * from '@wagmi/core/query'

export {
  type UseInfiniteQueryParameters,
  type UseInfiniteQueryReturnType,
  type UseMutationParameters,
  type UseMutationReturnType,
  type UseQueryParameters,
  type UseQueryReturnType,
  useInfiniteQuery,
  useMutation,
  useQuery,
} from '../utils/query.js'
</file>

<file path="packages/react/src/hooks/codegen/createUseReadContract.test-d.ts">
import { abi, mainnet, optimism } from '@wagmi/test'
import { assertType, expectTypeOf, test } from 'vitest'

import { createUseReadContract } from './createUseReadContract.js'

test('default', () => {
  const useReadErc20 = createUseReadContract({
    abi: abi.erc20,
  })

  const result = useReadErc20({
    functionName: 'balanceOf',
    args: ['0x'],
    chainId: 123,
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})

test('select data', () => {
  const useReadErc20 = createUseReadContract({
    abi: abi.erc20,
  })

  const result = useReadErc20({
    address: '0x',
    functionName: 'balanceOf',
    args: ['0x'],
    query: {
      select(data) {
        expectTypeOf(data).toEqualTypeOf<bigint>()
        return data?.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})

test('multichain address', () => {
  const useReadErc20 = createUseReadContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const result = useReadErc20({
    functionName: 'balanceOf',
    args: ['0x'],
    chainId: mainnet.id,
    // ^?
  })
  assertType<bigint | undefined>(result.data)

  useReadErc20({
    functionName: 'balanceOf',
    args: ['0x'],
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  useReadErc20({
    functionName: 'balanceOf',
    args: ['0x'],
    // @ts-expect-error address not allowed
    address: '0x',
  })
})

test('overloads', () => {
  const useReadViewOverloads = createUseReadContract({
    abi: abi.viewOverloads,
  })

  const result1 = useReadViewOverloads({
    functionName: 'foo',
  })
  assertType<number | undefined>(result1.data)

  const result2 = useReadViewOverloads({
    functionName: 'foo',
    args: [],
  })
  assertType<number | undefined>(result2.data)

  const result3 = useReadViewOverloads({
    functionName: 'foo',
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.data)

  const result4 = useReadViewOverloads({
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.data)
})

test('functionName', () => {
  const useReadErc20BalanceOf = createUseReadContract({
    abi: abi.erc20,
    address: '0x',
    functionName: 'balanceOf',
  })

  const result = useReadErc20BalanceOf({
    args: ['0x'],
    chainId: 1,
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})

test('functionName with overloads', () => {
  const useReadViewOverloads = createUseReadContract({
    abi: abi.viewOverloads,
    functionName: 'foo',
  })

  const result1 = useReadViewOverloads()
  assertType<number | undefined>(result1.data)

  const result2 = useReadViewOverloads({
    args: [],
  })
  assertType<number | undefined>(result2.data)

  const result3 = useReadViewOverloads({
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.data)

  const result4 = useReadViewOverloads({
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.data)
})
</file>

<file path="packages/react/src/hooks/codegen/createUseReadContract.ts">
import type {
  Config,
  ReadContractErrorType,
  ReadContractParameters,
  ResolvedRegister,
} from '@wagmi/core'
import type {
  ScopeKeyParameter,
  UnionCompute,
  UnionExactPartial,
  UnionStrictOmit,
} from '@wagmi/core/internal'
import type {
  ReadContractData,
  ReadContractQueryFnData,
  ReadContractQueryKey,
} from '@wagmi/core/query'
import type {
  Abi,
  Address,
  ContractFunctionArgs,
  ContractFunctionName,
} from 'viem'

import type { ConfigParameter, QueryParameter } from '../../types/properties.js'
import { useAccount } from '../useAccount.js'
import { useChainId } from '../useChainId.js'
import { useConfig } from '../useConfig.js'
import {
  type UseReadContractReturnType,
  useReadContract,
} from '../useReadContract.js'

type stateMutability = 'pure' | 'view'

export type CreateUseReadContractParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  functionName?:
    | functionName
    | ContractFunctionName<abi, stateMutability>
    | undefined
}

export type CreateUseReadContractReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
  ///
  omittedProperties extends 'abi' | 'address' | 'chainId' | 'functionName' =
    | 'abi'
    | (address extends undefined ? never : 'address')
    | (address extends Record<number, Address> ? 'chainId' : never)
    | (functionName extends undefined ? never : 'functionName'),
> = <
  name extends functionName extends ContractFunctionName<abi, stateMutability>
    ? functionName
    : ContractFunctionName<abi, stateMutability>,
  args extends ContractFunctionArgs<abi, stateMutability, name>,
  config extends Config = ResolvedRegister['config'],
  selectData = ReadContractData<abi, name, args>,
>(
  parameters?: UnionCompute<
    UnionExactPartial<
      UnionStrictOmit<
        ReadContractParameters<abi, name, args, config>,
        omittedProperties
      >
    > &
      ScopeKeyParameter &
      ConfigParameter<config> &
      QueryParameter<
        ReadContractQueryFnData<abi, name, args>,
        ReadContractErrorType,
        selectData,
        ReadContractQueryKey<abi, name, args, config>
      >
  > &
    (address extends Record<number, Address>
      ? { chainId?: keyof address | undefined }
      : unknown),
) => UseReadContractReturnType<abi, name, args, selectData>

export function createUseReadContract<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
>(
  props: CreateUseReadContractParameters<abi, address, functionName>,
): CreateUseReadContractReturnType<abi, address, functionName> {
  if (props.address !== undefined && typeof props.address === 'object')
    return (parameters) => {
      const config = useConfig(parameters)
      const configChainId = useChainId({ config })
      const account = useAccount({ config })
      const chainId =
        (parameters as { chainId?: number })?.chainId ??
        account.chainId ??
        configChainId
      return useReadContract({
        ...(parameters as any),
        ...(props.functionName ? { functionName: props.functionName } : {}),
        address: props.address?.[chainId],
        abi: props.abi,
      })
    }

  return (parameters) => {
    return useReadContract({
      ...(parameters as any),
      ...(props.address ? { address: props.address } : {}),
      ...(props.functionName ? { functionName: props.functionName } : {}),
      abi: props.abi,
    })
  }
}
</file>

<file path="packages/react/src/hooks/codegen/createUseSimulateContract.test-d.ts">
import { abi, mainnet, optimism } from '@wagmi/test'
import type { Address } from 'viem'
import { assertType, expectTypeOf, test } from 'vitest'

import { createUseSimulateContract } from './createUseSimulateContract.js'

test('default', () => {
  const useSimulateErc20 = createUseSimulateContract({
    abi: abi.erc20,
  })

  const result = useSimulateErc20({
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 123,
  })
  result.data?.request.chainId
  expectTypeOf(result.data).toMatchTypeOf<
    | {
        result: boolean
        request: {
          chainId: 123
          abi: readonly [
            {
              readonly name: 'transferFrom'
              readonly type: 'function'
              readonly stateMutability: 'nonpayable'
              readonly inputs: readonly [
                { readonly type: 'address'; readonly name: 'sender' },
                { readonly type: 'address'; readonly name: 'recipient' },
                { readonly type: 'uint256'; readonly name: 'amount' },
              ]
              readonly outputs: readonly [{ type: 'bool' }]
            },
          ]
          functionName: 'transferFrom'
          args: readonly [Address, Address, bigint]
        }
      }
    | undefined
  >()
})

test('select data', () => {
  const useSimulateErc20 = createUseSimulateContract({
    abi: abi.erc20,
  })

  const result = useSimulateErc20({
    address: '0x',
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    query: {
      select(data) {
        expectTypeOf(data.result).toEqualTypeOf<boolean>()
        return data?.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})

test('multichain address', () => {
  const useSimulateErc20 = createUseSimulateContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const result = useSimulateErc20({
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: optimism.id,
  })
  expectTypeOf(result.data?.result).toEqualTypeOf<boolean | undefined>()

  useSimulateErc20({
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  useSimulateErc20({
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    // @ts-expect-error address not allowed
    address: '0x',
  })
})

test('overloads', () => {
  const useSimulateWriteOverloads = createUseSimulateContract({
    abi: abi.writeOverloads,
  })

  const result1 = useSimulateWriteOverloads({
    functionName: 'foo',
  })
  assertType<number | undefined>(result1.data?.result)

  const result2 = useSimulateWriteOverloads({
    functionName: 'foo',
    args: [],
  })
  assertType<number | undefined>(result2.data?.result)

  const result3 = useSimulateWriteOverloads({
    functionName: 'foo',
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.data?.result)

  const result4 = useSimulateWriteOverloads({
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.data?.result)
})

test('functionName', () => {
  const useSimulateErc20 = createUseSimulateContract({
    abi: abi.erc20,
    functionName: 'transferFrom',
  })

  const result = useSimulateErc20({
    args: ['0x', '0x', 123n],
    chainId: 123,
  })
  result.data?.request.chainId
  expectTypeOf(result.data).toMatchTypeOf<
    | {
        result: boolean
        request: {
          chainId: 123
          abi: readonly [
            {
              readonly name: 'transferFrom'
              readonly type: 'function'
              readonly stateMutability: 'nonpayable'
              readonly inputs: readonly [
                { readonly type: 'address'; readonly name: 'sender' },
                { readonly type: 'address'; readonly name: 'recipient' },
                { readonly type: 'uint256'; readonly name: 'amount' },
              ]
              readonly outputs: readonly [{ type: 'bool' }]
            },
          ]
          functionName: 'transferFrom'
          args: readonly [Address, Address, bigint]
        }
      }
    | undefined
  >()
})

test('functionName with overloads', () => {
  const useSimulateWriteOverloads = createUseSimulateContract({
    abi: abi.writeOverloads,
    functionName: 'foo',
  })

  const result1 = useSimulateWriteOverloads({})
  assertType<number | undefined>(result1.data?.result)

  const result2 = useSimulateWriteOverloads({
    args: [],
  })
  assertType<number | undefined>(result2.data?.result)

  const result3 = useSimulateWriteOverloads({
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.data?.result)

  const result4 = useSimulateWriteOverloads({
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.data?.result)
})
</file>

<file path="packages/react/src/hooks/codegen/createUseSimulateContract.ts">
import type {
  Config,
  ResolvedRegister,
  SimulateContractErrorType,
  SimulateContractParameters,
} from '@wagmi/core'
import type { ScopeKeyParameter, UnionExactPartial } from '@wagmi/core/internal'
import type {
  SimulateContractData,
  SimulateContractQueryFnData,
  SimulateContractQueryKey,
} from '@wagmi/core/query'
import type {
  Abi,
  Address,
  ContractFunctionArgs,
  ContractFunctionName,
} from 'viem'

import type { ConfigParameter, QueryParameter } from '../../types/properties.js'
import { useAccount } from '../useAccount.js'
import { useChainId } from '../useChainId.js'
import { useConfig } from '../useConfig.js'
import {
  type UseSimulateContractReturnType,
  useSimulateContract,
} from '../useSimulateContract.js'

type stateMutability = 'nonpayable' | 'payable'

export type CreateUseSimulateContractParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  functionName?:
    | functionName
    | ContractFunctionName<abi, stateMutability>
    | undefined
}

export type CreateUseSimulateContractReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
> = <
  name extends functionName extends ContractFunctionName<abi, stateMutability>
    ? functionName
    : ContractFunctionName<abi, stateMutability>,
  args extends ContractFunctionArgs<abi, stateMutability, name>,
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = SimulateContractData<abi, name, args, config, chainId>,
>(
  parameters?: {
    abi?: undefined
    address?: address extends undefined ? Address : undefined
    functionName?: functionName extends undefined ? name : undefined
    chainId?: address extends Record<number, Address>
      ?
          | keyof address
          | (chainId extends keyof address ? chainId : never)
          | undefined
      : chainId | number | undefined
  } & UnionExactPartial<
    // TODO: Take `abi` and `address` from above and omit from below (currently breaks inference)
    SimulateContractParameters<abi, name, args, config, chainId>
  > &
    ScopeKeyParameter &
    ConfigParameter<config> &
    QueryParameter<
      SimulateContractQueryFnData<abi, name, args, config, chainId>,
      SimulateContractErrorType,
      selectData,
      SimulateContractQueryKey<abi, name, args, config, chainId>
    >,
) => UseSimulateContractReturnType<abi, name, args, config, chainId, selectData>

export function createUseSimulateContract<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
>(
  props: CreateUseSimulateContractParameters<abi, address, functionName>,
): CreateUseSimulateContractReturnType<abi, address, functionName> {
  if (props.address !== undefined && typeof props.address === 'object')
    return (parameters) => {
      const config = useConfig(parameters)
      const configChainId = useChainId({ config })
      const account = useAccount({ config })
      const chainId =
        (parameters as { chainId?: number })?.chainId ??
        account.chainId ??
        configChainId
      return useSimulateContract({
        ...(parameters as any),
        ...(props.functionName ? { functionName: props.functionName } : {}),
        address: props.address?.[chainId],
        abi: props.abi,
      })
    }

  return (parameters) => {
    return useSimulateContract({
      ...(parameters as any),
      ...(props.address ? { address: props.address } : {}),
      ...(props.functionName ? { functionName: props.functionName } : {}),
      abi: props.abi,
    })
  }
}
</file>

<file path="packages/react/src/hooks/codegen/createUseWatchContractEvent.test-d.ts">
import { http, createConfig, webSocket } from '@wagmi/core'
import { abi, mainnet, optimism } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { createUseWatchContractEvent } from './createUseWatchContractEvent.js'

test('default', () => {
  const useWatchErc20Event = createUseWatchContractEvent({
    abi: abi.erc20,
  })

  useWatchErc20Event({
    eventName: 'Transfer',
    chainId: 123,
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<{
        from?: `0x${string}` | undefined
        to?: `0x${string}` | undefined
        value?: bigint | undefined
      }>()
    },
  })
})

test('multichain address', () => {
  const useWatchErc20Event = createUseWatchContractEvent({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  useWatchErc20Event({
    eventName: 'Transfer',
    chainId: mainnet.id,
    // ^?
  })

  useWatchErc20Event({
    eventName: 'Transfer',
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  useWatchErc20Event({
    eventName: 'Transfer',
    // @ts-expect-error chain id must match address keys
    address: '0x',
  })
})

test('differing transports', () => {
  const useWatchErc20Event = createUseWatchContractEvent({
    abi: abi.erc20,
  })

  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  useWatchErc20Event({
    config,
    poll: false,
    address: '0x',
    onLogs() {},
  })

  useWatchErc20Event({
    config,
    chainId: mainnet.id,
    poll: true,
    address: '0x',
    onLogs() {},
  })
  useWatchErc20Event({
    config,
    chainId: mainnet.id,
    // @ts-expect-error poll required since http transport
    poll: false,
    address: '0x',
    onLogs() {},
  })

  useWatchErc20Event({
    config,
    chainId: optimism.id,
    poll: true,
    address: '0x',
    onLogs() {},
  })
  useWatchErc20Event({
    config,
    chainId: optimism.id,
    poll: false,
    address: '0x',
    onLogs() {},
  })
})

test('eventName', () => {
  const useWatchErc20Event = createUseWatchContractEvent({
    abi: abi.erc20,
    eventName: 'Transfer',
  })

  useWatchErc20Event({
    chainId: 123,
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<{
        from?: `0x${string}` | undefined
        to?: `0x${string}` | undefined
        value?: bigint | undefined
      }>()
    },
  })
})
</file>

<file path="packages/react/src/hooks/codegen/createUseWatchContractEvent.ts">
import type {
  Config,
  ResolvedRegister,
  WatchContractEventParameters,
} from '@wagmi/core'
import type {
  UnionCompute,
  UnionExactPartial,
  UnionStrictOmit,
} from '@wagmi/core/internal'
import type { Abi, Address, ContractEventName } from 'viem'

import type {
  ConfigParameter,
  EnabledParameter,
} from '../../types/properties.js'
import { useAccount } from '../useAccount.js'
import { useChainId } from '../useChainId.js'
import { useConfig } from '../useConfig.js'
import { useWatchContractEvent } from '../useWatchContractEvent.js'

export type CreateUseWatchContractEventParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  eventName extends ContractEventName<abi> | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  eventName?: eventName | ContractEventName<abi> | undefined
}

export type CreateUseWatchContractEventReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  eventName extends ContractEventName<abi> | undefined,
  ///
  omittedProperties extends 'abi' | 'address' | 'chainId' | 'eventName' =
    | 'abi'
    | (address extends undefined ? never : 'address')
    | (address extends Record<number, Address> ? 'chainId' : never)
    | (eventName extends undefined ? never : 'eventName'),
> = <
  name extends eventName extends ContractEventName<abi>
    ? eventName
    : ContractEventName<abi>,
  strict extends boolean | undefined = undefined,
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  parameters?: UnionCompute<
    UnionExactPartial<
      UnionStrictOmit<
        WatchContractEventParameters<abi, name, strict, config, chainId>,
        omittedProperties
      >
    > &
      ConfigParameter<config> &
      EnabledParameter
  > &
    (address extends Record<number, Address>
      ? { chainId?: keyof address | undefined }
      : unknown),
) => void

export function createUseWatchContractEvent<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  eventName extends ContractEventName<abi> | undefined = undefined,
>(
  props: CreateUseWatchContractEventParameters<abi, address, eventName>,
): CreateUseWatchContractEventReturnType<abi, address, eventName> {
  if (props.address !== undefined && typeof props.address === 'object')
    return (parameters) => {
      const config = useConfig(parameters)
      const configChainId = useChainId({ config })
      const account = useAccount({ config })
      const chainId =
        (parameters as { chainId?: number })?.chainId ??
        account.chainId ??
        configChainId
      return useWatchContractEvent({
        ...(parameters as any),
        ...(props.eventName ? { eventName: props.eventName } : {}),
        address: props.address?.[chainId],
        abi: props.abi,
      })
    }

  return (parameters) => {
    return useWatchContractEvent({
      ...(parameters as any),
      ...(props.address ? { address: props.address } : {}),
      ...(props.eventName ? { eventName: props.eventName } : {}),
      abi: props.abi,
    })
  }
}
</file>

<file path="packages/react/src/hooks/codegen/createUseWriteContract.test-d.ts">
import { abi } from '@wagmi/test'
import type { Address, Hash } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import { useSimulateContract } from '../useSimulateContract.js'
import { createUseWriteContract } from './createUseWriteContract.js'

const contextValue = { foo: 'bar' } as const

test('default', () => {
  const useWriteErc20 = createUseWriteContract({
    abi: abi.erc20,
  })

  const { writeContract } = useWriteErc20()
  writeContract({
    address: '0x',
    functionName: 'transfer',
    args: ['0x', 123n],
  })
})

test('context', () => {
  const useWriteErc20 = createUseWriteContract({
    abi: abi.erc20,
  })

  const { writeContract } = useWriteErc20({
    mutation: {
      onMutate() {
        return contextValue
      },
      onSuccess(data, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash>()
        expectTypeOf(variables.functionName).toEqualTypeOf<string>()
        expectTypeOf(variables.args).toEqualTypeOf<
          readonly unknown[] | undefined
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
    },
  })

  writeContract(
    {
      address: '0x',
      functionName: 'transfer',
      args: ['0x', 123n],
    },
    {
      onSuccess(data, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash>()
        expectTypeOf(variables.functionName).toEqualTypeOf<'transfer'>()
        expectTypeOf(variables.args).toEqualTypeOf<readonly [Address, bigint]>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
    },
  )
})

test('multichain address', () => {
  const useWriteErc20 = createUseWriteContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const { writeContract } = useWriteErc20()
  writeContract({
    functionName: 'transfer',
    args: ['0x', 123n],
    chainId: mainnet.id,
    // ^?
  })

  writeContract({
    functionName: 'transfer',
    args: ['0x', 123n],
    // @ts-expect-error chain id must match address keys
    chainId: 420,
  })

  writeContract({
    // @ts-expect-error address not allowed
    address: '0x',
    functionName: 'transfer',
    args: ['0x', 123n],
  })
})

test('overloads', () => {
  const useWriteOverloads = createUseWriteContract({
    abi: abi.writeOverloads,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const { writeContract } = useWriteOverloads()
  writeContract({
    functionName: 'foo',
    args: [],
  })

  writeContract({
    functionName: 'foo',
    args: ['0x'],
  })

  writeContract({
    functionName: 'foo',
    args: ['0x', '0x'],
  })
})

test('useSimulateContract', () => {
  const useWriteErc20 = createUseWriteContract({
    abi: abi.erc20,
    address: {
      [mainnet.id]: '0x',
      [optimism.id]: '0x',
    },
  })

  const { data } = useSimulateContract({
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })
  const { writeContract } = useWriteErc20()

  const request = data?.request
  if (request) writeContract(request)
})

test('functionName', () => {
  const useWriteErc20 = createUseWriteContract({
    abi: abi.erc20,
    functionName: 'transfer',
  })

  const { writeContract } = useWriteErc20()
  writeContract({
    address: '0x',
    args: ['0x', 123n],
  })
})
</file>

<file path="packages/react/src/hooks/codegen/createUseWriteContract.ts">
import type { MutateOptions } from '@tanstack/react-query'
import type {
  Config,
  ResolvedRegister,
  WriteContractErrorType,
} from '@wagmi/core'
import type {
  ChainIdParameter,
  Compute,
  ConnectorParameter,
  SelectChains,
  UnionCompute,
  UnionStrictOmit,
} from '@wagmi/core/internal'
import type {
  WriteContractData,
  WriteContractVariables,
} from '@wagmi/core/query'
import { useCallback } from 'react'
import type {
  Abi,
  Account,
  Address,
  Chain,
  ContractFunctionArgs,
  ContractFunctionName,
} from 'viem'
import type { WriteContractParameters as viem_WriteContractParameters } from 'viem/actions'

import { useAccount } from '../useAccount.js'
import { useChainId } from '../useChainId.js'
import { useConfig } from '../useConfig.js'
import {
  type UseWriteContractParameters,
  useWriteContract,
  type UseWriteContractReturnType as wagmi_UseWriteContractReturnType,
} from '../useWriteContract.js'

type stateMutability = 'nonpayable' | 'payable'

export type CreateUseWriteContractParameters<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
> = {
  abi: abi | Abi | readonly unknown[]
  address?: address | Address | Record<number, Address> | undefined
  functionName?:
    | functionName
    | ContractFunctionName<abi, stateMutability>
    | undefined
}

export type CreateUseWriteContractReturnType<
  abi extends Abi | readonly unknown[],
  address extends Address | Record<number, Address> | undefined,
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
> = <config extends Config = ResolvedRegister['config'], context = unknown>(
  parameters?: UseWriteContractParameters<config, context>,
) => Compute<
  Omit<
    wagmi_UseWriteContractReturnType<config, context>,
    'writeContract' | 'writeContractAsync'
  > & {
    writeContract: <
      const abi2 extends abi,
      name extends functionName extends ContractFunctionName<
        abi,
        stateMutability
      >
        ? functionName
        : ContractFunctionName<abi, stateMutability>,
      args extends ContractFunctionArgs<abi2, stateMutability, name>,
      chainId extends config['chains'][number]['id'],
    >(
      variables: Variables<
        abi2,
        functionName,
        name,
        args,
        config,
        chainId,
        address
      >,
      options?:
        | MutateOptions<
            WriteContractData,
            WriteContractErrorType,
            WriteContractVariables<
              abi2,
              name,
              args,
              config,
              chainId,
              // use `functionName` to make sure it's not union of all possible function names
              name
            >,
            context
          >
        | undefined,
    ) => void
    writeContractAsync: <
      const abi2 extends abi,
      name extends functionName extends ContractFunctionName<
        abi,
        stateMutability
      >
        ? functionName
        : ContractFunctionName<abi, stateMutability>,
      args extends ContractFunctionArgs<abi2, stateMutability, name>,
      chainId extends config['chains'][number]['id'],
    >(
      variables: Variables<
        abi2,
        functionName,
        name,
        args,
        config,
        chainId,
        address
      >,
      options?:
        | MutateOptions<
            WriteContractData,
            WriteContractErrorType,
            WriteContractVariables<
              abi2,
              name,
              args,
              config,
              chainId,
              // use `functionName` to make sure it's not union of all possible function names
              name
            >,
            context
          >
        | undefined,
    ) => Promise<WriteContractData>
  }
>

export function createUseWriteContract<
  const abi extends Abi | readonly unknown[],
  const address extends
    | Address
    | Record<number, Address>
    | undefined = undefined,
  functionName extends
    | ContractFunctionName<abi, stateMutability>
    | undefined = undefined,
>(
  props: CreateUseWriteContractParameters<abi, address, functionName>,
): CreateUseWriteContractReturnType<abi, address, functionName> {
  if (props.address !== undefined && typeof props.address === 'object')
    return (parameters) => {
      const config = useConfig(parameters)
      const result = useWriteContract(parameters)
      const configChainId = useChainId({ config })
      const account = useAccount({ config })
      type Args = Parameters<wagmi_UseWriteContractReturnType['writeContract']>
      return {
        ...(result as any),
        writeContract: useCallback(
          (...args: Args) => {
            let chainId: number | undefined
            if (args[0].chainId) chainId = args[0].chainId
            else if (args[0].account && args[0].account === account.address)
              chainId = account.chainId
            else if (args[0].account === undefined) chainId = account.chainId
            else chainId = configChainId

            const variables = {
              ...(args[0] as any),
              address: chainId ? props.address?.[chainId] : undefined,
              ...(props.functionName
                ? { functionName: props.functionName }
                : {}),
              abi: props.abi,
            }
            result.writeContract(variables, args[1] as any)
          },
          [
            account.address,
            account.chainId,
            props,
            configChainId,
            result.writeContract,
          ],
        ),
        writeContractAsync: useCallback(
          (...args: Args) => {
            let chainId: number | undefined
            if (args[0].chainId) chainId = args[0].chainId
            else if (args[0].account && args[0].account === account.address)
              chainId = account.chainId
            else if (args[0].account === undefined) chainId = account.chainId
            else chainId = configChainId

            const variables = {
              ...(args[0] as any),
              address: chainId ? props.address?.[chainId] : undefined,
              ...(props.functionName
                ? { functionName: props.functionName }
                : {}),
              abi: props.abi,
            }
            return result.writeContractAsync(variables, args[1] as any)
          },
          [
            account.address,
            account.chainId,
            props,
            configChainId,
            result.writeContractAsync,
          ],
        ),
      }
    }

  return (parameters) => {
    const result = useWriteContract(parameters)
    type Args = Parameters<wagmi_UseWriteContractReturnType['writeContract']>
    return {
      ...(result as any),
      writeContract: useCallback(
        (...args: Args) => {
          const variables = {
            ...(args[0] as any),
            ...(props.address ? { address: props.address } : {}),
            ...(props.functionName ? { functionName: props.functionName } : {}),
            abi: props.abi,
          }
          result.writeContract(variables, args[1] as any)
        },
        [props, result.writeContract],
      ),
      writeContractAsync: useCallback(
        (...args: Args) => {
          const variables = {
            ...(args[0] as any),
            ...(props.address ? { address: props.address } : {}),
            ...(props.functionName ? { functionName: props.functionName } : {}),
            abi: props.abi,
          }
          return result.writeContractAsync(variables, args[1] as any)
        },
        [props, result.writeContractAsync],
      ),
    }
  }
}

type Variables<
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, stateMutability> | undefined,
  name extends ContractFunctionName<abi, stateMutability>,
  args extends ContractFunctionArgs<abi, stateMutability, name>,
  config extends Config,
  chainId extends config['chains'][number]['id'],
  address extends Address | Record<number, Address> | undefined,
  ///
  allFunctionNames = ContractFunctionName<abi, stateMutability>,
  chains extends readonly Chain[] = SelectChains<config, chainId>,
  omittedProperties extends 'abi' | 'address' | 'functionName' =
    | 'abi'
    | (address extends undefined ? never : 'address')
    | (functionName extends undefined ? never : 'functionName'),
> = UnionCompute<
  {
    [key in keyof chains]: UnionStrictOmit<
      viem_WriteContractParameters<
        abi,
        name,
        args,
        chains[key],
        Account,
        chains[key],
        allFunctionNames
      >,
      omittedProperties | 'chain'
    >
  }[number] &
    (address extends Record<number, Address>
      ? {
          chainId?:
            | keyof address
            | (chainId extends keyof address ? chainId : never)
            | undefined
        }
      : Compute<ChainIdParameter<config, chainId>>) &
    ConnectorParameter & {
      /** @deprecated */
      __mode?: 'prepared'
    }
>
</file>

<file path="packages/react/src/hooks/useAccount.test-d.ts">
import type { Connector } from '@wagmi/core'
import type { Address, Chain } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { useAccount } from './useAccount.js'

test('states', () => {
  const result = useAccount()

  switch (result.status) {
    case 'reconnecting': {
      expectTypeOf(result).toMatchTypeOf<{
        address: Address | undefined
        chain: Chain | undefined
        chainId: number | undefined
        connector: Connector | undefined
        isConnected: boolean
        isConnecting: false
        isDisconnected: false
        isReconnecting: true
        status: 'reconnecting'
      }>()
      break
    }
    case 'connecting': {
      expectTypeOf(result).toMatchTypeOf<{
        address: Address | undefined
        chain: Chain | undefined
        chainId: number | undefined
        connector: Connector | undefined
        isConnected: false
        isReconnecting: false
        isConnecting: true
        isDisconnected: false
        status: 'connecting'
      }>()
      break
    }
    case 'connected': {
      expectTypeOf(result).toMatchTypeOf<{
        address: Address
        chain: Chain | undefined
        chainId: number
        connector: Connector
        isConnected: true
        isConnecting: false
        isDisconnected: false
        isReconnecting: false
        status: 'connected'
      }>()
      break
    }
    case 'disconnected': {
      expectTypeOf(result).toMatchTypeOf<{
        address: undefined
        chain: undefined
        chainId: undefined
        connector: undefined
        isConnected: false
        isReconnecting: false
        isConnecting: false
        isDisconnected: true
        status: 'disconnected'
      }>()
      break
    }
  }
})
</file>

<file path="packages/react/src/hooks/useAccount.ts">
'use client'

import {
  type Config,
  type GetAccountReturnType,
  type ResolvedRegister,
  getAccount,
  watchAccount,
} from '@wagmi/core'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'
import { useSyncExternalStoreWithTracked } from './useSyncExternalStoreWithTracked.js'

export type UseAccountParameters<config extends Config = Config> =
  ConfigParameter<config>

export type UseAccountReturnType<config extends Config = Config> =
  GetAccountReturnType<config>

/** https://wagmi.sh/react/api/hooks/useAccount */
export function useAccount<config extends Config = ResolvedRegister['config']>(
  parameters: UseAccountParameters<config> = {},
): UseAccountReturnType<config> {
  const config = useConfig(parameters)

  return useSyncExternalStoreWithTracked(
    (onChange) => watchAccount(config, { onChange }),
    () => getAccount(config),
  )
}
</file>

<file path="packages/react/src/hooks/useAccountEffect.ts">
'use client'

import { type GetAccountReturnType, watchAccount } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import { useEffect } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UseAccountEffectParameters = Compute<
  {
    onConnect?(
      data: Compute<
        Pick<
          Extract<GetAccountReturnType, { status: 'connected' }>,
          'address' | 'addresses' | 'chain' | 'chainId' | 'connector'
        > & {
          isReconnected: boolean
        }
      >,
    ): void
    onDisconnect?(): void
  } & ConfigParameter
>

/** https://wagmi.sh/react/api/hooks/useAccountEffect */
export function useAccountEffect(parameters: UseAccountEffectParameters = {}) {
  const { onConnect, onDisconnect } = parameters

  const config = useConfig(parameters)

  useEffect(() => {
    return watchAccount(config, {
      onChange(data, prevData) {
        if (
          (prevData.status === 'reconnecting' ||
            (prevData.status === 'connecting' &&
              prevData.address === undefined)) &&
          data.status === 'connected'
        ) {
          const { address, addresses, chain, chainId, connector } = data
          const isReconnected =
            prevData.status === 'reconnecting' ||
            // if `previousAccount.status` is `undefined`, the connector connected immediately.
            prevData.status === undefined
          onConnect?.({
            address,
            addresses,
            chain,
            chainId,
            connector,
            isReconnected,
          })
        } else if (
          prevData.status === 'connected' &&
          data.status === 'disconnected'
        )
          onDisconnect?.()
      },
    })
  }, [config, onConnect, onDisconnect])
}
</file>

<file path="packages/react/src/hooks/useBalance.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useBalance } from './useBalance.js'

test('select data', () => {
  const result = useBalance({
    query: {
      select(data) {
        return data?.value
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})
</file>

<file path="packages/react/src/hooks/useBalance.ts">
'use client'

import type { Config, GetBalanceErrorType, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetBalanceData,
  type GetBalanceOptions,
  type GetBalanceQueryKey,
  getBalanceQueryOptions,
} from '@wagmi/core/query'
import type { GetBalanceQueryFnData } from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseBalanceParameters<
  config extends Config = Config,
  selectData = GetBalanceData,
> = Compute<
  GetBalanceOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetBalanceQueryFnData,
      GetBalanceErrorType,
      selectData,
      GetBalanceQueryKey<config>
    >
>

export type UseBalanceReturnType<selectData = GetBalanceData> =
  UseQueryReturnType<selectData, GetBalanceErrorType>

/** https://wagmi.sh/react/api/hooks/useBalance */
export function useBalance<
  config extends Config = ResolvedRegister['config'],
  selectData = GetBalanceData,
>(
  parameters: UseBalanceParameters<config, selectData> = {},
): UseBalanceReturnType<selectData> {
  const { address, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getBalanceQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useBlock.test-d.ts">
import { http, createConfig, webSocket } from '@wagmi/core'
import { mainnet, optimism } from '@wagmi/core/chains'
import { expectTypeOf, test } from 'vitest'

import { useBlock } from './useBlock.js'

test('select data', () => {
  const result = useBlock({
    query: {
      select(data) {
        return data?.number
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  useBlock({
    config,
    watch: {
      poll: false,
    },
  })

  useBlock({
    config,
    chainId: mainnet.id,
    watch: {
      poll: true,
    },
  })
  useBlock({
    config,
    chainId: mainnet.id,
    watch: {
      // @ts-expect-error
      poll: false,
    },
  })

  useBlock({
    config,
    chainId: optimism.id,
    watch: {
      poll: true,
    },
  })
  useBlock({
    config,
    chainId: optimism.id,
    watch: {
      poll: false,
    },
  })
})
</file>

<file path="packages/react/src/hooks/useBlock.ts">
'use client'

import { useQueryClient } from '@tanstack/react-query'
import type { Config, GetBlockErrorType, ResolvedRegister } from '@wagmi/core'
import type {
  Compute,
  UnionCompute,
  UnionStrictOmit,
} from '@wagmi/core/internal'
import {
  type GetBlockData,
  type GetBlockOptions,
  type GetBlockQueryFnData,
  type GetBlockQueryKey,
  getBlockQueryOptions,
} from '@wagmi/core/query'
import type { BlockTag } from 'viem'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'
import {
  type UseWatchBlocksParameters,
  useWatchBlocks,
} from './useWatchBlocks.js'

export type UseBlockParameters<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,
> = Compute<
  GetBlockOptions<includeTransactions, blockTag, config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetBlockQueryFnData<includeTransactions, blockTag, config, chainId>,
      GetBlockErrorType,
      selectData,
      GetBlockQueryKey<includeTransactions, blockTag, config, chainId>
    > & {
      watch?:
        | boolean
        | UnionCompute<
            UnionStrictOmit<
              UseWatchBlocksParameters<
                includeTransactions,
                blockTag,
                config,
                chainId
              >,
              'chainId' | 'config' | 'onBlock' | 'onError'
            >
          >
        | undefined
    }
>

export type UseBlockReturnType<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,
> = UseQueryReturnType<selectData, GetBlockErrorType>

/** https://wagmi.sh/react/hooks/useBlock */
export function useBlock<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,
>(
  parameters: UseBlockParameters<
    includeTransactions,
    blockTag,
    config,
    chainId,
    selectData
  > = {},
): UseBlockReturnType<
  includeTransactions,
  blockTag,
  config,
  chainId,
  selectData
> {
  const { query = {}, watch } = parameters

  const config = useConfig(parameters)
  const queryClient = useQueryClient()
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  const options = getBlockQueryOptions(config, {
    ...parameters,
    chainId,
  })
  const enabled = Boolean(query.enabled ?? true)

  useWatchBlocks({
    ...({
      config: parameters.config,
      chainId: parameters.chainId!,
      ...(typeof watch === 'object' ? watch : {}),
    } as UseWatchBlocksParameters),
    enabled: Boolean(
      enabled && (typeof watch === 'object' ? watch.enabled : watch),
    ),
    onBlock(block) {
      queryClient.setQueryData(options.queryKey, block)
    },
  })

  return useQuery({
    ...(query as any),
    ...options,
    enabled,
  }) as UseBlockReturnType<
    includeTransactions,
    blockTag,
    config,
    chainId,
    selectData
  >
}
</file>

<file path="packages/react/src/hooks/useBlockNumber.test-d.ts">
import { http, createConfig, webSocket } from '@wagmi/core'
import { mainnet, optimism } from '@wagmi/core/chains'
import { expectTypeOf, test } from 'vitest'

import { useBlockNumber } from './useBlockNumber.js'

test('select data', () => {
  const result = useBlockNumber({
    query: {
      select(data) {
        expectTypeOf(data).toEqualTypeOf<bigint>()
        return data?.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  useBlockNumber({
    config,
    watch: {
      poll: false,
    },
  })

  useBlockNumber({
    config,
    chainId: mainnet.id,
    watch: {
      poll: true,
    },
  })
  useBlockNumber({
    config,
    chainId: mainnet.id,
    watch: {
      // @ts-expect-error
      poll: false,
    },
  })

  useBlockNumber({
    config,
    chainId: optimism.id,
    watch: {
      poll: true,
    },
  })
  useBlockNumber({
    config,
    chainId: optimism.id,
    watch: {
      poll: false,
    },
  })
})
</file>

<file path="packages/react/src/hooks/useBlockNumber.ts">
'use client'

import { useQueryClient } from '@tanstack/react-query'
import type {
  Config,
  GetBlockNumberErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type {
  Compute,
  UnionCompute,
  UnionStrictOmit,
} from '@wagmi/core/internal'
import {
  type GetBlockNumberData,
  type GetBlockNumberOptions,
  type GetBlockNumberQueryFnData,
  type GetBlockNumberQueryKey,
  getBlockNumberQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'
import {
  type UseWatchBlockNumberParameters,
  useWatchBlockNumber,
} from './useWatchBlockNumber.js'

export type UseBlockNumberParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockNumberData,
> = Compute<
  GetBlockNumberOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetBlockNumberQueryFnData,
      GetBlockNumberErrorType,
      selectData,
      GetBlockNumberQueryKey<config, chainId>
    > & {
      watch?:
        | boolean
        | UnionCompute<
            UnionStrictOmit<
              UseWatchBlockNumberParameters<config, chainId>,
              'chainId' | 'config' | 'onBlockNumber' | 'onError'
            >
          >
        | undefined
    }
>

export type UseBlockNumberReturnType<selectData = GetBlockNumberData> =
  UseQueryReturnType<selectData, GetBlockNumberErrorType>

/** https://wagmi.sh/react/api/hooks/useBlockNumber */
export function useBlockNumber<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockNumberData,
>(
  parameters: UseBlockNumberParameters<config, chainId, selectData> = {},
): UseBlockNumberReturnType<selectData> {
  const { query = {}, watch } = parameters

  const config = useConfig(parameters)
  const queryClient = useQueryClient()
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  const options = getBlockNumberQueryOptions(config, {
    ...parameters,
    chainId,
  })

  useWatchBlockNumber({
    ...({
      config: parameters.config,
      chainId: parameters.chainId,
      ...(typeof watch === 'object' ? watch : {}),
    } as UseWatchBlockNumberParameters),
    enabled: Boolean(
      (query.enabled ?? true) &&
        (typeof watch === 'object' ? watch.enabled : watch),
    ),
    onBlockNumber(blockNumber) {
      queryClient.setQueryData(options.queryKey, blockNumber)
    },
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useBlockTransactionCount.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useBlockTransactionCount } from './useBlockTransactionCount.js'

test('select data', () => {
  const result = useBlockTransactionCount({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<number | undefined>()
})
</file>

<file path="packages/react/src/hooks/useBlockTransactionCount.ts">
'use client'

import type {
  Config,
  GetBlockTransactionCountErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { UnionCompute } from '@wagmi/core/internal'
import {
  type GetBlockTransactionCountData,
  type GetBlockTransactionCountOptions,
  type GetBlockTransactionCountQueryFnData,
  type GetBlockTransactionCountQueryKey,
  getBlockTransactionCountQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseBlockTransactionCountParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockTransactionCountData,
> = UnionCompute<
  GetBlockTransactionCountOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetBlockTransactionCountQueryFnData,
      GetBlockTransactionCountErrorType,
      selectData,
      GetBlockTransactionCountQueryKey<config, chainId>
    >
>

export type UseBlockTransactionCountReturnType<
  selectData = GetBlockTransactionCountData,
> = UseQueryReturnType<selectData, GetBlockTransactionCountErrorType>

/** https://wagmi.sh/react/api/hooks/useBlockTransactionCount */
export function useBlockTransactionCount<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetBlockTransactionCountData,
>(
  parameters: UseBlockTransactionCountParameters<
    config,
    chainId,
    selectData
  > = {},
): UseBlockTransactionCountReturnType<selectData> {
  const { query = {} } = parameters

  const config = useConfig(parameters)
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  const options = getBlockTransactionCountQueryOptions(config, {
    ...parameters,
    chainId,
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useBytecode.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import type { Hex } from 'viem'
import { useBytecode } from './useBytecode.js'

test('select data', () => {
  const result = useBytecode({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<Hex | undefined>()
})
</file>

<file path="packages/react/src/hooks/useBytecode.ts">
'use client'

import type {
  Config,
  GetBytecodeErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetBytecodeData,
  type GetBytecodeOptions,
  type GetBytecodeQueryKey,
  getBytecodeQueryOptions,
} from '@wagmi/core/query'
import type { GetBytecodeQueryFnData } from '@wagmi/core/query'
import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseBytecodeParameters<
  config extends Config = Config,
  selectData = GetBytecodeData,
> = Compute<
  GetBytecodeOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetBytecodeQueryFnData,
      GetBytecodeErrorType,
      selectData,
      GetBytecodeQueryKey<config>
    >
>

export type UseBytecodeReturnType<selectData = GetBytecodeData> =
  UseQueryReturnType<selectData, GetBytecodeErrorType>

/** https://wagmi.sh/react/api/hooks/useBytecode */
export function useBytecode<
  config extends Config = ResolvedRegister['config'],
  selectData = GetBytecodeData,
>(
  parameters: UseBytecodeParameters<config, selectData> = {},
): UseBytecodeReturnType<selectData> {
  const { address, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getBytecodeQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useCall.test-d.ts">
import type { CallReturnType } from 'viem'
import { expectTypeOf, test } from 'vitest'
import { useCall } from './useCall.js'

test('select data', () => {
  const result = useCall({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<CallReturnType | undefined>()
})
</file>

<file path="packages/react/src/hooks/useCall.ts">
'use client'

import type { CallErrorType, Config, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type CallData,
  type CallOptions,
  type CallQueryKey,
  callQueryOptions,
} from '@wagmi/core/query'
import type { CallQueryFnData } from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseCallParameters<
  config extends Config = Config,
  selectData = CallData,
> = Compute<
  CallOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      CallQueryFnData,
      CallErrorType,
      selectData,
      CallQueryKey<config>
    >
>

export type UseCallReturnType<selectData = CallData> = UseQueryReturnType<
  selectData,
  CallErrorType
>

/** https://wagmi.sh/react/api/hooks/useCall */
export function useCall<
  config extends Config = ResolvedRegister['config'],
  selectData = CallData,
>(
  parameters: UseCallParameters<config, selectData> = {},
): UseCallReturnType<selectData> {
  const { query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = callQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useCallsStatus.ts">
'use client'

import type {
  Config,
  GetCallsStatusErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetCallsStatusData,
  type GetCallsStatusOptions,
  type GetCallsStatusQueryFnData,
  type GetCallsStatusQueryKey,
  getCallsStatusQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseCallsStatusParameters<
  config extends Config = Config,
  selectData = GetCallsStatusData,
> = Compute<
  GetCallsStatusOptions &
    ConfigParameter<config> &
    QueryParameter<
      GetCallsStatusQueryFnData,
      GetCallsStatusErrorType,
      selectData,
      GetCallsStatusQueryKey
    >
>

export type UseCallsStatusReturnType<selectData = GetCallsStatusData> =
  UseQueryReturnType<selectData, GetCallsStatusErrorType>

/** https://wagmi.sh/react/api/hooks/useCallsStatus */
export function useCallsStatus<
  config extends Config = ResolvedRegister['config'],
  selectData = GetCallsStatusData,
>(
  parameters: UseCallsStatusParameters<config, selectData>,
): UseCallsStatusReturnType<selectData> {
  const { query = {} } = parameters

  const config = useConfig(parameters)

  const options = getCallsStatusQueryOptions(config, parameters)

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useCapabilities.ts">
'use client'

import type {
  Config,
  GetCapabilitiesErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetCapabilitiesData,
  type GetCapabilitiesOptions,
  type GetCapabilitiesQueryFnData,
  type GetCapabilitiesQueryKey,
  getCapabilitiesQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useAccount } from './useAccount.js'
import { useConfig } from './useConfig.js'

export type UseCapabilitiesParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = GetCapabilitiesData<config, chainId>,
> = Compute<
  GetCapabilitiesOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetCapabilitiesQueryFnData<config, chainId>,
      GetCapabilitiesErrorType,
      selectData,
      GetCapabilitiesQueryKey<config, chainId>
    >
>

export type UseCapabilitiesReturnType<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = GetCapabilitiesData<config, chainId>,
> = UseQueryReturnType<selectData, GetCapabilitiesErrorType>

/** https://wagmi.sh/react/api/hooks/useCapabilities */
export function useCapabilities<
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = GetCapabilitiesData<config, chainId>,
>(
  parameters: UseCapabilitiesParameters<config, chainId, selectData> = {},
): UseCapabilitiesReturnType<config, chainId, selectData> {
  const { account, query = {} } = parameters

  const { address } = useAccount()
  const config = useConfig(parameters)

  const options = getCapabilitiesQueryOptions(config, {
    ...parameters,
    account: account ?? address,
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useChainId.test-d.ts">
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useChainId } from './useChainId.js'

test('default', () => {
  const chainId = useChainId()
  expectTypeOf(chainId).toEqualTypeOf<number>()
})

test('parameters: config', () => {
  const chainId = useChainId({ config })
  expectTypeOf(chainId).toEqualTypeOf<1 | 456 | 10>()
})
</file>

<file path="packages/react/src/hooks/useChainId.ts">
'use client'

import {
  type Config,
  type GetChainIdReturnType,
  type ResolvedRegister,
  getChainId,
  watchChainId,
} from '@wagmi/core'
import { useSyncExternalStore } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UseChainIdParameters<config extends Config = Config> =
  ConfigParameter<config>

export type UseChainIdReturnType<config extends Config = Config> =
  GetChainIdReturnType<config>

/** https://wagmi.sh/react/api/hooks/useChainId */
export function useChainId<config extends Config = ResolvedRegister['config']>(
  parameters: UseChainIdParameters<config> = {},
): UseChainIdReturnType<config> {
  const config = useConfig(parameters)

  return useSyncExternalStore(
    (onChange) => watchChainId(config, { onChange }),
    () => getChainId(config),
    () => getChainId(config),
  )
}
</file>

<file path="packages/react/src/hooks/useChains.ts">
'use client'

import {
  type Config,
  type GetChainsReturnType,
  type ResolvedRegister,
  getChains,
} from '@wagmi/core'
import { watchChains } from '@wagmi/core/internal'
import { useSyncExternalStore } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UseChainsParameters<config extends Config = Config> =
  ConfigParameter<config>

export type UseChainsReturnType<config extends Config = Config> =
  GetChainsReturnType<config>

/** https://wagmi.sh/react/api/hooks/useChains */
export function useChains<config extends Config = ResolvedRegister['config']>(
  parameters: UseChainsParameters<config> = {},
): UseChainsReturnType<config> {
  const config = useConfig(parameters)

  return useSyncExternalStore(
    (onChange) => watchChains(config, { onChange }),
    () => getChains(config),
    () => getChains(config),
  )
}
</file>

<file path="packages/react/src/hooks/useClient.test-d.ts">
import { chain, config } from '@wagmi/test'
import type { Chain } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { useClient } from './useClient.js'

test('default', () => {
  const client = useClient({ config })
  expectTypeOf(client.chain).toEqualTypeOf<(typeof config)['chains'][number]>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('parameters: chainId', () => {
  const client = useClient({
    config,
    chainId: chain.mainnet.id,
  })
  expectTypeOf(client.chain).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(client.chain).not.toEqualTypeOf<typeof chain.mainnet2>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('behavior: unconfigured chain', () => {
  {
    const client = useClient({ chainId: 123456 })
    if (client) {
      expectTypeOf(client.chain).toEqualTypeOf<Chain>()
      expectTypeOf(client.transport.type).toEqualTypeOf<string>()
    } else {
      expectTypeOf(client).toEqualTypeOf<undefined>()
    }
  }

  const client = useClient({
    config,
    // @ts-expect-error
    chainId: 123456,
  })
  expectTypeOf(client).toEqualTypeOf<undefined>()
})
</file>

<file path="packages/react/src/hooks/useClient.ts">
'use client'

import {
  type Config,
  type GetClientParameters,
  type GetClientReturnType,
  type ResolvedRegister,
  getClient,
  watchClient,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UseClientParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | number | undefined =
    | config['chains'][number]['id']
    | undefined,
> = Compute<GetClientParameters<config, chainId> & ConfigParameter<config>>

export type UseClientReturnType<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | number | undefined =
    | config['chains'][number]['id']
    | undefined,
> = GetClientReturnType<config, chainId>

/** https://wagmi.sh/react/api/hooks/useClient */
export function useClient<
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | number | undefined =
    | config['chains'][number]['id']
    | undefined,
>(
  parameters: UseClientParameters<config, chainId> = {},
): UseClientReturnType<config, chainId> {
  const config = useConfig(parameters)

  return useSyncExternalStoreWithSelector(
    (onChange) => watchClient(config, { onChange }),
    () => getClient(config, parameters),
    () => getClient(config, parameters),
    (x) => x,
    (a, b) => a?.uid === b?.uid,
  ) as any
}
</file>

<file path="packages/react/src/hooks/useConfig.test-d.ts">
import type { Config } from '@wagmi/core'
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useConfig } from './useConfig.js'

test('default', async () => {
  const result = useConfig()
  expectTypeOf(result).toEqualTypeOf<Config>()
})

test('parameters: config', async () => {
  const result = useConfig({ config })
  expectTypeOf(result).not.toEqualTypeOf<Config>()
  expectTypeOf(result).toEqualTypeOf<typeof config>()
})
</file>

<file path="packages/react/src/hooks/useConfig.ts">
'use client'

import type { Config, ResolvedRegister } from '@wagmi/core'
import { useContext } from 'react'

import { WagmiContext } from '../context.js'
import { WagmiProviderNotFoundError } from '../errors/context.js'
import type { ConfigParameter } from '../types/properties.js'

export type UseConfigParameters<config extends Config = Config> =
  ConfigParameter<config>

export type UseConfigReturnType<config extends Config = Config> = config

/** https://wagmi.sh/react/api/hooks/useConfig */
export function useConfig<config extends Config = ResolvedRegister['config']>(
  parameters: UseConfigParameters<config> = {},
): UseConfigReturnType<config> {
  const config = parameters.config ?? useContext(WagmiContext)
  if (!config) throw new WagmiProviderNotFoundError()
  return config as UseConfigReturnType<config>
}
</file>

<file path="packages/react/src/hooks/useConnect.test-d.ts">
import type {
  ConnectErrorType,
  Connector,
  CreateConnectorFn,
} from '@wagmi/core'
import { config } from '@wagmi/test'
import type { Address } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { useConnect } from './useConnect.js'

const connector = config.connectors[0]!
const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { connect, context, data, error, variables } = useConnect({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: Connector | CreateConnectorFn
        }>()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: Connector | CreateConnectorFn
        }>()
        expectTypeOf(error).toEqualTypeOf<ConnectErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: Connector | CreateConnectorFn
        }>()
        expectTypeOf(data).toEqualTypeOf<{
          accounts: readonly [Address, ...Address[]]
          chainId: number
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<
          | {
              accounts: readonly [Address, ...Address[]]
              chainId: number
            }
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<ConnectErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: Connector | CreateConnectorFn
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<
    | {
        accounts: readonly [Address, ...Address[]]
        chainId: number
      }
    | undefined
  >()
  expectTypeOf(error).toEqualTypeOf<ConnectErrorType | null>()
  expectTypeOf(variables).toMatchTypeOf<
    | {
        chainId?: number | undefined
        connector: CreateConnectorFn | Connector
      }
    | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  connect(
    {
      connector,
      foo: 'bar',
    },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: typeof connector | CreateConnectorFn
          foo?: string | undefined
        }>()
        expectTypeOf(error).toEqualTypeOf<ConnectErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: typeof connector | CreateConnectorFn
          foo?: string | undefined
        }>()
        expectTypeOf(data).toEqualTypeOf<{
          accounts: readonly [Address, ...Address[]]
          chainId: number
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<
          | {
              accounts: readonly [Address, ...Address[]]
              chainId: number
            }
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<ConnectErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<{
          chainId?: number | undefined
          connector: typeof connector | CreateConnectorFn
          foo?: string | undefined
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useConnect.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { Config, ConnectErrorType, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type ConnectData,
  type ConnectMutate,
  type ConnectMutateAsync,
  type ConnectVariables,
  connectMutationOptions,
} from '@wagmi/core/query'
import { useEffect } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'
import { type UseConnectorsReturnType, useConnectors } from './useConnectors.js'

export type UseConnectParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          ConnectData<config>,
          ConnectErrorType,
          ConnectVariables<config, config['connectors'][number]>,
          context
        >
      | undefined
  }
>

export type UseConnectReturnType<
  config extends Config = Config,
  context = unknown,
> = Compute<
  UseMutationReturnType<
    ConnectData<config>,
    ConnectErrorType,
    ConnectVariables<config, config['connectors'][number]>,
    context
  > & {
    connect: ConnectMutate<config, context>
    connectAsync: ConnectMutateAsync<config, context>
    connectors: Compute<UseConnectorsReturnType> | config['connectors']
  }
>

/** https://wagmi.sh/react/api/hooks/useConnect */
export function useConnect<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseConnectParameters<config, context> = {},
): UseConnectReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = connectMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  // Reset mutation back to an idle state when the connector disconnects.
  useEffect(() => {
    return config.subscribe(
      ({ status }) => status,
      (status, previousStatus) => {
        if (previousStatus === 'connected' && status === 'disconnected')
          result.reset()
      },
    )
  }, [config, result.reset])

  type Return = UseConnectReturnType<config, context>
  return {
    ...(result as Return),
    connect: mutate as Return['connect'],
    connectAsync: mutateAsync as Return['connectAsync'],
    connectors: useConnectors({ config }),
  }
}
</file>

<file path="packages/react/src/hooks/useConnections.ts">
'use client'

import {
  type GetConnectionsReturnType,
  getConnections,
  watchConnections,
} from '@wagmi/core'
import { useSyncExternalStore } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UseConnectionsParameters = ConfigParameter

export type UseConnectionsReturnType = GetConnectionsReturnType

/** https://wagmi.sh/react/api/hooks/useConnections */
export function useConnections(
  parameters: UseConnectionsParameters = {},
): UseConnectionsReturnType {
  const config = useConfig(parameters)

  return useSyncExternalStore(
    (onChange) => watchConnections(config, { onChange }),
    () => getConnections(config),
    () => getConnections(config),
  )
}
</file>

<file path="packages/react/src/hooks/useConnectorClient.test-d.ts">
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useConnectorClient } from './useConnectorClient.js'

test('parameters: config', async () => {
  const client = useConnectorClient({ config })
  expectTypeOf(client.data?.chain?.id!).toEqualTypeOf<1 | 456 | 10>()

  const client2 = useConnectorClient({ config, chainId: 1 })
  expectTypeOf(client2.data?.chain?.id!).toEqualTypeOf<1>()
})
</file>

<file path="packages/react/src/hooks/useConnectorClient.ts">
'use client'

import { useQueryClient } from '@tanstack/react-query'
import type {
  Config,
  GetConnectorClientErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute, Omit } from '@wagmi/core/internal'
import {
  type GetConnectorClientData,
  type GetConnectorClientOptions,
  type GetConnectorClientQueryFnData,
  type GetConnectorClientQueryKey,
  getConnectorClientQueryOptions,
} from '@wagmi/core/query'
import { useEffect, useRef } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import {
  type UseQueryParameters,
  type UseQueryReturnType,
  useQuery,
} from '../utils/query.js'
import { useAccount } from './useAccount.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseConnectorClientParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetConnectorClientData<config, chainId>,
> = Compute<
  GetConnectorClientOptions<config, chainId> &
    ConfigParameter<config> & {
      query?:
        | Compute<
            Omit<
              UseQueryParameters<
                GetConnectorClientQueryFnData<config, chainId>,
                GetConnectorClientErrorType,
                selectData,
                GetConnectorClientQueryKey<config, chainId>
              >,
              'gcTime' | 'staleTime'
            >
          >
        | undefined
    }
>

export type UseConnectorClientReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetConnectorClientData<config, chainId>,
> = UseQueryReturnType<selectData, GetConnectorClientErrorType>

/** https://wagmi.sh/react/api/hooks/useConnectorClient */
export function useConnectorClient<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetConnectorClientData<config, chainId>,
>(
  parameters: UseConnectorClientParameters<config, chainId, selectData> = {},
): UseConnectorClientReturnType<config, chainId, selectData> {
  const { query = {}, ...rest } = parameters

  const config = useConfig(rest)
  const queryClient = useQueryClient()
  const { address, connector, status } = useAccount({ config })
  const chainId = useChainId({ config })
  const activeConnector = parameters.connector ?? connector

  const { queryKey, ...options } = getConnectorClientQueryOptions<
    config,
    chainId
  >(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
    connector: activeConnector,
  })
  const enabled = Boolean(
    (status === 'connected' ||
      (status === 'reconnecting' && activeConnector?.getProvider)) &&
      (query.enabled ?? true),
  )

  const addressRef = useRef(address)
  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required
  useEffect(() => {
    const previousAddress = addressRef.current
    if (!address && previousAddress) {
      // remove when account is disconnected
      queryClient.removeQueries({ queryKey })
      addressRef.current = undefined
    } else if (address !== previousAddress) {
      // invalidate when address changes
      queryClient.invalidateQueries({ queryKey })
      addressRef.current = address
    }
  }, [address, queryClient])

  return useQuery({
    ...query,
    ...options,
    queryKey,
    enabled,
    staleTime: Number.POSITIVE_INFINITY,
  })
}
</file>

<file path="packages/react/src/hooks/useConnectors.ts">
'use client'

import {
  type Config,
  type GetConnectorsReturnType,
  type ResolvedRegister,
  getConnectors,
  watchConnectors,
} from '@wagmi/core'
import { useSyncExternalStore } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UseConnectorsParameters<config extends Config = Config> =
  ConfigParameter<config>

export type UseConnectorsReturnType<config extends Config = Config> =
  GetConnectorsReturnType<config>

/** https://wagmi.sh/react/api/hooks/useConnectors */
export function useConnectors<
  config extends Config = ResolvedRegister['config'],
>(
  parameters: UseConnectorsParameters<config> = {},
): UseConnectorsReturnType<config> {
  const config = useConfig(parameters)

  return useSyncExternalStore(
    (onChange) => watchConnectors(config, { onChange }),
    () => getConnectors(config),
    () => getConnectors(config),
  )
}
</file>

<file path="packages/react/src/hooks/useDeployContract.test-d.ts">
import type { DeployContractErrorType } from '@wagmi/core'
import { abi, bytecode } from '@wagmi/test'
import type { Abi, Hash } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { useDeployContract } from './useDeployContract.js'

const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, deployContract, variables } = useDeployContract(
    {
      mutation: {
        onMutate(variables) {
          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
            abi: Abi
            args?: readonly unknown[] | undefined
          }>()
          return contextValue
        },
        onError(error, variables, context) {
          expectTypeOf(error).toEqualTypeOf<DeployContractErrorType>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
            abi: Abi
            args?: readonly unknown[] | undefined
          }>()
        },
        onSuccess(data, variables, context) {
          expectTypeOf(data).toEqualTypeOf<Hash>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue>()

          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
            abi: Abi
            args?: readonly unknown[] | undefined
          }>()
        },
        onSettled(data, error, variables, context) {
          expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
          expectTypeOf(error).toEqualTypeOf<DeployContractErrorType | null>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
            abi: Abi
            args?: readonly unknown[] | undefined
          }>()
        },
      },
    },
  )

  expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
  expectTypeOf(error).toEqualTypeOf<DeployContractErrorType | null>()
  expectTypeOf(variables).toMatchTypeOf<
    { chainId?: number | undefined } | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  deployContract(
    {
      abi: abi.bayc,
      bytecode: bytecode.bayc,
      args: ['Bored Ape Wagmi Club', 'BAYC', 69420n, 0n],
      chainId: 1,
    },
    {
      onError(error, variables, context) {
        expectTypeOf(error).toEqualTypeOf<DeployContractErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: typeof abi.bayc
          args: readonly [string, string, bigint, bigint]
        }>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: typeof abi.bayc
          args: readonly [string, string, bigint, bigint]
        }>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
        expectTypeOf(error).toEqualTypeOf<DeployContractErrorType | null>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: typeof abi.bayc
          args: readonly [string, string, bigint, bigint]
        }>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useDeployContract.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type {
  Config,
  DeployContractErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type DeployContractData,
  type DeployContractMutate,
  type DeployContractMutateAsync,
  type DeployContractVariables,
  deployContractMutationOptions,
} from '@wagmi/core/query'
import type { Abi } from 'viem'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseDeployContractParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          DeployContractData,
          DeployContractErrorType,
          DeployContractVariables<Abi, config, config['chains'][number]['id']>,
          context
        >
      | undefined
  }
>

export type UseDeployContractReturnType<
  config extends Config = Config,
  context = unknown,
> = UseMutationReturnType<
  DeployContractData,
  DeployContractErrorType,
  DeployContractVariables<Abi, config, config['chains'][number]['id']>,
  context
> & {
  deployContract: DeployContractMutate<config, context>
  deployContractAsync: DeployContractMutateAsync<config, context>
}

/** https://wagmi.sh/react/api/hooks/useDeployContract */
export function useDeployContract<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseDeployContractParameters<config, context> = {},
): UseDeployContractReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = deployContractMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseDeployContractReturnType<config, context>
  return {
    ...result,
    deployContract: mutate as Return['deployContract'],
    deployContractAsync: mutateAsync as Return['deployContractAsync'],
  }
}
</file>

<file path="packages/react/src/hooks/useDisconnect.test-d.ts">
import type { Connector, DisconnectErrorType } from '@wagmi/core'
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useDisconnect } from './useDisconnect.js'

const connector = config.connectors[0]!
const contextValue = { foo: 'bar' } as const

test('parameter', () => {
  expectTypeOf(useDisconnect().disconnect)
    .parameter(0)
    .toEqualTypeOf<{ connector?: Connector | undefined } | undefined>()
  expectTypeOf(useDisconnect().disconnect)
    .parameter(0)
    .toEqualTypeOf<{ connector?: Connector | undefined } | undefined>()
})

test('context', () => {
  const { context, data, disconnect, error, variables } = useDisconnect({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<DisconnectErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        expectTypeOf(data).toEqualTypeOf<void>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<void | undefined>()
        expectTypeOf(error).toEqualTypeOf<DisconnectErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<void | undefined>()
  expectTypeOf(error).toEqualTypeOf<DisconnectErrorType | null>()
  expectTypeOf(variables).toEqualTypeOf<
    { connector?: Connector | undefined } | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  disconnect(
    { connector },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<DisconnectErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        expectTypeOf(data).toEqualTypeOf<void>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<void | undefined>()
        expectTypeOf(error).toEqualTypeOf<DisconnectErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<
          { connector?: Connector | undefined } | undefined
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useDisconnect.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { Connector, DisconnectErrorType } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type DisconnectData,
  type DisconnectMutate,
  type DisconnectMutateAsync,
  type DisconnectVariables,
  disconnectMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'
import { useConnections } from './useConnections.js'

export type UseDisconnectParameters<context = unknown> = Compute<
  ConfigParameter & {
    mutation?:
      | UseMutationParameters<
          DisconnectData,
          DisconnectErrorType,
          DisconnectVariables,
          context
        >
      | undefined
  }
>

export type UseDisconnectReturnType<context = unknown> = Compute<
  UseMutationReturnType<
    DisconnectData,
    DisconnectErrorType,
    DisconnectVariables,
    context
  > & {
    connectors: readonly Connector[]
    disconnect: DisconnectMutate<context>
    disconnectAsync: DisconnectMutateAsync<context>
  }
>

/** https://wagmi.sh/react/api/hooks/useDisconnect */
export function useDisconnect<context = unknown>(
  parameters: UseDisconnectParameters<context> = {},
): UseDisconnectReturnType<context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = disconnectMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  return {
    ...result,
    connectors: useConnections({ config }).map(
      (connection) => connection.connector,
    ),
    disconnect: mutate,
    disconnectAsync: mutateAsync,
  }
}
</file>

<file path="packages/react/src/hooks/useEnsAddress.ts">
'use client'

import type {
  Config,
  GetEnsAddressErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetEnsAddressData,
  type GetEnsAddressOptions,
  type GetEnsAddressQueryFnData,
  type GetEnsAddressQueryKey,
  getEnsAddressQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEnsAddressParameters<
  config extends Config = Config,
  selectData = GetEnsAddressData,
> = Compute<
  GetEnsAddressOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetEnsAddressQueryFnData,
      GetEnsAddressErrorType,
      selectData,
      GetEnsAddressQueryKey<config>
    >
>

export type UseEnsAddressReturnType<selectData = GetEnsAddressData> =
  UseQueryReturnType<selectData, GetEnsAddressErrorType>

/** https://wagmi.sh/react/api/hooks/useEnsAddress */
export function useEnsAddress<
  config extends Config = ResolvedRegister['config'],
  selectData = GetEnsAddressData,
>(
  parameters: UseEnsAddressParameters<config, selectData> = {},
): UseEnsAddressReturnType<selectData> {
  const { name, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getEnsAddressQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(name && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useEnsAvatar.ts">
'use client'

import type {
  Config,
  GetEnsAvatarErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetEnsAvatarData,
  type GetEnsAvatarOptions,
  type GetEnsAvatarQueryFnData,
  type GetEnsAvatarQueryKey,
  getEnsAvatarQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEnsAvatarParameters<
  config extends Config = Config,
  selectData = GetEnsAvatarData,
> = Compute<
  GetEnsAvatarOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetEnsAvatarQueryFnData,
      GetEnsAvatarErrorType,
      selectData,
      GetEnsAvatarQueryKey<config>
    >
>

export type UseEnsAvatarReturnType<selectData = GetEnsAvatarData> =
  UseQueryReturnType<selectData, GetEnsAvatarErrorType>

/** https://wagmi.sh/react/api/hooks/useEnsAvatar */
export function useEnsAvatar<
  config extends Config = ResolvedRegister['config'],
  selectData = GetEnsAvatarData,
>(
  parameters: UseEnsAvatarParameters<config, selectData> = {},
): UseEnsAvatarReturnType<selectData> {
  const { name, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getEnsAvatarQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(name && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useEnsName.ts">
'use client'

import type { Config, GetEnsNameErrorType, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetEnsNameData,
  type GetEnsNameOptions,
  type GetEnsNameQueryFnData,
  type GetEnsNameQueryKey,
  getEnsNameQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEnsNameParameters<
  config extends Config = Config,
  selectData = GetEnsNameData,
> = Compute<
  GetEnsNameOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetEnsNameQueryFnData,
      GetEnsNameErrorType,
      selectData,
      GetEnsNameQueryKey<config>
    >
>

export type UseEnsNameReturnType<selectData = GetEnsNameData> =
  UseQueryReturnType<selectData, GetEnsNameErrorType>

/** https://wagmi.sh/react/api/hooks/useEnsName */
export function useEnsName<
  config extends Config = ResolvedRegister['config'],
  selectData = GetEnsNameData,
>(
  parameters: UseEnsNameParameters<config, selectData> = {},
): UseEnsNameReturnType<selectData> {
  const { address, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getEnsNameQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useEnsResolver.ts">
'use client'

import type {
  Config,
  GetEnsResolverErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetEnsResolverData,
  type GetEnsResolverOptions,
  type GetEnsResolverQueryFnData,
  type GetEnsResolverQueryKey,
  getEnsResolverQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEnsResolverParameters<
  config extends Config = Config,
  selectData = GetEnsResolverData,
> = Compute<
  GetEnsResolverOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetEnsResolverQueryFnData,
      GetEnsResolverErrorType,
      selectData,
      GetEnsResolverQueryKey<config>
    >
>

export type UseEnsResolverReturnType<selectData = GetEnsResolverData> =
  UseQueryReturnType<selectData, GetEnsResolverErrorType>

/** https://wagmi.sh/react/api/hooks/useEnsResolver */
export function useEnsResolver<
  config extends Config = ResolvedRegister['config'],
  selectData = GetEnsResolverData,
>(
  parameters: UseEnsResolverParameters<config, selectData> = {},
): UseEnsResolverReturnType<selectData> {
  const { name, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getEnsResolverQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(name && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useEnsText.ts">
'use client'

import type { Config, GetEnsTextErrorType, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetEnsTextData,
  type GetEnsTextOptions,
  type GetEnsTextQueryFnData,
  type GetEnsTextQueryKey,
  getEnsTextQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEnsTextParameters<
  config extends Config = Config,
  selectData = GetEnsTextData,
> = Compute<
  GetEnsTextOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetEnsTextQueryFnData,
      GetEnsTextErrorType,
      selectData,
      GetEnsTextQueryKey<config>
    >
>

export type UseEnsTextReturnType<selectData = GetEnsTextData> =
  UseQueryReturnType<selectData, GetEnsTextErrorType>

/** https://wagmi.sh/react/api/hooks/useEnsText */
export function useEnsText<
  config extends Config = ResolvedRegister['config'],
  selectData = GetEnsTextData,
>(
  parameters: UseEnsTextParameters<config, selectData> = {},
): UseEnsTextReturnType<selectData> {
  const { key, name, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getEnsTextQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(key && name && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useEstimateFeesPerGas.test-d.ts">
import { expectTypeOf, test } from 'vitest'
import { useEstimateFeesPerGas } from './useEstimateFeesPerGas.js'

test('types', () => {
  const result = useEstimateFeesPerGas()
  expectTypeOf(result.data).toMatchTypeOf<
    | {
        gasPrice?: undefined
        maxFeePerGas: bigint
        maxPriorityFeePerGas: bigint
        formatted: {
          gasPrice?: undefined
          maxFeePerGas: string
          maxPriorityFeePerGas: string
        }
      }
    | undefined
  >()

  const result2 = useEstimateFeesPerGas({ type: 'legacy' })
  expectTypeOf(result2.data).toMatchTypeOf<
    | {
        gasPrice: bigint
        maxFeePerGas?: undefined
        maxPriorityFeePerGas?: undefined
        formatted: {
          gasPrice: string
          maxFeePerGas?: undefined
          maxPriorityFeePerGas?: undefined
        }
      }
    | undefined
  >()

  const result3 = useEstimateFeesPerGas({ type: 'eip1559' })
  expectTypeOf(result3.data).toMatchTypeOf<
    | {
        gasPrice?: undefined
        maxFeePerGas: bigint
        maxPriorityFeePerGas: bigint
        formatted: {
          gasPrice?: undefined
          maxFeePerGas: string
          maxPriorityFeePerGas: string
        }
      }
    | undefined
  >()
})
</file>

<file path="packages/react/src/hooks/useEstimateFeesPerGas.ts">
'use client'

import type {
  Config,
  EstimateFeesPerGasErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type EstimateFeesPerGasData,
  type EstimateFeesPerGasOptions,
  type EstimateFeesPerGasQueryFnData,
  type EstimateFeesPerGasQueryKey,
  estimateFeesPerGasQueryOptions,
} from '@wagmi/core/query'
import type { FeeValuesType } from 'viem'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEstimateFeesPerGasParameters<
  type extends FeeValuesType = FeeValuesType,
  config extends Config = Config,
  selectData = EstimateFeesPerGasData<type>,
> = Compute<
  EstimateFeesPerGasOptions<type, config> &
    ConfigParameter<config> &
    QueryParameter<
      EstimateFeesPerGasQueryFnData<type>,
      EstimateFeesPerGasErrorType,
      selectData,
      EstimateFeesPerGasQueryKey<config, type>
    >
>

export type UseEstimateFeesPerGasReturnType<
  type extends FeeValuesType = FeeValuesType,
  selectData = EstimateFeesPerGasData<type>,
> = UseQueryReturnType<selectData, EstimateFeesPerGasErrorType>

/** https://wagmi.sh/react/api/hooks/useEstimateFeesPerGas */
export function useEstimateFeesPerGas<
  config extends Config = ResolvedRegister['config'],
  type extends FeeValuesType = 'eip1559',
  selectData = EstimateFeesPerGasData<type>,
>(
  parameters: UseEstimateFeesPerGasParameters<type, config, selectData> = {},
): UseEstimateFeesPerGasReturnType<type, selectData> {
  const { query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = estimateFeesPerGasQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useEstimateGas.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useEstimateGas } from './useEstimateGas.js'

test('select data', () => {
  const result = useEstimateGas({
    query: {
      select(data) {
        return data.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})
</file>

<file path="packages/react/src/hooks/useEstimateGas.ts">
'use client'

import type {
  Config,
  EstimateGasErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import {
  type EstimateGasData,
  type EstimateGasOptions,
  type EstimateGasQueryFnData,
  type EstimateGasQueryKey,
  estimateGasQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'
import { useConnectorClient } from './useConnectorClient.js'

export type UseEstimateGasParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = EstimateGasData,
> = EstimateGasOptions<config, chainId> &
  ConfigParameter<config> &
  QueryParameter<
    EstimateGasQueryFnData,
    EstimateGasErrorType,
    selectData,
    EstimateGasQueryKey<config, chainId>
  >

export type UseEstimateGasReturnType<selectData = EstimateGasData> =
  UseQueryReturnType<selectData, EstimateGasErrorType>

/** https://wagmi.sh/react/api/hooks/useEstimateGas */
export function useEstimateGas<
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = EstimateGasData,
>(
  parameters?: UseEstimateGasParameters<config, chainId, selectData>,
): UseEstimateGasReturnType<selectData>

export function useEstimateGas(
  parameters: UseEstimateGasParameters = {},
): UseEstimateGasReturnType {
  const { connector, query = {} } = parameters

  const config = useConfig(parameters)
  const { data: connectorClient } = useConnectorClient({
    config,
    connector,
    query: { enabled: parameters.account === undefined },
  })
  const account = parameters.account ?? connectorClient?.account
  const chainId = useChainId({ config })

  const options = estimateGasQueryOptions(config, {
    ...parameters,
    account,
    chainId: parameters.chainId ?? chainId,
    connector,
  })
  const enabled = Boolean((account || connector) && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useEstimateMaxPriorityFeePerGas.test-d.ts">
import { expectTypeOf, test } from 'vitest'
import { useEstimateMaxPriorityFeePerGas } from './useEstimateMaxPriorityFeePerGas.js'

test('select data', () => {
  const result = useEstimateMaxPriorityFeePerGas({
    query: {
      select(data) {
        return data.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})
</file>

<file path="packages/react/src/hooks/useEstimateMaxPriorityFeePerGas.ts">
'use client'

import type {
  Config,
  EstimateMaxPriorityFeePerGasErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type EstimateMaxPriorityFeePerGasData,
  type EstimateMaxPriorityFeePerGasOptions,
  type EstimateMaxPriorityFeePerGasQueryFnData,
  type EstimateMaxPriorityFeePerGasQueryKey,
  estimateMaxPriorityFeePerGasQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseEstimateMaxPriorityFeePerGasParameters<
  config extends Config = Config,
  selectData = EstimateMaxPriorityFeePerGasData,
> = Compute<
  EstimateMaxPriorityFeePerGasOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      EstimateMaxPriorityFeePerGasQueryFnData,
      EstimateMaxPriorityFeePerGasErrorType,
      selectData,
      EstimateMaxPriorityFeePerGasQueryKey<config>
    >
>

export type UseEstimateMaxPriorityFeePerGasReturnType<
  selectData = EstimateMaxPriorityFeePerGasData,
> = UseQueryReturnType<selectData, EstimateMaxPriorityFeePerGasErrorType>

/** https://wagmi.sh/react/api/hooks/useEstimateMaxPriorityFeePerGas */
export function useEstimateMaxPriorityFeePerGas<
  config extends Config = ResolvedRegister['config'],
  selectData = EstimateMaxPriorityFeePerGasData,
>(
  parameters: UseEstimateMaxPriorityFeePerGasParameters<
    config,
    selectData
  > = {},
): UseEstimateMaxPriorityFeePerGasReturnType<selectData> {
  const { query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = estimateMaxPriorityFeePerGasQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useFeeHistory.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useFeeHistory } from './useFeeHistory.js'

test('select data', () => {
  const result = useFeeHistory({
    query: {
      select(data) {
        return data.gasUsedRatio
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<number[] | undefined>()
})
</file>

<file path="packages/react/src/hooks/useFeeHistory.ts">
'use client'

import type {
  Config,
  GetFeeHistoryErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetFeeHistoryData,
  type GetFeeHistoryOptions,
  type GetFeeHistoryQueryFnData,
  type GetFeeHistoryQueryKey,
  getFeeHistoryQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseFeeHistoryParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetFeeHistoryData,
> = Compute<
  GetFeeHistoryOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetFeeHistoryQueryFnData,
      GetFeeHistoryErrorType,
      selectData,
      GetFeeHistoryQueryKey<config, chainId>
    >
>

export type UseFeeHistoryReturnType<selectData = GetFeeHistoryData> =
  UseQueryReturnType<selectData, GetFeeHistoryErrorType>

/** https://wagmi.sh/react/api/hooks/useFeeHistory */
export function useFeeHistory<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetFeeHistoryData,
>(
  parameters: UseFeeHistoryParameters<config, chainId, selectData> = {},
): UseFeeHistoryReturnType<selectData> {
  const { blockCount, rewardPercentiles, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getFeeHistoryQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(
    blockCount && rewardPercentiles && (query.enabled ?? true),
  )

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useGasPrice.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useGasPrice } from './useGasPrice.js'

test('select data', () => {
  const result = useGasPrice({
    query: {
      select(data) {
        return data?.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})
</file>

<file path="packages/react/src/hooks/useGasPrice.ts">
'use client'

import type {
  Config,
  GetGasPriceErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetGasPriceData,
  type GetGasPriceOptions,
  type GetGasPriceQueryFnData,
  type GetGasPriceQueryKey,
  getGasPriceQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseGasPriceParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetGasPriceData,
> = Compute<
  GetGasPriceOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetGasPriceQueryFnData,
      GetGasPriceErrorType,
      selectData,
      GetGasPriceQueryKey<config, chainId>
    >
>

export type UseGasPriceReturnType<selectData = GetGasPriceData> =
  UseQueryReturnType<selectData, GetGasPriceErrorType>

/** https://wagmi.sh/react/api/hooks/useGasPrice */
export function useGasPrice<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetGasPriceData,
>(
  parameters: UseGasPriceParameters<config, chainId, selectData> = {},
): UseGasPriceReturnType<selectData> {
  const { query = {} } = parameters

  const config = useConfig(parameters)
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  const options = getGasPriceQueryOptions(config, {
    ...parameters,
    chainId,
  })

  return useQuery({ ...query, ...options })
}
</file>

<file path="packages/react/src/hooks/useInfiniteReadContracts.test-d.ts">
import { abi } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useInfiniteReadContracts } from './useInfiniteReadContracts.js'

test('select data', () => {
  const result = useInfiniteReadContracts({
    allowFailure: false,
    cacheKey: 'foo',
    contracts(pageParam) {
      expectTypeOf(pageParam).toEqualTypeOf<string>()
      return [
        {
          address: '0x',
          abi: abi.erc20,
          functionName: 'balanceOf',
          args: ['0x'],
        },
        {
          address: '0x',
          abi: abi.wagmiMintExample,
          functionName: 'tokenURI',
          args: [123n],
        },
      ]
    },
    query: {
      initialPageParam: '0',
      getNextPageParam(lastPage, allPages, lastPageParam, allPageParams) {
        expectTypeOf(lastPage).toEqualTypeOf<[bigint, string]>()
        expectTypeOf(allPages).toEqualTypeOf<[bigint, string][]>()
        expectTypeOf(lastPageParam).toEqualTypeOf<string>()
        expectTypeOf(allPageParams).toEqualTypeOf<string[]>()
        return lastPageParam + 1
      },
      select(data) {
        expectTypeOf(data.pageParams[0]!).toEqualTypeOf<string>()
        expectTypeOf(data.pages[0]!).toEqualTypeOf<[bigint, string]>()
        return data.pages[0]?.[0]!
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})
</file>

<file path="packages/react/src/hooks/useInfiniteReadContracts.ts">
'use client'

import type {
  Config,
  ReadContractsErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import {
  type InfiniteReadContractsQueryFnData,
  type InfiniteReadContractsQueryKey,
  infiniteReadContractsQueryOptions,
  structuralSharing,
} from '@wagmi/core/query'
import type { ContractFunctionParameters } from 'viem'

import type {
  InfiniteReadContractsData,
  InfiniteReadContractsOptions,
} from '../exports/query.js'
import type {
  ConfigParameter,
  InfiniteQueryParameter,
} from '../types/properties.js'
import {
  type UseInfiniteQueryParameters,
  type UseInfiniteQueryReturnType,
  useInfiniteQuery,
} from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseInfiniteContractReadsParameters<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  config extends Config = Config,
  pageParam = unknown,
  selectData = InfiniteReadContractsData<contracts, allowFailure>,
> = InfiniteReadContractsOptions<contracts, allowFailure, pageParam, config> &
  ConfigParameter<config> &
  InfiniteQueryParameter<
    InfiniteReadContractsQueryFnData<contracts, allowFailure>,
    ReadContractsErrorType,
    selectData,
    InfiniteReadContractsData<contracts, allowFailure>,
    InfiniteReadContractsQueryKey<contracts, allowFailure, pageParam, config>,
    pageParam
  >

export type UseInfiniteContractReadsReturnType<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  selectData = InfiniteReadContractsData<contracts, allowFailure>,
> = UseInfiniteQueryReturnType<selectData, ReadContractsErrorType>

/** https://wagmi.sh/react/api/hooks/useInfiniteReadContracts */
export function useInfiniteReadContracts<
  const contracts extends readonly unknown[],
  allowFailure extends boolean = true,
  config extends Config = ResolvedRegister['config'],
  pageParam = unknown,
  selectData = InfiniteReadContractsData<contracts, allowFailure>,
>(
  parameters: UseInfiniteContractReadsParameters<
    contracts,
    allowFailure,
    config,
    pageParam,
    selectData
  >,
): UseInfiniteContractReadsReturnType<contracts, allowFailure, selectData> {
  const { contracts = [], query } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = infiniteReadContractsQueryOptions(config, {
    ...parameters,
    chainId,
    contracts: contracts as UseInfiniteContractReadsParameters['contracts'],
    query: query as UseInfiniteQueryParameters,
  })

  return useInfiniteQuery({
    ...(query as any),
    ...options,
    initialPageParam: options.initialPageParam,
    structuralSharing: query.structuralSharing ?? structuralSharing,
  })
}
</file>

<file path="packages/react/src/hooks/usePrepareTransactionRequest.test-d.ts">
import { config } from '@wagmi/test'
import type { PrepareTransactionRequestReturnType } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { usePrepareTransactionRequest } from './usePrepareTransactionRequest.js'

test('select data', () => {
  const result = usePrepareTransactionRequest({
    query: {
      select(data) {
        return data
      },
    },
  })

  expectTypeOf(result.data).toMatchTypeOf<
    PrepareTransactionRequestReturnType | undefined
  >()
})

test('parameters: config', () => {
  const result = usePrepareTransactionRequest({
    config,
    chainId: 456,
  })
  if (result.data) expectTypeOf(result.data.chainId).toEqualTypeOf<456>()
})
</file>

<file path="packages/react/src/hooks/usePrepareTransactionRequest.ts">
'use client'

import type {
  Config,
  PrepareTransactionRequestErrorType,
  ResolvedRegister,
  SelectChains,
} from '@wagmi/core'
import {
  type PrepareTransactionRequestData,
  type PrepareTransactionRequestOptions,
  type PrepareTransactionRequestQueryKey,
  prepareTransactionRequestQueryOptions,
} from '@wagmi/core/query'
import type { PrepareTransactionRequestQueryFnData } from '@wagmi/core/query'
import type { PrepareTransactionRequestRequest as viem_PrepareTransactionRequestRequest } from 'viem'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UsePrepareTransactionRequestParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  > = viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
  selectData = PrepareTransactionRequestData<config, chainId, request>,
> = PrepareTransactionRequestOptions<config, chainId, request> &
  ConfigParameter<config> &
  QueryParameter<
    PrepareTransactionRequestQueryFnData<config, chainId, request>,
    PrepareTransactionRequestErrorType,
    selectData,
    PrepareTransactionRequestQueryKey<config, chainId, request>
  >

export type UsePrepareTransactionRequestReturnType<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  > = viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
  selectData = PrepareTransactionRequestData<config, chainId, request>,
> = UseQueryReturnType<selectData, PrepareTransactionRequestErrorType>

/** https://wagmi.sh/react/api/hooks/usePrepareTransactionRequest */
export function usePrepareTransactionRequest<
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  request extends viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  > = viem_PrepareTransactionRequestRequest<
    SelectChains<config, chainId>[0],
    SelectChains<config, chainId>[0]
  >,
  selectData = PrepareTransactionRequestData<config, chainId, request>,
>(
  parameters: UsePrepareTransactionRequestParameters<
    config,
    chainId,
    request,
    selectData
  > = {} as any,
): UsePrepareTransactionRequestReturnType<
  config,
  chainId,
  request,
  selectData
> {
  const { to, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = prepareTransactionRequestQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  } as PrepareTransactionRequestOptions<config, chainId, request>)
  const enabled = Boolean(to && (query.enabled ?? true))

  return useQuery({
    ...(query as any),
    ...options,
    enabled,
  }) as UsePrepareTransactionRequestReturnType<
    config,
    chainId,
    request,
    selectData
  >
}
</file>

<file path="packages/react/src/hooks/useProof.test-d.ts">
import type { GetProofReturnType } from 'viem'
import { expectTypeOf, test } from 'vitest'
import { useProof } from './useProof.js'

test('select data', () => {
  const result = useProof({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<GetProofReturnType | undefined>()
})
</file>

<file path="packages/react/src/hooks/useProof.ts">
'use client'

import type { Config, GetProofErrorType, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetProofData,
  type GetProofOptions,
  type GetProofQueryKey,
  getProofQueryOptions,
} from '@wagmi/core/query'
import type { GetProofQueryFnData } from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseProofParameters<
  config extends Config = Config,
  selectData = GetProofData,
> = Compute<
  GetProofOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetProofQueryFnData,
      GetProofErrorType,
      selectData,
      GetProofQueryKey<config>
    >
>

export type UseProofReturnType<selectData = GetProofData> = UseQueryReturnType<
  selectData,
  GetProofErrorType
>

/** https://wagmi.sh/react/api/hooks/useProof */
export function useProof<
  config extends Config = ResolvedRegister['config'],
  selectData = GetProofData,
>(
  parameters: UseProofParameters<config, selectData> = {},
): UseProofReturnType<selectData> {
  const { address, storageKeys, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getProofQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && storageKeys && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/usePublicClient.test-d.ts">
import { chain, config } from '@wagmi/test'
import type { Chain } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { usePublicClient } from './usePublicClient.js'

test('default', () => {
  const client = usePublicClient({ config })
  expectTypeOf(client.chain).toEqualTypeOf<(typeof config)['chains'][number]>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('parameters: chainId', () => {
  const client = usePublicClient({
    config,
    chainId: chain.mainnet.id,
  })
  expectTypeOf(client.chain).toEqualTypeOf<typeof chain.mainnet>()
  expectTypeOf(client.chain).not.toEqualTypeOf<typeof chain.mainnet2>()
  expectTypeOf(client.transport.type).toEqualTypeOf<'http'>()
})

test('behavior: unconfigured chain', () => {
  {
    const client = usePublicClient({ chainId: 123456 })
    if (client) {
      expectTypeOf(client.chain).toEqualTypeOf<Chain>()
      expectTypeOf(client.transport.type).toEqualTypeOf<string>()
    } else {
      expectTypeOf(client).toEqualTypeOf<undefined>()
    }
  }

  const client = usePublicClient({
    config,
    // @ts-expect-error
    chainId: 123456,
  })
  expectTypeOf(client).toEqualTypeOf<undefined>()
})
</file>

<file path="packages/react/src/hooks/usePublicClient.ts">
'use client'

import {
  type Config,
  type GetPublicClientParameters,
  type GetPublicClientReturnType,
  type ResolvedRegister,
  getPublicClient,
  watchPublicClient,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'

import type { ConfigParameter } from '../types/properties.js'
import { useConfig } from './useConfig.js'

export type UsePublicClientParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | number | undefined =
    | config['chains'][number]['id']
    | undefined,
> = Compute<
  GetPublicClientParameters<config, chainId> & ConfigParameter<config>
>

export type UsePublicClientReturnType<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | number | undefined =
    | config['chains'][number]['id']
    | undefined,
> = GetPublicClientReturnType<config, chainId>

/** https://wagmi.sh/react/api/hooks/usePublicClient */
export function usePublicClient<
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | number | undefined =
    | config['chains'][number]['id']
    | undefined,
>(
  parameters: UsePublicClientParameters<config, chainId> = {},
): UsePublicClientReturnType<config, chainId> {
  const config = useConfig(parameters)

  return useSyncExternalStoreWithSelector(
    (onChange) => watchPublicClient(config, { onChange }),
    () => getPublicClient(config, parameters),
    () => getPublicClient(config, parameters),
    (x) => x,
    (a, b) => a?.uid === b?.uid,
  ) as any
}
</file>

<file path="packages/react/src/hooks/useReadContract.test-d.ts">
import { abi } from '@wagmi/test'
import type { Address } from 'viem'
import { assertType, expectTypeOf, test } from 'vitest'

import {
  type UseReadContractParameters,
  type UseReadContractReturnType,
  useReadContract,
} from './useReadContract.js'

test('select data', () => {
  const result = useReadContract({
    address: '0x',
    abi: abi.erc20,
    functionName: 'balanceOf',
    args: ['0x'],
    query: {
      select(data) {
        expectTypeOf(data).toEqualTypeOf<bigint>()
        return data?.toString()
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})

test('UseReadContractParameters', () => {
  type Result = UseReadContractParameters<typeof abi.erc20, 'balanceOf'>
  expectTypeOf<Pick<Result, 'args' | 'functionName'>>().toEqualTypeOf<{
    functionName?:
      | 'symbol'
      | 'name'
      | 'allowance'
      | 'balanceOf'
      | 'decimals'
      | 'totalSupply'
      | undefined
    args?: readonly [Address] | undefined
  }>()
})

test('UseReadContractReturnType', () => {
  type Result = UseReadContractReturnType<typeof abi.erc20, 'balanceOf'>
  expectTypeOf<Result['data']>().toEqualTypeOf<bigint | undefined>()
})

test('overloads', () => {
  const result1 = useReadContract({
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
  })
  assertType<number | undefined>(result1.data)

  const result2 = useReadContract({
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
    args: [],
  })
  assertType<number | undefined>(result2.data)

  const result3 = useReadContract({
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
    args: ['0x'],
  })
  // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  assertType<string | undefined>(result3.data)

  const result4 = useReadContract({
    address: '0x',
    abi: abi.viewOverloads,
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  assertType<
    | {
        foo: `0x${string}`
        bar: `0x${string}`
      }
    | undefined
    // @ts-ignore  TODO: Fix https://github.com/wevm/viem/issues/1916
  >(result4.data)
})

test('deployless read (bytecode)', () => {
  const result = useReadContract({
    code: '0x',
    abi: abi.erc20,
    functionName: 'balanceOf',
    args: ['0x'],
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})
</file>

<file path="packages/react/src/hooks/useReadContract.ts">
'use client'

import type {
  Config,
  ReadContractErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { UnionCompute } from '@wagmi/core/internal'
import {
  type ReadContractData,
  type ReadContractOptions,
  type ReadContractQueryFnData,
  type ReadContractQueryKey,
  readContractQueryOptions,
  structuralSharing,
} from '@wagmi/core/query'
import type { Abi, ContractFunctionArgs, ContractFunctionName, Hex } from 'viem'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseReadContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'pure' | 'view'
  > = ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<
    abi,
    'pure' | 'view',
    functionName
  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  config extends Config = Config,
  selectData = ReadContractData<abi, functionName, args>,
> = UnionCompute<
  ReadContractOptions<abi, functionName, args, config> &
    ConfigParameter<config> &
    QueryParameter<
      ReadContractQueryFnData<abi, functionName, args>,
      ReadContractErrorType,
      selectData,
      ReadContractQueryKey<abi, functionName, args, config>
    >
>

export type UseReadContractReturnType<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'pure' | 'view'
  > = ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<
    abi,
    'pure' | 'view',
    functionName
  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  selectData = ReadContractData<abi, functionName, args>,
> = UseQueryReturnType<selectData, ReadContractErrorType>

/** https://wagmi.sh/react/api/hooks/useReadContract */
export function useReadContract<
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  config extends Config = ResolvedRegister['config'],
  selectData = ReadContractData<abi, functionName, args>,
>(
  parameters: UseReadContractParameters<
    abi,
    functionName,
    args,
    config,
    selectData
  > = {} as any,
): UseReadContractReturnType<abi, functionName, args, selectData> {
  const { abi, address, functionName, query = {} } = parameters
  // @ts-ignore
  const code = parameters.code as Hex | undefined

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = readContractQueryOptions<config, abi, functionName, args>(
    config,
    { ...(parameters as any), chainId: parameters.chainId ?? chainId },
  )
  const enabled = Boolean(
    (address || code) && abi && functionName && (query.enabled ?? true),
  )

  return useQuery({
    ...query,
    ...options,
    enabled,
    structuralSharing: query.structuralSharing ?? structuralSharing,
  })
}
</file>

<file path="packages/react/src/hooks/useReadContracts.test-d.ts">
import { abi } from '@wagmi/test'
import { assertType, expectTypeOf, test } from 'vitest'

import { useReadContracts } from './useReadContracts.js'

test('select data', () => {
  const result = useReadContracts({
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.erc20,
        functionName: 'balanceOf',
        chainId: 1,
        args: ['0x'],
      },
      {
        address: '0x',
        abi: abi.wagmiMintExample,
        functionName: 'tokenURI',
        args: [123n],
      },
    ],
    query: {
      select(data) {
        expectTypeOf(data).toEqualTypeOf<[bigint, string]>()
        return data[0]
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})

test('overloads', async () => {
  const result1 = useReadContracts({
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
      },
    ],
  })
  assertType<[number] | undefined>(result1.data)

  const result2 = useReadContracts({
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: [],
      },
    ],
  })
  assertType<[number] | undefined>(result2.data)

  const result3 = useReadContracts({
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: ['0x'],
      },
    ],
  })
  assertType<[string] | undefined>(result3.data)

  const result4 = useReadContracts({
    allowFailure: false,
    contracts: [
      {
        address: '0x',
        abi: abi.viewOverloads,
        functionName: 'foo',
        args: ['0x', '0x'],
      },
    ],
  })
  assertType<
    | [
        {
          foo: `0x${string}`
          bar: `0x${string}`
        },
      ]
    | undefined
  >(result4.data)
})
</file>

<file path="packages/react/src/hooks/useReadContracts.ts">
'use client'

import type {
  Config,
  ReadContractsErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type ReadContractsData,
  type ReadContractsOptions,
  type ReadContractsQueryFnData,
  type ReadContractsQueryKey,
  readContractsQueryOptions,
  structuralSharing,
} from '@wagmi/core/query'
import { useMemo } from 'react'
import type { ContractFunctionParameters } from 'viem'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseReadContractsParameters<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  config extends Config = Config,
  selectData = ReadContractsData<contracts, allowFailure>,
> = Compute<
  ReadContractsOptions<contracts, allowFailure, config> &
    ConfigParameter<config> &
    QueryParameter<
      ReadContractsQueryFnData<contracts, allowFailure>,
      ReadContractsErrorType,
      selectData,
      ReadContractsQueryKey<contracts, allowFailure, config>
    >
>

export type UseReadContractsReturnType<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  selectData = ReadContractsData<contracts, allowFailure>,
> = UseQueryReturnType<selectData, ReadContractsErrorType>

/** https://wagmi.sh/react/api/hooks/useReadContracts */
export function useReadContracts<
  const contracts extends readonly unknown[],
  allowFailure extends boolean = true,
  config extends Config = ResolvedRegister['config'],
  selectData = ReadContractsData<contracts, allowFailure>,
>(
  parameters: UseReadContractsParameters<
    contracts,
    allowFailure,
    config,
    selectData
  > = {},
): UseReadContractsReturnType<contracts, allowFailure, selectData> {
  const { contracts = [], query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = readContractsQueryOptions<config, contracts, allowFailure>(
    config,
    { ...parameters, chainId },
  )

  const enabled = useMemo(() => {
    let isContractsValid = false
    for (const contract of contracts) {
      const { abi, address, functionName } =
        contract as ContractFunctionParameters
      if (!abi || !address || !functionName) {
        isContractsValid = false
        break
      }
      isContractsValid = true
    }
    return Boolean(isContractsValid && (query.enabled ?? true))
  }, [contracts, query.enabled])

  return useQuery({
    ...options,
    ...query,
    enabled,
    structuralSharing: query.structuralSharing ?? structuralSharing,
  })
}
</file>

<file path="packages/react/src/hooks/useReconnect.test-d.ts">
import type {
  Connector,
  CreateConnectorFn,
  ReconnectErrorType,
} from '@wagmi/core'
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import type { Address } from 'viem'
import { useReconnect } from './useReconnect.js'

const connectors = [config.connectors[0]!]
const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, reconnect, variables } = useReconnect({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<ReconnectErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        expectTypeOf(data).toEqualTypeOf<
          {
            accounts: readonly [Address, ...Address[]]
            chainId: number
            connector: Connector
          }[]
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<
          | {
              accounts: readonly [Address, ...Address[]]
              chainId: number
              connector: Connector
            }[]
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<ReconnectErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<
    | {
        accounts: readonly [Address, ...Address[]]
        chainId: number
        connector: Connector
      }[]
    | undefined
  >()
  expectTypeOf(error).toEqualTypeOf<ReconnectErrorType | null>()
  expectTypeOf(variables).toEqualTypeOf<
    | {
        connectors?: readonly (CreateConnectorFn | Connector)[] | undefined
      }
    | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  reconnect(
    { connectors },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<ReconnectErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        expectTypeOf(data).toEqualTypeOf<
          {
            accounts: readonly [Address, ...Address[]]
            chainId: number
            connector: Connector
          }[]
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<
          | {
              accounts: readonly [Address, ...Address[]]
              chainId: number
              connector: Connector
            }[]
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<ReconnectErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<
          | {
              connectors?:
                | readonly (CreateConnectorFn | Connector)[]
                | undefined
            }
          | undefined
        >()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useReconnect.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { Connector, ReconnectErrorType } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type ReconnectData,
  type ReconnectMutate,
  type ReconnectMutateAsync,
  type ReconnectVariables,
  reconnectMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseReconnectParameters<context = unknown> = Compute<
  ConfigParameter & {
    mutation?:
      | UseMutationParameters<
          ReconnectData,
          ReconnectErrorType,
          ReconnectVariables,
          context
        >
      | undefined
  }
>

export type UseReconnectReturnType<context = unknown> = Compute<
  UseMutationReturnType<
    ReconnectData,
    ReconnectErrorType,
    ReconnectVariables,
    context
  > & {
    connectors: readonly Connector[]
    reconnect: ReconnectMutate<context>
    reconnectAsync: ReconnectMutateAsync<context>
  }
>

/** https://wagmi.sh/react/api/hooks/useReconnect */
export function useReconnect<context = unknown>(
  parameters: UseReconnectParameters<context> = {},
): UseReconnectReturnType<context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = reconnectMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  return {
    ...result,
    connectors: config.connectors,
    reconnect: mutate,
    reconnectAsync: mutateAsync,
  }
}
</file>

<file path="packages/react/src/hooks/useSendCalls.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { Config, ResolvedRegister, SendCallsErrorType } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type SendCallsData,
  type SendCallsMutate,
  type SendCallsMutateAsync,
  type SendCallsVariables,
  sendCallsMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseSendCallsParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          SendCallsData,
          SendCallsErrorType,
          SendCallsVariables<config, config['chains'][number]['id']>,
          context
        >
      | undefined
  }
>

export type UseSendCallsReturnType<
  config extends Config = Config,
  context = unknown,
> = Compute<
  UseMutationReturnType<
    SendCallsData,
    SendCallsErrorType,
    SendCallsVariables<config, config['chains'][number]['id']>,
    context
  > & {
    sendCalls: SendCallsMutate<config, context>
    sendCallsAsync: SendCallsMutateAsync<config, context>
  }
>

/** https://wagmi.sh/react/api/hooks/useSendCalls */
export function useSendCalls<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseSendCallsParameters<config, context> = {},
): UseSendCallsReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = sendCallsMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseSendCallsReturnType<config, context>
  return {
    ...result,
    sendCalls: mutate as Return['sendCalls'],
    sendCallsAsync: mutateAsync as Return['sendCallsAsync'],
  }
}
</file>

<file path="packages/react/src/hooks/useSendTransaction.test-d.ts">
import type { SendTransactionErrorType } from '@wagmi/core'
import type { Hash } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { useSendTransaction } from './useSendTransaction.js'

const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, sendTransaction, variables } =
    useSendTransaction({
      mutation: {
        onMutate(variables) {
          expectTypeOf(variables).toMatchTypeOf<
            { chainId?: number | undefined } | undefined
          >()
          return contextValue
        },
        onError(error, variables, context) {
          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
          }>()
          expectTypeOf(error).toEqualTypeOf<SendTransactionErrorType>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
        },
        onSuccess(data, variables, context) {
          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
          }>()
          expectTypeOf(data).toEqualTypeOf<Hash>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
        },
        onSettled(data, error, variables, context) {
          expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
          expectTypeOf(error).toEqualTypeOf<SendTransactionErrorType | null>()
          expectTypeOf(variables).toMatchTypeOf<{
            chainId?: number | undefined
          }>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
        },
      },
    })

  expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
  expectTypeOf(error).toEqualTypeOf<SendTransactionErrorType | null>()
  expectTypeOf(variables).toMatchTypeOf<
    { chainId?: number | undefined } | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  sendTransaction(
    { to: '0x' },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
        }>()
        expectTypeOf(error).toEqualTypeOf<SendTransactionErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
        }>()
        expectTypeOf(data).toEqualTypeOf<Hash>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
        expectTypeOf(error).toEqualTypeOf<SendTransactionErrorType | null>()
        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useSendTransaction.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type {
  Config,
  ResolvedRegister,
  SendTransactionErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type SendTransactionData,
  type SendTransactionMutate,
  type SendTransactionMutateAsync,
  type SendTransactionVariables,
  sendTransactionMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseSendTransactionParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          SendTransactionData,
          SendTransactionErrorType,
          SendTransactionVariables<config, config['chains'][number]['id']>,
          context
        >
      | undefined
  }
>

export type UseSendTransactionReturnType<
  config extends Config = Config,
  context = unknown,
> = Compute<
  UseMutationReturnType<
    SendTransactionData,
    SendTransactionErrorType,
    SendTransactionVariables<config, config['chains'][number]['id']>,
    context
  > & {
    sendTransaction: SendTransactionMutate<config, context>
    sendTransactionAsync: SendTransactionMutateAsync<config, context>
  }
>

/** https://wagmi.sh/react/api/hooks/useSendTransaction */
export function useSendTransaction<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseSendTransactionParameters<config, context> = {},
): UseSendTransactionReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = sendTransactionMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseSendTransactionReturnType<config, context>
  return {
    ...result,
    sendTransaction: mutate as Return['sendTransaction'],
    sendTransactionAsync: mutateAsync as Return['sendTransactionAsync'],
  }
}
</file>

<file path="packages/react/src/hooks/useShowCallsStatus.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type {
  Config,
  ResolvedRegister,
  ShowCallsStatusErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type ShowCallsStatusData,
  type ShowCallsStatusMutate,
  type ShowCallsStatusMutateAsync,
  type ShowCallsStatusVariables,
  showCallsStatusMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseShowCallsStatusParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          ShowCallsStatusData,
          ShowCallsStatusErrorType,
          ShowCallsStatusVariables,
          context
        >
      | undefined
  }
>

export type UseShowCallsStatusReturnType<context = unknown> = Compute<
  UseMutationReturnType<
    ShowCallsStatusData,
    ShowCallsStatusErrorType,
    ShowCallsStatusVariables,
    context
  > & {
    showCallsStatus: ShowCallsStatusMutate
    showCallsStatusAsync: ShowCallsStatusMutateAsync
  }
>

/** https://wagmi.sh/react/api/hooks/useShowCallsStatus */
export function useShowCallsStatus<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseShowCallsStatusParameters<config, context> = {},
): UseShowCallsStatusReturnType<context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = showCallsStatusMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseShowCallsStatusReturnType
  return {
    ...result,
    showCallsStatus: mutate as Return['showCallsStatus'],
    showCallsStatusAsync: mutateAsync as Return['showCallsStatusAsync'],
  }
}
</file>

<file path="packages/react/src/hooks/useSignMessage.test-d.ts">
import type { SignMessageErrorType } from '@wagmi/core'
import type { SignMessageVariables } from '@wagmi/core/query'
import { expectTypeOf, test } from 'vitest'

import { useSignMessage } from './useSignMessage.js'

const message = 'hello world'
const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, signMessage, variables } = useSignMessage({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        expectTypeOf(error).toEqualTypeOf<SignMessageErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        expectTypeOf(data).toEqualTypeOf<`0x${string}`>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<`0x${string}` | undefined>()
        expectTypeOf(error).toEqualTypeOf<SignMessageErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<`0x${string}` | undefined>()
  expectTypeOf(error).toEqualTypeOf<SignMessageErrorType | null>()
  expectTypeOf(variables).toEqualTypeOf<SignMessageVariables | undefined>()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  signMessage(
    { message },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        expectTypeOf(error).toEqualTypeOf<SignMessageErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        expectTypeOf(data).toEqualTypeOf<`0x${string}`>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<`0x${string}` | undefined>()
        expectTypeOf(error).toEqualTypeOf<SignMessageErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<SignMessageVariables>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useSignMessage.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { SignMessageErrorType } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type SignMessageData,
  type SignMessageMutate,
  type SignMessageMutateAsync,
  type SignMessageVariables,
  signMessageMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseSignMessageParameters<context = unknown> = Compute<
  ConfigParameter & {
    mutation?:
      | UseMutationParameters<
          SignMessageData,
          SignMessageErrorType,
          SignMessageVariables,
          context
        >
      | undefined
  }
>

export type UseSignMessageReturnType<context = unknown> = Compute<
  UseMutationReturnType<
    SignMessageData,
    SignMessageErrorType,
    SignMessageVariables,
    context
  > & {
    signMessage: SignMessageMutate<context>
    signMessageAsync: SignMessageMutateAsync<context>
  }
>

/** https://wagmi.sh/react/api/hooks/useSignMessage */
export function useSignMessage<context = unknown>(
  parameters: UseSignMessageParameters<context> = {},
): UseSignMessageReturnType<context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = signMessageMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  return {
    ...result,
    signMessage: mutate,
    signMessageAsync: mutateAsync,
  }
}
</file>

<file path="packages/react/src/hooks/useSignTypedData.test-d.ts">
import type {
  SignTypedDataErrorType,
  SignTypedDataReturnType,
} from '@wagmi/core'
import type { SignTypedDataVariables } from '@wagmi/core/query'
import { typedData } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useSignTypedData } from './useSignTypedData.js'

const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, signTypedData, variables } = useSignTypedData({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toMatchTypeOf<SignTypedDataVariables>()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toMatchTypeOf<SignTypedDataVariables>()
        expectTypeOf(error).toEqualTypeOf<SignTypedDataErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toMatchTypeOf<SignTypedDataVariables>()
        expectTypeOf(data).toEqualTypeOf<SignTypedDataReturnType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<SignTypedDataReturnType | undefined>()
        expectTypeOf(error).toEqualTypeOf<SignTypedDataErrorType | null>()
        expectTypeOf(variables).toMatchTypeOf<SignTypedDataVariables>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<SignTypedDataReturnType | undefined>()
  expectTypeOf(error).toEqualTypeOf<SignTypedDataErrorType | null>()
  expectTypeOf(variables).toMatchTypeOf<SignTypedDataVariables | undefined>()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  signTypedData(
    {
      types: typedData.basic.types,
      primaryType: 'Person',
      message: {
        name: 'Bob',
        wallet: '0x',
      },
    },
    {
      onError(error, variables, context) {
        expectTypeOf(error).toEqualTypeOf<SignTypedDataErrorType>()
        expectTypeOf(variables).toMatchTypeOf<{
          types: typeof typedData.basic.types
          primaryType: 'Person'
          message: {
            name: string
            wallet: `0x${string}`
          }
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(data).toEqualTypeOf<SignTypedDataReturnType>()
        expectTypeOf(variables).toMatchTypeOf<{
          types: typeof typedData.basic.types
          primaryType: 'Person'
          message: {
            name: string
            wallet: `0x${string}`
          }
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<SignTypedDataReturnType | undefined>()
        expectTypeOf(error).toEqualTypeOf<SignTypedDataErrorType | null>()
        expectTypeOf(variables).toMatchTypeOf<{
          types: typeof typedData.basic.types
          primaryType: 'Person'
          message: {
            name: string
            wallet: `0x${string}`
          }
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useSignTypedData.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { SignTypedDataErrorType } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type SignTypedDataData,
  type SignTypedDataMutate,
  type SignTypedDataMutateAsync,
  type SignTypedDataVariables,
  signTypedDataMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseSignTypedDataParameters<context = unknown> = Compute<
  ConfigParameter & {
    mutation?:
      | UseMutationParameters<
          SignTypedDataData,
          SignTypedDataErrorType,
          SignTypedDataVariables,
          context
        >
      | undefined
  }
>

export type UseSignTypedDataReturnType<context = unknown> = Compute<
  UseMutationReturnType<
    SignTypedDataData,
    SignTypedDataErrorType,
    SignTypedDataVariables,
    context
  > & {
    signTypedData: SignTypedDataMutate<context>
    signTypedDataAsync: SignTypedDataMutateAsync<context>
  }
>

/** https://wagmi.sh/react/api/hooks/useSignTypedData */
export function useSignTypedData<context = unknown>(
  parameters: UseSignTypedDataParameters<context> = {},
): UseSignTypedDataReturnType<context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = signTypedDataMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseSignTypedDataReturnType<context>
  return {
    ...result,
    signTypedData: mutate as Return['signTypedData'],
    signTypedDataAsync: mutateAsync as Return['signTypedDataAsync'],
  }
}
</file>

<file path="packages/react/src/hooks/useSimulateContract.test-d.ts">
import { abi, type config } from '@wagmi/test'
import type { Address } from 'viem'
import { expectTypeOf, test } from 'vitest'

import {
  type UseSimulateContractParameters,
  type UseSimulateContractReturnType,
  useSimulateContract,
} from './useSimulateContract.js'

test('default', () => {
  const result = useSimulateContract({
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
  })

  expectTypeOf(result.data).toMatchTypeOf<
    | {
        result: boolean
        request: {
          chainId?: undefined
          abi: readonly [
            {
              readonly name: 'transferFrom'
              readonly type: 'function'
              readonly stateMutability: 'nonpayable'
              readonly inputs: readonly [
                { readonly type: 'address'; readonly name: 'sender' },
                { readonly type: 'address'; readonly name: 'recipient' },
                { readonly type: 'uint256'; readonly name: 'amount' },
              ]
              readonly outputs: readonly [{ type: 'bool' }]
            },
          ]
          functionName: 'transferFrom'
          args: readonly [Address, Address, bigint]
        }
      }
    | undefined
  >()
})

test('select data', () => {
  const result = useSimulateContract({
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
    query: {
      select(data) {
        expectTypeOf(data.result).toEqualTypeOf<boolean>()
        return data.request.args
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<
    readonly [Address, Address, bigint] | undefined
  >()
})

test('UseSimulateContractParameters', () => {
  type Result = UseSimulateContractParameters<typeof abi.erc20, 'transferFrom'>
  expectTypeOf<Result>().toMatchTypeOf<{
    functionName?: 'approve' | 'transfer' | 'transferFrom' | undefined
    args?: readonly [Address, Address, bigint] | undefined
  }>()
})

test('UseSimulateContractReturnType', () => {
  type Result = UseSimulateContractReturnType<
    typeof abi.erc20,
    'transferFrom',
    ['0x', '0x', 123n],
    typeof config,
    1
  >
  expectTypeOf<Result['data']>().toMatchTypeOf<
    | {
        result: boolean
        request: {
          chainId: number
          abi: readonly [
            {
              readonly name: 'transferFrom'
              readonly type: 'function'
              readonly stateMutability: 'nonpayable'
              readonly inputs: readonly [
                { readonly type: 'address'; readonly name: 'sender' },
                { readonly type: 'address'; readonly name: 'recipient' },
                { readonly type: 'uint256'; readonly name: 'amount' },
              ]
              readonly outputs: readonly [{ type: 'bool' }]
            },
          ]
          functionName: 'approve' | 'transfer' | 'transferFrom'
          args: readonly [Address, Address, bigint]
        }
      }
    | undefined
  >()
})
</file>

<file path="packages/react/src/hooks/useSimulateContract.ts">
'use client'

import type {
  Config,
  ResolvedRegister,
  SimulateContractErrorType,
} from '@wagmi/core'
import {
  type SimulateContractData,
  type SimulateContractOptions,
  type SimulateContractQueryFnData,
  type SimulateContractQueryKey,
  simulateContractQueryOptions,
} from '@wagmi/core/query'
import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'
import { useConnectorClient } from './useConnectorClient.js'

export type UseSimulateContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'nonpayable' | 'payable'
  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = SimulateContractData<abi, functionName, args, config, chainId>,
> = SimulateContractOptions<abi, functionName, args, config, chainId> &
  ConfigParameter<config> &
  QueryParameter<
    SimulateContractQueryFnData<abi, functionName, args, config, chainId>,
    SimulateContractErrorType,
    selectData,
    SimulateContractQueryKey<abi, functionName, args, config, chainId>
  >

export type UseSimulateContractReturnType<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'nonpayable' | 'payable'
  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = SimulateContractData<abi, functionName, args, config, chainId>,
> = UseQueryReturnType<selectData, SimulateContractErrorType>

/** https://wagmi.sh/react/api/hooks/useSimulateContract */
export function useSimulateContract<
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = SimulateContractData<abi, functionName, args, config, chainId>,
>(
  parameters: UseSimulateContractParameters<
    abi,
    functionName,
    args,
    config,
    chainId,
    selectData
  > = {} as any,
): UseSimulateContractReturnType<
  abi,
  functionName,
  args,
  config,
  chainId,
  selectData
> {
  const { abi, address, connector, functionName, query = {} } = parameters

  const config = useConfig(parameters)
  const { data: connectorClient } = useConnectorClient({
    config,
    connector,
    query: { enabled: parameters.account === undefined },
  })
  const chainId = useChainId({ config })

  const options = simulateContractQueryOptions<
    config,
    abi,
    functionName,
    args,
    chainId
  >(config, {
    ...parameters,
    account: parameters.account ?? connectorClient?.account,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(
    abi && address && functionName && (query.enabled ?? true),
  )

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useStorageAt.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import type { Hex } from 'viem'
import { useStorageAt } from './useStorageAt.js'

test('select data', () => {
  const result = useStorageAt({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<Hex | undefined>()
})
</file>

<file path="packages/react/src/hooks/useStorageAt.ts">
'use client'

import type {
  Config,
  GetStorageAtErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetStorageAtData,
  type GetStorageAtOptions,
  type GetStorageAtQueryKey,
  getStorageAtQueryOptions,
} from '@wagmi/core/query'
import type { GetStorageAtQueryFnData } from '@wagmi/core/query'
import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseStorageAtParameters<
  config extends Config = Config,
  selectData = GetStorageAtData,
> = Compute<
  GetStorageAtOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetStorageAtQueryFnData,
      GetStorageAtErrorType,
      selectData,
      GetStorageAtQueryKey<config>
    >
>

export type UseStorageAtReturnType<selectData = GetStorageAtData> =
  UseQueryReturnType<selectData, GetStorageAtErrorType>

/** https://wagmi.sh/react/api/hooks/useStorageAt */
export function useStorageAt<
  config extends Config = ResolvedRegister['config'],
  selectData = GetStorageAtData,
>(
  parameters: UseStorageAtParameters<config, selectData> = {},
): UseStorageAtReturnType<selectData> {
  const { address, slot, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getStorageAtQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && slot && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useSwitchAccount.test-d.ts">
import type { Connector, SwitchAccountErrorType } from '@wagmi/core'
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import type { Address } from 'viem'
import { useSwitchAccount } from './useSwitchAccount.js'

const connector = config.connectors[0]!
const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, switchAccount, variables } = useSwitchAccount({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        expectTypeOf(error).toEqualTypeOf<SwitchAccountErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        expectTypeOf(data).toEqualTypeOf<{
          accounts: readonly [Address, ...Address[]]
          chainId: number
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<
          | {
              accounts: readonly [Address, ...Address[]]
              chainId: number
            }
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<SwitchAccountErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<
    | {
        accounts: readonly [Address, ...Address[]]
        chainId: number
      }
    | undefined
  >()
  expectTypeOf(error).toEqualTypeOf<SwitchAccountErrorType | null>()
  expectTypeOf(variables).toEqualTypeOf<{ connector: Connector } | undefined>()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  switchAccount(
    { connector },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        expectTypeOf(error).toEqualTypeOf<SwitchAccountErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        expectTypeOf(data).toEqualTypeOf<{
          accounts: readonly [Address, ...Address[]]
          chainId: number
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<
          | {
              accounts: readonly [Address, ...Address[]]
              chainId: number
            }
          | undefined
        >()
        expectTypeOf(error).toEqualTypeOf<SwitchAccountErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<{ connector: Connector }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useSwitchAccount.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type {
  Config,
  Connector,
  ResolvedRegister,
  SwitchAccountErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type SwitchAccountData,
  type SwitchAccountMutate,
  type SwitchAccountMutateAsync,
  type SwitchAccountVariables,
  switchAccountMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'
import { useConnections } from './useConnections.js'

export type UseSwitchAccountParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          SwitchAccountData<config>,
          SwitchAccountErrorType,
          SwitchAccountVariables,
          context
        >
      | undefined
  }
>

export type UseSwitchAccountReturnType<
  config extends Config = Config,
  context = unknown,
> = Compute<
  UseMutationReturnType<
    SwitchAccountData<config>,
    SwitchAccountErrorType,
    SwitchAccountVariables,
    context
  > & {
    connectors: readonly Connector[]
    switchAccount: SwitchAccountMutate<config, context>
    switchAccountAsync: SwitchAccountMutateAsync<config, context>
  }
>

/** https://wagmi.sh/react/api/hooks/useSwitchAccount */
export function useSwitchAccount<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseSwitchAccountParameters<config, context> = {},
): UseSwitchAccountReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = switchAccountMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  return {
    ...result,
    connectors: useConnections({ config }).map(
      (connection) => connection.connector,
    ),
    switchAccount: mutate,
    switchAccountAsync: mutateAsync,
  }
}
</file>

<file path="packages/react/src/hooks/useSwitchChain.test-d.ts">
import type { Connector, SwitchChainErrorType } from '@wagmi/core'
import type { Chain } from '@wagmi/core/chains'
import type { Compute, ExactPartial } from '@wagmi/core/internal'
import { chain } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import type { AddEthereumChainParameter } from 'viem'
import { useSwitchChain } from './useSwitchChain.js'

const chainId = chain.mainnet.id
const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { chains, context, data, error, switchChain, variables } =
    useSwitchChain({
      mutation: {
        onMutate(variables) {
          expectTypeOf(variables).toEqualTypeOf<{
            addEthereumChainParameter?:
              | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
              | undefined
            chainId: number
            connector?: Connector | undefined
          }>()
          return contextValue
        },
        onError(error, variables, context) {
          expectTypeOf(variables).toEqualTypeOf<{
            addEthereumChainParameter?:
              | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
              | undefined
            chainId: number
            connector?: Connector | undefined
          }>()
          expectTypeOf(error).toEqualTypeOf<SwitchChainErrorType>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
        },
        onSuccess(data, variables, context) {
          expectTypeOf(variables).toEqualTypeOf<{
            addEthereumChainParameter?:
              | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
              | undefined
            chainId: number
            connector?: Connector | undefined
          }>()
          expectTypeOf(data).toEqualTypeOf<Compute<Chain>>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
        },
        onSettled(data, error, variables, context) {
          expectTypeOf(data).toEqualTypeOf<Compute<Chain> | undefined>()
          expectTypeOf(error).toEqualTypeOf<SwitchChainErrorType | null>()
          expectTypeOf(variables).toEqualTypeOf<{
            addEthereumChainParameter?:
              | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
              | undefined
            chainId: number
            connector?: Connector | undefined
          }>()
          expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
        },
      },
    })

  expectTypeOf(chains).toEqualTypeOf<readonly [Chain, ...Chain[]]>()
  expectTypeOf(data).toEqualTypeOf<Compute<Chain> | undefined>()
  expectTypeOf(error).toEqualTypeOf<SwitchChainErrorType | null>()
  expectTypeOf(variables).toEqualTypeOf<
    | {
        addEthereumChainParameter?:
          | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
          | undefined
        chainId: number
        connector?: Connector | undefined
      }
    | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  switchChain(
    { chainId },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{
          addEthereumChainParameter?:
            | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
            | undefined
          chainId: number
          connector?: Connector | undefined
        }>()
        expectTypeOf(error).toEqualTypeOf<SwitchChainErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<{
          addEthereumChainParameter?:
            | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
            | undefined
          chainId: number
          connector?: Connector | undefined
        }>()
        expectTypeOf(data).toEqualTypeOf<Compute<Chain>>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Compute<Chain> | undefined>()
        expectTypeOf(error).toEqualTypeOf<SwitchChainErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<{
          addEthereumChainParameter?:
            | ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>>
            | undefined
          chainId: number
          connector?: Connector | undefined
        }>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useSwitchChain.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type {
  Config,
  ResolvedRegister,
  SwitchChainErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type SwitchChainData,
  type SwitchChainMutate,
  type SwitchChainMutateAsync,
  type SwitchChainVariables,
  switchChainMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useChains } from './useChains.js'
import { useConfig } from './useConfig.js'

export type UseSwitchChainParameters<
  config extends Config = Config,
  context = unknown,
> = Compute<
  ConfigParameter<config> & {
    mutation?:
      | UseMutationParameters<
          SwitchChainData<config, config['chains'][number]['id']>,
          SwitchChainErrorType,
          SwitchChainVariables<config, config['chains'][number]['id']>,
          context
        >
      | undefined
  }
>

export type UseSwitchChainReturnType<
  config extends Config = Config,
  context = unknown,
> = Compute<
  UseMutationReturnType<
    SwitchChainData<config, config['chains'][number]['id']>,
    SwitchChainErrorType,
    SwitchChainVariables<config, config['chains'][number]['id']>,
    context
  > & {
    chains: config['chains']
    switchChain: SwitchChainMutate<config, context>
    switchChainAsync: SwitchChainMutateAsync<config, context>
  }
>

/** https://wagmi.sh/react/api/hooks/useSwitchChain */
export function useSwitchChain<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseSwitchChainParameters<config, context> = {},
): UseSwitchChainReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = switchChainMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseSwitchChainReturnType<config, context>
  return {
    ...result,
    chains: useChains({ config }) as unknown as config['chains'],
    switchChain: mutate as Return['switchChain'],
    switchChainAsync: mutateAsync as Return['switchChainAsync'],
  }
}
</file>

<file path="packages/react/src/hooks/useSyncExternalStoreWithTracked.ts">
'use client'

import { deepEqual } from '@wagmi/core/internal'
import { useMemo, useRef } from 'react'
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'

const isPlainObject = (obj: unknown) =>
  typeof obj === 'object' && !Array.isArray(obj)

export function useSyncExternalStoreWithTracked<
  snapshot extends selection,
  selection = snapshot,
>(
  subscribe: (onStoreChange: () => void) => () => void,
  getSnapshot: () => snapshot,
  getServerSnapshot: undefined | null | (() => snapshot) = getSnapshot,
  isEqual: (a: selection, b: selection) => boolean = deepEqual,
) {
  const trackedKeys = useRef<string[]>([])
  const result = useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    (x) => x,
    (a, b) => {
      if (isPlainObject(a) && isPlainObject(b) && trackedKeys.current.length) {
        for (const key of trackedKeys.current) {
          const equal = isEqual(
            (a as { [_a: string]: any })[key],
            (b as { [_b: string]: any })[key],
          )
          if (!equal) return false
        }
        return true
      }
      return isEqual(a, b)
    },
  )

  return useMemo(() => {
    if (isPlainObject(result)) {
      const trackedResult = { ...result }
      let properties = {}
      for (const [key, value] of Object.entries(
        trackedResult as { [key: string]: any },
      )) {
        properties = {
          ...properties,
          [key]: {
            configurable: false,
            enumerable: true,
            get: () => {
              if (!trackedKeys.current.includes(key)) {
                trackedKeys.current.push(key)
              }
              return value
            },
          },
        }
      }
      Object.defineProperties(trackedResult, properties)
      return trackedResult
    }

    return result
  }, [result])
}
</file>

<file path="packages/react/src/hooks/useToken.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useToken } from './useToken.js'

test('select data', () => {
  const result = useToken({
    query: {
      select(data) {
        return data?.name
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<string | undefined>()
})
</file>

<file path="packages/react/src/hooks/useToken.ts">
'use client'

import type { Config, GetTokenErrorType, ResolvedRegister } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetTokenData,
  type GetTokenOptions,
  type GetTokenQueryFnData,
  type GetTokenQueryKey,
  getTokenQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseTokenParameters<
  config extends Config = Config,
  selectData = GetTokenData,
> = Compute<
  GetTokenOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetTokenQueryFnData,
      GetTokenErrorType,
      selectData,
      GetTokenQueryKey<config>
    >
>

export type UseTokenReturnType<selectData = GetTokenData> = UseQueryReturnType<
  selectData,
  GetTokenErrorType
>

/**
 * @deprecated
 *
 * https://wagmi.sh/react/api/hooks/useToken
 */
export function useToken<
  config extends Config = ResolvedRegister['config'],
  selectData = GetTokenData,
>(
  parameters: UseTokenParameters<config, selectData> = {},
): UseTokenReturnType<selectData> {
  const { address, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getTokenQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useTransaction.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useTransaction } from './useTransaction.js'

test('select data', () => {
  const result = useTransaction({
    query: {
      select(data) {
        return data?.nonce
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<number | undefined>()
})
</file>

<file path="packages/react/src/hooks/useTransaction.ts">
'use client'

import type {
  Config,
  GetTransactionErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetTransactionData,
  type GetTransactionOptions,
  type GetTransactionQueryFnData,
  type GetTransactionQueryKey,
  getTransactionQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseTransactionParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetTransactionData<config, chainId>,
> = Compute<
  GetTransactionOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetTransactionQueryFnData<config, chainId>,
      GetTransactionErrorType,
      selectData,
      GetTransactionQueryKey<config, chainId>
    >
>

export type UseTransactionReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetTransactionData<config, chainId>,
> = UseQueryReturnType<selectData, GetTransactionErrorType>

/** https://wagmi.sh/react/api/hooks/useTransaction */
export function useTransaction<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetTransactionData<config, chainId>,
>(
  parameters: UseTransactionParameters<config, chainId, selectData> = {},
): UseTransactionReturnType<config, chainId, selectData> {
  const { blockHash, blockNumber, blockTag, hash, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getTransactionQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(
    !(blockHash && blockNumber && blockTag && hash) && (query.enabled ?? true),
  )

  return useQuery({
    ...(query as any),
    ...options,
    enabled,
  }) as UseTransactionReturnType<config, chainId, selectData>
}
</file>

<file path="packages/react/src/hooks/useTransactionConfirmations.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useTransactionConfirmations } from './useTransactionConfirmations.js'

test('select data', () => {
  const result = useTransactionConfirmations({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})
</file>

<file path="packages/react/src/hooks/useTransactionConfirmations.ts">
'use client'

import type {
  Config,
  GetTransactionConfirmationsErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import {
  type GetTransactionConfirmationsData,
  type GetTransactionConfirmationsOptions,
  type GetTransactionConfirmationsQueryFnData,
  type GetTransactionConfirmationsQueryKey,
  getTransactionConfirmationsQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseTransactionConfirmationsParameters<
  config extends Config = Config,
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = GetTransactionConfirmationsData,
> = GetTransactionConfirmationsOptions<config, chainId> &
  ConfigParameter<config> &
  QueryParameter<
    GetTransactionConfirmationsQueryFnData,
    GetTransactionConfirmationsErrorType,
    selectData,
    GetTransactionConfirmationsQueryKey<config, chainId>
  >

export type UseTransactionConfirmationsReturnType<
  selectData = GetTransactionConfirmationsData,
> = UseQueryReturnType<selectData, GetTransactionConfirmationsErrorType>

/** https://wagmi.sh/react/api/hooks/useTransactionConfirmations */
export function useTransactionConfirmations<
  config extends Config = ResolvedRegister['config'],
  chainId extends config['chains'][number]['id'] | undefined = undefined,
  selectData = GetTransactionConfirmationsData,
>(
  parameters: UseTransactionConfirmationsParameters<
    config,
    chainId,
    selectData
  > = {} as any,
): UseTransactionConfirmationsReturnType<selectData> {
  const { hash, transactionReceipt, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getTransactionConfirmationsQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(
    !(hash && transactionReceipt) &&
      (hash || transactionReceipt) &&
      (query.enabled ?? true),
  )

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useTransactionCount.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useTransactionCount } from './useTransactionCount.js'

test('select data', () => {
  const result = useTransactionCount({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<number | undefined>()
})
</file>

<file path="packages/react/src/hooks/useTransactionCount.ts">
'use client'

import type {
  Config,
  GetTransactionCountErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import type { GetTransactionCountQueryFnData } from '@wagmi/core/query'
import {
  type GetTransactionCountData,
  type GetTransactionCountOptions,
  type GetTransactionCountQueryKey,
  getTransactionCountQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseTransactionCountParameters<
  config extends Config = Config,
  selectData = GetTransactionCountData,
> = Compute<
  GetTransactionCountOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      GetTransactionCountQueryFnData,
      GetTransactionCountErrorType,
      selectData,
      GetTransactionCountQueryKey<config>
    >
>

export type UseTransactionCountReturnType<
  selectData = GetTransactionCountData,
> = UseQueryReturnType<selectData, GetTransactionCountErrorType>

/** https://wagmi.sh/react/api/hooks/useTransactionCount */
export function useTransactionCount<
  config extends Config = ResolvedRegister['config'],
  selectData = GetTransactionCountData,
>(
  parameters: UseTransactionCountParameters<config, selectData> = {},
): UseTransactionCountReturnType<selectData> {
  const { address, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getTransactionCountQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(address && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useTransactionReceipt.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useTransactionReceipt } from './useTransactionReceipt.js'

test('select data', () => {
  const result = useTransactionReceipt({
    query: {
      select(data) {
        return data?.blockNumber
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})
</file>

<file path="packages/react/src/hooks/useTransactionReceipt.ts">
'use client'

import type {
  Config,
  GetTransactionReceiptErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type GetTransactionReceiptData,
  type GetTransactionReceiptOptions,
  type GetTransactionReceiptQueryKey,
  getTransactionReceiptQueryOptions,
} from '@wagmi/core/query'
import type { GetTransactionReceiptQueryFnData } from '@wagmi/core/query'
import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseTransactionReceiptParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetTransactionReceiptData<config, chainId>,
> = Compute<
  GetTransactionReceiptOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      GetTransactionReceiptQueryFnData<config, chainId>,
      GetTransactionReceiptErrorType,
      selectData,
      GetTransactionReceiptQueryKey<config, chainId>
    >
>

export type UseTransactionReceiptReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetTransactionReceiptData<config, chainId>,
> = UseQueryReturnType<selectData, GetTransactionReceiptErrorType>

/** https://wagmi.sh/react/api/hooks/useTransactionReceipt */
export function useTransactionReceipt<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetTransactionReceiptData<config, chainId>,
>(
  parameters: UseTransactionReceiptParameters<config, chainId, selectData> = {},
): UseTransactionReceiptReturnType<config, chainId, selectData> {
  const { hash, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = getTransactionReceiptQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(hash && (query.enabled ?? true))

  return useQuery({
    ...(query as any),
    ...options,
    enabled,
  }) as UseTransactionReceiptReturnType<config, chainId, selectData>
}
</file>

<file path="packages/react/src/hooks/useVerifyMessage.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useVerifyMessage } from './useVerifyMessage.js'

test('select data', () => {
  const result = useVerifyMessage({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<boolean | undefined>()
})
</file>

<file path="packages/react/src/hooks/useVerifyMessage.ts">
'use client'

import type {
  Config,
  ResolvedRegister,
  VerifyMessageErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type VerifyMessageData,
  type VerifyMessageOptions,
  type VerifyMessageQueryKey,
  verifyMessageQueryOptions,
} from '@wagmi/core/query'
import type { VerifyMessageQueryFnData } from '@wagmi/core/query'
import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseVerifyMessageParameters<
  config extends Config = Config,
  selectData = VerifyMessageData,
> = Compute<
  VerifyMessageOptions<config> &
    ConfigParameter<config> &
    QueryParameter<
      VerifyMessageQueryFnData,
      VerifyMessageErrorType,
      selectData,
      VerifyMessageQueryKey<config>
    >
>

export type UseVerifyMessageReturnType<selectData = VerifyMessageData> =
  UseQueryReturnType<selectData, VerifyMessageErrorType>

/** https://wagmi.sh/react/api/hooks/useVerifyMessage */
export function useVerifyMessage<
  config extends Config = ResolvedRegister['config'],
  selectData = VerifyMessageData,
>(
  parameters: UseVerifyMessageParameters<config, selectData> = {},
): UseVerifyMessageReturnType<selectData> {
  const { address, message, signature, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = verifyMessageQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(
    address && message && signature && (query.enabled ?? true),
  )

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useVerifyTypedData.test-d.ts">
import type { typedData } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import type { Address } from 'viem'
import {
  type UseVerifyTypedDataParameters,
  useVerifyTypedData,
} from './useVerifyTypedData.js'

test('select data', () => {
  const result = useVerifyTypedData({
    query: {
      select(data) {
        return data
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<boolean | undefined>()
})

test('UseReadContractParameters', () => {
  type Result = UseVerifyTypedDataParameters<
    typeof typedData.basic.types,
    'Mail'
  >
  expectTypeOf<Pick<Result, 'message' | 'primaryType'>>().toEqualTypeOf<{
    primaryType?: 'Mail' | 'Person'
    message?: {
      from: {
        name: string
        wallet: Address
      }
      to: {
        name: string
        wallet: Address
      }
      contents: string
    }
  }>()
})
</file>

<file path="packages/react/src/hooks/useVerifyTypedData.ts">
'use client'

import type {
  Config,
  ResolvedRegister,
  VerifyTypedDataErrorType,
} from '@wagmi/core'
import {
  type VerifyTypedDataData,
  type VerifyTypedDataOptions,
  type VerifyTypedDataQueryKey,
  verifyTypedDataQueryOptions,
} from '@wagmi/core/query'
import type { VerifyTypedDataQueryFnData } from '@wagmi/core/query'
import type { TypedData } from 'viem'
import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseVerifyTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  config extends Config = Config,
  selectData = VerifyTypedDataData,
> = VerifyTypedDataOptions<typedData, primaryType, config> &
  ConfigParameter<config> &
  QueryParameter<
    VerifyTypedDataQueryFnData,
    VerifyTypedDataErrorType,
    selectData,
    VerifyTypedDataQueryKey<typedData, primaryType, config>
  >

export type UseVerifyTypedDataReturnType<selectData = VerifyTypedDataData> =
  UseQueryReturnType<selectData, VerifyTypedDataErrorType>

/** https://wagmi.sh/react/api/hooks/useVerifyTypedData */
export function useVerifyTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
  config extends Config = ResolvedRegister['config'],
  selectData = VerifyTypedDataData,
>(
  parameters: UseVerifyTypedDataParameters<
    typedData,
    primaryType,
    config,
    selectData
  > = {} as any,
): UseVerifyTypedDataReturnType<selectData> {
  const {
    address,
    message,
    primaryType,
    signature,
    types,
    query = {},
  } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = verifyTypedDataQueryOptions<config, typedData, primaryType>(
    config,
    {
      ...parameters,
      chainId: parameters.chainId ?? chainId,
    },
  )
  const enabled = Boolean(
    address &&
      message &&
      primaryType &&
      signature &&
      types &&
      (query.enabled ?? true),
  )

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useWaitForCallsStatus.ts">
'use client'

import type {
  Config,
  ResolvedRegister,
  WaitForCallsStatusErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type WaitForCallsStatusData,
  type WaitForCallsStatusOptions,
  type WaitForCallsStatusQueryFnData,
  type WaitForCallsStatusQueryKey,
  waitForCallsStatusQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseWaitForCallsStatusParameters<
  config extends Config = Config,
  selectData = WaitForCallsStatusData,
> = Compute<
  WaitForCallsStatusOptions &
    ConfigParameter<config> &
    QueryParameter<
      WaitForCallsStatusQueryFnData,
      WaitForCallsStatusErrorType,
      selectData,
      WaitForCallsStatusQueryKey
    >
>

export type UseWaitForCallsStatusReturnType<
  selectData = WaitForCallsStatusData,
> = UseQueryReturnType<selectData, WaitForCallsStatusErrorType>

/** https://wagmi.sh/react/api/hooks/useWaitForCallsStatus */
export function useWaitForCallsStatus<
  config extends Config = ResolvedRegister['config'],
  selectData = WaitForCallsStatusData,
>(
  parameters: UseWaitForCallsStatusParameters<config, selectData>,
): UseWaitForCallsStatusReturnType<selectData> {
  const { id, query = {} } = parameters

  const config = useConfig(parameters)

  const options = waitForCallsStatusQueryOptions(config, parameters)
  const enabled = Boolean(id && (query.enabled ?? true))

  return useQuery({ ...query, ...options, enabled })
}
</file>

<file path="packages/react/src/hooks/useWaitForTransactionReceipt.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { useWaitForTransactionReceipt } from './useWaitForTransactionReceipt.js'

test('select data', () => {
  const result = useWaitForTransactionReceipt({
    query: {
      select(data) {
        return data?.blockNumber
      },
    },
  })
  expectTypeOf(result.data).toEqualTypeOf<bigint | undefined>()
})
</file>

<file path="packages/react/src/hooks/useWaitForTransactionReceipt.ts">
'use client'

import type {
  Config,
  ResolvedRegister,
  WaitForTransactionReceiptErrorType,
} from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type WaitForTransactionReceiptData,
  type WaitForTransactionReceiptOptions,
  type WaitForTransactionReceiptQueryFnData,
  type WaitForTransactionReceiptQueryKey,
  waitForTransactionReceiptQueryOptions,
} from '@wagmi/core/query'

import type { ConfigParameter, QueryParameter } from '../types/properties.js'
import { type UseQueryReturnType, useQuery } from '../utils/query.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseWaitForTransactionReceiptParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = WaitForTransactionReceiptData<config, chainId>,
> = Compute<
  WaitForTransactionReceiptOptions<config, chainId> &
    ConfigParameter<config> &
    QueryParameter<
      WaitForTransactionReceiptQueryFnData<config, chainId>,
      WaitForTransactionReceiptErrorType,
      selectData,
      WaitForTransactionReceiptQueryKey<config, chainId>
    >
>

export type UseWaitForTransactionReceiptReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = WaitForTransactionReceiptData<config, chainId>,
> = UseQueryReturnType<selectData, WaitForTransactionReceiptErrorType>

/** https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt */
export function useWaitForTransactionReceipt<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = WaitForTransactionReceiptData<config, chainId>,
>(
  parameters: UseWaitForTransactionReceiptParameters<
    config,
    chainId,
    selectData
  > = {},
): UseWaitForTransactionReceiptReturnType<config, chainId, selectData> {
  const { hash, query = {} } = parameters

  const config = useConfig(parameters)
  const chainId = useChainId({ config })

  const options = waitForTransactionReceiptQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
  })
  const enabled = Boolean(hash && (query.enabled ?? true))

  return useQuery({
    ...(query as any),
    ...options,
    enabled,
  }) as UseWaitForTransactionReceiptReturnType<config, chainId, selectData>
}
</file>

<file path="packages/react/src/hooks/useWalletClient.test-d.ts">
import { config } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import { useWalletClient } from './useWalletClient.js'

test('parameters: config', async () => {
  const client = useWalletClient({ config })
  expectTypeOf(client.data?.chain?.id!).toEqualTypeOf<1 | 456 | 10>()

  const client2 = useWalletClient({ config, chainId: 1 })
  expectTypeOf(client2.data?.chain?.id!).toEqualTypeOf<1>()
})
</file>

<file path="packages/react/src/hooks/useWalletClient.ts">
'use client'

// Almost identical implementation to `useConnectorClient` (except for return type)
// Should update both in tandem

import { useQueryClient } from '@tanstack/react-query'
import type {
  Config,
  GetWalletClientErrorType,
  ResolvedRegister,
} from '@wagmi/core'
import type { Compute, Omit } from '@wagmi/core/internal'
import {
  type GetWalletClientData,
  type GetWalletClientOptions,
  type GetWalletClientQueryFnData,
  type GetWalletClientQueryKey,
  getWalletClientQueryOptions,
} from '@wagmi/core/query'
import { useEffect, useRef } from 'react'

import type { ConfigParameter } from '../types/properties.js'
import {
  type UseQueryParameters,
  type UseQueryReturnType,
  useQuery,
} from '../utils/query.js'
import { useAccount } from './useAccount.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseWalletClientParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetWalletClientData<config, chainId>,
> = Compute<
  GetWalletClientOptions<config, chainId> &
    ConfigParameter<config> & {
      query?:
        | Compute<
            Omit<
              UseQueryParameters<
                GetWalletClientQueryFnData<config, chainId>,
                GetWalletClientErrorType,
                selectData,
                GetWalletClientQueryKey<config, chainId>
              >,
              'gcTime' | 'staleTime'
            >
          >
        | undefined
    }
>

export type UseWalletClientReturnType<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetWalletClientData<config, chainId>,
> = UseQueryReturnType<selectData, GetWalletClientErrorType>

/** https://wagmi.sh/react/api/hooks/useWalletClient */
export function useWalletClient<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  selectData = GetWalletClientData<config, chainId>,
>(
  parameters: UseWalletClientParameters<config, chainId, selectData> = {},
): UseWalletClientReturnType<config, chainId, selectData> {
  const { query = {}, ...rest } = parameters

  const config = useConfig(rest)
  const queryClient = useQueryClient()
  const { address, connector, status } = useAccount({ config })
  const chainId = useChainId({ config })
  const activeConnector = parameters.connector ?? connector

  const { queryKey, ...options } = getWalletClientQueryOptions<config, chainId>(
    config,
    {
      ...parameters,
      chainId: parameters.chainId ?? chainId,
      connector: parameters.connector ?? connector,
    },
  )
  const enabled = Boolean(
    (status === 'connected' ||
      (status === 'reconnecting' && activeConnector?.getProvider)) &&
      (query.enabled ?? true),
  )

  const addressRef = useRef(address)
  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required
  useEffect(() => {
    const previousAddress = addressRef.current
    if (!address && previousAddress) {
      // remove when account is disconnected
      queryClient.removeQueries({ queryKey })
      addressRef.current = undefined
    } else if (address !== previousAddress) {
      // invalidate when address changes
      queryClient.invalidateQueries({ queryKey })
      addressRef.current = address
    }
  }, [address, queryClient])

  return useQuery({
    ...query,
    ...options,
    queryKey,
    enabled,
    staleTime: Number.POSITIVE_INFINITY,
  } as any) as UseWalletClientReturnType<config, chainId, selectData>
}
</file>

<file path="packages/react/src/hooks/useWatchAsset.test-d.ts">
import type { WatchAssetErrorType } from '@wagmi/core'
import type { WatchAssetVariables } from '@wagmi/core/query'
import { expectTypeOf, test } from 'vitest'

import { useWatchAsset } from './useWatchAsset.js'

const tokenInfo = {
  address: '0x0000000000000000000000000000000000000000',
  symbol: 'NULL',
  decimals: 18,
}
const contextValue = { foo: 'bar' } as const

test('context', () => {
  const { context, data, error, watchAsset, variables } = useWatchAsset({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        expectTypeOf(error).toEqualTypeOf<WatchAssetErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        expectTypeOf(data).toEqualTypeOf<boolean>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<boolean | undefined>()
        expectTypeOf(error).toEqualTypeOf<WatchAssetErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<boolean | undefined>()
  expectTypeOf(error).toEqualTypeOf<WatchAssetErrorType | null>()
  expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables | undefined>()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  watchAsset(
    { type: 'ERC20', options: tokenInfo },
    {
      onError(error, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        expectTypeOf(error).toEqualTypeOf<WatchAssetErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        expectTypeOf(data).toEqualTypeOf<boolean>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<boolean | undefined>()
        expectTypeOf(error).toEqualTypeOf<WatchAssetErrorType | null>()
        expectTypeOf(variables).toEqualTypeOf<WatchAssetVariables>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()
      },
    },
  )
})
</file>

<file path="packages/react/src/hooks/useWatchAsset.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type { WatchAssetErrorType } from '@wagmi/core'
import type { Compute } from '@wagmi/core/internal'
import {
  type WatchAssetData,
  type WatchAssetMutate,
  type WatchAssetMutateAsync,
  type WatchAssetVariables,
  watchAssetMutationOptions,
} from '@wagmi/core/query'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseWatchAssetParameters<context = unknown> = Compute<
  ConfigParameter & {
    mutation?:
      | UseMutationParameters<
          WatchAssetData,
          WatchAssetErrorType,
          WatchAssetVariables,
          context
        >
      | undefined
  }
>

export type UseWatchAssetReturnType<context = unknown> = Compute<
  UseMutationReturnType<
    WatchAssetData,
    WatchAssetErrorType,
    WatchAssetVariables,
    context
  > & {
    watchAsset: WatchAssetMutate<context>
    watchAssetAsync: WatchAssetMutateAsync<context>
  }
>

/** https://wagmi.sh/react/api/hooks/useWatchAsset */
export function useWatchAsset<context = unknown>(
  parameters: UseWatchAssetParameters<context> = {},
): UseWatchAssetReturnType<context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = watchAssetMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  return {
    ...result,
    watchAsset: mutate,
    watchAssetAsync: mutateAsync,
  }
}
</file>

<file path="packages/react/src/hooks/useWatchBlockNumber.test-d.ts">
import { createConfig } from '@wagmi/core'
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import {
  type UseWatchBlockNumberParameters,
  useWatchBlockNumber,
} from './useWatchBlockNumber.js'

test('default', () => {
  useWatchBlockNumber({
    poll: false,
    onBlockNumber() {},
  })
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = UseWatchBlockNumberParameters<
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchBlockNumber({
    config,
    poll: false,
    onBlockNumber() {},
  })

  type Result2 = UseWatchBlockNumberParameters<typeof config, typeof mainnet.id>
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  useWatchBlockNumber({
    config,
    chainId: mainnet.id,
    poll: true,
    onBlockNumber() {},
  })
  useWatchBlockNumber({
    config,
    chainId: mainnet.id,
    // @ts-expect-error
    poll: false,
    onBlockNumber() {},
  })

  type Result3 = UseWatchBlockNumberParameters<
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchBlockNumber({
    config,
    chainId: optimism.id,
    poll: true,
    onBlockNumber() {},
  })
  useWatchBlockNumber({
    config,
    chainId: optimism.id,
    poll: false,
    onBlockNumber() {},
  })
})
</file>

<file path="packages/react/src/hooks/useWatchBlockNumber.ts">
'use client'

import {
  type Config,
  type ResolvedRegister,
  type WatchBlockNumberParameters,
  watchBlockNumber,
} from '@wagmi/core'
import type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'
import { useEffect } from 'react'

import type { ConfigParameter, EnabledParameter } from '../types/properties.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseWatchBlockNumberParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = UnionCompute<
  UnionExactPartial<WatchBlockNumberParameters<config, chainId>> &
    ConfigParameter<config> &
    EnabledParameter
>

export type UseWatchBlockNumberReturnType = void

/** https://wagmi.sh/react/api/hooks/useWatchBlockNumber */
export function useWatchBlockNumber<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  parameters: UseWatchBlockNumberParameters<config, chainId> = {} as any,
): UseWatchBlockNumberReturnType {
  const { enabled = true, onBlockNumber, config: _, ...rest } = parameters

  const config = useConfig(parameters)
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  // TODO(react@19): cleanup
  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array
  useEffect(() => {
    if (!enabled) return
    if (!onBlockNumber) return
    return watchBlockNumber(config, {
      ...(rest as any),
      chainId,
      onBlockNumber,
    })
  }, [
    chainId,
    config,
    enabled,
    onBlockNumber,
    ///
    rest.onError,
    rest.emitMissed,
    rest.emitOnBegin,
    rest.poll,
    rest.pollingInterval,
    rest.syncConnectedChain,
  ])
}
</file>

<file path="packages/react/src/hooks/useWatchBlocks.test-d.ts">
import { createConfig } from '@wagmi/core'
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import {
  type UseWatchBlocksParameters,
  useWatchBlocks,
} from './useWatchBlocks.js'

test('default', () => {
  useWatchBlocks({
    poll: false,
    onBlock() {},
  })
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = UseWatchBlocksParameters<
    false,
    'latest',
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchBlocks({
    config,
    poll: false,
    onBlock() {},
  })

  type Result2 = UseWatchBlocksParameters<
    false,
    'latest',
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  useWatchBlocks({
    config,
    chainId: mainnet.id,
    poll: true,
    onBlock() {},
  })

  type Result3 = UseWatchBlocksParameters<
    false,
    'latest',
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchBlocks({
    config,
    chainId: optimism.id,
    poll: true,
    onBlock() {},
  })
  useWatchBlocks({
    config,
    chainId: optimism.id,
    poll: false,
    onBlock() {},
  })
})
</file>

<file path="packages/react/src/hooks/useWatchBlocks.ts">
'use client'

import {
  type Config,
  type ResolvedRegister,
  type WatchBlocksParameters,
  watchBlocks,
} from '@wagmi/core'
import type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'
import { useEffect } from 'react'
import type { BlockTag } from 'viem'

import type { ConfigParameter, EnabledParameter } from '../types/properties.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseWatchBlocksParameters<
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = UnionCompute<
  UnionExactPartial<
    WatchBlocksParameters<includeTransactions, blockTag, config, chainId>
  > &
    ConfigParameter<config> &
    EnabledParameter
>

export type UseWatchBlocksReturnType = void

/** https://wagmi.sh/react/hooks/useWatchBlocks */
export function useWatchBlocks<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
  includeTransactions extends boolean = false,
  blockTag extends BlockTag = 'latest',
>(
  parameters: UseWatchBlocksParameters<
    includeTransactions,
    blockTag,
    config,
    chainId
  > = {} as any,
): UseWatchBlocksReturnType {
  const { enabled = true, onBlock, config: _, ...rest } = parameters

  const config = useConfig(parameters)
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  // TODO(react@19): cleanup
  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array
  useEffect(() => {
    if (!enabled) return
    if (!onBlock) return
    return watchBlocks(config, {
      ...(rest as any),
      chainId,
      onBlock,
    })
  }, [
    chainId,
    config,
    enabled,
    onBlock,
    ///
    rest.blockTag,
    rest.emitMissed,
    rest.emitOnBegin,
    rest.includeTransactions,
    rest.onError,
    rest.poll,
    rest.pollingInterval,
    rest.syncConnectedChain,
  ])
}
</file>

<file path="packages/react/src/hooks/useWatchContractEvent.test-d.ts">
import { http, createConfig, webSocket } from '@wagmi/core'
import { mainnet, optimism } from '@wagmi/core/chains'
import { abi } from '@wagmi/test'
import { expectTypeOf, test } from 'vitest'

import {
  type UseWatchContractEventParameters,
  useWatchContractEvent,
} from './useWatchContractEvent.js'

test('default', () => {
  useWatchContractEvent({
    address: '0x',
    abi: abi.erc20,
    eventName: 'Transfer',
    poll: false,
    args: {
      from: '0x',
      to: '0x',
    },
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<{
        from?: `0x${string}` | undefined
        to?: `0x${string}` | undefined
        value?: bigint | undefined
      }>()
    },
  })
})

test('behavior: no eventName', () => {
  useWatchContractEvent({
    address: '0x',
    abi: abi.erc20,
    args: {
      // TODO: Figure out why this is not working
      // @ts-ignore
      from: '0x',
      to: '0x',
    },
    onLogs(logs) {
      expectTypeOf(logs[0]!.eventName).toEqualTypeOf<'Transfer' | 'Approval'>()
      expectTypeOf(logs[0]!.args).toEqualTypeOf<
        | Record<string, unknown>
        | readonly unknown[]
        | {
            from?: `0x${string}` | undefined
            to?: `0x${string}` | undefined
            value?: bigint | undefined
          }
        | {
            owner?: `0x${string}` | undefined
            spender?: `0x${string}` | undefined
            value?: bigint | undefined
          }
      >()
    },
  })
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = UseWatchContractEventParameters<
    typeof abi.erc20,
    'Transfer' | 'Approval',
    true,
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchContractEvent({
    config,
    poll: false,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })

  type Result2 = UseWatchContractEventParameters<
    typeof abi.erc20,
    'Transfer' | 'Approval',
    true,
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  useWatchContractEvent({
    config,
    chainId: mainnet.id,
    poll: true,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })

  type Result3 = UseWatchContractEventParameters<
    typeof abi.erc20,
    'Transfer' | 'Approval',
    true,
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchContractEvent({
    config,
    chainId: optimism.id,
    poll: true,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })
  useWatchContractEvent({
    config,
    chainId: optimism.id,
    poll: false,
    address: '0x',
    abi: abi.erc20,
    onLogs() {},
  })
})
</file>

<file path="packages/react/src/hooks/useWatchContractEvent.ts">
'use client'

import {
  type Config,
  type ResolvedRegister,
  type WatchContractEventParameters,
  watchContractEvent,
} from '@wagmi/core'
import type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'
import { useEffect } from 'react'
import type { Abi, ContractEventName } from 'viem'

import type { ConfigParameter, EnabledParameter } from '../types/properties.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseWatchContractEventParameters<
  abi extends Abi | readonly unknown[] = Abi,
  eventName extends ContractEventName<abi> = ContractEventName<abi>,
  strict extends boolean | undefined = undefined,
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = UnionCompute<
  UnionExactPartial<
    WatchContractEventParameters<abi, eventName, strict, config, chainId>
  > &
    ConfigParameter<config> &
    EnabledParameter
>

export type UseWatchContractEventReturnType = void

/** https://wagmi.sh/react/api/hooks/useWatchContractEvent */
export function useWatchContractEvent<
  const abi extends Abi | readonly unknown[],
  eventName extends ContractEventName<abi>,
  strict extends boolean | undefined = undefined,
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  parameters: UseWatchContractEventParameters<
    abi,
    eventName,
    strict,
    config,
    chainId
  > = {} as any,
): UseWatchContractEventReturnType {
  const { enabled = true, onLogs, config: _, ...rest } = parameters

  const config = useConfig(parameters)
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  // TODO(react@19): cleanup
  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array
  useEffect(() => {
    if (!enabled) return
    if (!onLogs) return
    return watchContractEvent(config, {
      ...(rest as any),
      chainId,
      onLogs,
    })
  }, [
    chainId,
    config,
    enabled,
    onLogs,
    ///
    rest.abi,
    rest.address,
    rest.args,
    rest.batch,
    rest.eventName,
    rest.fromBlock,
    rest.onError,
    rest.poll,
    rest.pollingInterval,
    rest.strict,
    rest.syncConnectedChain,
  ])
}
</file>

<file path="packages/react/src/hooks/useWatchPendingTransactions.test-d.ts">
import { createConfig } from '@wagmi/core'
import { http, webSocket } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { expectTypeOf, test } from 'vitest'

import {
  type UseWatchPendingTransactionsParameters,
  useWatchPendingTransactions,
} from './useWatchPendingTransactions.js'

test('default', () => {
  useWatchPendingTransactions({
    poll: false,
    onTransactions() {},
  })
})

test('differing transports', () => {
  const config = createConfig({
    chains: [mainnet, optimism],
    transports: {
      [mainnet.id]: http(),
      [optimism.id]: webSocket(),
    },
  })

  type Result = UseWatchPendingTransactionsParameters<
    typeof config,
    typeof mainnet.id | typeof optimism.id
  >
  expectTypeOf<Result['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchPendingTransactions({
    config,
    poll: false,
    onTransactions() {},
  })

  type Result2 = UseWatchPendingTransactionsParameters<
    typeof config,
    typeof mainnet.id
  >
  expectTypeOf<Result2['poll']>().toEqualTypeOf<true | undefined>()
  useWatchPendingTransactions({
    config,
    chainId: mainnet.id,
    poll: true,
    onTransactions() {},
  })

  type Result3 = UseWatchPendingTransactionsParameters<
    typeof config,
    typeof optimism.id
  >
  expectTypeOf<Result3['poll']>().toEqualTypeOf<boolean | undefined>()
  useWatchPendingTransactions({
    config,
    chainId: optimism.id,
    poll: true,
    onTransactions() {},
  })
  useWatchPendingTransactions({
    config,
    chainId: optimism.id,
    poll: false,
    onTransactions() {},
  })
})
</file>

<file path="packages/react/src/hooks/useWatchPendingTransactions.ts">
'use client'

import {
  type Config,
  type ResolvedRegister,
  type WatchPendingTransactionsParameters,
  watchPendingTransactions,
} from '@wagmi/core'
import type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'
import { useEffect } from 'react'

import type { ConfigParameter, EnabledParameter } from '../types/properties.js'
import { useChainId } from './useChainId.js'
import { useConfig } from './useConfig.js'

export type UseWatchPendingTransactionsParameters<
  config extends Config = Config,
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
> = UnionCompute<
  UnionExactPartial<WatchPendingTransactionsParameters<config, chainId>> &
    ConfigParameter<config> &
    EnabledParameter
>

export type UseWatchPendingTransactionsReturnType = void

/** https://wagmi.sh/react/api/hooks/useWatchPendingTransactions */
export function useWatchPendingTransactions<
  config extends Config = ResolvedRegister['config'],
  chainId extends
    config['chains'][number]['id'] = config['chains'][number]['id'],
>(
  parameters: UseWatchPendingTransactionsParameters<
    config,
    chainId
  > = {} as any,
): UseWatchPendingTransactionsReturnType {
  const { enabled = true, onTransactions, config: _, ...rest } = parameters

  const config = useConfig(parameters)
  const configChainId = useChainId({ config })
  const chainId = parameters.chainId ?? configChainId

  // TODO(react@19): cleanup
  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array
  useEffect(() => {
    if (!enabled) return
    if (!onTransactions) return
    return watchPendingTransactions(config, {
      ...(rest as any),
      chainId,
      onTransactions,
    })
  }, [
    chainId,
    config,
    enabled,
    onTransactions,
    ///
    rest.batch,
    rest.onError,
    rest.poll,
    rest.pollingInterval,
    rest.syncConnectedChain,
  ])
}
</file>

<file path="packages/react/src/hooks/useWriteContract.test-d.ts">
import { http, type WriteContractErrorType, createConfig } from '@wagmi/core'
import { base } from '@wagmi/core/chains'
import { abi } from '@wagmi/test'
import type { Abi, Address, Hash } from 'viem'
import { expectTypeOf, test } from 'vitest'

import { useSimulateContract } from './useSimulateContract.js'
import { useWriteContract } from './useWriteContract.js'

const contextValue = { foo: 'bar' } as const

test('context', () => {
  const {
    context,
    data,
    error,
    writeContract: write,
    variables,
  } = useWriteContract({
    mutation: {
      onMutate(variables) {
        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: Abi
          functionName: string
          args?: readonly unknown[] | undefined
        }>()
        return contextValue
      },
      onError(error, variables, context) {
        expectTypeOf(error).toEqualTypeOf<WriteContractErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: Abi
          functionName: string
          args?: readonly unknown[] | undefined
        }>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: Abi
          functionName: string
          args?: readonly unknown[] | undefined
        }>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
        expectTypeOf(error).toEqualTypeOf<WriteContractErrorType | null>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: Abi
          functionName: string
          args?: readonly unknown[] | undefined
        }>()
      },
    },
  })

  expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
  expectTypeOf(error).toEqualTypeOf<WriteContractErrorType | null>()
  expectTypeOf(variables).toMatchTypeOf<
    { chainId?: number | undefined } | undefined
  >()
  expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

  write(
    {
      address: '0x',
      abi: abi.erc20,
      functionName: 'transferFrom',
      args: ['0x', '0x', 123n],
      chainId: 1,
    },
    {
      onError(error, variables, context) {
        expectTypeOf(error).toEqualTypeOf<WriteContractErrorType>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: typeof abi.erc20
          functionName: 'transferFrom'
          args: readonly [Address, Address, bigint]
        }>()
      },
      onSuccess(data, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue>()

        expectTypeOf(variables.functionName).toEqualTypeOf<'transferFrom'>()
        expectTypeOf(variables.args).toEqualTypeOf<
          readonly [Address, Address, bigint]
        >()
        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: typeof abi.erc20
          functionName: 'transferFrom'
          args: readonly [Address, Address, bigint]
        }>()
      },
      onSettled(data, error, variables, context) {
        expectTypeOf(data).toEqualTypeOf<Hash | undefined>()
        expectTypeOf(error).toEqualTypeOf<WriteContractErrorType | null>()
        expectTypeOf(context).toEqualTypeOf<typeof contextValue | undefined>()

        expectTypeOf(variables).toMatchTypeOf<{
          chainId?: number | undefined
          abi: typeof abi.erc20
          functionName: 'transferFrom'
          args: readonly [Address, Address, bigint]
        }>()
      },
    },
  )
})

test('useSimulateContract', () => {
  const { data } = useSimulateContract({
    address: '0x',
    abi: abi.erc20,
    functionName: 'transferFrom',
    args: ['0x', '0x', 123n],
    chainId: 1,
  })
  const { writeContract } = useWriteContract()

  const request = data?.request
  if (request) writeContract(request)
})

// https://github.com/wevm/wagmi/issues/3981
test('gh#3981', () => {
  const config = createConfig({
    chains: [base],
    transports: {
      [base.id]: http(),
    },
  })

  const abi = [
    {
      type: 'function',
      name: 'example1',
      inputs: [
        { name: 'exampleName', type: 'address', internalType: 'address' },
      ],
      outputs: [],
      stateMutability: 'payable',
    },
    {
      type: 'function',
      name: 'example2',
      inputs: [
        { name: 'exampleName', type: 'address', internalType: 'address' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
  ] as const

  const { writeContract } = useWriteContract({ config })
  writeContract({
    abi,
    address: '0x...',
    functionName: 'example1',
    args: ['0x...'],
    value: 123n,
  })
  writeContract({
    abi,
    address: '0x...',
    functionName: 'example2',
    args: ['0x...'],
    // @ts-expect-error
    value: 123n,
  })
})
</file>

<file path="packages/react/src/hooks/useWriteContract.ts">
'use client'

import { useMutation } from '@tanstack/react-query'
import type {
  Config,
  ResolvedRegister,
  WriteContractErrorType,
} from '@wagmi/core'
import {
  type WriteContractData,
  type WriteContractMutate,
  type WriteContractMutateAsync,
  type WriteContractVariables,
  writeContractMutationOptions,
} from '@wagmi/core/query'
import type { Abi } from 'viem'

import type { ConfigParameter } from '../types/properties.js'
import type {
  UseMutationParameters,
  UseMutationReturnType,
} from '../utils/query.js'
import { useConfig } from './useConfig.js'

export type UseWriteContractParameters<
  config extends Config = Config,
  context = unknown,
> = ConfigParameter<config> & {
  mutation?:
    | UseMutationParameters<
        WriteContractData,
        WriteContractErrorType,
        WriteContractVariables<
          Abi,
          string,
          readonly unknown[],
          config,
          config['chains'][number]['id']
        >,
        context
      >
    | undefined
}

export type UseWriteContractReturnType<
  config extends Config = Config,
  context = unknown,
> = UseMutationReturnType<
  WriteContractData,
  WriteContractErrorType,
  WriteContractVariables<
    Abi,
    string,
    readonly unknown[],
    config,
    config['chains'][number]['id']
  >,
  context
> & {
  writeContract: WriteContractMutate<config, context>
  writeContractAsync: WriteContractMutateAsync<config, context>
}

/** https://wagmi.sh/react/api/hooks/useWriteContract */
export function useWriteContract<
  config extends Config = ResolvedRegister['config'],
  context = unknown,
>(
  parameters: UseWriteContractParameters<config, context> = {},
): UseWriteContractReturnType<config, context> {
  const { mutation } = parameters

  const config = useConfig(parameters)

  const mutationOptions = writeContractMutationOptions(config)
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions,
  })

  type Return = UseWriteContractReturnType<config, context>
  return {
    ...result,
    writeContract: mutate as Return['writeContract'],
    writeContractAsync: mutateAsync as Return['writeContractAsync'],
  }
}
</file>

<file path="packages/react/src/types/properties.ts">
import type { DefaultError, QueryKey } from '@tanstack/react-query'
import type { Config } from '@wagmi/core'
import type { Omit } from '@wagmi/core/internal'

import type {
  UseInfiniteQueryParameters,
  UseQueryParameters,
} from '../utils/query.js'

export type EnabledParameter = {
  enabled?: boolean | undefined
}

export type ConfigParameter<config extends Config = Config> = {
  config?: Config | config | undefined
}

export type QueryParameter<
  queryFnData = unknown,
  error = DefaultError,
  data = queryFnData,
  queryKey extends QueryKey = QueryKey,
> = {
  query?:
    | Omit<
        UseQueryParameters<queryFnData, error, data, queryKey>,
        'queryFn' | 'queryHash' | 'queryKey' | 'queryKeyHashFn' | 'throwOnError'
      >
    | undefined
}

export type InfiniteQueryParameter<
  queryFnData = unknown,
  error = DefaultError,
  data = queryFnData,
  queryData = queryFnData,
  queryKey extends QueryKey = QueryKey,
  pageParam = unknown,
> = {
  query: Omit<
    UseInfiniteQueryParameters<
      queryFnData,
      error,
      data,
      queryData,
      queryKey,
      pageParam
    >,
    'queryFn' | 'queryHash' | 'queryKey' | 'queryKeyHashFn' | 'throwOnError'
  >
}
</file>

<file path="packages/react/src/utils/getVersion.ts">
import { version } from '../version.js'

export const getVersion = () => `wagmi@${version}`
</file>

<file path="packages/react/src/utils/query.ts">
import {
  type DefaultError,
  type QueryKey,
  type UseInfiniteQueryOptions,
  type UseInfiniteQueryResult,
  type UseMutationOptions,
  type UseMutationResult,
  type UseQueryOptions,
  type UseQueryResult,
  useInfiniteQuery as tanstack_useInfiniteQuery,
  useQuery as tanstack_useQuery,
  useMutation,
} from '@tanstack/react-query'
import type {
  Compute,
  ExactPartial,
  Omit,
  UnionStrictOmit,
} from '@wagmi/core/internal'
import { hashFn } from '@wagmi/core/query'

export type UseMutationParameters<
  data = unknown,
  error = Error,
  variables = void,
  context = unknown,
> = Compute<
  Omit<
    UseMutationOptions<data, error, Compute<variables>, context>,
    'mutationFn' | 'mutationKey' | 'throwOnError'
  >
>

export type UseMutationReturnType<
  data = unknown,
  error = Error,
  variables = void,
  context = unknown,
> = Compute<
  UnionStrictOmit<
    UseMutationResult<data, error, variables, context>,
    'mutate' | 'mutateAsync'
  >
>

export { useMutation }

////////////////////////////////////////////////////////////////////////////////

export type UseQueryParameters<
  queryFnData = unknown,
  error = DefaultError,
  data = queryFnData,
  queryKey extends QueryKey = QueryKey,
> = Compute<
  ExactPartial<
    Omit<UseQueryOptions<queryFnData, error, data, queryKey>, 'initialData'>
  > & {
    // Fix `initialData` type
    initialData?:
      | UseQueryOptions<queryFnData, error, data, queryKey>['initialData']
      | undefined
  }
>

export type UseQueryReturnType<data = unknown, error = DefaultError> = Compute<
  UseQueryResult<data, error> & {
    queryKey: QueryKey
  }
>

// Adding some basic customization.
// Ideally we don't have this function, but `import('@tanstack/react-query').useQuery` currently has some quirks where it is super hard to
// pass down the inferred `initialData` type because of it's discriminated overload in the on `useQuery`.
export function useQuery<queryFnData, error, data, queryKey extends QueryKey>(
  parameters: UseQueryParameters<queryFnData, error, data, queryKey> & {
    queryKey: QueryKey
  },
): UseQueryReturnType<data, error> {
  const result = tanstack_useQuery({
    ...(parameters as any),
    queryKeyHashFn: hashFn, // for bigint support
  }) as UseQueryReturnType<data, error>
  result.queryKey = parameters.queryKey
  return result
}

////////////////////////////////////////////////////////////////////////////////

export type UseInfiniteQueryParameters<
  queryFnData = unknown,
  error = DefaultError,
  data = queryFnData,
  queryData = queryFnData,
  queryKey extends QueryKey = QueryKey,
  pageParam = unknown,
> = Compute<
  Omit<
    UseInfiniteQueryOptions<
      queryFnData,
      error,
      data,
      queryData,
      queryKey,
      pageParam
    >,
    'initialData'
  > & {
    // Fix `initialData` type
    initialData?:
      | UseInfiniteQueryOptions<
          queryFnData,
          error,
          data,
          queryKey
        >['initialData']
      | undefined
  }
>

export type UseInfiniteQueryReturnType<
  data = unknown,
  error = DefaultError,
> = UseInfiniteQueryResult<data, error> & {
  queryKey: QueryKey
}

// Adding some basic customization.
export function useInfiniteQuery<
  queryFnData,
  error,
  data,
  queryKey extends QueryKey,
>(
  parameters: UseInfiniteQueryParameters<queryFnData, error, data, queryKey> & {
    queryKey: QueryKey
  },
): UseInfiniteQueryReturnType<data, error> {
  const result = tanstack_useInfiniteQuery({
    ...(parameters as any),
    queryKeyHashFn: hashFn, // for bigint support
  }) as UseInfiniteQueryReturnType<data, error>
  result.queryKey = parameters.queryKey
  return result
}
</file>

<file path="packages/react/src/context.ts">
'use client'

import type { ResolvedRegister, State } from '@wagmi/core'
import { createContext, createElement } from 'react'
import { Hydrate } from './hydrate.js'

export const WagmiContext = createContext<
  ResolvedRegister['config'] | undefined
>(undefined)

export type WagmiProviderProps = {
  config: ResolvedRegister['config']
  initialState?: State | undefined
  reconnectOnMount?: boolean | undefined
}

export function WagmiProvider(
  parameters: React.PropsWithChildren<WagmiProviderProps>,
) {
  const { children, config } = parameters

  const props = { value: config }
  return createElement(
    Hydrate,
    parameters,
    createElement(WagmiContext.Provider, props, children),
  )
}
</file>

<file path="packages/react/src/hydrate.ts">
'use client'

import { type ResolvedRegister, type State, hydrate } from '@wagmi/core'
import { type ReactElement, useEffect, useRef } from 'react'

export type HydrateProps = {
  config: ResolvedRegister['config']
  initialState?: State | undefined
  reconnectOnMount?: boolean | undefined
}

export function Hydrate(parameters: React.PropsWithChildren<HydrateProps>) {
  const { children, config, initialState, reconnectOnMount = true } = parameters

  const { onMount } = hydrate(config, {
    initialState,
    reconnectOnMount,
  })

  // Hydrate for non-SSR
  if (!config._internal.ssr) onMount()

  // Hydrate for SSR
  const active = useRef(true)
  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required
  useEffect(() => {
    if (!active.current) return
    if (!config._internal.ssr) return
    onMount()
    return () => {
      active.current = false
    }
  }, [])

  return children as ReactElement
}
</file>

<file path="packages/react/src/version.ts">
export const version = '2.15.2'
</file>

<file path="packages/react/test/setup.ts">
import { vi } from 'vitest'

// Make dates stable across runs
Date.now = vi.fn(() => new Date(Date.UTC(2023, 1, 1)).valueOf())

vi.mock('../src/version.ts', () => {
  return { version: 'x.y.z' }
})
</file>

<file path="packages/react/package.json">
{
  "name": "wagmi",
  "description": "React Hooks for Ethereum",
  "version": "2.15.2",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/wevm/wagmi.git",
    "directory": "packages/react"
  },
  "scripts": {
    "build": "pnpm run clean && pnpm run build:esm+types",
    "build:esm+types": "tsc --project tsconfig.build.json --outDir ./dist/esm --declaration --declarationMap --declarationDir ./dist/types",
    "check:types": "tsc --noEmit",
    "clean": "rm -rf dist tsconfig.tsbuildinfo actions chains codegen connectors experimental query",
    "test:build": "publint --strict && attw --pack --ignore-rules cjs-resolves-to-esm"
  },
  "files": [
    "dist/**",
    "!dist/**/*.tsbuildinfo",
    "src/**/*.ts",
    "!src/**/*.test.ts",
    "!src/**/*.test-d.ts",
    "/actions",
    "/chains",
    "/codegen",
    "/connectors",
    "/experimental",
    "/query"
  ],
  "sideEffects": false,
  "type": "module",
  "main": "./dist/esm/exports/index.js",
  "types": "./dist/types/exports/index.d.ts",
  "typings": "./dist/types/exports/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/types/exports/index.d.ts",
      "default": "./dist/esm/exports/index.js"
    },
    "./actions": {
      "types": "./dist/types/exports/actions.d.ts",
      "default": "./dist/esm/exports/actions.js"
    },
    "./actions/experimental": {
      "types": "./dist/types/exports/actions/experimental.d.ts",
      "default": "./dist/esm/exports/actions/experimental.js"
    },
    "./chains": {
      "types": "./dist/types/exports/chains.d.ts",
      "default": "./dist/esm/exports/chains.js"
    },
    "./codegen": {
      "types": "./dist/types/exports/codegen.d.ts",
      "default": "./dist/esm/exports/codegen.js"
    },
    "./connectors": {
      "types": "./dist/types/exports/connectors.d.ts",
      "default": "./dist/esm/exports/connectors.js"
    },
    "./experimental": {
      "types": "./dist/types/exports/experimental.d.ts",
      "default": "./dist/esm/exports/experimental.js"
    },
    "./query": {
      "types": "./dist/types/exports/query.d.ts",
      "default": "./dist/esm/exports/query.js"
    },
    "./package.json": "./package.json"
  },
  "typesVersions": {
    "*": {
      "actions": ["./dist/types/exports/actions.d.ts"],
      "chains": ["./dist/types/exports/chains.d.ts"],
      "codegen": ["./dist/types/exports/codegen.d.ts"],
      "connectors": ["./dist/types/exports/connectors.d.ts"],
      "experimental": ["./dist/types/exports/experimental.d.ts"],
      "query": ["./dist/types/exports/query.d.ts"]
    }
  },
  "peerDependencies": {
    "@tanstack/react-query": ">=5.0.0",
    "react": ">=18",
    "typescript": ">=5.0.4",
    "viem": "2.x"
  },
  "peerDependenciesMeta": {
    "typescript": {
      "optional": true
    }
  },
  "dependencies": {
    "@wagmi/connectors": "workspace:*",
    "@wagmi/core": "workspace:*",
    "use-sync-external-store": "1.4.0"
  },
  "devDependencies": {
    "@tanstack/react-query": "catalog:",
    "@testing-library/dom": "catalog:",
    "@testing-library/react": "catalog:",
    "@types/react": "catalog:",
    "@types/react-dom": "catalog:",
    "@types/use-sync-external-store": "^0.0.6",
    "react": "catalog:",
    "react-dom": "catalog:"
  },
  "contributors": ["awkweb.eth <t@wevm.dev>", "jxom.eth <j@wevm.dev>"],
  "funding": "https://github.com/sponsors/wevm",
  "keywords": [
    "wagmi",
    "react",
    "hooks",
    "eth",
    "ethereum",
    "dapps",
    "wallet",
    "web3"
  ]
}
</file>

<file path="packages/react/README.md">
# wagmi

React Hooks for Ethereum

## Installation

```bash
pnpm add wagmi viem @tanstack/react-query
```

## Documentation

For documentation and guides, visit [wagmi.sh](https://wagmi.sh).
</file>

<file path="packages/react/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/*.test.ts", "src/**/*.test-d.ts"],
  "compilerOptions": {
    "sourceMap": true
  }
}
</file>

<file path="packages/react/tsconfig.json">
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "jsx": "preserve"
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "test/**/*.ts", "test/**/*.tsx"],
  "exclude": []
}
</file>

<file path=".gitignore">
.DS_Store
.next
.nuxt
.pnpm-debug.log*
cache
coverage
dist
node_modules
tsconfig.tsbuildinfo
*.vitest-temp.json

# local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.envrc

# proxy packages
packages/cli/config
packages/cli/plugins
packages/core/actions
packages/core/chains
packages/core/codegen
packages/core/experimental
packages/core/internal
packages/core/query
packages/react/actions
packages/react/chains
packages/react/codegen
packages/react/connectors
packages/react/experimental
packages/react/query
packages/vue/actions
packages/vue/chains
packages/vue/connectors
packages/vue/nuxt
packages/vue/query
</file>

<file path=".npmrc">
auto-install-peers=false
enable-pre-post-scripts=true
link-workspace-packages=deep
provenance=true
strict-peer-dependencies=false
</file>

<file path="biome.json">
{
  "$schema": "./node_modules/@biomejs/biome/configuration_schema.json",
  "files": {
    "ignore": ["CHANGELOG.md", "pnpm-lock.yaml", "tsconfig.base.json"]
  },
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 80
  },
  "linter": {
    "ignore": ["packages/create-wagmi/templates/*"],
    "enabled": true,
    "rules": {
      "recommended": true,
      "a11y": {
        "useButtonType": "off"
      },
      "correctness": {
        "noUnusedVariables": "error",
        "useExhaustiveDependencies": "error"
      },
      "performance": {
        "noBarrelFile": "error",
        "noReExportAll": "error",
        "noDelete": "off"
      },
      "style": {
        "noNonNullAssertion": "off",
        "useShorthandArrayType": "error"
      },
      "suspicious": {
        "noArrayIndexKey": "off",
        "noConfusingVoidType": "off",
        "noConsoleLog": "error",
        "noExplicitAny": "off"
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "single",
      "trailingCommas": "all",
      "semicolons": "asNeeded"
    }
  },
  "organizeImports": {
    "enabled": true
  },
  "overrides": [
    {
      "include": ["*.vue"],
      "linter": {
        "rules": {
          "correctness": {
            "noUnusedVariables": "off"
          }
        }
      }
    },
    {
      "include": ["./scripts/**/*.ts"],
      "linter": {
        "rules": {
          "suspicious": {
            "noConsoleLog": "off"
          }
        }
      }
    },
    {
      "include": ["./playgrounds/**"],
      "linter": {
        "rules": {
          "style": {
            "useNodejsImportProtocol": "off"
          }
        }
      }
    }
  ],
  "vcs": {
    "enabled": true,
    "clientKind": "git",
    "useIgnoreFile": true
  }
}
</file>

<file path="FUNDING.json">
{
  "drips": {
    "ethereum": {
      "ownedBy": "0xd2135CfB216b74109775236E36d4b433F1DF507B"
    }
  },
  "opRetro": {
    "projectId": "0xc0615947773148cbc340b175fb9afc98dbb4e0acd31d018b1ee41a5538785abf"
  }
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2022-present weth, LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "private": true,
  "type": "module",
  "scripts": {
    "build": "pnpm run --r --filter \"./packages/**\" build",
    "changeset:prepublish": "pnpm version:update && pnpm build && bun scripts/formatPackageJson.ts && bun scripts/generateProxyPackages.ts",
    "changeset:publish": "pnpm changeset:prepublish && changeset publish",
    "changeset:version": "changeset version && pnpm version:update && pnpm format",
    "check": "biome check --write",
    "check:repo": "sherif -i viem",
    "check:types": "pnpm run --r --parallel check:types && tsc --noEmit",
    "check:unused": "pnpm clean && knip",
    "clean": "pnpm run --r --parallel clean && rm -rf packages/**/*.json.tmp",
    "deps": "pnpx taze -r",
    "dev": "pnpm dev:react",
    "dev:cli": "pnpm --filter cli dev",
    "dev:core": "pnpm --filter vite-core dev",
    "dev:create-wagmi": "pnpm --filter create-wagmi dev",
    "dev:next": "pnpm --filter next-app dev",
    "dev:nuxt": "pnpm --filter nuxt-app dev",
    "dev:react": "pnpm --filter vite-react dev",
    "dev:vue": "pnpm --filter vite-vue dev",
    "docs:dev": "pnpm --filter site dev",
    "format": "biome format --write",
    "postinstall": "pnpm preconstruct",
    "preconstruct": "bun scripts/preconstruct.ts",
    "preinstall": "pnpx only-allow pnpm",
    "prepare": "pnpm simple-git-hooks",
    "test": "vitest",
    "test:build": "bun scripts/generateProxyPackages.ts && pnpm run --r --parallel test:build",
    "test:cli": "vitest --project @wagmi/cli",
    "test:connectors": "vitest --project @wagmi/connectors",
    "test:core": "vitest --project @wagmi/core",
    "test:create-wagmi": "vitest --project create-wagmi",
    "test:cov": "vitest run --coverage",
    "test:react": "vitest --project wagmi",
    "test:typecheck": "vitest typecheck",
    "test:update": "vitest --update",
    "test:vue": "vitest --project @wagmi/vue",
    "version:update": "bun scripts/updateVersion.ts",
    "version:update:viem": "bun scripts/updateViemVersion.ts"
  },
  "devDependencies": {
    "@arethetypeswrong/cli": "^0.16.4",
    "@biomejs/biome": "^1.9.4",
    "@changesets/changelog-github": "0.4.6",
    "@changesets/cli": "^2.27.8",
    "@types/bun": "^1.1.10",
    "@vitest/coverage-v8": "^2.1.1",
    "@wagmi/test": "workspace:*",
    "bun": "^1.1.29",
    "happy-dom": "^15.7.4",
    "knip": "^5.30.6",
    "prool": "^0.0.23",
    "publint": "^0.2.11",
    "sherif": "^1.0.0",
    "simple-git-hooks": "^2.11.1",
    "typescript": "5.5.4",
    "viem": "2.28.0",
    "vitest": "^2.1.1"
  },
  "packageManager": "pnpm@9.11.0",
  "pnpm": {
    "peerDependencyRules": {
      "ignoreMissing": [
        "@algolia/client-search",
        "react",
        "react-native",
        "search-insights"
      ]
    }
  },
  "engines": {
    "node": "22.x"
  },
  "simple-git-hooks": {
    "pre-commit": "pnpm check"
  },
  "knip": {
    "ignore": ["**/templates/**", "**/hardhat.config.js"],
    "ignoreBinaries": ["only-allow"],
    "ignoreWorkspaces": [
      "packages/register-tests/**",
      "packages/test",
      "playgrounds/**"
    ],
    "workspaces": {
      ".": {
        "project": "scripts/*.ts"
      },
      "packages/cli": {
        "entry": [
          "src/cli.ts!",
          "src/exports/{config,index,plugins}.ts!",
          "types/*.d.ts!"
        ],
        "ignore": ["test/{constants,setup,utils}.ts"]
      },
      "packages/connectors": {
        "entry": "src/exports/index.ts!"
      },
      "packages/core": {
        "entry": "src/exports/{actions,chains,codegen,experimental,index,internal,query}.ts!",
        "ignore": ["test/setup.ts"],
        "ignoreDependencies": ["@tanstack/query-core"]
      },
      "packages/create-wagmi": {
        "entry": "src/cli.ts!"
      },
      "packages/react": {
        "entry": [
          "src/exports/{actions,chains,codegen,connectors,experimental,index,query}.ts!",
          "src/exports/actions/experimental.ts!"
        ],
        "ignore": ["test/setup.ts"]
      },
      "packages/test": {
        "entry": [
          "src/{globalSetup,setup}.ts!",
          "src/exports/{index,react}.ts!"
        ]
      },
      "packages/vue": {
        "entry": [
          "src/exports/{actions,chains,connectors,index,nuxt,query}.ts!",
          "src/exports/actions/experimental.ts!"
        ],
        "ignore": ["src/nuxt/runtime/*", "test/setup.ts"],
        "ignoreDependencies": ["nuxt"]
      },
      "site": {
        "project": ["**/*.ts", "**/*.tsx"]
      }
    }
  }
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - packages/*
  - "!packages/register-tests"
  - packages/cli/src/plugins/__fixtures__/hardhat
  - packages/register-tests/*
  - playgrounds/*
  - site

catalog:
  "@tanstack/query-core": "5.49.1"
  "@tanstack/react-query": "5.49.2"
  "@tanstack/vue-query": "5.49.1"
  "@testing-library/dom": "10.4.0"
  "@testing-library/react": "16.0.1"
  "@types/react": "18.3.1"
  "@types/react-dom": "18.3.0"
  react-dom: "18.3.1"
  react: "18.3.1"
  vue: "3.4.27"
</file>

<file path="tsconfig.base.json">
{
  // This tsconfig file contains the shared config for the build (tsconfig.build.json) and type checking (tsconfig.json) config.
  "include": [],
  "compilerOptions": {
    // Incremental builds
    // NOTE: Enabling incremental builds speeds up `tsc`. Keep in mind though that it does not reliably bust the cache when the `tsconfig.json` file changes.
    "incremental": true,

    // Type checking
    "strict": true,
    // "exactOptionalPropertyTypes": true, // Enabled once supported in tanstack query https://github.com/TanStack/query/issues/7641
    "noFallthroughCasesInSwitch": true, // Not enabled by default in `strict` mode.
    "noImplicitOverride": true, // Not enabled by default in `strict` mode.
    "noImplicitReturns": true, // Not enabled by default in `strict` mode.
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true, // Not enabled by default in `strict` mode.
    "noUnusedParameters": true, // Not enabled by default in `strict` mode.
    "useDefineForClassFields": true, // Not enabled by default in `strict` mode unless we bump `target` to ES2022.
    "useUnknownInCatchVariables": true,

    // JavaScript support
    "allowJs": false,
    "checkJs": false,

    // Interop constraints
    "forceConsistentCasingInFileNames": true,
    "verbatimModuleSyntax": true,

    // Language and environment
    "moduleResolution": "NodeNext",
    "module": "NodeNext",
    "target": "ES2021", // Setting this to `ES2021` enables native support for `Node v16+`: https://github.com/microsoft/TypeScript/wiki/Node-Target-Mapping.
    "lib": [
      "ES2022", // By using ES2022 we get access to the `.cause` property on `Error` instances.
      "DOM" // We are adding `DOM` here to get the `fetch`, etc. types. This should be removed once these types are available via DefinitelyTyped.
    ],

    // Skip type checking for node modules
    "skipLibCheck": true,
    "noErrorTruncation": true
  }
}
</file>

<file path="tsconfig.json">
{
  "extends": "./tsconfig.base.json",
  "include": ["scripts/**/*.ts", "vitest.workspace.ts", "vitest.config.ts"],
  "exclude": [],
  "compilerOptions": {
    "types": ["@types/bun"]
  }
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config'

export default defineConfig({
  server: {
    watch: {
      ignored: ['**/templates/**'],
    },
  },
  test: {
    coverage: {
      all: false,
      reporter: process.env.CI ? ['lcov'] : ['text', 'json', 'html'],
      exclude: [
        '**/dist/**',
        '**/*.test.ts',
        '**/*.test-d.ts',
        'packages/cli/**',
        'packages/test/**',
        // ignore third-party connectors
        'packages/connectors/**',
        'packages/core/src/connectors/injected.ts',
      ],
    },
    globalSetup: ['./packages/test/src/globalSetup.ts'],
    setupFiles: ['./packages/test/src/setup.ts'],
  },
})
</file>

<file path="vitest.workspace.ts">
import path from 'node:path'
import { defineWorkspace } from 'vitest/config'

const alias = {
  '@wagmi/connectors': path.resolve(
    __dirname,
    './packages/connectors/src/exports',
  ),
  '@wagmi/core': path.resolve(__dirname, './packages/core/src/exports'),
  '@wagmi/test': path.resolve(__dirname, './packages/test/src/exports'),
  '@wagmi/vue': path.resolve(__dirname, './packages/vue/src/exports'),
  wagmi: path.resolve(__dirname, './packages/react/src/exports'),
}

export default defineWorkspace([
  {
    test: {
      name: '@wagmi/cli',
      environment: 'node',
      include: ['./packages/cli/src/**/*.test.ts'],
      testTimeout: 10_000,
      setupFiles: ['./packages/cli/test/setup.ts'],
    },
  },
  {
    test: {
      name: '@wagmi/connectors',
      include: ['./packages/connectors/src/**/*.test.ts'],
      environment: 'happy-dom',
    },
    resolve: { alias },
  },
  {
    test: {
      name: '@wagmi/core',
      include: ['./packages/core/src/**/*.test.ts'],
      environment: 'happy-dom',
      testTimeout: 10_000,
      setupFiles: ['./packages/core/test/setup.ts'],
    },
    resolve: { alias },
  },
  {
    test: {
      name: 'create-wagmi',
      include: ['./packages/create-wagmi/src/**/*.test.ts'],
      environment: 'node',
      testTimeout: 10_000,
    },
  },
  {
    test: {
      name: 'wagmi',
      include: ['./packages/react/src/**/*.test.ts?(x)'],
      environment: 'happy-dom',
      testTimeout: 10_000,
      setupFiles: ['./packages/react/test/setup.ts'],
    },
    resolve: { alias },
  },
  {
    test: {
      name: '@wagmi/vue',
      include: ['./packages/vue/src/**/*.test.ts?(x)'],
      environment: 'happy-dom',
      testTimeout: 10_000,
      setupFiles: ['./packages/vue/test/setup.ts'],
    },
    resolve: { alias },
  },
  {
    test: {
      name: 'react-register',
      include: ['./packages/register-tests/react/src/**/*.test.ts'],
    },
    resolve: { alias },
  },
  {
    test: {
      name: '@wagmi/test',
      include: ['./packages/test/src/**/*.test.ts'],
    },
    resolve: { alias },
  },
])
</file>

</files>
