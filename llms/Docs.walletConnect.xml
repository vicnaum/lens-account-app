This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    BUG-REPORT.yml
    config.yml
    FEATURE-REQUEST.yml
docs/
  advanced/
    multichain/
      polkadot/
        dapp-integration-guide.md
        namespaces-guide.md
        wallet-integration-guide.md
      rpc-reference/
        bitcoin-rpc.md
        casper-rpc.md
        cosmos-rpc.md
        dogecoin-rpc.md
        ethereum-rpc.md
        everscale-rpc.md
        hedera-rpc.md
        litecoin-rpc.md
        near-rpc.md
        solana-rpc.md
        starknet-rpc.md
        stellar-rpc.md
        tezos-rpc.md
        xrpl-rpc.md
    providers/
      ethereum.mdx
      solana-adapter.mdx
      universal.mdx
    security/
      content-security-policy.md
    walletconnectmodal/
      about.mdx
      options.mdx
      resources.mdx
      theming.mdx
      usage.mdx
    faq.md
    glossary.md
    push-server.md
  api/
    core/
      about.mdx
      pairing.mdx
      relay.mdx
      shared-core.md
    notify/
      about.mdx
      usage.mdx
    sign/
      dapp-usage.md
      overview.md
      smart-contract-wallet-usage.md
      wallet-usage.md
  appkit/
    android/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        actions.mdx
        components.mdx
        installation.mdx
        one-click-auth.mdx
        options.mdx
        theming.mdx
        usage.mdx
    features/
      notifications.mdx
      one-click-auth.mdx
      onramp.mdx
      smart-accounts.mdx
      socials.mdx
      solana.mdx
      swaps.mdx
    flutter/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        actions.mdx
        custom-chains.mdx
        events.mdx
        installation.mdx
        options.mdx
        siwe.mdx
        theming.mdx
        usage.mdx
      onboarding/
        email.mdx
    ios/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        actions.mdx
        custom-chains.mdx
        installation.mdx
        one-click-auth.mdx
        options.mdx
        usage.mdx
    javascript/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        actions.mdx
        components.mdx
        custom-connectors.mdx
        installation.mdx
        options.mdx
        resources.mdx
        siwe.mdx
        theming.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        actions.mdx
      ethers5/
        implementation.mdx
      notifications/
        authorization-signatures/
          all-apps.mdx
          overview.mdx
          this-app.mdx
        frontend-integration/
          api.mdx
          examples.mdx
          migration-guide.mdx
          usage.mdx
        backend-integration.mdx
        cloud-sending.mdx
        cloud-setup.mdx
        demo.mdx
        overview.mdx
      onboarding/
        ens.mdx
        graduation.mdx
        smart-accounts.mdx
        socials.mdx
      solana/
        about/
          implementation.mdx
          programs.mdx
          triggermodal.mdx
        actions.mdx
      transactions/
        onramp.mdx
        swaps.mdx
        transaction-history.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        actions.mdx
    migration/
      from-anza-adapter-react.mdx
      from-rainbowkit-next.mdx
    next/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        components.mdx
        custom-connectors.mdx
        hooks.mdx
        installation.mdx
        options.mdx
        resources.mdx
        siwe.mdx
        theming.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
      ethers5/
        implementation.mdx
        triggermodal.mdx
      notifications/
        authorization-signatures/
          all-apps.mdx
          overview.mdx
          this-app.mdx
        embedded-widget/
          about.mdx
          usage.mdx
        frontend-integration/
          api.mdx
          examples.mdx
          migration-guide.mdx
          usage.mdx
        backend-integration.mdx
        cloud-sending.mdx
        cloud-setup.mdx
        demo.mdx
        overview.mdx
      onboarding/
        ens.mdx
        graduation.mdx
        smart-accounts.mdx
        socials.mdx
      solana/
        about/
          implementation.mdx
          programs.mdx
          triggermodal.mdx
        hooks.mdx
      transactions/
        onramp.mdx
        swaps.mdx
        transaction-history.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
    react/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        components.mdx
        custom-connectors.mdx
        hooks.mdx
        installation.mdx
        options.mdx
        resources.mdx
        siwe.mdx
        theming.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
      ethers5/
        implementation.mdx
        triggermodal.mdx
      notifications/
        authorization-signatures/
          all-apps.mdx
          overview.mdx
          this-app.mdx
        embedded-widget/
          about.mdx
          usage.mdx
        frontend-integration/
          api.mdx
          examples.mdx
          migration-guide.mdx
          usage.mdx
        backend-integration.mdx
        cloud-sending.mdx
        cloud-setup.mdx
        demo.mdx
        overview.mdx
      onboarding/
        ens.mdx
        graduation.mdx
        smart-accounts.mdx
        socials.mdx
        wallet-features.mdx
      solana/
        about/
          implementation.mdx
          programs.mdx
          triggermodal.mdx
        hooks.mdx
        implementation.mdx
        triggermodal.mdx
      transactions/
        onramp.mdx
        swaps.mdx
        transaction-history.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
    react-native/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        components.mdx
        hooks.mdx
        installation.mdx
        options.mdx
        resources.mdx
        siwe.mdx
      ethers/
        about/
          coinbase.mdx
          implementation.mdx
          installation-expo.mdx
          installation.mdx
        email.mdx
        hooks.mdx
      ethers5/
        about/
          coinbase.mdx
          implementation.mdx
          installation-expo.mdx
          installation.mdx
        hooks.mdx
      expo/
        additional-expo48.mdx
      notifications/
        authorization-signatures/
          all-apps.mdx
          overview.mdx
          this-app.mdx
        frontend-integration/
          api.mdx
          examples.mdx
          migration-guide.mdx
          usage.mdx
        backend-integration.mdx
        cloud-sending.mdx
        cloud-setup.mdx
        demo.mdx
        overview.mdx
      onboarding/
        email.mdx
      wagmi/
        about/
          coinbase.mdx
          implementation.mdx
          installation-expo.mdx
          installation.mdx
        email.mdx
        hooks.mdx
    shared/
      notifications/
        frontend-integration/
          api/
            events/
              javascript.mdx
              react.mdx
            initialization/
              javascript.mdx
              react.mdx
            managing-notifications/
              javascript.mdx
              react.mdx
            managing-subscription/
              javascript.mdx
              react.mdx
            registering-accounts/
              javascript.mdx
              react.mdx
            registering-push/
              javascript.mdx
              react.mdx
            setting-account/
              javascript.mdx
              react.mdx
            types/
              javascript.mdx
              react.mdx
          migration/
            javascript.mdx
            react.mdx
          usage/
            example/
              javascript.mdx
              react.mdx
            installation/
              javascript.mdx
              react.mdx
      siwe/
        code.mdx
        parameters.mdx
      components.mdx
      onramp.mdx
      options.mdx
      resources.mdx
      smart-accounts.mdx
      socials.mdx
      swaps.mdx
      theming.mdx
    unity/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        actions.mdx
        customization.mdx
        events.mdx
        installation.mdx
        options.mdx
        usage.mdx
    vue/
      cloud/
        analytics.mdx
        blockchain-api.mdx
        relay.mdx
        verify.mdx
      core/
        components.mdx
        composables.mdx
        custom-connectors.mdx
        installation.mdx
        options.mdx
        resources.mdx
        siwe.mdx
        theming.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        composables.mdx
      ethers5/
        implementation.mdx
        triggermodal.mdx
      notifications/
        authorization-signatures/
          all-apps.mdx
          overview.mdx
          this-app.mdx
        frontend-integration/
          api.mdx
          examples.mdx
          migration-guide.mdx
          usage.mdx
        backend-integration.mdx
        cloud-sending.mdx
        cloud-setup.mdx
        demo.mdx
        overview.mdx
      onboarding/
        ens.mdx
        graduation.mdx
        smart-accounts.mdx
        socials.mdx
      solana/
        about/
          implementation.mdx
          triggermodal.mdx
        implementation.mdx
        programs.mdx
        triggermodal.mdx
      transactions/
        onramp.mdx
        swaps.mdx
        transaction-history.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        composables.mdx
    overview.mdx
    upgrade.mdx
  cloud/
    chains/
      chain-list.mdx
      overview.md
    analytics.mdx
    blockchain-api.mdx
    explorer-submission.mdx
    explorer.md
    relay.mdx
    verify.mdx
  components/
    button/
      index.js
      styles.module.css
    GettingStarted/
      Card.js
    Home/
      Banner.js
      LargeContainer.js
      SmallContainer.js
      Wrapper.js
    Tabs/
      index.js
      styles.module.css
    Box.js
    ChainCard.js
    CloudBanner.js
    Container.js
    List.js
    PlatformTabItem.js
    PlatformTabs.js
    SolanaBanner.js
    Table.js
    W3MQuickStart.js
    WhatsNewBanner.js
    YoutubeEmbed.js
  walletkit/
    android/
      cloud/
        analytics.mdx
        explorer-submission.mdx
        relay.mdx
        verify.mdx
      notifications/
        notify/
          installation.mdx
          overview.mdx
          resources.mdx
          spam-protection.mdx
          usage.mdx
        push.mdx
      best-practices.mdx
      eip5792.mdx
      installation.mdx
      link-mode.mdx
      mobile-linking.mdx
      one-click-auth.mdx
      resources.mdx
      usage.mdx
      verify.mdx
    c-sharp/
      cloud/
        analytics.mdx
        explorer-submission.mdx
        relay.mdx
        verify.mdx
      installation.mdx
      usage.mdx
      verify.mdx
    features/
      notifications.mdx
      one-click-auth.mdx
      verify.mdx
    flutter/
      cloud/
        analytics.mdx
        explorer-submission.mdx
        relay.mdx
        verify.mdx
      eip5792.mdx
      installation.mdx
      mobile-linking.mdx
      one-click-auth.mdx
      usage.mdx
      verify.mdx
    ios/
      cloud/
        analytics.mdx
        explorer-submission.mdx
        relay.mdx
        verify.mdx
      notifications/
        notify/
          installation.mdx
          overview.mdx
          resources.mdx
          spam-protection.mdx
          usage.mdx
        push.mdx
      best-practices.mdx
      eip5792.mdx
      installation.mdx
      link-mode.mdx
      mobile-linking.mdx
      one-click-auth.mdx
      resources.mdx
      usage.mdx
      verify.mdx
    react-native/
      cloud/
        analytics.mdx
        explorer-submission.mdx
        relay.mdx
        verify.mdx
      notifications/
        notify/
          installation.mdx
          overview.mdx
          spam-protection.mdx
          usage.mdx
        push.mdx
      best-practices.mdx
      eip5792.mdx
      installation.mdx
      mobile-linking.mdx
      one-click-auth.mdx
      resources.mdx
      usage.mdx
      verify.mdx
    shared/
      mobile-linking.mdx
    web/
      cloud/
        analytics.mdx
        explorer-submission.mdx
        relay.mdx
        verify.mdx
      best-practices.mdx
      eip5792.mdx
      installation.mdx
      one-click-auth-siws.mdx
      one-click-auth.mdx
      resources.mdx
      usage.mdx
      verify.mdx
    best-practices.mdx
    overview.mdx
  web3modal/
    v2/
      _partials/
        customisation/
          customChainImages.mdx
          customChainProviders.mdx
          customDefaultChain.mdx
          customExplorerWallets.mdx
          customManualWallets.mdx
          customWagmiChains.mdx
          customWagmiConnectors.mdx
          customWagmiWalletsIntro.mdx
          customWalletImages.mdx
        options/
          chainImages.mdx
          chains.mdx
          defaultChain.mdx
          desktopWallets.mdx
          enableAccountView.mdx
          enableAuthMode.mdx
          enableExplorer.mdx
          enableNetworkView.mdx
          explorerExcludedWalletIds.mdx
          explorerRecommendedWalletIds.mdx
          metadata.mdx
          mobileWallets.mdx
          privacyPolicyUrl.mdx
          projectId.mdx
          termsOfServiceUrl.mdx
          themeMode.mdx
          themeVariables.mdx
          tokenContracts.mdx
          tokenImages.mdx
          walletImages.mdx
        obtainProjectId.mdx
        themeMode.mdx
        themeVariables.mdx
        themeVariablesTable.mdx
        wcModalThemeVariablesTable.mdx
  readme.mdx
src/
  css/
    banner.module.css
    custom.css
    feedback.module.css
    fonts.css
    sidebar.css
  theme/
    Admonition/
      index.js
      styles.module.css
    DocBreadcrumbs/
      Items/
        Home/
          index.js
          styles.module.css
      index.js
      styles.module.css
    DocItem/
      Footer/
        index.js
        styles.module.css
    DocSidebar/
      constants.js
      index.js
    Dropdown/
      utils/
        index.js
      icons.js
      index.js
      styles.module.css
    Navbar/
      ColorModeToggle/
        index.js
        styles.module.css
      Content/
        index.js
        styles.module.css
      Layout/
        index.js
        styles.module.css
      Logo/
        index.js
      MobileSidebar/
        Header/
          index.js
        Layout/
          index.js
        SecondaryMenu/
          index.js
        Toggle/
          index.js
        index.js
      Search/
        index.js
        styles.module.css
      index.js
    Root.js
static/
  img/
    walletconnect-logo-black.svg
    walletconnect-logo-white.svg
    walletconnect-logo.svg
.gitignore
.prettierrc.json
babel.config.js
docusaurus.config.js
LICENSE
package.json
README.mdx
sidebars.js
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/BUG-REPORT.yml">
name: üêõ Bug Report
description: Create a report to help us improve.
labels: ['bug', 'triage']

body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!
  - type: textarea
    id: describe-the-bug
    attributes:
      label: Describe the bug
      description: A clear and concise description of what the bug is.
      placeholder: Tell us what you expected!
    validations:
      required: true
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
contact_links:
  - name: ‚ùìAsk a question
    url: https://github.com/orgs/WalletConnect/discussions/new/choose
    about: Ask questions and discuss with other community members.
  - name: View our FAQ
    url: https://walletconnect.com/faq
    about: See our frequently asked questions.
</file>

<file path=".github/ISSUE_TEMPLATE/FEATURE-REQUEST.yml">
name: üí° Feature Request
description: Suggest an idea to make this documentation better.
labels: ['feature', 'triage']

body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this feature request!
  - type: textarea
    id: context
    attributes:
      label: Context
      description: Add any other context or screenshots about the feature request here.
      placeholder: Share the context
    validations:
      required: false
</file>

<file path="docs/advanced/multichain/polkadot/dapp-integration-guide.md">
# Dapp Integration Guide

## Dapp Guide Section Topics

- WalletConnect Code/Component Setup
- Constructing unsigned transactions
- Sending unsigned transactions for signing using WalletConnect
- Adding the signature to the ExtrinsicPayload
- Signing and sending the transaction to the node

---

# WalletConnect Code/Component Setup

1. **One time step**: Generate a unique `projectId` by visiting and creating your project‚Äôs profile on WalletConnect‚Äôs project dashboard at: https://cloud.walletconnect.com/.

2. Import `UniversalProvider` and `{ WalletConnectModal }` from `@walletconnect/universal-provider` and `@walletconnect/modal` respectively.

```js
import UniversalProvider from '@walletconnect/universal-provider'
import { WalletConnectModal } from '@walletconnect/modal'
```

3. Instantiate a universal provider using the `projectId` created for your app.

```js
const provider = await UniversalProvider.init({
  projectId: '2ea3f3ghubh32b8ie2f2',
  relayUrl: 'wss://relay.walletconnect.com'
})
```

4. On user action (e.g. user clicks connect for WalletConnect), call the connect method on the providers sign client passing in preferred params.

WalletConnect uses chain ids based on the CAIP standard (CAIP-13 for Polkadot Namespace): [Polkadot WalletConnect CAIP-13](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-13.md)

- polkadot CAIP id = `91b171bb158e2d3848fa23a9f1c25182`
- kusama CAIP id = `b0a8d493285c2df73290dfb7e61f870f`
- westend CAIP id = `e143f23803ac50e8f6f8e62695d1ce9e`
- statemint CAIP id = `68d56f15f85d3136970ec16946040bc1`
- hydradx CAIP id = `afdc188f45c71dacbaa0b62e16a91f72`
- phala network CAIP id = `1bb969d85965e4bb5a651abbedf21a54`
- astar network CAIP id = `9eb76c5184c4ab8679d2d5d819fdf90b`
- crust shadow CAIP id = `d4c0c08ca49dc7c680c3dac71a7c0703`
- mangata kusama mainnet CAIP id = `d611f22d291c5b7b69f1e105cca03352`
- turing network CAIP id = `0f62b701fb12d02237a33b84818c11f6`

- Chain ids correspond to the genesis hash for each respective chain

### Example Namespace and Sign Client connect call:

**Note**: this serves as an example where a dapp requires 3 different chain namespaces (polkadot, hydradx and turing network). The supported methods, chains, and events can all be defined by the dapp team based on the requirements of the dapp.

```js
const params = {
  requiredNamespaces: {
    polkadot: {
      methods: ['polkadot_signTransaction', 'polkadot_signMessage'],
      chains: [
        'polkadot:91b171bb158e2d3848fa23a9f1c25182', // polkadot
        'polkadot:afdc188f45c71dacbaa0b62e16a91f72', // hydradx
        'polkadot:0f62b701fb12d02237a33b84818c11f6' // turing network
      ],
      events: ['chainChanged", "accountsChanged']
    }
  }
}

const { uri, approval } = await provider.client.connect(params)
```

5. Create a standalone modal using your dapps WalletConnect projectId.

```js
const walletConnectModal = new WalletConnectModal({
  projectId: '2ea3f3ghubh32b8ie2f2'
})
```

6. Open the modal prompting the user to scan the QR code with their wallet app or copy the URI from the modal and paste into their wallet app to begin the session creation process.

```js
// if there is a URI from the client connect step open the modal
if (uri) {
  walletConnectModal.openModal({ uri })
}
// await session approval from the wallet app
const walletConnectSession = await approval()
```

7. Get the accounts from the session for use in constructing transactions.

```js
const walletConnectAccount = Object.values(walletConnectSession.namespaces)
  .map(namespace => namespace.accounts)
  .flat()

// grab account addresses from CAIP account formatted accounts
const accounts = wcAccounts.map(wcAccount => {
  const address = wcAccount.split(':')[2]
  return address
})
```

# Constructing Unsigned Transactions

One thing the dapp must do is properly construct the unsigned transaction. This consists of constructing an object with the intended chain‚Äôs metadata including the `specVersion`, `transactionVersion`, etc. In addition to these, you must provide the transaction data (`method`, `address` etc). Below is an example of what this general structure looks like using polkadotjs but this can be done in any valid way:

```js
const unsignedTransaction = {
  specVersion: api.runtimeVersion.specVersion.toHex(),
  transactionVersion: api.runtimeVersion.transactionVersion.toHex(),
  address: selectedWalletConnectAccountAddress,
  blockHash: lastHeader.hash.toHex(),
  blockNumber: blockNumber.toHex(),
  era: era.toHex(),
  genesisHash: api.genesisHash.toHex(),
  method: method.toHex(),
  nonce: nonce.toHex(),
  signedExtensions: [
    'CheckNonZeroSender',
    'CheckSpecVersion',
    'CheckTxVersion',
    'CheckGenesis',
    'CheckMortality',
    'CheckNonce',
    'CheckWeight',
    'ChargeTransactionPayment'
  ],
  tip: api.registry.createType('Compact<Balance>', 0).toHex(),
  version: tx.version
}
```

8. A specific example of constructing an unsigned transaction using polkadotjs api to retrieve the chains metadata.

```js
// import api and wsprovider
import { ApiPromise, WsProvider } from '@polkadot/api'

//instantiate wsProvider and api
const wsProvider = new WsProvider('wss://rpc.polkadot.io')
const api = await ApiPromise.create({ provider: wsProvider })

const lastHeader = await api.rpc.chain.getHeader()
const blockNumber = api.registry.createType('BlockNumber', lastHeader.number.toNumber())
const tx = api.tx.balances.transfer(keyring.bob.publicKey, 100)

const method = api.createType('Call', tx)
const era = api.registry.createType('ExtrinsicEra', {
  current: lastHeader.number.toNumber(),
  period: 64
})

const accountNonce = getBalanceAccount(submitAddress)?.nonce || 0
const nonce = api.registry.createType('Compact<Index>', accountNonce)

const unsignedTransaction = {
  specVersion: api.runtimeVersion.specVersion.toHex(),
  transactionVersion: api.runtimeVersion.transactionVersion.toHex(),
  address: selectedWalletConnectAccountAddress,
  blockHash: lastHeader.hash.toHex(),
  blockNumber: blockNumber.toHex(),
  era: era.toHex(),
  genesisHash: api.genesisHash.toHex(),
  method: method.toHex(),
  nonce: nonce.toHex(),
  signedExtensions: [
    'CheckNonZeroSender',
    'CheckSpecVersion',
    'CheckTxVersion',
    'CheckGenesis',
    'CheckMortality',
    'CheckNonce',
    'CheckWeight',
    'ChargeTransactionPayment'
  ],
  tip: api.registry.createType('Compact<Balance>', 0).toHex(),
  version: tx.version
}
```

# Sending unsigned transactions to the wallet for signing using WalletConnect

9. Send the unsigned transaction to the paired wallet for signing using the providers sign client. This triggers a `session_request` event which must be handled by the paired wallet.

### Polkadot Example

```js
const result = await client.request({
  chainId: 'polkadot:91b171bb158e2d3848fa23a9f1c25182',
  topic: walletConnectSession.topic,
  request: {
    method: 'polkadot_signTransaction',
    params: {
      address: selectedWalletConnectAddress,
      transactionPayload: unsignedTransaction
    }
  }
})
```

### Parachain Example (HydraDX)

```js
const result = await client.request({
  chainId: 'polkadot:afdc188f45c71dacbaa0b62e16a91f72',
  topic: walletConnectSession.topic,
  request: {
    method: 'polkadot_signTransaction',
    params: {
      address: selectedWalletConnectAddress,
      transactionPayload: unsignedTransaction
    }
  }
})
```

Once the request resolved, the expected response should be a result object which contains a signature

```js
{
  signature: '0x09u03f0h3nf34f0m3mn0fn34fn3f' // an example result
}
```

## Adding the signature to the ExtrinsicPayload

Using this signature, we can now create an `ExtrinsicPayload` and add the signature. Below is an example of this general step:

```js
// create the extrinsic payload using the unsigned transaction
const rawUnsignedTransaction = api.registry.createType('ExtrinsicPayload', unsignedTransaction, {
  version: unsignedTransaction.version
})

// add the signature to the extrinsic payload
tx.addSignature(selectedWalletConnectAddress, result.signature, rawUnsignedTransaction)
```

# Signing and sending the transaction to the node

Now, it is just about attaching the returned signature to the transaction and submitting it as specified by the dApp. Below is a specific example showing this process:

```js
const rawUnsignedTransaction = api.registry.createType('ExtrinsicPayload', unsignedTransaction, {
  version: unsignedTransaction.version
})

tx.addSignature(selectedWalletConnectAddress, result.signature, rawUnsignedTransaction)

// send the signed transaction to the node
const unsub = await tx.send(({ status, events }) => {
  // optionally handle ready status, notify user of submission
  if (status.isReady) {
    // ...
  }

  // optionally handle in block status, notify user of in block
  if (status.isInBlock) {
    // ...
  }

  // let user know outcome of transaction
  if (status.isFinalized) {
    events.forEach(({ event: { method } }) => {
      // if success optionally notify/update state
      if (method === 'ExtrinsicSuccess') {
        // ...
        unsub() // unsubscribe from extrinsic
      } else if (method === 'ExtrinsicFailed') {
        // on failure optionally notify/update state
        // ...
        unsub() // unsubscribe from extrinsic
      }
    })
  }
})
```
</file>

<file path="docs/advanced/multichain/polkadot/namespaces-guide.md">
# Namespaces Guide

## Guide Section Topics

- [Understanding Namespaces](#understanding-namespaces)
- [Proposal Namespaces](#proposal-namespaces)
- [Proposal Namespace Example](#proposal-namespace-example)
- [Session Namespaces](#session-namespaces)
- [Session Namespace Example](#session-namespace-example)
- [Chains](#chains), [Methods](#methods) and [Events](#events)
- [Using Namespaces with the Universal Provider](#dapps-universal-provider-and-namespaces)
- [Using Namespaces with the Web3Wallet](#wallets-web3wallet-and-namespaces)

### Understanding Namespaces

- Pairing sessions use specific methods, events and chains during their lifetimes. These arguments constitute what is known as a `namespace`.
- Namespaces are used to specify the chains, methods and events that are intended to be used in a particular session.
- They establish the minimal requirement for a wallet and a dapp to get paired. There are two types of namespaces, `proposal namespaces` and `session namespaces`.

### Proposal Namespaces

- A dapp sends a proposal namespace to the wallet for pairing. The proposal namespace contains the list of `chains`, `methods` and `events` that the dapp intends to make use of.
- The wallet validates if the received proposal namespaces are valid and returns a session with its approved namespaces as a response if it is valid along with the approved accounts for each chain in the namespace.
- If the requested proposal namespaces are not valid based on the wallets rules, the session cannot be established and the wallet rejects it with an error code that tells the dapp if the proposal namespaces have invalid chains, methods, events or if it was simply rejected by the user.

### Proposal Namespace Example

An example Proposal Namespace for a dapp which supports connecting to Polkadot, Ethereum, Polygon and Cosmos:

```js
{
  "polkadot": {
    "chains": [
        "polkadot:91b171bb158e2d3848fa23a9f1c25182", // Polkadot
        "polkadot:b0a8d493285c2df73290dfb7e61f870f", // Kusama
        ],
    "methods": ["polkadot_signMessage"],
    "events": ["accountsChanged"]
  },
  "eip155": {
    "chains": [
        "eip155:1",   // Ethereum
        "eip155:137"  // Polygon
        ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "chains": ["cosmos:cosmoshub-4"], // Cosmos
    "methods": ["cosmos_signDirect"],
    "events": ["someCosmosEvent"]
  }
}
```

### Session Namespaces

- The wallet validates if the received proposal namespaces match with the session namespaces it supports. If they match, a session is established successfully and pairing is completed. If not, the session is not established.
- The wallet session can also choose to provide access to more chains, methods or events that were not a part of the proposal namespaces. This means a dapp could send a proposal namespace with only Polkadot `['polkadot:91b171bb158e2d3848fa23a9f1c25182']` in its requiredNamespaces `chains` field but a wallet could return a session namespace with both Polkadot and Kusama `['polkadot:91b171bb158e2d3848fa23a9f1c25182','polkadot:b0a8d493285c2df73290dfb7e61f870f']` as part of the sessions namespaces.

### Session Namespace Example

```js
{
  "polkadot": {
    "accounts": [
        "polkadot:91b171bb158e2d3848fa23a9f1c25182:AZBEwbZhYeiofodZnM2iAoshP3pXRPNSJEKFqEPDmvv1mY7"
    ]
    "methods": ["polkadot_signMessage", "polkadot_signTransaction"],
    "events": ["accountsChanged"]
  },
  "eip155": {
    "accounts": [
      "eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb",
      "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"
    ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "accounts": [
      "cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"
    ],
    "methods": ["cosmos_signDirect", "personal_sign"],
    "events": ["someCosmosEvent", "proofFinalized"]
  }
}
```

### Chains

- `chains` is an array of chain ids which represent the chains the session will be using during its lifetime. For Polkadot, the format for each chain id is the chain agnostic namespace (e.g. `eip155`, `polkadot`, `cosmos` etc) followed by a colon and the genesis hash for the chain (e.g. `91b171bb158e2d3848fa23a9f1c25182` for Polkadot).
- A dapp or wallet can make as many or as few chain ids a part of its namespace as desired.

### Methods

- `methods` is represented as an array of wallet defined methods that a session supports.
- These are not pre-defined or centrally implemented and can be modified/extended as needed by a wallet.
- In the above Polkadot session namespace example there are two given methods `polkadot_signMessage` and `polkadot_signTransaction`. The idea for the functionality of these methods is to sign the relevant data (either a message or unsigned transaction) and return the signature. [An example for each method](https://github.com/WalletConnect/web-examples/blob/main/advanced/wallets/react-wallet-v2/src/lib/PolkadotLib.ts).
- If a dapp required additional method support such as receiving the signed hex for a transaction in order to submit it rather than the signature, a wallet only needs to define and add support for the method so that any dapp that requires that functionality can use it when making requests.
- An example would be adding a method named `polkadot_getSignedHex` and creating an implementation that signs, and returns the hash of the signed transaction.

```js
// Example Session Namespace
{
  "polkadot": {
    "accounts": [
        "polkadot:91b171bb158e2d3848fa23a9f1c25182:AZBEwbZhYeiofodZnM2iAoshP3pXRPNSJEKFqEPDmvv1mY7"
    ],
    "methods": [
        "polkadot_signMessage",
        "polkadot_signTransaction"
        "polkadot_getSignedHex",
    ],
    "events": ["accountsChanged"],
  }
 }

// In the wallets codebase, you'd add functionality to be called when this new method is called from a WalletConnect session
// Specific Example Implementation:

public async getSignedHex(payload: SignerPayloadJSON) {
    this.registry.setSignedExtensions(payload.signedExtensions)
    const txPayload = this.registry.createType('ExtrinsicPayload', payload, {
      version: payload.version
    });

    const { signature } = txPayload.sign(this.keypair)

    const extrinsic = registry.createType(
        'Extrinsic',
        { method: payload.method },
        { version: payload.version }
    );

    extrinsic.addSignature(unsigned.address, signature, unsigned);

    const hex = extrinsic.toHex();

    return { hex };
  }
```

- Wallets and dapps can define an agreed upon interface based on a particular chain or ecosystems needs.

### Events

- `events` represent specific changes in a sessions state that a dapp or wallet may want to take some action on.
- For example, a dapp or a wallet might want to perform some action if the user changes the selected session accounts. An example of emitting this event can be found below:

```js
await signClient.emit({
  topic,
  event: {
    name: 'accountsChanged',
    data: ['AZBEwbZhYeiofodZnM2iAoshP3pXRPNSJEKFqEPDmvv1mY7']
  },
  chainId: 'polkadot:91b171bb158e2d3848fa23a9f1c25182'
})
```

This can be useful in a wallet if a user is adding additional accounts to a session so that the wallet or dapp can respond and update their respective states using events such as `session_update` to update the accounts, chains, methods or events for the session or `session_delete` to end a session. [(More on events)](https://docs.walletconnect.com/specs/clients/sign/session-events#session_request).

### Using Namespaces

In order to creat a session proposal, call the connect method on the universal provider's sign client. The sign clients `connect` method accepts an object based on the following interface:

```js
interface ConnectParams {
  requiredNamespaces?: ProposalTypes.RequiredNamespaces;
  optionalNamespaces?: ProposalTypes.OptionalNamespaces;
  sessionProperties?: ProposalTypes.SessionProperties;
  pairingTopic?: string;
  relays?: RelayerTypes.ProtocolOptions[];
}
```

### Dapps: Universal Provider and Namespaces:

The connect method on the universal provider expects an object that matches the above `ConnectParams` interface. All fields are optional and in the below example we use only the `requiredNamespaces` field in our proposal namespace:

```js
const proposalNamespace = {
  requiredNamespaces: {
    polkadot: {
      methods: ['polkadot_signTransaction', 'polkadot_signMessage'],
      chains: ['polkadot:91b171bb158e2d3848fa23a9f1c25182'],
      events: ['chainChanged', 'accountsChanged']
    }
  }
}

// call connect on the universal provider passing the proposal namespace

const { uri, approval } = await provider.client.connect(proposalNamespace)
```

### Wallets: Web3Wallet and Namespaces:

When the web3wallet approves and creates a session, it must provide the session proposal `id` as well as the session `namespaces` which are approved for use in the session. An example of what this looks like is below.

```js
const session = await web3wallet.approveSession({
  id: proposal.id,
  namespaces: {
    polkadot: {
      accounts: [
        'polkadot:91b171bb158e2d3848fa23a9f1c25182:AZBEwbZhYeiofodZnM2iAoshP3pXRPNSJEKFqEPDmvv1mY7'
      ],
      methods: ['polkadot_signTransaction', 'polkadot_signMessage'],
      chains: ['polkadot:91b171bb158e2d3848fa23a9f1c25182'],
      events: ['chainChanged', 'accountsChanged']
    }
  }
})
```

More information on namespaces can be found [here](https://docs.walletconnect.com/specs/clients/sign/namespaces#controller-side-validation-of-incoming-proposal-namespaces-wallet).
</file>

<file path="docs/advanced/multichain/polkadot/wallet-integration-guide.md">
# Wallet Integration Guide

## Wallet Guide Section Topics

- WalletConnect Code/Component Setup
- Approving a Session Proposal
- Rejecting a Session Proposal
- Handling Session Request Events
- Session Persistence/Management

---

1. **Getting Started:** Generate a unique `projectId` by visiting and creating your project's profile on WalletConnect's project dashboard at:
   - `https://cloud.walletconnect.com/`

# WalletConnect Code/Component Setup

2. Import Core and Web3Wallet from WalletConnect.

```js
import { Core } from '@walletconnect/core'
import { Web3Wallet } from '@walletconnect/web3wallet'
```

3. Instantiate and add Core and Web3Wallet to the state of the wallet.

```js
const core = new Core({ projectId: 'fgu234234njbhvhv23525bj' })
const web3wallet = await Web3Wallet.init({
  core: core,
  metadata: {
    name: 'Example WalletConnect Wallet',
    description: 'Example WalletConnect Integration',
    url: 'myexamplewallet.com',
    icons: []
  }
})
```

4. Create a function to accept a session `uri` which will be passed from a dapp when a user either scans the dapp's WalletConnect qrcode modal or manually copies and pastes the uri from the modal into the wallet's UI.

```js
const onConnect = async (uri: string) => {
  // call web3wallet.core.pairing.pair( { uri: uri })
  // with the uri received from the dapp in order to emit the
  // `session_proposal` event
  const result = await web3wallet.core.pairing.pair({ uri })
}
```

5. Handle the `session_proposal` event on the `web3wallet`. This event is triggered when the `pair` method is called on `web3wallet.core.pairing` to create a pairing session.

# Approving a Session Proposal (Example)

When approving a session proposal, the wallet can perform any necessary checks such as ensuring that the proposal includes all required namespaces and any optional namespaces. The approval response also contains the approved accounts as part of the namespace. Below is an example showing the format for wallet accounts and how to include them in a session proposal approval.

```js
// example account addresses in wallet state
const substrateAccounts = [
  '5CK8D1sKNwF473wbuBP6NuhQfPaWUetNsWUNAAzVwTfxqjfr',
  '5F3sa2TJAWMqDhXG6jhV4N8ko9SxwGy8TpaNS1repo5EYjQX'
]

// format the accounts to match the chain:chain_id:address format
const walletConnectAccounts = accounts.map(
  account => `polkadot:91b171bb158e2d3848fa23a9f1c25182:${account.address}`
)

web3wallet.on('session_proposal', async proposal => {
  // optionally show user a modal or way to reject or approve session
  showWalletConnectModal()

  // handle user approval case

  // create the approved session with selected accounts, supported methods, chains and events for your wallet
  const session = await web3wallet.approveSession({
    id: proposal.id,
    namespaces: {
      polkadot: {
        accounts: walletConnectAccounts,
        methods: ['polkadot_signTransaction', 'polkadot_signMessage'],
        chains: ['polkadot:91b171bb158e2d3848fa23a9f1c25182'],
        events: ['chainChanged", "accountsChanged']
      }
    }
  })

  // create response object
  const response = { id: proposal.id, result: 'session approved', jsonrpc: '2.0' }

  // respond to the dapp request with the approved session's topic and response
  await web3wallet.respondSessionRequest({ topic: session.topic, response })
})
```

# Rejecting a Session Proposal (Example)

If the user does not approve the requested chains, methods, or accounts, or if the wallet does not support the requested chains or methods, the response should not be considered a success. Below is an example of rejecting a session proposal.

```js
// Note: session_request is emitted when the client on the dapp end calls the request method
// import getSdkError to create predefined ErrorResponse types
import { getSdkError } from '@walletconnect/utils'

web3wallet.on('session_proposal', async proposal => {
  // optionally show user a modal or way to reject or approve session
  showWalletConnectModal()

  // handle user reject action
  await web3wallet.rejectSession({
    id: proposal.id,
    reason: getSdkError('USER_REJECTED')
  })
})
```

# Handling Session Request Event

A dapp triggers an event when it requires the wallet to carry out a specific action, such as signing a transaction. The event includes a topic and a request object, which will differ based on the requested action. As seen in the [WalletConnect Web Examples](https://github.com/WalletConnect/web-examples/blob/main/advanced/wallets/react-wallet-v2/src/lib/PolkadotLib.ts), two common use cases in polkadot are signing messages and signing transactions. These methods are represented here as `polkadot_signMessage` and `polkadot_signTransaction` respectively and each simply signs the respective payload and returns the signature to the dapp. An example of a `session_request` event handler containing both can be found below.

```js
web3wallet.on('session_request', async requestEvent => {
  const { params, id } = requestEvent
  const { request } = params
  const address = request.params?.address

  // check that the request address is in your users list of wallets
  // Example:
  const wallet = getPolkadotWallet(address) //

  if (!wallet) {
    throw new Error('Polkadot wallet does not exist')
  }

  // handle supported methods (polkadot_signMessage, polkadot_signTransaction)
  switch (request.method) {
    case 'polkadot_signMessage':
      // call function used by wallet to sign message and return the signature
      const signature = await yourwallet.signMessage(request.params.message)

      // create the response containing the signature in the result
      const response = { id, result: { signature: signature }, jsonrpc: '2.0' }

      // respond to the dapp request with the response and topic
      await web3wallet.respondSessionRequest({ topic, response })

    case 'polkadot_signTransaction':
      // call function used by wallet to sign transactions and return the signature
      const signature = await yourwallet.signTransaction(request.params.transactionPayload)

      // create the response containing the signature in the result
      const response = { id, result: { signature: signature }, jsonrpc: '2.0' }

      // respond to the dapp request with the response and topic
      await web3wallet.respondSessionRequest({ topic, response })

    // throw error for methods your wallet doesn't support
    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
})
```

# Sessions Persistence/Management

- sessions can be saved/stored so users dont have to pair repeatedly
- sessions can be disconnected from using `await web3wallet.disconnectSession({ topic: topic });` passing the session topic.
- sessions can be extended using `await web3wallet.extendSession({ topic: topic });` passing the session topic.
- Default session lifetime is 7 days for WalletConnect v2.0.

# Further Documentation for WalletConnect 2.0

- https://docs.walletconnect.com/
</file>

<file path="docs/advanced/multichain/rpc-reference/bitcoin-rpc.md">
---
description: Bitcoin JSON-RPC Methods
---

# Bitcoin
We define an account as the group of addresses derived using the same account value in their [derivation paths](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#user-content-Path_levels). We use the first address of the [external chain](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#examples) ("first external address"), as the identifier for an account. An account's total balance is defined as the sum of all unspent transaction outputs (UTXOs) belonging to its entire group of addresses.

1. Dapps **must** only display the first external address as a connected account.
2. Wallets **must** only offer to connect the first external address(es).

#### Account Definition
The derivation path levels in the [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#path-levels), [BIP49](https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki#user-content-Public_key_derivation), [BIP84](https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki#public-key-derivation), [BIP86](https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki#user-content-Public_key_derivation) standards are: 
```
m / purpose' / coin_type' / account' / change / address_index
```

Addresses with different `purpose`, `change` and `address_index` values are considered to belong to the same account. Valid `purpose` values are 44, 49, 84 and 86. We use the first external Native SegWit (purpose = 84) address as the default account identifier.

For a specific seed phrase and path `m/84'/0'/0'/0/0` we get account 0 with identifier `bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu`. Its total balance is the sum of all UTXO balances on all addresses with derivation paths:
* `m/44'/0'/0'/change/address_index`
* `m/49'/0'/0'/change/address_index`
* `m/84'/0'/0'/change/address_index`
* `m/86'/0'/0'/change/address_index`

If the wallet user changes to account 1 we get path `m/84'/0'/1'/0/0` with identifier `bc1qku0qh0mc00y8tk0n65x2tqw4trlspak0fnjmfz`. Its total balance is the sum of all UTXO balances on all addresses with derivation paths:
* `m/44'/0'/1'/change/address_index`
* `m/49'/0'/1'/change/address_index`
* `m/84'/0'/1'/change/address_index`
* `m/86'/0'/1'/change/address_index`

## sendTransfer
This method is used to sign and submit a transfer of any `amount` of Bitcoin to a single `recipientAddress`, optionally including a `changeAddress` for the change amount and `memo` set as an OP_RETURN output by supporting wallets. The transaction will be signed and broadcast upon user approval.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `recipientAddress` : `String` - _(Required)_ The recipient's public address.
    * `amount` : `String` - _(Required)_ The amount of Bitcoin to send, denominated in satoshis (Bitcoin base unit).
    * `changeAddress` : `String` - _(Optional)_ The sender's public address to receive change.
    * `memo` : `String` - _(Optional)_ The OP_RETURN value as a hex string without 0x prefix, maximum 80 bytes.

### Returns
* `Object` 
    * `txid` : `String` - _(Required)_ The transaction id as a hex string without 0x prefix.

### Example
The example below specifies a simple transfer of 1.23 BTC (123000000 Satoshi).

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "sendTransfer",
    "params": {
        "account": "bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu",
        "recipientAddress": "bc1pmzfrwwndsqmk5yh69yjr5lfgfg4ev8c0tsc06e",
        "amount": "123000000",
        "memo": "636861726c6579206c6f766573206865"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": {
        "txid": "f007551f169722ce74104d6673bd46ce193c624b8550889526d1b93820d725f7"
    }
}
```

## getAccountAddresses
This method returns all current addresses needed for a dapp to fetch all UTXOs, calculate the total balance and prepare transactions. Dapps will typically use an indexing service to query for balances and UTXOs for all addresses returned by this method, such as:
* [Blockbook API](https://github.com/trezor/blockbook/blob/master/docs/api.md#get-address)
* [Bitcore API](https://github.com/bitpay/bitcore/blob/master/packages/bitcore-node/docs/api-documentation.md#address)

We recognize that there are two broad classes of wallets in use today:
1. Wallets that generate a new change or receive address for every transaction ("dynamic wallet").
2. Wallets that reuse the first external address for every transaction ("static wallet").

#### Implementation Details
* All wallets **should** include the first external address and all addresses with one or more UTXOs, unless they're filtered by `intentions`.
* Dynamic wallets **should** include minimum 2 unused change and receive addresses. Otherwise dapps may have to request [getAccountAddresses](#getAccountAddresses) after every transaction to discover the new addresses and keep track of the user's total balance.
* All wallets **must** return fewer than 20 unused change and receive addresses to avoid breaking the [gap limit](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#address-gap-limit).

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `intentions` : `String[]` - _(Optional)_ Filter what addresses to return, e.g. "payment" or "ordinal".

### Returns
* `Array`
    * `Object`
        * `address` : `String` - _(Required)_ Public address belonging to the account.
        * `publicKey` : `String` - _(Optional)_ Public key for the derivation path in hex, without 0x prefix.
        * `path` : `String` - _(Optional)_ Derivation path of the address e.g. "m/84'/0'/0'/0/0".
        * `intention` : `String` - _(Optional)_ Intention of the address, e.g. "payment" or "ordinal".

### Example: Dynamic Wallet
The example below specifies a result from a dynamic wallet. For the sake of this example, receive and change addresses with index 3-4 are considered unused and addresses with paths `m/49'/0'/0'/0/7` and `m/84'/0'/0'/0/2` are considered to have UTXOs.

Assuming the dapp monitors all returned addresses for balance changes, a new request to `getAccountAddresses` is only needed when all UTXOs in provided addresses have been spent, or when all provided `receive` addresses or `change` addresses have been used.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "getAccountAddresses",
    "params": {
        "account": "bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        {
            "address": "bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu",
            "publicKey": "0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c",
            "path": "m/84'/0'/0'/0/0"
        },
        {
            "address": "3KHhcgwPgYF9hE77zaKy2G36dpkcNtvQ33",
            "publicKey": "03b90230ca20150142bc2849a3df4517073978f32466214a0ebc00cac52f996989",
            "path": "m/49'/0'/0'/0/7"
        },
        {
            "address": "bc1qp59yckz4ae5c4efgw2s5wfyvrz0ala7rgvuz8z",
            "publicKey": "038ffea936b2df76bf31220ebd56a34b30c6b86f40d3bd92664e2f5f98488dddfa",
            "path": "m/84'/0'/0'/0/2"
        },
        {
            "address": "bc1qgl5vlg0zdl7yvprgxj9fevsc6q6x5dmcyk3cn3",
            "publicKey": "03de7490bcca92a2fb57d782c3fd60548ce3a842cad6f3a8d4e76d1f2ff7fcdb89",
            "path": "m/84'/0'/0'/0/3"
        },
        {
            "address": "bc1qm97vqzgj934vnaq9s53ynkyf9dgr05rargr04n",
            "publicKey": "03995137c8eb3b223c904259e9b571a8939a0ec99b0717684c3936407ca8538c1b",
            "path": "m/84'/0'/0'/0/4"
        },
        {
            "address": "bc1qv6vaedpeke2lxr3q0wek8dd7nzhut9w0eqkz9z",
            "publicKey": "03d0d243b6a3176fa20fa95cd7fb0e8e0829b83fc2b52053633d088c1a4ba91edf",
            "path": "m/84'/0'/0'/1/3"
        },
        {
            "address": "bc1qetrkzfslk0d4kqjnu29fdh04tkav9vj3k36vuh",
            "publicKey": "02a8dee7573bcc7d3c1e9b9e267dbf0cd717343c31d322c5b074a3a97090a0d952",
            "path": "m/84'/0'/0'/1/4"
        }
    ]
}
```

### Example: Static Wallet
The example below specifies a response from a static wallet. The returned address is used for both change and payments. It's the only address with UTXOs.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "getAccountAddresses",
    "params": {
        "account": "bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        {
            "address": "bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu",
            "publicKey": "0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c",
            "path": "m/84'/0'/0'/0/0"
        }
    ]
}
```

## signPsbt
This method can be used to request the signature of a Partially Signed Bitcoin Transaction (PSBT) and covers use-cases e.g. involving multiple-recipient transactions, requiring granular control over which UTXOs to spend or how to route change.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `psbt` : `String` - _(Required)_ Base64 encoded string of the PSBT to sign.
    * `signInputs` : `Array`
        * `Object`
            * `address` : `String` - _(Required)_ The address whose private key to use for signing.
            * `index` : `Integer` - _(Required)_ Specifies which input to sign.
            * `sighashTypes` : `Integer[]` - _(Optional)_ Specifies which part(s) of the transaction the signature commits to. Default is `[1]`.
    * `broadcast` : `Boolean` - _(Optional)_ Whether to broadcast the transaction after signing it. Default is `false`.

### Returns
* `Object`
    * `psbt` : `String` - _(Required)_ The base64 encoded signed PSBT.
    * `txid` : `String` - _(Optional)_ The transaction ID as a hex-encoded string, without 0x prefix. This must be returned if the transaction was broadcasted.

## signMessage
This method is used to sign a message with one of the connected account's addresses.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `message` : `String` - _(Required)_ The message to be signed by the wallet.
    * `address` : `String` - _(Optional)_ The address whose private key to use for signing the message.
    * `protocol` : `"ecdsa" | "bip322"` - _(Optional)_ Preferred signature type. Default is `"ecdsa"`.

### Returns
* `Object`
    * `address` : `String` - _(Required)_ The Bitcoin address used to sign the message.
    * `signature` : `String` - _(Required)_ Hex encoded bytes of the signature, without 0x prefix.
    * `messageHash` : `String` - _(Optional)_ Hex encoded bytes of the message hash, without 0x prefix.


## Events
### bip122_addressesChanged
This event is used by wallets to notify dapps about connected accounts' current addresses, for example all addresses with a UTXO and a few unused addresses. The event data has the same format as the [getAccountAddresses](#getaccountaddresses) result.

#### Implementation Details
* Wallets **should** emit a `bip122_addressesChanged` event immediately after connection approval of a BIP122 chain.
* Wallets **should** emit a `bip122_addressesChanged` event whenever a UTXO is spent or created for a connected account's addresses.
* Dapps **should** listen for `bip122_addressesChanged` events, collect and monitor all addresses for UTXO and balance changes.

Example [session_event](https://specs.walletconnect.com/2.0/specs/clients/sign/session-events#session_event) payload as received by a dapp:
```
{
  "id": 1675759795769537,
  "topic": "95d6aca451b8e3c6d9d176761bf786f1cc0a6d38dffd31ed896306bb37f6ae8d",
  "params": {
    "event": {
      "name": "bip122_addressesChanged",
      "data": [
        {
          "address": "bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu",
          "publicKey": "0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c",
          "path": "m/84'/0'/0'/0/0"
        },
        {
          "address": "3KHhcgwPgYF9hE77zaKy2G36dpkcNtvQ33",
          "publicKey": "03b90230ca20150142bc2849a3df4517073978f32466214a0ebc00cac52f996989",
          "path": "m/49'/0'/0'/0/7"
        },
        {
          "address": "bc1qp59yckz4ae5c4efgw2s5wfyvrz0ala7rgvuz8z",
          "publicKey": "038ffea936b2df76bf31220ebd56a34b30c6b86f40d3bd92664e2f5f98488dddfa",
          "path": "m/84'/0'/0'/0/2"
        },
        {
          "address": "bc1qgl5vlg0zdl7yvprgxj9fevsc6q6x5dmcyk3cn3",
          "publicKey": "03de7490bcca92a2fb57d782c3fd60548ce3a842cad6f3a8d4e76d1f2ff7fcdb89",
          "path": "m/84'/0'/0'/0/3"
        },
        {
          "address": "bc1qm97vqzgj934vnaq9s53ynkyf9dgr05rargr04n",
          "publicKey": "03995137c8eb3b223c904259e9b571a8939a0ec99b0717684c3936407ca8538c1b",
          "path": "m/84'/0'/0'/0/4"
        },
        {
          "address": "bc1qv6vaedpeke2lxr3q0wek8dd7nzhut9w0eqkz9z",
          "publicKey": "03d0d243b6a3176fa20fa95cd7fb0e8e0829b83fc2b52053633d088c1a4ba91edf",
          "path": "m/84'/0'/0'/1/3"
        },
        {
          "address": "bc1qetrkzfslk0d4kqjnu29fdh04tkav9vj3k36vuh",
          "publicKey": "02a8dee7573bcc7d3c1e9b9e267dbf0cd717343c31d322c5b074a3a97090a0d952",
          "path": "m/84'/0'/0'/1/4"
        }
      ]
    },
    "chainId": "bip122:000000000019d6689c085ae165831e93"
  }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/casper-rpc.md">
# Casper

## Methods

### casper_sign_deploy

Use the `casper_sign_deploy` method to request the user to approve or reject the signature of a transaction (aka deploy). The wallet should validate the received deploy object and present the details to the user for his review.

#### Parameters

- `address`. Type: `string`. The chain namespace and the public key corresponding to the key pair that signs the transaction separated with a colon character.
- `deploy`. Type: `object`. A Deploy object as per the Casper protocol specificatio.

#### Returns

- `deploy`. Type: `object`. The Deploy object including the newly generated approval item as per the Casper protocol specification.

If the user rejects the signature, the wallet returns the WalletConnect SDK error `USER_REJECTED`.

#### Example

Request:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "casper_sign_deploy",
  "params": {
    "deploy": {
      "hash": "a3301c9da7f0183f1c8904bed7fc72cf563454509462cada378b3f42a92f7b4f",
      "header": {
        "account": "02032E126170e5f28443775330B5B5Fe29dCE1a1dD3269910349525935ccbaf352EA",
        "timestamp": "2024-02-01T08:41:59.207Z",
        "ttl": "30m",
        "gas_price": 1,
        "body_hash": "188d88eedd3dc64b4ac3f8ca9b74be2b2fa588e2d537875d22b7e1a68658d19e",
        "dependencies": [],
        "chain_name": "casper-test"
      },
      "payment": {
        "ModuleBytes": {
          "module_bytes": "",
          "args": [["amount", { "bytes": "0400e1f505", "cl_type": "U512" }]]
        }
      },
      "session": {
        "Transfer": {
          "args": [
            ["amount", { "bytes": "0500f2052a01", "cl_type": "U512" }],
            [
              "target",
              {
                "bytes": "0202e99759649fa63a72c685b72e696b30c90f1deabb02d0d9b1de45eb371a73e5bb",
                "cl_type": "PublicKey"
              }
            ],
            ["id", { "bytes": "01d204000000000000", "cl_type": { "Option": "U64" } }]
          ]
        }
      },
      "approvals": []
    },
    "address": "casper:casper-test:02032E126170e5f28443775330B5B5Fe29dCE1a1dD3269910349525935ccbaf352EA"
  }
}
```

Response:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "deploy": {
      "hash": "a3301c9da7f0183f1c8904bed7fc72cf563454509462cada378b3f42a92f7b4f",
      "header": {
        "account": "02032E126170e5f28443775330B5B5Fe29dCE1a1dD3269910349525935ccbaf352EA",
        "timestamp": "2024-02-01T08:41:59.207Z",
        "ttl": "30m",
        "gas_price": 1,
        "body_hash": "188d88eedd3dc64b4ac3f8ca9b74be2b2fa588e2d537875d22b7e1a68658d19e",
        "dependencies": [],
        "chain_name": "casper-test"
      },
      "payment": {
        "ModuleBytes": {
          "module_bytes": "",
          "args": [["amount", { "bytes": "0400e1f505", "cl_type": "U512" }]]
        }
      },
      "session": {
        "Transfer": {
          "args": [
            ["amount", { "bytes": "0500f2052a01", "cl_type": "U512" }],
            [
              "target",
              {
                "bytes": "0202e99759649fa63a72c685b72e696b30c90f1deabb02d0d9b1de45eb371a73e5bb",
                "cl_type": "PublicKey"
              }
            ],
            ["id", { "bytes": "01d204000000000000", "cl_type": { "Option": "U64" } }]
          ]
        }
      },
      "approvals": [
        {
          "signer": "02032E126170e5f28443775330B5B5Fe29dCE1a1dD3269910349525935ccbaf352EA",
          "signature": "02ad07c25d7cef27598f67c7bafce3e07e4198de7884f0e48041965c0f0be2690956d25bae0510bec9463da4aa6a5e591fb3cb88c8f31df85bc0b6f857b80f64e2"
        }
      ]
    }
  }
}
```

### casper_sign_message

Use `casper_sign_message` to request the user to sign a message. It's recommended to use this method with human-readable text messages. Upon user approval, the wallet must generate a signature for the prefixed message `"Casper Message:\n" + message`. The prefix protects the user against misuse of this method, preventing a malicious actor from trying to trick the user into signing arbitrary data, like a network transaction.

#### Parameters

- `address`. Type: `string`. The chain namespace and the public key corresponding to the key pair that signs the transaction separated with a colon character.
- `message`. Type: `string`. The message to be signed.

#### Returns

- `signature`. Type: `string`. The signature of the message.

If the user rejects the signature, the wallet returns the WalletConnect SDK error `USER_REJECTED`.

#### Example

Request:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "casper_sign_message",
  "params": {
    "message": "CSPR.studio wants you to sign in with your Casper account:\n0x01953...808f3 \n\nIssued At: 07/21/2023 10:07:25\nnonce: 428b62e4",
    "address": "casper:casper-test:0202a8e3e5E32800792F37F738d95BF2610d86E97922D13ab97945bb062824ed9E8A"
  }
}
```

Response:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "casper_sign_message",
  "result": {
    "signature": "b52482afd2392b715cc43d9ad9f1f7067752a10ba5b49b89bc61b398e478841e6d8a4a224aeb944a34f23d98a232cdab6e5a60a5e886e8b0719d7b84277c405f"
  }
}
```

## Events

Currently, this specification doesn't define any required events for wallets.
</file>

<file path="docs/advanced/multichain/rpc-reference/cosmos-rpc.md">
---
description: Cosmos JSON-RPC Methods
---

# Cosmos

## cosmos_getAccounts

This method returns an array of key pairs available to sign from the wallet mapped with an associated algorithm and address on the blockchain.

### Parameters

    none

### Returns

    1.`Array` - Array of accounts:
    	1.1. `Object` - Account Data object with parameters:
    		1.1.1. `algo` : `STRING` - algorithm used for signing
    		1.1.2. `address` : `STRING` - corresponding address for keypair
    		1.1.3. `pubkey` : `STRING` - base64 encoded public key for keypair

### Example

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "cosmos_getAccounts",
    "params": {}
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result":  [
        {
            "algo": "secp256k1",
            "address": "cosmos1sguafvgmel6f880ryvq8efh9522p8zvmrzlcrq",
            "pubkey": "AgSEjOuOr991QlHCORRmdE5ahVKeyBrmtgoYepCpQGOW"
        }
    ]
}
```

## cosmos_signDirect

This method returns a signature for the provided document to be signed targeting the requested signer address corresponding to the keypair returned by the account data.

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `signerAddress` : `STRING` -  corresponding address for keypair
    	1.2. `signDoc` : `Object` - Document to be signed:
    		1.2.2. `chainId` : `STRING` - identifier of blockchain
    		1.2.1. `accountNumber` : `STRING` - blockchain account number
    		1.2.3. `authInfoBytes` : `DATA` - encoded authentication information
    		1.2.4. `bodyBytes` : `DATA` - encoded body of message to sign

### Returns

    1. `Object` - Signing parameters:
    	1.1. `signature` : `Object` -  corresponding signature for signed documented
            1.1.1. `pub_key` : `Object` - public key for keypair
                1.1.1.1: `type` : `STRING` - type of public key
                1.1.1.2: `value` : `STRING` - value of public key
            1.1.2. `signature`: `STRING` - corresponding signature for signed documented
    	1.2. `signed` : `Object` - Signed document:
    		1.2.2. `chainId` : `STRING` - identifier of blockchain
    		1.2.1. `accountNumber` : `STRING` - blockchain account number
    		1.2.3. `authInfoBytes` : `DATA` - encoded authentication information
    		1.2.4. `bodyBytes` : `DATA` - encoded body of message to sign

### Example

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "cosmos_signDirect",
    "params": {
        "signerAddress": "cosmos1sguafvgmel6f880ryvq8efh9522p8zvmrzlcrq",
        "signDoc":  {
            "chainId": "cosmoshub-4",
            "accountNumber": "1"
            "authInfoBytes": "CgoKABIECgIIARgBEhMKDQoFdWNvc20SBDIwMDAQwJoM",
            "bodyBytes": "CpABChwvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kEnAKLWNvc21vczFwa3B0cmU3ZmRrbDZnZnJ6bGVzamp2aHhobGMzcjRnbW1rOHJzNhItY29zbW9zMXF5cHF4cHE5cWNyc3N6ZzJwdnhxNnJzMHpxZzN5eWM1bHp2N3h1GhAKBXVjb3NtEgcxMjM0NTY3"
        }
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result":  {
        "signature": {
            "pub_key": {
                "type": "tendermint/PubKeySecp256k1",
                "value": "AgSEjOuOr991QlHCORRmdE5ahVKeyBrmtgoYepCpQGOW"
            },
            "signature": "AnTrXtS2lr9CBwhTpRa8ZlKcVR9PeIXGaTpvodyJU05QvRKVjIkQfOZl5JhdkfxCY+a6rhwCOYVcbKQTJlMw4w=="
        },
        "signed": {
            "chainId": "cosmoshub-4",
            "accountNumber": "1"
            "authInfoBytes": "CgoKABIECgIIARgBEhMKDQoFdWNvc20SBDIwMDAQwJoM",
            "bodyBytes": "CpABChwvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kEnAKLWNvc21vczFwa3B0cmU3ZmRrbDZnZnJ6bGVzamp2aHhobGMzcjRnbW1rOHJzNhItY29zbW9zMXF5cHF4cHE5cWNyc3N6ZzJwdnhxNnJzMHpxZzN5eWM1bHp2N3h1GhAKBXVjb3NtEgcxMjM0NTY3"
        }
    }
}
```

## cosmos_signAmino

This method returns a signature for the provided document to be signed targeting the requested signer address corresponding to the keypair returned by the account data.

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `signerAddress` : `STRING` -  corresponding address for keypair
    	1.2. `signDoc` : `Object` - Document to be signed:
    		1.2.2. `chain_id` : `STRING` - identifier of blockchain
    		1.2.1. `account_number` : `STRING` - blockchain account number
    		1.2.3. `sequence` : `STRING` - blockchain account sequence
    			1.2.4. `memo` : `STRING` - amino message memo
    		1.2.5. `msgs` : `Array` - array of amino messages to be signed:
    			1.2.5.1. `Object` - amino message object:
    				1.2.5.1.1. - `type` : `STRING` - amino message type
    				1.2.5.1.2. - `value` : `STRING` - amino message value
    		1.2.6. `fee` : `Object` - fee description object
    				1.2.6.1. `amount` : `Array` - array of currency fees:
    					1.2.6.1.1. `Object` - currency fee description object:
    						1.2.6.1.1.1. `denom` : `STRING` - currency denomination
    						1.2.6.1.1.2. `amount` : `STRING` - currency amount
    				1.2.6.2. `gas` : `STRING` - gas limit for execution

### Returns

    1. `Object` - Signing parameters:
    	1.1. `signature` : `Object` -  corresponding signature for signed documented
            1.1.1. `pub_key` : `Object` - public key for keypair
                1.1.1.1: `type` : `STRING` - type of public key
                1.1.1.2: `value` : `STRING` - value of public key
            1.1.2. `signature`: `STRING` - corresponding signature for signed documented
    	1.2. `signed` : `Object` - Signed document:
    		1.2.2. `chain_id` : `STRING` - identifier of blockchain
    		1.2.1. `account_number` : `STRING` - blockchain account number
    		1.2.3. `sequence` : `STRING` - blockchain account sequence
    			1.2.4. `memo` : `STRING` - amino message memo
    			1.2.5. `msgs` : `Array` - array of amino messages to be signed:
    			1.2.5.1. `Object` - amino message object:
    				1.2.5.1.1. - `type` : `STRING` - amino message type
    				1.2.5.1.2. - `value` : `STRING` - amino message value
    		1.2.6. `fee` : `Object` - fee description object
    				1.2.6.1. `amount` : `Array` - array of currency fees:
    					1.2.6.1.1. `Object` - currency fee description object:
    						1.2.6.1.1.1. `denom` : `STRING` - currency denomination
    						1.2.6.1.1.2. `amount` : `STRING` - currency amount
    				1.2.6.2. `gas` : `STRING` - gas limit for execution

### Example

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "cosmos_signAmino",
    "params": {
        "signerAddress": "cosmos1sguafvgmel6f880ryvq8efh9522p8zvmrzlcrq",
        "signDoc": {
            "chain_id": "foochain",
            "account_number": "7",
            "sequence": "54"
            "memo": "hello, world",
            "msgs": [],
            "fee": { "amount": [], "gas": "23" }
        }
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result":  {
        "signature": {
            "pub_key": {
                "type": "tendermint/PubKeySecp256k1",
                "value": "AgSEjOuOr991QlHCORRmdE5ahVKeyBrmtgoYepCpQGOW"
            },
            "signature": "AnTrXtS2lr9CBwhTpRa8ZlKcVR9PeIXGaTpvodyJU05QvRKVjIkQfOZl5JhdkfxCY+a6rhwCOYVcbKQTJlMw4w=="
        },
        "signed": {
            "chain_id": "foochain",
            "account_number": "7",
            "sequence": "54"
            "memo": "hello, world",
            "msgs": [],
            "fee": { "amount": [{"denom": "ufoo", "amount": "10000"}], "gas": "23" }
        }
    }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/dogecoin-rpc.md">
---
description: Dogecoin JSON-RPC Methods
---

# Dogecoin
We define an account as the group of addresses derived using the same account value in their [derivation paths](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#user-content-Path_levels). We use the first address of the [external chain](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#examples) ("first external address"), as the identifier for an account. An account's total balance is defined as the sum of all unspent transaction outputs (UTXOs) belonging to its entire group of addresses.

1. Dapps **must** only display the first external address as a connected account.
2. Wallets **must** only offer to connect the first external address(es).

#### Account Definition
The derivation path levels in the [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#path-levels) standard is: 
```
m / purpose' / coin_type' / account' / change / address_index
```

Addresses with different `purpose`, `change` and `address_index` values are considered to belong to the same account. We use the first external P2PKH (purpose = 44) address as the default account identifier.

For a specific seed phrase and path `m/44'/3'/0'/0/0` we get account 0 with identifier `DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ`. Its total balance is the sum of all UTXO balances on all addresses with derivation paths:
* `m/44'/3'/0'/change/address_index`

If the wallet user changes to account 1 we get path `m/44'/3'/1'/0/0` with identifier `DBcZSePDaMMduBMLymWHXhkE5ArFEvkagU`. Its total balance is the sum of all UTXO balances on all addresses with derivation paths:
* `m/44'/3'/1'/change/address_index`

## sendTransfer
This method is used to sign and submit a transfer of any `amount` of Dogecoin to a single `recipientAddress`, optionally including a `changeAddress` for the change amount and `memo` set as the OP_RETURN value by supporting wallets. The transaction will be signed and broadcast upon user approval.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `recipientAddress` : `String` - _(Required)_ The recipient's public address.
    * `amount` : `String` - _(Required)_ The amount of Dogecoin to send, denominated in satoshis (Dogecoin base unit).
    * `changeAddress` : `String` - _(Optional)_ The sender's public address to receive change.
    * `memo` : `String` - _(Optional)_ The OP_RETURN value as a hex string without 0x prefix, maximum 80 bytes.

### Returns
* `Object` 
    * `txid` : `String` - The transaction id as a hex string without 0x prefix.

### Example
The example below specifies a simple transfer of 1.23 DOGE (123000000 Satoshi).

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "sendTransfer",
    "params": {
        "account": "DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ",
        "recipient": "DBcZSePDaMMduBMLymWHXhkE5ArFEvkagU",
        "amount": "123000000",
        "memo": "636861726c6579206c6f766573206865"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": {
        "txid": "f007551f169722ce74104d6673bd46ce193c624b8550889526d1b93820d725f7"
    }
}
```

## getAccountAddresses
This method returns all current addresses needed for a dapp to fetch all UTXOs, calculate the total balance and prepare transactions. Dapps will typically use an indexing service to query for balances and UTXOs for all addresses returned by this method, such as:
* [Blockbook API](https://github.com/trezor/blockbook/blob/master/docs/api.md#get-address)
* [Bitcore API](https://github.com/bitpay/bitcore/blob/master/packages/bitcore-node/docs/api-documentation.md#address)

We recognize that there are two broad classes of wallets in use today:
1. Wallets that generate a new change or receive address for every transaction ("dynamic wallet").
2. Wallets that reuse the first external address for every transaction ("static wallet").

#### Implementation Details
* All wallets **should** include the first external address and all addresses with one or more UTXOs, unless they're filtered by `intentions`.
* Dynamic wallets **should** include minimum 2 unused change and receive addresses. Otherwise dapps may have to request [getAccountAddresses](#getAccountAddresses) after every transaction to discover the new addresses and keep track of the user's total balance.
* All wallets **must** return fewer than 20 unused change and receive addresses to avoid breaking the [gap limit](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#address-gap-limit).

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `intentions` : `String[]` - _(Optional)_ Filter what addresses to return, e.g. "payment" or "ordinal".

### Returns
* `Array`
    * `Object`
        * `address` : `String` - _(Required)_ Public address belonging to the account.
        * `publicKey` : `String` - _(Optional)_ Public key for the derivation path in hex, without 0x prefix.
        * `path` : `String` - _(Optional)_ Derivation path of the address e.g. "m/44'/3'/0'/0/0".
        * `intention` : `String` - _(Optional)_ Intention of the address, e.g. "payment" or "ordinal".

### Example: Dynamic Wallet
The example below specifies a result from a dynamic wallet. For the sake of this example, receive and change addresses with index 3-4 are considered unused and address with path `m/44'/3'/0'/0/2` is considered to have UTXOs.

Assuming the dapp monitors all returned addresses for balance changes, a new request to `getAccountAddresses` is only needed when all UTXOs in provided addresses have been spent, or when all provided `receive` addresses or `change` addresses have been used.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "getAccountAddresses",
    "params": {
        "account": "DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        {
            "address": "DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ",
            "path": "m/44'/3'/0'/0/0"
        },
        {
            "address": "DA6rZ9aV3mkz9uxNvddzzbXEEcSPN8SCUS",
            "path": "m/44'/3'/0'/0/2"
        },
        {
            "address": "DDtQfA541GQU2KDrY3ofF5F5hsKxkFiUuG",
            "path": "m/44'/3'/0'/0/3"
        },
        {
            "address": "D5A6wPFhCNChUiQHGXftD8DiNgc2G7yT1L",
            "path": "m/44'/3'/0'/0/4"
        },
        {
            "address": "DFG9R8ENG4mK5gUiU1VRr3FBT13LfWJ4Fb",
            "path": "m/44'/3'/0'/1/3"
        },
        {
            "address": "D7rakaGgZvaBH1vGTxnsQ3ZdV7ejX57hRy",
            "path": "m/44'/3'/0'/1/4"
        }
    ]
}
```

### Example: Static Wallet
The example below specifies a response from a static wallet. The returned address is used for both change and payments. It's the only address with UTXOs.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "getAccountAddresses",
    "params": {
        "account": "DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        {
            "address": "DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ",
            "path": "m/44'/3'/0'/0/0"
        }
    ]
}
```

## signPsbt
This method can be used to request the signature of a Partially Signed Bitcoin Transaction (PSBT) and covers use-cases e.g. involving multiple-recipient transactions, requiring granular control over which UTXOs to spend or how to route change.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `psbt` : `String` - _(Required)_ Base64 encoded string of the PSBT to sign.
    * `signInputs` : `Array`
        * `Object`
            * `address` : `String` - _(Required)_ The address whose private key to use for signing.
            * `index` : `Integer` - _(Required)_ Specifies which input to sign.
            * `sighashTypes` : `Integer[]` - _(Optional)_ Specifies which part(s) of the transaction the signature commits to. Default is `[1]`.
    * `broadcast` : `Boolean` - _(Optional)_ Whether to broadcast the transaction after signing it. Default is `false`.

### Returns
* `Object`
    * `psbt` : `String` - _(Required)_ The base64 encoded signed PSBT.
    * `txid` : `String` - _(Optional)_ The transaction ID as a hex-encoded string, without 0x prefix. This must be returned if the transaction was broadcasted.

## signMessage
This method is used to sign a message with one of the connected account's addresses.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `message` : `String` - _(Required)_ The message to be signed by the wallet.
    * `address` : `String` - _(Optional)_ The address whose private key to use for signing the message.
    * `protocol` : `"ecdsa" | "bip322"` - _(Optional)_ Preferred signature type. Default is `"ecdsa"`.

### Returns
* `Object`
    * `address` : `String` - _(Required)_ The Dogecoin address used to sign the message.
    * `signature` : `String` - _(Required)_ Hex encoded bytes of the signature, without 0x prefix.
    * `messageHash` : `String` - _(Optional)_ Hex encoded bytes of the message hash, without 0x prefix.

## Events
### bip122_addressesChanged
This event is used by wallets to notify dapps about connected accounts' current addresses, for example all addresses with a UTXO and a few unused addresses. The event data has the same format as the [getAccountAddresses](#getaccountaddresses) result.

#### Implementation Details
* Wallets **should** emit a `bip122_addressesChanged` event immediately after connection approval of a BIP122 chain.
* Wallets **should** emit a `bip122_addressesChanged` event whenever a UTXO is spent or created for a connected account's addresses.
* Dapps **should** listen for `bip122_addressesChanged` events, collect and monitor all addresses for UTXO and balance changes.

Example [session_event](https://specs.walletconnect.com/2.0/specs/clients/sign/session-events#session_event) payload as received by a dapp:
```
{
  "id": 1675759795769537,
  "topic": "95d6aca451b8e3c6d9d176761bf786f1cc0a6d38dffd31ed896306bb37f6ae8d",
  "params": {
    "event": {
      "name": "bip122_addressesChanged",
      "data": [
        {
            "address": "DTyt9wHTgizR8CwK8HAsWDaoMMxcaRuLWJ",
            "path": "m/44'/3'/0'/0/0"
        },
        {
            "address": "DA6rZ9aV3mkz9uxNvddzzbXEEcSPN8SCUS",
            "path": "m/44'/3'/0'/0/2"
        },
        {
            "address": "DDtQfA541GQU2KDrY3ofF5F5hsKxkFiUuG",
            "path": "m/44'/3'/0'/0/3"
        },
        {
            "address": "D5A6wPFhCNChUiQHGXftD8DiNgc2G7yT1L",
            "path": "m/44'/3'/0'/0/4"
        },
        {
            "address": "DFG9R8ENG4mK5gUiU1VRr3FBT13LfWJ4Fb",
            "path": "m/44'/3'/0'/1/3"
        },
        {
            "address": "D7rakaGgZvaBH1vGTxnsQ3ZdV7ejX57hRy",
            "path": "m/44'/3'/0'/1/4"
        }
      ]
    },
    "chainId": "bip122:1a91e3dace36e2be3bf030a65679fe821"
  }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/ethereum-rpc.md">
---
description: Ethereum JSON-RPC Methods
---

# Ethereum

## personal_sign

The sign method calculates an Ethereum specific signature with:`sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message)))`.

By adding a prefix to the message makes the calculated signature recognizable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data \(e.g. transaction\) and use the signature to impersonate the victim.

**Note** See ecRecover to verify the signature.

### Parameters

message, account

1. `DATA`, N Bytes - message to sign.
2. `DATA`, 20 Bytes - address.

### Returns

`DATA`: Signature

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "personal_sign",
  "params":["0xdeadbeaf","0x9b2055d370f73ec7d8a03e965129118dc8f5bf83"],
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b"
}
```

## eth_sign

The sign method calculates an Ethereum specific signature with: `sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message)))`.

By adding a prefix to the message makes the calculated signature recognizable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data \(e.g. transaction\) and use the signature to impersonate the victim.

**Note** the address to sign with must be unlocked.

### Parameters

account, message

1. `DATA`, 20 Bytes - address.
2. `DATA`, N Bytes - message to sign.

### Returns

`DATA`: Signature

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_sign",
  "params": ["0x9b2055d370f73ec7d8a03e965129118dc8f5bf83", "0xdeadbeaf"],
}


// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b"
}
```

An example how to use solidity ecrecover to verify the signature calculated with `eth_sign` can be found [here](https://gist.github.com/bas-vk/d46d83da2b2b4721efb0907aecdb7ebd). The contract is deployed on the testnet Ropsten and Rinkeby.

## eth_signTypedData

Calculates an Ethereum-specific signature in the form of `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`

By adding a prefix to the message makes the calculated signature recognizable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data \(e.g. transaction\) and use the signature to impersonate the victim.

**Note** the address to sign with must be unlocked.

### Parameters

account, message

1. `DATA`, 20 Bytes - address.
2. `DATA`, N Bytes - message to sign containing type information, a domain separator, and data

### Example Parameters

```javascript
;[
  '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
  {
    types: {
      EIP712Domain: [
        {
          name: 'name',
          type: 'string'
        },
        {
          name: 'version',
          type: 'string'
        },
        {
          name: 'chainId',
          type: 'uint256'
        },
        {
          name: 'verifyingContract',
          type: 'address'
        }
      ],
      Person: [
        {
          name: 'name',
          type: 'string'
        },
        {
          name: 'wallet',
          type: 'address'
        }
      ],
      Mail: [
        {
          name: 'from',
          type: 'Person'
        },
        {
          name: 'to',
          type: 'Person'
        },
        {
          name: 'contents',
          type: 'string'
        }
      ]
    },
    primaryType: 'Mail',
    domain: {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'
    },
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826'
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB'
      },
      contents: 'Hello, Bob!'
    }
  }
]
```

### Returns

`DATA`: Signature

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_signTypedData",
  "params": ["0x9b2055d370f73ec7d8a03e965129118dc8f5bf83", {see above}],
}
'

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"
}
```

## eth_sendTransaction

Creates new message call transaction or a contract creation, if the data field contains code.

### Parameters

1. `Object` - The transaction object
2. `from`: `DATA`, 20 Bytes - The address the transaction is send from.
3. `to`: `DATA`, 20 Bytes - \(optional when creating new contract\) The address the transaction is directed to.
4. `data`: `DATA` - The compiled code of a contract OR the hash of the invoked method signature and encoded parameters. For details see [Ethereum Contract ABI](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI)
5. `gas`: `QUANTITY` - \(optional, default: 90000\) Integer of the gas provided for the transaction execution. It will return unused gas.
6. `gasPrice`: `QUANTITY` - \(optional, default: To-Be-Determined\) Integer of the gasPrice used for each paid gas
7. `value`: `QUANTITY` - \(optional\) Integer of the value sent with this transaction
8. `nonce`: `QUANTITY` - \(optional\) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.

### Example Parameters

```javascript
;[
  {
    from: '0xb60e8dd61c5d32be8058bb8eb970870f07233155',
    to: '0xBDE1EAE59cE082505bB73fedBa56252b1b9C60Ce',
    data: '0x',
    gasPrice: '0x029104e28c',
    gas: '0x5208',
    value: '0x00'
  }
]
```

### Returns

`DATA`, 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.

Use [eth_getTransactionReceipt](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt) to get the contract address, after the transaction was mined, when you created a contract.

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_sendTransaction",
  "params":[{see above}],
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
}
```

## eth_signTransaction

Signs a transaction that can be submitted to the network at a later time using with `eth_sendRawTransaction`

### Parameters

1. `Object` - The transaction object
2. `from`: `DATA`, 20 Bytes - The address the transaction is send from.
3. `to`: `DATA`, 20 Bytes - \(optional when creating new contract\) The address the transaction is directed to.
4. `data`: `DATA` - The compiled code of a contract OR the hash of the invoked method signature and encoded parameters. For details see [Ethereum Contract ABI](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI)
5. `gas`: `QUANTITY` - \(optional, default: 90000\) Integer of the gas provided for the transaction execution. It will return unused gas.
6. `gasPrice`: `QUANTITY` - \(optional, default: To-Be-Determined\) Integer of the gasPrice used for each paid gas
7. `value`: `QUANTITY` - \(optional\) Integer of the value sent with this transaction
8. `nonce`: `QUANTITY` - \(optional\) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.

### Example Parameters

```javascript
;[
  {
    from: '0xb60e8dd61c5d32be8058bb8eb970870f07233155',
    to: '0xd46e8dd67c5d32be8058bb8eb970870f07244567',
    data: '0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675',
    gas: '0x76c0', // 30400
    gasPrice: '0x9184e72a000', // 10000000000000
    value: '0x9184e72a', // 2441406250
    nonce: '0x117' // 279
  }
]
```

### Returns

`DATA` - the signed transaction data

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_signTransaction",
  "params":[{see above}],
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
}
```

## eth_sendRawTransaction

Creates new message call transaction or a contract creation for signed transactions.

### Parameters

1. `DATA`, the signed transaction data.

### Returns

`DATA`, 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.

Use [eth_getTransactionReceipt](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt) to get the contract address, after the transaction was mined, when you created a contract.

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_sendRawTransaction",
  "params":[
    "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f07244567"
  ],
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/everscale-rpc.md">
---
description: Everscale JSON-RPC Methods
---

# Everscale

# WC JSON-RPC for Everscale

### ever_sign

Signature of a random message for authentication.

##### Parameters:

    1. message - some message in base64;
    2. withSignatureId - bool or number
    3. hashData - bool

##### Returns:

    1. signature - string signature in base64;
    2. pubkey - public key of the wallet's address;

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_sign",
  "params": {
        "message": "some message in base64",
        "withSignatureId": true,
        "hashData": true
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "signature": "0xa3f207... in base64",
        "pubkey": "0x07bf94e...37e3"
    }
}
```

### ever_sendMessage

Creates message, sends it to the network, monitors its processing and returns transaction's id.

##### Parameters:

    1. value - amount of coins attached to the message;
    2. bounce - should the answer message be generated in case of an error;
    3. destAddress - message destination address;
    4. destPayload - message destination payload;
        4.1. abi - destination contract ABI;
        4.2. method - destination contract method;
        4.3. params - destination contract method params

##### Returns:

    1. txId - transaction's id in blockchain;

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_sendMessage",
  "params": {
        "source_address": "0:695e42...b8d",
        "value": 1000000000,
        "bounce": False,
        "destAddress": "0:b38d96...708",
        "destPayload": {
            "abi": "",
            "method": "",
            "params": {}
        },
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "txId": "743e1c0046b82a48a2cf8cbe9a2059ce6f3862cfae377c77d9f1b4efd88d7acb"
    }
}
```

### ever_signMessage

Message that can then be sent to the blockchain.

##### Parameters:

    1. value - amount of coins attached to the message;
    2. bounce - should the answer message be generated in case of an error;
    3. destAddress - message destination address;
    4. destPayload - message destination payload;
       4.1. abi - destination contract ABI;
       4.2. method - destination contract method;
       4.3. params - destination contract method params

##### Returns:

    1. signedExtMessage - signed external message;
    2. expireAt - –ºessage expiration timestamp

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_processMessage",
  "params": {
        "source_address": "0:695e42...b8d",
        "value": 1000000000,
        "bounce": False,
        "destAddress": "0:b38d96...708",
        "destPayload": {
            "abi": "",
            "method": "",
            "params": {}
        },
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "signedExtMessage": "c0b0996a9f0ea8e472041857ff2da9cf8086a78603f823a7170891f43a217ff1",
        "expireAt": 1685594678
    }
}
```

### ever_sendExternalMessage

Sends an external message to the contract.

##### Parameters:

    1. destAddress - message destination address;
    2. destPayload - message destination payload;
        2.1. abi - destination contract ABI;
        2.2. method - destination contract method;
        2.3. params - destination contract method params

##### Returns:

    1. txId - transaction's id in blockchain;

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_sendExternalMessage",
  "params": {
        "sourceAddress": "0:695e42...b8d",
        "destAddress": "0:b38d96...708",
        "destPayload": {
            "abi": "",
            "method": "",
            "params": {}
        },
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "txId": "743e1c0046b82a48a2cf8cbe9a2059ce6f3862cfae377c77d9f1b4efd88d7acb"
    }
};
```

### ever_broadcastMessage

Sends an internal message from the user account without waiting for the transaction.

##### Parameters:

    1. value - amount of coins attached to the message;
    2. bounce - should the answer message be generated in case of an error;
    3. destAddress - message destination address;
    4. destPayload - message destination payload;
        4.1. abi - destination contract ABI;
        4.2. method - destination contract method;
        4.3. params - destination contract method params

##### Returns:

    1. hash: string - external message hash;
    2. account: string - destination account address (equals to source_address);
    3. expireAt: number - –ºessage expiration timestamp

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_broadcastMessage",
  "params": {
        "sourceAddress": "0:695e42...b8d",
        "value": 1000000000,
        "bounce": False,
        "destAddress": "0:b38d96...708",
        "destPayload": {
            "abi": "",
            "method": "",
            "params": {}
        },
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "hash": "743e1c0046b82a48a2cf8cbe9a2059ce6f3862cfae377c77d9f1b4efd88d7acb",
        "account": "0:695e42...b8d",
        "expireAt": 1684327417543
    }
};
```

### ever_broadcastExternalMessage

Sends an external message to the contract without waiting for the transaction.

##### Parameters:

    1. destAddress - message destination address;
    2. destPayload - message destination payload;
        2.1. abi - destination contract ABI;
        2.2. method - destination contract method;
        2.3. params - destination contract method params

##### Returns:

    1. hash: string - external message hash;
    2. account: string - destination account address (equals to source_address);
    3. expireAt: number - –ºessage expiration timestamp

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_broadcastExternalMessage",
  "params": {
        "sourceAddress": "0:695e42...b8d",
        "destAddress": "0:b38d96...708",
        "destPayload": {
            "abi": "",
            "method": "",
            "params": {}
        },
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "hash": "743e1c0046b82a48a2cf8cbe9a2059ce6f3862cfae377c77d9f1b4efd88d7acb",
        "account": "0:b38d96...708",
        "expireAt": 1684327417543
    }
}
```

### ever_addTokenAsset

Adds asset (TIP-3 or native tokens) to the selected account.

##### Parameters:

    1. rootContract - asset root address. Note: you can add native coin by leaving this field empty

##### Returns:

    1. newAsset: bool - returns true if the account did not have this asset before

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_addTokenAsset",
  "params": {
        "sourceAddress": "0:695e42...b8d",
        "rootContract": "0:b38d96...708"
    }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "newAsset": true
    }
}
```

### ever_encryptData

Encrypts arbitrary data with specified algorithm for each specified recipient.

##### Parameters:

    1. recipientPublicKeys - public keys of recipients. Hex encoded;
    2. algorithm - encryption algorithm. Currently supports only ‚ÄúChaCha20Poly1305‚Äù
    3. data - base64 encoded data;

##### Returns:

    1. encryptedData - encrypted data for each recipient
        1.1. algorithm - encryption algorithm
        1.2. sourcePublicKey - hex encoded encryptor's public key
        1.3. recipientPublicKey - hex encoded recipient public key
        1.4. data - base64 encoded data
        1.5. nonce - base64 encoded nonce

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_encryptData",
  "params": {
       "sourceAddress": "0:695e42...b8d",
       "recipientPublicKeys": ["0x6e74...4e95", "0x9532...403f"],
       "algorithm": "ChaCha20Poly1305",
       "data": "ZGF0YQ=="
  }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result":  {
        "encryptedData": [
           {
            "algorithm": "ChaCha20Poly1305",
            "sourcePublicKey": "0x209f...d08f",
	      "recipientPublicKey": "0x6e74...4e95",
            "data": "ZW5jRGF0YTE=",
            "nonce": "bm9uY2Ux"
           },
           {
            "algorithm": "ChaCha20Poly1305",
            "sourcePublicKey": "0x209f...d08f",
            "recipientPublicKey": "0x6e74...4e95",
            "data":"ZW5jRGF0YTI=",
            "nonce":"bm9uY2Uy"
           }
        ]
    }
};
```

### ever_decryptData

Decrypts encrypted data.

##### Parameters:

    1. algorithm - encryption algorithm. Currently supports only ‚ÄúChaCha20Poly1305‚Äù
    2. recipientPublicKey - hex encoded recipient public key
    3. data - base64 encoded data
    4. nonce - base64 encoded nonce

##### Returns:

    1. data - base64 encoded decrypted data

##### Example:

```
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "ever_decryptData",
  "params": {
       "sourceAddress": "0:695e42...b8d",
       "algorithm": "ChaCha20Poly1305",
       "recipientPublicKey": "0x6e74...4e95",
       "data": "ZW5jRGF0YTE=",
       "nonce": "bm9uY2Ux"
  }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
       "data": "ZGF0YQ=="
   }
};
```
</file>

<file path="docs/advanced/multichain/rpc-reference/hedera-rpc.md">
---
description: Hedera JSON-RPC Methods
---

# Hedera

The following JSON-RPC methods offer native integration into Hedera utilizing the [Hedera APIs](https://hashgraph.github.io/hedera-protobufs/) and the [Hedera SDKs](https://docs.hedera.com/hedera/sdks-and-apis/sdks).

Hedera documentation can be found at [docs.hedera.com](https://docs.hedera.com/hedera/).

The following resources provide specific information referenced in the methods below.

- The Hedera network structure is summarized by [Mainnet Nodes](https://docs.hedera.com/hedera/networks/mainnet/mainnet-nodes)
- The full list of Hedera functionality is described by the protobuf definitions: [Hedera Functionality](https://hashgraph.github.io/hedera-protobufs/#proto.HederaFunctionality)
- Further details about these methods can be found in the accompanying Hedera Improvement Proposal: [HIP-820](https://hips.hedera.com/hip/hip-820)
- The `signerAccountId` utilized in the methods below is specified by [HIP-30](https://hips.hedera.com/hip/hip-30)
- A Hedera Transaction ID is composed of the account id that pays for a transaction and the valid start timestamp in nanoseconds: [Hedera Transaction ID](https://docs.hedera.com/hedera/sdks-and-apis/sdks/transactions/transaction-id)
- There are pre-processing validation response codes returned by the network: [ResponseCodeEnum](https://github.com/hashgraph/hedera-protobufs/blob/f36e05bd6bf3f572707ca9bb338f5ad6421a4241/services/response_code.proto#L32)

_Hedera has a separate open-source project implementing parts of the [Ethereum JSON-RPC standard](https://docs.hedera.com/hedera/core-concepts/smart-contracts/json-rpc-relay) which is not covered in this documentation._

## Methods

- [`hedera_signAndExecuteTransaction`](#hedera_signandexecutetransaction)
- [`hedera_signTransaction`](#hedera_signtransaction)
- [`hedera_executeTransaction`](#hedera_executetransaction)
- [`hedera_signAndExecuteQuery`](#hedera_signandexecutequery)
- [`hedera_signMessage`](#hedera_signmessage)
- [`hedera_getNodeAddresses`](#hedera_getnodeaddresses)

## hedera\_signAndExecuteTransaction

The `hedera_signAndExecuteTransaction` method is a generic method for executing a transaction on the Hedera network. A dApp can begin by constructing a transaction with one of the Hedera SDKs or by constructing the raw protobuf messages and may select one or more consensus nodes that are authorized to execute the transaction.

The dApp then constructs a list of valid transaction bytes that differ only in the node account id and serializes the list, for example by using the `toBytes()` method of an SDK. Finally, the dApp base64 encodes the resulting bytes. This final base64 encoded string of bytes is sent as a method param titled `transactionList` to the wallet.

Wallets and SDKs must take special care to deserialize the list of transactions and validate that each transaction in the list differs only in the node authorized to receive the transaction and does NOT differ in intent before submitting to an end user for approval and ultimately signing.

### Parameters

    1. `Object` - signAndExecuteTransaction parameters
      1.1. `signerAccountId` : `String` - Hedera account id in the format `<network>:<shard>.<realm>.<num><-optional-checksum>`
      1.2. `transactionList` : `String` - Base64 encoded string of TransactionList bytes

### Returns

    1. `Object` - Result of transaction submission to Hedera network
      1.1. `nodeId` : `String` - The Hedera node the transaction was submitted to
      1.2. `transactionHash` : `String` - The hash of the transaction
      1.3. `transactionId` : `String` - Transaction ID, which includes the payer account id and the valid start timestamp

### Error

In certain conditions, the Hedera network will return a response that signifies a pre-processing validation error, for example, when the transaction has expired. In these cases, wallets will return an error with the following format:

    1. `Object` - Result of transaction submission to Hedera network
      1.1. `code` : 9000 - The reserved WalletConnect error code for unknown errors or errors not related to the WalletConnect protocol
      1.2. `message` : `String` - A human readable string describing the nature of the failure
      1.3. `data` : `Number` - An integer representing the ResponseCodeEnum value returned from the Hedera Node, which indicates the reason for the failure


### Example

#### Request
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "hedera_signAndExecuteTransaction",
  "params": {
    "signerAccountId": "hedera:testnet:0.0.12345",
    "transactionList": "Co8BKowBCocBChoKDAjchKWmBhDW..."
  }
}
```
#### Result
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "nodeId": "0.0.3",
    "transactionHash": "252b8fd...",
    "transactionId": "0.0.12345678@1689281510.675369303"
  }
}
```
#### Error
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "error": {
    "code": 9000,
    "message": "The transaction failed with precheck code...",
    "data": 6
  }
}
```
## hedera\_signTransaction

The `hedera_signTransaction` signs a `TransactionBody` and returns a `SignatureMap` to the caller.

### Parameters

    1. `Object` - signTransaction parameters
      1.1 `signerAccountId` : `String` - Hedera account id in the format `<network>:<shard>.<realm>.<num><-optional-checksum>`
      1.2 `transactionBody` : `String` - Base64 encoded string representation of TransactionBody

### Returns

    1. `Object` - SignatureMap of related signed TransactionBody
      1.1 `signatureMap` : `String` - Base64 encoded string of SignatureMap

### Example

#### Request
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "hedera_signTransaction",
  "params": {
    "signerAccountId": "hedera:testnet:0.0.12345",
    "transactionBody": "Co8BKowBCocBChoKDAjchKWmBhDW..."
  }
}
```
#### Result
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "signatureMap": "VGhpcyBpcyBqdXN0IHNvbWUgc3R1..."
  }
}
```
## hedera\_executeTransaction

When a dApp only requires the services of the controller to act as a relay to the Hedera network for submitting an already signed transaction, it can use the `hedera_executeTransaction` method.

### Parameters

    1. `Object` - executeTransaction parameters
      1.1 `transactionList` : `String` Base64 encoded TransactionList

### Returns

    1. `Object` - Result of transaction submission to the Hedera network
      1.1. `nodeId` : `String` - The Hedera node the transaction was submitted to
      1.1. `transactionHash` : `String` - The hash of the transaction
      1.1. `transactionId` : `String` - Transaction ID, which includes the payer account id and the valid start timestamp

### Error

In certain conditions, the Hedera network with return a response that signifies a pre-processing validation error, for example, when the transaction has expired. In these cases, wallets will return an error with the following format:

    1. `Object` - Result of transaction submission to the Hedera network
      1.1. `code` : 9000 - The reserved WalletConnect error code for unknown errors or errors not related to the WalletConnect protocol
      1.1. `message` : `String` - A human readable string describing the nature of the failure
      1.1. `data` : `Number` - An integer representing the ResponseCodeEnum value returned from the Hedera Node, which indicates the reason for the failure

### Example

#### Request
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "hedera_executeTransaction",
  "params": {
    "transactionList": "Co8BKowBCocBChoKDAjchKWmBhDW..."
  }
}
```
#### Result
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "nodeId": "0.0.3",
    "transactionHash": "252b8fd...",
    "transactionId": "0.0.12345678@1689281510.675369303"
  }
}
```

#### Error
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "error": {
    "code": 9000,
    "message": "The transaction failed with precheck code...",
    "data": 6
  }
}
```
## hedera\_signAndExecuteQuery

This method provides functionality to perform a query on a Hedera consensus node. Many Queries against consensus nodes have a transaction fee [Learn more about Queries](https://docs.hedera.com/hedera/sdks-and-apis/sdks/queries).

Most requests that do not change network state can be performed against a [Mirror Node](https://docs.hedera.com/hedera/core-concepts/mirror-nodes) and for many use cases calling a mirror node endpoint is the recommended approach.

### Parameters

    1. `Object` - signAndExecuteQuery parameters
      1.1 `signerAccountId` : `String` - Hedera account id in the format `<network>:<shard>.<realm>.<num><-optional-checksum>`
      1.2 `query` : `String` - base64 encoded Query

### Returns

    1. `Object` - Result of the Query submitteed to a Hedera consensus node
      1.1. `response` : `String` - Base64 encoding of the Hedera API response


## hedera\_signMessage

This method accepts a plain text string value as input. If approved by the user, the controller UTF-8 encodes this message prepended with "\x19Hedera Signed Message:\n" plus the length of the message and signs the resulting bytes in the same manner as HAPI transactions are signed. The resulting signature(s) are transmitted back to the user encoded in a SignatureMap structure. The pseudo code for computing the signature is as follows:

```javascript
<Ed25519 or ECDSA Key>.sign("\x19Hedera Signed Message:\n" + len(message) + message)
```

### Parameters

    1. `Object` - signMessage parameters
      1.1 `signerAccountId` : `String` - Hedera account id in the format `<network>:<shard>.<realm>.<num><-optional-checksum>`
      1.2 `message` : `String`

### Returns

    1. `Object` - signMessage result
      1.1 `signatureMap` : `String` - Base64 encoded SignatureMap

### Example

#### Request

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "hedera_signMessage",
  "params": {
    "signerAccountId": "hedera:testnet:0.0.12345"
    "message": "Co8BKowBCocBChoKDAjchKWmBhDW..."
  }
}
```

#### Result

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "signatureMap": "CAAQABjMrxoYABIGCAAQABgHGIDIr..."
  }
}
```

## hedera\_getNodeAddresses

While constructing a transaction for transmission to a controller, a dApp needs to choose which Hedera Network node shall receive the transaction prior to signing (this is a requirement of the Hedera API Protocol). While a dApp can easily obtain a list of potential Hedera Nodes, a controller may not have an all-inclusive list nor a path to the node‚Äôs gRPC endpoint. The `hedera_getNodeAddresses` method allows a dApp to request a list of node wallet addresses known to the controller. The controller should only include nodes in this list that it is willing and able to submit transactions to at the time of the request.

### Returns

    1. `Object` - signMessage result
      1.1 `nodes` : `Array` - an array of strings in `<shard>.<realm>.<num><-optional-checksum>` format, each identifying a node by its Hedera Address

### Example

#### Request

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "hedera_getNodeAddresses",
}
```

#### Result

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "nodes": ["0.0.3", "0.0.4"]
  }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/litecoin-rpc.md">
---
description: Litecoin JSON-RPC Methods
---

# Litecoin
We define an account as the group of addresses derived using the same account value in their [derivation paths](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#user-content-Path_levels). We use the first address of the [external chain](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#examples) ("first external address"), as the identifier for an account. An account's total balance is defined as the sum of all unspent transaction outputs (UTXOs) belonging to its entire group of addresses.

1. Dapps **must** only display the first external address as a connected account.
2. Wallets **must** only offer to connect the first external address(es).

#### Account Definition
The derivation path levels in the [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#path-levels), [BIP49](https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki#user-content-Public_key_derivation), [BIP84](https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki#public-key-derivation), [BIP86](https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki#user-content-Public_key_derivation) standards are: 
```
m / purpose' / coin_type' / account' / change / address_index
```

Addresses with different `purpose`, `change` and `address_index` values are considered to belong to the same account. Valid `purpose` values are 44, 49, 84 and 86. We use the first external Native SegWit (purpose = 84) address as the default account identifier.

For a specific seed phrase and path `m/84'/2'/0'/0/0` we get account 0 with identifier `ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0`. Its total balance is the sum of all UTXO balances on all addresses with derivation paths:
* `m/44'/2'/0'/change/address_index`
* `m/49'/2'/0'/change/address_index`
* `m/84'/2'/0'/change/address_index`
* `m/86'/2'/0'/change/address_index`

If the wallet user changes to account 1 we get path `m/84'/2'/1'/0/0` with identifier `ltc1qn9h77dt0s6ar78ptxq58t2ne7tyhvfnruc3e7d`. Its total balance is the sum of all UTXO balances on all addresses with derivation paths:
* `m/44'/2'/1'/change/address_index`
* `m/49'/2'/1'/change/address_index`
* `m/84'/2'/1'/change/address_index`
* `m/86'/2'/1'/change/address_index`

## sendTransfer
This method is used to sign and submit a transfer of any `amount` of Litecoin to a single `recipientAddress`, optionally including a `changeAddress` for the change amount and `memo` set as the OP_RETURN value by supporting wallets. The transaction will be signed and broadcast upon user approval.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `recipientAddress` : `String` - _(Required)_ The recipient's public address.
    * `amount` : `String` - _(Required)_ The amount of Litecoin to send, denominated in litoshis (Litecoin base unit).
    * `changeAddress` : `String` - _(Optional)_ The sender's public address to receive change.
    * `memo` : `String` - _(Optional)_ The OP_RETURN value as a hex string without 0x prefix, maximum 80 bytes.

### Returns
* `Object` 
    * `txid` : `String` - The transaction id as a hex string without 0x prefix.

### Example
The example below specifies a simple transfer of 1.23 LTC (123000000 Litoshi).

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "sendTransfer",
    "params": {
        "account": "ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0",
        "recipient": "ltc1qn9h77dt0s6ar78ptxq58t2ne7tyhvfnruc3e7d",
        "amount": "123000000",
        "memo": "636861726c6579206c6f766573206865"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": {
        "txid": "f007551f169722ce74104d6673bd46ce193c624b8550889526d1b93820d725f7"
    }
}
```

## getAccountAddresses
This method returns all current addresses needed for a dapp to fetch all UTXOs, calculate the total balance and prepare transactions. Dapps will typically use an indexing service to query for balances and UTXOs for all addresses returned by this method, such as:
* [Blockbook API](https://github.com/trezor/blockbook/blob/master/docs/api.md#get-address)
* [Bitcore API](https://github.com/bitpay/bitcore/blob/master/packages/bitcore-node/docs/api-documentation.md#address)

We recognize that there are two broad classes of wallets in use today:
1. Wallets that generate a new change or receive address for every transaction ("dynamic wallet").
2. Wallets that reuse the first external address for every transaction ("static wallet").

#### Implementation Details
* All wallets **should** include the first external address and all addresses with one or more UTXOs, unless they're filtered by `intentions`.
* Dynamic wallets **should** include minimum 2 unused change and receive addresses. Otherwise dapps may have to request [getAccountAddresses](#getAccountAddresses) after every transaction to discover the new addresses and keep track of the user's total balance.
* All wallets **must** return fewer than 20 unused change and receive addresses to avoid breaking the [gap limit](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#address-gap-limit).

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `intentions` : `String[]` - _(Optional)_ Filter what addresses to return, e.g. "payment" or "ordinal".

### Returns
* `Array`
    * `Object`
        * `address` : `String` - _(Required)_ Public address belonging to the account.
        * `publicKey` : `String` - _(Optional)_ Public key for the derivation path in hex, without 0x prefix.
        * `path` : `String` - _(Optional)_ Derivation path of the address e.g. "m/84'/2'/0'/0/0".
        * `intention` : `String` - _(Optional)_ Intention of the address, e.g. "payment" or "ordinal".

### Example: Dynamic Wallet
The example below specifies a result from a dynamic wallet. For the sake of this example, receive and change addresses with index 3-4 are considered unused and addresses with paths `m/49'/2'/0'/0/7` and `m/84'/2'/0'/0/2` are considered to have UTXOs.

Assuming the dapp monitors all returned addresses for balance changes, a new request to `getAccountAddresses` is only needed when all UTXOs in provided addresses have been spent, or when all provided `receive` addresses or `change` addresses have been used.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "getAccountAddresses",
    "params": {
        "account": "ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        {
            "address": "ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0",
            "path": "m/84'/2'/0'/0/0"
        },
        {
            "address": "LXkGhTKmZpviAtYdDaxWbiJsdg4tA6EzrU",
            "path": "m/49'/2'/0'/0/7"
        },
        {
            "address": "ltc1qj4plcuyhuzw0sycf99gcayzhhcddfj6xkcke5g",
            "path": "m/84'/2'/0'/0/2"
        },
        {
            "address": "ltc1qsdxa6pseqekqg5d3uksaxnwrey2s2ujcx03alc",
            "path": "m/84'/2'/0'/0/3"
        },
        {
            "address": "ltc1qhuvt3sq8xmx9ktzdfznkzvjl5zup7mg9zpwllw",
            "path": "m/84'/2'/0'/0/4"
        },
        {
            "address": "ltc1qtjd3y5a2axpwzfjcj4y9zy50qfjuxwzm0vu5fq",
            "path": "m/84'/2'/0'/1/3"
        },
        {
            "address": "ltc1qp7ujtprgl0quvcg0dj335p37r2mc2cxdc8xumq",
            "path": "m/84'/2'/0'/1/4"
        }
    ]
}
```

### Example: Static Wallet
The example below specifies a response from a static wallet. The returned address is used for both change and payments. It's the only address with UTXOs.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "getAccountAddresses",
    "params": {
        "account": "ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0"
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        {
            "address": "ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0",
            "path": "m/84'/2'/0'/0/0"
        }
    ]
}
```

## signPsbt
This method can be used to request the signature of a Partially Signed Bitcoin Transaction (PSBT) and covers use-cases e.g. involving multiple-recipient transactions, requiring granular control over which UTXOs to spend or how to route change.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `psbt` : `String` - _(Required)_ Base64 encoded string of the PSBT to sign.
    * `signInputs` : `Array`
        * `Object`
            * `address` : `String` - _(Required)_ The address whose private key to use for signing.
            * `index` : `Integer` - _(Required)_ Specifies which input to sign.
            * `sighashTypes` : `Integer[]` - _(Optional)_ Specifies which part(s) of the transaction the signature commits to. Default is `[1]`.
    * `broadcast` : `Boolean` - _(Optional)_ Whether to broadcast the transaction after signing it. Default is `false`.

### Returns
* `Object`
    * `psbt` : `String` - _(Required)_ The base64 encoded signed PSBT.
    * `txid` : `String` - _(Optional)_ The transaction ID as a hex-encoded string, without 0x prefix. This must be returned if the transaction was broadcasted.

## signMessage
This method is used to sign a message with one of the connected account's addresses.

### Parameters
* `Object`
    * `account` : `String` - _(Required)_ The connected account's first external address.
    * `message` : `String` - _(Required)_ The message to be signed by the wallet.
    * `address` : `String` - _(Optional)_ The address whose private key to use for signing the message.
    * `protocol` : `"ecdsa" | "bip322"` - _(Optional)_ Preferred signature type. Default is `"ecdsa"`.

### Returns
* `Object`
    * `address` : `String` - _(Required)_ The Litecoin address used to sign the message.
    * `signature` : `String` - _(Required)_ Hex encoded bytes of the signature, without 0x prefix.
    * `messageHash` : `String` - _(Optional)_ Hex encoded bytes of the message hash, without 0x prefix.

## Events
### bip122_addressesChanged
This event is used by wallets to notify dapps about connected accounts' current addresses, for example all addresses with a UTXO and a few unused addresses. The event data has the same format as the [getAccountAddresses](#getaccountaddresses) result.

#### Implementation Details
* Wallets **should** emit a `bip122_addressesChanged` event immediately after connection approval of a BIP122 chain.
* Wallets **should** emit a `bip122_addressesChanged` event whenever a UTXO is spent or created for a connected account's addresses.
* Dapps **should** listen for `bip122_addressesChanged` events, collect and monitor all addresses for UTXO and balance changes.

Example [session_event](https://specs.walletconnect.com/2.0/specs/clients/sign/session-events#session_event) payload as received by a dapp:
```
{
  "id": 1675759795769537,
  "topic": "95d6aca451b8e3c6d9d176761bf786f1cc0a6d38dffd31ed896306bb37f6ae8d",
  "params": {
    "event": {
      "name": "bip122_addressesChanged",
      "data": [
        {
            "address": "ltc1q8c6fshw2dlwun7ekn9qwf37cu2rn755u9ym7p0",
            "path": "m/84'/2'/0'/0/0"
        },
        {
            "address": "LXkGhTKmZpviAtYdDaxWbiJsdg4tA6EzrU",
            "path": "m/49'/2'/0'/0/7"
        },
        {
            "address": "ltc1qj4plcuyhuzw0sycf99gcayzhhcddfj6xkcke5g",
            "path": "m/84'/2'/0'/0/2"
        },
        {
            "address": "ltc1qsdxa6pseqekqg5d3uksaxnwrey2s2ujcx03alc",
            "path": "m/84'/2'/0'/0/3"
        },
        {
            "address": "ltc1qhuvt3sq8xmx9ktzdfznkzvjl5zup7mg9zpwllw",
            "path": "m/84'/2'/0'/0/4"
        },
        {
            "address": "ltc1qtjd3y5a2axpwzfjcj4y9zy50qfjuxwzm0vu5fq",
            "path": "m/84'/2'/0'/1/3"
        },
        {
            "address": "ltc1qp7ujtprgl0quvcg0dj335p37r2mc2cxdc8xumq",
            "path": "m/84'/2'/0'/1/4"
        }
      ]
    },
    "chainId": "bip122:12a765e31ffd4059bada1e25190f6e98"
  }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/near-rpc.md">
---
description: NEAR JSON-RPC Methods
---

# NEAR

The method names below are based on the [Bridge Wallets](https://github.com/near/NEPs/blob/master/specs/Standards/Wallets/BridgeWallets.md#) Standard for NEAR.

## near_getAccounts

Retrieve all accounts visible to the session. `publicKey` references the underlying `FullAccess` key linked to each account.

### Parameters

    none

### Returns

    1.`Array` - Array of accounts:
        1.1. `Object`
            1.1.1. `accountId` : `String` - The account name to which the publicKey corresponds as plain text
            1.1.2. `publicKey` : `String` - The public counterpart of the key used to sign, expressed as a string with format `<key-type>:<base58-key-bytes>`

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "near_getAccounts",
  "params": {}
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [{
    "accountId": "alice.near",
    "publicKey": "ed25519:DmnRVNb89cLKZY1cH1Zcr3rxMVD9r1cVfnDac7RFwM94"
  }]
}
```

## near_signIn

For dApps that often sign gas-only transactions, `FunctionCall` access keys can be created for one or more accounts to greatly improve the UX. While this could be achieved with `signTransactions`, it suggests a direct intention that a user wishes to sign in to a dApp's smart contract.

### Parameters

    1. `Object` - Sign In parameters:
    	1.1. `permission` : `Object` -  Function call key permission parameters
                1.1.1. `receiverId` : `String` - smart contract for witch the function call access key will be created
                1.1.2. `methodNames` : `Array<String>` - list of methods that can be called on the smart contract
    	1.2. `accounts` : `Array` - list of accounts for which a FunctionCall access key will be added:
                1.2.1. `Object` - Account
                    1.2.1.1. `accountId` : `String` - The account name to which the publicKey corresponds as plain text
                    1.2.1.2. `publicKey` : `String` - The public counterpart of the key used to sign, expressed as a string with format `<key-type>:<base58-key-bytes>`

### Returns

    void

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "near_signIn",
  "params": {
    "permission": {
      "receiverId": "guest-book.testnet",
      "methodNames": []
    },
    "accounts": [{
        "accountId": "alice.near",
        "publicKey": "ed25519:DmnRVNb89cLKZY1cH1Zcr3rxMVD9r1cVfnDac7RFwM94"
    }]
  }
}

```

## near_signOut

Delete one or more `FunctionCall` access keys created with `signIn`. While this could be achieved with `signTransactions`, it suggests a direct intention that a user wishes to sign out from a dApp's smart contract.

### Parameters

    1.`Array` - Array of accounts:
        1.1. `Object`
            1.1.1. `accountId` : `String` - The account name to which the publicKey corresponds as plain text
            1.1.2. `publicKey` : `String` - The public counterpart of the key used to sign, expressed as a string with format `<key-type>:<base58-key-bytes>`

### Returns

    void

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "near_signOut",
  "params": {
    "accounts": [{
      "accountId": "alice.near",
      "publicKey": "ed25519:DmnRVNb89cLKZY1cH1Zcr3rxMVD9r1cVfnDac7RFwM94"
    }]
  }
}
```

## near_signTransaction

Sign a transaction. It makes use of [near-api-js](https://github.com/near/near-api-js) to enable interoperability with dApps that will already use it for constructing transactions and communicating with RPC endpoints.

[Transaction](https://nomicon.io/RuntimeSpec/Transactions) passed to `signTransaction` must be encoded.

### Parameters

     1. `Object` - Signing parameters:
    	1.1. `transaction` : `Uint8Array` - Encoded Transaction via transactions.Transaction.encode()

### Returns

The result of `signTransaction` and is encoded [SignedTransaction](https://nomicon.io/RuntimeSpec/Transactions#signed-transaction) model.

     1. `Uint8Array` - Encoded SignedTransaction via transactions.SignedTransaction.encode()

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "near_signTransaction",
  "params": {
    "transaction": {
    "type": "Buffer",
      "data": [32, 0, 0, 0, 100, 101, 118, 45, 49, 54, 55, 49, 51, 56, 55, 51, 57, 56 ...]
    }
  }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
  "type": "Buffer",
    "data": [32, 0, 0, 0, 100, 101, 118, 45, 49, 54, 55, 49, 51, 56, 55, 51, 57, 56 ...]
  }
}
```

## near_signTransactions

Sign a list of transactions. It makes use of [near-api-js](https://github.com/near/near-api-js) to enable interoperability with dApps that will already use it for constructing transactions and communicating with RPC endpoints.

[Transactions](https://nomicon.io/RuntimeSpec/Transactions) passed to `signTransactions` must be encoded.

### Parameters

    1. `Array<Object>` - Signing parameters:
    	1.1. `transactions` : `Array<Uint8Array>` - Array of Encoded Transaction via transactions.Transaction.encode()

### Returns

The result of `signTransactions` and are encoded [SignedTransaction](https://nomicon.io/RuntimeSpec/Transactions#signed-transaction) models.

    1. `Array<Uint8Array>` - Array of Encoded SignedTransaction via transactions.SignedTransaction.encode()

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "near_signTransactions",
  "params": {
  "transactions": [
      { "type": "Buffer", "data": [32, 0, 0, 0, 100, 101, 118, 45, 49, 54, 55, 49, 53, 52, 49, 55, 56, 57, 51, 50 ...] },
      { "type": "Buffer", "data": [32, 0, 0, 0, 100, 101, 118, 45, 49, 54, 55, 49, 53, 52, 49, 55, 56, 57, 51, 50 ...] }
    ]
  }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [
    { "type": "Buffer", "data": [32, 0, 0, 0, 100, 101, 118, 45, 49, 54, 55, 49, 53, 52, 49, 55, 56, 57, 51, 50 ...] },
    { "type": "Buffer", "data": [32, 0, 0, 0, 100, 101, 118, 45, 49, 54, 55, 49, 53, 52, 49, 55, 56, 57, 51, 50 ...] }
  ]
}

```
</file>

<file path="docs/advanced/multichain/rpc-reference/solana-rpc.md">
---
description: Solana JSON-RPC Methods
---

# Solana

## solana_getAccounts

This method returns an Array of public keys available to sign from the wallet.

### Parameters

    none

### Returns

    1.`Array` - Array of accounts:
    	1.1. `Object`
    		1.1.1. `pubkey` : `String` - public key for keypair

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "solana_getAccounts",
  "params": {}
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [{ "pubkey": "722RdWmHC5TGXBjTejzNjbc8xEiduVDLqZvoUGz6Xzbp" }]
}
```

## solana_requestAccounts

This method returns an Array of public keys available to sign from the wallet.

### Parameters

    none

### Returns

    1.`Array` - Array of accounts:
    	1.1. `Object`
    		1.1.1. `pubkey` : `String` - public key for keypair

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "solana_getAccounts",
  "params": {}
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [{ "pubkey": "722RdWmHC5TGXBjTejzNjbc8xEiduVDLqZvoUGz6Xzbp" }]
}
```

## solana_signTransaction

This method returns a signature over the provided instructions by the targeted public key.

### Parameters

`Object` - Signing parameters:<br />
- **[deprecated]** `feePayer` : `String` -  public key of the transaction fee payer<br />
- **[deprecated]** `instructions` : `Array` of `Object` - instructions to be atomically executed:<br />
&nbsp;- `Object` - instruction<br />
&emsp;- `programId` : `String` - public key of the on chain program<br />
&emsp;- `data` : `String | undefined` - encoded calldata for instruction<br />
&emsp;- `keys` : `Array` of `Object`- account metadata used to define instructions<br />
&emsp;&emsp;- `Object` - key<br />
&emsp;&emsp;&emsp;- `isSigner` : `Boolean` - true if an instruction requires a transaction signature matching `pubkey`<br />
&emsp;&emsp;&emsp;- `isWritable` : `Boolean` - true if the `pubkey` can be loaded as a read-write account<br />
&emsp;&emsp;&emsp;- `pubkey` : `String` - public key of authorized program<br />
- **[deprecated]** `recentBlockhash` : `String` - a recent blockhash<br />
- **[deprecated]** `signatures` : `Array` of `Object`, - (optional) previous partial signatures for this instruction set<br />
&nbsp;- `Object` - partial signature<br />
&emsp;- `pubkey` : `String` - pubkey of the signer<br />
&emsp;- `signature` : `String` - signature matching `pubkey`<br />
- `transaction` : `String`, - base64-encoded serialized transaction<br />

### Returns

    1. `Object`
    	1.1. `signature` : `String` - corresponding signature for signed instructions

### Example

```javascript
// Request
{
	"id": 1,
	"jsonrpc": "2.0",
	"method": "solana_signTransaction",
	"params": {
		"feePayer": "AqP3MyNwDP4L1GJKYhzmaAUdrjzpqJUZjahM7kHpgavm",
		"instructions": [{
			"programId": "Vote111111111111111111111111111111111111111",
			"data": "37u9WtQpcm6ULa3VtWDFAWoQc1hUvybPrA3dtx99tgHvvcE7pKRZjuGmn7VX2tC3JmYDYGG7",
			"keys": [{
				"isSigner": true,
				"isWritable": true,
				"pubkey": "AqP3MyNwDP4L1GJKYhzmaAUdrjzpqJUZjahM7kHpgavm"
			}]
		}],
		"recentBlockhash": "2bUz6wu3axM8cDDncLB5chWuZaoscSjnoMD2nVvC1swe",
		"signatures": [{
			"pubkey": "AqP3MyNwDP4L1GJKYhzmaAUdrjzpqJUZjahM7kHpgavm",
			"signature": "2Lb1KQHWfbV3pWMqXZveFWqneSyhH95YsgCENRWnArSkLydjN1M42oB82zSd6BBdGkM9pE6sQLQf1gyBh8KWM2c4"
		}],
                "transaction": "r32f2..FD33r"
	}
}

// Result
{
	"id": 1,
	"jsonrpc": "2.0",
	"result":  { signature: "2Lb1KQHWfbV3pWMqXZveFWqneSyhH95YsgCENRWnArSkLydjN1M42oB82zSd6BBdGkM9pE6sQLQf1gyBh8KWM2c4" }
}
```

## solana_signMessage

This method returns a signature for the provided message from the requested signer address.

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `message` : `String` -  the message to be signed (base58 encoded)
    	1.2. `pubkey` : `String` -  public key of the signer

### Returns

    1. `Object`
    	1.1. `signature` : `String` - corresponding signature for signed message

### Example

```javascript
// Request
{
	"id": 1,
	"jsonrpc": "2.0",
	"method": "solana_signMessage",
	"params": {
		"message": "37u9WtQpcm6ULa3VtWDFAWoQc1hUvybPrA3dtx99tgHvvcE7pKRZjuGmn7VX2tC3JmYDYGG7",
		"pubkey": "AqP3MyNwDP4L1GJKYhzmaAUdrjzpqJUZjahM7kHpgavm"
	}
}

// Result
{
	"id": 1,
	"jsonrpc": "2.0",
	"result":  { signature: "2Lb1KQHWfbV3pWMqXZveFWqneSyhH95YsgCENRWnArSkLydjN1M42oB82zSd6BBdGkM9pE6sQLQf1gyBh8KWM2c4" }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/starknet-rpc.md">
---
description: Starknet JSON-RPC Methods
---

# Starknet

We define new types for starknet:

- `FELT`, a number represented by a hex string. Prefixed with 0x. It can be left padded with zeroes or not. It follows the [Cairo Field Element spec](https://www.cairo-lang.org/docs/how_cairo_works/cairo_intro.html#field-elements)
- `ABI`, a representation of a Starknet contract‚Äôs interface. As [Starknet ABI Spec](https://docs.starknet.io/documentation/architecture_and_concepts/Contracts/contract-abi/)

## starknet_requestAddInvokeTransaction

Requests the wallet to sign and submit a [INVOKE transaction](https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#invoke_transaction)

This request might be processed before the account is deployed. In that scenario the wallet will ask the user to do the deployment and the requested transaction.

### Parameters

```
1. `FELT`, `accountAddress` : Account that is being requested to send a transaction
2. `Object`, `executionRequest` : Transaction requested
    2.1. `calls` : `Object[]` array of calls to perform
        2.1.1. `contractAddress` : `Felt`
        2.1.2. `entrypoint` : `Felt`
        2.1.3. `calldata` : `Felt[]` (Optional)
    2.2. `abis` : `ABI[]` (Optional) one or more contract abis which can be used to display the calls
```

### Example Parameters

```javascript
{
      "accountAddress": "0x003a8278a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64",
      "executionRequest" : {
            "calls" : [
                {
                  "contractAddress": "0x003a8278a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64",
                  "entrypoint": "0x555278a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64",
                  "calldata": ["0x003", "0xa82705a5b27e2bbc4a64"]
                },
                {
                    "contractAddress": "0x00111178a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64",
                    "entrypoint": "0x0022228a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64"
                }
            ],
            "abis" : [{
                "inputs": [{ "name": "amount", "type": "felt" }],
                "name": "set_balance",
                "outputs": [],
                "type": "function"
            }]
      }
}
```

### Returns

1. `FELT`, `transaction_hash` : The hash of the transaction submitted by the wallet

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "starknet_requestAddInvokeTransaction",
  "params":{see above}
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": { "transaction_hash" : "0x01d666de4dc4d7e888190475ea6381a862e7d77cc3cb425e72ebf85e1d5144fa" }
}
```

## starknet_signTypedData

Request the wallet to sign an _Off-chain message_ as defined here [Starknet Off-chain message spec](https://community.starknet.io/t/signing-transactions-and-off-chain-messages/66). This is similar to Ethereum's EIP-712

This request might be processed before the account is deployed. In that scenario the wallet will ask the user to do the deployment and sign the data

### Parameters

account, message

```
1. `FELT`, `accountAddress` : account address used for signing.
2. `Object`, `typedData` : typed data to sign containing type information, a domain separator, and data. It follows the Starknet Off-chain message spec
```

### Example Parameters

```javascript
{
    "accountAddress" : "0x003a8278a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64",
    "typedData" : {
          "types" : {
              "StarkNetDomain ": [
                  { "name" : "name", "type" : "felt" },
                  { "name" : "version", "type" : "felt" },
                  { "name" : "chainId", "type" : "felt" }
              ],
              "Person" : [
                  { "name": "name", "type" : "felt" },
                  { "name": "wallet", "type" : "felt" }
              ],
              "Mail": [
                  { "name": "from", "type": "Person" },
                  { "name": "to", "type": "Person" },
                  { "name": "contents", "type": "felt" }
              ]
          },
          "primaryType" : "Mail",
          "domain" : {
              "name" : "StarkNet Mail",
              "version" : "1",
              "chainId" : 1
          },
          "message" : {
              "from" : {
                  "name" : "Cow",
                  "wallet" : "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
              },
              "to": {
                  "name" : "Bob",
                  "wallet" : "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
              },
              "contents" : "Hello, Bob!"
          }
  }
}
```

### Returns

1. `FELT[]`, `signature` : Signature as an array of Felts

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "starknet_signTypedData",
  "params": ["0x003a8278a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64", {see above}]
}


// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": { "signature" : ["0x3a8278a26f32452f156260d81b93efb0eca126b44df7b005a5b27e2bbc4a64", "0x072e509b6502e2bbc4a649052eb6c299d53a04e16605b915621c", "0x07897a1b93efb0eca126b44df4646", "0x072e509b6502e2bbc4a649052eb6c299d53a04e16605b915621c"] }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/stellar-rpc.md">
---
description: Stellar JSON-RPC Methods
---

# Stellar

## stellar_signAndSubmitXDR

This method sends the Stellar transaction encoded as [XDR](https://developers.stellar.org/api/introduction/xdr/) to the wallet. The wallet is expected to sign the transaction and submit it to the Stellar network. For accounts protected with [multisig](https://developers.stellar.org/docs/glossary/multisig/), the wallet should also handle the collection of signatures and submission of the transaction at a later time.
The method returns the transaction status: `success` - if the transaction was successfully confirmed in the Stellar network, `pending` - if the transaction requires additional signatures

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `xdr` : `STRING` -  stellar transaction encoded as XDR

### Returns

    1. `Object` - Signing parameters:
    	1.1. `status` : `success` or `pending`

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "stellar_signAndSubmitXDR",
  "params": {
    "xdr": "AAAAAPewD+/6X8o0bx3bp49Wf+mUhG3o+TUrcjcst717DWJVAAAAyAFvzscADTkNAAAAAAAAAAAAAAACAAAAAAAAAAYAAAACWE1BVEsAAAAAAAAAAAAAAAPvNOuztX4IjvV8pztsEc1/ZnTz0G3p5Cx4vcf04+xUAAONfqTGgAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAD2NyeXB0b21hcmluZS5ldQAAAAAAAAAAAAAAAAF7DWJVAAAAQK3vfUCZ8mbjW3ssMd0n1tJTF9Fv6EbuJ6cWKkYXBqG5itqanPbFzIQoZEHbPS8nr2vo4dROvKI0uQzNcfExKwM="
  }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "status": "success"
  }
}
```

## stellar_signXDR

This method sends the Stellar transaction encoded as [XDR](https://developers.stellar.org/api/introduction/xdr/) to the wallet. The wallet is expected to sign the transaction and return the signed transaction.

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `xdr` : `STRING` -  stellar transaction encoded as XDR

### Returns

    1. `Object` - Signing parameters:
    	1.1. `signedXDR` : `STRING` -  stellar transaction encoded as XDR

### Example

```javascript
// Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "stellar_signXDR",
  "params": {
    "xdr": "AAAAAPewD+/6X8o0bx3bp49Wf+mUhG3o+TUrcjcst717DWJVAAAAyAFvzscADTkNAAAAAAAAAAAAAAACAAAAAAAAAAYAAAACWE1BVEsAAAAAAAAAAAAAAAPvNOuztX4IjvV8pztsEc1/ZnTz0G3p5Cx4vcf04+xUAAONfqTGgAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAD2NyeXB0b21hcmluZS5ldQAAAAAAAAAAAAAAAAF7DWJVAAAAQK3vfUCZ8mbjW3ssMd0n1tJTF9Fv6EbuJ6cWKkYXBqG5itqanPbFzIQoZEHbPS8nr2vo4dROvKI0uQzNcfExKwM="
  }
}

// Result
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "signedXDR": "AAAAAPewD+/6X8o0bx3bp49Wf+mUhG3o+TUrcjcst717DWJVAAAAyAFvzscADTkNAAAAAAAAAAAAAAACAAAAAAAAAAYAAAACWE1BVEsAAAAAAAAAAAAAAAPvNOuztX4IjvV8pztsEc1/ZnTz0G3p5Cx4vcf04+xUAAONfqTGgAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAD2NyeXB0b21hcmluZS5ldQAAAAAAAAAAAAAAAAF7DWJVAAAAQK3vfUCZ8mbjW3ssMd0n1tJTF9Fv6EbuJ6cWKkYXBqG5itqanPbFzIQoZEHbPS8nr2vo4dROvKI0uQzNcfExKwM="
  }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/tezos-rpc.md">
---
description: Tezos JSON-RPC Methods
---

# Tezos

## tezos_getAccounts

This method returns an array of public keys, which correspond to keypairs available in the wallet for signing.

### Parameters

    none

### Returns

    1.`Array` - Array of accounts:
    	1.1. `Object` - Account Data object with parameters:
    		1.1.1. `algo` : `STRING` - algorithm used for signing
    		1.1.2. `address` : `STRING` - corresponding address for keypair
    		1.1.3. `pubkey` : `STRING` - public key for keypair

### Example

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "tezos_getAccounts",
    "params": {}
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result":  [
        {
            "algo": "ed25519",
            "address": "tz1VQA4RP4fLjEEMW2FR4pE9kAg5abb5h5GL",
            "pubkey": "edpku4US3ZykcZifjzSGFCmFr3zRgCKndE82estE4irj4d5oqDNDvf"
        }
    ]
}
```

## tezos_send

This method returns a hash for the provided operations. They will be signed by the keypair corresponding to the requested signer address and sent to the blockchain.

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `account` : `STRING` - corresponding address for keypair
    	1.2. `operations` : `Array` - operations to be signed:
    		1.2.1. `Object` - identifier of blockchain
                1.2.1.1. `kind` : `STRING` - type of the operation
                1.2.1.2. `destination` : `STRING` - recipient of the operation
                1.2.1.3. `amount` : `STRING` - mutez amount
                1.2.1.4. `fee` : `STRING` - (optional) operation fee - NOTE: Not all wallets will respect this value because it's usually set by the wallet depending on network usage
                1.2.1.5. `gas_limit` : `STRING` - (optional) integer of the gas_limit
                1.2.1.6. `storage_limit` : `STRING` - (optional) integer of the storage_limit
                1.2.1.7. `parameters` : `Object` - (optional) contract call data

Note: All [RPC Operations](https://github.com/ecadlabs/taquito/blob/4dc6c391047b977b11eb92c7f5a5bc508ca32f01/packages/taquito/src/operations/types.ts#L553C13-L567) are valid. The above definition describes only the most common operation type.

### Returns

    1. `Object` - Signing parameters:
    	1.1. `operationHash` : `STRING` - hash of the operation

### Example

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "tezos_send",
    "params": {
        "account": "tz1VQA4RP4fLjEEMW2FR4pE9kAg5abb5h5GL",
        "operations": [
            {
                "kind": "transaction";
                "amount": "1";
                "destination": "tz1VQA4RP4fLjEEMW2FR4pE9kAg5abb5h5GL";
            }
        ]
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result":  {
        "operationHash": "op..."
    }
}
```

## tezos_sign

This method returns a signature for the provided payload. It will be signed by the keypair corresponding to the requested signer address.

### Parameters

    1. `Object` - Signing parameters:
    	1.1. `account` : `STRING` - corresponding address for keypair
    	1.2. `payload` : `STRING` - payload to be signed

### Returns

    1. `Object` - Signing parameters:
    	1.1. `signature` : `STRING` -  signature for signed payload

### Example

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "tezos_sign",
    "params": {
        "account": "tz1VQA4RP4fLjEEMW2FR4pE9kAg5abb5h5GL",
        "payload": "05010000004254",
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result":  {
        "signature": "edsig..."
    }
}
```
</file>

<file path="docs/advanced/multichain/rpc-reference/xrpl-rpc.md">
---
description: XRPL JSON-RPC Methods
---

# XRPL

## xrpl_signTransaction

This method is used to sign and submit a transaction to the XRP Ledger (XRPL). Every transaction has the same set of [common fields][XRPL Transaction Common Fields], plus additional fields based on the [transaction type][XRPL Transaction Types]. It is expected that the dapp provides all transaction fields defined as `required`, but not necessarily the `auto-fillable`.

### Parameters

- `Object`
  - `tx_json` : `Object` - _(Required)_ JSON specification of the transaction.
  - `autofill` : `Boolean` - _(Optional)_ Defaults to `true`. Set to `false` to skip auto-filling parameters.
  - `submit` : `Boolean` - _(Optional)_ Defaults to `true`. Set to `false` to skip submitting the transaction.

Please note that if you set `submit` to `false`, your dapp will need to encode the signed `tx_json` to the required [binary format][XRPL Serialization], before you can send it as `tx_blob` to an XRPL node using the [submit][XRPL Signed Transaction] command.

### Returns

- `Object`
  - `tx_json` : `Object` - JSON specification of the complete transaction as signed, including any fields that were auto-filled.

### Example

The example below specifies a simple DEX order for selling 15,000 XRP in exchange for 7,072.8 USD.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "xrpl_signTransaction",
    "params": {
        "tx_json": {
            "TransactionType": "OfferCreate",
            "Account": "rMBzp8CgpE441cp5PVyA9rpVV7oT8hP3ys",
            "Flags": 524288,
            "LastLedgerSequence": 7108682,
            "Expiration": 595640108,
            "TakerGets": "15000000000",
            "TakerPays": {
                "currency": "USD",
                "issuer": "rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B",
                "value": "7072.8"
            }
        }
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": {
        "tx_json": {
            "Account": "rMBzp8CgpE441cp5PVyA9rpVV7oT8hP3ys",
            "Expiration": 595640108,
            "Fee": "10",
            "Flags": 524288,
            "OfferSequence": 1752791,
            "Sequence": 1752792,
            "LastLedgerSequence": 7108682,
            "SigningPubKey": "03EE83BB432547885C219634A1BC407A9DB0474145D69737D09CCDC63E1DEE7FE3",
            "TakerGets": "15000000000",
            "TakerPays": {
                "currency": "USD",
                "issuer": "rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B",
                "value": "7072.8"
            },
            "TransactionType": "OfferCreate",
            "TxnSignature": "30440220143759437C04F7B61F012563AFE90D8DAFC46E86035E1D965A9CED282C97D4CE02204CFD241E86F17E011298FC1A39B63386C74306A5DE047E213B0F29EFA4571C2C",
            "hash": "73734B611DDA23D3F5F62E20A173B78AB8406AC5015094DA53F53D39B9EDB06C"
        }
    }
}
```

## xrpl_signTransactionFor

This method is used to add a signature to a [multi-signed][XRPL Multisign] transaction. The same common fields and transaction types as single-signed transactions are supported.

### Parameters

- `Object`
  - `tx_signer` : `String` - _(Required)_ The XRPL address of the signer.
  - `tx_json` : `Object` - _(Required)_ JSON specification of the transaction.
  - `autofill` : `Boolean` - _(Optional)_ Defaults to `false`. Set to `true` to auto-fill parameters.
  - `submit` : `Boolean` - _(Optional)_ Defaults to `false`. Set to `true` to submit the transaction.

Please note that `autofill` and `submit` both defaults to `false`, since explicit transaction specification and controlled submission is typically needed for multi-signed transactions.

### Returns

- `Object`
  - `tx_json` : `Object` - JSON specification of the complete transaction as signed, including any fields that were auto-filled.

### Example

The example below specifies a multi-signed payment transaction, already signed ([in serial][XRPL Multisign Methods]) by 3 of 4 required signers. Since only one more signature is required, the optional `submit` parameter has been set to `true`.

```javascript
// Request
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "xrpl_signTransactionFor",
    "params": {
        "submit": true,
        "tx_signer": "rJ4wmkgK8n93UjtaqQTaj1vxBwQWdLrBjP",
        "tx_json": {
            "Account": "rh2EsAe2xVE71ZBjx7oEL2zpD4zmSs3sY9",
            "TransactionType": "Payment",
            "Amount": "400000000000000",
            "Destination": "r9NpyVfLfUG8hatuCCHKzosyDtKnBdsEN3",
            "Fee": "5000",
            "Flags": 2147483648,
            "LastLedgerSequence": 73541531,
            "Sequence": 38,
            "Signers": [
                {
                    "Signer": {
                        "Account": "re3LGjhrCvthtWWwrfKbVJjXN9PYDeQDJ",
                        "SigningPubKey": "0320ECD5569CAFA4E23147BE238DBFB268DB3B5A502ED339387AC7DCA0ADC6FB90",
                        "TxnSignature": "3045022100EC2BF025E748A028187EDB3C350D518F91F05BC201EAFC9C92566DE9E48AA1B7022018847D172386E93679630E3905BD30481359E5766931944F79F1BA6D910F5C01"
                    }
                },
                {
                    "Signer": {
                        "Account": "rpcL6T32dYb6FDgdm4CnC1DZQSoMvvkLRd",
                        "SigningPubKey": "030BF97DA9A563A9A0679DD527F615CF8EA6B2DB55543075B72822B8D39910B5E1",
                        "TxnSignature": "304402201A891AF3945C81E2D6B95213B79E9A31635209AF0FB94DA8C0983D15F454179B0220388679E02CE6DE2AAC904A9C2F42208418BEF60743A7F9F76FC36D519902DA8C"
                    }
                },
                {
                    "Signer": {
                        "Account": "r3vw3FnkXn2L7St45tzpySZsXVgG75seNk",
                        "SigningPubKey": "030BE281F6DFF9AFD260003375B64235DDBCD5B7A54511BE3DA1FEF1ADE4A85D87",
                        "TxnSignature": "3044022049D36ACE39F1208B4C78A1550F458E54E21161FA4B52B3763C8FA9C4FE45B52C022003BE3579B5B5558A27BB7DC6A8ED163999A451665974138298469C1FDACA615F"
                    }
                }
            ],
            "SigningPubKey": ""
        }
    }
}

// Result
{
    "id": 1,
    "jsonrpc": "2.0",
    "result": {
        "tx_json": {
            "Account": "rh2EsAe2xVE71ZBjx7oEL2zpD4zmSs3sY9",
            "TransactionType": "Payment",
            "Amount": "400000000000000",
            "Destination": "r9NpyVfLfUG8hatuCCHKzosyDtKnBdsEN3",
            "Fee": "5000",
            "Flags": 2147483648,
            "LastLedgerSequence": 73541531,
            "Sequence": 38,
            "Signers": [
                {
                    "Signer": {
                        "Account": "re3LGjhrCvthtWWwrfKbVJjXN9PYDeQDJ",
                        "SigningPubKey": "0320ECD5569CAFA4E23147BE238DBFB268DB3B5A502ED339387AC7DCA0ADC6FB90",
                        "TxnSignature": "3045022100EC2BF025E748A028187EDB3C350D518F91F05BC201EAFC9C92566DE9E48AA1B7022018847D172386E93679630E3905BD30481359E5766931944F79F1BA6D910F5C01"
                    }
                },
                {
                    "Signer": {
                        "Account": "rpcL6T32dYb6FDgdm4CnC1DZQSoMvvkLRd",
                        "SigningPubKey": "030BF97DA9A563A9A0679DD527F615CF8EA6B2DB55543075B72822B8D39910B5E1",
                        "TxnSignature": "304402201A891AF3945C81E2D6B95213B79E9A31635209AF0FB94DA8C0983D15F454179B0220388679E02CE6DE2AAC904A9C2F42208418BEF60743A7F9F76FC36D519902DA8C"
                    }
                },
                {
                    "Signer": {
                        "Account": "r3vw3FnkXn2L7St45tzpySZsXVgG75seNk",
                        "SigningPubKey": "030BE281F6DFF9AFD260003375B64235DDBCD5B7A54511BE3DA1FEF1ADE4A85D87",
                        "TxnSignature": "3044022049D36ACE39F1208B4C78A1550F458E54E21161FA4B52B3763C8FA9C4FE45B52C022003BE3579B5B5558A27BB7DC6A8ED163999A451665974138298469C1FDACA615F"
                    }
                },
                {
                    "Signer": {
                        "Account": "rJ4wmkgK8n93UjtaqQTaj1vxBwQWdLrBjP",
                        "SigningPubKey": "02D5D616D4005B91DE02BF6E29157B514C667810860F389CF36DC9E4D5E73BFE79",
                        "TxnSignature": "304402207589FA73E72F85A2C8F82BBCB3C7C67C455D4C14A946BA427A4735F4ED106123022069845499A9DE50F26765F097BA0EA3C96E56A1304B380E0533514AEEF29363D7"
                    }
                }
            ],
            "SigningPubKey": "",
            "hash": "BA2AF0C652F46C97B85C1D17080EEC7422C092B0BD906DCA344B42EF30FA8285",
        }
    }
}
```

[XRPL Transaction Common Fields]: https://xrpl.org/transaction-common-fields.html
[XRPL Transaction Types]: https://xrpl.org/transaction-types.html
[XRPL Signed Transaction]: https://xrpl.org/transaction-basics.html#example-signed-transaction-blob
[XRPL Serialization]: https://xrpl.org/serialization.html#examples
[XRPL Algorithms]: https://xrpl.org/cryptographic-keys.html#signing-algorithms
[XRPL Multisign]: https://xrpl.org/multi-signing.html#multi-signing
[XRPL Multisign Methods]: https://xrpl.org/send-a-multi-signed-transaction.html#3-get-additional-signatures
</file>

<file path="docs/advanced/providers/ethereum.mdx">
import Table from '../../components/Table'

# Ethereum Provider

[EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compliant Provider for the WalletConnect v2 protocol.
Built on top of [Universal Provider](./universal.mdx) and [WalletConnectModal](../walletconnectmodal/about.mdx).
You can use this on it's own or pass it down to libraries like ethers, viem or web3js.

## Installation

```bash npm2yarn
npm install @walletconnect/ethereum-provider
```

## Initialization

Initialize Ethereum Provider by calling its `init` method and passing down the required arguments:

```ts
import { EthereumProvider } from '@walletconnect/ethereum-provider'

const provider = await EthereumProvider.init({
  projectId: 'YOUR_PROJECT_ID',
  metadata: {
    name: 'My Website',
    description: 'My Website Description',
    url: 'https://mywebsite.com', // origin must match your domain & subdomain
    icons: ['https://avatars.githubusercontent.com/u/37784886']
  },
  showQrModal: true,
  optionalChains: [1, 137, 2020],

  /*Optional - Add custom RPCs for each supported chain*/
  rpcMap: {
    1: 'mainnet.rpc...',
    137: 'polygon.rpc...'
  }
})
```

:::info

- Make sure that `url` from `metadata` matches your domain and subdomain. This will later be used by [Verify API](../../cloud/verify.mdx) to confirm if your application has been verified or not.
- We recommend using `optionalChains` (optional namespaces) over `chains` (required namespaces).  
  _Required namespaces_ will block wallets from connecting to your application if any of the chains are not supported by the wallet. Smart Contract Wallets can only support one chain,
  the one that they had been deployed to, this might cause issues when using required namespaces.
- Using `chains`, `methods` or `events` will create a _Required Namespaces_ object internally.
- `optionalMethods` and `optionalChains` default to the following methods and events: [Read source code](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/providers/ethereum-provider/src/constants/rpc.ts).
- If `rpcMap` is not defined it will fallback to [Blockchain API](../../cloud/blockchain-api.mdx) RPCs. Keep in mind that Blockchain API supports a limited [list of chains](https://github.com/WalletConnect/rpc-proxy/blob/master/SUPPORTED_CHAINS.md).
  :::

### Init Params

The Ethereum Provider's `init` method takes the following parameters:

<Table
  headers={['Value', 'Description', 'type', 'Required']}
  data={[
    {
      value: 'projectId',
      description:
        'Your project ID obtained from WalletConnect Cloud: https://cloud.walletconnect.com/',
      type: { code: 'string' },
      required: 'true'
    },
    {
      value: 'showQrModal',
      description:
        'Ethereum Provider integrates WalletConnectModal internally. When set to true it will open the UI modal when the connect function is called.',
      type: { code: 'boolean' },
      required: 'true'
    },
    {
      value: 'optionalChains',
      description:
        'An array of the chain IDs you want to support. It is highly recommended to use "optionalChains" over "chains" for multi-chain dapps, this will ensure compatibility with Smart Contract Wallets.',
      type: { code: 'number[]' },
      required: 'false'
    },
    {
      value: 'optionalMethods',
      description:
        'The Ethereum methods you want to support and send in the session proposal under the "optionalNamespaces" scope. If undefined it will default to all the EIP-1193 compatible methods.',
      type: { code: 'string[]' },
      required: 'false'
    },
    {
      value: 'optionalEvents',
      description:
        'The Ethereum events you want to support and send in the session proposal under the "optionalNamespaces" scope. If undefined it will default to all the EIP-1193 compatible events.',
      type: { code: 'string[]' },
      required: 'false'
    },
    {
      value: 'rpcMap',
      description: 'An object which keys are chain IDs and values are their RPC endpoints.',
      type: { code: 'Record<number, string>' },
      required: 'false'
    },
    {
      value: 'metadata',
      description:
        'Your applications metadata. It is important to set the correct URL as this will later be used by the Verify API to check if your domain has been verified.',
      type: { code: 'Metadata' },
      required: 'false'
    },
    {
      value: 'qrModalOptions',
      description:
        'An array of WalletConnectModal options. See https://docs.walletconnect.com/web3modal/options',
      type: { code: 'QrModalOptions' },
      required: 'false'
    },
    {
      value: 'chains',
      description:
        'An array of required chain IDs you want to support. If the wallet does not support this chains it will not be able to connect. Not recommended for multi-chain applications.',
      type: { code: 'number[]' },
      required: 'false'
    },
    {
      value: 'methods',
      description:
        'The required methods you want to support.  Not recommended for multi-chain applications.',
      type: { code: 'string[]' },
      required: 'false'
    },
    {
      value: 'events',
      description:
        'The required events you want to support. Not recommended for multi-chain applications.',
      type: { code: 'string[]' },
      required: 'false'
    }
  ]}
/>

## Use with WalletConnectModal

When `showQrModal` is enabled, EthereumProvider will automatically show and hide [WalletConnectModal](../walletconnectmodal/about.mdx).
You can also pass all relevant modal options under `qrModalOptions`. See [WalletConnectModal options](../walletconnectmodal/options.mdx) for all available fields.

## Use without WalletConnectModal

You can subscribe to the `display_uri` event and handle the URI yourself.

```ts
function handleURI(uri: string) {
  //code...
}

provider.on('display_uri', handleURI)

await provider.connect()
// or
const accounts = await provider.enable()
```

You can then use the URI to generate a QR Code or redirect the user from the mobile browser to the wallet and request to connect.
The later one will require you to use the wallet's deep link and the URI. You can get the deep link of wallets that support the WalletConnect v2 protocol from the [Explorer API](../../cloud/explorer.md).

## Sending Requests

```typescript
const result = await provider.request({ method: 'eth_requestAccounts' })

// OR

provider.sendAsync({ method: 'eth_requestAccounts' }, CallBackFunction)
```

## Events

```typescript
// chain changed
provider.on('chainChanged', handler)
// accounts changed
provider.on('accountsChanged', handler)
// session established
provider.on('connect', handler)
// session event - chainChanged/accountsChanged/custom events
provider.on('session_event', handler)
// connection uri
provider.on('display_uri', handler)
// session disconnected from the wallet - this won't be called when the disconnect function is called from the dapp.
provider.on('disconnect', handler)
```

## Session data

Once a wallet is connected you can find the session data in the `provider.session` object.

The session object includes the following properties, _among others_:

- **namespaces**: `session.namespaces` is an object that contains the approved session data.

:::caution

Note that the `chains` object is an optional parameter and may be undefined. Therefore, we encourage apps to obtain the approved chains from the `session.accounts` object instead.

:::

```ts
interface Namespaces {
  chains?: string[]
  accounts: string[]
  methods: string[]
  events: string[]
}
```

- **requiredNamespaces, optionalNamespaces & sessionProperties**: These objects contain the namespaces and properties proposed for the session.
- **peer**: The `session.peer.metadata` object contains the metadata of the connected wallet.

```ts
interface Metadata {
  name: string
  description: string
  url: string
  icons: string[]
  verifyUrl?: string
  redirect?: {
    native?: string
    universal?: string
  }
}
```

Find the complete type definition of the `session` object [here](https://github.com/WalletConnect/walletconnect-monorepo/blob/022e4d492c9862ab9b17c1a7b12884bdcd992ae4/packages/types/src/sign-client/session.ts#L25).
</file>

<file path="docs/advanced/providers/solana-adapter.mdx">
import CloudBanner from '../../components/CloudBanner'

# Solana Adapter

The WalletConnect Solana Adapter allows you to integrate the WalletConnect protocol into the Wallet Adapter library.

:::note
If you are not familiar with the Wallet Adapter library it is recommended to use [AppKit instead](../../appkit//overview.mdx).
:::

## Installation

```bash npm2yarn
npm install @walletconnect/solana-adapter
```

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

<CloudBanner />

## Implementation

Add the `WalletConnectAdapter` to your wallets list.

```tsx
import { ReactNode, useMemo, useState } from 'react'
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react'
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base'
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui'
import { clusterApiUrl } from '@solana/web3.js'

import '@solana/wallet-adapter-react-ui/styles.css'

/* highlight-add-start */
import { WalletConnectWalletAdapter } from '@walletconnect/solana-adapter'
/* highlight-add-end */

export const SolanaContext = ({ children }: { children: ReactNode }) => {
	const endpoint = useMemo(() => clusterApiUrl(WalletAdapterNetwork.Mainnet), [])

	const wallets = useMemo(
		() => [
      /* highlight-add-start */
			new WalletConnectWalletAdapter({
				network: WalletAdapterNetwork.Mainnet,
				options: {
					projectId: 'YOUR_PROJECT_ID',
				},
			}),
      /* highlight-add-end */
		],
		// eslint-disable-next-line react-hooks/exhaustive-deps
		[],
	)

	return (
		<ConnectionProvider endpoint={endpoint}>
			<WalletProvider wallets={wallets} autoConnect>
				<WalletModalProvider>
					{children}
				</WalletModalProvider>
			</WalletProvider>
		</ConnectionProvider>
	)
}
```
</file>

<file path="docs/advanced/providers/universal.mdx">
# Universal Provider

Universal Provider is a multi-chain provider for WalletConnect v2 protocol.

:::note
Find more about different supported chains [here](../../cloud/chains/overview.md).
:::

## Installation

```bash npm2yarn
npm install @walletconnect/universal-provider
```

## Usage

```typescript
import UniversalProvider from '@walletconnect/universal-provider'

//  Initialize the provider
const provider = await UniversalProvider.init({
  projectId: 'YOUR_PROJECT_ID',
  metadata: {
    name: 'React App',
    description: 'React App for WalletConnect',
    url: 'https://walletconnect.com/',
    icons: ['https://avatars.githubusercontent.com/u/37784886']
  },
  client: undefined // optional instance of @walletconnect/sign-client
})

//  create sub providers for each namespace/chain
await provider.connect({
  optionalNamespaces: {
    eip155: {
      methods: [
        'eth_sendTransaction',
        'eth_signTransaction',
        'eth_sign',
        'personal_sign',
        'eth_signTypedData'
      ],
      chains: ['eip155:80001'],
      events: ['chainChanged', 'accountsChanged'],
      rpcMap: {
        80001:
          'https://rpc.walletconnect.com?chainId=eip155:80001&projectId=<your walletconnect project id>'
      }
    }
  },
  pairingTopic: '<123...topic>', // optional topic to connect to
  skipPairing: false // optional to skip pairing ( later it can be resumed by invoking .pair())
})
```

## Events

```typescript
// Subscribe for pairing URI
provider.on('display_uri', uri => {
  console.log('display_uri', uri)
})

// Subscribe to session ping
provider.on('session_ping', ({ id, topic }) => {
  console.log('session_ping', id, topic)
})

// Subscribe to session event
provider.on('session_event', ({ event, chainId }) => {
  console.log('session_event', event, chainId)
})

// Subscribe to session update
provider.on('session_update', ({ topic, params }) => {
  console.log('session_update', topic, params)
})

// Subscribe to session delete
provider.on('session_delete', ({ id, topic }) => {
  console.log('session_delete', id, topic)
})
```

## Provider Methods

```typescript
interface RequestArguments {
  method: string;
  params?: any[] | undefined;
}

// Send JSON RPC requests

/**
 * @param payload
 * @param chain - optionally specify which chain should handle this request
 * in the format `<namespace>:<chainId>` e.g. `eip155:1`
 */
const result = await provider.request(payload: RequestArguments, chain: string | undefined);
```

## Chain switching

`DefaultChain` is the current chain that the provider will target for the next requested transaction.

```typescript
// set the default chain to 56
provider.setDefaultChain(`eip155:56`, rpcUrl?: string | undefined);
```

## Session data

Once a wallet is connected you can find the session data in the `provider.session` object.

The session object includes the following properties, _among others_:

- **namespaces**: `session.namespaces` is an object that contains the approved session data.

:::caution

Note that the `chains` object is an optional parameter and may be undefined. Therefore, we encourage apps to obtain the approved chains from the `session.accounts` object instead.

:::

```ts
interface Namespaces {
  chains?: string[]
  accounts: string[]
  methods: string[]
  events: string[]
}
```

- **requiredNamespaces, optionalNamespaces & sessionProperties**: These objects contain the namespaces and properties proposed for the session.
- **peer**: The `session.peer.metadata` object contains the metadata of the connected wallet.

```ts
interface Metadata {
  name: string
  description: string
  url: string
  icons: string[]
  verifyUrl?: string
  redirect?: {
    native?: string
    universal?: string
  }
}
```

Find the complete type definition of the `session` object [here](https://github.com/WalletConnect/walletconnect-monorepo/blob/022e4d492c9862ab9b17c1a7b12884bdcd992ae4/packages/types/src/sign-client/session.ts#L25).
</file>

<file path="docs/advanced/security/content-security-policy.md">
# Content Security Policy (CSP)

## Overview

A Content Security Policy (CSP) is a security feature that helps protect web applications from various attacks like Cross-Site Scripting (XSS), clickjacking, and data injection. By specifying allowed content sources, CSPs minimize the risk of executing malicious content on your site.

## CSP Guidance

### AppKit

The following is a **partial CSP** that covers WalletConnect's libraries and services for [AppKit](https://docs.walletconnect.com/appkit/overview). Note that **you may need to define additional sources based on your application's requirements**.

```
default-src 'self';
script-src 'self';
style-src https://fonts.googleapis.com;
img-src 'self' data: blob: https://walletconnect.org https://walletconnect.com https://secure.walletconnect.com https://secure.walletconnect.org https://tokens-data.1inch.io https://tokens.1inch.io https://ipfs.io;
font-src 'self' https://fonts.gstatic.com;
connect-src 'self' https://rpc.walletconnect.com https://rpc.walletconnect.org https://explorer-api.walletconnect.com https://explorer-api.walletconnect.org https://relay.walletconnect.com https://relay.walletconnect.org wss://relay.walletconnect.com wss://relay.walletconnect.org https://pulse.walletconnect.com https://pulse.walletconnect.org https://api.web3modal.com https://api.web3modal.org https://keys.walletconnect.com https://keys.walletconnect.org https://notify.walletconnect.com https://notify.walletconnect.org https://echo.walletconnect.com https://echo.walletconnect.org https://push.walletconnect.com https://push.walletconnect.org wss://www.walletlink.org;
frame-src 'self' https://verify.walletconnect.com https://verify.walletconnect.org https://secure.walletconnect.com https://secure.walletconnect.org;
```

:::info

You may need to list the RPC endpoints used by blockchain networks you have enabled (e.g. via the [`@wagmi/chains` package](https://wagmi.sh/core/api/chains)) as part of your `connect-src` definition.

For a full of list of RPC sources used by `wagmi/viem`, please refer to [Viem's chain definitions](https://github.com/wevm/viem/tree/main/src/chains/definitions).

:::

## Testing and Deploying Your CSP

### Test Your CSP in a Staging Environment

Run through your standard user flows in a staging environment with CSP enforcement. This may include connecting to browser extension wallets, transacting, logging out, etc. Directives may need updates after SDK upgrades. Always test your CSP again before deploying updates to production.

### Using Report-Only Mode

Use the `Content-Security-Policy-Report-Only` header, which sends violation reports without enforcing policies. This helps assess the impact of CSP changes without affecting functionality.

### Deployment

First deploy your CSP in `report-only` mode. After validation, migrate to `Content-Security-Policy` for enforcement.

### Monitoring

Configure `report-uri` or `report-to` to receive violation reports and set up a monitoring dashboard for review.
</file>

<file path="docs/advanced/walletconnectmodal/about.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Introduction

WalletConnectModal is a simple ui library intended for advanced use cases where users manage connections strings and associated WalletConnect API's themselves.

<CloudBanner />

## Installation

<PlatformTabs
	groupId="wcm"
	activeOptions={["web","ios","android", "react-native","flutter","unity"]}
>
<PlatformTabItem value="web">

#### Add packages (NPM)

```bash npm2yarn
npm install @walletconnect/modal
```

#### Add packages (CDN)

WalletConnectModal uses [unpkg](https://www.unpkg.com/) as its official CDN provider.
Instead of using the npm package, you can simply import it from their CDN and use it in the same way.

```html
<script type="module">
  import { WalletConnectModal } from 'https://unpkg.com/@walletconnect/modal'
</script>
```

</PlatformTabItem>
<PlatformTabItem value="ios">

:::caution
**The WalletConnectModal SDK is currently in Alpha and is not production-ready**.

It's public API and associated documentation may still see significant and breaking changes.
:::

#### SwiftPackageManager

You can add a WalletConnect SDK to your project with Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub url: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package
5. Choose the WalletConnectV2 products that you want installed in your app.

#### Alternatively, add WalletConnectModal to a `Package.swift` manifest

To integrate via a `Package.swift` manifest instead of Xcode, you can add
WalletConnectModal to the dependencies array of your package:

```swift
dependencies: [
  .package(
    name: "WalletConnectV2",
    url: "https://github.com/WalletConnectV2/WalletConnectSwiftV2.git",
    .upToNextMajor(from: "1.6.4")
  ),

  // Any other dependencies you have...
],
```

Then, in any target that depends on a WalletConnectV2 product, add it to the `dependencies`
array of that target:

```swift
.target(
  name: "MyTargetName",
  dependencies: [
    // The product(s) you want (e.g. WalletConnectModal).
    .product(name: "WalletConnectModal", package: "WalletConnectV2"),
  ]
),
```

</PlatformTabItem>
<PlatformTabItem value="android">

:::caution
**The WalletConnectModal SDK is currently in Alpha and is not production-ready**.

It's public API and associated documentation may still see significant and breaking changes.
:::

Kotlin implementation of WalletConnectModal for Android applications.

Android Core ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-core)

WalletConnectModal ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/walletconnect-modal)

#### Requirements

- Android min SDK 23
- Java 11

#### Installation

root/build.gradle.kts:

```gradle
allprojects {
   repositories {
      mavenCentral()
      maven { url "https://jitpack.io" }
   }
}
```

app/build.gradle.kts

```gradle
implementation(platform("com.walletconnect:android-bom:$BOM_VERSION"))
implementation("com.walletconnect:android-core")
implementation("com.walletconnect:walletconnect-modal")
```

</PlatformTabItem>
<PlatformTabItem value="react-native">
<Tabs>
<TabItem value="rn-cli" label="React Native CLI">

```bash npm2yarn
npm install @walletconnect/modal-react-native
```

Additionally add these extra packages to help with async storage, polyfills, modals and SVG's.

```bash npm2yarn
npm install @react-native-async-storage/async-storage react-native-get-random-values react-native-modal react-native-svg @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```

#### (Optional) Enable Wallet Detection

To enable WalletConnectModal to detect wallets installed on the device, you need to make specific changes to the native code of your project.

##### For iOS:

1. Open your `Info.plist` file.
2. Locate the `<key>LSApplicationQueriesSchemes</key>` section.
3. Add the desired wallet schemes as string entries within the `<array>`. These schemes represent the wallets you want to detect.
4. Refer to our [Info.plist example file](https://github.com/WalletConnect/react-native-examples/blob/main/dapps/ModalUProvider/ios/ModalUProvider/Info.plist) for a detailed illustration.

Example:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>metamask</string>
  <string>trust</string>
  <string>safe</string>
  <string>rainbow</string>
  <string>uniswap</string>
  <!-- Add other wallet schemes names here -->
</array>
```

##### For Android:

1. Open your `AndroidManifest.xml` file.
2. Locate the `<queries>` section.
3. Add the desired wallet package names as `<package>` entries within the `<queries>`. These package names correspond to the wallets you want to detect.
4. Refer to our [AndroidManifest.xml example file](https://github.com/WalletConnect/react-native-examples/blob/main/dapps/ModalUProvider/android/app/src/main/AndroidManifest.xml) for detailed guidance.

Example:

```xml
<queries>
  <package android:name="io.metamask"/>
  <package android:name="com.wallet.crypto.trustapp"/>
  <package android:name="io.gnosis.safe"/>
  <package android:name="me.rainbow"/>
  <!-- Add other wallet package names here -->
</queries>
```

Important Note: The WalletConnect SDK will only be able to detect the wallets that you explicitly list in your native files. Make sure to include all the relevant wallet schemes/packages you want to support.

For additional wallet schemes and package names, you can explore our [Explorer API](../../cloud/explorer.md). This API offers an up-to-date list of wallet identifiers that you can integrate into your project for enhanced wallet detection.

</TabItem>

<TabItem value="expo" label="Expo">

```
npx expo install @walletconnect/modal-react-native
```

Additionally add these extra packages to help with async storage, polyfills, modals and SVG's.

```
npx expo install @react-native-async-storage/async-storage react-native-get-random-values react-native-modal react-native-svg @react-native-community/netinfo @walletconnect/react-native-compat
```

<details>
<summary>Additional setup for Expo SDK 48 only</summary>
<div>

If you are using Expo SDK 48, you also need to polyfill `crypto` with expo-crypto library.

1. Add `expo-crypto`

```
npx expo install expo-crypto
```

2. Create a file named `crypto-polyfill.js`

```js
// src/crypto-polyfill.js

// Apply only with Expo SDK 48
import { getRandomValues as expoCryptoGetRandomValues } from 'expo-crypto'

class Crypto {
  getRandomValues = expoCryptoGetRandomValues
}

// eslint-disable-next-line no-undef
const webCrypto = typeof crypto !== 'undefined' ? crypto : new Crypto()

;(() => {
  if (typeof crypto === 'undefined') {
    Object.defineProperty(window, 'crypto', {
      configurable: true,
      enumerable: true,
      get: () => webCrypto
    })
  }
})()
```

3. Import `crypto-polyfill.js` in your App root file

```js
import './crypto-polyfill.js'
...
import { useWalletConnectModal } from '@walletconnect/modal-react-native';
```

</div>
</details>

#### (Optional) Enable Wallet Detection (iOS Only)

To enable WalletConnectModal to detect wallets installed on the device in your Expo project for iOS, follow these steps:

1. Open your `app.json` (or `app.config.js`) file.
2. Locate the ios section within the configuration.
3. Add the `infoPlist` object if it doesn't exist, and within it, include the `LSApplicationQueriesSchemes` array. This array will contain the desired wallet schemes you want to detect.
4. Add the wallet schemes to the `LSApplicationQueriesSchemes` array.

Your configuration should look like this:

```json
{
  "expo": {
    "ios": {
      "bundleIdentifier": "com.your.app",
      "infoPlist": {
        "LSApplicationQueriesSchemes": [
          "metamask",
          "trust",
          "safe",
          "rainbow",
          "uniswap"
          // Add other wallet schemes names here
        ]
      }
    }
  }
}
```

Configuring wallet detection for Android is not supported through Expo, as there's no direct way to add the required queries. This configuration is specifically for iOS in an Expo project.

Important Note: The WalletConnect SDK will only be able to detect the wallets that you explicitly list in your native files. Make sure to include all the relevant wallet schemes you want to support.

For additional wallet schemes, you can explore our [Explorer API](../../cloud/explorer.md). This API offers an up-to-date list of wallet identifiers that you can integrate into your project for enhanced wallet detection.

</TabItem>
</Tabs>

</PlatformTabItem>
<PlatformTabItem value="flutter">

Install the WalletConnect Modal package.

```dart
flutter pub add walletconnect_modal_flutter
```

</PlatformTabItem>
<PlatformTabItem value="unity">

#### Prerequisites

- Unity 2021.3 or above
- IL2CPP code stripping level: Minimal (or lower)

<Tabs>

<TabItem value="openupm-cli" label="OpenUPM CLI">

To install packages via OpenUPM, you need to have [Node.js](https://nodejs.org/en/) and [openupm-cli](https://openupm.com/docs/getting-started.html#installing-openupm-cli) installed. Once you have them installed, you can run the following commands:

```bash
openupm add com.walletconnect.modal
```

</TabItem>

<TabItem value="pm-openupm" label="Package Manager with OpenUPM">

1. Open `Advanced Project Settings` from the gear ‚öô menu located at the top right of the Package Manager‚Äôs toolbar
2. Add a new scoped registry with the following details:
   - Name: `OpenUPM`
   - URL: `https://package.openupm.com`
   - Scope(s): `com.walletconnect`
3. Press plus ‚ûï and then `Save` buttons
4. In the Package Manager windows open the add ‚ûï menu from the toolbar
5. Select `Add package by name...`
6. Enter the package name:
   - `com.walletconnect.modal`
7. Press `Add` button

</TabItem>

<TabItem value="pm-git-utl" label="Package Manager with Git URL">

1. Open the add ‚ûï menu in the Package Manager‚Äôs toolbar
2. Select `Add package from git URL...`
3. Enter the package URL. You will need to install 3 packages in the following order:

**WalletConnectUnity Core**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core
```

**WalletConnectUnity UI**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.ui
```

**WalletConnectUnity Modal**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.modal
```

4. Press `Add` button

</TabItem>
</Tabs>

#### (Optional) Installed Wallet Detection

To enable WalletConnect Modal to detect wallets installed on the device, you need to make specific changes to the native sides of the project.

<Tabs>
<TabItem value="unity-installed-wallets-android" label="Android">

1. In Unity [override Android Manifest](https://docs.unity3d.com/Manual/overriding-android-manifest.html).
2. Add your `<queries>...</queries>` schemes outside of `<application />` scope in the manifest file.
3. Refer to [Android Specs](https://developer.android.com/guide/topics/manifest/queries-element) for more information.

Example:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <queries>
        <package android:name="io.metamask"/>
        <package android:name="com.wallet.crypto.trustapp"/>
        <package android:name="io.gnosis.safe"/>
        <package android:name="me.rainbow"/>
        <!-- Add other wallet schemes names here -->
    </queries>

    <application>
        ...
    </application>
</manifest>
```

More wallet package names can be found in [our sample AndroidManifest.xml](https://github.com/WalletConnect/WalletConnectUnity/blob/project/modal-sample/Assets/Plugins/Android/AndroidManifest.xml).

</TabItem>
<TabItem value="unity-installed-wallets-ios" label="iOS">

Wallet detection may produce inaccurate results on iOS Simulator. It is recommended to test on a real device.

1. Make an iOS build.
2. In the generated Xcode project, find `Info.plist` file and open it with a external editor (i.e. not Xcode).
3. Locate or create `<key>LSApplicationQueriesSchemes</key>` section.
4. Add the desired wallet schemes as string entries within the `<array>`. These schemes represent the wallets you want to detect.

Example:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        ...

        <key>LSApplicationQueriesSchemes</key>
        <array>
            <string>metamask</string>
            <string>trust</string>
            <string>safe</string>
            <string>rainbow</string>
            <string>uniswap</string>
            <string>zerion</string>
            <string>imtokenv2</string>
            <string>spot</string>
            <string>omni</string>
            <string>dfw</string>
            <string>tpoutside</string>
            <string>robinhood-wallet</string>
        </array>

        ...
    </dict>
</plist>
```

</TabItem>
</Tabs>

Important Note: The WalletConnect SDK will only be able to detect the wallets that you explicitly list in your native files. Make sure to include all the relevant wallet schemes/packages you want to support.

For additional wallet schemes and package names, you can explore our [Explorer API](../../cloud/explorer.md). This API offers an up-to-date list of wallet identifiers that you can integrate into your project for enhanced wallet detection.

</PlatformTabItem>
</PlatformTabs>

## Next Steps

Now that you've installed WalletConnectModal, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the library.
</file>

<file path="docs/advanced/walletconnectmodal/options.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

import MobileWalletsPartial from '../../web3modal/v2/_partials/options/mobileWallets.mdx'
import DesktopWalletsPartial from '../../web3modal/v2/_partials/options/desktopWallets.mdx'
import WalletImagesPartial from '../../web3modal/v2/_partials/options/walletImages.mdx'
import ExplorerRecommendedWalletIdsPartial from '../../web3modal/v2/_partials/options/explorerRecommendedWalletIds.mdx'
import ExplorerExcludedWalletIdsPartial from '../../web3modal/v2/_partials/options/explorerExcludedWalletIds.mdx'
import TermsOfServiceUrlPartial from '../../web3modal/v2/_partials/options/termsOfServiceUrl.mdx'
import PrivacyPolicyUrlPartial from '../../web3modal/v2/_partials/options/privacyPolicyUrl.mdx'
import EnableExplorerPartial from '../../web3modal/v2/_partials/options/enableExplorer.mdx'
import ThemeModePartial from '../../web3modal/v2/_partials/options/themeMode.mdx'
import ThemeVariablesPartial from '../../web3modal/v2/_partials/options/themeVariables.mdx'
import ProjectIdPartial from '../../web3modal/v2/_partials/options/projectId.mdx'
import EnableAuthModePartial from '../../web3modal/v2/_partials/options/enableAuthMode.mdx'
import ChainsPartial from '../../web3modal/v2/_partials/options/chains.mdx'

# Options

<PlatformTabs
	groupId="wcm"
	activeOptions={["web", "react-native", "android", "flutter", "unity"]}
>
<PlatformTabItem value="web">

Following options can be passed to `WalletConnectModal` i.e.

```tsx
new WalletConnectModal({
  projectId: 'YOUR_PROJECT_ID'
})
```

#### projectId (required)

<ProjectIdPartial />

#### chains (required)

<ChainsPartial />

#### mobileWallets (optional)

<MobileWalletsPartial />

#### desktopWallets (optional)

<DesktopWalletsPartial />

#### walletImages (optional)

<WalletImagesPartial />

#### explorerRecommendedWalletIds (optional)

<ExplorerRecommendedWalletIdsPartial />

#### explorerExcludedWalletIds (optional)

<ExplorerExcludedWalletIdsPartial />

#### termsOfServiceUrl (optional)

<TermsOfServiceUrlPartial />

#### privacyPolicyUrl (optional)

<PrivacyPolicyUrlPartial />

#### enableExplorer (optional)

<EnableExplorerPartial />

#### themeMode (optional)

<ThemeModePartial />

#### themeVariables (optional)

<ThemeVariablesPartial />

#### enableAuthMode (optional)

<EnableAuthModePartial />

</PlatformTabItem>
<PlatformTabItem value="react-native">

#### projectId (required)

Your project‚Äôs unique identifier that can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com). Enables following functionalities within WalletConnectModal: wallet and chain logos, optional WalletConnect RPC, support for all v2 wallets from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet&version=2). Defaults to `undefined`.

```ts
projectId: string
```

#### providerMetadata (required)

Object that contains metadata of your app

```ts
providerMetadata: {
  name: string;
  description: string;
  url: string;
  icons: string[];
  redirect: {
    native: string;
    universal?: string;
  }
};
```

#### sessionParams (optional)

Defaults to:

```ts
sessionParams = {
  namespaces: {
    eip155: {
      methods: ['eth_sendTransaction', 'personal_sign'],
      chains: ['eip155:1'],
      events: ['chainChanged', 'accountsChanged'],
      rpcMap: {}
    }
  }
}
```

#### relayUrl (optional)

Define a custom Relay Server URL. Defaults to `"wss://relay.walletconnect.com"`

#### onCopyClipboard (optional)

This function is intended to be called when the user wants to copy something to the clipboard, and allows you to add the necessary actions to copy the value to the Clipboard.

Now used in:

- Copy button in QR Code view

```ts
onCopyClipboard: (value: string) => void;

//example
const onCopyClipboard = (value: string) => {
  Clipboard.setString(value);
};
```

#### explorerRecommendedWalletIds (optional)

Allows to override default recommended wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to prioritize (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. If you want to completely disable recommended wallets, you can set this option to `NONE`. Defaults to `undefined`.

```ts
explorerRecommendedWalletIds: string[] | 'NONE'

//example
explorerRecommendedWalletIds={[
  '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
]}
```

#### explorerExcludedWalletIds (optional)

Allows to exclude wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. If you want to exclude all wallets, you can set this option to `ALL`, however if `explorerRecommendedWalletIds` were defined, they will still be fetched. Defaults to `undefined`.

```ts
explorerExcludedWalletIds: string[] | 'ALL'

//example
explorerExcludedWalletIds={[
  '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
]}
```

#### accentColor (optional)

Allows to override WalletConnectModal's accent accentColor

```ts
accentColor: 'string' | undefined

//example
accentColor = '#9090FF'
```

</PlatformTabItem>

<PlatformTabItem value="android">

#### Explorer recommended wallets

Allows to set default recommended wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define a list of wallets ids you'd like to prioritise (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```kotlin
val recommendedWalletsIds = listOf<String>(
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"
)

val initParams = Modal.Params.Init(core = CoreClient, recommendedWalletsIds = recommendedWalletsIds)

WalletConnectModal.initialize(
    init = initParams,
    onSuccess = {
        // Callback will be called if initialization is successful
    },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

#### Explorer excluded wallets

Allows to exclude wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```kotlin
val excludedWalletIds = listOf<String>(
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"
)

val initParams = Modal.Params.Init(core = CoreClient, excludedWalletIds = excludedWalletIds)

WalletConnectModal.initialize(
    init = initParams,
    onSuccess = {
        // Callback will be called if initialization is successful
    },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

#### Show installed wallets

Allows you to show the `INSTALLED` label under the wallet icon in the list. To use this feature, you need to add selected wallets that you want to handle to `AndroidManifest.xml` as a query. Specs: [Android Specs](https://developer.android.com/guide/topics/manifest/queries-element)

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <queries>
        <package android:name="..."/>
    </queries>

    <application>
        ...
    </application>
</manifest>
```

</PlatformTabItem>

<PlatformTabItem value="flutter">

#### Web3App or projectId & PairingMetadata (required)

You must provide either a Web3App or a projectId and PairingMetadata.
Providing the Web3App lets you register callbacks on the Web3App you'd like to use.
Otherwise, we recommend just providing the projectId and PairingMetadata to the WalletConnectModalService directly.

```dart
final Web3App web3App = await Web3App.createInstance(
  projectId: 'YOUR_PROJECT_ID',
  metadata: const PairingMetadata(
    name: 'Flutter Dapp Example',
    description: 'Flutter Dapp Example',
    url: 'https://www.walletconnect.com/',
    icons: ['https://walletconnect.com/walletconnect-logo.png'],
    redirect: Redirect(
      native: 'flutterdapp://',
      universal: 'https://www.walletconnect.com',
    ),
  ),
);

// Register callbacks on the Web3App you'd like to use

WalletConnectModalService service = WalletConnectModalService(
  web3App: web3App,
);
```

or

```dart
WalletConnectModalService service = WalletConnectModalService(
  projectId: projectId,
  metadata: const PairingMetadata(
    name: 'Flutter Dapp Example',
    description: 'Flutter Dapp Example',
    url: 'https://www.walletconnect.com/',
    icons: ['https://walletconnect.com/walletconnect-logo.png'],
    redirect: Redirect(
      native: 'flutterdapp://',
      universal: 'https://www.walletconnect.com',
    ),
  ),
);
```

#### requiredNamespaces (optional)

Defaults to null.

This is the initial set of namespaces that will be requested from the wallet.

You can change it at any time with the `setRequiredNamespaces` method.

#### optionalNamespaces (optional)

Defaults to null.

This is the initial set of optional namespaces that will be requested from the wallet.

You can change it at any time with the `setOptionalNamespaces` method.

#### recommendedWalletIds (optional)

Allows to override default recommended wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to prioritize (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. Defaults to `null`.

```dart
final Set<String> recommendedWalletIds = {
  'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96', // MetaMask
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0', // Trust
}
```

#### excludedWalletState & excludedWalletids (optional)

The `excludedWalletState` Determines the state of the excluded wallets. Defaults to `ExcludedWalletState.list`.

If the `excludedWalletState` is `ExcludedWalletState.list`, the `excludedWalletIds` will be used to remove items from the list of wallets returned from the [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). If the `excludedWalletState` is `ExcludedWalletState.all`, all wallets will be excluded except for the ones defined in `recommendedWalletIds`.

</PlatformTabItem>

<PlatformTabItem value="unity">

#### ConnectOptions

Session connection options

```csharp
ConnectOptions = new ConnectOptions
{
    RequiredNamespaces = new RequiredNamespaces
    {
        {
            "eip155", new ProposedNamespace
            {
                Methods = new[]
                {
                    "eth_sendTransaction",
                    "personal_sign",
                    "eth_signTypedData"
                },
                Chains = new[]
                {
                    "eip155:1"
                },
                Events = new[]
                {
                    "chainChanged",
                    "accountsChanged"
                },
            }
        }
    }
}
```

#### IncludedWalletIds

Allows to override default recommended wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to prioritize (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. Defaults to `null`.

```csharp
IncludedWalletIds = new[]
{
    "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96", // MetaMask
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0", // Trust
}
```

#### ExcludedWalletIds

Allows to exclude wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. Defaults to `null`.

```csharp
ExcludedWalletIds = new[]
{
    "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96", // MetaMask
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0", // Trust
}
```

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/advanced/walletconnectmodal/resources.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

# Resources

Valuable assets for developers and users interested in integrating Web3Wallet into their applications.

<!--Todo: Prettify this section-->

- [Awesome WalletConnect](https://github.com/WalletConnect/awesome-walletconnect) - Community-curated collection of WalletConnect-enabled wallets, libraries, and tools.
- [AppKit Laboratory](https://lab.web3modal.com) - A place to test your wallet integrations against various setups of AppKit.
- [Web3Wallet GitHub](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet) - Web3Wallet GitHub repository.

## Implementation Examples

<PlatformTabs
	groupId="wcm"
	activeOptions={["web","ios","android", "react-native", "flutter", "unity"]}
>
<PlatformTabItem value="web">

To check more in detail go and visit our [WalletConnect Modal Web implementation app](https://github.com/WalletConnect/web3modal-examples)

</PlatformTabItem>
<PlatformTabItem value="ios">

To check more in detail go and visit our [WalletConnect Modal Swift implementation app](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example/WalletApp)

</PlatformTabItem>
<PlatformTabItem value="android">

To check more in detail go and visit our [WalletConnect Modal Kotlin implementation app](https://github.com/WalletConnect/WalletConnectKotlinV2/tree/develop/sample)

</PlatformTabItem>
<PlatformTabItem value="react-native">

- Check our implementation of [Modal + Viem](https://github.com/WalletConnect/react-native-examples/tree/main/dapps/ModalViem)
- Check our implementation of [Modal + Ethers](https://github.com/WalletConnect/react-native-examples/tree/main/dapps/ModalEthers)
- Check our implementation of [Modal + Universal Provider](https://github.com/WalletConnect/react-native-examples/tree/main/dapps/ModalUProvider)
- To check more in details go and visit our [WalletConnect Modal React Native implementation app](https://github.com/WalletConnect/modal-react-native/tree/main/example)

</PlatformTabItem>
<PlatformTabItem value="flutter">

To check more in detail go and visit our [WalletConnect Modal Flutter implementation app](https://github.com/WalletConnect/WalletConnectModalFlutter/tree/master/example/sign)

</PlatformTabItem>
<PlatformTabItem value="unity">

To check more in detail go and visit our [WalletConnect Modal Unity implementation sample](https://github.com/WalletConnect/WalletConnectUnity/tree/main/Packages/com.walletconnect.modal/Samples~/Modal%20Sample)

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/advanced/walletconnectmodal/theming.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

import WcModalThemeVariablesTable from '../../web3modal/v2/_partials/wcModalThemeVariablesTable.mdx'
import ThemeModePartial from '../../web3modal/v2/_partials/themeMode.mdx'
import ThemeVariablesPartial from '../../web3modal/v2/_partials/themeVariables.mdx'

# Theming

:::note
The following theme configuration is only available for **Web** and **React Native**.
:::

<PlatformTabs
	groupId="wcm"
	activeOptions={["web", "react-native", "android", "flutter"]}
>
<PlatformTabItem value="web">

#### themeMode

<ThemeModePartial />

### Example

```tsx
const modal = new WalletConnectModal({
  themeMode: 'dark'
})
```

## themeVariables

<ThemeVariablesPartial />

### Example

```tsx
const modal = new WalletConnectModal({
  themeVariables: {
    '--wcm-font-family': 'Roboto, sans-serif',
    '--wcm-accent-color': '#F5841F'
  }
})
```

### List of theme variables

<WcModalThemeVariablesTable />

</PlatformTabItem>
<PlatformTabItem value="react-native">

## themeMode (optional)

Puts WalletConnectModal into dark or light mode. Defaults to user's system preference.

```ts
themeMode: 'dark' | 'light'
```

## accentColor (optional)

Allows to override Modal's accent color. Defaults to `undefined`.

```ts
<WalletConnectModal
  ...
  accentColor="#9090FF"
/>
```

</PlatformTabItem>

<PlatformTabItem value="android">

#### WalletConnectModal Theme

Allows to override Modal's accent color.

#### Compose

Wrap your composables in `WalletConnectModalTheme`.

```kotlin
WalletConnectModalTheme(
    accentColor = Color(0xFF3496ff),
    onAccentColor = Color.White
) {
    ModalBottomSheetLayout() {  }
}
```

#### Android View

You can override the default Modal's accent color by creating a `WalletConnectModalTheme`.

```xml
<style name="WalletConnectModalTheme">
    <item name="accentColor">#FF47A1FF</item>
    <item name="onAccentColor">#FFFFFFFF</item>
</style>
```

</PlatformTabItem>

<PlatformTabItem value="flutter">

To theme the `WalletConnectModal` you must wrap your `MaterialApp` with a `WalletConnectModalTheme` widget.

```dart
return WalletConnectModalTheme(
  data: WalletConnectModalThemeData.darkMode,
  child: MaterialApp(
    title: 'Flutter Demo',
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
      useMaterial3: true,
    ),
    home: const MyHomePage(title: 'WalletConnectModal Sign Example'),
  ),
);
```

If you don't wrap your `MaterialApp` with a `WalletConnectModalTheme` widget, the `WalletConnectModal` will use the default light theme.

You can build your own theme by creating a `WalletConnectModalThemeData` object.

Here is how the dark mode theme is built:

```dart
// Dark Mode Theme
WalletConnectModalThemeData(
  primary100: Color(0xFF47A1FF),
  primary090: Color(0xFF59AAFF),
  primary080: Color(0xFF6CB4FF),
  overlay002: Color.fromARGB(5, 255, 255, 255),
  overlay005: Color.fromARGB(13, 255, 255, 255),
  overlay010: Color.fromARGB(26, 255, 255, 255),
  overlay020: Color.fromARGB(51, 255, 255, 255),
  overlay030: Color.fromARGB(77, 255, 255, 255),
  foreground100: Color(0xFFE4E7E7),
  foreground200: Color(0xFF949E9E),
  foreground275: Color(0xFF788181),
  foreground300: Color(0xFF6E7777),
  background100: Color(0xFF141414),
  background200: Color(0xFF272A2A),
  background300: Color(0xFF3B4040),
  inverse000: Color(0xFF000000),
  inverse100: Color(0xFFFFFFFF),
  error: Color(0xFFF25A67),
  success: Color(0xFF26D962),
  fontFamily: 'roboto',
  radius4XS: 6.0,
  radius3XS: 8.0,
  radius2XS: 12.0,
  radiusXS: 16.0,
  radiusS: 20.0,
  radiusM: 28.0,
  radiusL: 36.0,
  radius3XL: 80.0,
);
```

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/advanced/walletconnectmodal/usage.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

# Usage

This section provides instructions on how to use WalletConnectModal in your project.

## Implementation

<PlatformTabs
	groupId="wcm"
	activeOptions={["web","ios","android","flutter","react-native", "unity"]}
>
<PlatformTabItem value="web">

Start by importing `WalletConnectModal` and initializing it.

```js
import { WalletConnectModal } from '@walletconnect/modal'

const modal = new WalletConnectModal({
  projectId: 'YOUR_PROJECT_ID',
  chains: ['eip155:1']
})
```

#### Trigger the modal

Once you have obtained your connection uri, you can open or close the modal.

From here on, use `provider` as you normally would, WalletConnectModal will be shown and hidden automatically i.e.

```js
await modal.openModal({
  uri: 'YOUR_CONNECTION_URI'
})

// Do some work...

modal.closeModal()
```

</PlatformTabItem>
<PlatformTabItem value="ios">

#### Configure Networking and Pair clients

Make sure that you properly configure Networking and Pair Clients first.

- [Networking](../../api/core/relay.mdx)

#### Initialize WalletConnectModal Client

In order to initialize a client just call a `configure` method from the Web3Wallet instance wrapper

```swift
let metadata = AppMetadata(
    name: "Example Wallet",
    description: "Wallet description",
    url: "example.wallet",
    icons: ["https://avatars.githubusercontent.com/u/37784886"],
    // Used for the Verify: to opt-out verification ignore this parameter
    verifyUrl: "verify.walletconnect.com"
)

WalletConnectModal.configure(
    projectId: PROJECT_ID,
    metadata: metadata
)
```

This example will default to using following namespaces.

```swift
let methods: Set<String> = ["eth_sendTransaction", "personal_sign", "eth_signTypedData"]
let events: Set<String> = ["chainChanged", "accountsChanged"]
let blockchains: Set<Blockchain> = [Blockchain("eip155:1")!]
let namespaces: [String: ProposalNamespace] = [
    "eip155": ProposalNamespace(
        chains: blockchains,
        methods: methods,
        events: events
    )
]

let defaultSessionParams =  SessionParams(
                                requiredNamespaces: namespaces,
                                optionalNamespaces: nil,
                                sessionProperties: nil
                            )
```

If you want to change that you can call configure and define your own session parameters like this.

```swift
let metadata = AppMetadata(...)

let sessionParams = SessionParams(...)

WalletConnectModal.configure(
    projectId: PROJECT_ID,
    metadata: metadata,
    sessionParams: sessionParams
)
```

or you can change them later by calling `WalletConnectModal.set(sessionParams: SessionParams(...))`

</PlatformTabItem>
<PlatformTabItem value="android">

`WalletConnectModal` is a singleton that interacts with the WalletConnectModal SDK.

#### Initialize

```kotlin
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val projectId = "" // Get Project ID at https://cloud.walletconnect.com/
val appMetaData = Core.Model.AppMetaData(
    name = "Kotlin.WalletConnectModal",
    description = "Kotlin WalletConnectModal Implementation",
    url = "kotlin.walletconnect.com",
    icons = listOf("https://raw.githubusercontent.com/WalletConnect/walletconnect-assets/master/Icon/Gradient/Icon.png"),
    redirect = "kotlin-modal://request"
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

WalletConnectModal.initialize(
    init = Modal.Params.Init(CoreClient),
    onSuccess = {
        // Callback will be called if initialization is successful
     },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

#### SessionParams

This example will default to using following namespaces.
You can define your own session parameters like this.

```kotlin
val methods: List<String> = listOf("eth_sendTransaction", "personal_sign", "eth_sign", "eth_signTypedData")
val events: List<String> = listOf("chainChanged", "accountsChanged")
val chains: List<String> = listOf("eip155:1")
val namespaces = mapOf(
    "eip155" to Modal.Model.Namespace.Proposal(
        chains = chains,
        methods = methods,
        events = events
    )
)

val sessionParams = Modal.Params.SessionParams(
    requiredNamespaces = namespaces,
    optionalNamespaces = null,
    properties = null
)

WalletConnectModal.setSessionParams(sessionParams)
```

**IMPORTANT**: `SessionParams` must be set before opening the modal.

</PlatformTabItem>
<PlatformTabItem value="flutter">

Create your `WalletConnectModalService` which is your primary class for opening, closing, disconnecting, etc.

Be sure to update the project ID and metadata with your own.

```dart
WalletConnectModalService service = WalletConnectModalService(
  projectId: 'YOUR_PROJECT_ID',
  metadata: const PairingMetadata(
    name: 'Flutter WalletConnect',
    description: 'Flutter WalletConnectModal Sign Example',
    url: 'https://walletconnect.com/',
    icons: ['https://walletconnect.com/walletconnect-logo.png'],
    redirect: Redirect(
      native: 'flutterdapp://',
      universal: 'https://www.walletconnect.com',
    ),
  ),
);
await service.init();
```

The service must be initialized before it can be used.

With the `WalletConnectModalService` created and ready, you can call `_service.open()` to open the modal.

To make things easy, you can use the WalletConnectModalConnect widget to open the modal.
This is a button that changes its state based on the modal and connection.
This widget requires the WalletConnectModalService to be passed in.

```dart
WalletConnectModalConnect(
  walletConnectModalService: _service,
),
```

#### iOS Setup

For each app you would like to be able to deep link to, you must add that app's link into the `ios/Runner/Info.plist` file like so:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>metamask</string>
  <string>rainbow</string>
  <string>trust</string>
</array>
```

To handle deep linking to your app, you will also need to add the following to the plist file:

```xml
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>flutterdapp</string> <!-- Change "flutterdapp" to be your deep link -->
        </array>
        <key>CFBundleURLName</key>
        <string>com.walletconnect.flutterdapp</string> <!-- Change this package name to be your package -->
    </dict>
</array>
```

#### Android Setup

On android 11+ you must specify that use can use the internet, along with the different packages you would like to be able to deep link to in the `android/app/src/main/AndroidManifest.xml` file like so:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Intent so you can deep link to wallets -->
    <queries>
        <intent>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="https" />
        </intent>
        <package android:name="io.metamask"/>
        <package android:name="com.wallet.crypto.trustapp"/>
        <package android:name="io.gnosis.safe"/>
        <package android:name="me.rainbow"/>
        <package android:name="io.zerion.android"/>
        <package android:name="com.imtoken.app"/>
        <!-- Add other wallets you would like to launch from within the app -->
    </queries>
    <!-- Permission to access the internet -->
    <uses-permission android:name="android.permission.INTERNET"/>
    <!-- Update your activity to handle the deep linking from other apps -->
    <activity
            ...>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <!-- Accepts URIs that begin with "flutterdapp://‚Äù, change this to be your deep link -->
                <data android:scheme="flutterdapp" />
            </intent-filter>
        </activity>
    ...
</manifest>
```

For other packages, see the [example project](https://github.com/WalletConnect/Web3ModalFlutter/blob/2981053456ecd3511ca2e3a7f0def7c75e22af62/example/sign/android/app/src/main/AndroidManifest.xml#L2)

For some reason, multiple wallets have the `metamask` intent, and will launch metamask as a result.
This is a bug in the wallets, not this package.

</PlatformTabItem>

<PlatformTabItem value="react-native">

Start by importing `@walletconnect/react-native-compat` at the top of your app. Then import the WalletConnect Modal package, replace `YOUR_PROJECT_ID` with your [WalletConnect Cloud](https://cloud.walletconnect.com/sign-in) Project ID and add your Project's info in `providerMetadata`

```tsx
import '@walletconnect/react-native-compat'
import { WalletConnectModal } from '@walletconnect/modal-react-native'

const projectId = 'YOUR_PROJECT_ID'

const providerMetadata = {
  name: 'YOUR_PROJECT_NAME',
  description: 'YOUR_PROJECT_DESCRIPTION',
  url: 'https://your-project-website.com/',
  icons: ['https://your-project-logo.com/'],
  redirect: {
    native: 'YOUR_APP_SCHEME://',
    universal: 'YOUR_APP_UNIVERSAL_LINK.com'
  }
}

function App() {
  return (
    <>
      <WalletConnectModal projectId={projectId} providerMetadata={providerMetadata} />
    </>
  )
}
```

</PlatformTabItem>

<PlatformTabItem value="unity">

1. Fill in the Project ID and Metadata fields in the `Assets/WalletConnectUnity/Resources/WalletConnectProjectConfig` asset.
   - If you don‚Äôt have a Project ID, you can create one at [WalletConnect Cloud](https://cloud.walletconnect.com).
   - The `Redirect` fields are optional. They are used to redirect the user back to your app after they approve or reject the session.
2. Add `WalletConnectModal` prefab from `WalletConnectUnity Modal` package to the first scene in your game.

</PlatformTabItem>
</PlatformTabs>

## Usage

<PlatformTabs
	groupId="wcm"
	activeOptions={["web","ios","android","flutter", "react-native", "unity"]}
>

<PlatformTabItem value="web">

#### openModal

Action to open the modal. Returns promise that resolves once modal is visible.

#### Example

```js
await modal.openModal({
  uri: 'YOUR_CONNECTION_URI'
})
```

#### Reference

```ts
openModal: (options?: OpenOptions) => Promise<void>
```

```ts
interface OpenOptions {
  // Uri that will be used to generate qrcode and mobile links, required
  uri: string
  // CAIP-2 compliant chain ids to override initial chains defined when creating the modal
  // Learn about CAIP-10: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md
  chains?: string[]
}
```

#### closeModal

Action to close the modal.

#### Example

```js
modal.closeModal()
```

#### Reference

```ts
closeModal: () => void
```

#### subscribeModal

Action to subscribe to modal state changes.

#### Example

```js
modal.subscribeModal(state => console.log(state))
```

#### Reference

```ts
subscribeModal: (callback: (state: ModalState) => void) => void
```

```ts
interface ModalState {
  open: boolean
}
```

</PlatformTabItem>
<PlatformTabItem value="ios">

To actually present the modal you can simply call.

```swift
WalletConnectModal.present()
```

It will traverse the view hierarchy and try to present from top most controller. This is meant more towards SwiftUI.

Otherwise you can specify the viewController to present from.

```swift
WalletConnectModal.present(from: viewController)
```

#### Subscribe for WalletConnectModal Publishers

The following publishers are available to subscribe:

```swift
public var sessionPublisher: AnyPublisher<[Session], Never>
public var sessionSettlePublisher: AnyPublisher<Session, Never>
public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never>
public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
public var sessionResponsePublisher: AnyPublisher<Response, Never>
public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
```

#### Sign methods

WalletConnectModal is internally using Sign SDK and most of its method are being exposed through WalletConnectModal interface.

#### Where to go from here

Check the WalletConnectModal usage in our Example Showcase app that is part of WalletConnectSwiftV2 repository.
Build API documentation in Xcode by going to `Product -> Build Documentation`

</PlatformTabItem>

<PlatformTabItem value="android">

#### Android Compose

```kotlin
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.ModalBottomSheetState
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.google.accompanist.navigation.material.BottomSheetNavigator
import com.google.accompanist.navigation.material.ExperimentalMaterialNavigationApi
import com.google.accompanist.navigation.material.ModalBottomSheetLayout
import com.google.accompanist.navigation.material.bottomSheet
import com.walletconnect.wcmodal.ui.walletConnectModalGraph

setContent {
    val modalSheetState = rememberModalBottomSheetState(initialValue = ModalBottomSheetValue.Hidden, skipHalfExpanded = true)
    val bottomSheetNavigator = BottomSheetNavigator(modalSheetState)
    val navController = rememberNavController(bottomSheetNavigator)

    ModalBottomSheetLayout(bottomSheetNavigator = bottomSheetNavigator) {
        NavHost(
            navController = navController,
            startDestination = "home"
        ) {
            composable("home") {
                HomeScreen()
            }
            walletConnectModalGraph(navController)
        }
    }
}
```

**IMPORTANT**: WalletConnectModal uses accompanist navigation material inside. `ModalBottomSheetLayout` should be imported from [Accompanist Navigation Material](https://google.github.io/accompanist/navigation-material/)

```kotlin
import com.walletconnect.wcmodal.ui.openWalletConnectModal

navController.openWalletConnectModal()
```

#### Android View

#### Navigation Component

```xml
<navigation >
    <fragment
        android:id="@+id/HomeFragment"
        android:name="com.walletconnect.sample.HomeFragment">

        <action
            android:id="@+id/action_to_bottomSheet"
            app:destination="@id/bottomSheet" />
    </fragment>

    <dialog
        android:id="@+id/bottomSheet"
        android:name="com.walletconnect.wcmodal.ui.WalletConnectModalSheet" />
</navigation>
```

```kotlin
import androidx.navigation.fragment.findNavController
import com.walletconnect.wcmodal.ui.openWalletConnectModal

findNavController().openWalletConnectModal(id = R.id.action_to_bottomSheet)
```

#### Kotlin DSL

```kotlin
import androidx.navigation.createGraph
import androidx.navigation.fragment.fragment
import com.walletconnect.wcmodal.ui.walletConnectModal

navController.graph = navController.createGraph("Home") {
    fragment<HomeFragment>("Home")
    walletConnectModal()
}
```

```kotlin
import androidx.navigation.fragment.findNavController
import com.walletconnect.wcmodal.ui.openWalletConnectModal

findNavController().openWalletConnectModal()
```

#### WalletConnectModal.ModalDelegate

```kotlin
val walletConnectModalDelegate = object : WalletConnectModal.ModalDelegate {
    override fun onSessionApproved(approvedSession: Modal.Model.ApprovedSession) {
        // Triggered when receives the session approval from wallet
    }

    override fun onSessionRejected(rejectedSession: Modal.Model.RejectedSession) {
        // Triggered when receives the session rejection from wallet
    }

    override fun onSessionUpdate(updatedSession: Modal.Model.UpdatedSession) {
        // Triggered when receives the session update from wallet
    }

    override fun onSessionExtend(session: Modal.Model.Session) {
        // Triggered when receives the session extend from wallet
    }

    override fun onSessionEvent(sessionEvent: Modal.Model.SessionEvent) {
        // Triggered when the peer emits events that match the list of events agreed upon session settlement
    }

    override fun onSessionDelete(deletedSession: Modal.Model.DeletedSession) {
        // Triggered when receives the session delete from wallet
    }

    override fun onSessionRequestResponse(response: Modal.Model.SessionRequestResponse) {
        // Triggered when receives the session request response from wallet
    }

    override fun onProposalExpired(proposal: Modal.Model.ExpiredProposal) {
        // Triggered when a proposal becomes expired
    }

    override fun onRequestExpired(request: Modal.Model.ExpiredRequest) {
        // Triggered when a request becomes expired
    }

    override fun onConnectionStateChange(state: Modal.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Modal.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}
```

The WalletConnectModal needs a `WalletConnectModal.ModalDelegate` passed to it for it to be able to expose asynchronously updates sent from the Wallet. It can only be called after successful `WalletConnectModal` initialization

#### Connect

```kotlin
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val chains: List<String> = /*List of chains that wallet will be requested for*/
val methods: List<String> = /*List of methods that wallet will be requested for*/
val events: List<String> = /*List of events that wallet will be requested for*/
val requiredNamespaces: Map<String, Modal.Model.Namespaces.Proposal> = mapOf(namespace, Modal.Model.Namespaces.Proposal(accounts, methods, events)) /*Required namespaces to setup a session*/
val optionalNamespaces: Map<String, Modal.Model.Namespaces.Proposal> = mapOf(namespace, Modal.Model.Namespaces.Proposal(accounts, methods, events)) /*Optional namespaces to setup a session*/
val pairing: Core.Model.Pairing = /*Either an active or inactive pairing*/
val connectParams = Modal.Params.Connect(requiredNamespaces, optionalNamespaces, pairing)

WalletConnectModal.connect(
    connect = connectParams,
    onSuccess = {
        /* callback that letting you know that you have successfully initiated connecting */
    },
    onError = { error =>
        /* callback for error while trying to initiate a connection with a peer */
    }
)
```

More about optional and required namespaces can be found [here](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md)

#### Disconnect

```kotlin
val disconnectParams = WalletConnectModal.Params.Disconnect(topic)

WalletConnectModal.disconnect(
    disconnect = disconnectParams,
    onSuccess = {
    /* callback that letting you know that you have successfully disconnected */
    },
    onError = { error ->
    /* callback for error while trying to disconnection with a peer */
    }
)
```

#### Request

```kotlin
val requestParams = Modal.Params.Request(
    sessionTopic = sessionTopic,
    method = /* Selected method */,
    params = /* Method params  */,
    chainId = /* Chain id */
)

WalletConnectModal.request(
    request = requestParams,
    onSuccess = {
    /* callback that letting you know that you have successful request */
    },
    onError = { error ->
    /* callback for error */
    }
)
```

#### Get List of Active Sessions

```kotlin
WalletConnectModal.getListOfActiveSessions()
```

To get a list of active sessions, call `WalletConnectModal.getListOfActiveSessions()` which will return a list of type `Modal.Model.Session`.

#### Get list of pending session requests for a topic

```kotlin
WalletConnectModal.getActiveSessionByTopic(topic)
```

To get an active session for a topic, call `WalletConnectModal.getActiveSessionByTopic()` and pass a topic which will return
a `Modal.Model.Session` object containing requestId, method, chainIs and params for pending request.

</PlatformTabItem>

<PlatformTabItem value="flutter">

You can launch the currently connected wallet by calling `service.launchCurrentWallet()`.

</PlatformTabItem>

<PlatformTabItem value="react-native">

#### useWalletConnectModal

Hook to programmatically control the modal. Useful when you want to use your own UI elements and subscribe to modals state.

\*Note: A new session is created automatically when the modal is opened, so avoid calling `provider.connect` by yourself.

```tsx
import { useWalletConnectModal } from "@walletconnect/modal-react-native";

const { isOpen, open, close, provider, isConnected, address } = useWalletConnectModal();

// Modal's open state
isOpen;

// Open modal
interface Options {
  route?: 'ConnectWallet' | 'Qrcode' | 'WalletExplorer';
}
await open(options?: Options);

// Close modal
close();

// Initialized provider
provider;

// Wallet connection state
isConnected;

// Connected account's address
address;

```

#### Example

```tsx
import { Pressable, Text } from 'react-native'
import '@walletconnect/react-native-compat'
import { WalletConnectModal, useWalletConnectModal } from '@walletconnect/modal-react-native'

const projectId = 'YOUR_PROJECT_ID'

const providerMetadata = {
  name: 'YOUR_PROJECT_NAME',
  description: 'YOUR_PROJECT_DESCRIPTION',
  url: 'https://your-project-website.com/',
  icons: ['https://your-project-logo.com/'],
  redirect: {
    native: 'YOUR_APP_SCHEME://',
    universal: 'YOUR_APP_UNIVERSAL_LINK.com'
  }
}

function App() {
  const { open, isConnected, provider } = useWalletConnectModal()

  const onPress = () => {
    if (isConnected) {
      provider.disconnect()
    } else {
      open()
    }
  }

  return (
    <>
      <Pressable onPress={onPress}>
        <Text>{isConnected ? 'Disconnect' : 'Connect'}</Text>
      </Pressable>
      <WalletConnectModal projectId={projectId} providerMetadata={providerMetadata} />
    </>
  )
}
```

</PlatformTabItem>
<PlatformTabItem value="unity">

#### Connection and Events

- WalletConnect Modal is a singleton that can be accessed from any scene.
- By default Modal will initialize itself asynchronously on Awake. During initialization it will also try to connect
  to the last
  session.
- After initialization, Modal invokes `WalletConnectModal.Ready` static event.
- If `Ready` argument's `SessionResumed` is `true`, it means that Modal has successfully connected to the last
  session. In this case you don't need to open the modal. Otherwise, open the modal with `WalletConnectModal.Open()`
  static method.

```csharp
private void Start()
{
    WalletConnectModal.Ready += (sender, args) =>
    {
        if (args.SessionResumed)
        {
            // Session has been resumed, proceed to the game
        }
        else
        {
            // Session hasn't been resumed

            // Define required namespaces for new session
            var requiredNamespaces = new RequiredNamespaces
            {
                {
                    "eip155", new ProposedNamespace
                    {
                        Methods = new[]
                        {
                            "eth_sendTransaction",
                            "personal_sign",
                            "eth_signTypedData"
                        },
                        Chains = new[]
                        {
                            "eip155:1"
                        },
                        Events = new[]
                        {
                            "chainChanged",
                            "accountsChanged"
                        }
                    }
                }
            };

            var connectOptions = new ConnectOptions
            {
                RequiredNamespaces = requiredNamespaces
            };

            // Open the modal
            WalletConnectModal.Open(new WalletConnectModalOptions
            {
                ConnectOptions = connectOptions
            });
        }
    };
}
```

Subscribe to `ActiveSessionChanged` and `SessionDeleted` events. It's recommended to do it in `Ready` event handler.

```csharp
WalletConnectModal.Ready += (sender, args) =>
{
    // ....

    // Invoked after wallet connected
    WalletConnect.Instance.ActiveSessionChanged += (_, sessionStruct) =>
    {
        // Session connected/updated, proceed to the game if sessionStruct.topic is not null/empty
    };

    // Invoked after wallet disconnected
    WalletConnect.Instance.SessionDisconnected += (_, _) =>
    {
        // Session deleted, show sign in screen
    };
};
```

#### Disconnection

To disconnect from the current session, call `WalletConnectModal.Disconnect()` static method.

### Interaction with RPC

The WalletConnect Modal is responsible for facilitating communication between the game and the wallet.
Some methods do not require the user to interact with the wallet. For example, `eth_getBalance` is used to get the address balance,
and `eth_call` is used to read data from a smart contract without modifying its state, hence no signature is required.

To call these methods, you can use the [Nethereum.Web3](https://www.nuget.org/packages/nethereum.web3) package.

```csharp
private static async Task GetAccountBalance()
{
    var session = WalletConnect.Instance.ActiveSession;

    // Because one session can have multiple namespaces, we need to select one.
    // In most cases, especially in games, dapp will use only one namespace.
    var @namespace = session.Namespaces.First();
    var address = session.CurrentAddress(@namespace.Key).Address;

    var config = ProjectConfiguration.Load();

    // Using WalletConnect Blockchain API: https://docs.walletconnect.com/cloud/blockchain-api
    var url = $"https://rpc.walletconnect.com/v1?chainId={@namespace.Value.Chains[0]}&projectId={config.Id}";

    var web3 = new Nethereum.Web3.Web3(url);
    var balance = await web3.Eth.GetBalance.SendRequestAsync(address);
    Debug.Log($"Balance of {address} in Wei: {balance.Value}");

    var etherAmount = Nethereum.Web3.Web3.Convert.FromWei(balance.Value);
    Debug.Log($"Balance of {address} in Ether: {etherAmount}");
}
```

#### Interaction with Smart Contracts

To query smart contracts, you can use [Nethereum.Web3](https://www.nuget.org/packages/nethereum.web3) package
to make `eth_call` requests directly to the RPC endpoint.
However, to call methods that modify the state of the smart contract, you need user to sign the transaction in the wallet.

There are two ways to interact with smart contracts:

- **With Interceptor**: using Nethereum's `RequestInterceptor` (recommended)
- **Manual**: using Netherum's tools to encode data and make requests directly with WalletConnect

<Tabs>

<TabItem value="interceptor" label="Interceptor (recommended)">

    WalletConnect provides a Nethereum interceptor utility that will route requests that require user signature to the wallet.
    With this approach, you don't need to manually encode data and make requests. Use convenient Nethereum's methods to interact with smart contracts, and interceptor
    will automatically route requests to the wallet.

    [WalletConnectUnity Nethereum source code](https://github.com/WalletConnect/WalletConnectUnity/tree/main/Packages/con.walletconnect.nethereum)

#### Install interceptor

    ```bash
    openupm add com.walletconnect.nethereum
    ```

    #### Use interceptor

    This example shows how to call `transfer` method of ERC20 smart contract using interceptor.

    ```csharp
    // Nethereum's Web3 instance
    var web3 = new Web3();

    // Instance of WalletConnect singleton
    var walletConnect = WalletConnect.Instance;

    // Interceptor that will route requests requiring signing to the wallet connected with WalletConnect
    var walletConnectUnityInterceptor = new WalletConnectUnityInterceptor(walletConnect);

    // Assign the interceptor to the Web3 instance
    web3.Client.OverridingRequestInterceptor = walletConnectUnityInterceptor;

    const string contractAddress = "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984";
    const string recipientAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
    const BigInteger amount = 1;

    // Get ERC20 contract service
    var contractService = Web3Modal.Web3.Eth.ERC20.GetContractService(contractAddress);

    // Call transfer method of ERC20 contract
    await contractService.TransferRequestAsync(recipientAddress, amount);
    ```

    Nethereum allows to deploy and interact with custom smart contracts as well.
    Refer to the [Nethereum documentation](https://docs.nethereum.com/en/latest/nethereum-smartcontrats-gettingstarted/) for more information.

</TabItem>

<TabItem value="manual" label="Manual">

    The example below shows how to call `approve` method of WETH9 (Wrapped Ether) smart contract. It encodes data with Nethereum and makes request with WalletConnect.

    ```csharp
    public async Task ContractTransaction()
    {
        var session = WalletConnect.Instance.ActiveSession;

        // Because one session can have multiple namespaces, we need to select one.
        // In most cases, especially in games, dapp will use only one namespace.
        var @namespace = session.Namespaces.First();
        var myAddress = session.CurrentAddress(@namespace.Key).Address;

        // Define contract and function details
        var contractAddress = "0x4200000000000000000000000000000000000006";
        var toAddress = myAddress; // Use sender's address for the sake of example
        var amount = new BigInteger(12345);

        // Define the parameters for the approve function
        var parameters = new Parameter[] {
            new("address", "guy"),
            new("uint256", "wad")
        };

        var functionCallEncoder = new FunctionCallEncoder();
        var sha3Signature = new Sha3Keccack().CalculateHash("approve(address,uint256)");

        // Encode the parameters
        var encodedParameters = functionCallEncoder
            .EncodeParameters(parameters, toAddress, amount)
            .ToHex();

        // Combine signature and parameters
        var data = "0x" + sha3Signature[..8] + encodedParameters;

        // Create transaction
        var ethSendTransaction = new EthSendTransaction(new Transaction
        {
            From = myAddress,
            To = contractAddress,
            Value = "0",
            Data = data
        });

        try
        {
            var result = await WalletConnect.Instance.RequestAsync<EthSendTransaction, string>(ethSendTransaction);
            Debug.Log($"Transaction success! TxHash: {result}", this);
        }
        catch (Exception e)
        {
            Debug.LogError(e, this);
        }
    }

    public class Transaction
    {
        [JsonProperty("from")] public string From { get; set; }

        [JsonProperty("to")] public string To { get; set; }

        [JsonProperty("gas", NullValueHandling = NullValueHandling.Ignore)]
        public string Gas { get; set; }

        [JsonProperty("gasPrice", NullValueHandling = NullValueHandling.Ignore)]
        public string GasPrice { get; set; }

        [JsonProperty("value")] public string Value { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; } = "0x";
    }

    [RpcMethod("eth_sendTransaction"), RpcRequestOptions(Clock.ONE_MINUTE, 99997)]
    public class EthSendTransaction : List<Transaction>
    {
        public EthSendTransaction(params Transaction[] transactions) : base(transactions)
        {
        }

        [Preserve]
        public EthSendTransaction()
        {
        }
    }
    ```

    Please refer to [Nethereum](https://nethereum.com/) documentation for more details. Nethereum provides tools to simplify encoding and decoding.
    These tools hadn't been used in the example above to better illustrate the process.

</TabItem>

</Tabs>

#### Subscribe to session events

```csharp
var signClient = WalletConnect.Instance.SignClient;
signClient.SubscribeToSessionEvent("chainChanged", OnChainChanged);
```

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/advanced/faq.md">
# FAQs

## What chains does WalletConnect support?

WalletConnect operates as a chain-agnostic protocol, adhering to the [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md) standard. While the WalletConnect protocol supports various chains, you can refer to the [list](../cloud/chains/chain-list.mdx) for the known compatible blockchains. However, please note that our SDKs have certain limitations on the chains they support.

If you intend to extend support for non-EVM chains in your wallet or dapp, it is recommended to review the cross-chain primitives supported by the WalletConnect protocol through the Chain Agnostic Standards Alliance's [Namespaces](https://namespaces.chainagnostic.org/) project. Additionally, feel free to reach out to our community team for further guidance. In the event that the desired chain lacks documentation in the Namespaces project, you can collaborate with an expert in the respective chain's tooling and submit a [namespaces PR](https://github.com/ChainAgnostic/namespaces/?tab=readme-ov-file#namespaces).

## Will the relay server `bridge.walletconnect.org` still work in v2?

No, the bridge servers are v1 only.

## How can I reconnect to the same pairing if my browser was restarted?

The `signClient` will restore & reconnect its pairings automatically after the page is reloaded. All pairings are stored on the page's `localStorage`.

For more context, feel free to check our [web examples](https://github.com/WalletConnect/web-examples).

## The default relay endpoint is blocked. How can I get around this?

When initializing `signClient`, you can set `relayUrl` to `wss://relay.walletconnect.org`.

```js
const signClient = await SignClient.init({
  projectId: '<YOUR PROJECT ID>',
  relayUrl: 'wss://relay.walletconnect.org',
  metadata: {}
})
```

## How can we use a custom relay for our bridge without a WC URI parameter as the host?

You are more than welcome to utilize a custom URI parameter during testing. However, it is currently not recommended for use in a production environment.

## Why is self-hosting not an option at this time? Are there plans to make this possible in the future?

We understand the desire for developers to self-host their own relay. We share this vision, and have embarked on a decentralization roadmap in order to achieve this. By the end of this summer, we will launch a permissioned network and invite a select group of partners to participate in this crucial first phase. Our objective is to make self-hosting relay a reality with the creation of the decentralized WalletConnect Network, and we appreciate your patience as we progress in this enormous mission.
</file>

<file path="docs/advanced/glossary.md">
# Glossary

## Sequence

Sequences refers to a complete flow starting from a Proposal and reaching Settlement. A proposer will create a sequence proposal that will derive a Signal to share out-of-band with the responder in order to reach agreement regarding different permissions and conditions for the sequence. A Sequence establishes how the two clients will relay messages with each other, which keys they will use to encrypt and authenticate messages and additionally what are the permissions regarding the JSON-RPC requests that can be made, notifications that can be emitted and what state will be shared.

There are two types of sequences specified by the protocol called Pairing and Session.

## Pairing

Pairing is a specialized sequence which has fixed permissions to only allow a client to propose sessions through it using the method `wc_sessionPropose` which it will be used as a signal out-of-band for session proposals.

## Session

Session is a generalized sequence which has customizable permissions regarding JSON-RPC requests, notifications emitted and also what accounts are exposed based on the set of chains determined in the permissions.

## Signal

A signal is a payload that can be shared outside of the sequence (out-of-band) to communicate a proposal to another client. Each sequence has its own type of signal.

Pairing is a specialized sequence which has fixed permissions therefore the signal can be encoded as an URI using only the proposal topic, proposer's publicKey, relay protocol options and the controller flag for the proposer. This can be shared either through a qrcode or deep link between clients.

Session is a generalized sequence which has customized permissions therefore the signal is a proposal sent through a settled pairing already established between the two clients.

## Settlement

Settlement refers to the internal event which both clients will execute from a successful response of a sequence proposal.

In the case of a responder, the settlement happens before the response is published to the proposer.

In the case of a proposer, the settlement happens after receiving the response published by the responder.

Settlement will generate a shared key using the key pairs of the participants and it will determine the topic from hashing the shared key which is only known to both participants

## Controller

A client can be either a controller or non-controller. This means that all sequences responded and/or proposed by this client will be controlled by it.

A controller is not bounded by the permissions set by the sequence, meaning it can send any JSON-RPC request, emit any notification type and is the only participant that upgrade the permissions or update the state of the sequence.

The controller client will always be the "wallet" which is exposing blockchain accounts to a "dapp" and therefore is also in charge of signing.

Disconnecting is however not exclusive to the controller client and can be triggered by either participants.

## Expiry

Expiry refers to the timestamp when the sequence is deleted.

Whenever the responder settles the sequence it calculates the expiry by adding the TTL to the current timestamp. The proposer would then use the expiry calculated by the responder.

Expiry times are always represented in seconds.

## Time to Live (TTL)

Time to live (TTL) refers to the maximum duration for a sequence to live.

TTL plus the current timestamp is used to calculate the expiry timestamp.

TTL times are always represented in seconds.

## Shared Key

Shared key is the key derived using both participants key pairs using the elliptic curve Diffie-Hellman (ECDH) key agreement scheme.

The chosen elliptic curve was Curve25519 offering 128 bits of security (256 bits key size) which was specifically designed for ECDH and it's widely supported by many different platforms natively. The name of its DH function is X25519

## Authenticated Encryption

Authentication Encryption refers to a form of encryption which simultaneously assures the confidentiality and authenticity of data.

The chosen approach was to encrypt-then-mac which produces a MAC based on the resulting ciphertext. The encryption uses AES-256-CBC with a random Initialization Vector (IV) and authentication uses HMAC-SHA256. The encrypted payloads are serialized in the following order: iv, publicKey, mac and cipherText.

To derive the encryption and authentication keys it uses a SHA512 hash of the shared key using the first 32bytes for encryption and the last 32 bytes for authentication

## JSON-RPC

JSON-RPC is a stateless, light weight remote procedure call (RPC) protocol which uses JSON (RFC 4627) as data format. You can read more about JSON-RPC specification [here](https://www.jsonrpc.org/specification)

## Relay

Relay refers to the system, network and/or mechanism used to send and receives messages between the two clients.

## Publish-Subscribe pattern

Publish-Subscribe (also known as PubSub) is a messaging pattern where senders of messages (publishers) do not send messages directly to receivers but instead label messages with a topic that can be listened to by subscribers. Subscribers only receive messages matching the topics that have expressed interest on.

## Topics

Topics are 32 bytes hexadecimal strings which are used to identify messages sent between two clients regarding either proposed sequences or settled sequences. Proposed sequences use a randomly generated topic while Settled sequences use a SHA256 hash of the sharedKey.

## Namespaces

Namespaces are used to specify the chains, methods and events that are intended to be used in a particular session. They establish the minimal requirement for a wallet and a dapp to get paired. There are two types of namespaces,

### Proposal namespaces

A dapp sends a proposal namespace to the wallet for pairing. The proposal namespace contains the list of chains, methods and events that are required for the dapp. The wallet validates if the received proposal namespaces are valid and returns a session namespace as a response if it is valid. If the requested proposal namespaces are not valid, the session cannot be established and the wallet rejects it with an error code that tells the dapp if the proposal namespaces have invalid chains, methods, events or if it was rejected by the user

**Example :** If a dapp wants access to Ethereum Mainnet, Polygon and Cosmos Mainnet - the required chains, methods and events should be mentioned in the proposal namespaces request as follows :

```js
{
  "eip155": {
    "chains": ["eip155:137", "eip155:1"],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "chains": ["cosmos:cosmoshub-4"],
    "methods": ["cosmos_signDirect"],
    "events": ["someCosmosEvent"]
  }
}
```

### Session namespaces

The dapp validates if the received proposal namespaces comply with the session namespaces. If they comply, a session is established successfully and pairing is completed. If not, the session is not established and all the cached data related to the namespaces are deleted. The session namespace can also choose to provide access to more chains, methods or events that were not a part of the proposal namespaces.

**Example :** The following is an example for a session namespace which complies with the requested proposal namespace example,

```js
{
  "eip155": {
    "accounts": [
      "eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb",
      "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"
    ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "accounts": [
      "cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"
    ],
    "methods": ["cosmos_signDirect", "personal_sign"],
    "events": ["someCosmosEvent", "proofFinalized"]
  }
}
```

You can also see that `personal_sign` method and `proofFinalized` event are not requested by the proposal namespaces but is still granted by the session namespaces. Hence, session namespaces can grant additional access to more chains, methods and events which were not requested by the proposal namespaces.
</file>

<file path="docs/advanced/push-server.md">
# Push Server

The Push Server sends WalletConnect protocol activity using FCM or APNs to users. The Push Server can be used with our [WalletKit SDK](../walletkit/overview.mdx).

Several options exist for setting up the Push Server:

1. Using [WalletConnect Cloud](#setup-in-walletconnect-cloud) (recommended)
2. Self-host the [Push Server](https://github.com/WalletConnect/push-server)
3. Write your own implementation using the [spec](https://specs.walletconnect.com/2.0/specs/servers/push/spec)

It is recommended that you use WalletConnect Cloud for simplicity and ease of integration. Typically you only need to self-host if you have concerns about our hosted platform having access to your FCM or APNs server credentials, such as for regulatory reasons. If you want to self-host or implement against the spec, please reach out to devrel@walletconnect.com for assistance.

## Setup in WalletConnect Cloud

1. Create a Project in the Cloud App. Go to [WalletConnect Cloud](https://cloud.walletconnect.com/) and sign up for an account.

2. To get your project's Push URL, from the Cloud App, go into the settings tab and click on `Create Push URL`.

![create-push-url](/assets/create-push-url.png)

3. From the same settings tab, you will see the FCM and the APNS settings becomes available to setup. Add your [FCM](#Firebase Cloud Messaging API (FCM v1)) and/or [APNs](#apple-push-notifications-apns) details.

![fmc-and-apns-details-form](/assets/apns-fmc-details.png)

### Firebase Cloud Messaging API (FCM v1)

:::info
If you already have FCM Legacy enabled and then enable FCM v1, push notifications will automatically be sent with the newer FCM v1 API automatically. No migration of devices/apps is necessary.
:::

- In your [Firebase](https://console.firebase.google.com) project settings, under _Firebase Cloud Messaging API (V1)_, click the Manage Service Accounts link
  ![Manage service accounts link](/assets/push-fcmv1-manage-service-accounts.png)
- You may use the default `firebase-adminsdk` service account, but we recommend making a new, minimally privileged, service account. Eg a ready-made role from Firebase `Firebase Cloud Messaging API Admin` would only give access to messaging and notifications:
  - Click the _Create service account_ button
    ![Create service account button](/assets/push-fcmv1-create-sa-button.png)
  - Provide an arbitrary name and ID. E.g. `WalletConnect Cloud Push Server` and click _Create and Continue_
    ![Provide a name](/assets/push-fcmv1-create-sa.png)
  - Select the `Firebase Cloud Messaging API Admin` role and click _Continue_
    ![Select the `Firebase Cloud Messaging API Admin` role](/assets/push-fcmv1-create-sa-grants.png)
  - Click Done
- Next create keys for the service account by clicking on the `‚ãÆ` button next to the service account and selecting _Manage keys_  
  ![Manage keys](/assets/push-fcmv1-sa-manage-keys.png)
  - Click _Add key_ -> _Create new key_  
    ![Create new key](/assets/push-fcmv1-sa-new-key.png)
  - Select _JSON_ and click _Create_
  - A `.json` file containing the service account credentials will be automatically downloaded to your computer
- Upload the credentaials JSON file to your Cloud project's FCM V1 settings and click _Save_

You should now see a green checkbox indicating that FCM V1 has been enabled! Now any clients that register themselves on the Push Server will receive FCM push notifications for relay messages to that client.

### Cloud Messaging API (FCM Legacy)

:::caution
FCM Legacy is deprecated and [will be removed June 20, 2024](https://firebase.google.com/docs/cloud-messaging/migrate-v1). We strongly encourage you to setup FCM v1 (above) instead.

![FCM legacy deprecated](/assets/push-fcm-legacy-deprecated.png)

When FCM v1 is enabled in WalletConnect Cloud, it will replace the use of the legacy FCM API. No migration of devices/apps is necessary.
:::

Google's FCM allows you to use send notifications to both Android and Apple devices. At this time, we only support apps using the FCM client API.

- Enable Legacy Cloud Messaging API in the Firebase project settings
  ![legacy-fcm-cloud-messaging](/assets/legacy-fcm-cloud-messaging-api.png)
- [Set up Android](https://firebase.google.com/docs/cloud-messaging/android/client)
- [Set up Apple](https://firebase.google.com/docs/cloud-messaging/ios/client)

### Apple Push Notifications (APNs)

Apple recommends using a Token-Based Connection for APNS over a Certificate-Based connection. Please refer to their documentation for instructions on obtaining either.

- [Token-Based Connection](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/establishing_a_token-based_connection_to_apns)
- [Certificate-Based Connection](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/establishing_a_certificate-based_connection_to_apns)
</file>

<file path="docs/api/core/about.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

<!--TODO-->

## Next Steps

The next section will walk you through the process of setting up your project to use the library.
</file>

<file path="docs/api/core/pairing.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Pairing API

The Pairing API is a lightweight API for establishing an encrypted, protocol-agnostic communication layer between peers.
Its purpose is to provide a secure channel for proposing protocols or sending requests between dapp and wallet.

<CloudBanner />

## Installation

<PlatformTabs
	groupId="api"
	activeOptions={["web","ios","android","react-native","unity","csharp"]}
>
<PlatformTabItem value="web">

WalletConnect currently offers Sign and Auth SDKs.
To allow a reusable communication channel between peers,
the Pairing API exposes a standard interface and allows for sending and receiving multi-protocol requests over a single pairing.

Each SDK uses the same implementation of `core/pairing` (via `@walletconnect/core`) to manage pairings.
To run multiple SDKs side-by-side (e.g. Sign and Auth), please refer to the [Sharing a Core instance] guide.

</PlatformTabItem>
<PlatformTabItem value="ios">

#### Add SDK for your project.

You can add a WalletConnect Core SDKs to your project with Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package
5. Select WalletConnectPairing check mark

</PlatformTabItem>
<PlatformTabItem value="android">

Kotlin implementation of Android CoreClient for all WalletConnect SDKs. This SDK is developed in Kotlin and usable in both Java and Kotlin files.

![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-core)

#### Requirements

- Android min SDK 23
- Java 11

#### Installation

root/build.gradle.kts:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

app/build.gradle

```gradle
implementation("com.walletconnect:android-core:release_version")
```

#### Project set up

To use initialize RelayClient properly you will need a projectId. Go to https://cloud.walletconnect.com/app, register your project and get projectId.

#### CoreClient initialization

Before using any of the WalletConnect Kotlin SDKs, it is necessary to initialize the CoreClient. The initialization of CoreClient must always happen in the Android Application class. Provide the projectId generated in the WalletConnect Cloud, the WebSocket URL, choose the connection type, and pass the application class. You can also pass your own Relay instance using the `RelayConnectionInterface`.

```kotlin
val projectId = "" //Get Project ID at https://cloud.walletconnect.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val application = //Android Application level class
[Optional] val optionalRelay: RelayConnectionInterface? = /*implement interface*/

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = application, relay = optionalRelay)
```

#### Using your own Relay instance

The CoreClient offers the ability to use a custom Relay client. Just creating an instance of `RelayConnectionInterface` and passing it to `CoreClient.initialize`.

```kotlin
...
val optionalRelay: RelayConnectionInterface = /*implement interface*/

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = application, relay = optionalRelay)
```

</PlatformTabItem>
<PlatformTabItem value="react-native">

WalletConnect currently offers Sign and Auth SDKs.
To allow a reusable communication channel between peers,
the Pairing API exposes a standard interface and allows for sending and receiving multi-protocol requests over a single pairing.

Each SDK uses the same implementation of `core/pairing` (via `@walletconnect/core`) to manage pairings.
To run multiple SDKs side-by-side (e.g. Sign and Auth), please refer to the [Sharing a Core instance] guide.

</PlatformTabItem>
<PlatformTabItem value="csharp">

Install the `WalletConnect.Core` nuget package, which implements the Pairing API

```shell
dotnet add package WalletConnect.Core
```

Once the `WalletConnect.Core` library is installed, create a Metadata object. It will describe your application and define its appearance in a web browser. Then configure the Pair instance with a metadata object you have instantiated.

```csharp
var metadata = new Metadata()
{
    Name = "my-app",
    Description = "My app description",
    Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
    Url = "https://walletconnect.com",
}

var options = new CoreOptions()
{
    ProjectId = "...",
    Name = "my-app",
}

var core = new WalletConnectCore(options);
core.Pairing.Configure(metadata);
```

</PlatformTabItem>
<PlatformTabItem value="unity">

:::tip

Since `WalletConnectUnity` is a wrapper around `WalletConnectSharp`, usage of the pairing API is identical to `C#`. Please refer to C# documentation on how to use Pairing inside `WalletConnectUnity`.

:::

#### Package Installation

<Tabs>
<TabItem value="openupm-cli" label="OpenUPM CLI">

To install packages via OpenUPM, you need to have [Node.js](https://nodejs.org/en/) and [openupm-cli](https://openupm.com/docs/getting-started.html#installing-openupm-cli) installed. Once you have them installed, you can run the following commands:

```bash
openupm add com.walletconnect.core
```

</TabItem>
<TabItem value="pm-openupm" label="Package Manager with OpenUPM">

1. Open `Advanced Project Settings` from the gear ‚öô menu located at the top right of the Package Manager‚Äôs toolbar
2. Add a new scoped registry with the following details:
   - Name: `OpenUPM`
   - URL: `https://package.openupm.com`
   - Scope(s): `com.walletconnect`
3. Press plus ‚ûï and then `Save` buttons
4. In the Package Manager windows open the add ‚ûï menu from the toolbar
5. Select `Add package by name...`
6. Enter the package name:
   - `com.walletconnect.core`
7. Press `Add` button

</TabItem>
<TabItem value="pm-git-utl" label="Package Manager with Git URL">

1. Open the add ‚ûï menu in the Package Manager‚Äôs toolbar
2. Select `Add package from git URL...`
3. Enter the package URL:

**WalletConnectUnity Core**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core
```

4. Press `Add` button

It's possible to lock the version of the package by adding `#{version}` at the end of the git URL, where `#{version}` is the git tag of the version you want to use.
For example, to install version `1.0.1` of WalletConnectUnity Modal, use the following URL:

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core#core/1.0.1
```

</TabItem>
</Tabs>

#### WebGL

Due to WebGL's single-threaded nature, certain asynchronous operations like `Task.Run`, `Task.ContinueWith`, `Task.Delay`, and `ConfigureAwait(false)` are not natively supported.

To enable these operations in WebGL builds, an additional third-party package, [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher), is required. This package modifies the Unity WebGL build to delegate work to the `SynchronizationContext`, allowing these operations to be executed on the same thread without blocking the main application. Please note that all tasks are still executed on a single thread, and any blocking calls will freeze the entire application.

The [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher) package can be added via git URL:

```
https://github.com/VolodymyrBS/WebGLThreadingPatcher.git
```

#### Initialization

1. Fill in the Project ID and Metadata fields in the `Assets/WalletConnectUnity/Resources/WalletConnectProjectConfig` asset.
   - If you don‚Äôt have a Project ID, you can create one at [WalletConnect Cloud](https://cloud.walletconnect.com).
   - The `Redirect` fields are optional. They are used to redirect the user back to your app after they approve or reject the session.
2. Initialize `WalletConnect` and get reference to the instance of `Core`:

```csharp
// Initialize singleton
await WalletConnect.Instance.InitializeAsync();

// Or handle instancing manually
var walletConnectUnity = new WalletConnect();
await walletConnectUnity.InitializeAsync();

var core = WalletConnect.Instance.SignClient.Core;
```

</PlatformTabItem>
</PlatformTabs>

## Usage

<PlatformTabs
	groupId="api"
	activeOptions={["web","ios","android","react-native","csharp"]}
>
<PlatformTabItem value="web">

The methods listed below are limited to only the public methods of the Pairing API that we recommend you interact with directly.
For an exhaustive list, please refer to the spec and/or implementation linked under [Useful Links](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-methods) above.

The keyword `sdkClient` is used here as a placeholder for any WalletConnect SDK that implements the Pairing API (e.g. `signClient`, `authClient`, etc).

```ts
 // Creates a new (inactive) pairing. Returns the URI for a peer to consume via `pair`, as well as the pairing topic.
const {topic, uri} = await sdkClient.core.pairing.create()

// Pair with a peer's proposed pairing, extracted from the provided `uri` parameter.
await sdkClient.core.pairing.pair({ uri: "wc:1b3eda3f4..." })

// Activate a previously created pairing (e.g. after the peer has paired), by providing the pairing topic.
await sdkClient.core.pairing.activate({ topic: "1b3eda3f4..." })

// Updates the expiry of an existing pairing, by providing the pairing topic and an `expiry` in seconds (e.g. `60` for one minute from now)
await sdkClient.core.pairing.updateExpiry({ topic: "1b3eda3f4...", expiry: 60 })

// Updates a pairing's metadata, by providing the pairing topic and the desired metadata.
await sdkClient.core.pairing.updateMetadata({ topic: "1b3eda3f4...", metadata: { name: "MyDapp", ... } })

// Returns an array of all existing pairings.
const pairings = sdkClient.core.pairing.getPairings()

// Pings a pairing's peer, by providing the pairing topic.
await sdkClient.core.pairing.ping({ topic: "1b3eda3f4..." })

// Disconnects/Removes a pairing, by providing the pairing topic.
await sdkClient.core.pairing.disconnect({ topic: "1b3eda3f4..." })
```

#### Listeners for pairing-related events

The Pairing API currently emits the following events:

- `pairing_ping`
- `pairing_delete`
- `pairing_expire`

Any of these events can be listened for via the standard Node [`EventEmitter` interface](https://nodejs.org/api/events.html#class-eventemitter):

```ts
sdkClient.core.pairing.events.on('pairing_delete', ({ id, topic }) => {
  // clean up after the pairing for `topic` was deleted.
})
```

</PlatformTabItem>
<PlatformTabItem value="ios">

Create an AppMetadata object. It will describe your application and define its appearance in a web browser.

Starting from WalletConnect SDK version 1.9.5, the `redirect` field in the `AppMetadata` object is mandatory. Ensure that the provided value matches your app's URL scheme to prevent redirection-related issues.

Then configure the Pair instance with a metadata object you have instantiated.

```swift
let metadata = AppMetadata(name: <String>,
                           description: <String>,
                           url: <String>,
                           icons: <[String]>,
                           redirect: AppMetadata.Redirect(native: "example://", universal: nil))

Pair.configure(metadata: metadata)
```

#### Pairing Wallet Usage

In pair wallet with dapp, the user needs to scan a QR code or open a deep link generated by dapp, then instantiate `WalletConnectURI` from the scanned QR code string and call the `pair()` function as follows.

```swift
let uri WalletConnectURI(string: <String>)
try! await Pair.instance.pair(uri: uri)
```

Now wallet and a dapp have a secure communication channel that will be used by top level APIs.

#### Pairing Dapp Usage

In order to pair dapp and a wallet, dapp needs to generate and share a uri with wallet.
To generate a uri call `create()` function on Pair instance as follows.

```swift
let uri = try await Pair.instance.create()
```

Now you can share the uri with the wallet.

</PlatformTabItem>
<PlatformTabItem value="android">

#### **Create Pairing**

```kotlin
val pairing: Pairing? = CoreClient.Pairing.create() { error -> }
```

When first establishing a pairing with a Peer, call `CoreClient.Pairing.create`. This will try and generate a new pairing with a URI parameter that can be used to establish a connection with the other Peer as well as other meta data related to the pairing.

#

#### **Pair Clients**

```kotlin
val pairingParams = Core.Params.Pair(pairingUri)
CoreClient.Pairing.pair(pairingParams) { error -> }
```

To pair the wallet with the Dapp, call the CoreClient.Pairing's pair function which needs a `Core.Params.Pair` parameter. `Core.Params.Pair` is where the WC Uri will be passed.

#

#### **Get List of Active Pairings**

```kotlin
val listOfActivePairings: List<Core.Model.Pairing> = CoreClient.Pairing.getPairings()
```

To get a list of the most current active pairings, call `CoreClient.Pairing.getPairings()` which will return a list of type `Core.Model.Pairing`.

#

#### **Disconnect a Pairing**

```kotlin
CoreClient.Pairing.disconnect(topic = /*Pairing topic*/") { error -> }
```

To disconnect from a pairing, just pass the topic of the pairing to disconnect from (use `getPairings()` to get a list of all active pairings and their topics).

</PlatformTabItem>
<PlatformTabItem value="react-native">

The methods listed below are limited to only the public methods of the Pairing API that we recommend you interact with directly.
For an exhaustive list, please refer to the spec and/or implementation linked under [Useful Links](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-methods) above.

The keyword `sdkClient` is used here as a placeholder for any WalletConnect SDK that implements the Pairing API (e.g. `signClient`, `authClient`, etc).

```ts
 // Creates a new (inactive) pairing. Returns the URI for a peer to consume via `pair`, as well as the pairing topic.
const {topic, uri} = await sdkClient.core.pairing.create()

// Pair with a peer's proposed pairing, extracted from the provided `uri` parameter.
await sdkClient.core.pairing.pair({ uri: "wc:1b3eda3f4..." })

// Activate a previously created pairing (e.g. after the peer has paired), by providing the pairing topic.
await sdkClient.core.pairing.activate({ topic: "1b3eda3f4..." })

// Updates the expiry of an existing pairing, by providing the pairing topic and an `expiry` in seconds (e.g. `60` for one minute from now)
await sdkClient.core.pairing.updateExpiry({ topic: "1b3eda3f4...", expiry: 60 })

// Updates a pairing's metadata, by providing the pairing topic and the desired metadata.
await sdkClient.core.pairing.updateMetadata({ topic: "1b3eda3f4...", metadata: { name: "MyDapp", ... } })

// Returns an array of all existing pairings.
const pairings = sdkClient.core.pairing.getPairings()

// Pings a pairing's peer, by providing the pairing topic.
await sdkClient.core.pairing.ping({ topic: "1b3eda3f4..." })

// Disconnects/Removes a pairing, by providing the pairing topic.
await sdkClient.core.pairing.disconnect({ topic: "1b3eda3f4..." })
```

#### Listeners for pairing-related events

The Pairing API currently emits the following events:

- `pairing_ping`
- `pairing_delete`
- `pairing_expire`

Any of these events can be listened for via the standard Node [`EventEmitter` interface](https://nodejs.org/api/events.html#class-eventemitter):

```ts
sdkClient.core.pairing.events.on('pairing_delete', ({ id, topic }) => {
  // clean up after the pairing for `topic` was deleted.
})
```

</PlatformTabItem>
<PlatformTabItem value="csharp">

#### Pairing Wallet Usage

When paring a wallet with a dapp, the user needs to scan a QR code or open a deep link generated by the dapp. Grab the string¬†from the scanned QR code string or from the deep link and call the¬†`Pair()`¬†function as follows.

```csharp
var uri = "...";
PairingStruct pairingData = await core.Pairing.Pair(uri);
```

Now the wallet and a dapp have a secure communication channel that will be used by top level APIs.

#### Pairing Dapp Usage

In order to pair dapp and a wallet, dapp needs to generate and share a uri with wallet. To generate a uri call¬†`create()`¬†function on Pair instance as follows.

```csharp

var pairData = await core.Pairing.Create();
string topic = pairData.Topic;
string uri = pairData.Uri;
```

Now you can share the uri with the wallet either through a QR Code or by using a deep link.

#### Message Sending / Handling

Once a wallet and dapp has been paired, they can send messages securely to the pairing topic.

Requests can be received from the dapp by handling the message callback in the `MessageHandler` module.

```csharp
core.MessageHandler.MessageEventHandler<MyRequest, MyResponse>()
    .FilterRequests(r => r.Topic == pairingData.Topic)
    .OnRequest +=
		async delegate(RequestEventArgs<MyRequest, MyResponse> eventArgs)
		{
		    Console.WriteLine(eventArgs.Request);
		    eventArgs.Response = new MyResponse()
		    {
		        // ...
		    };
		};
```

A response can be sent for any request by setting the `Response` field in the `eventArgs` parameter.

Receiving responses is handled the same way, but instead of the `OnRequest` event you would use the `OnResponse` event.

Request, Responses and Errors can be sent using the `SendRequest` , `SendResult` and `SendError` functions in the `MessageHandler` module.

```csharp
long id = await core.MessageHandler.SendRequest<MyRequest, MyResponse>(pairingTopic, data);
```

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/api/core/relay.mdx">
# Relay Client

import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

Relay client provides transport layer for Sign, Auth and Chat SDKs.
You can configure it once and every SDK will transport protocol messages via same instance of a relay client with only one opened websocket connection.
The Relay API can be accessed through the Core Client

<PlatformTabs
	groupId="w3w"
	activeOptions={["ios","android"]}
>
<PlatformTabItem value="ios">

Before using Sign or Auth SDK, it is necessary to configure a shared Networking Client instance. Set a project ID generated when starting a project on WalletConnect Cloud and SocketFactory instance.

WalletConnect Swift SDK does not depend on any websocket library. SocketFactory parameter allows you to pass your own implementation of websocket connection.

Here's an example of WebSocketFactory implementation using Starscream v3

```swift
import Starscream

extension WebSocket: WebSocketConnecting { }

struct SocketFactory: WebSocketFactory {
    func create(with url: URL) -> WebSocketConnecting {
        return WebSocket(url: url)
    }
}
```

Please note that if you have made changes to the list of **Allowed Domains** in the **WalletConnect Cloud Dashboard**, then you may encounter an error with the connection if you use **Starscream** or any other socket client. For example, the native implementation of **Starscream** will use the `relay.walletconnect.com` as an `Origin` parameter if not provided, which will be missing from the list of **Allowed Domains**. The solution to this could be the inclusion of the `relay.walletconnect.com` in the **Allowed Domains**, corresponding changes in the socket client implementation, or following changes in the `WebSocketFactory`.

Create and register App Group Identifier in [Apple Developer Center](https://developer.apple.com/account/resources/identifiers/list/applicationGroup) if needed and provide it during Networking client configuration.

```swift
import Starscream

extension WebSocket: WebSocketConnecting { }

struct DefaultSocketFactory: WebSocketFactory {
    func create(with url: URL) -> WebSocketConnecting {
        var urlRequest = URLRequest(url: url)
        urlRequest.addValue("allowed.domain.com", forHTTPHeaderField: "Origin")
        return WebSocket(request: urlRequest)
    }
}
```

#### Networking client configuration

```swift
Networking.configure(groupIdentifier: <String>, projectId: <String>, socketFactory: SocketFactory())
```

`groupIdentifier` - App group identifier, created on [Apple Developer Center](https://developer.apple.com/account/resources/identifiers/list/applicationGrou). Enables to share keychain items between the Notify SDK and a UNNotificationServiceExtension to receive and decrypt push notifications.

#### Web Socket Connection

By default web socket connection is handled internally by the SDK. That means that Web socket will be safely disconnected when apps go to background and it will connect back when app reaches foreground. But if it is not expected for your app and you want to handle socket connection manually you can do it as follows:

1. set socketConnectionType for manual

```swift
Networking.configure(projectId: <String>, socketFactory: SocketFactory(), socketConnectionType: .manual)
```

2. control socket connection:

```swift
try Networking.instance.connect()
```

```swift
try Networking.instance.disconnect()
```

</PlatformTabItem>
<PlatformTabItem value="android">

#### Web Socket connection control

There are two connection types, Automatic and Manual.

Automatic connection type enables SDK to control web socket connection internally. Meaning, web socket connection is closed when app goes to the background and is opened when app goes to the foreground.

Manual connection type enables developers to control web socket connection.

```kotlin
CoreClient.initialize(projectId = projectId, connectionType = ConnectionType.MANUAL, application = application)

CoreClient.Relay.connect() { error -> /*Error when wrong connection type is in use*/}

CoreClient.Relay.disconnect() { error -> /*Error when wrong connection type is in use*/}
```

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/api/core/shared-core.md">
# Shared Core Instance

:::note
The following content are only available for JavaScript.
:::

WalletConnect's SDKs are designed to share common logic and resources via the `@walletconnect/core` package.

**If you intend to leverage multiple SDKs together (e.g. Sign + Auth), it is highly recommended to instantiate
a single `Core` instance and pass it to the relevant SDKs.** This avoids each SDK creating its own `Core` instance,
and thus duplicating computation, memory allocation, event listeners etc.

In the following example, we first instantiate a `Core` instance, and then proceed to instantiate both the Sign
and Auth SDK with this shared `Core`:

```ts
import { Core } from '@walletconnect/core'
import SignClient from '@walletconnect/sign-client'
import { AuthClient } from '@walletconnect/auth-client'

// First instantiate a separate `Core` instance.
const core = new Core({
  projectId: '<YOUR_PROJECT_ID>'
})

const metadata = {
  name: 'Example Dapp',
  description: 'Example Dapp',
  url: '#',
  icons: ['https://walletconnect.com/walletconnect-logo.png']
}

// Pass `core` to the SignClient on init.
const signClient = await SignClient.init({ core, metadata })

// Pass `core` to the AuthClient on init.
const authClient = await AuthClient.init({ core, metadata })
```
</file>

<file path="docs/api/notify/about.mdx">
# Introduction

WalletConnect Notify is a push notification protocol that enables apps to notify users of both off-chain and on-chain events.
The Notify API allows wallet users to register subscriptions for different on-chain or off-chain events that are relevant to the user.
The notifications are sent to the respective wallets.

To integrate on the Dapp Side, check [here.](../../appkit/features/notifications.mdx)

To integrate on the Wallet Side, check [here.](../../walletkit/features/notifications.mdx)
</file>

<file path="docs/api/notify/usage.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Wallet Usage

<CloudBanner />

## Implementation

<PlatformTabs
	groupId="api"
	activeOptions={["web","ios","android", "react-native"]}
>
<PlatformTabItem value="web">

Install the WalletConnect client package.

```bash npm2yarn
npm install @walletconnect/notify-client
```

**If you are using the SDK on a server (such as Node.js), you will need to install an additional package:**

```bash npm2yarn
npm install lokijs --save
```

The above step is not required if you are using the SDK on the browser-side.

## Initialize the SDK clients

```javascript
import { NotifyClient } from '@walletconnect/notify-client'

const notifyClient = await NotifyClient.init({
  projectId: '<YOUR PROJECT ID>'
})
```

## Add listeners for relevant events

```javascript
// Handle response to a `notifyClient.subscribe(...)` call
notifyClient.on('notify_subscription', async ({ params }) => {
  const { error } = params

  if (error) {
    // Setting up the subscription failed.
    // Inform the user of the error and/or clean up app state.
    console.error('Setting up subscription failed: ', error)
  } else {
    // New subscription was successfully created.
    // Inform the user and/or update app state to reflect the new subscription.
    console.log(`Subscribed successfully.`)
  }
})

// Handle an incoming notification
notifyClient.on('notify_message', ({ params }) => {
  const { message } = params
  // e.g. build a notification using the metadata from `message` and show to the user.
})

// Handle response to a `notifyClient.update(...)` call
notifyClient.on('notify_update', ({ params }) => {
  const { error } = params

  if (error) {
    // Updating the subscription's scope failed.
    // Inform the user of the error and/or clean up app state.
    console.error('Setting up subscription failed: ', error)
  } else {
    // Subscription's scope was updated successfully.
    // Inform the user and/or update app state to reflect the updated subscription.
    console.log(`Successfully updated subscription scope.`)
  }
})

// Handle a change in the existing subscriptions (e.g after a subscribe or update)
notifyClient.on('notify_subscriptions_changed', ({ params }) => {
  const { subscriptions } = params
  // `subscriptions` will contain any *changed* subscriptions since the last time this event was emitted.
  // To get a full list of subscriptions for a given account you can use `notifyClient.getActiveSubscriptions({ account: 'eip155:1:0x63Be...' })`
})
```

## Register an identity key for cross-device account syncing

:::note
This is a one-time action per account. It does not need to be repeated after initial registration of the new account.
:::

To register an identity key, you must provide a callback to the `onSign: (message: string) => string` parameter of the `register` method.
In order to authorize the Notify subscription, the SDK will trigger this callback with a message to sign, expecting the signature for that message to be returned.

Some suggested ways to implement the `onSign` callback are via:

- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)
- The [`signMessage` method](https://wagmi.sh/core/actions/signMessage) in `@wagmi/core`

### Registering as a dapp

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`
const domain =  'app.mydomain.com', // pass the domain (i.e. the hostname) where your dapp is hosted.
const allApps =  false // The user will be prompted to authorize this dapp to send and receive messages on their behalf for only this specific domain using their WalletConnect identity.


// No need to register and sign message if already registered.
if (notifyClient.isRegistered({ account, domain, allApps })) return;

const {registerParams, message}  = notifyClient.prepareRegistration({
  account,
  domain,
  allApps
});

const signature = await ethersWallet.signMessage(message);

await notifyClient.register({
  registerParams,
  signature,
})
```

### Registering as a wallet

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`
const domain =  'app.mydomain.com', // pass the domain (i.e. the hostname) where your dapp is hosted.
const allApps =  true // The user will be prompted to authorize this wallet to send and receive messages on their behalf for ALL domains using their WalletConnect identity.

// No need to register and sign message if already registered.
if (notifyClient.isRegistered({ account, domain, allApps })) return;

const {registerParams, message}  = notifyClient.prepareRegistration({
  account,
  domain,
  allApps
});

const signature = await ethersWallet.signMessage(message);

await notifyClient.register({
  registerParams,
  signature,
})

```

### Unregistering

Any identity registered can be unregistered via the `unregister` method.

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`

await notifyClient.unregister({
  account
})
```

## Managing Subscriptions

#### Creating a new subscription

:::info
To identify dapps that can be subscribed to via Notify, we can query the following Explorer API endpoint:

https://explorer-api.walletconnect.com/v3/dapps?projectId=YOUR_PROJECT_ID&is_notify_enabled=true
:::

```javascript
// Get the domain of the target dapp from the Explorer API response
const appDomain = new URL(fetchedExplorerDapp.platform_browser).hostname

// Subscribe to `fetchedExplorerDapp` by passing the account to be subscribed and the domain of the target dapp.
await notifyClient.subscribe({
  account,
  appDomain
})

// -> Success/Failure will be received via the `notify_update` event registered previously.
// -> New subscription will be emitted via the `notify_subscriptions_changed` watcher event.
```

#### Updating notification types on an existing subscription

```javascript
// `topic` - subscription topic of the subscription that should be updated.
// `scope` - an array of notification types that should be enabled going forward. The current scopes can be found under `subscription.scope`.
await notifyClient.update({
  topic,
  scope: ['alerts']
})
// -> Success/Failure will be received via the `notify_update` event registered previously.
// -> Updated subscription will be emitted via the `notify_subscriptions_changed` watcher event.

// get notification types by accessing `scope` member of a dapp's subscription
const notificationTypes = notifyClient
  .getActiveSubscriptions({ account })
  .filter(subscription => subscription.topic === topic).scope
```

#### Removing an existing subscription

```javascript
// `topic` - subscription topic of the subscription that should be deleted.
await notifyClient.deleteSubscription({ topic })
```

#### Retrieving all currently active subscriptions

```javascript
// Will return all active subscriptions for the provided account, keyed by subscription topic.
const accountSubscriptions = notifyClient.getActiveSubscriptions({
  account: `eip155:1:0x63Be...`
})
```

#### Retrieving past messages for a given subscription

```javascript
// Will return all past Notify messages for the provided subscription topic, keyed by messageId.
const messageHistory = notifyClient.getNotificationHistory({
  topic,
  limit: 10,
  startingAfter: 'notification-id',
  unreadFirst: true
})
```

#### Marking notification as read

```javascript
// Will mark the 2 specific notifications as read
const messageHistory = notifyClient.markNotificationsAsRead({
  topic,
  notificationIds: ['notification-1', 'notification-2']
})
```

</PlatformTabItem>
<PlatformTabItem value="ios">

#### Add SDK for Your Project.

You can add a WalletConnect SDK to your project with the Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package
5. Select WalletConnectNotify check mark

#### Initialization

Make sure Networking and Pairing are properly configured.

- [Networking](../core/relay.mdx)

#### Configure your project to enable Push Notifications

[Configure Project](https://docs.walletconnect.com/advanced/echo-server)

#### Configure a Client

Configure the `Notify` instance with:

```swift
try Notify.configure(environment: APNSEnvironment, crypto: CryptoProvider)
```

environment - Use `debug` environment for debug builds and `release` for release and TestFlight builds
crypto - CruptoProvider is a protocol, you are required to provide an implementation of two methods recoverPubKey and keccak256.

#### Register for Push Notifications

In order to enable Push Notifications for your app you need to follow standard procedure:

[Enable Push Notifications Capability](https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns#2980170)

Ask for user permissions:

call registerForPushNotifications() early in your app's lifecycle to initiate the registration process with Apple Push Notification service:

```swift
    func registerForPushNotifications() {
        UNUserNotificationCenter.current()
            .requestAuthorization(
                options: [.alert, .sound, .badge]
            ) { granted, error in
                guard granted else { return }
                DispatchQueue.main.async {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
    }
```

Receive token from Apple Push Notification Services and register it at the Push Server:

```swift
    func application(
      _ application: UIApplication,
      didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
    ) {
        Task(priority: .high) {
            try await Notify.instance.register(deviceToken: deviceToken)
        }
    }
```

#

# Subscribe Events

#### Subscribe new subscription

Emits on new subscription created.

```swift
public var newSubscriptionPublisher: AnyPublisher<NotifySubscription, Never> {
```

#### Subscribe Notify Message

Emits new notify message from a dapp.

```swift
public var notifyMessagePublisher: AnyPublisher<PushMessage, Never>
```

#### Subscribe Subscription Deletion

Emits a topic of a deleted subscription.

```swift
public var deleteSubscriptionPublisher: AnyPublisher<String, Never>
```

#### Subscribe Subscription Update

Emits a result of a subscription update, containing updated subscription if successful.

```swift
public var updateSubscriptionPublisher: AnyPublisher<Result<PushSubscription, Error>, Never> {
```

#### Subscribe Active Subscriptions

Emits a list of active subscriptions.

```swift
public var subscriptionsPublisher: AnyPublisher<[PushSubscription], Never>
```

#### Register an identity key and enable cross-device account syncing

:::note
This is a one-time action that does not need to be repeated after initial registration of the new account.
:::

To register an identity key, you must provide a callback to the ` onSign: @escaping SigningCallback` parameter of the `register` method.
In order to register identity keys and enable cross device sync, the SDK will trigger this callback with a messages to sign, expecting the signature for that message to be returned.

```swift

Notify.instance.register(account: account, onSign: onSign)

func onSign(message: String) -> SigningResult {

    // Provide your own sing function implementation that returns CacaoSignature
    // For more detailed example see our sample WalletApp
    let signature = try! signer.sign(message: message)
    return .signed(signature)
}
```

#### Create Notify Subscription

To enable seamless communication between a Dapp and a wallet, the wallet must first establish a Notify Subscription. This crucial step allows the Dapp and its associated services to publish notify messages directly to the wallet. Upon granting permission for the wallet's iOS application to display Push Notifications, users will experience real-time updates in the form of push notifications on their devices. For an enhanced user experience, consider subscribing to the `notifyMessagePublisher` channel. This option ensures that notify messages are delivered promptly when the app is active and a web socket connection is established, keeping users informed and engaged.

To subscribe to dapp's notify messages first fetch publicly discoverable dapps with WalletConnet explorer:

https://explorer-api.walletconnect.com/v3/dapps?projectId={your_project_id}&is_notify_enabled=true

and request a subscription directly from the wallet:

```swift
public func subscribe(metadata: AppMetadata, account: Account, onSign: @escaping SigningCallback) async throws {
```

`metadata` - metadata object of publicly discoverable dapp fetched from WalletConnect explorer

`account` - an account you want to associate a sebscription with

`onSign` - callback that requires a signature from a user

#### Get Active Subscriptions

```swift
Notify.instance.getActiveSubscriptions()
```

#### Delete Subscription

To delete a subscription.

```swift
try await Notify.instance.deleteSubscription(topic: String)
```

#### Get Notify Messages

To get messages by topic call:

```swift
Notify.instance.getMessageHistory(topic: subscription.topic)
```

#### Decrypt Push Notifications

All push notifications that are sent via APNs are encrypted and have following payload:

```
{
  "aps":{
    "content-available":1,
    "mutable-content":1
  },
    "ciphertext": String, // encrypted payload
    "topic": String,  //  subscription topic
}
```

In order to decrypt a PN you need to instantiate [UNNotificationServiceExtension](https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension).
Learn how to [modify the content in newly delivered notifications](https://developer.apple.com/documentation/usernotifications/modifying_content_in_newly_delivered_notifications).
Create a [keychain group](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps) that is shared between your wallet application and the notification service. It must be called `group.com.walletconnect.sdk`.
Import WalletConnectNotify inside your notification service extension file, initialize `NotifyDecryptionService()` and decrypt the message:

```swift
    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
        if let bestAttemptContent = bestAttemptContent {
            let topic = bestAttemptContent.userInfo["topic"] as! String
            let ciphertext = bestAttemptContent.userInfo["blob"] as! String
            do {
                let service = NotifyDecryptionService()
                let pushMessage = try service.decryptMessage(topic: topic, ciphertext: ciphertext)
                bestAttemptContent.title = pushMessage.title
                bestAttemptContent.body = pushMessage.body
                contentHandler(bestAttemptContent)
                return
            }
        ...
    }
```

#### Where to Go from Here

- Try our [Wallet App](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example/WalletApp) and to test notifications.
- Build API documentation in XCode: go to Product -> Build Documentation

</PlatformTabItem>
<PlatformTabItem value="android">

Kotlin implementation of WalletConnect Notify protocol for Android applications.

#### Prerequisite

**Android BOM** ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-bom)

#### Requirements

- Android min SDK 23
- Java 11

#### Implementation

root/build.gradle.kts:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

app/build.gradle.kts

```gradle
implementation(platform("com.walletconnect:android-bom::release_version"))
implementation("com.walletconnect:android-core")
implementation("com.walletconnect:notify")
```

#### Implementation

Once you've finished the previous step, you're ready to start implementing the Notify API.

#### Initialization

The Notify client is responsible for creating and maintaining subscriptions. To initialize the Notify client, create a `Notify.Params.Init` object in the Android Application class with the `CoreClient`. The `Notify.Params.Init` object will then be passed to the `NotifyClient` initialize function.

`NotifyClient` should be initialized in the Application class.

```kotlin
val projectId = "" // Get Project ID at https://cloud.walletconnect.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val appMetaData = Core.Model.AppMetaData(
    name = "Wallet Name",
    description = "Wallet Description",
    url = "Wallet URL",
    icons = /*list of icon url strings*/,
    redirect = "kotlin-wallet-wc:/request" // Custom Redirect URI
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

val init = Notify.Params.Init(CoreClient)

NotifyClient.initialize(init) { error ->
    // Error will be thrown if there's an issue during initialization
}
```

#### Register for Push Notifications

The `NotifyMessageService` is a wrapper around the `FirebaseMessagingService`. This wrapper class needs to be implemented for the Notify SDK to be able to decrypt and notify wallets of a push notification sent from the Dapp in the background.
This service also needs to be registered in the AndroidManifest.xml file similar to the example in the [FCM documentation](https://firebase.google.com/docs/cloud-messaging/android/client#manifest).

```kotlin
class CustomFirebaseService: NotifyMessageService() {

    override fun newToken(token: String) {
        // Triggered when Firebase Cloud Messaging creates a new token and that token is registered with the Echo server
    }

    override fun registeringFailed(token: String, throwable: Throwable) {
        // Triggered when Firebase Cloud Messaging if there is an error with registering with the Echo server with a new token
    }

    override fun onMessage(message: Notify.Model.Message, originalMessage: RemoteMessage) {
        // Triggered when a message is sent from the Echo server through Firebase Cloud Messaging and the message contains `Notify.Model.Message`. The original FCM RemoteMessage is also returned
    }

    override fun onDefaultBehavior(message: RemoteMessage) {
        // Triggered when a message is sent from the Echo server through Firebase Cloud Messaging and the message does not contain `Notify.Model.Message`. The original FCM RemoteMessage returned instead
    }

    override fun onError(throwable: Throwable, defaultMessage: RemoteMessage) {
        // Triggered when there is an error that occurs when a message is received from the Echo server
    }
}
```

```xml
<application...>
    <service android:name=".CustomFirebaseService">
        <intent-filter>
            <action android:name="com.google.firebase.MESSAGING_EVENT" />
        </intent-filter>
    </service>
</application>
```

#### Register for Subscriptions

`NotifyClient` needs a `NotifyClient.Delegate` passed to it for it to be able to expose asynchronous updates sent from the dapp.

```kotlin
val walletDelegate = object : NotifyClient.Delegate {

    override fun onNotifySubscription(notifySubscribe: Notify.Event.Subscription) {
        // Triggered when a wallet initiated subscription has been created
    }

    override fun onNotifyMessage(notifyMessage: Notify.Event.Message) {
        // Triggered when a message has been sent by the Dapp. The message contains the title, body, icon, and url
    }

    override fun onNotifyDelete(notifyDelete: Notify.Event.Delete) {
        // Triggered when the Dapp deletes the subscription. The notifyDelete contains the topic that was deleted
    }

    override fun onNotifyUpdate(notifyUpdate: Notify.Event.Update) {
        // Triggered after updating a subscription was successful. The notifyUpdate will either contain the updated subscription details or an error
    }

    override fun onError(error: Notify.Model.Error) {
        // Triggered when there's an error inside the SDK
    }
}

NotifyClient.setDelegate(walletDelegate)
```

#### Register blockchain account

In order to use Notify SDK account must register identity in [Keyserver](https://specs.walletconnect.com/2.0/specs/servers/keys/). To verify ownership over blockchain account when registering identities in [Keyserver](https://specs.walletconnect.com/2.0/specs/servers/keys/) user's must sign message provided on `onSign(message: String)` callback. Currently only [`EIP191`](https://eips.ethereum.org/EIPS/eip-191) signatures are supported in [Keyserver](https://specs.walletconnect.com/2.0/specs/servers/keys/)

##### NotifyClient.register

```kotlin
val params = Notify.Params.Registration(
    account = /*[CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md) compatible accountId*/,
    onSign = {
        // Message to be signed. When user decides to sign message use CacaoSigner to sign message.
        // CacaoSigner is a util for easy message signing.
        return CacaoSigner.sign(message, /*privateKey*/, SignatureType.EIP191)
        // When users decides to not sign message return null
        return null
    }
)

NotifyClient.register(
      params,
      onSuccess = {
          // callback for when the subscription request was successfully sent
      },
      onError = { error: Notify.Model.Error ->
          // callback for when the subscription request has failed
      }
  )
```

#### Unregister blockchain account

To stop receiving notifications for specific blockchain account call `NotifyClient.unregister`. This will delete all local data of subscriptions and messages associated with the account, locally remove and unregister Identity from [Keyserver](https://specs.walletconnect.com/2.0/specs/servers/keys/) and unsubscribe from all active subscriptions.

```kotlin
val unregistrationParams = Notify.Params.Unregistration(/*CAIP-10 account*/)
NotifyClient.unregister(
  unregistrationParams,
  onSuccess = {
      // callback for when the unregistration was successful
  },
  onError = { error ->
    // callback for when the unregistration has failed
  }
)
```

#### Subscribe to a Dapp

Calling `NotifyClient.subscribe` will establish the subscription with the dapp specified in the `Notify.Params.Subscribe` params passed into the function. The `Notify.Params.Subscribe` params requires the uri of the dapp and a CAIP-10 compatible account.

```kotlin
val subscribeParams = Notify.Params.Subscribe(/*Dapp uri*/, /*CAIP-10 account*/)

NotifyClient.subscribe(
    params = subscribeParams,
    onSuccess = {
        // callback for when the subscription request was successfully sent
    },
    onError = { error: Notify.Model.Error ->
        // callback for when the subscription request has failed
    }
)
```

#### Update Subscription

To update a subscription, pass `Notify.Params.Update` with the subscription topic that is to be updated. If unsuccessful, an error is returned in the callback. The subscription topic can be fetched from the `NotifyClient.getActiveSubscriptions()`

```kotlin
val topic = // active subscription topic
val scope = // list of notification types
val params = Notify.Params.Update(topic, scope)

NotifyClient.update(params) { error ->
    // callback for when the update has failed
}
```

#### Delete Subscription

To delete a subscription, pass `Notify.Params.DeleteSubscription` with the subscription topic that is to be deleted. If unsuccessful, an error is returned in the callback. The subscription topic can be fetched from the `NotifyClient.getActiveSubscriptions()`

```kotlin
val topic = // active subscription topic
val params = Notify.Params.DeleteSubscription(topic)

NotifyClient.deleteSubscription(params) { error ->
    // callback for when the delete has failed
}
```

#### Get Active Subscriptions

To get a map of all the active subscriptions, call the `getActiveSubscriptions` function. It will return a map with the topic as the key and `Notify.Model.Subscription` as the value.

```kotlin
NotifyClient.getActiveSubscriptions()
```

#### Get Notification Types

To get a map of all the active subscriptions, call the `getNotificationTypes` function. It will return a map with the notification type id as the key and `Notify.Model.NotificationType` as the value.

```kotlin
val appMetadata: Core.Model.AppMetaData = /*App Metadata could be fetched from NotifyClient.getActiveSubscriptions()*/
val appDomain: String = /*App Domain*/ // URI(appMetadata.url).host
val notificationTypesParams = Notify.Params.NotificationTypes(appDomain)
NotifyClient.getNotificationTypes(notificationTypesParams)
```

#### Get Message History

To get all the messages for a specific subscription topic, call the `getMessageHistory` function by passing an instance of `Notify.Params.MessageHistory`. It will return a map with the request ids as the key and `Notify.Model.MessageRecord` as the value.

```kotlin
val subscriptionTopic =/*Subscription Topic*/
val messageHistoryParams = Notify.Params.MessageHistory(subscriptionTopic)
val mapOfMessages: Map<Long, Notify.Model.MessageRecord> = NotifyClient.getMessageHistory(messageHistoryParams)
```

#### Decrypt Message

To decrypt a message sent by Push server, pass the topic and encrypted message into `Notify.Params.DecryptMessage`. Pass the variable into `NotifyClient.decryptMessage` and use the `onSuccess` and `onError` callbacks to react to the result. This function is not needed when using the `NotifyMessageService`.

```kotlin
val params = Notify.Params.DecryptMessage(topic = /*topic*/, encryptedMessage = /*encrypted message*/)

NotifyClient.decryptMessage(
    params,
    onSuccess = { message: Notify.Model.Message ->
        // callback for when the decryption is successful
    },
    onError = { error: Notify.Model.Error ->
        // callback for when the decryption has failed
    }
)
```

#### Push Notification best practices

`Notify.Model.Message` contains a `type` field, which is a unique id of the notification type. It is recommended to use this field as a notification channel id. By doing so it will create a channel for each notification type. To allow users to granularly control which notifications they want to receive within system settings, it is recommended to create a separate channel for every dapp and every notification type they might have. By doing so user would be able to turn off notifications for specific notification type per every subscribed dapp.

```kotlin
override fun onMessage(message: Notify.Model.Message, originalMessage: RemoteMessage) {
    val appMetadata = NotifyClient.getActiveSubscriptions()[message.topic]?.metadata ?: throw IllegalStateException("No active subscription for topic: ${message.topic}")
    val appDomain = URI(appMetadata.url).host ?: throw IllegalStateException("Unable to parse domain from $appMetadata.url")

    val typeName = NotifyClient.getNotificationTypes(Notify.Params.NotificationTypes(appDomain))[message.type]?.name
        ?: throw IllegalStateException("No notification type for topic:${message.topic} and type: ${message.type}")

    val channelId = message.type
    val channelName = (appMetadata.name + ": " + typeName)

    val notificationBuilder = NotificationCompat.Builder(this, channelId)
        .setContentTitle(message.title)
        .setSmallIcon(android.R.drawable.ic_popup_reminder) // specify icon for notification
        .setContentText(message.body)
        .setAutoCancel(true) // clear notification after click
        .setSound(defaultSoundUri) // specify sound for notification
        .setContentIntent(pendingIntent) // specify pendingIntent

    // Since android Oreo notification channel is needed.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH)
        notificationManager.createNotificationChannel(channel)
    }

    notificationManager.notify(message.hashCode(), notificationBuilder.build()) // specify id of notification
}


```

</PlatformTabItem>
<PlatformTabItem value="react-native">

Install the WalletConnect NotifyClient package.

```bash npm2yarn
npm install @walletconnect/notify-client @walletconnect/react-native-compat
```

## Initialize the Notify SDK client.

```javascript
import { NotifyClient } from '@walletconnect/notify-client'

const notifyClient = await NotifyClient.init({
  projectId: '<YOUR PROJECT ID>'
})
```

## Add listeners for relevant events

```javascript
// Handle response to a `notifyClient.subscribe(...)` call
notifyClient.on('notify_subscription', async ({ params }) => {
  const { error } = params

  if (error) {
    // Setting up the subscription failed.
    // Inform the user of the error and/or clean up app state.
    console.error('Setting up subscription failed: ', error)
  } else {
    // New subscription was successfully created.
    // Inform the user and/or update app state to reflect the new subscription.
    console.log(`Subscribed successfully.`)
  }
})

// Handle an incoming notification
notifyClient.on('notify_message', ({ params }) => {
  const { message } = params
  // e.g. build a notification using the metadata from `message` and show to the user.
})

// Handle response to a `notifyClient.update(...)` call
notifyClient.on('notify_update', ({ params }) => {
  const { error } = params

  if (error) {
    // Updating the subscription's scope failed.
    // Inform the user of the error and/or clean up app state.
    console.error('Setting up subscription failed: ', error)
  } else {
    // Subscription's scope was updated successfully.
    // Inform the user and/or update app state to reflect the updated subscription.
    console.log(`Successfully updated subscription scope.`)
  }
})

// Handle a change in the existing subscriptions (e.g after a subscribe or update)
notifyClient.on('notify_subscriptions_changed', ({ params }) => {
  const { subscriptions } = params
  // `subscriptions` will contain any *changed* subscriptions since the last time this event was emitted.
  // To get a full list of subscriptions for a given account you can use `notifyClient.getActiveSubscriptions({ account: 'eip155:1:0x63Be...' })`
})
```

## Register an identity key for cross-device account syncing

:::note
This is a one-time action per account. It does not need to be repeated after initial registration of the new account.
:::

### Registering as a dapp

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`
const domain =  'app.mydomain.com', // pass the domain (i.e. the hostname) where your dapp is hosted.
const allApps =  false // The user will be prompted to authorize this dapp to send and receive messages on their behalf for only this specific domain using their WalletConnect identity.


// No need to register and sign message if already registered.
if (notifyClient.isRegistered({ account, domain, allApps })) return;

const {registerParams, message}  = notifyClient.prepareRegistration({
  account,
  domain,
  allApps
});

const signature = await ethersWallet.signMessage(message);

await notifyClient.register({
  registerParams,
  signature,
})
```

### Registering as a wallet

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`
const domain =  'app.mydomain.com', // pass the domain (i.e. the hostname) where your dapp is hosted.
const allApps =  true // The user will be prompted to authorize this wallet to send and receive messages on their behalf for ALL domains using their WalletConnect identity.



// No need to register and sign message if already registered.
if (notifyClient.isRegistered({ account, domain, allApps })) return;

const {registerParams, message}  = notifyClient.prepareRegistration({
  account,
  domain,
  allApps
});

const signature = await ethersWallet.signMessage(message);

await notifyClient.register({
  registerParams,
  signature,
})
```

## Managing Subscriptions

#### Creating a new subscription

:::info
To identify dapps that can be subscribed to via Notify, we can query the following Explorer API endpoint:

https://explorer-api.walletconnect.com/v3/dapps?projectId=YOUR_PROJECT_ID&is_notify_enabled=true
:::

```javascript
// Get the domain of the target dapp from the Explorer API response
const appDomain = new URL(fetchedExplorerDapp.platform_browser).hostname

// Subscribe to `fetchedExplorerDapp` by passing the account to be subscribed and the domain of the target dapp.
await notifyClient.subscribe({
  account,
  appDomain
})

// -> Success/Failure will be received via the `notify_update` event registered previously.
// -> New subscription will be emitted via the `notify_subscriptions_changed` watcher event.
```

#### Updating notification types on an existing subscription

```javascript
// `topic` - subscription topic of the subscription that should be updated.
// `scope` - an array of notification types that should be enabled going forward. The current scopes can be found under `subscription.scope`.
await notifyClient.update({
  topic,
  scope: ['alerts']
})

// -> Success/Failure will be received via the `notify_update` event registered previously.
// -> Updated subscription will be emitted via the `notify_subscriptions_changed` watcher event.

// get notification types by accessing `scope` member of a dapp's subscription
const notificationTypes = notifyClient
  .getActiveSubscriptions({ account })
  .filter(subscription => subscription.topic === topic).scope
```

#### Removing an existing subscription

```javascript
// `topic` - subscription topic of the subscription that should be deleted.
await notifyClient.deleteSubscription({ topic })
```

#### Retrieving all currently active subscriptions

```javascript
// Will return all active subscriptions for the provided account, keyed by subscription topic.
const accountSubscriptions = notifyClient.getActiveSubscriptions({
  account: `eip155:1:0x63Be...`
})
```

#### Retrieving all past messages for a given subscription

```javascript
// Will return all past Notify messages for the provided subscription topic, keyed by messageId.
const messageHistory = notifyClient.getNotificationHistory({ topic })
```

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/api/sign/dapp-usage.md">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

# Dapp Usage

## Implementation

<PlatformTabs
groupId="api-sign"
activeOptions={["web","ios","android","flutter","csharp", "unity"]}>

<PlatformTabItem value="web">
This library is compatible with Node.js, browsers and React Native applications (Node.js modules require polyfills for React Native).

Dapps will also need to install WalletConnectModal for the UI.

```bash npm2yarn
npm install @walletconnect/modal
```

:::info
For an example implementation, please refer to our `react-dapp-v2` [example](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2).
:::

#### Install Packages

Dapps will also need to install `WalletConnectModal` for the UI.

```bash npm2yarn
npm install @walletconnect/modal
```

#### Create a Session

**1. Initiate your WalletConnect client with the relay server, using [your Project ID](../../cloud/relay.mdx).**

```javascript
import SignClient from '@walletconnect/sign-client'

const signClient = await SignClient.init({
  projectId: '<YOUR_PROJECT_ID>',
  // optional parameters
  relayUrl: '<YOUR RELAY URL>',
  metadata: {
    name: 'Example Dapp',
    description: 'Example Dapp',
    url: '#',
    icons: ['https://walletconnect.com/walletconnect-logo.png']
  }
})
```

**2. Add listeners for desired `SignClient` events.**

:::info
To listen to pairing-related events, please follow the guidance for [Pairing API event listeners](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-api).
:::

```javascript
signClient.on('session_event', ({ event }) => {
  // Handle session events, such as "chainChanged", "accountsChanged", etc.
})

signClient.on('session_update', ({ topic, params }) => {
  const { namespaces } = params
  const _session = signClient.session.get(topic)
  // Overwrite the `namespaces` of the existing session with the incoming one.
  const updatedSession = { ..._session, namespaces }
  // Integrate the updated session state into your dapp state.
  onSessionUpdate(updatedSession)
})

signClient.on('session_delete', () => {
  // Session was deleted -> reset the dapp state, clean up from user session, etc.
})
```

**3. Create a new WalletConnectModal instance.**

```javascript
import { WalletConnectModal } from '@walletconnect/modal'

const walletConnectModal = new WalletConnectModal({
  projectId: '<YOUR_PROJECT_ID>',
  // `standaloneChains` can also be specified when calling `walletConnectModal.openModal(...)` later on.
  standaloneChains: ['eip155:1']
})
```

**4. Connect the application and specify session permissions.**

```javascript
try {
  const { uri, approval } = await signClient.connect({
    // Optionally: pass a known prior pairing (e.g. from `signClient.core.pairing.getPairings()`) to skip the `uri` step.
    pairingTopic: pairing?.topic,
    // Provide the namespaces and chains (e.g. `eip155` for EVM-based chains) we want to use in this session.
    requiredNamespaces: {
      eip155: {
        methods: [
          'eth_sendTransaction',
          'eth_signTransaction',
          'eth_sign',
          'personal_sign',
          'eth_signTypedData'
        ],
        chains: ['eip155:1'],
        events: ['chainChanged', 'accountsChanged']
      }
    }
  })

  // Open QRCode modal if a URI was returned (i.e. we're not connecting an existing pairing).
  if (uri) {
    walletConnectModal.openModal({ uri })
    // Await session approval from the wallet.
    const session = await approval()
    // Handle the returned session (e.g. update UI to "connected" state).
    // * You will need to create this function *
    onSessionConnect(session)
    // Close the QRCode modal in case it was open.
    walletConnectModal.closeModal()
  }
} catch (e) {
  console.error(e)
}
```

#### Session Authenticate with ReCaps

The authenticate() method enhances the WalletConnect protocol, offering EVM dApps a sophisticated mechanism to request wallet authentication and simultaneously establish a session. This innovative approach not only authenticates the user but also facilitates a seamless session creation, integrating the capabilities defined by ERC-5573, also known as ReCaps.

ReCaps extend the SIWE protocol, enabling users to give informed consent for dApps to exercise scoped capabilities on their behalf. This consent mechanism is crucial for authorizing a dApp to perform actions or access resources, thus ensuring security and trust in dApp interactions. These scoped capabilities are specified through ReCap URIs in the resources field of the AuthRequestParams, which translate to human-readable consent in the SIWE message, detailing the actions a dApp is authorized to undertake.

To initiate an authentication and authorization request, a dApp invokes the authenticate() method, passing in parameters that include desired capabilities as outlined in EIP-5573. The method generates a pairing URI for user interaction, facilitating a streamlined authentication and consent process.

Example of initiating an authentication request with ReCaps:

```typescript
const { uri, response } = await signClient.authenticate({
  chains: ['eip155:1', 'eip155:2'], // chains your dapp requests authentication for
  domain: 'localhost', // your domain
  uri: 'http://localhost/login', // uri
  nonce: '1239812982', // random nonce
  methods: ['personal_sign', 'eth_chainId', 'eth_signTypedData_v4'], // the methods you wish to use
  resources: ['https://example.com'] // any resources relevant to the connection
})

// Present the URI to users as QR code to be able to connect with a wallet
...

// wait for response
const result = await response()

// after a Wallet establishes a connection response will resolve with auths ( authentication objects ) & the established session
const { auths, session } = result;

// now you can send requests to that session
```

#### Making Requests

Once the session has been established successfully, you can start making JSON-RPC requests to be approved and signed by the wallet:

```javascript
const result = await signClient.request({
  topic: session.topic,
  chainId: 'eip155:1',
  request: {
    method: 'personal_sign',
    params: [
      '0x7468697320697320612074657374206d65737361676520746f206265207369676e6564',
      '0x1d85568eEAbad713fBB5293B45ea066e552A90De'
    ]
  }
})
```

> For more information on available JSON-RPC requests, see the [JSON-RPC reference](../../advanced/multichain/rpc-reference/ethereum-rpc.md).

### Restoring a Session

Sessions are saved to localstorage, meaning that even if the web page is reloaded, the session can still be retrieved, as demonstrated in the following code:

```ts
const lastKeyIndex = signClient.session.getAll().length - 1
const lastSession = signClient.session.getAll()[lastKeyIndex]
```

#### Finding a Specific Session

If you need to find a specific session, you can do so by passing in a known `requiredNamespace` and calling `find`.

```ts
const specificSession = _client.find({
  requiredNamespaces: {
    eip155: {
      methods: [
        'eth_sendTransaction',
        'eth_signTransaction',
        'eth_sign',
        'personal_sign',
        'eth_signTypedData'
      ],
      chains: ['eip155:5'],
      events: ['chainChanged', 'accountsChanged']
    }
  }
})
```

</PlatformTabItem>

<PlatformTabItem value="ios">

#### Configure Networking and Pair clients

Make sure that you properly configure Networking and Pair Clients first.

- [Networking](../core/relay.mdx)
- [Pairing](../core/pairing.mdx)

#### Configure Sign Client

In order to initialize a client, call a `configure` method on the Sign instance

```swift
Sign.configure(crypto: CryptoProvider)
```

#### Subscribe for Sign publishers

When your `Sign` instance receives requests from a peer it will publish related event. So you should set subscription to handle them.

To track sessions subscribe to `sessionsPublisher` publisher

```swift
Sign.instance.sessionsPublisher
    .receive(on: DispatchQueue.main)
    .sink { [unowned self] (sessions: [Session]) in
        // reload UI
    }.store(in: &publishers)
```

Following publishers are available to subscribe:

```swift
    public var sessionsPublisher: AnyPublisher<[Session], Never>
    public var sessionProposalPublisher: AnyPublisher<Session.Proposal, Never>
    public var sessionRequestPublisher: AnyPublisher<Request, Never>
    public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
    public var sessionSettlePublisher: AnyPublisher<Session, Never>
    public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
    public var sessionResponsePublisher: AnyPublisher<Response, Never>
    public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never>
    public var sessionUpdatePublisher: AnyPublisher<(sessionTopic: String, namespaces: [String : SessionNamespace]), Never>
    public var sessionEventPublisher: AnyPublisher<(event: Session.Event, sessionTopic: String, chainId: Blockchain?), Never>
    public var sessionUpdateExpiryPublisher: AnyPublisher<(sessionTopic: String, expiry: Date), Never>
```

#### Connect Clients

1. Prepare namespaces that constraints minimal requirements for your dApp:

```Swift
let methods: Set<String> = ["eth_sendTransaction", "personal_sign", "eth_signTypedData"]
let blockchains: Set<Blockchain> = [Blockchain("eip155:1")!, Blockchain("eip155:137")!]
let namespaces: [String: ProposalNamespace] = ["eip155": ProposalNamespace(chains: blockchains, methods: methods, events: []]
```

To learn more on namespaces, check out our [specs](https://specs.walletconnect.com/2.0/specs/clients/sign/namespaces).

2. Your App should generate a pairing URI and share it with a wallet. Uri can be presented as a QR code or sent via a universal link. Wallet begins subscribing for session proposals after receiving URI. In order to create a pairing and send a session proposal, you need to call the following:

```Swift
let uri = try await Sign.instance.connect(requiredNamespaces: namespaces, topic: uri.topic)
```

#### Session Authenticate with ReCaps

The authenticate() method enhances the WalletConnect protocol, offering EVM dApps a sophisticated mechanism to request wallet authentication and simultaneously establish a session. This innovative approach not only authenticates the user but also facilitates a seamless session creation, integrating the capabilities defined by ERC-5573, also known as ReCaps.

ReCaps extend the SIWE protocol, enabling users to give informed consent for dApps to exercise scoped capabilities on their behalf. This consent mechanism is crucial for authorizing a dApp to perform actions or access resources, thus ensuring security and trust in dApp interactions. These scoped capabilities are specified through ReCap URIs in the resources field of the AuthRequestParams, which translate to human-readable consent in the SIWE message, detailing the actions a dApp is authorized to undertake.

To initiate an authentication and authorization request, a dApp invokes the authenticate() method, passing in parameters that include desired capabilities as outlined in EIP-5573. The method generates a pairing URI for user interaction, facilitating a streamlined authentication and consent process.

Example of initiating an authentication request with ReCaps:

```swift
func initiateAuthentication() {
    Task {
        do {
            let authParams = AuthRequestParams.stub() // Customize your AuthRequestParams as needed
            let uri = try await Sign.instance.authenticate(authParams)
            // Present the URI to the user, e.g., show a QR code or send a deep link
            presentAuthenticationURI(uri)
        } catch {
            print("Failed to initiate authentication request: \(error)")
        }
    }
}
```

##### Subscribe to Authentication Responses

Once you have initiated an authentication request, you need to listen for responses from wallets. Responses will indicate whether the authentication request was approved or rejected. Use the authResponsePublisher to subscribe to these events.

Example subscription to authentication responses:

```swift
Sign.instance.authResponsePublisher
    .receive(on: DispatchQueue.main)
    .sink { response in
        switch response.result {
        case .success(let (session, _)):
            if let session = session {
                // Authentication successful, session established
                handleSuccessfulAuthentication(session)
            } else {
                // Authentication successful, but no session created (SIWE-only flow)
                handleSuccessfulAuthenticationWithoutSession()
            }
        case .failure(let error):
            // Authentication request was rejected or failed
            handleAuthenticationFailure(error)
        }
    }
    .store(in: &subscriptions)
```

In this setup, the authResponsePublisher notifies your dApp of the outcome of the authentication request. Your dApp can then proceed based on whether the authentication was successful, rejected, or failed due to an error.

Example of AuthRequestParams:

```swift
extension AuthRequestParams {
    static func stub(
        domain: String = "yourDappDomain.com",
        chains: [String] = ["eip155:1", "eip155:137"],
        nonce: String = "uniqueNonce",
        uri: String = "https://yourDappDomain.com/login",
        statement: String? = "I accept the Terms of Service: https://yourDappDomain.com/tos",
        resources: [String]? = nil, // here your dapp may request authorization with recaps
        methods: [String]? = ["personal_sign", "eth_sendTransaction"]
    ) -> AuthRequestParams {
        return try! AuthRequestParams(
            domain: domain,
            chains: chains,
            nonce: nonce,
            uri: uri,
            statement: statement,
            resources: resources,
            methods: methods
        )
    }
}
```

#### Send Request to the Wallet

Once the session has been established `sessionSettlePublisher` will publish an event. Your dApp can start requesting wallet now.

```Swift
let method = "personal_sign"
let walletAddress = "0x9b2055d370f73ec7d8a03e965129118dc8f5bf83" // This should match the connected address
let requestParams = AnyCodable(["0x4d7920656d61696c206973206a6f686e40646f652e636f6d202d2031363533333933373535313531", walletAddress])
let request = Request(topic: session.topic, method: method, params: requestParams, chainId: Blockchain(chainId)!)
try await Sign.instance.request(params: request)
```

When wallet respond `sessionResponsePublisher` will publish an event so you can verify the response.

#### Extending a Session

By default, session lifetime is set for 7 days and after that time user's session will expire. But if you consider that a session should be extended you can call:

```Swift
try await Sign.instance.extend(topic: session.topic)
```

Above method will extend a user's session to a week.

#### Where to go from here

- Try our [Example dApp](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example) that is part of [WalletConnectSwiftV2 repository](https://github.com/WalletConnect/WalletConnectSwiftV2).
- Build API documentation in XCode: go to Product -> Build Documentation

</PlatformTabItem>

<PlatformTabItem value="android">

#### **Initialization**

```kotlin
val projectId = "" // Get Project ID at https://cloud.walletconnect.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val appMetaData = Core.Model.AppMetaData(
    name = "Dapp Name",
    description = "Dapp Description",
    url = "Dapp URL",
    icons = /*list of icon url strings*/,
    redirect = "kotlin-dapp-wc:/request" // Custom Redirect URI
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

val init = Sign.Params.Init(core = CoreClient)

SignClient.initialize(init) { error ->
    // Error will be thrown if there's an issue during initialization
}
```

The Dapp client is responsible for initiating the connection with wallets and defining the required namespaces (CAIP-2) from the Wallet and is also in charge of sending requests. To initialize the Sign client, create a `Sign.Params.Init` object in the Android Application class with the Core Client. The `Sign.Params.Init` object will then be passed to the `SignClient` initialize function.

#

# **Dapp**

#### **SignClient.DappDelegate**

```kotlin
val dappDelegate = object : SignClient.DappDelegate {
    override fun onSessionApproved(approvedSession: Sign.Model.ApprovedSession) {
        // Triggered when Dapp receives the session approval from wallet
    }

    override fun onSessionRejected(rejectedSession: Sign.Model.RejectedSession) {
        // Triggered when Dapp receives the session rejection from wallet
    }

    fun onSessionAuthenticateResponse(sessionAuthenticateResponse: Sign.Model.SessionAuthenticateResponse) {
        // Triggered when Dapp receives the session authenticate response from wallet
    }

    override fun onSessionUpdate(updatedSession: Sign.Model.UpdatedSession) {
        // Triggered when Dapp receives the session update from wallet
    }

    override fun onSessionExtend(session: Sign.Model.Session) {
        // Triggered when Dapp receives the session extend from wallet
    }

    override fun onSessionEvent(sessionEvent: Sign.Model.SessionEvent) {
        // Triggered when the peer emits events that match the list of events agreed upon session settlement
    }

    override fun onSessionDelete(deletedSession: Sign.Model.DeletedSession) {
        // Triggered when Dapp receives the session delete from wallet
    }

    override fun onSessionRequestResponse(response: Sign.Model.SessionRequestResponse) {
        // Triggered when Dapp receives the session request response from wallet
    }

    override fun onProposalExpired(proposal: Modal.Model.ExpiredProposal) {
        // Triggered when a proposal becomes expired
    }

    override fun onRequestExpired(request: Modal.Model.ExpiredRequest) {
        // Triggered when a request becomes expired
    }

    override fun onConnectionStateChange(state: Sign.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Sign.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}

SignClient.setDappDelegate(dappDelegate)
```

The SignClient needs a `SignClient.DappDelegate` passed to it for it to be able to expose asynchronously updates sent from the Wallet.

#

#### **Connect**

```kotlin
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val chains: List<String> = /*List of chains that wallet will be requested for*/
val methods: List<String> = /*List of methods that wallet will be requested for*/
val events: List<String> = /*List of events that wallet will be requested for*/
val requiredNamespaces: Map<String, Sign.Model.Namespaces.Proposal> = mapOf(namespace, Sign.Model.Namespaces.Proposal(accounts, methods, events)) /*Required namespaces to setup a session*/
val optionalNamespaces: Map<String, Sign.Model.Namespaces.Proposal> = mapOf(namespace, Sign.Model.Namespaces.Proposal(accounts, methods, events)) /*Optional namespaces to setup a session*/
val pairing: Core.Model.Pairing = /*Either an active or inactive pairing*/
val connectParams = Sign.Params.Connect(requiredNamespaces, optionalNamespaces, pairing)

fun SignClient.connect(connectParams,
    { onSuccess ->
        /*callback that returns letting you know that you have successfully initiated connecting*/
    },
    { error ->
        /*callback for error while trying to initiate a connection with a peer*/
    }
)
```

More about optional and required namespaces can be found [here](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md)

#

#### **Authenticate**

The authenticate() method enhances the WalletConnect protocol, offering EVM dApps a sophisticated mechanism to request wallet authentication and simultaneously establish a session. This innovative approach not only authenticates the user but also facilitates a seamless session creation, integrating the capabilities defined by ERC-5573, also known as ReCaps.

Capabilities are specified through ReCap URIs in the resources field of the Sign.Params.Authenticate, which translate to human-readable consent in the SIWE message, detailing the actions a dApp is authorized to undertake.

To initiate an authentication and authorization request, a dApp invokes the authenticate() method, passing in parameters that include desired capabilities as outlined in EIP-5573. The method generates a pairing URI for user interaction, facilitating a streamlined authentication and consent process.

Example of initiating an authentication request with ReCaps:

```kotlin
 val authenticateParams = Sign.Params.Authenticate(
            domain = "your.domain",
            chains = listof("eip155:1", "eip155:137"),
            methods = listOf("personal_sign", "eth_signTypedData"),
            uri = "https://yourDappDomain.com/login",
            nonce = randomNonce,
            statement = "Sign in with wallet.",
            resources = null, // here your dapp may request authorization with recaps
        )

SignClient.authenticate(authenticateParams,
    onSuccess = { url ->
        //Handle authentication URI. Show as a QR code a send via deeplink
    },
    onError = { error ->
        //Handle error
    }
)
```

Once you have sent an authentication request, await for responses from wallets. Responses will indicate whether the authentication request was approved or rejected. Use the onSessionAuthenticateResponse callback to receive a response:

```kotlin
 fun onSessionAuthenticateResponse(sessionAuthenticateResponse: Sign.Model.SessionAuthenticateResponse) {
        // Triggered when Dapp receives the session authenticate response from wallet

        if (sessionAuthenticateResponse is Sign.Model.SessionAuthenticateResponse.Result) {
            if (sessionAuthenticateResponse.session != null) {
                // Authentication successful, session established
            } else {
                // Authentication successful, but no session created (SIWE-only flow)
            }
        } else {
            // Authentication request was rejected or failed
        }

}
```

#

#### **Get List of Settled Sessions**

```kotlin
SignClient.getListOfSettledSessions()
```

To get a list of the most current settled sessions, call `SignClient.getListOfSettledSessions()` which will return a list of type `Session`.

#

#### **Get list of pending session requests for a topic**

```kotlin
SignClient.getPendingRequests(topic: String)
```

To get a list of pending session requests for a topic, call `SignClient.getPendingRequests()` and pass a topic which will return
a `PendingRequest` object containing requestId, method, chainIs and params for pending request.

</PlatformTabItem>

<PlatformTabItem value="flutter">

#### Initialization

To create an instance of `SignClient`, you need to pass in the core and metadata parameters.

```dart
SignClient signClient = await SignClient.createInstance(
    relayUrl: 'wss://relay.walletconnect.com', // The relay websocket URL, leave blank to use the default
    projectId: '123',
    metadata: PairingMetadata(
        name: 'dapp (Requester)',
        description: 'A dapp that can request that transactions be signed',
        url: 'https://walletconnect.com',
        icons: ['https://avatars.githubusercontent.com/u/37784886'],
    ),
);
```

#### Connection

To connect with specific parameters and display the returned URI, use `connect` with the required namespaces.

```dart
ConnectResponse response = await signClient.connect(
    requiredNamespaces: {
        'eip155': RequiredNamespace(
            chains: ['eip155:1'], // Ethereum chain
            methods: ['eth_signTransaction'], // Requestable Methods
        ),
        'kadena': RequiredNamespace(
            chains: ['kadena:mainnet01'], // Kadena chain
            methods: ['kadena_quicksign_v1'], // Requestable Methods
        ),
    }
);

Uri? uri = response.uri;
```

You will use that URI to display a QR code or handle a deep link.

We recommend not handling deep linking yourself. If you want to deep link, then use the [walletconnect_modal_flutter](https://pub.dev/packages/walletconnect_modal_flutter) package.

#### Session Data

Once you've displayed the URI you can wait for the future and hide the QR code once you've received session data.

```dart
final SessionData session = await response.session.future;
```

#### Request Signatures

Once the session had been created, you can request signatures.

```dart
final signature = await signClient.request(
    topic: session.topic,
    chainId: 'eip155:1',
    request: SessionRequestParams(
        method: 'eth_signTransaction',
        params: 'json serializable parameters',
    ),
);
```

#### Respond to Events

You can also respond to events from the wallet, like chain changed, using `onSessionEvent` and `registerEventHandler`.

```dart
signClient.onSessionEvent.subscribe((SessionEvent? session) {
    // Do something with the event
});

signClient.registerEventHandler(
    namespace: 'kadena',
    event: 'kadena_transaction_updated',
);
```

# To Test

Run tests using `flutter test`.
Expected flutter version is: >`3.3.10`

# Useful Commands

- `flutter pub run build_runner build --delete-conflicting-outputs` - Regenerates JSON Generators
- `flutter doctor -v` - get paths of everything installed.
- `flutter pub get`
- `flutter upgrade`
- `flutter clean`
- `flutter pub cache clean`
- `flutter pub deps`
- `flutter pub run dependency_validator` - show unused dependencies and more
- `dart format lib/* -l 120`
- `flutter analyze`

</PlatformTabItem>

<PlatformTabItem value="csharp">

#### Setup

First you must setup `SignClientOptions` which stores both the `ProjectId` and `Metadata`. You may also optionally specify the storage module to use. By default, the `FileSystemStorage` module is used if none is specified.

```csharp
var dappOptions = new SignClientOptions()
{
    ProjectId = "39f3dc0a2c604ec9885799f9fc5feb7c",
    Metadata = new Metadata()
    {
        Description = "An example dapp to showcase WalletConnectSharpv2",
        Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
        Name = "WalletConnectSharpv2 Dapp Example",
        Url = "https://walletconnect.com"
    },
    // Uncomment to disable persistent storage
    // Storage = new InMemoryStorage()
};
```

Then, you must setup the `ConnectOptions` which define what blockchain, RPC methods and events your dapp will use.

_C# Constructor_

```csharp
var dappConnectOptions = new ConnectOptions()
{
    RequiredNamespaces = new RequiredNamespaces()
    {
        {
            "eip155", new RequiredNamespace()
            {
                Methods = new[]
                {
                    "eth_sendTransaction",
                    "eth_signTransaction",
                    "eth_sign",
                    "personal_sign",
                    "eth_signTypedData",
                },
                Chains = new[]
                {
                    "eip155:1"
                },
                Events = new[]
                {
                    "chainChanged",
                    "accountsChanged",
                }
            }
        }
    }
};
```

_Builder Functions Style_

```csharp
var dappConnectOptions1 = new ConnectOptions()
    .RequireNamespace("eip155", new RequiredNamespace()
        .WithMethod("eth_sendTransaction")
        .WithMethod("eth_signTransaction")
        .WithMethod("eth_sign")
        .WithMethod("personal_sign")
        .WithMethod("eth_signTypedData")
        .WithChain("eip155:1")
        .WithEvent("chainChanged")
        .WithEvent("accountsChanged")
    );
```

With both options defined, you can initialize and connect the SDK.

```csharp
var dappClient = await WalletConnectSignClient.Init(dappOptions);
var connectData = await dappClient.Connect(dappConnectOptions);
```

You can grab the `Uri` for the connection request from `connectData`.

```csharp
ExampleShowQRCode(connectData.Uri);
```

Then await connection approval using the `Approval` Task object.

```csharp
Task<SessionStruct> sessionConnectTask = connectData.Approval;
SessionStruct sessionData = await sessionConnectTask;

// or
// SessionStruct sessionData = await connectData.Approval;
```

This `Task` will return the `SessionStruct` when the session was approved, or throw an exception when the session request has either

- Timed out
- Been Rejected

#### Connected Address

To get the currently connected address, use the following function

```csharp
public class Caip25Address
{
    public string Address;
    public string ChainId;
}

public Caip25Address GetCurrentAddress(string chain)
{
    if (string.IsNullOrWhiteSpace(chain))
        return null;

    var defaultNamespace = currentSession.Namespaces[chain];

    if (defaultNamespace.Accounts.Length == 0)
        return null;

    var fullAddress = defaultNamespace.Accounts[0];
    var addressParts = fullAddress.Split(":");

    var address = addressParts[2];
    var chainId = string.Join(':', addressParts.Take(2));

    return new Caip25Address()
    {
        Address = address,
        ChainId = chainId,
    };
}

public Caip25Address GetCurrentAddress()
{
    var currentSession = dappClient.Session.Get(dappClient.Session.Keys[0]);

    var defaultChain = currentSession.Namespaces.Keys.FirstOrDefault();

    if (string.IsNullOrWhiteSpace(defaultChain))
        return null;

    return GetCurrentAddress(defaultChain);
}
```

#### WalletConnect Methods

All sign methods require the `topic` of the session to be given. This can be found in the `SessionStruct` object given when a session has been given approval by the user.

```csharp
var sessionTopic = sessionData.Topic;
```

##### Update Session

Update a session, adding/removing additional namespaces in the given topic.

```csharp
var newNamespaces = new Namespaces(...);
var request = await dappClient.UpdateSession(sessionTopic, newNamespaces);
await request.Acknowledged();
```

##### Extend Session

Extend a session's expiry time so the session remains open

```csharp
var request = await dappClient.Extend(sessionTopic);
await request.Acknowledged();
```

##### Ping

Send a ping to the session

```csharp
var request = await dappClient.Ping(sessionTopic);
await request.Acknowledged();
```

#### Session Requests

Sending session requests as a dapp requires to build the request **and** response classes that the session request `params` will be structured. C# is a statically typed language, so these types must be given whenever you do a session request (or do any querying for session requests).

Currently, **WalletConnectSharp does not automatically assume the object type for `params` is an array**. This is very important, since most EVM RPC requests have `params` as an array type. **Use `List<T>` to workaround this**. For example, for `eth_sendTransaction`, use `List<Transaction>` instead of `Transaction`.

Newtonsoft.Json is used for JSON serialization/deserialization, therefore you can use Newtonsoft.Json attributes when defining fields in your request/response classes.

##### Building a Request type

Create a class for the request and populate it with the JSON properties the request object has. For this example, we will use `eth_sendTransaction`

The `params` field for `eth_sendTransaction` has the object type

```csharp
using Newtonsoft.Json;

public class Transaction
{
    public string from;

    // Newtonsoft.Json attributes can be used
    [JsonProperty("to")]
    public string To;

    [JsonProperty("gas", NullValueHandling = NullValueHandling.Ignore)]
    public string Gas;

    // Properties have limited support
    [JsonProperty("gasPrice", NullValueHandling = NullValueHandling.Ignore)]
    public string GasPrice { get; set; }

    [JsonProperty("value")]
    public string Value { get; set; }

    [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
    public string Data { get; set; } = "0x";
}
```

:::note

[**the `params` field is an array of this object**](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
:::

```json
params: [
  {
    from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
    to: "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
    gas: "0x76c0", // 30400
    gasPrice: "0x9184e72a000", // 10000000000000
    value: "0x9184e72a", // 2441406250
    data: "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
  },
]
```

Now, let's define the actual request class we'll use in `dappClient.Request`

```csharp
[RpcMethod("eth_sendTransaction"), RpcRequestOptions(Clock.ONE_MINUTE, 99997)]
public class EthSendTransaction : List<Transaction>
{
    public EthSendTransaction(params Transaction[] transactions) : base(transactions)
    {
    }
}
```

The `RpcMethod` class attributes defines the rpc method this request uses. The `RpcRequestOptions` class attributes define the expiry time and tag attached to the request. **Both of these attributes are required**

We use `List<Transaction>` since the `params` field for `eth_sendTransaction` is actually sent as an object array. If the `params` field was a normal object, then we could use `Transaction` or define the fields directly into this class.

##### Sending a request

The response type for `eth_sendTransaction` is a `string`, so no response type is required to be made. You only need to create a response type if the response type is a custom object.

```csharp
var wallet = GetCurrentAddress();
var result = new EthSendTransaction(new Transaction()
{
    From = wallet.Address,
    To = wallet.Address,
    Value = "0"
});

// Returns the transaction hash or throws an error
string result = await dappClient.Request<EthSendTransaction, string>(sessionTopic, request, wallet.ChainId);
```

#### Disconnecting

To disconnect a session, use the `Disconnect` function. You may optional provide a reason for the disconnect

```csharp
await dappClient.Disconnect(sessionTopic);

// or

await dappClient.Disconnect(sessionTopic, Error.FromErrorType(ErrorType.USER_DISCONNECTED));
```

#### Subscribe to session events

```csharp
dappClient.SubscribeToSessionEvent("chainChanged", OnChainChanged);
```

</PlatformTabItem>

<PlatformTabItem value="unity">

WalletConnectUnity is a wrapper for WalletConnectSharp. It simplifies managing a single active session, addressing a common challenge with the original library.

#### Features of WalletConnectUnity

1. **Simplified Session Management**: WalletConnectSharp is designed to support multiple sessions, requiring developers to manually track and restore the active session. WalletConnectUnity simplifies this process by focusing on a single session, making it easier to manage session restoration.

2. **Session Restoration**: WalletConnectUnity includes methods to easily access and restore the active session from storage.

3. **Deep Linking Support**: WalletConnectUnity automatically handles deep linking for mobile and desktop wallets.

4. **QR Code Generation**: WalletConnectUnity provides a utility for generating QR codes.

#### Usage

To use WalletConnectUnity in your project:

1. Fill in the Project ID and Metadata fields in the `Assets/WalletConnectUnity/Resources/WalletConnectProjectConfig` asset.
   - If you don‚Äôt have a Project ID, you can create one at [WalletConnect Cloud](https://cloud.walletconnect.com).
   - The `Redirect` fields are optional. They are used to redirect the user back to your app after they approve or reject the session.
2. Initialize `WalletConnect` and connect the wallet:

```csharp
// Initialize singleton
await WalletConnect.Instance.InitializeAsync();

// Or handle instancing manually
var walletConnectUnity = new WalletConnect();
await walletConnectUnity.InitializeAsync();

// Try to resume the last session
var sessionResumed = await WalletConnect.Instance.TryResumeSessionAsync();
if (!sessionResumed)
{
    var connectedData = await WalletConnect.Instance.ConnectAsync(connectOptions);

    // Create QR code texture
    var texture = WalletConnectUnity.Core.Utils.QRCode.EncodeTexture(connectedData.Uri);

    // ... Display QR code texture

    // Wait for wallet approval
    await connectedData.Approval;
}
```

All features of WalletConnectSharp are accessible in WalletConnectUnity.
For complex scenarios, the `SignClient` can be accessed directly through `WalletConnect.SignClient`.

Refer to the `C#` documentation for details on using the Sign API within WalletConnectUnity.
The usage of the WalletConnectSharp.Sign API remains consistent with `C#`.

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/api/sign/overview.md">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Introduction

WalletConnect Sign is a remote signer protocol to communicate securely between web3 wallets and dapps. The protocol establishes a remote pairing between two apps and/or devices using a Relay server to relay payloads. These payloads are symmetrically encrypted through a shared key between the two peers. The pairing is initiated by one peer displaying a QR Code or deep link with a standard WalletConnect URI and is established when the counter-party approves this pairing request.

<CloudBanner />

## Installation

<PlatformTabs
groupId="api-sign"
activeOptions={["web","ios","android","flutter","csharp","unity"]}>

<PlatformTabItem value="web">

```bash npm2yarn
npm install @walletconnect/sign-client
```

:::info

For Node.js, the WalletConnect SignClient additionally requires `lokijs` to manage storage internally.

:::

```bash npm2yarn
npm install --save @walletconnect/sign-client lokijs@1.x
```

</PlatformTabItem>

<PlatformTabItem value="ios">
  <Tabs
queryString="ios-method"
	values={[
		{ label: 'SwiftPackageManager', value: 'spm', },
		{ label: 'Cocoapods', value: 'cocoa', },
	]}
>
<TabItem value="spm">

You can add a WalletConnect SDK to your project with Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package
5. Select WalletConnect check mark

</TabItem>
<TabItem value="cocoa">

1. Update Cocoapods spec repos. Type in terminal `pod repo update`
2. Initialize Podfile if needed with `pod init`
3. Add pod to your Podfile:

```ruby
pod 'WalletConnectSwiftV2'
```

4. Install pods with `pod install`

If you encounter any problems during package installation, you can specify the exact path to the repository

```ruby
pod 'WalletConnectSwiftV2', :git => 'https://github.com/WalletConnect/WalletConnectSwiftV2.git', :tag => '1.0.5'
```

</TabItem>
</Tabs>
</PlatformTabItem>

<PlatformTabItem value="android">
Kotlin implementation of WalletConnect v2 Sign protocol for Android applications. This SDK is developed in Kotlin and usable in both Java and Kotlin files.

- Android Core ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-core)
- Sign ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/sign)

#### Requirements

- Android min SDK 23
- Java 11

#### Installation

root/build.gradle.kts:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

app/build.gradle.kts

```gradle
implementation("com.walletconnect:android-core:release_version")
implementation("com.walletconnect:sign:release_version")
```

</PlatformTabItem>

<PlatformTabItem value="flutter">
Install the WalletConnect client package.

```dart
flutter pub add walletconnect_flutter_v2
```

#### Platform Specific Setup

Depending on your platform, you will have to add different permissions to get the package to work.

#### MacOS

Add the following to your `DebugProfile.entitlements` and `Release.entitlements` files so that it can connect to the WebSocket server.

```xml
<key>com.apple.security.network.client</key>
<true/>
```

</PlatformTabItem>

<PlatformTabItem value="csharp">

#### Install via Packages

Install the WalletConnect Sign Client package via Nuget.

```shell
dotnet add package WalletConnect.Sign
```

</PlatformTabItem>

<PlatformTabItem value="unity">

WalletConnectUnity.Core is a Unity package that provides a client implementation of the WalletConnect v2 protocol. It is built on top of the [WalletConnectSharp.Sign](https://github.com/WalletConnect/WalletConnectSharp) library, which provides the core functionality for the WalletConnect protocol.

#### Prerequisites

- Unity 2021.3 or above
- IL2CPP code stripping level: Minimal (or lower)

#### Package Installation

<Tabs>

<TabItem value="openupm-cli" label="OpenUPM CLI">

To install packages via OpenUPM, you need to have [Node.js](https://nodejs.org/en/) and [openupm-cli](https://openupm.com/docs/getting-started.html#installing-openupm-cli) installed. Once you have them installed, you can run the following commands:

```bash
openupm add com.walletconnect.core
```

</TabItem>

<TabItem value="pm-openupm" label="Package Manager with OpenUPM">

1. Open `Advanced Project Settings` from the gear ‚öô menu located at the top right of the Package Manager‚Äôs toolbar
2. Add a new scoped registry with the following details:
   - Name: `OpenUPM`
   - URL: `https://package.openupm.com`
   - Scope(s): `com.walletconnect`
3. Press plus ‚ûï and then `Save` buttons
4. In the Package Manager windows open the add ‚ûï menu from the toolbar
5. Select `Add package by name...`
6. Enter the package name:
   - `com.walletconnect.core`
7. Press `Add` button

</TabItem>

<TabItem value="pm-git-utl" label="Package Manager with Git URL">

1. Open the add ‚ûï menu in the Package Manager‚Äôs toolbar
2. Select `Add package from git URL...`
3. Enter the package URL:

**WalletConnectUnity Core**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core
```

4. Press `Add` button

It's possible to lock the version of the package by adding `#{version}` at the end of the git URL, where `#{version}` is the git tag of the version you want to use.
For example, to install version `1.0.1` of WalletConnectUnity Modal, use the following URL:

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core#core/1.0.1
```

</TabItem>
</Tabs>

#### WebGL

Due to WebGL's single-threaded nature, certain asynchronous operations like `Task.Run`, `Task.ContinueWith`, `Task.Delay`, and `ConfigureAwait(false)` are not natively supported.

To enable these operations in WebGL builds, an additional third-party package, [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher), is required. This package modifies the Unity WebGL build to delegate work to the `SynchronizationContext`, allowing these operations to be executed on the same thread without blocking the main application. Please note that all tasks are still executed on a single thread, and any blocking calls will freeze the entire application.

The [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher) package can be added via git URL:

```
https://github.com/VolodymyrBS/WebGLThreadingPatcher.git
```

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/api/sign/smart-contract-wallet-usage.md">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

# Smart Contract Wallet Usage

:::info
This section is limited to just for Web/JavaScript at the present moment
:::

Smart Contract wallets like [Argent](https://argent.gitbook.io/argent/wallet-connect-and-argent) are fully supported by the WalletConnect protocol.

However, there are some considerations to be taken when integrating WalletConnect in your dapp for Smart Contract wallets, regarding how the accounts are exposed in the session, message signatures are returned, and transactions are broadcasted.

<PlatformTabs
groupId="api-sign"
activeOptions={["web"]}>

<PlatformTabItem value="web">

### Accounts

:::tip
When you connect your dapp to a smart contract wallet, you will receive the **smart account address** for the wallet. This is not to be confused with the **delegate keys** that are used to sign messages and transactions.
:::

You can detect smart contract wallets by verifying on-chain if the exposed account address has any associated code deployed.

<Tabs>
<TabItem value="ethersjs" label="ethers.js">

```javascript
import { providers, utils } from 'ethers'

const provider = new providers.JsonRpcProvider(rpcUrl)

const bytecode = await provider.getCode(address)

const isSmartContract = bytecode && utils.hexStripZeros(bytecode) !== '0x'
```

</TabItem>
<TabItem value="web3js" label="web3.js">

```javascript
import Web3 from 'web3'

const web3 = new Web3(rpcUrl)

const bytecode = await web3.eth.getCode(address)

const isSmartContract = bytecode && utils.hexStripZeros(bytecode) !== '0x'
```

</TabItem>
</Tabs>

Smart contract wallets are essentially multi-signature wallets that use multiple keys to authorize operations on behalf of these smart contract accounts, so you will have to take into consideration how messages and transactions are handled by your dapp.

## Messages

Normally, when verifying signatures from "normal" accounts, which are Externally Owned Accounts (EOAs), you would use an ECDSA method called `ecrecover()` to retrieve the corresponding public key, which will then map to an address.

In the case of Smart Contract Wallets, you are not able to sign a message with the smart contract account. Therefore, the standard [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) was defined to outline a validation method which can be called on-chain, labeled `isValidSignature()`.

```text
contract ERC1271 {
  bytes4 constant internal MAGICVALUE = 0x1626ba7e;

  function isValidSignature(
    bytes32 _hash,
    bytes memory _signature
  )
    public
    view
    returns (bytes4 magicValue);
}
```

This method has a single parameter `_hash` which should be [EIP-191](https://eips.ethereum.org/EIPS/eip-191) compliant and can be computed using:

<Tabs>
<TabItem value="ethersjs" label="ethers.js">

```javascript
import { utils } from 'ethers'

const hash = utils.hashMessage(message)
```

</TabItem>
<TabItem value="web3js" label="web3.js">

```javascript
import Web3 from 'web3'

const web3 = new Web3(rpcUrl)

const hash = web3.eth.accounts.hashMessage(message)
```

</TabItem>
</Tabs>

## Transactions

Smart Contract wallets, like [Argent](https://argent.gitbook.io/argent/wallet-connect-and-argent), commonly use the concept of meta transactions. These are a specific type of transaction that is signed by one or more key pairs but is submitted to the Ethereum network by a relayer.

The relayer pays the gas fee (in ETH), and the wallet will refund the relayer (in ETH or ERC20 tokens) up to an amount signed by the wallet's owner.

From your dapp's perspective, this is managed by the mobile wallet application. Your dapp will submit a regular `{ to, value, data }` transaction to the web3 provider. This transaction will be transmitted to the mobile wallet application through WalletConnect.

The mobile wallet will transform the data into a meta transaction:

- `to` will be the `RelayerManager` contract address
- `data` will be the encoded data of the call to the `execute()` method with the relevant parameters

Your dapp will receive the transaction hash in order to monitor the status of the transaction, and events will be emitted as usual.

The relayer has the ability to replay a transaction with a higher gas price due to fluctuating network conditions. The transaction hash is modified, and the dapp will not be aware of the new transaction hash.

One solution could be for your dapp to observe a specific event being emitted instead of the transaction status. There is currently work on standardizing events for transactions replies that has been recently proposed via [EIP-2831](https://eips.ethereum.org/EIPS/eip-2831). We hope to improve our SDKs in the future to take this standard into account.

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/api/sign/wallet-usage.md">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Wallet Usage

Sign API establishes a session between a wallet and a dapp in order to expose a set of blockchain accounts that can sign transactions or messages using a secure remote JSON-RPC transport with methods and events.

<CloudBanner/>

<PlatformTabs
groupId="api-sign"
activeOptions={["web","ios","android","csharp"]}>

<PlatformTabItem value="web">

:::info
This library is compatible with Node.js, browsers and React Native applications (Node.js modules require polyfills for React Native).
:::info

#### Migrating from v1.x

**We recommend you install v1 and v2 together for maximum compatibility.** If your wallet already uses `@walletconnect/client@1.x.x`,
you should be able to add `@walletconnect/sign-client@2.x.x` without any issues.

If you experience dependency clashes or you require both `@walletconnect/types@1.x.x` and `@walletconnect/types@2.x.x` in parallel
in your wallet's top-level dependencies, please refer to the [`legacy` packages](https://github.com/WalletConnect/walletconnect-legacy/tree/main/packages) which were published explicitly for this purpose.

In the above scenario, you would replace `@walletconnect/types@1.x.x` with `@walletconnect/legacy-types` and then install `@walletconnect/types@2.x.x`.

#### Initializing the client

Initialize client as a controller using [your Project ID](../../cloud/relay.mdx).

```js
const signClient = await SignClient.init({
  projectId: '<YOUR PROJECT ID>',
  // optional parameters
  relayUrl: '<YOUR RELAY URL>',
  metadata: {
    name: 'Wallet name',
    description: 'A short description for your wallet',
    url: "<YOUR WALLET'S URL>",
    icons: ["<URL TO WALLET'S LOGO/ICON>"]
  }
})
```

#### Setting up event listeners

WalletConnect v2.0 emits events related to the current session. The listeners listed in the following code snippet represent typical
events in a session's lifecycle that you can listen for to synchronise your application accordingly.

Example: when a `session_delete` event is emitted, it makes sense to change the UI from an active session state to
an inactive/disconnected state.

**1. Add listeners for desired `SignClient` events.**

:::info
To listen to pairing-related events, please follow the guidance for [Pairing API event listeners.](../core/pairing.mdx)
:::

```ts
signClient.on('session_proposal', event => {
  // Show session proposal data to the user i.e. in a modal with options to approve / reject it

  interface Event {
    id: number
    params: {
      id: number
      expiry: number
      relays: Array<{
        protocol: string
        data?: string
      }>
      proposer: {
        publicKey: string
        metadata: {
          name: string
          description: string
          url: string
          icons: string[]
        }
      }
      requiredNamespaces: Record<
        string,
        {
          chains: string[]
          methods: string[]
          events: string[]
        }
      >
      pairingTopic?: string
    }
  }
})

signClient.on('session_event', event => {
  // Handle session events, such as "chainChanged", "accountsChanged", etc.

  interface Event {
    id: number
    topic: string
    params: {
      event: {
        name: string
        data: any
      }
      chainId: string
    }
  }
})

signClient.on('session_request', event => {
  // Handle session method requests, such as "eth_sign", "eth_sendTransaction", etc.

  interface Event {
    id: number
    topic: string
    params: {
      request: {
        method: string
        params: any
      }
      chainId: string
    }
  }
})

signClient.on('session_ping', event => {
  // React to session ping event

  interface Event {
    id: number
    topic: string
  }
})

signClient.on('session_delete', event => {
  // React to session delete event

  interface Event {
    id: number
    topic: string
  }
})
```

# Pairing and session permissions

#### URI

The pairing proposal between a wallet and a dapp is made using an [URI](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/). In WalletConnect v2.0 the session and pairing are decoupled from each other. This means that a URI is shared to construct a pairing proposal, and only after settling the pairing the dapp can propose a session using that pairing. In simpler words, the dapp generates an URI that can be used by the wallet for pairing.

#### Namespaces

The `namespaces` parameter is used to specify the namespaces and chains that are intended to be used in the session. The following is an example:

```js
namespaces: {
  eip155: {
    accounts: ["eip155:1:0x0000000000..., eip155:2:0x0000000000..."],
    methods: ["personal_sign", "eth_sendTransaction"],
    events: ["accountsChanged"]
  },
};
```

#### Pairing with `uri`

To create a pairing proposal, simply pass the `uri` received from the dapp into the `signClient.core.pairing.pair()` function.

:::caution
As of 2.0.0 (stable), calling pairing-specific methods (such as `signClient.pair()`) directly on `signClient` will continue to work, but is considered deprecated and will be removed in a future major version.

It is recommended to instead call these methods directly via the [Pairing API.](../core//pairing.mdx), e.g.: `signClient.core.pairing.pair()`.
:::

```js
// This will trigger the `session_proposal` event
await signClient.core.pairing.pair({ uri })

// Approve session proposal, use id from session proposal event and respond with namespace(s) that satisfy dapps request and contain approved accounts
const { topic, acknowledged } = await signClient.approve({
  id: 123,
  namespaces: {
    eip155: {
      accounts: ['eip155:1:0x0000000000...'],
      methods: ['personal_sign', 'eth_sendTransaction'],
      events: ['accountsChanged']
    }
  }
})

// Optionally await acknowledgement from dapp
const session = await acknowledged()

// Or reject session proposal
await signClient.reject({
  id: 123,
  reason: {
    code: 1,
    message: 'rejected'
  }
})
```

#### Pairing with QR Codes

To facilitate better user experience, it is possible to pair wallets with dapps by scanning QR codes. This can be implemented by using any QR code scanning library (example, [react-qr-reader](https://www.npmjs.com/package/react-qr-reader)). After scanning the QR code, pass the obtained `uri` into the `signClient.pair()` function. A useful reference for implementing QR codes for pairing is the [react wallet example](https://github.com/WalletConnect/web-examples/blob/main/advanced/wallets/react-wallet-v2/).

## Authenticated Session

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a Sign-In with Ethereum (SIWE) message, enhanced by ReCaps (ReCap Capabilities). This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

#### Handling Authentication Requests

To handle incoming authentication requests, subscribe to the `session_authenticate` event. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```typescript
web3wallet.on('session_authenticate', async payload => {
  // Process the authentication request here.
  // Steps include:
  // 1. Populate the authentication payload with the supported chains and methods
  // 2. Format the authentication message using the payload and the user's account
  // 3. Present the authentication message to the user
  // 4. Sign the authentication message(s) to create a verifiable authentication object(s)
  // 5. Approve the authentication request with the authentication object(s)
})
```

#### Populate Authentication Payload

```typescript
import { populateAuthPayload } from "@walletconnect/utils";

// EVM chains that your wallet supports
const supportedChains = ["eip155:1", "eip155:2", 'eip155:137'];
// EVM methods that your wallet supports
const supportedMethods = ["personal_sign", "eth_sendTransaction", "eth_signTypedData"];
// Populate the authentication payload with the supported chains and methods
const authPayload = populateAuthPayload({
  authPayload: payload.params.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
});
// Prepare the user's address in CAIP10(https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) format
const iss = `eip155:1:0x0Df6d2a56F90e8592B4FfEd587dB3D5F5ED9d6ef`;
// Now you can use the authPayload to format the authentication message
const message = web3wallet.formatAuthMessage({
  request: authPayload,
  iss
});

// Present the authentication message to the user
...
```

#### Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.
   :::

```typescript
// Approach 1
// Sign the authentication message(s) to create a verifiable authentication object(s)
const signature = await cryptoWallet.signMessage(message, privateKey)
// Build the authentication object(s)
const auth = buildAuthObject(
  authPayload,
  {
    t: 'eip191',
    s: signature
  },
  iss
)

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths: [auth]
})

// Approach 2
// Note that you can also sign multiple messages for every requested chain/address pair
const auths = []
authPayload.chains.forEach(async chain => {
  const message = web3wallet.formatAuthMessage({
    request: authPayload,
    iss: `${chain}:${cryptoWallet.address}`
  })
  const signature = await cryptoWallet.signMessage(message)
  const auth = buildAuthObject(
    authPayload,
    {
      t: 'eip191', // signature type
      s: signature
    },
    `${chain}:${cryptoWallet.address}`
  )
  auths.push(auth)
})

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths
})
```

#### Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```typescript
import { getSdkError } from '@walletconnect/utils'

await web3wallet.rejectSessionAuthenticate({
  id: payload.id,
  reason: getSdkError('USER_REJECTED') // or choose a different reason if applicable
})
```

</PlatformTabItem>

<PlatformTabItem value="ios">

#### Configure Networking and Pair Clients

Confirm you have configured the Network and Pair Client first

- [Networking](../core/relay.mdx)
- [Pairing](../core/pairing.mdx)

#### Configure Sign Client

In order to initialize a client, call a `configure` method on the Sign instance

```swift
Sign.configure(crypto: CryptoProvider)
```

#### Subscribe for Sign Publishers

The following publishers are available to subscribe:

```swift
public var sessionsPublisher: AnyPublisher<[Session], Never>
public var sessionProposalPublisher: AnyPublisher<(proposal: Session.Proposal, context: VerifyContext?), Never>
public var sessionRequestPublisher: AnyPublisher<(request: Request, context: VerifyContext?), Never>
public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
public var sessionSettlePublisher: AnyPublisher<Session, Never>
public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
public var sessionResponsePublisher: AnyPublisher<Response, Never>
public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never>
public var sessionUpdatePublisher: AnyPublisher<(sessionTopic: String, namespaces: [String : SessionNamespace]), Never>
public var sessionEventPublisher: AnyPublisher<(event: Session.Event, sessionTopic: String, chainId: Blockchain?), Never>
public var sessionUpdateExpiryPublisher: AnyPublisher<(sessionTopic: String, expiry: Date), Never>
```

#### Connect Clients

Your Wallet should allow users to scan a QR code generated by dapps. You are responsible for implementing it on your own.
For testing, you can use our test dapp at: https://react-app.walletconnect.com/, which is v2 protocol compliant.
Once you derive a URI from the QR code call `pair` method:

```swift
try await Pair.instance.pair(uri: uri)
```

if everything goes well, you should handle following event:

```swift
Sign.instance.sessionProposalPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] session in
        self?.verifyDapp(session.context)
        self?.showSessionProposal(session.proposal)
    }.store(in: &publishers)
```

Session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Handshake procedure is defined by [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md).
`Session.Proposal` object conveys set of required `ProposalNamespaces` that contains required blockchains methods and events. Dapp requests with methods and wallet will emit events defined in namespaces.

`VerifyContext` provides a domain verification information about `Session.Proposal` and `Request`. It consists of origin of a Dapp from where the request has been sent, validation enum that says whether origin is **unknown**, **valid** or **invalid** and verify URL server.

To enable or disable verification find the **Verify SDK** toggle in your project [cloud](https://cloud.walletconnect.com).

```swift
public struct VerifyContext: Equatable, Hashable {
   public enum ValidationStatus {
       case unknown
       case valid
       case invalid
   }

   public let origin: String?
   public let validation: ValidationStatus
   public let verifyUrl: String
}
```

The user will either approve the session proposal (with session namespaces) or reject it. Session namespaces must at least contain requested methods, events and accounts associated with proposed blockchains.

Accounts must be provided according to [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md) specification and be prefixed with a chain identifier. chain_id + : + account_address. You can find more on blockchain identifiers in [CAIP2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md). Our `Account` type meets the criteria.

```
let account = Account("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
```

Accounts sent in session approval must at least match all requested blockchains.

Example proposal namespaces request:

```json
{
  "eip155": {
    "chains": ["eip155:137", "eip155:1"],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "chains": ["cosmos:cosmoshub-4"],
    "methods": ["cosmos_signDirect"],
    "events": ["someCosmosEvent"]
  }
}
```

Example session namespaces response:

```json
{
  "eip155": {
    "accounts": [
      "eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb",
      "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"
    ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "accounts": ["cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"],
    "methods": ["cosmos_signDirect", "personal_sign"],
    "events": ["someCosmosEvent", "proofFinalized"]
  }
}
```

#### üí° AutoNamespaces Builder Utility

`AutoNamespaces` is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns ready-to-use `SessionNamespace` object.

```swift
public static func build(
    sessionProposal: Session.Proposal,
    chains: [Blockchain],
    methods: [String],
    events: [String],
    accounts: [Account]
) throws -> [String: SessionNamespace]
```

Example usage

```swift
do {
    let sessionNamespaces = try AutoNamespaces.build(
        sessionProposal: proposal,
        chains: [Blockchain("eip155:1")!, Blockchain("eip155:137")!],
        methods: ["eth_sendTransaction", "personal_sign"],
        events: ["accountsChanged", "chainChanged"],
        accounts: [
            Account(blockchain: Blockchain("eip155:1")!, address: "0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!,
            Account(blockchain: Blockchain("eip155:137")!, address: "0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
        ]
    )
    try await Sign.instance.approve(proposalId: proposal.id, namespaces: sessionNamespaces)
} catch {
    print(error)
}
```

#### Approve Session

```swift
 Sign.instance.approve(
    proposalId: "proposal_id",
    namespaces: sessionNamespaces
)
```

#### Reject Session

```swift
Sign.instance.reject(
    proposalId: "proposal_id",
    reason: .userRejected
)
```

When session is successfully approved `sessionSettlePublisher` will publish a `Session`

```swift
Sign.instance.sessionSettlePublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] _ in
        self?.reloadSessions()
    }.store(in: &publishers)
```

`Session` object represents an active session connection with a dapp. It contains dapp‚Äôs metadata (that you may want to use for displaying an active session to the user), namespaces, and expiry date. There is also a topic property that you will use for linking requests with related sessions.

You can always query settled sessions from the client later with:

```swift
Sign.instance.getSessions()
```

#### Track Sessions

When your `Sign` instance receives requests from a peer it will publish a related event. Set a subscription to handle them.

To track sessions subscribe to `sessionsPublisher` publisher

```swift
Sign.instance.sessionsPublisher
    .receive(on: DispatchQueue.main)
    .sink { [self self] (sessions: [Session]) in
        // Reload UI
    }.store(in: &publishers)
```

#### Handle Requests from Dapp

After the session is established, a dapp will request your wallet's users to sign a transaction or a message. Requests will be delivered by the following publisher.

```swift
Sign.instance.sessionRequestPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] session in
        self?.verifyDapp(session.context)
        self?.showSessionRequest(session.request)
    }.store(in: &publishers)
```

When a wallet receives a session request, you probably want to show it to the user. It‚Äôs method will be in scope of session namespaces. And it‚Äôs params are represented by `AnyCodable` type. An expected object can be derived as follows:

```swift
if sessionRequest.method == "personal_sign" {
    let params = try! sessionRequest.params.get([String].self)
} else if method == "eth_signTypedData" {
    let params = try! sessionRequest.params.get([String].self)
} else if method == "eth_sendTransaction" {
    let params = try! sessionRequest.params.get([EthereumTransaction].self)
}
```

Now, your wallet (as it owns your user‚Äôs private keys) is responsible for signing the transaction. After doing it, you can send a response to a dapp.

```swift
let response: AnyCodable = sign(request: sessionRequest) // Implement your signing method
try await Sign.instance.respond(topic: request.topic, requestId: request.id, response: .response(response))
```

#### Update Session

If you want to update user session's chains, accounts, methods or events you can use session update method.

```swift
try await Sign.instance.update(topic: session.topic, namespaces: newNamespaces)
```

#### Extend Session

By default, session lifetime is set for 7 days and after that time user's session will expire. But if you consider that a session should be extended you can call:

```swift
try await Sign.instance.extend(topic: session.topic)
```

above method will extend a user's session to a week.

#### Disconnect Session

For good user experience your wallet should allow users to disconnect unwanted sessions. In order to terminate a session use `disconnect` method.

```swift
try await Sign.instance.disconnect(topic: session.topic)
```

### Authenticated Session

An authenticated session represents a secure connection established between a wallet and a dApp after successful authentication.

#### Handling Authentication Requests

To handle incoming authentication requests, subscribe to the authenticateRequestPublisher. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```swift
Sign.instance.authenticateRequestPublisher
    .receive(on: DispatchQueue.main)
    .sink { result in
        // Process the authentication request here.
        // This involves displaying UI to the user.
    }
    .store(in: &subscriptions) // Assuming `subscriptions` is where you store your Combine subscriptions.
```

#### Building Authentication Objects

To interact with authentication requests, first build authentication objects (AuthObject). These objects are crucial for approving authentication requests. This involves:

**Creating an Authentication Payload** - Generate an authentication payload that matches your application's supported chains and methods.
**Formatting Authentication Messages** - Format the authentication message using the payload and the user's account.
**Signing the Authentication Message** - Sign the formatted message to create a verifiable authentication object.

Example Implementation:

```swift
func buildAuthObjects(request: AuthenticationRequest, account: Account, privateKey: String) throws -> [AuthObject] {
    let requestedChains = Set(request.payload.chains.compactMap { Blockchain($0) })
    let supportedChains: Set<Blockchain> = [Blockchain("eip155:1")!, Blockchain("eip155:137")!, Blockchain("eip155:69")!]
    let commonChains = requestedChains.intersection(supportedChains)
    let supportedMethods = ["personal_sign", "eth_sendTransaction"]

    var authObjects = [AuthObject]()
    for chain in commonChains {
        let accountForChain = Account(blockchain: chain, address: account.address)!
        let supportedAuthPayload = try Sign.instance.buildAuthPayload(
            payload: request.payload,
            supportedEVMChains: Array(commonChains),
            supportedMethods: supportedMethods
        )
        let formattedMessage = try Sign.instance.formatAuthMessage(payload: supportedAuthPayload, account: accountForChain)
        let signature = // Assume `signMessage` is a function you've implemented to sign messages.
            signMessage(message: formattedMessage, privateKey: privateKey)

        let authObject = try Sign.instance.buildSignedAuthObject(
            authPayload: supportedAuthPayload,
            signature: signature,
            account: accountForChain
        )
        authObjects.append(authObject)
    }
    return authObjects
}

```

#### Approving Authentication Requests

To approve an authentication request, construct AuthObject instances for each supported blockchain, sign the authentication messages, build AuthObjects and call approveSessionAuthenticate with the request ID and the authentication objects.

```swift
let session = try await Sign.instance.approveSessionAuthenticate(requestId: requestId, auths: authObjects)
```

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.
   :::

#### Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```swift
try await Sign.instance.rejectSession(requestId: requestId)
```

#### Where to go from here

- Try our example wallet implementation [here](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example/WalletApp).
<!-- - To dive deeper into protocol concepts check out our [documentation](https://docs.walletconnect.com/protocol/glossary) -->
- Build API documentation in XCode: go to Product -> Build Documentation

</PlatformTabItem>

<PlatformTabItem value="android">

#### **Initialization**

```kotlin
val projectId = "" // Get Project ID at https://cloud.walletconnect.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val appMetaData = Core.Model.AppMetaData(
    name = "Wallet Name",
    description = "Wallet Description",
    url = "Wallet URL",
    icons = /*list of icon url strings*/,
    redirect = "kotlin-wallet-wc:/request" // Custom Redirect URI
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

val init = Sign.Params.Init(core = CoreClient)

SignClient.initialize(init) { error ->
    // Error will be thrown if there's an issue during initialization
}
```

The wallet client will always be responsible for exposing accounts (CAPI10 compatible) to a Dapp and therefore is also in charge of signing.
To initialize the Sign client, create a `Sign.Params.Init` object in the Android Application class with the Core Client. The `Sign.Params.Init` object will then be passed to the `SignClient`initialize function.

# **Wallet**

#### **SignClient.WalletDelegate**

```kotlin
val walletDelegate = object : SignClient.WalletDelegate {
    override fun onSessionProposal(sessionProposal: Sign.Model.SessionProposal, verifyContext: Sign.Model.VerifyContext) {
        // Triggered when wallet receives the session proposal sent by a Dapp
    }

    val onSessionAuthenticate: ((Sign.Model.SessionAuthenticate, Sign.Model.VerifyContext) -> Unit)? get() = null
    // Triggered when wallet receives the session authenticate sent by a Dapp

    override fun onSessionRequest(sessionRequest: Sign.Model.SessionRequest, verifyContext: Sign.Model.VerifyContext) {
        // Triggered when a Dapp sends SessionRequest to sign a transaction or a message
    }

    override fun onSessionDelete(deletedSession: Sign.Model.DeletedSession) {
        // Triggered when the session is deleted by the peer
    }

    override fun onSessionSettleResponse(settleSessionResponse: Sign.Model.SettledSessionResponse) {
        // Triggered when wallet receives the session settlement response from Dapp
    }

    override fun onSessionUpdateResponse(sessionUpdateResponse: Sign.Model.SessionUpdateResponse) {
        // Triggered when wallet receives the session update response from Dapp
    }

    override fun onConnectionStateChange(state: Sign.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Sign.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}
SignClient.setWalletDelegate(walletDelegate)
```

`Sign.Model.VerifyContext` provides a domain verification information about SessionProposal and SessionRequest. It consists of origin of a Dapp from where the request has been sent, validation Enum that says whether origin is VALID, INVALID or UNKNOWN and verify url server.

```kotlin
data class VerifyContext(
    val id: Long,
    val origin: String,
    val validation: Model.Validation,
    val verifyUrl: String
)

enum class Validation {
    VALID, INVALID, UNKNOWN
}
```

The SignClient needs a `SignClient.WalletDelegate` passed to it for it to be able to expose asynchronous updates sent from the Dapp.

#

#### **Session Approval**

NOTE: addresses provided in `accounts` array should follow [CAPI10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)
semantics.

```kotlin
val proposerPublicKey: String = /*Proposer publicKey from SessionProposal object*/
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val accounts: List<String> = /*List of accounts on chains*/
val methods: List<String> = /*List of methods that wallet approves*/
val events: List<String> = /*List of events that wallet approves*/
val namespaces: Map<String, Sign.Model.Namespaces.Session> = mapOf(namespace, Sign.Model.Namespaces.Session(accounts, methods, events))

val approveParams: Sign.Params.Approve = Sign.Params.Approve(proposerPublicKey, namespaces)
SignClient.approveSession(approveParams) { error -> /*callback for error while approving a session*/ }
```

To send an approval, pass a Proposer's Public Key along with the map of namespaces to the `SignClient.approveSession` function.

#

#### **Session Rejection**

```kotlin
val proposerPublicKey: String = /*Proposer publicKey from SessionProposal object*/
val rejectionReason: String = /*The reason for rejecting the Session Proposal*/
val rejectionCode: String = /*The code for rejecting the Session Proposal*/
For reference use CAIP-25: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md

val rejectParams: Sign.Params.Reject = Reject(proposerPublicKey, rejectionReason, rejectionCode)
SignClient.rejectSession(rejectParams) { error -> /*callback for error while rejecting a session*/ }
```

To send a rejection for the Session Proposal, pass a proposerPublicKey, rejection reason and rejection code to
the `SignClient.rejectSession` function.

#

#### **Session Disconnect**

```kotlin
val disconnectionReason: String = /*The reason for disconnecting the Session*/
val disconnectionCode: String = /*The code for disconnecting the Session*/
val sessionTopic: String = /*Topic from the Session*/
For reference use CAIP-25: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md
val disconnectParams = Sign.Params.Disconnect(sessionTopic, disconnectionReason, disconnectionCode)

SignClient.disconnect(disconnectParams) { error -> /*callback for error while disconnecting a session*/ }
```

To disconnect from a settled session, pass a disconnection reason with code and the Session topic to the `SignClient.disconnect`
function.

#

#### **Respond Request**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val jsonRpcResponse: Sign.Model.JsonRpcResponse.JsonRpcResult = /*Settled Session Request ID along with request data*/
val result = Sign.Params.Response(sessionTopic = sessionTopic, jsonRpcResponse = jsonRpcResponse)

SignClient.respond(result) { error -> /*callback for error while responding session request*/ }
```

To respond to JSON-RPC method that were sent from Dapps for a session, submit a `Sign.Params.Response` with the session's topic and request
ID along with the respond data to the `SignClient.respond` function.

#### **Reject Request**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val jsonRpcResponseError: Sign.Model.JsonRpcResponse.JsonRpcError = /*Session Request ID along with error code and message*/
val result = Sign.Params.Response(sessionTopic = sessionTopic, jsonRpcResponse = jsonRpcResponseError)

SignClient.respond(result) { error -> /*callback for error while responding session request*/ }
```

To reject a JSON-RPC method that was sent from a Dapps for a session, submit a `Sign.Params.Response` with the settled session's topic and
request ID along with the rejection data to the `SignClient.respond` function.

#

#### **Session Update**

NOTE: addresses provided in `accounts` array should follow [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)
semantics and syntax.

```kotlin
val sessionTopic: String = /*Topic of Session*/
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val accounts: List<String> = /*List of accounts on authorized chains*/
val methods: List<String> = /*List of methods that wallet approves*/
val events: List<String> = /*List of events that wallet approves*/
val namespaces: Map<String, Sign.Model.Namespaces.Session> = mapOf(namespace, Sign.Model.Namespaces.Session(accounts, methods, events))
val updateParams = Sign.Params.Update(sessionTopic, namespaces)

SignClient.update(updateParams) { error -> /*callback for error while sending session update*/ }
```

To update a session with namespaces, use `SignClient.Update` to submit a `Sign.Params.Update` object with the session's topic and updated namespace objects (i.e. adding requesting new methods or events, new accounts on authorized chains, or authorizing new chainIds within a multi-chain namespace).

#

#### **Session Extend**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val extendParams = Sign.Params.Extend(sessionTopic = sessionTopic)

SignClient.extend(extendParams) { error -> /*callback for error while extending a session*/ }
```

To extend a session, create a `Sign.Params.Extend` object with the session's topic to update the session with to `Sign.Extend`. Session is
extended by 7 days.

#### **Session Ping**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val pingParams = Sign.Params.Ping(sessionTopic)
val listener = object : Sign.Listeners.SessionPing {
    override fun onSuccess(pingSuccess: Model.Ping.Success) {
        // Topic being pinged
    }

    override fun onError(pingError: Model.Ping.Error) {
        // Error
    }
}

SignClient.ping(pingParams, listener)
```

To ping a peer with a session, call `SignClient.ping` with the `Sign.Params.Ping` with a session's topic. If ping is successful, topic is
echo'd in listener.

#

#### **Authenticated Session**

An authenticated session represents a secure connection established between a wallet and a dApp after successful authentication.

### Authentication Requests

To handle incoming authentication requests, set up SignClient.WalletDelegate. The onSessionAuthenticate callback will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```kotlin
override val onSessionAuthenticate: ((Wallet.Model.SessionAuthenticate, Wallet.Model.VerifyContext) -> Unit)
  get() = { sessionAuthenticate, verifyContext ->
      // Triggered when wallet receives the session authenticate sent by a Dapp
      // Process the authentication request here
      // This involves displaying UI to the user
}
```

### Responding Authentication Request

To interact with authentication requests, build authentication objects (Sign.Model.Cacao). It involves the following steps:

**Creating an Authentication Payload Params** - Generate an authentication payload params that matches your application's supported chains and methods.
**Formatting Authentication Messages** - Format the authentication message using the payload and the user's account.
**Signing the Authentication Message** - Sign the formatted message to create a verifiable authentication object.

Example:

```kotlin
override val onSessionAuthenticate: ((Wallet.Model.SessionAuthenticate, Wallet.Model.VerifyContext) -> Unit)
  get() = { sessionAuthenticate, verifyContext ->
  val auths = mutableListOf<Sign.Model.Cacao>()

  val authPayloadParams =
    generateAuthPayloadParams(
      sessionAuthenticate.payloadParams,
      supportedChains = listOf("eip155:1", "eip155:137", "eip155:56"), // Note: Only EVM chains are supported
      supportedMethods = listOf("personal_sign", "eth_signTypedData", "eth_sign")
  )

  authPayloadParams.chains.forEach { chain ->
    val issuer = "did:pkh:$chain:$address"
    val formattedMessage = formatAuthMessage(Sign.Params.FormatMessage(authPayloadParams, issuer))

    val signature = signMessage(message: formattedMessage, privateKey: privateKey) //Note: Assume `signMessage` is a function you've implemented to sign messages.
    val auth = generateAuthObject(authPayloadParams, issuer, signature)
    auths.add(auth)
  }
}
```

### Approving Authentication Requests

To approve an authentication request, construct Sign.Model.Cacao instances for each supported chain, sign the authentication messages, build AuthObjects and call approveAuthenticate with the request ID and the authentication objects.

```kotlin
 val approveAuthenticate = Sign.Params.ApproveAuthenticate(id = sessionAuthenticate.id, auths = auths)
SignClient.approveAuthenticate(approveProposal,
  onSuccess = {
    //Redirect back to the dapp if redirect is set: sessionAuthenticate.participant.metadata?.redirect
  },
  onError = { error ->
      //Handle error
  }
)
```

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.
   :::

### Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectAuthenticate method.

```kotlin
val rejectParams = Sign.Params.RejectAuthenticate(
    id = sessionAuthenticate.id,
    reason = "Reason"
)

SignClient.rejectAuthenticate(rejectParams,
  onSuccess = {
        //Success
  },
  onError = { error ->
      //Handle error
  }
)
```

</PlatformTabItem>

<PlatformTabItem value="csharp">

#### Setup

First you must setup `SignClientOptions` which stores both the `ProjectId` and `Metadata`. You may also optionally specify the storage module to use. By default, the `FileSystemStorage` module is used if none is specified.

```csharp
var walletOptions = new SignClientOptions()
{
    ProjectId = "39f3dc0a2c604ec9885799f9fc5feb7c",
    Metadata = new Metadata()
    {
        Description = "An example wallet to showcase WalletConnectSharpv2",
        Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
        Name = "WalletConnectSharpv2 Wallet Example",
        Url = "https://walletconnect.com"
    },
    // Uncomment to disable persistent storage
    // Storage = new InMemoryStorage()
};
```

Once you have the options defined, you can initialize the SDK.

```csharp
var walletClient = await WalletConnectSignClient.Init(walletOptions);
```

Wallets can pair an incoming session using the session's Uri. Pairing a session lets the Wallet obtain the connection proposal which can then be approved or denied.

```csharp
ProposalStruct proposal = await walletClient.Pair(connectData.Uri);
```

The wallet can then approve or reject the proposal using either of the following:

```csharp
string addressToConnect = ...;
var approveData = await walletClient.Approve(proposal, addressToConnect);
await approveData.Acknowledged();
```

```csharp
string[] addressesToConnect = ...;
var approveData = await walletClient.Approve(proposal, addressesToConnect);
await approveData.Acknowledged();
```

```csharp
await walletClient.Reject(proposal, "User rejected");
```

#### WalletConnect Methods

All sign methods require the `topic` of the session to be given. This can be found in the `SessionStruct` object given when a session has been given approval by the user.

```csharp
var sessionTopic = sessionData.Topic;
```

##### Update Session

Update a session, adding/removing additional namespaces in the given topic.

```csharp
var newNamespaces = new Namespaces(...);
var request = await walletClient.UpdateSession(sessionTopic, newNamespaces);
await request.Acknowledged();
```

##### Extend Session

Extend a session's expiry time so the session remains open

```csharp
var request = await walletClient.Extend(sessionTopic);
await request.Acknowledged();
```

##### Ping

Send a ping to the session

```csharp
var request = await walletClient.Ping(sessionTopic);
await request.Acknowledged();
```

#### Responding to Session Requests

Responding to session requests is very similar to sending session requests. See dApp usage on how sending session requests works. All custom session requests requires a request class **and** response class to be created that matches the `params` field type in the custom session request. C# is a statically typed language, so these types must be given whenever you do a session request (or do any querying for session requests).

Currently, **WalletConnectSharp does not automatically assume the object type for `params` is an array**. This is very important, since most EVM RPC requests have `params` as an array type. **Use `List<T>` to workaround this**. For example, for `eth_sendTransaction`, use `List<Transaction>` instead of `Transaction`.

Newtonsoft.Json is used for JSON serialization/deserialization, therefore you can use Newtonsoft.Json attributes when defining fields in your request/response classes.

##### Building a Response type

Create a class for the response and populate it with the JSON properties the response object has. For this example, we will use `eth_getTransactionReceipt`

The `params` field for `eth_getTransactionReceipt` has the object type

```csharp
using Newtonsoft.Json;
using System.Numerics;

[RpcMethod("eth_getTransactionReceipt"), RpcRequestOptions(Clock.ONE_MINUTE, 99995)]
public class TransactionReceipt
{
    [JsonProperty("transactionHash")]
    public string TransactionHash;

    [JsonProperty("transactionIndex")]
    public BigInteger TransactionIndex;

    [JsonProperty("blockHash")]
    public string BlockHash;

    [JsonProperty("blockNumber")]
    public BigInteger BlockNumber;

    [JsonProperty("from")]
    public string From;

    [JsonProperty("to")]
    public string To;

    [JsonProperty("cumulativeGasUsed")]
    public BigInteger CumulativeGasUsed;

    [JsonProperty("effectiveGasPrice ")]
    public BigInteger EffectiveGasPrice ;

    [JsonProperty("gasUsed")]
    public BigInteger GasUsed;

    [JsonProperty("contractAddress")]
    public string ContractAddress;

    [JsonProperty("logs")]
    public object[] Logs;

    [JsonProperty("logsBloom")]
    public string LogBloom;

    [JsonProperty("type")]
    public BigInteger Type;

    [JsonProperty("status")]
    public BigInteger Status;
}
```

The `RpcMethod` class attributes defines the rpc method this response uses, this is optional. The `RpcResponseOptions` class attributes define the expiry time and tag attached to the response, **this is required**.

##### Sending a response

To respond to requests from a dApp, you must define the class representing the request object type. The request type for `eth_getTransactionReceipt` is the following:

```csharp
[RpcMethod("eth_getTransactionReceipt"), RpcRequestOptions(Clock.ONE_MINUTE, 99994)]
public class EthGetTransactionReceipt : List<string>
{
    public EthGetTransactionReceipt(params string[] hashes) : base(hashes)
    {
    }
}
```

We can handle the `eth_getTransactionReceipt` session request by doing the following:

```csharp
walletClient.Engine.SessionRequestEvents<EthGetTransactionReceipt, TransactionReceipt>().OnRequest += OnEthTransactionReceiptRequest;

private Task OnEthTransactionReceiptRequest(RequestEventArgs<EthGetTransactionReceipt, TransactionReceipt> e)
{
    // logic for request goes here
    // set e.Response to return a response
}
```

The callback function gets invoked whenever the wallet receives the `eth_getTransactionReceipt` request from a connected dApp. You may optionally filter further which requests are handled using the `FilterRequests` function

```csharp
walletClient.Engine.SessionRequestEvents<EthGetTransactionReceipt, TransactionReceipt>()
    .FilterRequests(r => r.Topic == sessionTopic)
    .OnRequest += OnEthTransactionReceiptRequest;
```

The callback returns a `Task`, so the callback can be made async. To return a response, **you must** set the `Response` field in `RequestEventArgs<T, TR>` with the desired response.

```csharp
private async Task OnEthTransactionReceiptRequest(RequestEventArgs<EthGetTransactionReceipt, TransactionReceipt> e)
{
    var txHash = e.Request.Params[0];
    var receipt = await EthGetTransactionReceipt(txHash);
    e.Response = receipt;
}
```

#### Disconnecting

To disconnect a session, use the `Disconnect` function. You may optional provide a reason for the disconnect

```csharp
await walletClient.Disconnect(sessionTopic);

// or

await walletClient.Disconnect(sessionTopic, Error.FromErrorType(ErrorType.USER_DISCONNECTED));
```

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/appkit/android/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/android/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/android/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/android/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/android/core/actions.mdx">
# Actions

## Chains

### Get selected chain

You can get selected chain by calling the `getSelectedChain()` on the `Web3Modal` object.

```kotlin
Web3Modal.getSelectedChain()
```

## Web3Modal.ModalDelegate

```kotlin
val web3ModalModalDelegate = object : Web3Modal.ModalDelegate {
    override fun onSessionApproved(approvedSession: Modal.Model.ApprovedSession) {
        // Triggered when receives the session approval from wallet
    }

    override fun onSessionRejected(rejectedSession: Modal.Model.RejectedSession) {
        // Triggered when receives the session rejection from wallet
    }

    override fun onSessionUpdate(updatedSession: Modal.Model.UpdatedSession) {
        // Triggered when receives the session update from wallet
    }

    override fun onSessionExtend(session: Modal.Model.Session) {
        // Triggered when receives the session extend from wallet
    }

    override fun onSessionEvent(sessionEvent: Modal.Model.SessionEvent) {
        // Triggered when the peer emits events that match the list of events agreed upon session settlement
    }

    override fun onSessionDelete(deletedSession: Modal.Model.DeletedSession) {
        // Triggered when receives the session delete from wallet
    }

    override fun onSessionRequestResponse(response: Modal.Model.SessionRequestResponse) {
        // Triggered when receives the session request response from wallet
    }

    override fun onProposalExpired(proposal: Modal.Model.ExpiredProposal) {
        // Triggered when a proposal becomes expired
    }

    override fun onRequestExpired(request: Modal.Model.ExpiredRequest) {
        // Triggered when a request becomes expired
    }

    override fun onConnectionStateChange(state: Modal.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Modal.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}
```

You have set delegate on Web3Modal to start getting updates from Wallet.

```kotlin
    Web3Modal.setDelegate(web3ModalModalDelegate)
```

## Actions

### Disconnect

```kotlin

Web3Modal.disconnect(
    onSuccess = {
    /* callback that letting you know that you have successfully disconnected */
    },
    onError = { error ->
    /* callback for error while trying to disconnection with a peer */
    }
)
```

### Request

```kotlin
val requestParams = Modal.Params.Request(
    method = /* Selected method */,
    params = /* Method params  */,
)

Web3Modal.request(
    request = requestParams,
    onSuccess = {
    /* callback that letting you know that you have successful request */
    },
    onError = { error ->
    /* callback for error */
    }
)
```

### Get Active Account

Returns the current active account connected via Web3Modal

```kotlin
Web3Modal.getAccount()
```

### Get Connection type

Return information about the type of our connection

```kotlin
Web3Modal.getConnectorType()
```
</file>

<file path="docs/appkit/android/core/components.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Components

You can use predefined Web3ModalComponent and add it in your application. As a view, dialog or modal.

```kotlin
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.ModalBottomSheetState
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.compose.material.ModalBottomSheetLayout

setContent {
    val modalSheetState = rememberModalBottomSheetState(initialValue = ModalBottomSheetValue.Hidden, skipHalfExpanded = true)
    val coroutineScope = rememberCoroutineScope()
    val navController = rememberNavController()

    ModalBottomSheetLayout(
        sheetContent = {
            Web3ModalComponent(
                shouldOpenChooseNetwork = true | false,
                closeModal = { coroutineScope.launch { modalSheetState.hide() }
            )
        }
    ) {
        // content
    }
}
```

## Buttons

You can add ready made button components to your application

### Web3Button

<Tabs
    groupId="android_web3button"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

```kotlin
import com.walletconnect.web3.modal.ui.components.button.Web3Button
import com.walletconnect.web3.modal.ui.components.button.ConnectButtonSize
import com.walletconnect.web3.modal.ui.components.button.AccountButtonType
import com.walletconnect.web3.modal.ui.components.button.rememberWeb3ModalState

YourAppScreen(navController: NavController) {
    val web3ModalState = rememberWeb3ModalState(navController = navController)
    Web3Button(
        state = web3ModalState,
        accountButtonType = AccountButtonType.NORMAL || AccountButtonType.MIXED,
        connectButtonSize = ConnectButtonSize.NORMAL || ConnectButtonSize.SMALL
    )
}
```

</TabItem>

<TabItem value="view" label="View">

```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

        <com.walletconnect.web3.modal.ui.components.button.views.Web3Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:connect_button_size="NORMAL" || "SMALL"
            app:account_button_type="NORMAL" || "MIXED"
        />
</LinearLayout>
```

</TabItem>
</Tabs>

### Network Button

<Tabs
    groupId="android_network_button"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

```kotlin
import com.walletconnect.web3.modal.ui.components.button.NetworkButton
import com.walletconnect.web3.modal.ui.components.button.rememberWeb3ModalState

YourAppScreen(navController: NavController) {
    val web3ModalState = rememberWeb3ModalState(navController = navController)
    NetworkButton(state = web3ModalState)
}
```

</TabItem>

<TabItem value="view" label="View">

```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

        <com.walletconnect.web3.modal.ui.components.button.views.NetworkButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
        />
</LinearLayout>
```

</TabItem>
</Tabs>

### Connect Button

<Tabs
    groupId="android_connect_button"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

```kotlin
import com.walletconnect.web3.modal.ui.components.button.ConnectButton
import com.walletconnect.web3.modal.ui.components.button.ConnectButtonSize
import com.walletconnect.web3.modal.ui.components.button.rememberWeb3ModalState

YourAppScreen(navController: NavController) {
    val web3ModalState = rememberWeb3ModalState(navController = navController)
    ConnectButton(
        state = web3ModalState,
        buttonSize = ConnectButtonSize.NORMAL || ConnectButtonSize.SMALL
    )
}
```

</TabItem>

<TabItem value="view" label="View">

```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

        <com.walletconnect.web3.modal.ui.components.button.views.ConnectButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:connect_button_size="NORMAL" || "SMALL"
        />
</LinearLayout>
```

</TabItem>
</Tabs>

### Account Button

<Tabs
    groupId="android_account_button"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

```kotlin
import com.walletconnect.web3.modal.ui.components.button.AccountButton
import com.walletconnect.web3.modal.ui.components.button.AccountButtonType
import com.walletconnect.web3.modal.ui.components.button.rememberWeb3ModalState

YourAppScreen(navController: NavController) {
    val web3ModalState = rememberWeb3ModalState(navController = navController)
    AccountButton(
        state = web3ModalState,
        buttonSize = AccountButtonType.NORMAL || AccountButtonType.MIXED
    )
}
```

</TabItem>

<TabItem value="view" label="View">

```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

        <com.walletconnect.web3.modal.ui.components.button.views.AccountButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:account_button_type="NORMAL" || "MIXED"
        />
</LinearLayout>
```

</TabItem>
</Tabs>

### Web3Modal State

Web3modalState is an object that ensures communication between your application and the state of the Web3Modal.

#### Create web3ModalState:

NavController is required to create Web3ModalState

```kotlin
    val web3modalState = rememberWeb3ModalState(navController)
```

#### Web3ModalState methods

```kotlin
    web3ModalState.isOpen
```

returns `StateFlow<Boolean>` whose value is updated depending on whether the web3modal component is open

```kotlin
    web3modalState.isConnected
```

returns `StateFlow<Boolean>` whose value depends on the active session in Web3Modal
</file>

<file path="docs/appkit/android/core/installation.mdx">
# Installation

Kotlin implementation of AppKit for Android applications.

Android Core ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-core)

Web3Modal ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/web3modal)

### Requirements

- Android min SDK 23
- Java 11

### Installation

root/build.gradle.kts:

```gradle
allprojects {
   repositories {
      mavenCentral()
      maven { url "https://jitpack.io" }
   }
}
```

app/build.gradle.kts

```gradle
implementation(platform("com.walletconnect:android-bom:$BOM_VERSION"))
implementation("com.walletconnect:android-core")
implementation("com.walletconnect:web3modal")
```
</file>

<file path="docs/appkit/android/core/one-click-auth.mdx">
---
title: One-Click Auth / SIWE
---

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a form of authentication that enables users to control their digital identity with their Ethereum account. SIWE is a standard also known as¬†[EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

One-Click Auth¬†represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.
Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as¬†"ReCaps". ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary. WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## Configure your AppKit Client

To integrate SIWE with AppKit, you need to configure your Web3Modal client using `Modal.Model.AuthPayloadParams`, which are required to create a SIWE message for the user to sign:

```kotlin
 Web3Modal.setAuthRequestParams(authPayloadParams)
```

#### Example of AuthRequestParams

```kotlin
 val authParams = Modal.Model.AuthPayloadParams(
    chains = ["eip155:1", "eip155:137"],
    domain = "yourDappDomain.com",
    uri = "https://yourDappDomain.com/login",
    nonce = //uniqueNonce,
    statement = "I accept the Terms of Service: https://yourDappDomain.com/",
    methods = ["personal_sign", "eth_sendTransaction"],
    resources = null //// Here your dapp may request authorization with ReCaps
)
```

Configuring your Web3Modal client with Modal.Model.AuthPayloadParams will prioritize authentication requests over regular session proposals. If the wallet supports One-Click Auth, the session will be created and the user will automatically authenticate without needing to send another SIWE request over personal_sign. If the wallet does not support One-Click Auth, it will fall back to the session proposal. In this case, to authenticate the user, AppKit will send another session request to prove address ownership.

To check whether the user has signed a SIWE message, check `onSessionAuthenticateResponse` callback from `Web3Modal.ModalDelegate`:

```kotlin
fun onSessionAuthenticateResponse(response: Modal.Model.SessionAuthenticateResponse) {
    // Triggered when Dapp receives the session authenticate response from wallet

    if (response is Modal.Model.SessionAuthenticateResponse.Result) {
        if (response.session != null) {
            // Authentication successful, session established
        } else {
            // Authentication successful, but no session created (SIWE-only flow)
        }
    } else {
        // Authentication request was rejected or failed
    }
}
```

### Fallback to SIWE Over Session Request

If the wallet connecting to your dapp does not support One-Click Auth, the SDK will fallback to the `wc_sessionPropose` method and create a session with the wallet. AppKit will then inform the user that they need to sign a message to prove address ownership. AppKit will send a SIWE request to the wallet, and once the wallet responds with a signed message, use `onSIWEAuthenticationResponse` callback to check the result:

```kotlin
 override fun onSIWEAuthenticationResponse(response: Modal.Model.SIWEAuthenticateResponse) {
    if (response is Modal.Model.SIWEAuthenticateResponse.Result) {
        // message and signature
    } else {
        //error
    }
}
```

### Link Mode

The latest release of AppKit supports link mode, a low latency mechanism for transporting One-Click Auth requests and session requests over universal links, reducing the need for a WebSocket connection with the Relay. This significantly enhances the user experience when connecting native dApps to native wallets by reducing the latency associated with networking connections, especially when the user has an unstable internet connection.

To support link mode, configure your AppMetaData `appLink` with a valid universal link and set the `linkMode` property to `true`:

```kotlin
 val appMetaData = Core.Model.AppMetaData(
    ...
    appLink = "https://example.com/example_dapp",
    linkMode = true
)

CoreClient.initialize(
   metaData: appMetaData,
    ...
)

Web3Modal.initialize(Modal.Params.Init(core = CoreClient))
```

Once link mode is configured, your dApp will connect and send requests to wallets via app links after receiving proof from the wallet that it also supports link mode.

The wallet will also send responses using app links. Your app needs to pass these responses to the Web3Modal client so it can process them.

```kotlin
Web3Modal.handleDeepLink(url) { error -> 
    //handle error

}
```

Ensure to handle incoming app links in your Activity onCreate method and in onNewIntent callback.

Ensure that your App Link is properly configured in your app's Manifest file with the `autoVerify` set to `true`:

```
<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />

    <data android:scheme="https" android:host="your_host" />
</intent-filter>
```

For more information on how to configure app links for your app, refer to the [Android Documentation](https://developer.android.com/training/app-links/verify-android-applinks).

For enabling links to app content check [this](https://developer.android.com/training/app-links/deep-linking) documentation page. 

For more information on how to interact with other apps using intents, see [Android Intent Documentation](https://developer.android.com/training/basics/intents).
</file>

<file path="docs/appkit/android/core/options.mdx">
# Options

### Explorer recommended wallets

Allows to set default recommended wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define a list of wallets ids you'd like to prioritize (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```kotlin
val recommendedWalletsIds = listOf<String>(
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"
)

val initParams = Modal.Params.Init(core = CoreClient, recommendedWalletsIds = recommendedWalletsIds)

Web3Modal.initialize(
    init = initParams,
    onSuccess = {
        // Callback will be called if initialization is successful
    },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

### Explorer excluded wallets

Allows to exclude wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```kotlin
val excludedWalletIds = listOf<String>(
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"
)

val initParams = Modal.Params.Init(core = CoreClient, excludedWalletIds = excludedWalletIds)

Web3Modal.initialize(
    init = initParams,
    onSuccess = {
        // Callback will be called if initialization is successful
    },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

### Show installed wallets

Allows you to show the `INSTALLED` icon in the list. To use this feature, you need to add selected wallets that you want to handle to `AndroidManifest.xml` as a query. Specs: [Android Specs](https://developer.android.com/guide/topics/manifest/queries-element)

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <queries>
        <package android:name="..."/>
    </queries>

    <application>
        ...
    </application>
</manifest>
```

### Enable coinbase

:::caution
**The Coinbase integration is Experimental**.
It's public API and associated documentation may still see significant and breaking changes.
:::

Coinbase has been added since version 1.2.0

```kotlin
val initParams = Modal.Params.Init(core = CoreClient, coinbaseEnabled = true)

Web3Modal.initialize(
    init = initParams,
    onSuccess = {
        // Callback will be called if initialization is successful
    },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

Coinbase Wallet SDK requires Web3Modal registration in Activity to receive responses from Coinbase wallet

```kotlin
    fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Web3Modal.register(this)
        // Your content
    }
```
</file>

<file path="docs/appkit/android/core/theming.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Theming

## Usage

<Tabs
    groupId="android_theming"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

Wrap your composable component with `Web3ModalTheme`

```kotlin
import com.walletconnect.web3.modal.ui.Web3ModalTheme

Web3ModalTheme(
    mode = Web3ModalTheme.Mode.AUTO || Web3ModalTheme.Mode.LIGHT || Web3ModalTheme.Mode.DARK,
    lightColors = Web3ModalTheme.provideLightWeb3ModalColors(
        // Override colors
    ),
    darkColors = Web3ModalTheme.provideDarkWeb3ModalColors(
        // Override colors
    )
)    {
    /* any Web3Modal component or graph */
}

```

</TabItem>

<TabItem value="view" label="View">

You can define Web3ModalTheme in yours `style.xml` files

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Web3ModalTheme">
        <item name="modalMode">AUTO || LIGHT || DARK</item>
        /* Override colors */
    </style>
</resources>
```

</TabItem>
</Tabs>

## Mode

<Tabs
    groupId="android_mode_colors"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

```kotlin
    enum class Mode {
        LIGHT, DARK, AUTO
    }
```

</TabItem>

<TabItem value="view" label="View">

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <attr name="modalMode" format="enum">
        <enum name="AUTO" value="0"/>
        <enum name="DARK" value="1"/>
        <enum name="LIGHT" value="2"/>
    </attr>
</resources>
```

</TabItem>
</Tabs>

## Colors

<Tabs
    groupId="android_theming_colors"
    activeOptions={["compose", "view"]}
>
<TabItem value="compose" label="Compose">

Customizable colors in Web3ModalTheme.
To override colors you need to use methods `Web3ModalTheme.provideLightWeb3ModalColors` or Web3ModalTheme.provideDarkWeb3ModalColors
To override foreground or background `ColorPalette` you can define new palette or use one of the Web3ModalTheme methods to provide Palette and override selected colors

```kotlin
    interface Colors {
        val accent100: Color
        val accent90: Color
        val accent80: Color
        val foreground: ColorPalette
        val background: ColorPalette
        val grayGlass: Color
        val success: Color
        val error: Color
    }
```

ColorPalette

```kotlin
    data class ColorPalette(
        val color100: Color,
        val color125: Color,
        val color150: Color,
        val color175: Color,
        val color200: Color,
        val color225: Color,
        val color250: Color,
        val color275: Color,
        val color300: Color,
    )
```

</TabItem>

<TabItem value="view" label="View">

```xml
<?xml version="1.0" encoding="utf-8"?>

You can override those values in Web3ModalTheme in your style.xml file

<resources>
    <attr name="modalAccent100" format="color"/>
    <attr name="modalAccent90" format="color"/>
    <attr name="modalAccent80" format="color"/>
    <attr name="modalForeground100" format="color"/>
    <attr name="modalForeground125" format="color"/>
    <attr name="modalForeground150" format="color"/>
    <attr name="modalForeground175" format="color"/>
    <attr name="modalForeground200" format="color"/>
    <attr name="modalForeground225" format="color"/>
    <attr name="modalForeground250" format="color"/>
    <attr name="modalForeground275" format="color"/>
    <attr name="modalForeground300" format="color"/>
    <attr name="modalBackground100" format="color"/>
    <attr name="modalBackground125" format="color"/>
    <attr name="modalBackground150" format="color"/>
    <attr name="modalBackground175" format="color"/>
    <attr name="modalBackground200" format="color"/>
    <attr name="modalBackground225" format="color"/>
    <attr name="modalBackground250" format="color"/>
    <attr name="modalBackground275" format="color"/>
    <attr name="modalBackground300" format="color"/>
    <attr name="modalGrayGlass" format="color"/>
    <attr name="modalSuccess" format="color"/>
    <attr name="modalError" format="color"/>

</resources>
```

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/android/core/usage.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Usage

`Web3Modal` is a singleton that interacts with the WalletConnectModal SDK.

## Implementation

#### Initialize

```kotlin
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val projectId = "" // Get Project ID at https://cloud.walletconnect.com/
val appMetaData = Core.Model.AppMetaData(
    name = "Kotlin.Web3Modal",
    description = "Kotlin Web3Modal Implementation",
    url = "kotlin.walletconnect.com",
    icons = listOf("https://raw.githubusercontent.com/WalletConnect/walletconnect-assets/master/Icon/Gradient/Icon.png"),
    redirect = "kotlin-web3modal://request"
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

Web3Modal.initialize(
    init = Modal.Params.Init(CoreClient),
    onSuccess = {
        // Callback will be called if initialization is successful
     },
    onError = { error ->
        // Error will be thrown if there's an issue during initialization
    }
)
```

#### Session properties

You can define session properties by calling the `setSessionProperties` method on the `Web3Modal` object.

#### Chains

This example of define ethereum chain. You can define the chains you want to use. The chain must be EVM compatible.

```kotlin
Example of definition chains: https://github.com/WalletConnect/WalletConnectKotlinV2/blob/master/product/web3modal/src/main/kotlin/com/walletconnect/web3/modal/presets/Web3ModalChainsPresets.kt

Web3Modal.setChains(Web3ModalChainsPresets.ethChains.values.toList())
```

**IMPORTANT**: `Chains` must be set before opening the modal.

## Usage

<Tabs
    groupId="android"
    activeOptions={["compose_accompanist", "compose_component", "kotlin-dsl", "nav-graph"]}
>
<TabItem value="compose_accompanist" label="Compose Accompanist">

```kotlin
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.ModalBottomSheetState
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.google.accompanist.navigation.material.BottomSheetNavigator
import com.google.accompanist.navigation.material.ExperimentalMaterialNavigationApi
import com.google.accompanist.navigation.material.ModalBottomSheetLayout
import com.google.accompanist.navigation.material.bottomSheet
import com.walletconnect.web3.modal.ui.web3ModalGraph

setContent {
    val modalSheetState = rememberModalBottomSheetState(initialValue = ModalBottomSheetValue.Hidden, skipHalfExpanded = true)
    val bottomSheetNavigator = BottomSheetNavigator(modalSheetState)
    val navController = rememberNavController(bottomSheetNavigator)

    ModalBottomSheetLayout(bottomSheetNavigator = bottomSheetNavigator) {
        NavHost(
            navController = navController,
            startDestination = "home"
        ) {
            composable("home") {
                HomeScreen()
            }
            web3ModalGraph(navController)
        }
    }
}
```

**IMPORTANT**: Web3Modal uses accompanist navigation material inside. `ModalBottomSheetLayout` should be imported from [Accompanist Navigation Material](https://google.github.io/accompanist/navigation-material/)

```kotlin
import com.walletconnect.web3.modal.ui.openWeb3Modal

navController().openWeb3Modal(
    shouldOpenChooseNetwork = true | false
    onError = {  }
)
```

</TabItem>

<TabItem value="compose_component" label="Compose Component">

```kotlin
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.ModalBottomSheetState
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.compose.material.ModalBottomSheetLayout

setContent {
    val modalSheetState = rememberModalBottomSheetState(initialValue = ModalBottomSheetValue.Hidden, skipHalfExpanded = true)
    val coroutineScope = rememberCoroutineScope()
    val navController = rememberNavController()

    ModalBottomSheetLayout(
        sheetContent = {
            Web3ModalComponent(
                shouldOpenChooseNetwork = true | false,
                closeModal = { coroutineScope.launch { modalSheetState.hide() }
            )
        }
    ) {
        // content
    }
}
```

</TabItem>

<TabItem value="kotlin-dsl" label="Kotlin DSL">

```kotlin
import androidx.navigation.createGraph
import androidx.navigation.fragment.fragment
import com.walletconnect.web3.modal.ui.web3ModalGraph

navController.graph = navController.createGraph("Home") {
    fragment<HomeFragment>("Home")
    web3Modal()
}
```

```kotlin
import androidx.navigation.fragment.findNavController
import com.walletconnect.web3.modal.ui.openWeb3Modal

findNavController().openWeb3Modal(
    shouldOpenChooseNetwork = true | false
    onError = {  }
)
```

</TabItem>
<TabItem value="nav-graph" label="Nav graph">

```xml
<navigation >
    <fragment
        android:id="@+id/HomeFragment"
        android:name="com.walletconnect.sample.HomeFragment">
    </fragment>

    <include app:graph ="@navigation/web3modal_graph"/>
</navigation>
```

```kotlin
import androidx.navigation.fragment.findNavController
import com.walletconnect.web3.modal.ui.openWeb3Modal

findNavController().openWeb3Modal(
    shouldOpenChooseNetwork = true | false
    onError = {  }
)
```

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/features/notifications.mdx">
import Button from '../../components/button'
import Wrapper from '../../components/Home/Wrapper'
import useBaseUrl from '@docusaurus/useBaseUrl'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# Notifications

Notifications power web3 communications between apps and their communities, allowing projects to directly engage users with web3-native notifications sent straight to their wallet address.
Maximize reach with multiple touch points across in-app notifications, in-wallet notifications, and via the Web3Inbox app.

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/notifications/overview'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/notifications/overview',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/notifications/overview'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/notifications/overview'
    }
  ]}
/>
</file>

<file path="docs/appkit/features/one-click-auth.mdx">
import Button from '../../components/button'
import Container from '../../components/Container.js'
import Wrapper from '../../components/Home/Wrapper'
import W3MQuickStart from '../../components/W3MQuickStart'
import useBaseUrl from '@docusaurus/useBaseUrl'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'
import androidLogo from '../../../static/assets/home/androidLogo.png'
import iosLogo from '../../../static/assets/home/iosLogo.png'
import rnLogo from '../../../static/assets/home/rnLogo.png'
import flutterLogo from '../../../static/assets/home/flutterLogo.png'

# One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Enable your users to connect to web3 through a single tap with One-Click Auth, improving connectivity speeds and creating all-around better UX and friction-free user journeys. With one-tap multi-chain and multi-account signing, let users authenticate multiple chains and accounts simultaneously.

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/core/siwe'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/core/siwe',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/core/siwe'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/core/siwe'
    },
    {
      name: 'iOS',
      type: 'ios',
      description: 'Get started with AppKit in iOS.',
      icon: iosLogo,
      href: '../ios/core/one-click-auth',
      isWhite: true
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with AppKit in React Native.',
      icon: rnLogo,
      href: '../react-native/core/siwe'
    },
    {
      name: 'Flutter',
      type: 'flutter',
      description: 'Get started with AppKit in Flutter.',
      icon: flutterLogo,
      href: '../flutter/core/siwe'
    }
  ]}
/>

<br />

<Button name="Try Demo" url="https://lab.web3modal.com/library/wagmi-siwe/" />
</file>

<file path="docs/appkit/features/onramp.mdx">
---
pagination_next: appkit/react/core/installation
title: On-Ramp
---

import Button from '../../components/button'
import Wrapper from '../../components/Home/Wrapper'
import useBaseUrl from '@docusaurus/useBaseUrl'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# On-Ramp

On-Ramp securely provides users access to over 100 cryptocurrencies from right within your app. In just a few clicks, users can purchase tokens to support in-app activity and transactions across multiple chains. Set up in minutes with just one line of code.

<Button name="Try Demo" url="https://lab.web3modal.com/library/wagmi/" />

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/transactions/onramp'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/transactions/onramp',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/transactions/onramp'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/transactions/onramp'
    }
  ]}
/>

## Process Overview

AppKit On-Ramp makes it easy for users to purchase crypto without the hassle of switching between multiple platforms and signing multiple messages - a simple, seamless, in-app experience for anyone looking to securely transact within web3.

For a step-by-step guide on user flow with AppKit On-Ramp, refer to our Youtube video [here](https://youtu.be/m1E_N5b3r18?t=241&feature=shared).

:::info Note
On-Ramp is supported in the latest version of AppKit. If you are using an older version, make sure you upgrade.
:::

### Connect your wallet

Head over to a AppKit-enabled application and click the "Connect Wallet" button. You will be prompted to connect your wallet.

<img className="image-margin" src={useBaseUrl('/img/w3m/onramp/1.png')} />

### Select "Buy Crypto"

Once connected, select "Buy Crypto" from the wallet modal.

<img className="image-margin" src={useBaseUrl('/img/w3m/onramp/2.png')} />

### Choose your provider

Select "Coinbase" as your provider.

<img className="image-margin" src={useBaseUrl('/img/w3m/onramp/3.png')} />

### Complete your purchase

Complete your purchase using Coinbase Pay. You will be prompted to sign in to your Coinbase account.
If the payment page does not appear, you can copy link from the wallet modal and paste it in your browser.

<img className="image-margin" src={useBaseUrl('/img/w3m/onramp/4.png')} />

### Select assets and amount

Choose the asset and amount you would like to purchase from Coinbase.

<img className="image-margin" src={useBaseUrl('/img/w3m/onramp/5.png')} />

### Receive your crypto

Once your purchase is complete, you will receive your crypto in your wallet.

<img className="image-margin" src={useBaseUrl('/img/w3m/onramp/6.png')} />
</file>

<file path="docs/appkit/features/smart-accounts.mdx">
import Button from '../../components/button'
import Wrapper from '../../components/Home/Wrapper'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# Smart Accounts

AppKit now supports Smart Accounts, offering users enhanced security and convenience with features like multi-signature authorization and automated transaction workflows.
This update ensures a seamless and efficient experience for managing digital assets within decentralized applications.

<Button name="Try Demo" url="https://lab.web3modal.com/" />

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/onboarding/smart-accounts'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/onboarding/smart-accounts',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/onboarding/smart-accounts'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/onboarding/smart-accounts'
    }
  ]}
/>
</file>

<file path="docs/appkit/features/socials.mdx">
import Button from '../../components/button'
import Container from '../../components/Container.js'
import Wrapper from '../../components/Home/Wrapper'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'
import rnLogo from '../../../static/assets/home/rnLogo.png'
import flutterLogo from '../../../static/assets/home/flutterLogo.png'

# Email & Socials

Bring your app to a world of new users in minutes with Email and Social login, giving both new and existing users the ability to seamlessly connect to your app using just an email address or social account. Set up with just one line of code and enable Smart Account functionality in minutes.

<Button name="Try Demo" url="https://lab.web3modal.com/library/wagmi/" />
## Supported Providers
AppKit supports the following providers:
- **Email**, **Google**, **X**, **GitHub**, **Discord**, **Apple**, **Facebook** and **Farcaster**.

## Supported Chains

Our Email & Socials feature supports the following chains:
+ Algorand, Arbitrum, Astar zkEVM, Base, Berachain, Binance, Celo, Chiliz, Cronos, Etherlink, Fantom, Flare, Harmony, Hedera, Horizen EON, Loopring, Moonbeam, Near, Optimism, RARI Chain, Sei, ZetaChain, zkSync and XDC Network


## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/onboarding/socials'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/onboarding/socials',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/onboarding/socials'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/onboarding/socials'
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with AppKit in React Native.',
      icon: rnLogo,
      href: '../react-native/onboarding/email'
    },
    {
      name: 'Flutter',
      type: 'flutter',
      description: 'Get started with AppKit in Flutter.',
      icon: flutterLogo,
      href: '../flutter/onboarding/email'
    }
  ]}
/>
</file>

<file path="docs/appkit/features/solana.mdx">
---
pagination_next: appkit/react/core/installation
title: Solana
---

import Button from '../../components/button'
import Container from '../../components/Container.js'
import Wrapper from '../../components/Home/Wrapper'
import W3MQuickStart from '../../components/W3MQuickStart'
import useBaseUrl from '@docusaurus/useBaseUrl'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# Solana

The AppKit SDK supports Solana, allowing users to connect their Solana wallets to applications. AppKit provides a simple, secure, and seamless in-app experience for users looking to transact within web3.

<Button name="Try Demo" url="https://lab.web3modal.com/library/solana/" />

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/core/installation?platform=solana'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/core/installation?platform=solana',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/core/installation?platform=solana'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/core/installation?platform=solana'
    }
  ]}
/>
</file>

<file path="docs/appkit/features/swaps.mdx">
---
pagination_next: appkit/react/transactions/swaps
title: Swaps
---

import Button from '../../components/button'
import Wrapper from '../../components/Home/Wrapper'

import reactLogo from '../../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../../static/assets/home/nextjsLogo.png'
import vueLogo from '../../../static/assets/home/vueLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# Swaps

Enable users to easily switch between crypto assets without leaving your app. With Swaps, users can easily and securely swap tokens right within your app via the AppKit Modal. Set up in minutes with just one line of code.

<Button name="Try Demo" url="https://lab.web3modal.com/" />

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: '../react/transactions/swaps'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: '../next/transactions/swaps',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: '../vue/transactions/swaps'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: '../javascript/transactions/swaps'
    }
  ]}
/>
</file>

<file path="docs/appkit/flutter/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/flutter/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/flutter/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/flutter/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/flutter/core/actions.mdx">
# Actions

### Launch the current wallet

If you connected your dApp through deep linkining to a Wallet app you can launch that wallet app with the following:

```dart
_w3mService.launchConnectedWallet();
```

### Launch block explorer

You can open the selected chain's block explorer easily:

```dart
_w3mService.launchBlockExplorer();
```

### Send an RPC request

```dart
final result = await _w3mService.request(
  topic: _w3mService.session?.topic ?? '',
  chainId: 'eip155:1', // Connected chain id
  request: SessionRequestParams(
    method: 'personal_sign',
    params: ['Sign this', '0xdeadbeef'],
  ),
);
```

A list of all available methods can be found in [constants.dart](https://github.com/WalletConnect/WalletConnectFlutterV2/blob/master/lib/apis/utils/constants.dart#L70) file, which is already exported for you to use directly from web3modal package.

### List of approved chains by the connected wallet

```dart
_w3mService.getApprovedChains();
```

### List of approved methods by connected wallet

```dart
_w3mService.getApprovedMethods();
```

### List of approved events by the connected wallet

```dart
_w3mService.getApprovedEvents();
```

### Interact with Smart Contracts

#### Read function:

```dart
Future<List<dynamic>> requestReadContract({
  required DeployedContract deployedContract,
  required String functionName,
  required String rpcUrl,
  EthereumAddress? sender,
  List<dynamic> parameters = const [],
});
```

#### Usage:

1. Create a DeployedContract object

```dart
// Create DeployedContract object using contract's ABI and address
final deployedContract = DeployedContract(
  ContractAbi.fromJson(
    jsonEncode([{.....}]), // ABI object
    'TokenName',
  ),
  EthereumAddress.fromHex('0xaddress.......'), // Contract address
);
```

2. Read from it by calling a read function

```dart
Future<void> getWalletBalance() async {
  // Get balance of wallet
  final result = await _w3mService.requestReadContract(
    deployedContract: deployedContract,
    functionName: 'balanceOf',
    rpcUrl: 'https://{rpc-url}.com',
    parameters: [
      EthereumAddress.fromHex('0xaddress....'), // Your address
    ],
  );
}

Future<void> getTotalSupply() async {
  // Get token total supply
  final result = await _w3mService.requestReadContract(
    deployedContract: deployedContract,
    functionName: 'totalSupply',
    rpcUrl: 'https://{rpc-url}.com',
  );
}
```

#### Write function:

```dart
Future<dynamic> requestWriteContract({
  required String topic,
  required String chainId,
  required String rpcUrl,
  required DeployedContract deployedContract,
  required String functionName,
  required Transaction transaction,
  String? method,
  List<dynamic> parameters = const [],
});
```

#### Usage:

1. Create a DeployedContract object (same as before)

```dart
// Create DeployedContract object using contract's ABI and address
final deployedContract = DeployedContract(
  ContractAbi.fromJson(
    jsonEncode([{.....}]), // ABI object
    'TokenName',
  ),
  EthereumAddress.fromHex('0xaddress.......'), // Contract address
);
```

2. Write to it by calling a write function

```dart
Future<void> transferToken() async {
  // Transfer 0.01 amount of Token using Smart Contract's transfer function
  final result = await _w3mService.requestWriteContract(
    topic: _w3mService.session.topic,
    chainId: 'eip155:1',
    rpcUrl: 'https://{rpc-url}.com',
    deployedContract: contract,
    functionName: 'transfer',
    transaction: Transaction(
      from: EthereumAddress.fromHex('0xaddressFrom....'),
      to: EthereumAddress.fromHex('0xaddressTo....'),
      value: EtherAmount.fromInt(EtherUnit.finney, 10), // == 0.010
    ),
  );
}

Future<void> writeMessage() async {
  // Write a message data
  final result = await _w3mService.requestWriteContract(
    topic: _w3mService.session.topic,
    chainId: 'eip155:1',
    rpcUrl: 'https://{rpc-url}.com',
    deployedContract: contract,
    functionName: 'sayHello',
    transaction: Transaction(
      from: EthereumAddress.fromHex('0xaddressFrom....'),
    ),
    parameters: ['Hello world!'],
  );
}
```

For a complete example app check out the [example app](https://github.com/WalletConnect/Web3ModalFlutter/blob/master/example/lib/utils/crypto/eip155.dart#L297) for Web3Modal
</file>

<file path="docs/appkit/flutter/core/custom-chains.mdx">
# Custom Chains

## Custom Chain addition and selection

You can add your own custom chain to the `W3MChainPresets.chains` object **before initialization**:

Like so...

```dart
W3MChainPresets.chains.putIfAbsent('<chainID>', () => <Your W3MChainInfo>);
await _w3mService.init();
```

:::info
If you modify the presets (add/remove chains), it will reflect in the `W3MNetworkSelectButton` widget.
:::

Or you can select your own chain by calling the `selectChain()` method from `W3MService` **after initialization**:.

```dart
await _w3mService.init();
_w3mService.selectChain(<Your W3MChainInfo>);
```

By using this option, your custom chain is not going to be added to the list of presets, so it's not going to show up in the `W3MNetworkSelectButton`. Use this method if you are not going to display `W3MNetworkSelectButton`.

:::note
The chain must be EVM compatible
:::

The list of chain presets can be found in [w3m_chains_presets.dart](https://github.com/WalletConnect/Web3ModalFlutter/blob/master/lib/utils/w3m_chains_presets.dart) which is already exported for you to use directly from web3modal package.
</file>

<file path="docs/appkit/flutter/core/events.mdx">
# Events

### List of events you can subscribe to in order to get connection updates

```dart
// A connection is settled
_w3mService.onModalConnect.subscribe((ModalConnect? event) {});
```

```dart
// Used when SIWEConfig is enabled will be called when SIWE login finishes
_w3mService.onModalUpdate.subscribe((ModalConnect? event) {});
```

```dart
// A connection is deleted (disconnected)
_w3mService.onModalDisconnect.subscribe((ModalDisconnect? event) {});
```

```dart
// An error occurs during connection
_w3mService.onModalError.subscribe((ModalError? event) {});
```

```dart
// User selectes a different network in the dapp
_w3mService.onModalNetworkChange.subscribe((ModalNetworkChange? event) {});
```

---

:::info note
These methods are only available when connecting through WalletConnect protocol.
Since Coinbase Wallet uses it own connection channel, these methods are not available when user connects with it.
:::

```dart
// A session expires
_w3mService.onSessionExpireEvent.subscribe((SessionExpire? event) {});
```

```dart
// A session data is updated
_w3mService.onSessionUpdateEvent.subscribe((SessionUpdate? event) {});
```

```dart
// A request event is happening
_w3mService.onSessionEventEvent.subscribe((SessionEvent? event) {});
```
</file>

<file path="docs/appkit/flutter/core/installation.mdx">
---
title: Installation
---

import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'
import YoutubeEmbed from '../../../components/YoutubeEmbed'

# Flutter

With Web3Modal Flutter, you can easily let people interact with multiple EVM compatible wallets and blockchains.

Let's get started with the installation and configuration!

## Installation

1.  - Add `web3modal_flutter` as dependency in your `/pubspec.yaml` and run `flutter pub get` (check out the [latest version](https://pub.dev/packages/web3modal_flutter/install))
    - Or simply run `flutter pub add web3modal_flutter`
2.  - Locate your `/ios/Podfile` file and add the following as the first line:

```ruby
platform :ios, '13.0'
```

3.  - Run `$ pod install` inside `/ios` folder.
4.  - You should now be able to run your app with `flutter run --dart-define=PROJECT_ID={your_project_id}`

### Enable Installed Wallet Detection

To enable Web3Modal to detect wallets installed on the device, you need to make specific changes to the native sides of the project.

<PlatformTabs
	groupId="w3m_flutter"
	activeOptions={["ios","android"]}
>
<PlatformTabItem value="ios">

1. Open your `Info.plist` file.
2. Locate the `<key>LSApplicationQueriesSchemes</key>` section.
3. Add the desired wallet schemes as string entries within the `<array>`. These schemes represent the wallets you want to detect.
4. Refer to our [Info.plist example file](https://github.com/WalletConnect/react-native-examples/blob/main/dapps/ModalUProvider/ios/ModalUProvider/Info.plist) for a detailed illustration.

Example:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>metamask</string>
  <string>trust</string>
  <string>safe</string>
  <string>rainbow</string>
  <!-- Add other wallet schemes names here -->
</array>
```

</PlatformTabItem>
<PlatformTabItem value="android">

1. Open your `AndroidManifest.xml` file.
2. Add your `<queries>...</queries>` schemes outside of `<application />` scope.
3. Refer to [Android Specs](https://developer.android.com/guide/topics/manifest/queries-element) for more information.

Example:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <queries>
        <package android:name="io.metamask"/>
        <package android:name="com.wallet.crypto.trustapp"/>
        <package android:name="io.gnosis.safe"/>
        <package android:name="me.rainbow"/>
        <!-- Add other wallet schemes names here -->
    </queries>

    <application>
        ...
    </application>
</manifest>
```

</PlatformTabItem>
</PlatformTabs>

### Enable Coinbase Wallet

:::info VERSION DEPENDENCY

Coinbase Wallet is available from **web3modal_flutter: ^3.1.0** and higher.

:::

Since Coinbase Wallet uses its own SDK, there are a few extra but simply steps to do if you are planning to include and support it.


<PlatformTabs
	groupId="w3m_flutter"
	activeOptions={["ios","android"]}
>
<PlatformTabItem value="ios">

1. Open your `Info.plist` file.
2. Locate the `<key>LSApplicationQueriesSchemes</key>` section.
3. Include `<string>cbwallet</string>` scheme as mentioned above in previous section

Example:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>cbwallet</string>
  <!-- Any other scheme previously added -->
</array>
```

4. Make sure pods are installed, otherwise run `pod install` inside your `/ios` folder.
5. Open your `/ios/Runner.xcworkspace` file with Xcode and add the following code in `AppDelegate.swift` file:

```swift
import CoinbaseWalletSDK
```

```swift
override func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    if #available(iOS 13.0, *) {
      if (CoinbaseWalletSDK.isConfigured == true) {
        if (try? CoinbaseWalletSDK.shared.handleResponse(url)) == true {
            return true
        }
      }
    }

    return super.application(app, open: url, options: options)
}

override func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
    if #available(iOS 13.0, *) {
      if (CoinbaseWalletSDK.isConfigured == true) {
        if let url = userActivity.webpageURL,
            (try? CoinbaseWalletSDK.shared.handleResponse(url)) == true {
            return true
        }
      }
    }

    return super.application(application, continue: userActivity, restorationHandler: restorationHandler)
}
```

Checkout out the [AppDelegate.swift](https://github.com/WalletConnect/Web3ModalFlutter/blob/master/example/ios/Runner/AppDelegate.swift) file from our sample dapp for reference.

</PlatformTabItem>
<PlatformTabItem value="android">

1. Open your `AndroidManifest.xml` file.
2. Add `<package android:name="org.toshi"/>` scheme inside `<queries>...</queries>` as mentioned above in previous section

Example:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <queries>
        <package android:name="org.toshi"/>
        <!-- Any other scheme previously added -->
    </queries>

    <application>
        ...
    </application>
</manifest>
```

</PlatformTabItem>
</PlatformTabs>

### Disable Coinbase Wallet

Coinbase Wallet is enabled by default even if, in order to function properly, a few steps has to be done as described in the previous section. However, if you don't want to include/support Coinbase Wallet on your app you just need to pass Coinbase Wallet id `fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa` to [excludedWalletIds](./options#excludedwalletids) options Array.
</file>

<file path="docs/appkit/flutter/core/options.mdx">
# Options

```dart
final _w3mService = W3MService(
  projectId: '{YOUR_PROJECT_ID}',
  metadata: const PairingMetadata(
    name: 'Web3Modal Flutter Example',
    description: 'Web3Modal Flutter Example',
    url: 'https://www.walletconnect.com/',
    icons: ['https://walletconnect.com/walletconnect-logo.png'],
    redirect: Redirect(
      native: 'flutterdapp://',
      universal: 'https://www.walletconnect.com',
    ),
  ),
  // enableAnalytics: true, // OPTIONAL - null by default
  // enableEmail: true, // OPTIONAL - false by default
  // requiredNamespaces: {}, OPTIONAL
  // optionalNamespaces: {}, OPTIONAL
  // featuredWalletIds: {}, OPTIONAL
  // includedWalletIds: {}, OPTIONAL
  // excludedWalletIds: {}, OPTIONAL
);
```

## enableAnalytics

Enable analytics to get more insights on your users activity within your [WalletConnect Cloud's dashboard](https://cloud.walletconnect.com)

## enableEmail

Used to enable/disable [Email Wallets](../onboarding//email.mdx) feature.

## requiredNamespaces and optionalNamespaces

These values are optionals and, in most cases, not required since Web3Modal already defines every required and optional namespace internally. However, if you would want to override that definition with your own, these are the object yout should use.

These are the set of namespaces that will be requested from the wallet you are connecting to.

## featuredWalletIds

Allows to override default recommended wallets that are fetched from the API. You can define an array of wallet ids you'd like to prioritize (order is respected). You can get these ids from the [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet) by clicking on the copy icon of desired wallet card.

- Defaults to `null`, Wallets are ordered as they are got

```dart
final Set<String> featuredWalletIds = {
  'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96', // MetaMask
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0', // Trust
  'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa', // Coinbase Wallet
}
```

## includedWalletIds

Similar to `featuredWalletIds` this option allows you to determine exactly which wallets do you want to show. If `includedWalletIds` is set then only the wallets listed in this object are going to be displayed in the modal.

- Defaults to `null`, every wallet in our explorer service is included

```dart
final Set<String> includedWalletIds = {
  'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96', // MetaMask
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0', // Trust
  'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa', // Coinbase Wallet
}
```

## excludedWalletIds

Similar to `includedWalletIds` this option allows you to exclude a list of wallets from the API response.

- Defaults to `null`, no wallet is excluded

```dart
final Set<String> excludedWalletIds = {
  'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96', // MetaMask
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0', // Trust
  'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa', // Coinbase Wallet
}
```
</file>

<file path="docs/appkit/flutter/core/siwe.mdx">
---
title: One-Click Auth / SIWE
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Button from '../../../components/button'

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a new form of authentication that enables users to control their digital identity with their Ethereum account.
SIWE is a standard also known as [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in Web3Modal by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as ["ReCaps"](https://eips.ethereum.org/EIPS/eip-5573). ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary.
WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## Pre-requisites
In order for SIWE to work, you need to have a backend to communicate with. This backend will be used to generate a nonce, verify messages and handle sessions.
More info [here](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-backend)

:::info
This feature is supported from `web3modal_flutter: ^3.3.0`
:::

## Configure your SIWEConfig object

```dart
final _siweConfig = SIWEConfig(
  getNonce: () async {
    // The getNonce method functions as a safeguard
    // against spoofing, akin to a CSRF token.

    return await yourApi.getNonce();
  },
  getMessageParams: () async {
    // Parameters to create the SIWE message internally.
    // More info in https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-222.method

    return SIWEMessageArgs(
      domain: 'yourdomain.com',
      uri: 'https://yourdomain.com/login',
      statement: 'Please sign with your account',
      methods: ['personal_sign', 'eth_sendTransaction'],
    );
  },
  createMessage: (SIWECreateMessageArgs args) {
    // Method for generating an EIP-4361-compatible message.
    // You can use our provided formatMessage() method or implement your own

    return AuthSignature.formatMessage(args);
  },
  verifyMessage: (SIWEVerifyMessageArgs args) async {
    // This function ensures the message is valid,
    // has not been tampered with, and has been appropriately
    // signed by the wallet address.

    try {
      final isValidMessage = await yourApi.verifyMessage(args.toJson());
      return isValidMessage;
    } catch (error) {
      // error validating message
      return false;
    }
  },
  getSession: () async {
    // Called after verifyMessage() succeeds
    // The backend session should store the associated address and chainId
    // and return it via the `getSession` method.

    try {
      final session = await yourApi.getSession();
      return SIWESession(address: session.address, chains: [session.chainId]);
    } catch (error) {
      // error getting session
      rethrow;
    }
  },
  onSignIn: (SIWESession session) {
    // Called after getSession() succeeds
  },
  signOut: () async {
    // Called when wallet disconnects if `signOutOnDisconnect == true` and/or when
    // `signOutOnAccountChange == true` and/or 
    // `signOutOnNetworkChange == true`
    try {
      final success = await yourApi.signOut();
      return success;
    } catch (error) {
      // error signing out
      return false;
    }
  },
  onSignOut: () {
    // Called after signOut() succeeds
  },
  // enabled: true, // OPTIONAL. Enables One-Click Auth + SIWE logic, if `false`, regular session proposal will be used. (default `true`)
  // signOutOnDisconnect: true, // OPTIONAL (default `true`)
  // signOutOnAccountChange: true, // OPTIONAL (default `true`)
  // signOutOnNetworkChange: true, // OPTIONAL (default `true`)
);
```

## Initialize Web3Modal with your `siweConfig`
Add the siwe configuration in `W3MService` initialization

:::info note
If `siweConfig:` is used then `W3MService` object will require a `BuildContext context` parameter to be passed.
:::

```dart
final _w3mService = W3MService(
  context: context,
  projectId: '{YOUR_PROJECT_ID}',
  metadata: const PairingMetadata(
    ...
  ),
  siweConfig: _siweConfig, // not setting `siweConfig` hast the same effect as setting `false` on `siweConfig.enable`
);
```

### SIWEConfig reference

```dart
class SIWEConfig {
  final Future<String> Function() getNonce;
  final Future<SIWEMessageArgs> Function() getMessageParams;
  final String Function(SIWECreateMessageArgs args) createMessage;
  final Future<bool> Function(SIWEVerifyMessageArgs args) verifyMessage;
  final Future<SIWESession?> Function() getSession;
  final Future<bool> Function() signOut;
  // Callback when user signs in
  final Function(SIWESession session)? onSignIn;
  // Callback when user signs out
  final VoidCallback? onSignOut;
  // Defaults to true
  final bool enabled;
  // In milliseconds, defaults to 5 minutes
  final int nonceRefetchIntervalMs;
  // In milliseconds, defaults to 5 minutes
  final int sessionRefetchIntervalMs;
  // Defaults to true
  final bool signOutOnDisconnect;
  // Defaults to true
  final bool signOutOnAccountChange;
  // Defaults to true
  final bool signOutOnNetworkChange;
  //

  SIWEConfig({
    required this.getNonce,
    required this.getMessageParams,
    required this.createMessage,
    required this.verifyMessage,
    required this.getSession,
    required this.signOut,
    this.onSignIn,
    this.onSignOut,
    this.enabled = true,
    this.signOutOnDisconnect = true,
    this.signOutOnAccountChange = true,
    this.signOutOnNetworkChange = true,
    this.nonceRefetchIntervalMs = 300000,
    this.sessionRefetchIntervalMs = 300000,
  });
}

```

## Exported functions

### `generateNonce`

Simple method to generate a timestamp-based nonce

```dart
AuthSignature.generateNonce();
```

### `formatMessage`

Creates [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361#informal-message-template) message based on input arguments.

```dart
AuthSignature.formatMessage(args);
```

### `verifySignature`

Verify a SIWE signature. Internally it calls your backend verification method.

```dart
await AuthSignature.verifySignature(
  address,
  message,
  signature,
  chainId,
  projectId,
);
```

### `getChainIdFromMessage`

Get the chain ID from the SIWE message.

```dart
AuthSignature.getChainIdFromMessage(message);
```

### `getAddressFromMessage`

Get the address from the SIWE message.

```dart
AuthSignature.getAddressFromMessage(message);
```
</file>

<file path="docs/appkit/flutter/core/theming.mdx">
# Theming

To theme the `Web3Modal` you must wrap your `MaterialApp` with a `Web3ModalTheme` widget.

```dart
return Web3ModalTheme(
  child: MaterialApp(
    ...
  ),
);
```

### Default themes

**Web3ModalTheme** already comes with 2 default themes.<br />
A light option: `Web3ModalColors.lightMode`<br />
A dark option: `Web3ModalColors.darkMode`.<br />
You can switch between them by toggling the `isDarkMode:` parameter in `Web3ModalTheme` like so:

```dart
return Web3ModalTheme(
  isDarkMode: _isDarkMode,
  child: MaterialApp(
    ...
  ),
);
```

### Custom themes

You can define your own light and dark themes by tweaking `Web3ModalThemeData` parameters. For instance, if you want to change the main foreground and background color you could do:

```dart
final _themeData = Web3ModalThemeData(
  lightColors: Web3ModalColors.lightMode.copyWith(
    accent100: Colors.red,
    background125: Colors.yellow.shade300,
  ),
  darkColors: Web3ModalColors.darkMode.copyWith(
    accent100: Colors.green,
    background125: Colors.brown,
  ),
);
```

and pass this object to `Web3ModalTheme`'s `themeData:` parameter:

```dart
return Web3ModalTheme(
  isDarkMode: _isDarkMode,
  themeData: _themeData,
  child: MaterialApp(
    ...
  ),
);
```

### Preset theme shortcuts

`Web3ModalTheme` comes with default border radiuses but you can override these values by passing your own values to `Web3ModalRadiuses()` object and then adding this object to `Web3ModalThemeData`'s `radiuses:` parameter.

But you can also set **no corner radiuses** at all by setting this value to `Web3ModalRadiuses.square` or **everything circular** by using `Web3ModalRadiuses.circular`

```dart
final _themeData = Web3ModalThemeData(
  lightColors: Web3ModalColors.lightMode.copyWith(
    accent100: Colors.red,
    background125: Colors.yellow.shade300,
  ),
  darkColors: Web3ModalColors.darkMode.copyWith(
    accent100: Colors.green,
    background125: Colors.brown,
  ),
  // No corner radius, modal will look square, use Web3ModalRadiuses.circular to make everything circular
  radiuses: Web3ModalRadiuses.square,
);
```

:::info
If you don't wrap your `MaterialApp` with a `Web3ModalTheme` widget, the `Web3Modal` will use the default light theme.
:::

`Web3ModalTheme` is an InheritedWidget so it comes with a few handy methods for you to use:

Check if the current time is dark:

```dart
final isDarkMode = Web3ModalTheme.of(context).isDarkMode;
final isMaybeDarkMode = Web3ModalTheme.maybeOf(context)?.isDarkMode;
```

Get current `Web3ModalThemeData` object:

```dart
final data = Web3ModalTheme.getDataOf(context);
```

Get current `Web3ModalColors` object:

```dart
final colors = Web3ModalTheme.colorsOf(context);
```

You can build your own theme by creating a `Web3ModalThemeData` object. _(More and easier customization options will come in the future)_
</file>

<file path="docs/appkit/flutter/core/usage.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

import CloudBanner from '../../../components/CloudBanner'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Usage

## Import the package:

```dart
import 'package:web3modal_flutter/web3modal_flutter.dart';
```

Create your `W3MService` which is your primary class for opening, closing, disconnecting, etc.

Be sure to update the **project ID** and metadata with your own.

<CloudBanner />

## W3MService initialization

In order to initialize a W3MService instance you must provide a **projectId** and a **metadata**.

```dart
final _w3mService = W3MService(
  projectId: '{YOUR_PROJECT_ID}',
  metadata: const PairingMetadata(
    name: 'Web3Modal Flutter Example',
    description: 'Web3Modal Flutter Example',
    url: 'https://www.walletconnect.com/',
    icons: ['https://walletconnect.com/walletconnect-logo.png'],
    redirect: Redirect(
      native: 'flutterdapp://',
      universal: 'https://www.walletconnect.com',
    ),
  ),
);

// Register here the event callbacks on the service you'd like to use. See `Events` section.

await _w3mServices.init();
```

The `metadata` object should contain your dApp's name, description, url and icon. Redirect object is optional but **highly recommended**. See next session why.

## Redirect to your dApp

The service's metadata object contains a `redirect` option that serves to the purpose of redirecting back to your dapp from the connected wallet.

```dart
redirect: Redirect(
  native: 'flutterdapp://', // your own custom scheme for deep linking
  universal: 'https://www.walletconnect.com', // your own universal link for deep linking
),
```

But in order for the redirect mechanism to work you would also need to add the following in the iOS and Android native sides:

<PlatformTabs
	groupId="w3m_flutter"
	activeOptions={["ios","android"]}
>
<PlatformTabItem value="ios">

1. Locate your `Info.plist` file under `your_project/ios/Runner/` folder.
2. Locate the `<key>CFBundleURLTypes</key>` section.
3. Add your schema as `<dict>` entry within the `<array>` object as follows.

```xml
<key>CFBundleURLTypes</key>
<array>
  <dict>
    <key>CFBundleTypeRole</key>
    <string>Editor</string>
    <key>CFBundleURLName</key>
    <string>com.example.yourBundleId</string> <!-- Bundle ID of your app -->
    <key>CFBundleURLSchemes</key>
    <array>
      <!-- your own custom scheme. Be mind of removing :// for this step -->
      <string>flutterdapp</string>
    </array>
  </dict>
</array>
```

</PlatformTabItem>
<PlatformTabItem value="android">

1. Locate your `AndroidManifest.xml` file under `your_project/android/app/src/main/` fodler.
2. Locate the `<Activity .MainActivity` inside `<application />` scope.
3. Add the following intent

```xml
<intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <!-- your own custom scheme. Be mind of removing :// for this step -->
    <data android:scheme="flutterdapp" />
</intent-filter>
```

</PlatformTabItem>
</PlatformTabs>

## Connection Buttons

You can use the `W3MConnectWalletButton`, which will open the Web3Modal with no prior network selected

```dart
W3MConnectWalletButton(service: _w3mService)
```

Or you can use `W3MNetworkSelectButton` which will first show a network selection prompt:

```dart
W3MNetworkSelectButton(service: _w3mService)
```

Once session is approved you can use `W3MAccountButton` widget to show basic account data and to open Account data modal:

```dart
W3MAccountButton(service: _w3mService)
```

## Network selection or direct wallet connection

You can choose either to enable **Connect Wallet** button only after selecting a network (default behaviour) or to not display a **Select Network** button and directly navigate users to connect a wallet.

If you decide to take first approach of showing a `W3MNetworkSelectButton` **and** `W3MConnectWalletButton` (which is enabled only after selecting a Network) you simple have to add these two buttons on your code:

For instance:

```dart
Column(
  mainAxisAlignment: MainAxisAlignment.center,
  children: [
    W3MNetworkSelectButton(service: _w3mService),
    W3MConnectWalletButton(service: _w3mService),
  ],
),
```

and `W3MConnectWalletButton` will handle it's state automatically.

But, as mentioned before, you can decide to just show the **Connect Wallet** button alone, in this case you would need to set it's state to `ConnectButtonState.none` like so:

```dart
W3MConnectWalletButton(
  service: _w3mService,
  state: ConnectButtonState.none,
),
```

this way `W3MConnectWalletButton` will be always enabled.
</file>

<file path="docs/appkit/flutter/onboarding/email.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Email Wallets

AppKit enables passwordless Web3 onboarding and authentication, allowing your users interact with your application by creating a non-custodial wallet with just their emails.


:::info VERSION DEPENDENCY
Email Wallet is available from **web3modal_flutter: ^3.2.0** and higher.
:::

## Integration

In order to support Email Wallets creation just set `enableEmail` parameter to `true` in `W3MService` initialization.

```dart
final _w3mService = W3MService(
  projectId: '{YOUR_PROJECT_ID}',
  metadata: const PairingMetadata(
    ...
  ),
  enableEmail: true, // OPTIONAL - false by default
);
```

:::note

Remember to whitelist your dapp's iOS's bundleId and Android's packageName in your cloud configuration.

1. LogIn into https://cloud.walletconnect.com
2. Open Dashboard and scroll down to **Mobile Application IDs** menu
3. Add your iOS Bundle ID and your Android Package Name

:::

## User Flow

1. Users will be able to connect to you application by simply using an email address. AppKit will send to them a One Time Password (OTP) to copy and paste in the modal, which will help to verify the user's authenticity. This will create a non-custodial wallet for your user which will be available in any application that integrates AppKit and Email Wallets.

2. Eventually the user can optionally choose to move from a non-custodial wallet to a self-custodial one by pressing "Upgrade Wallet" on AppKit. This will open the (WalletConnect secure website) that will walk your user through the upgrading process.

:::info Note

Due to Safari‚Äôs strict third-party cookie policies, the SDK is not preserving sessions after the app is terminated (removed from memory). So upon app termination the user will have to re-authenticate themself through a new OTP code if they want to sign. Our team is working to solve this issue soon.

:::
</file>

<file path="docs/appkit/ios/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/ios/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/ios/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/ios/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/ios/core/actions.mdx">
# Actions

## Chains

### Chain selection

You can select your own chain by calling the `selectChain(_ chain: Chain)` static method on the `Web3Modal` object.

### Get selected chain

You can get selected chain by calling the `getSelectedChain()` static method on the `Web3Modal` object.

## Sign Actions

### Create pairing

```swift
let uri: WalletConnectURI = try await Web3Modal.instance.createPairing()
```

### Connect

```swift
try await Web3Modal.instance.connect(
    requiredNamespaces: [String: ProposalNamespace],
    optionalNamespaces: [String: ProposalNamespace]?,
    sessionProperties: [String: String]?,
    topic: topic // Can be existing topic or nil to create new one
)

// Or without specifying namespaces to stick with default values

try await Web3Modal.instance.connect(
    topic: topic // Can be existing topic or nil to create new one
)
```

More about optional and required namespaces can be found [here](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md)

### Disconnect

```swift
try await Web3Modal.instance.disconnect(topic: topic)
```

### Request

```swift
try await Web3Modal.instance.request(
    params: .init(
        topic: session.topic,
        method: "some_method",
        params: AnyCodable(payload),
        chainId: Blockchain
    )
)
```

### Get List of Active Sessions

```swift
Web3Modal.instance.getSessions()
```

To get a list of active sessions, call `Web3Modal.instance.getSessions()` which will return `[Session]`.

### launch connected wallet

```swift
Web3Modal.instance.launchCurrentWallet()
```

To open a wallet that your dapp is connected to

### handle deep links

```swift
Web3Modal.instance.handleDeeplink(url)
```

### Cleanup

```swift
Web3Modal.instance.cleanup(topic)
```

Delete all stored data such as: pairings, sessions, keys
</file>

<file path="docs/appkit/ios/core/custom-chains.mdx">
# Custom Chains

## Custom Chain Selection

You can add your own chain to extend default set of chain presets by calling the `addChainPreset(_ chain: Chain)` static method on the `Web3Modal` object.

:::info
If you modify the presets, it will be reflected in the `Web3ModalNetworkButton` button and Network selection screens.
:::

:::note
The chain must be EVM compatible
:::
</file>

<file path="docs/appkit/ios/core/installation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Installation

<Tabs>
<TabItem value="spm" label="SPM">

### SwiftPackageManager

You can add AppKit to your project with Swift Package Manager. In order to do that:

1. Open Xcode
2. Go to File -> Add Packages
3. Paste the repo GitHub url: https://github.com/WalletConnect/web3modal-swift
4. Tap Add Package
5. Choose the Web3Modal products that you want installed in your app.

### Alternatively, add Web3Modal to a `Package.swift` manifest

To integrate via a `Package.swift` manifest instead of Xcode, you can add
Web3Modal to the dependencies array of your package:

```swift
dependencies: [
  .package(
    name: "Web3Modal",
    url: "https://github.com/WalletConnectV2/web3modal-swift.git",
    .upToNextMajor(from: "1.0.13")
  ),

  // Any other dependencies you have...
],
```

Then, in any target that depends on a Web3Modal product, add it to the `dependencies`
array of that target:

```swift
.target(
  name: "MyTargetName",
  dependencies: [
    // The product(s) you want (most likely Web3Modal).
    .product(name: "Web3Modal", package: "Web3Modal"),
  ]
),
```

</TabItem>
<TabItem value="cocoapods" label="Cocoapods">

1. Update Cocoapods spec repos. Type in terminal `pod repo update`
2. Initialize Podfile if needed with `pod init`
3. Add pod to your Podfile like this:

```ruby
pod 'Web3Modal', '~> 1.0'
```

4. Install pods with `pod install`
   If you encounter any problems during package installation, you can specify the exact path to the repository

```ruby
pod 'Web3Modal', :git => 'https://github.com/WalletConnect/web3modal-swift.git', :tag => '1.0.13'
```

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/ios/core/one-click-auth.mdx">
---
title: One-Click Auth / SIWE
---

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a form of authentication that enables users to control their digital identity with their Ethereum account. SIWE is a standard also known as¬†EIP-4361.

### One-Click Auth

One-Click Auth¬†represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.
Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as¬†"ReCaps". ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary. WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.


### Configure your AppKit Client

To integrate SIWE with AppKit, you need to configure your Web3Modal client using `AuthRequestParams`, which are required to create a SIWE message for the user to sign:

```swift
Web3Modal.configure(
    ...
    authRequestParams: authRequestParams,
    ...
)

#### Example of AuthRequestParams

```swift
extension AuthRequestParams {
    static func stub(
        domain: String = "yourDappDomain.com",
        chains: [String] = ["eip155:1", "eip155:137"],
        nonce: String = "uniqueNonce",
        uri: String = "https://yourDappDomain.com/login",
        statement: String? = "I accept the Terms of Service: https://yourDappDomain.com/tos",
        resources: [String]? = nil, // Here your dapp may request authorization with ReCaps
        methods: [String]? = ["personal_sign", "eth_sendTransaction"]
    ) -> AuthRequestParams {
        return try! AuthRequestParams(
            domain: domain,
            chains: chains,
            nonce: nonce,
            uri: uri,
            statement: statement,
            resources: resources,
            methods: methods
        )
    }
}
```

Configuring your Web3Modal client with AuthRequestParams will prioritize authentication requests over regular session proposals. If the wallet supports One-Click Auth, the session will be created and the user will automatically authenticate without needing to send another SIWE request over personal_sign. If the wallet does not support One-Click Auth, it will fall back to the session proposal. In this case, to authenticate the user, you can send another session request to prove address ownership.

To check whether the user has signed a SIWE message, subscribe to authResponsePublisher:

```swift
Web3Modal.instance.authResponsePublisher.sink { (id, result) in
    switch result {
    case .success((session, cacaos)):
        // User has authenticated
        ...
    }
}
```

### Link Mode

The latest release of AppKit supports link mode, a low latency mechanism for transporting 1-click auth requests and session requests over universal links, eliminating the need for a WebSocket connection with the Relay. This significantly enhances the user experience when connecting native dApps to native wallets by reducing the latency associated with networking connections, especially when the user has an unstable internet connection.

To support link mode, configure your AppMetadata.Redirect with a valid universal link and set the linkMode property to true:


```swift
let metadata = AppMetadata(
    ...
    redirect: try! AppMetadata.Redirect(native: "exampleApp://", universal: "https://example.com/example_dapp", linkMode: true)
)

Web3Modal.configure(
    ...
    metadata: metadata,
    ...
)
```

For more information on how to configure universal links for your app, refer to the [Apple Documentation](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc).

For a debugging guide, visit the [Debugging Universal Links](https://developer.apple.com/documentation/technotes/tn3155-debugging-universal-links) page.


Once link mode is configured, your dApp will connect and send requests to wallets via universal links after receiving proof from the wallet that it also supports link mode.

The wallet will also send responses using universal links. Your app needs to pass these responses to the Web3Modal client so it can process them.

```swift
Web3Modal.instance.handleDeeplink(url)
```
</file>

<file path="docs/appkit/ios/core/options.mdx">
# Options

### Explorer recommended wallets

Allows to set default recommended wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define a list of wallets ids you'd like to prioritize (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```swift
Web3Modal.configure(
    ...
    recommendedWalletIds: [String]
    ...
)
```

### Explorer excluded wallets

Allows to exclude wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```swift
Web3Modal.configure(
    ...
    excludedWalletIds: [String]
    ...
)
```

### Add custom wallets

If you want to list wallet that is not included in the explorer, you can configure the client as follows:

```swift
Web3Modal.configure(
    ...
    customWallets: [
                .init(
                    id: "swift-sample",
                    name: "Swift Sample Wallet",
                    homepage: "https://walletconnect.com/",
                    imageUrl: "https://avatars.githubusercontent.com/u/37784886?s=200&v=4",
                    order: 1,
                    mobileLink: "walletapp://",
                    linkMode: "https://lab.web3modal.com/wallet"
                )
            ]
    ...
)
```

### Enable Installed Wallet Detection

To enable Web3Modal to detect wallets installed on the device, you need to make specific changes your project Info.plist.

#### For iOS:

1. Open your `Info.plist` file.
2. Locate the `<key>LSApplicationQueriesSchemes</key>` section.
3. Add the desired wallet schemes as string entries within the `<array>`. These schemes represent the wallets you want to detect.
4. Refer to our [Info.plist example file](https://github.com/WalletConnect/react-native-examples/blob/main/dapps/ModalUProvider/ios/ModalUProvider/Info.plist) for a detailed illustration.

Example:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>metamask</string>
  <string>trust</string>
  <string>safe</string>
  <string>rainbow</string>
  <string>uniswap</string>
  <!-- Add other wallet schemes names here -->
</array>
```

### Enable Coinbase Wallet

:::info
Coinbase Wallet is available from Web3Modal **version 1.1.0** and higher
:::

Since Coinbase Wallet uses its own SDK there are a few simply steps to do if you are planning to include and support it

1. Open your `Info.plist` file.
2. Locate the `<key>LSApplicationQueriesSchemes</key>` section.
3. Include `<string>cbwallet</string>` scheme as mentioned above in previous section

Example:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>cbwallet</string>
  <!-- Any other scheme previously added -->
</array>
```

Then you need to add the following code to your `AppDelegate.swift` file

```swift
import CoinbaseWalletSDK

override func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    Web3Modal.instance.handleDeeplink(url)
}
```

or for SwiftUI attach `onOpenURL` modifier somewhere in your view hieararchy like shown below.

```swift
WindowGroup {
  YourView()
      .onOpenURL { url in
          Web3Modal.instance.handleDeeplink(url)
      }
}

```

:::note
If you don't want to include/support Coinbase Wallet you just need to set `coinbaseEnabled` to `false` in your Web3Modal configure call.
:::
</file>

<file path="docs/appkit/ios/core/usage.mdx">
import CloudBanner from '../../../components/CloudBanner'

# Usage

### Configure Networking and Pair clients

Make sure that you properly configure Networking and Pair Clients first.

- [Networking](../../../api/core/relay.mdx)

### Initialize Web3Modal Client

In order to initialize a client just call a `configure` method from the Web3Modal instance wrapper

```swift
let metadata = AppMetadata(
    name: "Example Wallet",
    description: "Wallet description",
    url: "example.wallet",
    icons: ["https://avatars.githubusercontent.com/u/37784886"],
    // Used for the Verify: to opt-out verification ignore this parameter
    verifyUrl: "verify.walletconnect.com"
)

Web3Modal.configure(
    projectId: PROJECT_ID,
    metadata: metadata
)
```

<CloudBanner />

This example will default to using following namespaces.

```swift
let methods: Set<String> = ["eth_sendTransaction", "personal_sign", "eth_signTypedData"]
let events: Set<String> = ["chainChanged", "accountsChanged"]
let blockchains: Set<Blockchain> = [Blockchain("eip155:1")!]
let namespaces: [String: ProposalNamespace] = [
    "eip155": ProposalNamespace(
        chains: blockchains,
        methods: methods,
        events: events
    )
]

let defaultSessionParams =  SessionParams(
                                requiredNamespaces: namespaces,
                                optionalNamespaces: nil,
                                sessionProperties: nil
                            )
```

If you want to change that you can call configure and define your own session parameters like this.

```swift
let metadata = AppMetadata(...)

let sessionParams = SessionParams(...)

Web3Modal.configure(
    projectId: PROJECT_ID,
    metadata: metadata,
    sessionParams: sessionParams
)
```

or you can change them later by calling `Web3Modal.set(sessionParams: SessionParams(...))`

### Provided UI components

Now you can use the `Web3ModalButton` or `Web3ModalNetworkButton` components. These two components reflect the state of the Web3Modal client,
including the session state, account address and balance, currently selected network, and will automatically update when the state changes.
More can be found in https://github.com/WalletConnect/web3modal-swift/blob/develop/Sample/Example/ContentView.swift as part of the Sample app.

### Custom UI

If you want to use custom UI you can present the modal by simply calling.

```swift
Web3Modal.present()
```

It will traverse the view hierarchy and try to present from top most controller. This is meant more towards SwiftUI.

Otherwise you can specify the viewController to present from.

```swift
Web3Modal.present(from: viewController)
```

### Subscribe for Web3Modal Publishers

The following publishers are available to subscribe:

```swift
public var sessionPublisher: AnyPublisher<[Session], Never>
public var sessionSettlePublisher: AnyPublisher<Session, Never>
public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never>
public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
public var sessionResponsePublisher: AnyPublisher<Response, Never>
public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
public var authResponsePublisher: AnyPublisher<(id: RPCID, result: Result<(Session?, [Cacao]), AuthError>), Never> 
```

### Sign methods

Web3Modal is internally using Sign SDK and most of its method are being exposed through Web3Modal interface.

### Where to go from here

Check the Web3Modal usage in our Sample app that is part of Web3Modal repository.
</file>

<file path="docs/appkit/javascript/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/javascript/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/javascript/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/javascript/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/javascript/core/actions.mdx">
import Table from '../../../components/Table'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiActions from '../wagmi/actions.mdx'
import EthersActions from '../ethers/actions.mdx'
import SolanaActions from '../solana/actions.mdx'

# Actions

Actions are functions that will help you control the modal, subscribe to wallet events and interact with them and smart contracts.

## Open and close the modal

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

modal.open()

modal.close()
```

You can also select the modal's view when calling the `open` function

```ts
modal.open({ view: 'Account' })
```

List of views you can select

<Table
  headers={['Variable', 'Description']}
  data={[
    {
      variable: { code: 'Connect' },
      description: 'Principal view of the modal - default view when disconnected'
    },
    {
      variable: { code: 'Account' },
      description: 'User profile - default view when connected'
    },
    {
      variable: { code: 'AllWallets' },
      description: 'Shows the list of all available wallets'
    },
    {
      variable: { code: 'Networks' },
      description:
        'List of available networks - you can select and target a specific network before connecting'
    },
    {
      variable: { code: 'WhatIsANetwork' },
      description: '"What is a network" onboarding view'
    },
    {
      variable: { code: 'WhatIsAWallet' },
      description: '"What is a wallet" onboarding view'
    },
    {
      variable: { code: 'OnRampProviders' },
      description: '"On-Ramp main view'
    }
  ]}
/>

## Disconnect

```ts
modal.disconnect()
```

## WalletInfo

Metadata information from the connected wallet

```ts
function handler({ name, icon }) {
  console.log(name, icon)
}

modal.subscribeWalletInfo(handler)

//or

const { name, icon } = modal.getWalletInfo()
```

## Ethereum Library

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers"]}>
<PlatformTabItem value="wagmi">

<WagmiActions />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersActions />

</PlatformTabItem>
</PlatformTabs>

## Modal State

Get the current value of the modal's state

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

const { open, selectedNetworkId } = modal.getState()
```

The modal state is an object of two properties:

<Table
  headers={['Property', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'open' },
      description: 'Open state will be true when the modal is open and false when closed.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'selectedNetworkId' },
      description: 'The current chain id selected by the user',
      type: { code: 'number' }
    }
  ]}
/>

You can also subscribe to the modal's state changes.

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

modal.subscribeState(newState => console.log(newState))
```

## ThemeMode

Set the `themeMode` after creating the modal

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

modal.setThemeMode('dark')
```

Get the current `themeMode` value by calling the `getThemeMode` function

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

const themeMode = modal.getThemeMode()
```

## themeVariables

Set the `themeVariables` after creating the modal

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

modal.setThemeVariables({ ... })
```

Get the current `themeVariables` value by calling the `getThemeVariables` function

```ts
const modal = createWeb3Modal({ wagmiConfig, projectId })

const themeMode = modal.getThemeVariables()
```

## Subscribe to theme changes

```ts
const unsubscribe = modal.subscribeTheme(newTheme => console.log(newTheme))
```

## Track modal events

```ts
modal.getEvent() // get last event
modal.subscribeEvents(event => console.log(event)) // subscribe to events
```
</file>

<file path="docs/appkit/javascript/core/components.mdx">
---
title: Components
---

import Components from '../../shared/components.mdx'

# Web Components

<Components />
</file>

<file path="docs/appkit/javascript/core/custom-connectors.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Custom connectors

Add custom connectors for Ethers or Wagmi

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "solana"]}>
<PlatformTabItem value="wagmi">

If you already have Wagmi integrated into your application or would like more control over Wagmi's configuration, you can integrate AppKit on top of it.

```ts
import { createWeb3Modal } from '@web3modal/wagmi'

import { reconnect, http, createConfig } from '@wagmi/core'
import { sepolia } from '@wagmi/core/chains'
import { walletConnect } from '@wagmi/connectors'

const projectId = 'YOUR_PROJECT_ID'

const metadata = {
  //...
}

const config = createConfig({
  chains: [sepolia],
  transports: {
    [sepolia.id]: http()
  },
  connectors: [
    walletConnect({ projectId, metadata, showQrModal: false }), // showQrModal must be false.
    //other connectors...
  ]
})
reconnect(config)

const modal = createWeb3Modal({
  //...
  wagmiConfig: config,
})
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

Coming soon...

</PlatformTabItem>
<PlatformTabItem value="solana">
Add custom wallet adapters for Solana wallets by first installing the wallet adapter package and then including the adapters in the wallets array. You can find a more Solana wallet adapters [here](https://github.com/anza-xyz/wallet-adapter/tree/master/packages/wallets). 

```bash npm2yarn
npm install @solana/wallet-adapter-solflare
```

```ts
import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  //...
}

const solanaConfig = defaultSolanaConfig({
  chains,
  projectId,
  metadata
})

// 3. Create modal
const modal = createWeb3Modal({
  solanaConfig,
  projectId: projectId,
  metadata: metadata,
  chains,
  enableAnalytics: true,
  termsConditionsUrl: 'https://walletconnect.com/terms',
  privacyPolicyUrl: 'https://walletconnect.com/privacy',
  wallets: [
      new SolflareWalletAdapter(),
    ]
})
```
</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/javascript/core/installation.mdx">
---
title: Installation
---

import CloudBanner from '../../../components/CloudBanner'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiImplementation from '../wagmi/about/implementation.mdx'
import WagmiModal from '../wagmi/about/triggermodal.mdx'

import Ethers5Implementation from '../ethers5/implementation.mdx'

import EthersImplementation from '../ethers/about/implementation.mdx'
import EthersModal from '../ethers/about/triggermodal.mdx'

import SolanaImplementation from '../solana/about/implementation.mdx'
import SolanaModal from '../solana/about/triggermodal.mdx'
import SolanaPrograms from '../solana/about/programs.mdx'

# JavaScript

AppKit has support for [Wagmi](https://wagmi.sh/) and [Ethers v6](https://docs.ethers.org/v6/) on Ethereum and [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/) on Solana.
Choose one of these Ethereum Libraries or 'Solana' to get started.

:::info Note
We recommend using [Vite](https://vitejs.dev/guide/#scaffolding-your-first-vite-project) to get started with AppKit JavaScript.
:::

## Installation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5", "ethers","solana"]}>
<PlatformTabItem value="wagmi">

```bash npm2yarn
npm install @web3modal/wagmi @wagmi/core @wagmi/connectors viem
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```bash npm2yarn
npm install @web3modal/ethers5 ethers@5.7.2
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```bash npm2yarn
npm install @web3modal/ethers ethers
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```bash npm2yarn
npm install @web3modal/solana
```

</PlatformTabItem>
</PlatformTabs>

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

<CloudBanner />

## Implementation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5", "ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiImplementation />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<Ethers5Implementation />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersImplementation />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaImplementation />

</PlatformTabItem>
</PlatformTabs>

## Trigger the modal

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi","ethers5", "ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiModal />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<EthersModal />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersModal />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaModal />

</PlatformTabItem>
</PlatformTabs>

## Smart Contract Interaction

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers","solana"]}>

<PlatformTabItem value="wagmi">

[Wagmi actions](https://wagmi.sh/core/api/actions/readContract) can help us interact with wallets and smart contracts:

```tsx
import { readContract } from '@wagmi/core'
import { USDTAbi } from '../abi/USDTAbi'

const USDTAddress = '0x...'

const data = readContract({
  address: USDTAddress,
  abi: USDTAbi,
  functionName: 'symbol'
})
```

Read more about Wagmi actions for smart contract interaction [here](https://wagmi.sh/core/actions/readContract).

</PlatformTabItem>
<PlatformTabItem value="ethers">

[Ethers](https://docs.ethers.org/v6/) can help us interact with wallets and smart contracts:

```tsx
import { BrowserProvider, Contract, formatUnits } from 'ethers'

const USDTAddress = '0x617f3112bf5397D0467D315cC709EF968D9ba546'

// The ERC-20 Contract ABI, which is a common contract interface
// for tokens (this is the Human-Readable ABI format)
const USDTAbi = [
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function balanceOf(address) view returns (uint)',
  'function transfer(address to, uint amount)',
  'event Transfer(address indexed from, address indexed to, uint amount)'
]

const walletProvider = modal.getWalletProvider()

async function getBalance() {
  if (!isConnected) throw Error('User disconnected')

  const ethersProvider = new BrowserProvider(walletProvider)
  const signer = await ethersProvider.getSigner()
  // The Contract object
  const USDTContract = new Contract(USDTAddress, USDTAbi, signer)
  const USDTBalance = await USDTContract.balanceOf(address)

  console.log(formatUnits(USDTBalance, 18))
}
```

</PlatformTabItem>
<PlatformTabItem value="solana">
  <SolanaPrograms />
</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/javascript/core/options.mdx">
---
title: Options
---

import Options from '../../shared/options.mdx'

# Options

<Options />
</file>

<file path="docs/appkit/javascript/core/resources.mdx">
---
title: Resources
---

import Resources from '../../shared/resources.mdx'

# Resources

<Resources />
</file>

<file path="docs/appkit/javascript/core/siwe.mdx">
---
title: One-Click Auth / SIWE
---

import SiweCode from '../../shared/siwe/code.mdx'
import SiweParams from '../../shared/siwe/parameters.mdx'

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a new form of authentication that enables users to control their digital identity with their Ethereum account.
SIWE is a standard also known as [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as ["ReCaps"](https://eips.ethereum.org/EIPS/eip-5573). ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary.
WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## Installation

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```bash npm2yarn
npm i @web3modal/siwe
```

</TabItem>
<TabItem value="legacy" label="Legacy">

:::caution
For a better UX we recommend using One-Click Auth.
:::

Install the AppKit SIWE package, additionally we also recommend installing [siwe](https://docs.login.xyz/) which will abstract a lot of the required logic.

```bash npm2yarn
npm i @web3modal/siwe siwe
```

</TabItem>
</Tabs>

## Configure your SIWE Client

<SiweCode />

## Initialize AppKit with your `siweConfig`

```ts
createWeb3Modal({
  //..
  siweConfig
})
```

## SIWE Config Parameters

<SiweParams />
</file>

<file path="docs/appkit/javascript/core/theming.mdx">
import Theming from '../../shared/theming.mdx'

# Theming

<Theming />
</file>

<file path="docs/appkit/javascript/ethers/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In your `main.ts` file set up the following configuration.

```ts
import { createWeb3Modal, defaultConfig } from '@web3modal/ethers'

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// 3. Create your application's metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // url must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}

// 4. Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1 // used for the Coinbase SDK
})

// 5. Create a AppKit instance
const modal = createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/javascript/ethers/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).

<Tabs>
<TabItem value="components" label="Web Component">

```html
  <body>
    <div id="app">
      <w3m-button></w3m-button>
      <w3m-network-button> </w3m-network-button>
    </div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

Learn more about the AppKit web components [here](../../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="actions" label="actions">

You can trigger the modal by calling the `open` function from a modal instance returned by `createWeb3Modal`.

Let's first add two html button elements into our `index.html` file:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML Example</title>
  </head>
  <body>
    <button id="open-connect-modal">Open Modal</button>
    <button id="open-network-modal">Open Networks</button>
    <script type="module" src="main.js"></script>
  </body>
</html>
```

Following with our `main.ts` file, we can now add the needed logic to open the modal:

```ts
const openConnectModalBtn = document.getElementById('open-connect-modal')
const openNetworkModalBtn = document.getElementById('open-network-modal')

openConnectModalBtn.addEventListener('click', () => modal.open())
openNetworkModalBtn.addEventListener('click', () => modal.open({ view: 'Networks' }))
```

Learn more about the AppKit actions [here](../../core/actions.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/javascript/ethers/actions.mdx">
import Button from '../../../components/button'

You can use the following methods to get data and subscribe to changes:

### getAddress

```ts
const address = modal.getAddress()
```

### getError

```ts
const error = modal.getError()
```

### getChainId

```ts
const chainId = modal.getChainId()
```

### switchNetwork

```ts
const chainId = 137

modal.switchNetwork(chainId)
```

### getIsConnected

```ts
const isConnected = modal.getIsConnected()
```

### getWalletProvider

The wallet provider.

```ts
const walletProvider = modal.getWalletProvider()
```

### getWalletProviderType

```ts
const walletProviderType = modal.getWalletProviderType()
```

### subscribeProvider

```ts
function handleChange({ provider, providerType, address, error, chainId, isConnected }) {
  //...
}

modal.subscribeProvider(handleChange)
```

<Button name="Learn More" url="https://docs.ethers.org/v6/getting-started/#starting-blockchain" />
</file>

<file path="docs/appkit/javascript/ethers5/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In your `main.ts` file set up the following configuration.

```ts
import { createWeb3Modal, defaultConfig } from '@web3modal/ethers5'

// 1. Get projectId at https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// 3. Create your application's metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // url must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}

// 4. Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1 // used for the Coinbase SDK
})

// 5. Create a AppKit instance
const modal = createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/javascript/notifications/authorization-signatures/all-apps.mdx">
# Signing the message: ‚ÄúI further authorize this app to view and manage my notifications for ALL apps‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you may be presented with a signature request that reads the following message:

> I further authorize this app to view and manage my notifications for ALL apps. Read more at https://walletconnect.com/notifications-all-apps

For any signature request, it‚Äôs critical that you always read the message attached before signing in order to fully understand the permissions you‚Äôre granting.

Take caution when signing this request as doing so will allow the app to:

- Subscribe you to notifications from any app
- Manage your notifications for any app
- View your notifications from any app

The app will not be able to:

- Sign blockchain transactions or additional messages

Typically, apps you subscribe to for notifications will send a slightly [different request](this-app) that asks you to only authorize them to manage notifications _for that app only_ upon signing. You should only ever be presented with the message shown in the example above when an app requires wider access to your subscriptions and messages.

A common example of this would be an app that enables you to view notifications and messages from multiple apps, like a wallet or the [Web3Inbox.com app](https://app.web3inbox.com).

Always be cautious when granting this permission to an app, and ensure that you‚Äôre familiar with the app sending the request.

## Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/all-apps/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/all-apps/message.jpg" />
</div>
</file>

<file path="docs/appkit/javascript/notifications/authorization-signatures/overview.mdx">
# Authorization Signatures

When a user wants to enable notifications with an app or wallet, they must sign a SIWE message with their account granting that app access to view and manage their notifications. The SIWE message varies depending on whether the app is requesting access to manage all app notifications, or just that app's notifications. Below are the two possible SIWE messages the user would be requested to sign:

- [I authorize [...] this app](this-app)
- [I authorize [...] all apps](all-apps)
</file>

<file path="docs/appkit/javascript/notifications/authorization-signatures/this-app.mdx">
# Signing the message: ‚ÄúI further authorize this app to send me notifications‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you'll likely be presented with a signature request that reads the following message:

> I further authorize this app to send me notifications. Read more at https://walletconnect.com/notifications

For any signature request, it‚Äôs critical that you always read the message attached before signing to fully understand the permissions you‚Äôre granting.

By signing this request, you‚Äôre allowing the app to:

- Subscribe you to notifications from only this app
- Manage your notifications for only this app
- View your notifications from only this app

The app will not be able to:

- Sign blockchain transactions or additional messages
- Subscribe to, manage, or view notifications from other apps

Most apps that send notifications using Web3Inbox will request for you to sign this message&mdash;this will allow the app to simply interact with you directly. If you wish to opt-in to receive notifications from this app, signing this message will enable you to do so.

If you‚Äôve signed up to notifications but have received a different message, head [here](all-apps) to learn about other scenarios in which you may receive a signature request regarding notifications.

### Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/this-app/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/this-app/message.jpg" />
</div>
</file>

<file path="docs/appkit/javascript/notifications/frontend-integration/api.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CloudBanner from '../../../../components/CloudBanner'

import Initialization from '../../../shared/notifications/frontend-integration/api/initialization/javascript.mdx'
import SettingAccount from '../../../shared/notifications/frontend-integration/api/setting-account/javascript.mdx'
import Registering from '../../../shared/notifications/frontend-integration/api/registering-accounts/javascript.mdx'
import Managing from '../../../shared/notifications/frontend-integration/api/managing-subscription/javascript.mdx'
import ManagingNotifications from '../../../shared/notifications/frontend-integration/api/managing-notifications/javascript.mdx'
import Types from '../../../shared/notifications/frontend-integration/api/types/javascript.mdx'
import RegisteringPush from '../../../shared/notifications/frontend-integration/api/registering-push/javascript.mdx'
import Events from '../../../shared/notifications/frontend-integration/api/events/javascript.mdx'

# API

## Initialization

<Initialization/>

## Managing Account

### Setting account for web3inbox

<SettingAccount/>

### Registering an account

<Registering/>

## Managing Subscription

<Managing/>

## Managing Notifications

<ManagingNotifications/>

## Notification Types

<Types/>

## Registering for Device Push Notifications

<RegisteringPush/>

## Listening For Events

<Events/>
</file>

<file path="docs/appkit/javascript/notifications/frontend-integration/examples.mdx">
# Examples

- Our production [GM App](https://gm.walletconnect.com) which sends daily "gm!" notifications to all subscribers.
- [React GM Dapp](https://github.com/WalletConnect/gm-dapp) - a Web3Inbox Dapp using React, Typescript, Next.js & Ethers.
- Bare bones [template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) demonstrating basic functionality in an easy to base from way.
</file>

<file path="docs/appkit/javascript/notifications/frontend-integration/migration-guide.mdx">
import Migration from '../../../shared/notifications/frontend-integration/migration/javascript.mdx'

# Migration Guide

## General Migration notes

- `isLimited` flag has been removed in favor of `allApps` flag. They essentially mean the opposite thing.
- Deleting messages is no longer possible
- Messages are now stored on notify server and can be paged
- Registration is more flexible since it is now split into 2 functions

## Migrating from 0.x to 1.0.0

<Migration/>
</file>

<file path="docs/appkit/javascript/notifications/frontend-integration/usage.mdx">
import Installation from '../../../shared/notifications/frontend-integration/usage/installation/javascript.mdx'
import Example from '../../../shared/notifications/frontend-integration/usage/example/javascript.mdx'

# Usage

AppKit Notifications provides you the building blocks necessary to allow users to subscribe, receive notifications, and manage notification preferences, all from your app's UI. The Web3Inbox SDK supports both React hooks and JavaScript-based integrations.

Before begin using Web3Inbox, you will first need to [setup your project](../cloud-setup) to send notifications.

## Installation

<Installation/>

## Example Usage

This basic example demonstrates how to use the AppKit Notifications to subscribe to notifications and receive them in your app. Refer to the [API Reference](./api) for more details on the available methods.

<Example/>

## UX Guidelines

For the best user experience we have several recommendations on how to build the Web3Inbox flows into your app:

- Have an explicit opt-in UI to subscribe to notifications. Some users may not want to receive notifications, and enabling notifications requires the user to sign a message with their blockchain account. Enabling notifications should be optional, and if they do enable them they should be told that they will need to sign a message to enable this.
- Have a button to unsubscribe from notifications once they are enabled. Users may want to stop receiving notifications, so you should have a button to unsubscribe from notifications if the user wants to.
- Make use of [notification types](../cloud-setup#notification-types). These allow the user fine-grained control over what types of notifications they want to receive from your app. These allow users to only unsubscribe from the specific notifications they are no longer interested in, rather than needing to unsubscribe from your entire app. Your app should include functionality to manage notification preferences.
</file>

<file path="docs/appkit/javascript/notifications/backend-integration.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Backend Integration

Once an account is subscribed to your app's notifications you can test sending notifications to the account. You can subscribe in your app directly with our [Frontend Integration](frontend-integration/usage), or with one of the below testing options.

We recommend testing notifications with the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to your phone. You can also try one of our sample wallets:

- [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
- [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

## Authentication

To send notifications and access all subscriber information for your dapp, you will need your Notify API Secret and project ID.

You can find the Notify API Secret under the Notify API section of the APIs tab of your project on [WalletConnect Cloud](https://cloud.walletconnect.com). Follow steps on the [Cloud Setup](cloud-setup) page to configure this. This secret allows publishing notifications to any account subscribed to your app, so should not be published and should only be used by your app backend.

## Sending notifications

Only plaintext is supported, and newlines are ignored.

To send a notification notification you can call the `/notify` endpoint. This endpoint supports the following fields:

- `type` - The Notification type ID copied from WalletConnect Cloud.
- `title` - The title of the notification. Max 64 characters.
- `body` - The body of the notification containing more detail. Max 255 characters.
- `url` (optional) - A URL attached to the notification that the user can navigate to. Max 255 characters.
- `accounts` - A list of [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) account IDs for which to send the notification to. Max 500 accounts per request. Also see the [rate limits](#rate-limits) below.
- `notification_id` (optional) - An idempotency key of arbitrary format used to dedup multiple requests. Max 255 characters. Multiple calls with the same `notification_id` will use the first call's `notification` content, but will send to any additional account IDs listed in `accounts`.

```typescript
type RequestBody = {
  notification_id?: string | null
  notification: {
    type: string
    title: string
    body: string
    url?: string | null
  }
  accounts: string[]
}
```

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/notify`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    notification: {
      type: 'a1e53b95-18e5-4af8-9f03-9308ec87b687',
      title: 'The price of Ethereum has risen',
      body: 'The price of Ethereum has gone up 10%',
      url: 'https://app.example.com'
    },
    accounts: ['eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029']
  })
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/<PROJECT_ID>/notify' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "notification": {
      "type": "a1e53b95-18e5-4af8-9f03-9308ec87b687",
      "title": "The price of Ethereum has risen",
      "body": "The price of Ethereum has gone up 10%",
      "url": "https://app.example.com"
    },
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029"
    ]
  }'
```

</TabItem>

</Tabs>

## Get subscribers

You can tell if an account is subscribed and get information about subscribers using the `/v1/<project-id>/subscribers` endpoint. You can provide up to 100 accounts in the request.

If the account is subscribed, it will be returned as a key in the response along with a list of subscribed notification types as the value. If the account is not a subscriber, it will not be returned in the response.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const requestBody: RequestBody = {
  accounts: [
    'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029',
    'eip155:1:0x0000000000000000000000000000000000000000'
  ]
}

const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/subscribers`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
  body: JSON.stringify(requestBody)
})

const subscribers: ResponseBody = await response.json()

type RequestBody = {
  // Max 100 accounts
  accounts: string[]
}
type ResponseBody = {
  [account: string]: Subscriber
}
type Subscriber = {
  notification_types: string[]
}
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029",
      "eip155:1:0x0000000000000000000000000000000000000000"
    ]
  }'
```

</TabItem>

</Tabs>

Example response:

```jsonc
{
  "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029": {
    "notification_types": ["4d1c97ad-c182-4097-8f2c-8f80c0674df2"]
  }
}
```

## Get all subscribers

:::caution
This endpoint will download _all_ subscribers of your app, which is an expensive operation and can take several seconds to complete. Because of this, it has a low rate limit.
:::

You can get a list of all of the currently-subscribed accounts by calling the `/<project-id>/subscribers` endpoint.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/subscribers`, {
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
const subscribers: string[] = await response.json()
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl 'https://notify.walletconnect.com/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Mark all notifications as read

Unless marked as read by an app frontend, notifications will always be "unread". Because of this, when you
initially add support for displaying unread status or unread count to your frontend, users that have received
notifications in the past will have notifications display as "unread" even if they already have seen them.
This can potentially be an undesireable user experience.

To mitigate this problem, you can make a one-time call to the `/v1/<project-id>/mark-all-as-read` API endpoint
which will mark all existing notifications as read. Notifications marked as read in this way will not contribute
to read rate analytics. After you deploy your integration of unread states, you can call this endpoint to
reset the unread state for all of your existing notifications.

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/mark-all-as-read`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/mark-all-as-read' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Rate limits

To protect our system and subscribers, various limits and rate limits are in-place.

Rate limits are implemented as [token bucket](https://en.wikipedia.org/wiki/Token_bucket) and contain both rate and burst amounts. On average, a rate of requests can be made. However, since real-world applications often make requests in bursts, this fixed rate can be surpassed temporarily up to the burst amount, provided the app subsequently makes requests below the average in order to recover its bursting capability.

- `POST /<project-id>/notify`:
  - Each app can send 2 notifications per hour to an account, with a burst up to 50. Accounts that have been rate limited will be returned in the request response. Exceptions may be made on a per-project basis for special circumstances.
  - Each app can call this endpoint 2 times per second with a burst up to 20. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/subscribers`
  - Each app can call this endpoint 100 times per second with a burst up to 100. Rate limited requests will return a 429 status code.
- `GET /<project-id>/subscribers`
  - Each app can call this endpoint 1 time every 5 minutes with a burst up to 2. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/mark-all-as-read`
  - Each app can call this endpoint 1 time per hour with a burst up to 5. Rate limited requests will return a 429 status code.
</file>

<file path="docs/appkit/javascript/notifications/cloud-sending.mdx">
import useBaseUrl from '@docusaurus/useBaseUrl'

# Sending with Cloud

You can send notifications to subscribed users easily in [WalletConnect Cloud](https://cloud.walletconnect.com). Sending to users involves targeting particular [notification types](./cloud-setup#notification-types) who will receive your notification if they have not opted-out. You can specify a title and body for the notification, as well as a call-to-action link which users will be taken to when clicking on the notification.

Users can subscribe to your app in [several places](overview#subscribing-and-receiving-notifications) including the [Web3Inbox.com app](https://app.web3inbox.com), in your app with our [frontend SDK](frontend-integration/usage), or in supporting wallets.

To send notifications, you can use the utility provided in [WalletConnect Cloud](https://cloud.walletconnect.com) under the Notify API section:

1. In the APIs tab of your project, navigate to the Notify API section. You should see a banner with a link to the Send Notification playground.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground.png')} />

1. This allows you to send notifications to your subscribers. After you select the associated project, you can select the notification type, title, body, and link to send to your subscribers.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground-send.png')} />
</file>

<file path="docs/appkit/javascript/notifications/cloud-setup.mdx">
import CloudBanner from '../../../components/CloudBanner'
import useBaseUrl from '@docusaurus/useBaseUrl'

# Cloud Setup

This page explains the configuration required in order to obtain a Notify API Secret and configure your project to send notifications.

For a quick start to experiment with, you can try the [web3inbox template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) and following the steps in the README.

<CloudBanner />

## Domain to use

It is important to understand what domain you are using for your project as you are required to host a static file (the `did.json` file) on this domain before being able to use Notify API. The [WalletConnect Cloud](https://cloud.walletconnect.com) and clients receiving and managing your notifications use this file to authenticate that your domain is associated with the source of the notifications.

You can pick 1 domain and this is configured in the Dapp URL field of the Notify API section of the [WalletConnect Cloud](https://cloud.walletconnect.com). You may change your domain at any time, as long as you properly host the new `did.json` file there. Note that only one project may use a given domain at the same time.

During development it is optional to use your production domain for testing. Instead, you can use a staging domain, or even a entirely separate domain e.g. Vercel test site. However, once you move to production you will need to update your domain to your production domain and host a new file there.

Note that the file must be hosted on a real, publicly accessible, domain in order to verify its legitimacy. The use of `localhost` or other local addresses is not allowed.

## Dapp name, description, and logo

The dapp name, description, and logo are displayed in wallets that integrate Notify API as well as in the [Web3Inbox.com app](https://app.web3inbox.com). These details should be provided for the best user experience and to help the user identify your app.

## Notification types

Notification types are an important feature of Notify API and are a way for a user to have control over what types of notifications they receive. Users can change their notification types at any time in your app, their wallet, or the [Web3Inbox.com app](https://app.web3inbox.com). When sending notifications, you must use one of these configured notification types which you reference in code by its UUID.

Notification types are configured with a name, description, and icon which allow the user understand what types of notifications they would receive for that type. When a user receives a push notification on their device, they will see the icon that is configured with the notification type. Examples of notification types may include "Account updates" or "Service updates".

:::info
By default users are subscribed to all available notification types. However, it's worth nothing that if you add new notification types later users will not be automatically subscribed to them. If you have new notification types available, you may consider sending a notification informing users of this new available notification type and ask users to enable it. You may also add functionality to your app frontend to subscribe the user to the new notification type when they visit your app. Because of the additional effort in subscribing users to notification types after they initially subscribe, it is worth considering in advance what notification types you may need in the future.
:::

## Setup steps

### Navigating to Notify API section

In [WalletConnect Cloud](https://cloud.walletconnect.com), navigate to the APIs tab of your project.

<img className="image-margin" src={useBaseUrl('/img/w3i/1.png')} />

### Configuring Notify API

Under Notify API > Configuration > `DAPP INFORMATION`, fill in the Dapp URL field. This is the domain of your app that you will use to publish notifications.

<img className="image-margin" src={useBaseUrl('/img/w3i/dapp-info.png')} />

### Adding Notification Image and Types

Under the same section, next to Notification types, click on the "Add Notification Type" button and add a title, notification image and description for your notification type. This is the type of notification that your app will publish.

For example, if you are going to send promotional content as notification, you might want to add a notification type called "Promotional" with a description "Promotional content from the XYZ Team.".
You can also add a relevant image for the notification type.

<img className="image-margin" src={useBaseUrl('/img/w3i/notification-type.png')} />

### Saving Changes

Optionally, you can add a logo and description for your project. This will be shown to users when they subscribe to your app. Click "Save" to save your changes.

### Notify Secret

Take note of your new Notify API Secret. You will need this to publish notifications. This secret
allows publishing notifications to any account subscribed to your app, so should not be published
and should only be used by your app backend.

<img className="image-margin" src={useBaseUrl('/img/w3i/3.png')} />

### Hosting did.json file

Next, you will need to host `did.json` file on this page at the `/.well-known/` directory of your public URL. Please also ensure that your application has CORS enabled. An example is linked [here.](https://github.com/WalletConnect/gm-dapp/blob/main/next.config.js)

- Download `did.json` (click on `DID:WEB` section to show the download button ) and host it at, for example, `https://app.example.com/.well-known/did.json`
  <img className="image-margin" src={useBaseUrl('/img/w3i/did.png')} />

### Enabling Welcome Notifications

Welcome Notifications are notifications that are sent to users when they subscribe to your app. This is a great way to welcome users to your app and explain what types of notifications they will receive.

To enable Welcome Notifications, switch on the toggle in the Welcome Notifications section of your WalletConnect Cloud project after adding relevant Notification Type, Title, Body & Link.

<img className="image-margin" src={useBaseUrl('/img/w3i/welcome.png')} />

### Enabling Notify API

Once all changes have been saved and the `did.json` file has been deployed successfully, switch on the toggle switch in the Notify API section of your WalletConnect Cloud project. If everything is configured correctly, you should see a success toast: "Notify configuration successfully verified"

<img className="image-margin" src={useBaseUrl('/img/w3i/5.png')} />
<img className="image-margin" src={useBaseUrl('/img/w3i/6.png')} />

## Send Notifications in Cloud

Once you have completed the setup steps, you can now send notifications to users who have subscribed to your app. [Read more](./cloud-sending)

## Next steps

1. Now you are ready for accounts to subscribe to your app and send notifications to them using your Notify API Secret or with WalletConnect Cloud.

   - Read more on [sending notifications with WalletConnect Cloud](./cloud-sending)
   - Read more on [frontend integration](./frontend-integration/usage)
   - Read more on [backend integration](./backend-integration)

1. If you haven't already, [verify your apps domain](../cloud/verify) for improved security.

2. Navigate to the `Metrics` tab and select Web3Inbox from the dropdown to access analytics for your app. [Learn more about Web3Inbox Analytics](../cloud/analytics#web3inbox).

   <img className="image-margin" src={useBaseUrl('/img/w3i/metrics.png')} />
</file>

<file path="docs/appkit/javascript/notifications/demo.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Demo

## Try Web3Inbox

The fastest way to try Web3Inbox is to go to [app.web3inbox.com](https://app.web3inbox.com) and try subscribing to some dapps. The [Web3Inbox.com app](https://app.web3inbox.com) is a universal inbox for web3 users to access all their notifications in one place.

- [Web3Inbox.com app](https://app.web3inbox.com)

Or access the repo at [github.com/WalletConnect/web3inbox](https://github.com/WalletConnect/web3inbox/).

## Native notifications

Web3Inbox also supports native notifications on iOS and Android. To try native notifications, you can use the [Web3Inbox.com app](https://app.web3inbox.com) and subscribe to dapps or build one of our sample apps.

A wallet that supports Notify is required to receive notifications.

## Wallet notifications

To try wallet notifications on a iOS or Android device, use a wallet that supports Notify. Alternatively, try building one of our sample apps, or grab a sample wallet preview build from Testflight or Firebase.

<PlatformTabs
	groupId="w3iw"
	activeOptions={["ios", "android", "web"]}
>

<PlatformTabItem value="web">
- [React Native](../../../walletkit/react-native/notifications/notify/installation)

</PlatformTabItem>

<PlatformTabItem value="ios">

- [Swift](../../../walletkit/ios/notifications/notify/installation)
- [Testflight](https://testflight.apple.com/join/09bTAryp)

</PlatformTabItem>

<PlatformTabItem value="android">

- [Kotlin](../../../walletkit/android/notifications/notify/installation)
- [Firebase](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/javascript/notifications/overview.mdx">
# Introduction

AppKit provides a toolkit for integrating Web3 notification features into apps. AppKit Notifications can be used to send notifications from your app directly to wallets.

This SDK utilizes WalletConnect's Notify API and is designed for Web3 scenarios, providing event-based notifications for activities like DAO votes, DeFi transaction alerts, and updates for NFT holders. Apps can send notifications to subscribed accounts, and users can receive and view their notifications in a supporting wallet, in the [Web3Inbox.com app](https://app.web3inbox.com), or in the app's frontend. Users can also discover Notify-compatible apps in their wallet or the [Web3Inbox.com app](https://app.web3inbox.com) to subscribe to.

AppKit Notifications is not to be confused with the [Web3Inbox.com app](https://app.web3inbox.com) which allows users to receive and manage their notifications from all apps, as they would in a wallet.

![Web3Inbox](/assets/web3inbox/w3i-hero.png)

## Getting Started

AppKit Notifications can be added to your app in a few steps:

- [Setup your project](cloud-setup) to send authenticated notifications.
- Use our [frontend SDK](frontend-integration/usage) to enable users to subscribe to notifications in your app.
- Finally, use [WalletConnect Cloud](cloud-sending) or our [API in your backend](backend-integration) to send notifications to subscribed users.

## Overview

Some of the key features of the Web3Inbox SDK include:

- **Device push notifications:** Push notifications to the user's wallet (if it supports Notify API) or the [Web3Inbox.com app](https://app.web3inbox.com).
- **Notification history:** Notifications are stored and can be accessed from any device.
- **Spam protection/subscription control.** Using notification types, subscribers can opt-out of certain notification types they do not want to receive.
- **Tracking read status across devices.**

## Subscribing and receiving notifications

Users can receive notifications in several places:

- In the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to the user's phone
- In your app's frontend using our [frontend SDK](frontend-integration/usage)
- Natively in their wallet if the wallet supports Notify API.
  - You can also test with one of our sample wallets:
    - [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
    - [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

Users can also subscribe to notifications in all of the above locations too. To be discoverable in the Web3Inbox.com app or in wallets, apps must submit an explorer listing.

## Try it out

See the [demo section](demo) for sample apps and the Web3Inbox universal inbox app.

## FAQ

### What chains does Web3Inbox support?

Web3Inbox supports EOA accounts on all `eip155` (EVM) chains, and smart accounts on all `eip155` chains that our Blockchain API [supports](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md). We have plans to expand support in the future.
</file>

<file path="docs/appkit/javascript/onboarding/ens.mdx">
# ENS Provider
</file>

<file path="docs/appkit/javascript/onboarding/graduation.mdx">
# Graduation
</file>

<file path="docs/appkit/javascript/onboarding/smart-accounts.mdx">
---
title: Smart Accounts
---

import SmartAccount from '../../shared/smart-accounts.mdx'

<SmartAccount />
</file>

<file path="docs/appkit/javascript/onboarding/socials.mdx">
---
title: Email & Socials
---

import Socials from '../../shared/socials.mdx'

<Socials />
</file>

<file path="docs/appkit/javascript/solana/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

AppKit Solana is built on top of the AppKit library and provides a set of components and actions to easily connect Solana wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  name: 'AppKit',
  description: 'AppKit Solana Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

const solanaConfig = defaultSolanaConfig({
  metadata,
  chains,
  projectId
})

// 3. Create modal
const modal = createWeb3Modal({
  solanaConfig,
  chains,
  projectId,
  wallets: [
      // Solana wallet adapters (check Custom connectors for more info)
  ]
})
```
</file>

<file path="docs/appkit/javascript/solana/about/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to this [demo app](https://appkit-solana.vercel.app/).

```js
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js'
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'

function deserializeCounterAccount(data) {
  if (data?.byteLength !== 8) {
    throw Error('Need exactly 8 bytes to deserialize counter')
  }

  return {
    count: Number(data[0])
  }
}

const { address, currentChain } = useWeb3ModalAccount()
const { walletProvider, connection } = useWeb3ModalProvider()

async function onIncrementCounter() {
  const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy')

  const counterKeypair = Keypair.generate()
  const counter = counterKeypair.publicKey

  const balance = await connection.getBalance(walletProvider.publicKey)
  if (balance < LAMPORTS_PER_SOL / 100) {
    throw Error('Not enough SOL in wallet')
  }

  const COUNTER_ACCOUNT_SIZE = 8
  const allocIx = SystemProgram.createAccount({
    fromPubkey: walletProvider.publicKey,
    newAccountPubkey: counter,
    lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
    space: COUNTER_ACCOUNT_SIZE,
    programId: PROGRAM_ID
  })

  const incrementIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      {
        pubkey: counter,
        isSigner: false,
        isWritable: true
      }
    ],
    data: Buffer.from([0x0])
  })

  const tx = new Transaction().add(allocIx).add(incrementIx)

  tx.feePayer = walletProvider.publicKey
  tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash

  await walletProvider.signAndSendTransaction(tx, [counterKeypair])

  const counterAccountInfo = await connection.getAccountInfo(counter, {
    commitment: 'confirmed'
  })

  if (!counterAccountInfo) {
    throw new Error('Expected counter account to have been created')
  }

  const counterAccount = deserializeCounterAccount(counterAccountInfo?.data)

  if (counterAccount.count !== 1) {
    throw new Error('Expected count to have been 1')
  }

  console.log(`[alloc+increment] count is: ${counterAccount.count}`);
}
```
</file>

<file path="docs/appkit/javascript/solana/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).
In this example we are going to use the `<w3m-button>` component.

 Web components are global html elements that don't require importing.

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML Example</title>
  </head>
  <body>
    /* highlight-add-start */
    <w3m-button></w3m-button>
    /* highlight-add-end */
    <script type="module" src="main.ts"></script>
  </body>
</html>
```

Learn more about the AppKit web components [here](../../core/components.mdx)
</file>

<file path="docs/appkit/javascript/solana/actions.mdx">
import Button from '../../../components/button'

You can use the following methods to get data and subscribe to changes:

### getAddress

```ts
const address = modal.getAddress()
```

### getError

```ts
const error = modal.getError()
```

### getChainId

```ts
const chainId = modal.getChainId()
```

### getIsConnected

```ts
const isConnected = modal.getIsConnected()
```

### getWalletProvider

The wallet provider.

```ts
const walletProvider = modal.getWalletProvider()
```

// TODO - add sign message example

### getWalletProviderType

The wallet or protocol of the walletProvider.

```ts
const walletProviderType = modal.getWalletProviderType()
```

### subscribeProvider

subscribe to chainId, address, provider changes.

```ts
function handleChange({ provider, providerType, address, error, chainId, isConnected }) {
  //...
}

modal.subscribeProvider(handleChange)
```

<Button name="Learn More" url="https://docs.ethers.org/v6/getting-started/#starting-blockchain" />
</file>

<file path="docs/appkit/javascript/transactions/onramp.mdx">
---
title: On-Ramp
---

import Onramp from '../../shared/onramp.mdx'

# On-Ramp

<Onramp />
</file>

<file path="docs/appkit/javascript/transactions/swaps.mdx">
import Swaps from '../../shared/swaps.mdx'

# Swaps

<Swaps/>
</file>

<file path="docs/appkit/javascript/transactions/transaction-history.mdx">
# Transaction History
</file>

<file path="docs/appkit/javascript/wagmi/about/implementation.mdx">
For a quick integration you can use `defaultWagmiConfig` function which wraps Wagmi's [`createConfig`](https://wagmi.sh/core/api/createConfig) function with a predefined configuration.
This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api.mdx) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

In your `main.ts` file set up the following configuration.

```ts
import { createWeb3Modal, defaultWagmiConfig } from '@web3modal/wagmi'

import { mainnet, arbitrum } from 'viem/chains'
import { reconnect } from '@wagmi/core'

// 1. Get a project ID at https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create wagmiConfig
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain.
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

const chains = [mainnet, arbitrum] as const
export const config = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
})
reconnect(config)

// 3. Create modal
const modal = createWeb3Modal({
  wagmiConfig: config,
  projectId,
})
```
</file>

<file path="docs/appkit/javascript/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).
In this example we are going to use the `<w3m-button>` component.

 Web components are global html elements that don't require importing.

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML Example</title>
  </head>
  <body>
    /* highlight-add-start */
    <w3m-button></w3m-button>
    /* highlight-add-end */
    <script type="module" src="main.ts"></script>
  </body>
</html>
```

Learn more about the AppKit web components [here](../../core/components.mdx)
</file>

<file path="docs/appkit/javascript/wagmi/actions.mdx">
import Button from '../../../components/button'

You can use [Wagmi actions](https://wagmi.sh/core/actions/getAccount) to sign messages, interact with smart contracts, and much more.

### getAccount

Action for accessing account data and connection status.

```tsx
import { getAccount } from '@wagmi/core'
import { wagmiConfig } from './main'

const account = getAccount(wagmiConfig)
```

### signMessage

Action for signing messages with connected account.

```ts
import { signMessage } from '@wagmi/core'
import { wagmiConfig } from './main'

await signMessage(wagmiConfig, { message: 'hello world' })
```

<Button name="Learn More" url="https://wagmi.sh/core/actions/readContract" />
</file>

<file path="docs/appkit/migration/from-anza-adapter-react.mdx">
---
title: Migration from Solana Anza Adapter to AppKit
pagination_next: 

---

# Migration from Solana Anza Adapter to AppKit

Follow the steps below to migrate from the Starter Pack of Anza Adapter to AppKit. Based on the default implementation. Our starting point is the [Anza Adapter Starter Pack](https://github.com/anza-xyz/wallet-adapter/blob/master/packages/starter/react-ui-starter/) in Github.

## Step 1. Integrate Solana Appkit

### a. Create a project in WalletConnect Cloud

+ Create a new project on [WalletConnect Cloud](https://cloud.walletconnect.com) and obtain a new project ID.

### b. Uninstall old packages and install the AppKit packages: 

```bash npm2yarn
npm uninstall @solana/wallet-adapter-base @solana/wallet-adapter-react @solana/wallet-adapter-react-ui
```

```bash npm2yarn
npm install @web3modal/solana
```

### c. Add imports to the top of the `App.tsx`

Remove old imports:

```tsx
/* highlight-delete-start */
- import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
- import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
- import { WalletModalProvider, WalletMultiButton } from '@solana/wallet-adapter-react-ui';
/* highlight-delete-end */
```

Add the new imports:

```tsx
/* highlight-add-start */
+ import { createWeb3Modal, defaultSolanaConfig, useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'
+ import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'
/* highlight-add-end */
```

Update the code:

```tsx
// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

//  Get projectId at https://cloud.walletconnect.com
const projectId = import.meta.env.VITE_PROJECT_ID;
if (!projectId) throw new Error("Project ID is undefined");


// 2. Create solanaConfig
const metadata = {
    name: 'Appkit Solana Example',
    description: 'Appkit Solana Example',
    url: 'https://example.com', // origin must match your domain & subdomain
    icons: ['https://avatars.githubusercontent.com/u/37784886'],
}

const solanaConfig = defaultSolanaConfig({
        metadata,
        chains,
        projectId,
        auth: {
          email: true,
          socials: ['google', 'x', 'farcaster', 'github']
        }
    })

//  Create modal
createWeb3Modal({
    metadata,
    solanaConfig,
    chains,
    projectId,
  })
```
:::info
Email an social logins are enabled by default.
:::


### d. Update the `App.tsx` component

Use the AppKit Button. It can be configure following these [guidelines](https://docs.walletconnect.com/appkit/react-native/core/components#w3mbutton-).

:::info
AppKit's web components are global HTML elements that don't require importing.
:::

```tsx
const Content: FC = () => {
/* highlight-delete-start */
-   return <WalletMultiButton />;
/* highlight-delete-end */
/* highlight-add-start */
+   return <w3m-button />
/* highlight-add-end */   
};

```

### e. Create the `.env` file with the projectId

```
VITE_PROJECT_ID=<Add_your_project_id>
```

## Step 2. Interact with the Solana network

After integrating AppKit, you can interact with the Solana network using the `@solana/web3.js` library. 
You can check our [example](https://github.com/WalletConnect/web-examples/tree/main/dapps/web3modal/react-solana) on how to fully interact or read our [documentation](https://docs.walletconnect.com/appkit/react/core/installation#smart-contract-interaction) for more information.

### a. Add all the imports you need to interact with the Solana network:

```tsx
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'
import {
  PublicKey,
  Transaction,
  SystemProgram,
  Connection
} from '@solana/web3.js'
```

### b. call the hooks `useWeb3ModalAccount` and `useWeb3ModalProvider`:

```tsx
const { address } = useWeb3ModalAccount()
const { walletProvider, connection } = useWeb3ModalProvider() 
```

### c. Create a function to generate a transaction:

```tsx
const handleSendTransaction = async () => {
  if (!walletProvider || !address || !connection) {
    // walletProvider, connection or address are undefined
    return;
  }

  // Recipient address
  const recipientAddress = new PublicKey("DG1Bq6muEMqaW6MHzWZFfQ8MmHiwvEuQcjVefVmPoV3j")

  // Create a new transaction
  const transaction = new Transaction().add(
    SystemProgram.transfer({
      fromPubkey: walletProvider.publicKey,
      toPubkey: recipientAddress,
      lamports: 10000000,  //0.01 SOL
    })
  )
  transaction.feePayer = walletProvider.publicKey;

  const { blockhash } = await connection.getLatestBlockhash();
  transaction.recentBlockhash = blockhash;
  const tx = await walletProvider.sendTransaction(transaction, connection as Connection)
}
```

### d. Call the function:
  
  ```tsx
  <button onClick={handleSendTransaction}>Send Transaction</button>
  ```

### e. Install and Run the Solana AppKit Project.

Install dependencies:
```bash npm2yarn
npm install
```
 Start the project:
```bash npm2yarn
npm run dev
```

# Final notes

- Check our [Solana AppKit React Docs](/appkit/react/core/installation?platform=solana) for more information on how to customize your project.
- Test your application thoroughly to ensure that the migration has been successful and that all functionality is working as expected.
</file>

<file path="docs/appkit/migration/from-rainbowkit-next.mdx">
---
title: Migration from RainbowKit to AppKit
pagination_next: 

---

# Migration from RainbowKit to AppKit

Follow the steps below to migrate from the default RainbowKit project using Next.js Pages to an AppKit project using wagmi.

### Step 1. Create a project in WalletConnect Cloud

+ Create a new project on [WalletConnect Cloud](https://cloud.walletconnect.com) and obtain a new project ID.

### Step 2. Install & uninstall libraries

+ Run this command to install AppKit and uninstall RainbowKit.

```bash
pnpm install @web3modal/wagmi && pnpm uninstall @rainbow-me/rainbowkit
```

### Step 3. Change the index.tsx

Use the AppKit Button. It can be configure following these [guidelines](https://docs.walletconnect.com/appkit/react-native/core/components#w3mbutton-).
```tsx
/* highlight-delete-start */
- import { ConnectButton } from '@rainbow-me/rainbowkit';
/* highlight-delete-end */

/* highlight-delete-start */
- <ConnectButton />
/* highlight-delete-end */
/* highlight-add-start */
+ <w3m-button />
/* highlight-add-end */
```

:::info
AppKit's web components are global HTML elements that don't require importing.
:::

### Step 4. Changes in your config file

+ Replace the following import statements:
```tsx
/* highlight-delete-start */
- import { getDefaultConfig } from '@rainbow-me/rainbowkit';
/* highlight-delete-end */
/* highlight-add-start */
+ import { defaultWagmiConfig } from "@web3modal/wagmi/react/config";
/* highlight-add-end */
```

+ If you have something similar to this
```tsx
/* highlight-delete-start */
- export const config = getDefaultConfig({
-  appName: 'RainbowKit App',
-  projectId: 'YOUR_PROJECT_ID',
-  chains: [
-    mainnet,
-    polygon,
-    optimism,
-    arbitrum,
-    base,
-    ...(process.env.NEXT_PUBLIC_ENABLE_TESTNETS === 'true' ? [sepolia] : []),
-  ],
-  ssr: true,
- });
/* highlight-delete-end */
```

+ Replace the wagmi config for this example. Also you can customize email and social logins following this [guidelines](https://docs.walletconnect.com/appkit/react/onboarding/socials).

```tsx
/* highlight-add-start */
export const projectId = "YOUR_PROJECT_ID";

export const metadata = {
  name: "My App",
  description: "My App description",
  url: "https://example.com", // origin must match your domain and subdomain
  icons: ["https://example.com/favicon.png"]
};

// Create wagmiConfig
export const config = defaultWagmiConfig({
  chains, // chains are the same
  projectId, // Use the new project ID
  metadata,
  auth: { 
    email: true, 
    socials: ["github", "google", "x", "discord", "apple"],
    showWallets: true, // default to true
  },
  ssr: true,
});
/* highlight-add-end */
```

### Step 5. Update app.tsx

In this step, we'll update the import statements and remove the RainbowKitProvider from the component tree.

+ Replace the following import statements:
```tsx
import '../styles/globals.css';
/* highlight-delete-start */
- import '@rainbow-me/rainbowkit/styles.css';
/* highlight-delete-end */
import type { AppProps } from 'next/app';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';

/* highlight-delete-start */
- import { RainbowKitProvider } from '@rainbow-me/rainbowkit';
/* highlight-delete-end */
/* highlight-add-start */
+ import { createWeb3Modal } from "@web3modal/wagmi/react"
/* highlight-add-end */

/* highlight-delete-start */
- import { config } from '../wagmi';
/* highlight-delete-end */
/* highlight-add-start */
+ import { config, metadata, projectId } from '../wagmi';
/* highlight-add-end */
```


+ Initialize AppKit:
```tsx
const client = new QueryClient();

/* highlight-add-start */
// Create modal
createWeb3Modal({
  metadata,
  wagmiConfig: config,
  projectId,
  enableAnalytics: true, // Optional - defaults to your Cloud configuration
  enableOnramp: true, // Optional - false as default
});
/* highlight-add-end */
```

+ Update the component:
```tsx
function MyApp({ Component, pageProps }: AppProps) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={client}>
/* highlight-delete-start */
-       <RainbowKitProvider>
/* highlight-delete-end */
          <Component {...pageProps} />
/* highlight-delete-start */
-       </RainbowKitProvider>
/* highlight-delete-end */
      </QueryClientProvider>
    </WagmiProvider>
  );
}

export default MyApp;
```

### Final notes

+ Ensure that you have updated all relevant configurations and imports in your project to reflect the changes from RainbowKit to AppKit.
+ Test your application thoroughly to ensure that the migration has been successful and that all functionality is working as expected.
+ Check our [AppKit web examples](https://github.com/WalletConnect/web-examples/tree/main/dapps/web3modal) to compare with your implementation in case you are having issues
</file>

<file path="docs/appkit/next/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/next/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/next/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/next/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/next/core/components.mdx">
---
title: Components
---

import Components from '../../shared/components.mdx'

# Web Components

<Components />
</file>

<file path="docs/appkit/next/core/custom-connectors.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Custom connectors

Add custom connectors for Ethers or Wagmi

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "solana"]}>
<PlatformTabItem value="wagmi">

If you already have Wagmi integrated into your application or would like more control over Wagmi's configuration, you can integrate AppKit on top of it.

```tsx
import { createConfig, cookieStorage, createStorage, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { walletConnect } from 'wagmi/connectors'

export const projectId = process.env.NEXT_PUBLIC_PROJECT_ID

const metadata = {
  //...
}

// Create wagmiConfig
export const config = createConfig({
  chains: [sepolia],
  transports: {
    [sepolia.id]: http()
  },
  connectors: [
    walletConnect({ projectId, metadata, showQrModal: false }), // showQrModal must be false.
    // Other connectors...
  ],
  ssr: true,
  storage: createStorage({
    storage: cookieStorage
  })
})
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

Coming soon...

</PlatformTabItem>
<PlatformTabItem value="solana">
Add custom wallet adapters for Solana wallets by first installing the wallet adapter package and then including the adapters in the wallets array. You can find a more Solana wallet adapters [here](https://github.com/anza-xyz/wallet-adapter/tree/master/packages/wallets).

```bash npm2yarn
npm install @solana/wallet-adapter-solflare
```

```ts
import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/react'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  //...
}

const solanaConfig = defaultSolanaConfig({
  chains,
  projectId,
  metadata
})

// 3. Create modal
const modal = createWeb3Modal({
  solanaConfig,
  projectId: projectId,
  metadata: metadata,
  chains,
  enableAnalytics: true,
  termsConditionsUrl: 'https://walletconnect.com/terms',
  privacyPolicyUrl: 'https://walletconnect.com/privacy',
  wallets: [
      new SolflareWalletAdapter(),
    ]
})
```
</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/next/core/hooks.mdx">
import Table from '../../../components/Table'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiHooks from '../wagmi/hooks.mdx'
import EthersHooks from '../ethers/hooks.mdx'
import SolanaHooks from '../solana/hooks.mdx'

# Hooks

Hooks are functions that will help you control the modal, subscribe to wallet events and interact with them and smart contracts.

## useWeb3Modal

Control the modal with the `useWeb3Modal` hook

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>

<PlatformTabItem value="wagmi">

```ts
import { useWeb3Modal } from '@web3modal/wagmi/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```ts
import { useWeb3Modal } from '@web3modal/ethers5/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
import { useWeb3Modal } from '@web3modal/ethers/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```ts
import { useWeb3Modal } from '@web3modal/solana/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
</PlatformTabs>

You can also select the modal's view when calling the `open` function

```ts
open({ view: 'Account' })
```

List of views you can select

<Table
  headers={['Variable', 'Description']}
  data={[
    {
      variable: { code: 'Connect' },
      description: 'Principal view of the modal - default view when disconnected'
    },
    {
      variable: { code: 'Account' },
      description: 'User profile - default view when connected'
    },
    {
      variable: { code: 'AllWallets' },
      description: 'Shows the list of all available wallets'
    },
    {
      variable: { code: 'Networks' },
      description:
        'List of available networks - you can select and target a specific network before connecting'
    },
    {
      variable: { code: 'WhatIsANetwork' },
      description: '"What is a network" onboarding view'
    },
    {
      variable: { code: 'WhatIsAWallet' },
      description: '"What is a wallet" onboarding view'
    },
    {
      variable: { code: 'OnRampProviders' },
      description: '"On-Ramp main view'
    }
  ]}
/>

## useDisconnect

```ts
const { disconnect } = useDisconnect()

disconnect()
```

## useWalletInfo

Metadata information from the connected wallet

```ts
import { useWalletInfo } from '@web3modal/wagmi/react'


export default Component(){
  const { walletInfo } = useWalletInfo()

  console.log(walletInfo.name, walletInfo.icon)

  //...
}
```

## Ethereum Library

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers"]}>
<PlatformTabItem value="wagmi">

<WagmiHooks />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersHooks />

</PlatformTabItem>
</PlatformTabs>

## useWeb3ModalState

Get the current value of the modal's state

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

```ts
import { useWeb3ModalState } from '@web3modal/wagmi/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```ts
import { useWeb3ModalState } from '@web3modal/ethers5/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
import { useWeb3ModalState } from '@web3modal/ethers/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```ts
import { useWeb3ModalState } from '@web3modal/solana/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
</PlatformTabs>

The modal state consists of two reactive values:

<Table
  headers={['State', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'open' },
      description: 'Open state will be true when the modal is open and false when closed.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'selectedNetworkId' },
      description: 'The current chain id selected by the user',
      type: { code: 'number' }
    }
  ]}
/>

## useWeb3ModalTheme

```ts
const { themeMode, themeVariables, setThemeMode, setThemeVariables } = useWeb3ModalTheme()

setThemeMode('dark')

setThemeVariables({
  '--w3m-color-mix': '#00BB7F',
  '--w3m-color-mix-strength': 40
})
```

## Track modal events

```ts
import { useWeb3ModalEvents } from '@web3modal/wagmi/react'

const events = useWeb3ModalEvents()
```
</file>

<file path="docs/appkit/next/core/installation.mdx">
---
title: Installation
---

import CloudBanner from '../../../components/CloudBanner'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiImplementation from '../wagmi/about/implementation.mdx'
import WagmiModal from '../wagmi/about/triggermodal.mdx'

import Ethers5Implementation from '../ethers5/implementation.mdx'
import Ethers5Modal from '../ethers5/triggermodal.mdx'

import EthersImplementation from '../ethers/about/implementation.mdx'
import EthersModal from '../ethers/about/triggermodal.mdx'

import SolanaImplementation from '../solana/about/implementation.mdx'
import SolanaModal from '../solana/about/triggermodal.mdx'
import SolanaPrograms from '../solana/about/programs.mdx'

# Next.js

AppKit has support for [Wagmi](https://wagmi.sh/) and [Ethers v6](https://docs.ethers.org/v6/) on Ethereum and [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/) on Solana.
Choose one of these Ethereum Libraries or 'Solana' to get started.

:::info Note
These steps are specific to [Next.js](https://nextjs.org/) app router. For other React frameworks read the [React documentation](../../react/core/installation.mdx).
:::

## Installation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

```bash npm2yarn
npm install @web3modal/wagmi wagmi viem @tanstack/react-query
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```bash npm2yarn
npm install @web3modal/ethers5 ethers@5.7.2
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```bash npm2yarn
npm install @web3modal/ethers ethers
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```bash npm2yarn
npm install @web3modal/solana
```

</PlatformTabItem>
</PlatformTabs>

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

<CloudBanner />

## Implementation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiImplementation />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<Ethers5Implementation />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersImplementation />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaImplementation />

</PlatformTabItem>
</PlatformTabs>

## Trigger the modal

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiModal />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<Ethers5Modal />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersModal />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaModal />

</PlatformTabItem>
</PlatformTabs>

## Smart Contract Interaction

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers","solana"]}>
<PlatformTabItem value="wagmi">

[Wagmi hooks](https://wagmi.sh/react/api/hooks/useReadContract) can help us interact with wallets and smart contracts:

```tsx
import { useReadContract } from 'wagmi'
import { USDTAbi } from '../abi/USDTAbi'

const USDTAddress = '0x...'

function App() {
  const result = useReadContract({
    abi: USDTAbi,
    address: USDTAddress,
    functionName: 'totalSupply'
  })
}
```

Read more about Wagmi hooks for smart contract interaction [here](https://wagmi.sh/react/hooks/useReadContract).

</PlatformTabItem>
<PlatformTabItem value="ethers">

[Ethers](https://docs.ethers.org/v6/) can help us interact with wallets and smart contracts:

```tsx
import { useWeb3ModalProvider, useWeb3ModalAccount } from '@web3modal/ethers/react'
import { BrowserProvider, Contract, formatUnits } from 'ethers'

const USDTAddress = '0x617f3112bf5397D0467D315cC709EF968D9ba546'

// The ERC-20 Contract ABI, which is a common contract interface
// for tokens (this is the Human-Readable ABI format)
const USDTAbi = [
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function balanceOf(address) view returns (uint)',
  'function transfer(address to, uint amount)',
  'event Transfer(address indexed from, address indexed to, uint amount)'
]

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()
  const { walletProvider } = useWeb3ModalProvider()

  async function getBalance() {
    if (!isConnected) throw Error('User disconnected')

    const ethersProvider = new BrowserProvider(walletProvider)
    const signer = await ethersProvider.getSigner()
    // The Contract object
    const USDTContract = new Contract(USDTAddress, USDTAbi, signer)
    const USDTBalance = await USDTContract.balanceOf(address)

    console.log(formatUnits(USDTBalance, 18))
  }

  return <button onClick={getBalance}>Get User Balance</button>
}
```

</PlatformTabItem>
<PlatformTabItem value="solana">
  <SolanaPrograms />
</PlatformTabItem>
</PlatformTabs>

## Extra configuration

Next.js relies on [SSR](https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering). This means some specific steps are required to make Web3Modal work properly.

- Add the following code in the `next.config.js` file

```ts
// Path: next.config.js
const nextConfig = {
  webpack: config => {
    config.externals.push('pino-pretty', 'lokijs', 'encoding')
    return config
  }
}
```

- [Learn more about SSR with Wagmi](https://wagmi.sh/react/guides/ssr)
</file>

<file path="docs/appkit/next/core/options.mdx">
---
title: Options
---

import Options from '../../shared/options.mdx'

# Options

<Options />
</file>

<file path="docs/appkit/next/core/resources.mdx">
---
title: Resources
---

import Resources from '../../shared/resources.mdx'

# Resources

<Resources />
</file>

<file path="docs/appkit/next/core/siwe.mdx">
---
title: One-Click Auth / SIWE
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Button from '../../../components/button'

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a new form of authentication that enables users to control their digital identity with their Ethereum account.
SIWE is a standard also known as [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as ["ReCaps"](https://eips.ethereum.org/EIPS/eip-5573). ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary.
WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## NextAuth

[NextAuth](https://next-auth.js.org/) is a complete open-source authentication solution for Next.js applications.
It is designed from the ground up to support Next.js and Serverless. We can use NextAuth with SIWE to handle users authentication and sessions.

## Installation

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```bash npm2yarn
npm i @web3modal/siwe next-auth
```

</TabItem>
<TabItem value="legacy" label="Legacy">

:::caution
For a better UX we recommend using One-Click Auth.
:::

Install the AppKit SIWE package, additionally we also recommend installing [siwe](https://docs.login.xyz/) which will abstract a lot of the required logic.

```bash npm2yarn
npm i @web3modal/siwe siwe next-auth
```

</TabItem>
</Tabs>

## Configure your SIWE Client

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```ts
import { getCsrfToken, signIn, signOut, getSession } from 'next-auth/react'
import type { SIWEVerifyMessageArgs, SIWECreateMessageArgs, SIWESession } from '@web3modal/siwe'
import { createSIWEConfig, formatMessage } from '@web3modal/siwe'
import { mainnet, sepolia } from 'viem/chains'

export const siweConfig = createSIWEConfig({
  getMessageParams: async () => ({
    domain: typeof window !== 'undefined' ? window.location.host : '',
    uri: typeof window !== 'undefined' ? window.location.origin : '',
    chains: [mainnet.id, sepolia.id],
    statement: 'Please sign with your account'
  }),
  createMessage: ({ address, ...args }: SIWECreateMessageArgs) => formatMessage(args, address),
  getNonce: async () => {
    const nonce = await getCsrfToken()
    if (!nonce) {
      throw new Error('Failed to get nonce!')
    }

    return nonce
  },
  getSession: async () => {
    const session = await getSession()
    if (!session) {
      throw new Error('Failed to get session!')
    }

    const { address, chainId } = session as unknown as SIWESession

    return { address, chainId }
  },
  verifyMessage: async ({ message, signature }: SIWEVerifyMessageArgs) => {
    try {
      const success = await signIn('credentials', {
        message,
        redirect: false,
        signature,
        callbackUrl: '/protected'
      })

      return Boolean(success?.ok)
    } catch (error) {
      return false
    }
  },
  signOut: async () => {
    try {
      await signOut({
        redirect: false
      })

      return true
    } catch (error) {
      return false
    }
  }
})
```

### `verifySignature`

Verify a SIWE signature.

```ts
import { verifySignature } from '@web3modal/siwe'

const isValid = await verifySignature({ address, message, signature, chainId, projectId })
```

### `getChainIdFromMessage`

Get the chain ID from the SIWE message.

```ts
import { getChainIdFromMessage } from '@web3modal/siwe'

const chainId = getChainIdFromMessage(message)
```

### `getAddressFromMessage`

Get the address from the SIWE message.

```ts
import { getAddressFromMessage } from '@web3modal/siwe'

const address = getAddressFromMessage(message)
```

</TabItem>
<TabItem value="legacy" label="Legacy">

With help of the [siwe package](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-frontend) we will create the required configuration for AppKit.

:::note
The nonce and verification process will be implemented in your backend. [Read more.](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-backend)
:::

Let's create a file to instantiate our SIWE configuration. For this example we will use `config/siwe.ts`

```ts
import { getCsrfToken, signIn, signOut, getSession } from 'next-auth/react'

import { SiweMessage } from 'siwe'

import type { SIWEVerifyMessageArgs, SIWECreateMessageArgs } from '@web3modal/siwe'
import { createSIWEConfig } from '@web3modal/siwe'

export const siweConfig = createSIWEConfig({
  createMessage: ({ nonce, address, chainId }: SIWECreateMessageArgs) =>
    new SiweMessage({
      version: '1',
      domain: window.location.host,
      uri: window.location.origin,
      address,
      chainId,
      nonce,
      // Human-readable ASCII assertion that the user will sign, and it must not contain `\n`.
      statement: 'Sign in With Ethereum.'
    }).prepareMessage(),
  getNonce: async () => {
    const nonce = await getCsrfToken()
    if (!nonce) {
      throw new Error('Failed to get nonce!')
    }

    return nonce
  },
  getSession,
  verifyMessage: async ({ message, signature }: SIWEVerifyMessageArgs) => {
    try {
      const success = await signIn('credentials', {
        message,
        redirect: false,
        signature,
        callbackUrl: '/protected'
      })

      return Boolean(success?.ok)
    } catch (error) {
      return false
    }
  },
  signOut: async () => {
    try {
      await signOut({
        redirect: false
      })

      return true
    } catch (error) {
      return false
    }
  }
})
```

</TabItem>
</Tabs>

## Set up your API route

Add `NEXTAUTH_SECRET` as an environment variable, it will be used to encrypt and decrypt user sessions. [Learn more.](https://next-auth.js.org/configuration/options#nextauth_secret)

Create your API route at `app/api/auth/[...nextauth]/route.ts`.

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```ts
import NextAuth from 'next-auth'
import credentialsProvider from 'next-auth/providers/credentials'
import {
  type SIWESession,
  verifySignature,
  getChainIdFromMessage,
  getAddressFromMessage
} from '@web3modal/siwe'

declare module 'next-auth' {
  interface Session extends SIWESession {
    address: string
    chainId: number
  }
}

const nextAuthSecret = process.env.NEXTAUTH_SECRET
if (!nextAuthSecret) {
  throw new Error('NEXTAUTH_SECRET is not set')
}

const projectId = process.env.NEXT_PUBLIC_PROJECT_ID
if (!projectId) {
  throw new Error('NEXT_PUBLIC_PROJECT_ID is not set')
}

const providers = [
  credentialsProvider({
    name: 'Ethereum',
    credentials: {
      message: {
        label: 'Message',
        type: 'text',
        placeholder: '0x0'
      },
      signature: {
        label: 'Signature',
        type: 'text',
        placeholder: '0x0'
      }
    },
    async authorize(credentials) {
      try {
        if (!credentials?.message) {
          throw new Error('SiweMessage is undefined')
        }
        const { message, signature } = credentials
        const address = getAddressFromMessage(message)
        const chainId = getChainIdFromMessage(message)

        const isValid = await verifySignature({ address, message, signature, chainId, projectId })

        if (isValid) {
          return {
            id: `${chainId}:${address}`
          }
        }

        return null
      } catch (e) {
        return null
      }
    }
  })
]

const handler = NextAuth({
  // https://next-auth.js.org/configuration/providers/oauth
  secret: nextAuthSecret,
  providers,
  session: {
    strategy: 'jwt'
  },
  callbacks: {
    session({ session, token }) {
      if (!token.sub) {
        return session
      }

      const [, chainId, address] = token.sub.split(':')
      if (chainId && address) {
        session.address = address
        session.chainId = parseInt(chainId, 10)
      }

      return session
    }
  }
})

export { handler as GET, handler as POST }
```

</TabItem>
<TabItem value="legacy" label="Legacy">

```ts
import { NextAuthOptions } from 'next-auth'
import credentialsProvider from 'next-auth/providers/credentials'
import { getCsrfToken } from 'next-auth/react'
import NextAuth from 'next-auth/next'

import type { SIWESession } from '@web3modal/siwe'
import { SiweMessage } from 'siwe'

declare module 'next-auth' {
  interface Session extends SIWESession {
    address: string
    chainId: number
  }
}

const nextAuthSecret = process.env.NEXTAUTH_SECRET
if (!nextAuthSecret) {
  throw new Error('NEXTAUTH_SECRET is not set')
}
// Get your projectId on https://cloud.walletconnect.com
const projectId = process.env.NEXT_PUBLIC_PROJECT_ID
if (!projectId) {
  throw new Error('NEXT_PUBLIC_PROJECT_ID is not set')
}

const authOptions: NextAuthOptions = {
  // https://next-auth.js.org/configuration/providers/oauth
  secret: nextAuthSecret,
  providers: [
    credentialsProvider({
      name: 'Ethereum',
      credentials: {
        message: {
          label: 'Message',
          type: 'text',
          placeholder: '0x0'
        },
        signature: {
          label: 'Signature',
          type: 'text',
          placeholder: '0x0'
        }
      },
      async authorize(credentials, req) {
        try {
          if (!credentials?.message) {
            throw new Error('SiweMessage is undefined')
          }
          const siwe = new SiweMessage(credentials.message)
          const nonce = await getCsrfToken({ req: { headers: req.headers } })
          const result = await siwe.verify({
            signature: credentials?.signature || '',
            nonce
          })
          if (result.success) {
            return {
              id: `eip155:${siwe.chainId}:${siwe.address}`
            }
          }

          return null
        } catch (e) {
          return null
        }
      }
    })
  ],
  session: {
    strategy: 'jwt'
  },
  callbacks: {
    session({ session, token }) {
      if (!token.sub) {
        return session
      }

      const [, chainId, address] = token.sub.split(':')
      if (chainId && address) {
        session.address = address
        session.chainId = parseInt(chainId, 10)
      }

      return session
    }
  }
}

const handler = NextAuth(authOptions)
export { handler as GET, handler as POST }
```


</TabItem>
</Tabs>

<Button name="Learn More" url="https://next-auth.js.org/" />

## Initialize AppKit with your `siweConfig`.

```js
createWeb3Modal({
  //..
  siweConfig
})
```

### SIWE Config reference

```ts
interface SIWEConfig {
  // Required
  getNonce: () => Promise<string>
  createMessage: (args: SIWECreateMessageArgs) => string
  verifyMessage: (args: SIWEVerifyMessageArgs) => Promise<boolean>
  getSession: () => Promise<SIWESession | null>
  signOut: () => Promise<boolean>

  // Optional
  onSignIn?: (session?: SIWESession) => void
  onSignOut?: () => void
  // Defaults to true
  enabled?: boolean
  // In milliseconds, defaults to 5 minutes
  nonceRefetchIntervalMs?: number
  // In milliseconds, defaults to 5 minutes
  sessionRefetchIntervalMs?: number
  // Defaults to true
  signOutOnDisconnect?: boolean
  // Defaults to true
  signOutOnAccountChange?: boolean
  // Defaults to true
  signOutOnNetworkChange?: boolean
}
```

### Required

#### getNonce

The getNonce method functions as a safeguard against spoofing, akin to a CSRF token. The siwe package provides a generateNonce() helper, or you can utilize an existing CSRF token from your backend if available.

#### createMessage

The official siwe package offers a straightforward method for generating an EIP-4361-compatible message, which can subsequently be authenticated using the same package. The nonce parameter is derived from your getNonce endpoint, while the address and chainId variables are sourced from the presently connected wallet.

#### verifyMessage

The `verifyMessage` method should lean on the siwe package's new

```js
SiweMessage(message).validate(signature)
```

to ensure the message is valid, has not been tampered with, and has been appropriately signed by the wallet address.

#### getSession

The backend session should store the associated address and chainId and return it via the `getSession` method.

#### signOut

The users session can be destroyed calling `signOut`.

### Optional

#### onSignIn `(session?: SIWESession) => void`

Callback when user signs in.

#### onSignOut `() => void`

Callback when user signs out.

#### enabled `boolean` - defaults to `true`

Whether or not to enable SIWE. Defaults to true.

#### nonceRefetchIntervalMs `number` - defaults to `300000`ms (5 minutes)

How often to refetch the nonce, in milliseconds.

#### sessionRefetchIntervalMs `number` - defaults to `300000`ms (5 minutes)

How often to refetch the session, in milliseconds.

#### signOutOnDisconnect `boolean` - defaults to true

Whether or not to sign out when the user disconnects their wallet.

#### signOutOnAccountChange `boolean` - defaults to true

Users will be signed out and redirected to the SIWE view to sign a new message in order to keep the SIWE session in sync with the connected account.

#### signOutOnNetworkChange `boolean` - defaults to true

Users will be signed out and redirected to the SIWE view to sign a new message in order to keep the SIWE session in sync with the connected account/network.
</file>

<file path="docs/appkit/next/core/theming.mdx">
import Theming from '../../shared/theming.mdx'

# Theming

<Theming />
</file>

<file path="docs/appkit/next/ethers/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In this example we will create a new file called `context/web3modal.tsx` outside our app directory and set up the following configuration

```tsx
'use client'

import { createWeb3Modal, defaultConfig } from '@web3modal/ethers/react'

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// 3. Create a metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // origin must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}
// 4. Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1 // used for the Coinbase SDK
})

// 5. Create a AppKit instance
createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export function AppKit({ children }) {
  return children
}
```

Next, in your `app/layout.tsx` or `app/layout.jsx` file, import the custom AppKit component.

```tsx
import './globals.css'

import { AppKit } from '../context/web3modal'

export const metadata = {
  title: 'AppKit',
  description: 'AppKit Example'
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AppKit>{children}</AppKit>
      </body>
    </html>
  )
}
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/next/ethers/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Component">

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { useWeb3Modal } from '@web3modal/ethers/react'

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useWeb3Modal()

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: 'Networks' })}>Open Network Modal</button>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/next/ethers/hooks.mdx">
import Button from '../../../components/button'

### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/ethers/react'

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()

  //...
}
```

### useSwitchNetwork

```tsx
import { useSwitchNetwork } from '@web3modal/ethers/react'

const chainId = 137

const { switchNetwork } = useSwitchNetwork()

switchNetwork(chainId)
```

### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from 'ethers'
import { useWeb3ModalProvider } from '@web3modal/ethers/react'

function Components() {
  const { walletProvider } = useWeb3ModalProvider()

  async function onSignMessage() {
    const provider = new BrowserProvider(walletProvider)
    const signer = await provider.getSigner()
    const signature = await signer?.signMessage('Hello AppKit Ethers')
    console.log(signature)
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>
}
```

### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/ethers/react'

function Components() {
  const { error } = useWeb3ModalError()

  //...
}
```

<Button
  name="Learn More About Ethers"
  url="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="docs/appkit/next/ethers5/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In this example we will create a new file called `context/web3modal.tsx` outside our app directory and set up the following configuration

```tsx
'use client'

import { createWeb3Modal, defaultConfig } from '@web3modal/ethers5/react'

// 1. Get projectId at https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// 3. Create a metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // origin must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}

// 4. Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1 // used for the Coinbase SDK
})

// 5. Create a AppKit instance
createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export function AppKit({ children }) {
  return children
}
```

Next, in your `app/layout.tsx` or `app/layout.jsx` file, import the custom Web3Modal component.

```tsx
import './globals.css'

import { AppKit } from '../context/web3modal'

export const metadata = {
  title: 'AppKit',
  description: 'AppKit Example'
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AppKit>{children}</AppKit>
      </body>
    </html>
  )
}
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/next/ethers5/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../core/components.mdx) or build your own button with AppKit [**hooks**](../core/hooks.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Component">

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { useWeb3Modal } from '@web3modal/ethers/react'

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useWeb3Modal()

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: 'Networks' })}>Open Network Modal</button>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/next/notifications/authorization-signatures/all-apps.mdx">
# Signing the message: ‚ÄúI further authorize this app to view and manage my notifications for ALL apps‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you may be presented with a signature request that reads the following message:

> I further authorize this app to view and manage my notifications for ALL apps. Read more at https://walletconnect.com/notifications-all-apps

For any signature request, it‚Äôs critical that you always read the message attached before signing in order to fully understand the permissions you‚Äôre granting.

Take caution when signing this request as doing so will allow the app to:

- Subscribe you to notifications from any app
- Manage your notifications for any app
- View your notifications from any app

The app will not be able to:

- Sign blockchain transactions or additional messages

Typically, apps you subscribe to for notifications will send a slightly [different request](this-app) that asks you to only authorize them to manage notifications _for that app only_ upon signing. You should only ever be presented with the message shown in the example above when an app requires wider access to your subscriptions and messages.

A common example of this would be an app that enables you to view notifications and messages from multiple apps, like a wallet or the [Web3Inbox.com app](https://app.web3inbox.com).

Always be cautious when granting this permission to an app, and ensure that you‚Äôre familiar with the app sending the request.

## Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/all-apps/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/all-apps/message.jpg" />
</div>
</file>

<file path="docs/appkit/next/notifications/authorization-signatures/overview.mdx">
# Authorization Signatures

When a user wants to enable notifications with an app or wallet, they must sign a SIWE message with their account granting that app access to view and manage their notifications. The SIWE message varies depending on whether the app is requesting access to manage all app notifications, or just that app's notifications. Below are the two possible SIWE messages the user would be requested to sign:

- [I authorize [...] this app](this-app)
- [I authorize [...] all apps](all-apps)
</file>

<file path="docs/appkit/next/notifications/authorization-signatures/this-app.mdx">
# Signing the message: ‚ÄúI further authorize this app to send me notifications‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you'll likely be presented with a signature request that reads the following message:

> I further authorize this app to send me notifications. Read more at https://walletconnect.com/notifications

For any signature request, it‚Äôs critical that you always read the message attached before signing to fully understand the permissions you‚Äôre granting.

By signing this request, you‚Äôre allowing the app to:

- Subscribe you to notifications from only this app
- Manage your notifications for only this app
- View your notifications from only this app

The app will not be able to:

- Sign blockchain transactions or additional messages
- Subscribe to, manage, or view notifications from other apps

Most apps that send notifications using Web3Inbox will request for you to sign this message&mdash;this will allow the app to simply interact with you directly. If you wish to opt-in to receive notifications from this app, signing this message will enable you to do so.

If you‚Äôve signed up to notifications but have received a different message, head [here](all-apps) to learn about other scenarios in which you may receive a signature request regarding notifications.

### Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/this-app/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/this-app/message.jpg" />
</div>
</file>

<file path="docs/appkit/next/notifications/embedded-widget/about.mdx">
# Introduction

** Embedded widget **: Drop-in widget for fast integration. Limited customization.

## Installation

```bash npm2yarn
npm i @web3inbox/core @web3inbox/widget-react
```

## Next Steps

Now that you've installed Web3Inbox Widget, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the library.
</file>

<file path="docs/appkit/next/notifications/embedded-widget/usage.mdx">
import CloudBanner from '../../../../components/CloudBanner'

# Usage

<CloudBanner />

Using Embedded Widget is the way to go if you want a ready made UI that's ready for plug-and-play.

## Getting Started

```ts
import { W3iWidget, useManageView } from "@web3inbox/widget-react";
import "@web3inbox/widget-react/dist/compiled.css";
...

const { open } = useManageView()
open();

return (
	<W3iWidget
		account="eip155:1:0x..."
		projectId="7a..."
		onSign={yourSignFunction}
		onConnect={connectFunction}
	/>
)

```
</file>

<file path="docs/appkit/next/notifications/frontend-integration/api.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CloudBanner from '../../../../components/CloudBanner'

import Initialization from '../../../shared/notifications/frontend-integration/api/initialization/react.mdx'
import SettingAccount from '../../../shared/notifications/frontend-integration/api/setting-account/react.mdx'
import Registering from '../../../shared/notifications/frontend-integration/api/registering-accounts/react.mdx'
import Managing from '../../../shared/notifications/frontend-integration/api/managing-subscription/react.mdx'
import ManagingNotifications from '../../../shared/notifications/frontend-integration/api/managing-notifications/react.mdx'
import Types from '../../../shared/notifications/frontend-integration/api/types/react.mdx'
import RegisteringPush from '../../../shared/notifications/frontend-integration/api/registering-push/react.mdx'
import Events from '../../../shared/notifications/frontend-integration/api/events/react.mdx'

# API

## Initialization

<Initialization/>

## Managing Account

### Setting account for web3inbox

<SettingAccount/>

### Registering an account

<Registering/>

## Managing Subscription

<Managing/>

## Managing Notifications

<ManagingNotifications/>

## Notification Types

<Types/>

## Registering for Device Push Notifications

<RegisteringPush/>

## Listening For Events

<Events/>
</file>

<file path="docs/appkit/next/notifications/frontend-integration/examples.mdx">
# Examples

- Our production [GM App](https://gm.walletconnect.com) which sends daily "gm!" notifications to all subscribers.
- [React GM Dapp](https://github.com/WalletConnect/gm-dapp) - a Web3Inbox Dapp using React, Typescript, Next.js & Ethers.
- Bare bones [template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) demonstrating basic functionality in an easy to base from way.
</file>

<file path="docs/appkit/next/notifications/frontend-integration/migration-guide.mdx">
import Migration from '../../../shared/notifications/frontend-integration/migration/react.mdx'

# Migration Guide

## General Migration notes

- `isLimited` flag has been removed in favor of `allApps` flag. They essentially mean the opposite thing.
- Deleting messages is no longer possible
- Messages are now stored on notify server and can be paged
- Registration is more flexible since it is now split into 2 functions

## Migrating from 0.x to 1.0.0

<Migration/>
</file>

<file path="docs/appkit/next/notifications/frontend-integration/usage.mdx">
import Installation from '../../../shared/notifications/frontend-integration/usage/installation/react.mdx'
import Example from '../../../shared/notifications/frontend-integration/usage/example/react.mdx'

# Usage

AppKit Notifications provides you the building blocks necessary to allow users to subscribe, receive notifications, and manage notification preferences, all from your app's UI. The Web3Inbox SDK supports both React hooks and JavaScript-based integrations.

Before begin using Web3Inbox, you will first need to [setup your project](../cloud-setup) to send notifications.

## Installation

<Installation/>

## Example Usage

This basic example demonstrates how to use the AppKit Notifications to subscribe to notifications and receive them in your app. Refer to the [API Reference](./api) for more details on the available methods.

<Example/>

## UX Guidelines

For the best user experience we have several recommendations on how to build the Web3Inbox flows into your app:

- Have an explicit opt-in UI to subscribe to notifications. Some users may not want to receive notifications, and enabling notifications requires the user to sign a message with their blockchain account. Enabling notifications should be optional, and if they do enable them they should be told that they will need to sign a message to enable this.
- Have a button to unsubscribe from notifications once they are enabled. Users may want to stop receiving notifications, so you should have a button to unsubscribe from notifications if the user wants to.
- Make use of [notification types](../cloud-setup#notification-types). These allow the user fine-grained control over what types of notifications they want to receive from your app. These allow users to only unsubscribe from the specific notifications they are no longer interested in, rather than needing to unsubscribe from your entire app. Your app should include functionality to manage notification preferences.
</file>

<file path="docs/appkit/next/notifications/backend-integration.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Backend Integration

Once an account is subscribed to your app's notifications you can test sending notifications to the account. You can subscribe in your app directly with our [Frontend Integration](frontend-integration/usage), or with one of the below testing options.

We recommend testing notifications with the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to your phone. You can also try one of our sample wallets:

- [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
- [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

## Authentication

To send notifications and access all subscriber information for your dapp, you will need your Notify API Secret and project ID.

You can find the Notify API Secret under the Notify API section of the APIs tab of your project on [WalletConnect Cloud](https://cloud.walletconnect.com). Follow steps on the [Cloud Setup](cloud-setup) page to configure this. This secret allows publishing notifications to any account subscribed to your app, so should not be published and should only be used by your app backend.

## Sending notifications

Only plaintext is supported, and newlines are ignored.

To send a notification notification you can call the `/notify` endpoint. This endpoint supports the following fields:

- `type` - The Notification type ID copied from WalletConnect Cloud.
- `title` - The title of the notification. Max 64 characters.
- `body` - The body of the notification containing more detail. Max 255 characters.
- `url` (optional) - A URL attached to the notification that the user can navigate to. Max 255 characters.
- `accounts` - A list of [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) account IDs for which to send the notification to. Max 500 accounts per request. Also see the [rate limits](#rate-limits) below.
- `notification_id` (optional) - An idempotency key of arbitrary format used to dedup multiple requests. Max 255 characters. Multiple calls with the same `notification_id` will use the first call's `notification` content, but will send to any additional account IDs listed in `accounts`.

```typescript
type RequestBody = {
  notification_id?: string | null
  notification: {
    type: string
    title: string
    body: string
    url?: string | null
  }
  accounts: string[]
}
```

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/notify`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    notification: {
      type: 'a1e53b95-18e5-4af8-9f03-9308ec87b687',
      title: 'The price of Ethereum has risen',
      body: 'The price of Ethereum has gone up 10%',
      url: 'https://app.example.com'
    },
    accounts: ['eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029']
  })
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/<PROJECT_ID>/notify' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "notification": {
      "type": "a1e53b95-18e5-4af8-9f03-9308ec87b687",
      "title": "The price of Ethereum has risen",
      "body": "The price of Ethereum has gone up 10%",
      "url": "https://app.example.com"
    },
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029"
    ]
  }'
```

</TabItem>

</Tabs>

## Get subscribers

You can tell if an account is subscribed and get information about subscribers using the `/v1/<project-id>/subscribers` endpoint. You can provide up to 100 accounts in the request.

If the account is subscribed, it will be returned as a key in the response along with a list of subscribed notification types as the value. If the account is not a subscriber, it will not be returned in the response.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const requestBody: RequestBody = {
  accounts: [
    'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029',
    'eip155:1:0x0000000000000000000000000000000000000000'
  ]
}

const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/subscribers`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
  body: JSON.stringify(requestBody)
})

const subscribers: ResponseBody = await response.json()

type RequestBody = {
  // Max 100 accounts
  accounts: string[]
}
type ResponseBody = {
  [account: string]: Subscriber
}
type Subscriber = {
  notification_types: string[]
}
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029",
      "eip155:1:0x0000000000000000000000000000000000000000"
    ]
  }'
```

</TabItem>

</Tabs>

Example response:

```jsonc
{
  "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029": {
    "notification_types": ["4d1c97ad-c182-4097-8f2c-8f80c0674df2"]
  }
}
```

## Get all subscribers

:::caution
This endpoint will download _all_ subscribers of your app, which is an expensive operation and can take several seconds to complete. Because of this, it has a low rate limit.
:::

You can get a list of all of the currently-subscribed accounts by calling the `/<project-id>/subscribers` endpoint.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/subscribers`, {
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
const subscribers: string[] = await response.json()
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl 'https://notify.walletconnect.com/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Mark all notifications as read

Unless marked as read by an app frontend, notifications will always be "unread". Because of this, when you
initially add support for displaying unread status or unread count to your frontend, users that have received
notifications in the past will have notifications display as "unread" even if they already have seen them.
This can potentially be an undesireable user experience.

To mitigate this problem, you can make a one-time call to the `/v1/<project-id>/mark-all-as-read` API endpoint
which will mark all existing notifications as read. Notifications marked as read in this way will not contribute
to read rate analytics. After you deploy your integration of unread states, you can call this endpoint to
reset the unread state for all of your existing notifications.

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/mark-all-as-read`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/mark-all-as-read' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Rate limits

To protect our system and subscribers, various limits and rate limits are in-place.

Rate limits are implemented as [token bucket](https://en.wikipedia.org/wiki/Token_bucket) and contain both rate and burst amounts. On average, a rate of requests can be made. However, since real-world applications often make requests in bursts, this fixed rate can be surpassed temporarily up to the burst amount, provided the app subsequently makes requests below the average in order to recover its bursting capability.

- `POST /<project-id>/notify`:
  - Each app can send 2 notifications per hour to an account, with a burst up to 50. Accounts that have been rate limited will be returned in the request response. Exceptions may be made on a per-project basis for special circumstances.
  - Each app can call this endpoint 2 times per second with a burst up to 20. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/subscribers`
  - Each app can call this endpoint 100 times per second with a burst up to 100. Rate limited requests will return a 429 status code.
- `GET /<project-id>/subscribers`
  - Each app can call this endpoint 1 time every 5 minutes with a burst up to 2. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/mark-all-as-read`
  - Each app can call this endpoint 1 time per hour with a burst up to 5. Rate limited requests will return a 429 status code.
</file>

<file path="docs/appkit/next/notifications/cloud-sending.mdx">
import useBaseUrl from '@docusaurus/useBaseUrl'

# Sending with Cloud

You can send notifications to subscribed users easily in [WalletConnect Cloud](https://cloud.walletconnect.com). Sending to users involves targeting particular [notification types](./cloud-setup#notification-types) who will receive your notification if they have not opted-out. You can specify a title and body for the notification, as well as a call-to-action link which users will be taken to when clicking on the notification.

Users can subscribe to your app in [several places](overview#subscribing-and-receiving-notifications) including the [Web3Inbox.com app](https://app.web3inbox.com), in your app with our [frontend SDK](frontend-integration/usage), or in supporting wallets.

To send notifications, you can use the utility provided in [WalletConnect Cloud](https://cloud.walletconnect.com) under the Notify API section:

1. In the APIs tab of your project, navigate to the Notify API section. You should see a banner with a link to the Send Notification playground.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground.png')} />

1. This allows you to send notifications to your subscribers. After you select the associated project, you can select the notification type, title, body, and link to send to your subscribers.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground-send.png')} />
</file>

<file path="docs/appkit/next/notifications/cloud-setup.mdx">
import CloudBanner from '../../../components/CloudBanner'
import useBaseUrl from '@docusaurus/useBaseUrl'

# Cloud Setup

This page explains the configuration required in order to obtain a Notify API Secret and configure your project to send notifications.

For a quick start to experiment with, you can try the [web3inbox template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) and following the steps in the README.

<CloudBanner />

## Domain to use

It is important to understand what domain you are using for your project as you are required to host a static file (the `did.json` file) on this domain before being able to use Notify API. The [WalletConnect Cloud](https://cloud.walletconnect.com) and clients receiving and managing your notifications use this file to authenticate that your domain is associated with the source of the notifications.

You can pick 1 domain and this is configured in the Dapp URL field of the Notify API section of the [WalletConnect Cloud](https://cloud.walletconnect.com). You may change your domain at any time, as long as you properly host the new `did.json` file there. Note that only one project may use a given domain at the same time.

During development it is optional to use your production domain for testing. Instead, you can use a staging domain, or even a entirely separate domain e.g. Vercel test site. However, once you move to production you will need to update your domain to your production domain and host a new file there.

Note that the file must be hosted on a real, publicly accessible, domain in order to verify its legitimacy. The use of `localhost` or other local addresses is not allowed.

## Dapp name, description, and logo

The dapp name, description, and logo are displayed in wallets that integrate Notify API as well as in the [Web3Inbox.com app](https://app.web3inbox.com). These details should be provided for the best user experience and to help the user identify your app.

## Notification types

Notification types are an important feature of Notify API and are a way for a user to have control over what types of notifications they receive. Users can change their notification types at any time in your app, their wallet, or the [Web3Inbox.com app](https://app.web3inbox.com). When sending notifications, you must use one of these configured notification types which you reference in code by its UUID.

Notification types are configured with a name, description, and icon which allow the user understand what types of notifications they would receive for that type. When a user receives a push notification on their device, they will see the icon that is configured with the notification type. Examples of notification types may include "Account updates" or "Service updates".

:::info
By default users are subscribed to all available notification types. However, it's worth nothing that if you add new notification types later users will not be automatically subscribed to them. If you have new notification types available, you may consider sending a notification informing users of this new available notification type and ask users to enable it. You may also add functionality to your app frontend to subscribe the user to the new notification type when they visit your app. Because of the additional effort in subscribing users to notification types after they initially subscribe, it is worth considering in advance what notification types you may need in the future.
:::

## Setup steps

### Navigating to Notify API section

In [WalletConnect Cloud](https://cloud.walletconnect.com), navigate to the APIs tab of your project.

<img className="image-margin" src={useBaseUrl('/img/w3i/1.png')} />

### Configuring Notify API

Under Notify API > Configuration > `DAPP INFORMATION`, fill in the Dapp URL field. This is the domain of your app that you will use to publish notifications.

<img className="image-margin" src={useBaseUrl('/img/w3i/dapp-info.png')} />

### Adding Notification Image and Types

Under the same section, next to Notification types, click on the "Add Notification Type" button and add a title, notification image and description for your notification type. This is the type of notification that your app will publish.

For example, if you are going to send promotional content as notification, you might want to add a notification type called "Promotional" with a description "Promotional content from the XYZ Team.".
You can also add a relevant image for the notification type.

<img className="image-margin" src={useBaseUrl('/img/w3i/notification-type.png')} />

### Saving Changes

Optionally, you can add a logo and description for your project. This will be shown to users when they subscribe to your app. Click "Save" to save your changes.

### Notify Secret

Take note of your new Notify API Secret. You will need this to publish notifications. This secret
allows publishing notifications to any account subscribed to your app, so should not be published
and should only be used by your app backend.

<img className="image-margin" src={useBaseUrl('/img/w3i/3.png')} />

### Hosting did.json file

Next, you will need to host `did.json` file on this page at the `/.well-known/` directory of your public URL. Please also ensure that your application has CORS enabled. An example is linked [here.](https://github.com/WalletConnect/gm-dapp/blob/main/next.config.js)

- Download `did.json` (click on `DID:WEB` section to show the download button ) and host it at, for example, `https://app.example.com/.well-known/did.json`
  <img className="image-margin" src={useBaseUrl('/img/w3i/did.png')} />

### Enabling Welcome Notifications

Welcome Notifications are notifications that are sent to users when they subscribe to your app. This is a great way to welcome users to your app and explain what types of notifications they will receive.

To enable Welcome Notifications, switch on the toggle in the Welcome Notifications section of your WalletConnect Cloud project after adding relevant Notification Type, Title, Body & Link.

<img className="image-margin" src={useBaseUrl('/img/w3i/welcome.png')} />

### Enabling Notify API

Once all changes have been saved and the `did.json` file has been deployed successfully, switch on the toggle switch in the Notify API section of your WalletConnect Cloud project. If everything is configured correctly, you should see a success toast: "Notify configuration successfully verified"

<img className="image-margin" src={useBaseUrl('/img/w3i/5.png')} />
<img className="image-margin" src={useBaseUrl('/img/w3i/6.png')} />

## Send Notifications in Cloud

Once you have completed the setup steps, you can now send notifications to users who have subscribed to your app. [Read more](./cloud-sending)

## Next steps

1. Now you are ready for accounts to subscribe to your app and send notifications to them using your Notify API Secret or with WalletConnect Cloud.

   - Read more on [sending notifications with WalletConnect Cloud](./cloud-sending)
   - Read more on [frontend integration](./frontend-integration/usage)
   - Read more on [backend integration](./backend-integration)

1. If you haven't already, [verify your apps domain](../cloud/verify) for improved security.



1. Navigate to the `Metrics` tab and select Web3Inbox from the dropdown to access analytics for your app. [Learn more about Web3Inbox Analytics](../cloud/analytics#web3inbox).

   <img className="image-margin" src={useBaseUrl('/img/w3i/metrics.png')} />
</file>

<file path="docs/appkit/next/notifications/demo.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Demo

## Try AppKit Notifications

The fastest way to try AppKit Notifications is to go to [app.web3inbox.com](https://app.web3inbox.com) and try subscribing to some dapps. The [Web3Inbox.com app](https://app.web3inbox.com) is a universal inbox for web3 users to access all their notifications in one place.

- [Web3Inbox.com app](https://app.web3inbox.com)

Or access the repo at [github.com/WalletConnect/web3inbox](https://github.com/WalletConnect/web3inbox/).

## Native notifications

AppKit Notifications also supports native notifications on iOS and Android. To try native notifications, you can use the [Web3Inbox.com app](https://app.web3inbox.com) and subscribe to dapps or build one of our sample apps.

A wallet that supports Notify is required to receive notifications.

## Wallet notifications

To try wallet notifications on a iOS or Android device, use a wallet that supports Notify. Alternatively, try building one of our sample apps, or grab a sample wallet preview build from Testflight or Firebase.

<PlatformTabs
	groupId="w3iw"
	activeOptions={["ios", "android", "web"]}
>

<PlatformTabItem value="web">
- [React Native](../../../walletkit/react-native/notifications/notify/installation)

</PlatformTabItem>

<PlatformTabItem value="ios">

- [Swift](../../../walletkit/ios/notifications/notify/installation)
- [Testflight](https://testflight.apple.com/join/09bTAryp)

</PlatformTabItem>

<PlatformTabItem value="android">

- [Kotlin](../../../walletkit/android/notifications/notify/installation)
- [Firebase](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/next/notifications/overview.mdx">
# Introduction

AppKit Notifications provides a toolkit for integrating Web3 notification features into apps. AppKit Notifications can be used to send notifications from your app directly to wallets.

This SDK utilizes WalletConnect's Notify API and is designed for Web3 scenarios, providing event-based notifications for activities like DAO votes, DeFi transaction alerts, and updates for NFT holders. Apps can send notifications to subscribed accounts, and users can receive and view their notifications in a supporting wallet, in the [Web3Inbox.com app](https://app.web3inbox.com), or in the app's frontend. Users can also discover Notify-compatible apps in their wallet or the [Web3Inbox.com app](https://app.web3inbox.com) to subscribe to.

AppKit Notifications is not to be confused with the [Web3Inbox.com app](https://app.web3inbox.com) which allows users to receive and manage their notifications from all apps, as they would in a wallet.

![Web3Inbox](/assets/web3inbox/w3i-hero.png)

## Getting Started

AppKit Notifications can be added to your app in a few steps:

- [Setup your project](cloud-setup) to send authenticated notifications.
- Use our [frontend SDK](frontend-integration/usage) to enable users to subscribe to notifications in your app.
- Finally, use [WalletConnect Cloud](cloud-sending) or our [API in your backend](backend-integration) to send notifications to subscribed users.

## Overview

Some of the key features of AppKit Notifications include:

- **Device push notifications:** Push notifications to the user's wallet (if it supports Notify API) or the [Web3Inbox.com app](https://app.web3inbox.com).
- **Notification history:** Notifications are stored and can be accessed from any device.
- **Spam protection/subscription control.** Using notification types, subscribers can opt-out of certain notification types they do not want to receive.
- **Tracking read status across devices.**

## Subscribing and receiving notifications

Users can receive notifications in several places:

- In the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to the user's phone
- In your app's frontend using our [frontend SDK](frontend-integration/usage)
- Natively in their wallet if the wallet supports Notify API.
  - You can also test with one of our sample wallets:
    - [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
    - [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

Users can also subscribe to notifications in all of the above locations too. To be discoverable in the Web3Inbox.com app or in wallets, apps must submit an explorer listing.

## Try it out

See the [demo section](demo) for sample apps and the Web3Inbox universal inbox app.

## FAQ

### What chains does AppKit Notifications support?

AppKit Notifications supports EOA accounts on all `eip155` (EVM) chains, and smart accounts on all `eip155` chains that our Blockchain API [supports](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md). We have plans to expand support in the future.
</file>

<file path="docs/appkit/next/onboarding/ens.mdx">
# ENS Provider
</file>

<file path="docs/appkit/next/onboarding/graduation.mdx">
# Graduation
</file>

<file path="docs/appkit/next/onboarding/smart-accounts.mdx">
---
title: Smart Accounts
---

import SmartAccount from '../../shared/smart-accounts.mdx'

<SmartAccount />
</file>

<file path="docs/appkit/next/onboarding/socials.mdx">
---
title: Email & Socials
---

import Socials from '../../shared/socials.mdx'

<Socials />
</file>

<file path="docs/appkit/next/solana/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

AppKit Solana provides a set of React components and hooks to easily connect Solana wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
// App.tsx

import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/react'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  name: 'AppKit',
  description: 'AppKit Solana Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

const solanaConfig = defaultSolanaConfig({
  metadata,
  chains,
  projectId
})

// 3. Create modal
createWeb3Modal({
  solanaConfig,
  chains,
  projectId,
  wallets: [
      // Solana wallet adapters (check Custom connectors for more info)
  ]
})

export default function App() {
  return <YourApp />
}
```
</file>

<file path="docs/appkit/next/solana/about/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to this [demo app](https://appkit-solana.vercel.app/).

```tsx
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js'
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'

function deserializeCounterAccount(data?: Buffer): { count: number } {
  if (data?.byteLength !== 8) {
    throw Error('Need exactly 8 bytes to deserialize counter')
  }

  return {
    count: Number(data[0])
  }
}

const { address, currentChain } = useWeb3ModalAccount()
const { walletProvider, connection } = useWeb3ModalProvider()

async function onIncrementCounter() {
  const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy')

  const counterKeypair = Keypair.generate()
  const counter = counterKeypair.publicKey

  const balance = await connection.getBalance(walletProvider.publicKey)
  if (balance < LAMPORTS_PER_SOL / 100) {
    throw Error('Not enough SOL in wallet')
  }

  const COUNTER_ACCOUNT_SIZE = 8
  const allocIx: TransactionInstruction = SystemProgram.createAccount({
    fromPubkey: walletProvider.publicKey,
    newAccountPubkey: counter,
    lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
    space: COUNTER_ACCOUNT_SIZE,
    programId: PROGRAM_ID
  })

  const incrementIx: TransactionInstruction = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      {
        pubkey: counter,
        isSigner: false,
        isWritable: true
      }
    ],
    data: Buffer.from([0x0])
  })

  const tx = new Transaction().add(allocIx).add(incrementIx)

  tx.feePayer = walletProvider.publicKey
  tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash

  await walletProvider.signAndSendTransaction(tx, [counterKeypair])

  const counterAccountInfo = await connection.getAccountInfo(counter, {
    commitment: 'confirmed'
  })

  if (!counterAccountInfo) {
    throw new Error('Expected counter account to have been created')
  }

  const counterAccount = deserializeCounterAccount(counterAccountInfo?.data)

  if (counterAccount.count !== 1) {
    throw new Error('Expected count to have been 1')
  }

  console.log(`[alloc+increment] count is: ${counterAccount.count}`);
}
```
</file>

<file path="docs/appkit/next/solana/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our default web components or build your own logic using AppKit hooks.

<Tabs>
<TabItem value="components" label="Components">

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { useWeb3Modal } from '@web3modal/solana/react'

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useWeb3Modal()

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: 'Networks' })}>Open Network Modal</button>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/next/solana/hooks.mdx">
import Button from '../../../components/button'

### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/solana/react'

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()

  //...
}
```

### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'

function SignMessage() {
  // 0. Get account and provider
  const { address } = useWeb3ModalAccount()
  const { walletProvider } = useWeb3ModalProvider()

  // 1. Create a function to sign a message
  async function onSignMessage() {
    try {
      if (!walletProvider || !address) {
        throw Error('user is disconnected')
      }

      // 2. Encode message and sign it
      const encodedMessage = new TextEncoder().encode('Hello from AppKit')
      const signature = await walletProvider.signMessage(encodedMessage)

      console.log(signature)
    } catch (err) {
      // Handle Error Here
    }
  }

  // 3. Create a button to trigger the function
  return <button onClick={onSignMessage}>Sign Message</button>
}
```

### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/solana/react'

function Components() {
  const { error } = useWeb3ModalError()

  //...
}
```
</file>

<file path="docs/appkit/next/transactions/onramp.mdx">
---
title: On-Ramp
---

import Onramp from '../../shared/onramp.mdx'

# On-Ramp

<Onramp />
</file>

<file path="docs/appkit/next/transactions/swaps.mdx">
import Swaps from '../../shared/swaps.mdx'

# Swaps

<Swaps/>
</file>

<file path="docs/appkit/next/transactions/transaction-history.mdx">
# Transaction History
</file>

<file path="docs/appkit/next/wagmi/about/implementation.mdx">
For a quick integration you can use `defaultWagmiConfig` function which wraps Wagmi's [`createConfig`](https://wagmi.sh/core/api/createConfig) function with a predefined configuration.
This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api.mdx) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

### Wagmi config

Create a new file for your Wagmi configuration, since we are going to be calling this function on the client and the server it cannot live inside a file with the 'use client' directive.

For this example we will create a file called `config/index.tsx` outside our app directory and set up the following configuration

```tsx
import { defaultWagmiConfig } from '@web3modal/wagmi/react/config'

import { cookieStorage, createStorage } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

// Get projectId from https://cloud.walletconnect.com
export const projectId = process.env.NEXT_PUBLIC_PROJECT_ID

if (!projectId) throw new Error('Project ID is not defined')

export const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

// Create wagmiConfig
const chains = [mainnet, sepolia] as const
export const config = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  ssr: true,
  storage: createStorage({
    storage: cookieStorage
  }),
})
```

:::info

- Notice that we are using here the [recommended configuration from Wagmi for SSR](https://wagmi.sh/react/guides/ssr).
- Using cookies is completely optional and by default Wagmi will use `localStorage` instead if the `storage` param is not defined.
- The `ssr` flag will delay the hydration of the Wagmi's store to avoid hydration mismatch errors.
  :::

<br />

### Context Provider

Let's create now a context provider that will wrap our application and initialized AppKit (`createWeb3Modal` needs to be called inside a React Client Component file).

In this example we will create a file called `context/index.tsx` outside our app directory and set up the following configuration

```tsx
'use client'

import React, { ReactNode } from 'react'
import { config, projectId, metadata } from '@/config'

import { createWeb3Modal } from '@web3modal/wagmi/react'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

import { State, WagmiProvider } from 'wagmi'

// Setup queryClient
const queryClient = new QueryClient()

if (!projectId) throw new Error('Project ID is not defined')

// Create modal
createWeb3Modal({
  metadata,
  wagmiConfig: config,
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export default function AppKitProvider({
  children,
  initialState
}: {
  children: ReactNode
  initialState?: State
}) {
  return (
    <WagmiProvider config={config} initialState={initialState}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  )
}
```

### Layout

Next, in our `app/layout.tsx` file, we will import our `AppKitProvider` component and call [the Wagmi's function `cookieToInitialState`.](https://wagmi.sh/react/guides/ssr#_2-hydrate-the-cookie)

The `initialState` returned by `cookieToInitialState`, contains the optimistic values that will populate the Wagmi's store both on the server and client.

```tsx
import './globals.css'
import type { Metadata } from 'next'
import { headers } from 'next/headers'

import { cookieToInitialState } from 'wagmi'

import { config } from '@/config'
import AppKitProvider from '@/context'

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app'
}

export default function RootLayout({
  children
}: Readonly<{
  children: React.ReactNode
}>) {
  const initialState = cookieToInitialState(config, headers().get('cookie'))
  return (
    <html lang="en">
      <body>
        <AppKitProvider initialState={initialState}>{children}</AppKitProvider>
      </body>
    </html>
  )
}
```
</file>

<file path="docs/appkit/next/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useweb3modal).
In this example we are going to use the `<w3m-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../../core/components.mdx)
</file>

<file path="docs/appkit/next/wagmi/hooks.mdx">
import Button from '../../../components/button'

You can use [Wagmi hooks](https://wagmi.sh/react/hooks/useAccount) to sign messages, interact with smart contracts, and much more.

### useAccount

Hook for accessing account data and connection status.

```tsx
import { useAccount } from 'wagmi'

function App() {
  const { address, isConnecting, isDisconnected } = useAccount()

  if (isConnecting) return <div>Connecting‚Ä¶</div>
  if (isDisconnected) return <div>Disconnected</div>
  return <div>{address}</div>
}
```

### useSignMessage

Hook for signing messages with connected account.

```tsx
import { useSignMessage } from 'wagmi'

function App() {
  const { signMessage } = useSignMessage()

  return <button onClick={() => signMessage({ message: 'hello world' })}>Sign message</button>
}
```

<Button name="Learn More" url="https://wagmi.sh/react/hooks/useReadContract" />
</file>

<file path="docs/appkit/react/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/react/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/react/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/react/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/react/core/components.mdx">
---
title: Components
---

import Components from '../../shared/components.mdx'

# Web Components

<Components />
</file>

<file path="docs/appkit/react/core/custom-connectors.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Custom connectors

Custom connectors, such as social logins, WalletConnect QR, Coinbasewallet, etc., can be integrated into your Modal. A simple example of how to incorporate them for Wagmi or Ethers library.
<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "solana"]}>

<PlatformTabItem value="wagmi">

If you already have Wagmi integrated into your application or would like more control over Wagmi's configuration, you can integrate AppKit on top of it.

```tsx
import { createWeb3Modal } from '@web3modal/wagmi/react'

import { http, createConfig, WagmiProvider } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { walletConnect } from 'wagmi/connectors'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

const projectId = 'YOUR_PROJECT_ID'

const metadata = {
  //...
}

// create the connectors (delete the ones you don't need)
const connectors: CreateConnectorFn[] = []
connectors.push(walletConnect({ projectId, metadata, showQrModal: false })) // showQrModal must be false
connectors.push(injected({ shimDisconnect: true }))
connectors.push(
  coinbaseWallet({
    appName: metadata.name,
    appLogoUrl: metadata.icons[0]
  })
)

connectors.push(
  authConnector({
    options: { projectId },
    socials: ['google', 'x', 'github', 'discord', 'apple', 'facebook', 'farcaster'], // add Social logins
    showWallets: true,
    email: true,
    walletFeatures: false
  })
)

const config = createConfig({
  chains: [sepolia],
  transports: {
    [sepolia.id]: http()
  },
  connectors
})

createWeb3Modal({
  wagmiConfig: config,
  projectId
})

export function ContextProvider({ children }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  )
}
```

Check our React Wagmi demo in [Github](https://github.com/WalletConnect/web-examples/tree/main/dapps/web3modal/react)

</PlatformTabItem>
<PlatformTabItem value="ethers">

```tsx
import { createWeb3Modal, defaultConfig } from '@web3modal/ethers/react'

const projectId = 'YOUR_PROJECT_ID'

// Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// Create a metadata object
const metadata = {
  //...
}

// Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1, // used for the Coinbase SDK
  auth: {
    email: true,
    socials: ['google', 'x', 'github', 'discord', 'apple', 'facebook', 'farcaster'], // add social logins
    showWallets: true,
    walletFeatures: false
  }
})

// Create a AppKit instance
createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

// Now, you can render connect button
ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <w3m-button />
  </React.StrictMode>
)
```

Check our React ethers demo in [Github](https://github.com/WalletConnect/web-examples/tree/main/dapps/web3modal/react-ethers)

</PlatformTabItem>
<PlatformTabItem value="solana">
Add custom wallet adapters for Solana wallets by first installing the wallet adapter package and then including the adapters in the wallets array. You can find a more Solana wallet adapters [here](https://github.com/anza-xyz/wallet-adapter/tree/master/packages/wallets).

```bash npm2yarn
npm install @solana/wallet-adapter-solflare
```

```ts
import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/react'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  //...
}

const solanaConfig = defaultSolanaConfig({
  chains,
  projectId,
  metadata
})

// 3. Create modal
const modal = createWeb3Modal({
  solanaConfig,
  projectId: projectId,
  metadata: metadata,
  chains,
  enableAnalytics: true,
  termsConditionsUrl: 'https://walletconnect.com/terms',
  privacyPolicyUrl: 'https://walletconnect.com/privacy',
  wallets: [
      new SolflareWalletAdapter(),
    ]
})
```

</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/appkit/react/core/hooks.mdx">
import Table from '../../../components/Table'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiHooks from '../wagmi/hooks.mdx'
import EthersHooks from '../ethers/hooks.mdx'
import SolanaHooks from '../solana/hooks.mdx'

# Hooks

Hooks are functions that will help you control the modal, subscribe to wallet events and interact with them and smart contracts.

## useWeb3Modal

Control the modal with the `useWeb3Modal` hook

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers", "solana"]}>
<PlatformTabItem value="wagmi">

```ts
import { useWeb3Modal } from '@web3modal/wagmi/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```ts
import { useWeb3Modal } from '@web3modal/ethers5/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
import { useWeb3Modal } from '@web3modal/ethers/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```ts
import { useWeb3Modal } from '@web3modal/solana/react'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
</PlatformTabs>

You can also select the modal's view when calling the `open` function

```ts
open({ view: 'Account' })
```

List of views you can select

<Table
  headers={['Variable', 'Description']}
  data={[
    {
      variable: { code: 'Connect' },
      description: 'Principal view of the modal - default view when disconnected'
    },
    {
      variable: { code: 'Account' },
      description: 'User profile - default view when connected'
    },
    {
      variable: { code: 'AllWallets' },
      description: 'Shows the list of all available wallets'
    },
    {
      variable: { code: 'Networks' },
      description:
        'List of available networks - you can select and target a specific network before connecting'
    },
    {
      variable: { code: 'WhatIsANetwork' },
      description: '"What is a network" onboarding view'
    },
    {
      variable: { code: 'WhatIsAWallet' },
      description: '"What is a wallet" onboarding view'
    },
    {
      variable: { code: 'OnRampProviders' },
      description: '"On-Ramp main view'
    }
  ]}
/>

## useDisconnect

```ts
const { disconnect } = useDisconnect()

disconnect()
```

## useWalletInfo

Metadata information from the connected wallet

```ts
import { useWalletInfo } from '@web3modal/wagmi/react'


export default Component(){
  const { walletInfo } = useWalletInfo()

  console.log(walletInfo.name, walletInfo.icon)

  //...
}
```

## Ethereum Library

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers"]}>
<PlatformTabItem value="wagmi">

<WagmiHooks />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersHooks />

</PlatformTabItem>
</PlatformTabs>

## useWeb3ModalState

Get the current value of the modal's state

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "wagmi1", "ethers5","ethers", "solana"]}>
<PlatformTabItem value="wagmi">

```ts
import { useWeb3ModalState } from '@web3modal/wagmi/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="wagmi1">

```ts
import { useWeb3ModalState } from '@web3modal/wagmi/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```ts
import { useWeb3ModalState } from '@web3modal/ethers5/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
import { useWeb3ModalState } from '@web3modal/ethers/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```ts
import { useWeb3ModalState } from '@web3modal/solana/react'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
</PlatformTabs>

The modal state consists of two reactive values:

<Table
  headers={['State', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'open' },
      description: 'Open state will be true when the modal is open and false when closed.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'selectedNetworkId' },
      description: 'The current chain id selected by the user',
      type: { code: 'number' }
    }
  ]}
/>

## useWeb3ModalTheme

```ts
const { themeMode, themeVariables, setThemeMode, setThemeVariables } = useWeb3ModalTheme()

setThemeMode('dark')

setThemeVariables({
  '--w3m-color-mix': '#00BB7F',
  '--w3m-color-mix-strength': 40
})
```

## Track modal events

```ts
import { useWeb3ModalEvents } from '@web3modal/wagmi/react'

const events = useWeb3ModalEvents()
```
</file>

<file path="docs/appkit/react/core/installation.mdx">
---
title: Installation
---

import CloudBanner from '../../../components/CloudBanner'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'
import YoutubeEmbed from '../../../components/YoutubeEmbed'

import WagmiImplementation from '../wagmi/about/implementation.mdx'
import WagmiModal from '../wagmi/about/triggermodal.mdx'

import Ethers5Implementation from '../ethers5/implementation.mdx'
import Ethers5Modal from '../ethers5/triggermodal.mdx'

import EthersImplementation from '../ethers/about/implementation.mdx'
import EthersModal from '../ethers/about/triggermodal.mdx'

import SolanaImplementation from '../solana/about/implementation.mdx'
import SolanaModal from '../solana/about/triggermodal.mdx'
import SolanaPrograms from '../solana/about/programs.mdx'

# React

AppKit has support for [Wagmi](https://wagmi.sh/) and [Ethers v6](https://docs.ethers.org/v6/) on Ethereum and [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/) on Solana.
Choose one of these ethereum libraries or solana to get started.

## Installation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

```bash npm2yarn
npm install @web3modal/wagmi wagmi viem @tanstack/react-query
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```bash npm2yarn
npm install @web3modal/ethers5 ethers@5.7.2
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```bash npm2yarn
npm install @web3modal/ethers ethers
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```bash npm2yarn
npm install @web3modal/solana
```

</PlatformTabItem>
</PlatformTabs>

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

<CloudBanner />

## Implementation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiImplementation />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<Ethers5Implementation />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersImplementation />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaImplementation />

</PlatformTabItem>
</PlatformTabs>

## Trigger the modal

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiModal />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<Ethers5Modal />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersModal />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaModal />

</PlatformTabItem>
</PlatformTabs>

## Smart Contract Interaction

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers","solana"]}>
<PlatformTabItem value="wagmi">

[Wagmi hooks](https://wagmi.sh/react/api/hooks/useReadContract) can help us interact with wallets and smart contracts:

```tsx
import { useReadContract } from 'wagmi'
import { USDTAbi } from '../abi/USDTAbi'

const USDTAddress = '0x...'

function App() {
  const result = useReadContract({
    abi: USDTAbi,
    address: USDTAddress,
    functionName: 'totalSupply'
  })
}
```

Read more about Wagmi hooks for smart contract interaction [here](https://wagmi.sh/react/hooks/useReadContract).

</PlatformTabItem>
<PlatformTabItem value="ethers">

[Ethers](https://docs.ethers.org/v6/) can help us interact with wallets and smart contracts:

```tsx
import { useWeb3ModalProvider, useWeb3ModalAccount } from '@web3modal/ethers/react'
import { BrowserProvider, Contract, formatUnits } from 'ethers'

const USDTAddress = '0x617f3112bf5397D0467D315cC709EF968D9ba546'

// The ERC-20 Contract ABI, which is a common contract interface
// for tokens (this is the Human-Readable ABI format)
const USDTAbi = [
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function balanceOf(address) view returns (uint)',
  'function transfer(address to, uint amount)',
  'event Transfer(address indexed from, address indexed to, uint amount)'
]

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()
  const { walletProvider } = useWeb3ModalProvider()

  async function getBalance() {
    if (!isConnected) throw Error('User disconnected')

    const ethersProvider = new BrowserProvider(walletProvider)
    const signer = await ethersProvider.getSigner()
    // The Contract object
    const USDTContract = new Contract(USDTAddress, USDTAbi, signer)
    const USDTBalance = await USDTContract.balanceOf(address)

    console.log(formatUnits(USDTBalance, 18))
  }

  return <button onClick={getBalance}>Get User Balance</button>
}
```

</PlatformTabItem>
<PlatformTabItem value="solana">
  <SolanaPrograms />
</PlatformTabItem>

</PlatformTabs>

## Video Tutorial

<YoutubeEmbed videoId="SGeXcva3amY" />
</file>

<file path="docs/appkit/react/core/options.mdx">
---
title: Options
---

import Options from '../../shared/options.mdx'

# Options

<Options />
</file>

<file path="docs/appkit/react/core/resources.mdx">
---
title: Resources
---

import Resources from '../../shared/resources.mdx'

# Resources

<Resources />
</file>

<file path="docs/appkit/react/core/siwe.mdx">
---
title: One-Click Auth / SIWE
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import SiweCode from '../../shared/siwe/code.mdx'
import SiweParams from '../../shared/siwe/parameters.mdx'

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a new form of authentication that enables users to control their digital identity with their Ethereum account.
SIWE is a standard also known as [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as ["ReCaps"](https://eips.ethereum.org/EIPS/eip-5573). ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary.
WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## Installation

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```bash npm2yarn
npm i @web3modal/siwe
```

</TabItem>
<TabItem value="legacy" label="Legacy">

:::caution
For a better UX we recommend using One-Click Auth.
:::

Install the AppKit SIWE package, additionally we also recommend installing [siwe](https://docs.login.xyz/) which will abstract a lot of the required logic.

```bash npm2yarn
npm i @web3modal/siwe siwe
```

</TabItem>
</Tabs>

## Configure your SIWE Client

<SiweCode />

## Initialize AppKit with your `siweConfig`
Add the `siweConfig` to your createWeb3Modal parameters

```ts
createWeb3Modal({
  //..
  siweConfig
})
```

## SIWE Config Parameters

<SiweParams />
</file>

<file path="docs/appkit/react/core/theming.mdx">
import Theming from '../../shared/theming.mdx'

# Theming

<Theming />
</file>

<file path="docs/appkit/react/ethers/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
import { createWeb3Modal, defaultConfig } from '@web3modal/ethers/react'

// 1. Get projectId
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// 3. Create a metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // origin must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}

// 4. Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1 // used for the Coinbase SDK
})

// 5. Create a AppKit instance
createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export default function App() {
  return <YourApp />
}
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/react/ethers/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Component">

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { useWeb3Modal } from '@web3modal/ethers/react'

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useWeb3Modal()

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: 'Networks' })}>Open Network Modal</button>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/react/ethers/hooks.mdx">
import Button from '../../../components/button'

### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/ethers/react'

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()

  //...
}
```

### useSwitchNetwork

```tsx
import { useSwitchNetwork } from '@web3modal/ethers/react'

const chainId = 137

const { switchNetwork } = useSwitchNetwork()

switchNetwork(chainId)
```

### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from 'ethers'
import { useWeb3ModalProvider } from '@web3modal/ethers/react'

function Components() {
  const { walletProvider } = useWeb3ModalProvider()

  async function onSignMessage() {
    const provider = new BrowserProvider(walletProvider)
    const signer = await provider.getSigner()
    const signature = await signer?.signMessage('Hello AppKit Ethers')
    console.log(signature)
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>
}
```

### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/ethers/react'

function Components() {
  const { error } = useWeb3ModalError()

  //...
}
```

<Button
  name="Learn More About Ethers"
  url="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="docs/appkit/react/ethers5/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
import { createWeb3Modal, defaultConfig } from '@web3modal/ethers5/react'

// 1. Get projectId
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

// 3. Create a metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // origin must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}

// 4. Create Ethers config
const ethersConfig = defaultConfig({
  /*Required*/
  metadata,

  /*Optional*/
  enableEIP6963: true, // true by default
  enableInjected: true, // true by default
  enableCoinbase: true, // true by default
  rpcUrl: '...', // used for the Coinbase SDK
  defaultChainId: 1 // used for the Coinbase SDK
})

// 5. Create a AppKit instance
createWeb3Modal({
  ethersConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export default function App() {
  return <YourApp />
}
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/react/ethers5/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../core/components.mdx) or build your own button with AppKit [**hooks**](../core/hooks.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Component">

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { useWeb3Modal } from '@web3modal/ethers5/react'

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useWeb3Modal()

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: 'Networks' })}>Open Network Modal</button>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/react/notifications/authorization-signatures/all-apps.mdx">
# Signing the message: ‚ÄúI further authorize this app to view and manage my notifications for ALL apps‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you may be presented with a signature request that reads the following message:

> I further authorize this app to view and manage my notifications for ALL apps. Read more at https://walletconnect.com/notifications-all-apps

For any signature request, it‚Äôs critical that you always read the message attached before signing in order to fully understand the permissions you‚Äôre granting.

Take caution when signing this request as doing so will allow the app to:

- Subscribe you to notifications from any app
- Manage your notifications for any app
- View your notifications from any app

The app will not be able to:

- Sign blockchain transactions or additional messages

Typically, apps you subscribe to for notifications will send a slightly [different request](this-app) that asks you to only authorize them to manage notifications _for that app only_ upon signing. You should only ever be presented with the message shown in the example above when an app requires wider access to your subscriptions and messages.

A common example of this would be an app that enables you to view notifications and messages from multiple apps, like a wallet or the [Web3Inbox.com app](https://app.web3inbox.com).

Always be cautious when granting this permission to an app, and ensure that you‚Äôre familiar with the app sending the request.

## Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/all-apps/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/all-apps/message.jpg" />
</div>
</file>

<file path="docs/appkit/react/notifications/authorization-signatures/overview.mdx">
# Authorization Signatures

When a user wants to enable notifications with an app or wallet, they must sign a SIWE message with their account granting that app access to view and manage their notifications. The SIWE message varies depending on whether the app is requesting access to manage all app notifications, or just that app's notifications. Below are the two possible SIWE messages the user would be requested to sign:

- [I authorize [...] this app](this-app)
- [I authorize [...] all apps](all-apps)
</file>

<file path="docs/appkit/react/notifications/authorization-signatures/this-app.mdx">
# Signing the message: ‚ÄúI further authorize this app to send me notifications‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you'll likely be presented with a signature request that reads the following message:

> I further authorize this app to send me notifications. Read more at https://walletconnect.com/notifications

For any signature request, it‚Äôs critical that you always read the message attached before signing to fully understand the permissions you‚Äôre granting.

By signing this request, you‚Äôre allowing the app to:

- Subscribe you to notifications from only this app
- Manage your notifications for only this app
- View your notifications from only this app

The app will not be able to:

- Sign blockchain transactions or additional messages
- Subscribe to, manage, or view notifications from other apps

Most apps that send notifications using Web3Inbox will request for you to sign this message&mdash;this will allow the app to simply interact with you directly. If you wish to opt-in to receive notifications from this app, signing this message will enable you to do so.

If you‚Äôve signed up to notifications but have received a different message, head [here](all-apps) to learn about other scenarios in which you may receive a signature request regarding notifications.

### Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/this-app/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/this-app/message.jpg" />
</div>
</file>

<file path="docs/appkit/react/notifications/embedded-widget/about.mdx">
# Introduction

** Embedded widget **: Drop-in widget for fast integration. Limited customization.

## Installation

```bash npm2yarn
npm i @web3inbox/core @web3inbox/widget-react
```

## Next Steps

Now that you've installed Web3Inbox Widget, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the library.
</file>

<file path="docs/appkit/react/notifications/embedded-widget/usage.mdx">
import CloudBanner from '../../../../components/CloudBanner'

# Usage

<CloudBanner />

Using Embedded Widget is the way to go if you want a ready made UI that's ready for plug-and-play.

## Getting Started

```ts
import { W3iWidget, useManageView } from "@web3inbox/widget-react";
import "@web3inbox/widget-react/dist/compiled.css";
...

const { open } = useManageView()
open();

return (
	<W3iWidget
		account="eip155:1:0x..."
		projectId="7a..."
		onSign={yourSignFunction}
		onConnect={connectFunction}
	/>
)

```
</file>

<file path="docs/appkit/react/notifications/frontend-integration/api.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CloudBanner from '../../../../components/CloudBanner'

import Initialization from '../../../shared/notifications/frontend-integration/api/initialization/react.mdx'
import SettingAccount from '../../../shared/notifications/frontend-integration/api/setting-account/react.mdx'
import Registering from '../../../shared/notifications/frontend-integration/api/registering-accounts/react.mdx'
import Managing from '../../../shared/notifications/frontend-integration/api/managing-subscription/react.mdx'
import ManagingNotifications from '../../../shared/notifications/frontend-integration/api/managing-notifications/react.mdx'
import Types from '../../../shared/notifications/frontend-integration/api/types/react.mdx'
import RegisteringPush from '../../../shared/notifications/frontend-integration/api/registering-push/react.mdx'
import Events from '../../../shared/notifications/frontend-integration/api/events/react.mdx'

# API

## Initialization

<Initialization/>

## Managing Account

### Setting account for web3inbox

<SettingAccount/>

### Registering an account

<Registering/>

## Managing Subscription

<Managing/>

## Managing Notifications

<ManagingNotifications/>

## Notification Types

<Types/>

## Registering for Device Push Notifications

<RegisteringPush/>

## Listening For Events

<Events/>
</file>

<file path="docs/appkit/react/notifications/frontend-integration/examples.mdx">
# Examples

- Our production [GM App](https://gm.walletconnect.com) which sends daily "gm!" notifications to all subscribers.
- [React GM Dapp](https://github.com/WalletConnect/gm-dapp) - a Web3Inbox Dapp using React, Typescript, Next.js & Ethers.
- Bare bones [template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) demonstrating basic functionality in an easy to base from way.
</file>

<file path="docs/appkit/react/notifications/frontend-integration/migration-guide.mdx">
import Migration from '../../../shared/notifications/frontend-integration/migration/react.mdx'

# Migration Guide

## General Migration notes

- `isLimited` flag has been removed in favor of `allApps` flag. They essentially mean the opposite thing.
- Deleting messages is no longer possible
- Messages are now stored on notify server and can be paged
- Registration is more flexible since it is now split into 2 functions

## Migrating from 0.x to 1.0.0

<Migration/>
</file>

<file path="docs/appkit/react/notifications/frontend-integration/usage.mdx">
import Installation from '../../../shared/notifications/frontend-integration/usage/installation/react.mdx'
import Example from '../../../shared/notifications/frontend-integration/usage/example/react.mdx'

# Usage

AppKit Notifications provides you the building blocks necessary to allow users to subscribe, receive notifications, and manage notification preferences, all from your app's UI. The Web3Inbox SDK supports both React hooks and JavaScript-based integrations.

Before begin using Web3Inbox, you will first need to [setup your project](../cloud-setup) to send notifications.

## Installation

<Installation/>

## Example Usage

This basic example demonstrates how to use the AppKit Notifications to subscribe to notifications and receive them in your app. Refer to the [API Reference](./api) for more details on the available methods.

<Example/>

## UX Guidelines

For the best user experience we have several recommendations on how to build the Web3Inbox flows into your app:

- Have an explicit opt-in UI to subscribe to notifications. Some users may not want to receive notifications, and enabling notifications requires the user to sign a message with their blockchain account. Enabling notifications should be optional, and if they do enable them they should be told that they will need to sign a message to enable this.
- Have a button to unsubscribe from notifications once they are enabled. Users may want to stop receiving notifications, so you should have a button to unsubscribe from notifications if the user wants to.
- Make use of [notification types](../cloud-setup#notification-types). These allow the user fine-grained control over what types of notifications they want to receive from your app. These allow users to only unsubscribe from the specific notifications they are no longer interested in, rather than needing to unsubscribe from your entire app. Your app should include functionality to manage notification preferences.
</file>

<file path="docs/appkit/react/notifications/backend-integration.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Backend Integration

Once an account is subscribed to your app's notifications you can test sending notifications to the account. You can subscribe in your app directly with our [Frontend Integration](frontend-integration/usage), or with one of the below testing options.

We recommend testing notifications with the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to your phone. You can also try one of our sample wallets:

- [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
- [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

## Authentication

To send notifications and access all subscriber information for your dapp, you will need your Notify API Secret and project ID.

You can find the Notify API Secret under the Notify API section of the APIs tab of your project on [WalletConnect Cloud](https://cloud.walletconnect.com). Follow steps on the [Cloud Setup](cloud-setup) page to configure this. This secret allows publishing notifications to any account subscribed to your app, so should not be published and should only be used by your app backend.

## Sending notifications

Only plaintext is supported, and newlines are ignored.

To send a notification notification you can call the `/notify` endpoint. This endpoint supports the following fields:

- `type` - The Notification type ID copied from WalletConnect Cloud.
- `title` - The title of the notification. Max 64 characters.
- `body` - The body of the notification containing more detail. Max 255 characters.
- `url` (optional) - A URL attached to the notification that the user can navigate to. Max 255 characters.
- `accounts` - A list of [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) account IDs for which to send the notification to. Max 500 accounts per request. Also see the [rate limits](#rate-limits) below.
- `notification_id` (optional) - An idempotency key of arbitrary format used to dedup multiple requests. Max 255 characters. Multiple calls with the same `notification_id` will use the first call's `notification` content, but will send to any additional account IDs listed in `accounts`.

```typescript
type RequestBody = {
  notification_id?: string | null
  notification: {
    type: string
    title: string
    body: string
    url?: string | null
  }
  accounts: string[]
}
```

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/notify`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    notification: {
      type: 'a1e53b95-18e5-4af8-9f03-9308ec87b687',
      title: 'The price of Ethereum has risen',
      body: 'The price of Ethereum has gone up 10%',
      url: 'https://app.example.com'
    },
    accounts: ['eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029']
  })
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/<PROJECT_ID>/notify' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "notification": {
      "type": "a1e53b95-18e5-4af8-9f03-9308ec87b687",
      "title": "The price of Ethereum has risen",
      "body": "The price of Ethereum has gone up 10%",
      "url": "https://app.example.com"
    },
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029"
    ]
  }'
```

</TabItem>

</Tabs>

## Get subscribers

You can tell if an account is subscribed and get information about subscribers using the `/v1/<project-id>/subscribers` endpoint. You can provide up to 100 accounts in the request.

If the account is subscribed, it will be returned as a key in the response along with a list of subscribed notification types as the value. If the account is not a subscriber, it will not be returned in the response.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const requestBody: RequestBody = {
  accounts: [
    'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029',
    'eip155:1:0x0000000000000000000000000000000000000000'
  ]
}

const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/subscribers`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
  body: JSON.stringify(requestBody)
})

const subscribers: ResponseBody = await response.json()

type RequestBody = {
  // Max 100 accounts
  accounts: string[]
}
type ResponseBody = {
  [account: string]: Subscriber
}
type Subscriber = {
  notification_types: string[]
}
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029",
      "eip155:1:0x0000000000000000000000000000000000000000"
    ]
  }'
```

</TabItem>

</Tabs>

Example response:

```jsonc
{
  "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029": {
    "notification_types": ["4d1c97ad-c182-4097-8f2c-8f80c0674df2"]
  }
}
```

## Get all subscribers

:::caution
This endpoint will download _all_ subscribers of your app, which is an expensive operation and can take several seconds to complete. Because of this, it has a low rate limit.
:::

You can get a list of all of the currently-subscribed accounts by calling the `/<project-id>/subscribers` endpoint.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/subscribers`, {
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
const subscribers: string[] = await response.json()
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl 'https://notify.walletconnect.com/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Mark all notifications as read

Unless marked as read by an app frontend, notifications will always be "unread". Because of this, when you
initially add support for displaying unread status or unread count to your frontend, users that have received
notifications in the past will have notifications display as "unread" even if they already have seen them.
This can potentially be an undesireable user experience.

To mitigate this problem, you can make a one-time call to the `/v1/<project-id>/mark-all-as-read` API endpoint
which will mark all existing notifications as read. Notifications marked as read in this way will not contribute
to read rate analytics. After you deploy your integration of unread states, you can call this endpoint to
reset the unread state for all of your existing notifications.

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/mark-all-as-read`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/mark-all-as-read' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Rate limits

To protect our system and subscribers, various limits and rate limits are in-place.

Rate limits are implemented as [token bucket](https://en.wikipedia.org/wiki/Token_bucket) and contain both rate and burst amounts. On average, a rate of requests can be made. However, since real-world applications often make requests in bursts, this fixed rate can be surpassed temporarily up to the burst amount, provided the app subsequently makes requests below the average in order to recover its bursting capability.

- `POST /<project-id>/notify`:
  - Each app can send 2 notifications per hour to an account, with a burst up to 50. Accounts that have been rate limited will be returned in the request response. Exceptions may be made on a per-project basis for special circumstances.
  - Each app can call this endpoint 2 times per second with a burst up to 20. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/subscribers`
  - Each app can call this endpoint 100 times per second with a burst up to 100. Rate limited requests will return a 429 status code.
- `GET /<project-id>/subscribers`
  - Each app can call this endpoint 1 time every 5 minutes with a burst up to 2. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/mark-all-as-read`
  - Each app can call this endpoint 1 time per hour with a burst up to 5. Rate limited requests will return a 429 status code.
</file>

<file path="docs/appkit/react/notifications/cloud-sending.mdx">
import useBaseUrl from '@docusaurus/useBaseUrl'

# Sending with Cloud

You can send notifications to subscribed users easily in [WalletConnect Cloud](https://cloud.walletconnect.com). Sending to users involves targeting particular [notification types](./cloud-setup#notification-types) who will receive your notification if they have not opted-out. You can specify a title and body for the notification, as well as a call-to-action link which users will be taken to when clicking on the notification.

Users can subscribe to your app in [several places](overview#subscribing-and-receiving-notifications) including the [Web3Inbox.com app](https://app.web3inbox.com), in your app with our [frontend SDK](frontend-integration/usage), or in supporting wallets.

To send notifications, you can use the utility provided in [WalletConnect Cloud](https://cloud.walletconnect.com) under the Notify API section:

1. In the APIs tab of your project, navigate to the Notify API section. You should see a banner with a link to the Send Notification playground.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground.png')} />

1. This allows you to send notifications to your subscribers. After you select the associated project, you can select the notification type, title, body, and link to send to your subscribers.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground-send.png')} />
</file>

<file path="docs/appkit/react/notifications/cloud-setup.mdx">
import CloudBanner from '../../../components/CloudBanner'
import useBaseUrl from '@docusaurus/useBaseUrl'

# Cloud Setup

This page explains the configuration required in order to obtain a Notify API Secret and configure your project to send notifications.

For a quick start to experiment with, you can try the [web3inbox template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) and following the steps in the README.

<CloudBanner />

## Domain to use

It is important to understand what domain you are using for your project as you are required to host a static file (the `did.json` file) on this domain before being able to use Notify API. The [WalletConnect Cloud](https://cloud.walletconnect.com) and clients receiving and managing your notifications use this file to authenticate that your domain is associated with the source of the notifications.

You can pick 1 domain and this is configured in the Dapp URL field of the Notify API section of the [WalletConnect Cloud](https://cloud.walletconnect.com). You may change your domain at any time, as long as you properly host the new `did.json` file there. Note that only one project may use a given domain at the same time.

During development it is optional to use your production domain for testing. Instead, you can use a staging domain, or even a entirely separate domain e.g. Vercel test site. However, once you move to production you will need to update your domain to your production domain and host a new file there.

Note that the file must be hosted on a real, publicly accessible, domain in order to verify its legitimacy. The use of `localhost` or other local addresses is not allowed.

## Dapp name, description, and logo

The dapp name, description, and logo are displayed in wallets that integrate Notify API as well as in the [Web3Inbox.com app](https://app.web3inbox.com). These details should be provided for the best user experience and to help the user identify your app.

## Notification types

Notification types are an important feature of Notify API and are a way for a user to have control over what types of notifications they receive. Users can change their notification types at any time in your app, their wallet, or the [Web3Inbox.com app](https://app.web3inbox.com). When sending notifications, you must use one of these configured notification types which you reference in code by its UUID.

Notification types are configured with a name, description, and icon which allow the user understand what types of notifications they would receive for that type. When a user receives a push notification on their device, they will see the icon that is configured with the notification type. Examples of notification types may include "Account updates" or "Service updates".

:::info
By default users are subscribed to all available notification types. However, it's worth nothing that if you add new notification types later users will not be automatically subscribed to them. If you have new notification types available, you may consider sending a notification informing users of this new available notification type and ask users to enable it. You may also add functionality to your app frontend to subscribe the user to the new notification type when they visit your app. Because of the additional effort in subscribing users to notification types after they initially subscribe, it is worth considering in advance what notification types you may need in the future.
:::

## Setup steps

### Navigating to Notify API section

In [WalletConnect Cloud](https://cloud.walletconnect.com), navigate to the APIs tab of your project.

<img className="image-margin" src={useBaseUrl('/img/w3i/1.png')} />

### Configuring Notify API

Under Notify API > Configuration > `DAPP INFORMATION`, fill in the Dapp URL field. This is the domain of your app that you will use to publish notifications.

<img className="image-margin" src={useBaseUrl('/img/w3i/dapp-info.png')} />

### Adding Notification Image and Types

Under the same section, next to Notification types, click on the "Add Notification Type" button and add a title, notification image and description for your notification type. This is the type of notification that your app will publish.

For example, if you are going to send promotional content as notification, you might want to add a notification type called "Promotional" with a description "Promotional content from the XYZ Team.".
You can also add a relevant image for the notification type.

<img className="image-margin" src={useBaseUrl('/img/w3i/notification-type.png')} />

### Saving Changes

Optionally, you can add a logo and description for your project. This will be shown to users when they subscribe to your app. Click "Save" to save your changes.

### Notify Secret

Take note of your new Notify API Secret. You will need this to publish notifications. This secret
allows publishing notifications to any account subscribed to your app, so should not be published
and should only be used by your app backend.

<img className="image-margin" src={useBaseUrl('/img/w3i/3.png')} />

### Hosting did.json file

Next, you will need to host `did.json` file on this page at the `/.well-known/` directory of your public URL. Please also ensure that your application has CORS enabled. An example is linked [here.](https://github.com/WalletConnect/gm-dapp/blob/main/next.config.js)

- Download `did.json` (click on `DID:WEB` section to show the download button ) and host it at, for example, `https://app.example.com/.well-known/did.json`
  <img className="image-margin" src={useBaseUrl('/img/w3i/did.png')} />

### Enabling Welcome Notifications

Welcome Notifications are notifications that are sent to users when they subscribe to your app. This is a great way to welcome users to your app and explain what types of notifications they will receive.

To enable Welcome Notifications, switch on the toggle in the Welcome Notifications section of your WalletConnect Cloud project after adding relevant Notification Type, Title, Body & Link.

<img className="image-margin" src={useBaseUrl('/img/w3i/welcome.png')} />

### Enabling Notify API

Once all changes have been saved and the `did.json` file has been deployed successfully, switch on the toggle switch in the Notify API section of your WalletConnect Cloud project. If everything is configured correctly, you should see a success toast: "Notify configuration successfully verified"

<img className="image-margin" src={useBaseUrl('/img/w3i/5.png')} />
<img className="image-margin" src={useBaseUrl('/img/w3i/6.png')} />

## Send Notifications in Cloud

Once you have completed the setup steps, you can now send notifications to users who have subscribed to your app. [Read more](./cloud-sending)

## Next steps

1. Now you are ready for accounts to subscribe to your app and send notifications to them using your Notify API Secret or with WalletConnect Cloud.

   - Read more on [sending notifications with WalletConnect Cloud](./cloud-sending)
   - Read more on [frontend integration](./frontend-integration/usage)
   - Read more on [backend integration](./backend-integration)

1. If you haven't already, [verify your apps domain](../cloud/verify) for improved security.



1. Navigate to the `Metrics` tab and select Web3Inbox from the dropdown to access analytics for your app. [Learn more about Web3Inbox Analytics](../cloud/analytics#web3inbox).

   <img className="image-margin" src={useBaseUrl('/img/w3i/metrics.png')} />
</file>

<file path="docs/appkit/react/notifications/demo.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Demo

## Try AppKit Notifications

The fastest way to try AppKit Notifications is to go to [app.web3inbox.com](https://app.web3inbox.com) and try subscribing to some dapps. The [Web3Inbox.com app](https://app.web3inbox.com) is a universal inbox for web3 users to access all their notifications in one place.

- [Web3Inbox.com app](https://app.web3inbox.com)

Or access the repo at [github.com/WalletConnect/web3inbox](https://github.com/WalletConnect/web3inbox/).

## Native notifications

AppKit Notifications also supports native notifications on iOS and Android. To try native notifications, you can use the [Web3Inbox.com app](https://app.web3inbox.com) and subscribe to dapps or build one of our sample apps.

A wallet that supports Notify is required to receive notifications.

## Wallet notifications

To try wallet notifications on a iOS or Android device, use a wallet that supports Notify. Alternatively, try building one of our sample apps, or grab a sample wallet preview build from Testflight or Firebase.

<PlatformTabs
	groupId="w3iw"
	activeOptions={["ios", "android", "web"]}
>

<PlatformTabItem value="web">
- [React Native](../../../walletkit/react-native/notifications/notify/installation)

</PlatformTabItem>

<PlatformTabItem value="ios">

- [Swift](../../../walletkit/ios/notifications/notify/installation)
- [Testflight](https://testflight.apple.com/join/09bTAryp)

</PlatformTabItem>

<PlatformTabItem value="android">

- [Kotlin](../../../walletkit/android/notifications/notify/installation)
- [Firebase](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/react/notifications/overview.mdx">
# Introduction

AppKit Notifications provides a toolkit for integrating Web3 notification features into apps. AppKit Notifications can be used to send notifications from your app directly to wallets.

This SDK utilizes WalletConnect's Notify API and is designed for Web3 scenarios, providing event-based notifications for activities like DAO votes, DeFi transaction alerts, and updates for NFT holders. Apps can send notifications to subscribed accounts, and users can receive and view their notifications in a supporting wallet, in the [Web3Inbox.com app](https://app.web3inbox.com), or in the app's frontend. Users can also discover Notify-compatible apps in their wallet or the [Web3Inbox.com app](https://app.web3inbox.com) to subscribe to.

AppKit Notifications is not to be confused with the [Web3Inbox.com app](https://app.web3inbox.com) which allows users to receive and manage their notifications from all apps, as they would in a wallet.

![Web3Inbox](/assets/web3inbox/w3i-hero.png)

## Getting Started

AppKit Notifications can be added to your app in a few steps:

- [Setup your project](cloud-setup) to send authenticated notifications.
- Use our [frontend SDK](frontend-integration/usage) to enable users to subscribe to notifications in your app.
- Finally, use [WalletConnect Cloud](cloud-sending) or our [API in your backend](backend-integration) to send notifications to subscribed users.

## Overview

Some of the key features of AppKit Notifications include:

- **Device push notifications:** Push notifications to the user's wallet (if it supports Notify API) or the [Web3Inbox.com app](https://app.web3inbox.com).
- **Notification history:** Notifications are stored and can be accessed from any device.
- **Spam protection/subscription control.** Using notification types, subscribers can opt-out of certain notification types they do not want to receive.
- **Tracking read status across devices.**

## Subscribing and receiving notifications

Users can receive notifications in several places:

- In the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to the user's phone
- In your app's frontend using our [frontend SDK](frontend-integration/usage)
- Natively in their wallet if the wallet supports Notify API.
  - You can also test with one of our sample wallets:
    - [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
    - [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

Users can also subscribe to notifications in all of the above locations too. To be discoverable in the Web3Inbox.com app or in wallets, apps must submit an explorer listing.

## Try it out

See the [demo section](demo) for sample apps and the Web3Inbox universal inbox app.

## FAQ

### What chains does AppKit Notifications support?

AppKit Notifications supports EOA accounts on all `eip155` (EVM) chains, and smart accounts on all `eip155` chains that our Blockchain API [supports](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md). We have plans to expand support in the future.
</file>

<file path="docs/appkit/react/onboarding/ens.mdx">
# ENS Provider
</file>

<file path="docs/appkit/react/onboarding/graduation.mdx">
# Graduation
</file>

<file path="docs/appkit/react/onboarding/smart-accounts.mdx">
---
title: Smart Accounts
---

import SmartAccount from '../../shared/smart-accounts.mdx'

<SmartAccount />
</file>

<file path="docs/appkit/react/onboarding/socials.mdx">
---
title: Email & Socials
---

import Socials from '../../shared/socials.mdx'

<Socials />
</file>

<file path="docs/appkit/react/onboarding/wallet-features.mdx">
# Wallet Features
</file>

<file path="docs/appkit/react/solana/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

AppKit Solana provides a set of React components and hooks to easily connect Solana wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
// App.tsx

import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/react'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  name: 'AppKit',
  description: 'AppKit Solana Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

const solanaConfig = defaultSolanaConfig({
  metadata,
  chains,
  projectId
})

// 3. Create modal
createWeb3Modal({
  solanaConfig,
  chains,
  projectId,
  wallets: [
      // Solana wallet adapters (check Custom connectors for more info)
  ]
})

export default function App() {
  return <YourApp />
}
```
</file>

<file path="docs/appkit/react/solana/about/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to this [demo app](https://appkit-solana.vercel.app/).

```tsx
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js'
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'

function deserializeCounterAccount(data?: Buffer): { count: number } {
  if (data?.byteLength !== 8) {
    throw Error('Need exactly 8 bytes to deserialize counter')
  }

  return {
    count: Number(data[0])
  }
}

const { address, currentChain } = useWeb3ModalAccount()
const { walletProvider, connection } = useWeb3ModalProvider()

async function onIncrementCounter() {
  const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy')

  const counterKeypair = Keypair.generate()
  const counter = counterKeypair.publicKey

  const balance = await connection.getBalance(walletProvider.publicKey)
  if (balance < LAMPORTS_PER_SOL / 100) {
    throw Error('Not enough SOL in wallet')
  }

  const COUNTER_ACCOUNT_SIZE = 8
  const allocIx: TransactionInstruction = SystemProgram.createAccount({
    fromPubkey: walletProvider.publicKey,
    newAccountPubkey: counter,
    lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
    space: COUNTER_ACCOUNT_SIZE,
    programId: PROGRAM_ID
  })

  const incrementIx: TransactionInstruction = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      {
        pubkey: counter,
        isSigner: false,
        isWritable: true
      }
    ],
    data: Buffer.from([0x0])
  })

  const tx = new Transaction().add(allocIx).add(incrementIx)

  tx.feePayer = walletProvider.publicKey
  tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash

  await walletProvider.signAndSendTransaction(tx, [counterKeypair])

  const counterAccountInfo = await connection.getAccountInfo(counter, {
    commitment: 'confirmed'
  })

  if (!counterAccountInfo) {
    throw new Error('Expected counter account to have been created')
  }

  const counterAccount = deserializeCounterAccount(counterAccountInfo?.data)

  if (counterAccount.count !== 1) {
    throw new Error('Expected count to have been 1')
  }

  console.log(`[alloc+increment] count is: ${counterAccount.count}`);
}
```
</file>

<file path="docs/appkit/react/solana/about/triggermodal.mdx">
To open AppKit you can use our default [web components](../../core/components.mdx) or build your own logic using [AppKit hooks](../../core/hooks.mdx).
In this example we are going to use the `<w3m-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```
</file>

<file path="docs/appkit/react/solana/hooks.mdx">
import Button from '../../../components/button'

### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/solana/react'

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()

  //...
}
```

### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react'

function SignMessage() {
  // 0. Get account and provider
  const { address } = useWeb3ModalAccount()
  const { walletProvider } = useWeb3ModalProvider()

  // 1. Create a function to sign a message
  async function onSignMessage() {
    try {
      if (!walletProvider || !address) {
        throw Error('user is disconnected')
      }

      // 2. Encode message and sign it
      const encodedMessage = new TextEncoder().encode('Hello from AppKit')
      const signature = await walletProvider.signMessage(encodedMessage)

      console.log(signature)
    } catch (err) {
      // Handle Error Here
    }
  }

  // 3. Create a button to trigger the function
  return <button onClick={onSignMessage}>Sign Message</button>
}
```

### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/solana/react'

function Components() {
  const { error } = useWeb3ModalError()

  //...
}
```
</file>

<file path="docs/appkit/react/solana/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
import { createWeb3Modal, defaultConfig } from '@web3modal/solana/react'

// 1. Get projectId
const projectId = 'YOUR_PROJECT_ID'

// 2. Set chains
const mainnet = {
  chainId: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
  name: 'Solana',
  currency: 'SOL',
  explorerUrl: 'https://solscan.io',
  rpcUrl: 'https://rpc.walletconnect.org/v1'
}

// 3. Create a metadata object
const metadata = {
  name: 'My Website',
  description: 'My Website description',
  url: 'https://mywebsite.com', // origin must match your domain & subdomain
  icons: ['https://avatars.mywebsite.com/']
}

// 4. Create Ethers config
const solanaConfig = defaultConfig({
  /*Required*/
  metadata,
  /*Optional*/
  projectId,
  enableInjected,
  defaultChainId
})

// 5. Create a Web3Modal instance
createWeb3Modal({
  solanaConfig,
  chains: [mainnet],
  projectId,
  enableAnalytics: true, // Optional - defaults to your Cloud configuration
})

export default function App() {
  return <YourApp />
}
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/react/solana/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open Web3Modal you can use our [**web component**](../core/components.mdx) or build your own button with Web3Modal [**hooks**](../core/hooks.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Component">

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the Web3Modal web components [here](../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { useWeb3Modal } from '@web3modal/ethers5/react'

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useWeb3Modal()

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: 'Networks' })}>Open Network Modal</button>
    </>
  )
}
```

Learn more about the Web3Modal hooks [here](../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/react/transactions/onramp.mdx">
---
title: On-Ramp
---

import Onramp from '../../shared/onramp.mdx'

# On-Ramp

<Onramp />
</file>

<file path="docs/appkit/react/transactions/swaps.mdx">
import Swaps from '../../shared/swaps.mdx'

# Swaps

<Swaps/>
</file>

<file path="docs/appkit/react/transactions/transaction-history.mdx">
# Transaction History
</file>

<file path="docs/appkit/react/wagmi/about/implementation.mdx">
For a quick integration you can use `defaultWagmiConfig` function which wraps Wagmi's [`createConfig`](https://wagmi.sh/core/api/createConfig) function with a predefined configuration.
This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api.mdx) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

On top of your app set up the following configuration, making sure that all functions are called **outside** any React component to avoid unwanted rerenders.

```tsx
import { createWeb3Modal } from '@web3modal/wagmi/react'
import { defaultWagmiConfig } from '@web3modal/wagmi/react/config'

import { WagmiProvider } from 'wagmi'
import { arbitrum, mainnet } from 'wagmi/chains'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

// 0. Setup queryClient
const queryClient = new QueryClient()

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create wagmiConfig
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

const chains = [mainnet, arbitrum] as const
const config = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
})

// 3. Create modal
createWeb3Modal({
  metadata,
  wagmiConfig: config,
  projectId,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export function AppKitProvider({ children }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  )
}
```
</file>

<file path="docs/appkit/react/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useweb3modal).
In this example we are going to use the `<w3m-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <w3m-button />
}
```

Learn more about the AppKit web components [here](../../core/components.mdx)
</file>

<file path="docs/appkit/react/wagmi/hooks.mdx">
import Button from '../../../components/button'

You can use [Wagmi hooks](https://wagmi.sh/react/hooks/useAccount) to sign messages, interact with smart contracts, and much more.

### useAccount

Hook for accessing account data and connection status.

```tsx
import { useAccount } from 'wagmi'

function App() {
  const { address, isConnecting, isDisconnected } = useAccount()

  if (isConnecting) return <div>Connecting‚Ä¶</div>
  if (isDisconnected) return <div>Disconnected</div>
  return <div>{address}</div>
}
```

### useSignMessage

Hook for signing messages with connected account.

```tsx
import { useSignMessage } from 'wagmi'

function App() {
  const { signMessage } = useSignMessage()

  return <button onClick={() => signMessage({ message: 'hello world' })}>Sign message</button>
}
```

<Button name="Learn More" url="https://wagmi.sh/react/hooks/useReadContract" />
</file>

<file path="docs/appkit/react-native/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/react-native/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/react-native/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/react-native/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/react-native/core/components.mdx">
---
title: Components
---

# Components

import Table from '../../../components/Table'

### List of components available in AppKit package

### `<W3mButton />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'disabled' },
      description: 'Enable or disable the button.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'balance' },
      description: "Show or hide the user's balance.",
      type: { code: "'show' or 'hide'" }
    },
    {
      variable: { code: 'size' },
      description: 'Default size for the button.',
      type: { code: "'md' or 'sm'" }
    },
    {
      variable: { code: 'label' },
      description: 'The text shown in the button.',
      type: { code: 'string' }
    },
    {
      variable: { code: 'loadingLabel' },
      description: 'The text shown in the button when the modal is open.',
      type: { code: 'string' }
    }
  ]}
/>

### `<W3mAccountButton />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'disabled' },
      description: 'Enable or disable the button.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'balance' },
      description: "Show or hide the user's balance.",
      type: { code: "'show' or 'hide'" }
    }
  ]}
/>

### `<W3mConnectButton />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'size' },
      description: 'Default size for the button.',
      type: { code: "'md' or 'sm'" }
    },
    {
      variable: { code: 'label' },
      description: 'The text shown in the button.',
      type: { code: 'string' }
    },
    {
      variable: { code: 'loadingLabel' },
      description: 'The text shown in the button when the modal is open.',
      type: { code: 'string' }
    }
  ]}
/>

### `<W3mNetworkButton />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'disabled' },
      description: 'Enable or disable the button.',
      type: { code: 'boolean' }
    }
  ]}
/>
</file>

<file path="docs/appkit/react-native/core/hooks.mdx">
import Table from '../../../components/Table'
import Button from '../../../components/button'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiHooks from '../wagmi/hooks.mdx'
import EthersHooks from '../ethers/hooks.mdx'
import Ethers5Hooks from '../ethers5/hooks.mdx'

# Hooks

## useWeb3Modal

Control the modal with the `useWeb3Modal` hook

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
```ts
import { useWeb3Modal } from '@web3modal/wagmi-react-native'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
````
</PlatformTabItem>

<PlatformTabItem value="ethers">
```ts
import { useWeb3Modal } from '@web3modal/ethers-react-native'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
````

</PlatformTabItem>

<PlatformTabItem value="ethers5">
```ts
import { useWeb3Modal } from '@web3modal/ethers5-react-native'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
````
</PlatformTabItem>

</PlatformTabs>

You can also select the modal's view when calling the `open` function

```ts
open({ view: 'Account' })
````

List of views you can select

<Table
  headers={['Variable', 'Description']}
  data={[
    {
      variable: { code: 'Connect' },
      description: 'Principal view of the modal - default view when disconnected'
    },
    {
      variable: { code: 'Account' },
      description: 'User profile - default view when connected'
    },
    {
      variable: { code: 'Networks' },
      description:
        'List of available networks - you can select and target a specific network before connecting'
    },
    {
      variable: { code: 'WhatIsANetwork' },
      description: '"What is a network" onboarding view'
    },
    {
      variable: { code: 'WhatIsAWallet' },
      description: '"What is a wallet" onboarding view'
    }
  ]}
/>

## useWeb3ModalState

Get the current value of the modal's state

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
  ```ts
import { useWeb3ModalState } from '@web3modal/wagmi-react-native'

const { open, selectedNetworkId } = useWeb3ModalState()
````
</PlatformTabItem>

<PlatformTabItem value="ethers">
```ts
import { useWeb3ModalState } from '@web3modal/ethers-react-native'

const { open, selectedNetworkId } = useWeb3ModalState()
````

</PlatformTabItem>

<PlatformTabItem value="ethers5">
```ts
import { useWeb3ModalState } from '@web3modal/ethers5-react-native'

const { open, selectedNetworkId } = useWeb3ModalState()
````
</PlatformTabItem>

</PlatformTabs>

The modal state consists of two reactive values:

<Table
  headers={['State', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'open' },
      description: 'Open state will be true when the modal is open and false when closed.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'selectedNetworkId' },
      description: 'The current chain id selected by the user',
      type: { code: 'number' }
    }
  ]}
/>


## useWeb3ModalEvents

Get the last tracked modal event

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
  ```ts
import { useWeb3ModalEvents } from '@web3modal/wagmi-react-native'

const event = useWeb3ModalEvents()
````

</PlatformTabItem>

<PlatformTabItem value="ethers">
```ts
import { useWeb3ModalEvents } from '@web3modal/ethers-react-native'

const event = useWeb3ModalEvents()
````
</PlatformTabItem>

<PlatformTabItem value="ethers5">
```ts
import { useWeb3ModalEvents } from '@web3modal/ethers5-react-native'

const event = useWeb3ModalEvents()
````

</PlatformTabItem>

</PlatformTabs>

## useWalletInfo

Get the metadata information from the connected wallet

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
```ts
import { useWalletInfo } from '@web3modal/wagmi-react-native'

const { walletInfo } = useWalletInfo()
````

</PlatformTabItem>

<PlatformTabItem value="ethers">
```ts
import { useWalletInfo } from '@web3modal/ethers-react-native'

const { walletInfo } = useWalletInfo()
````
</PlatformTabItem>

<PlatformTabItem value="ethers5">
```ts
import { useWalletInfo } from '@web3modal/ethers5-react-native'

const { walletInfo } = useWalletInfo()
````

</PlatformTabItem>

</PlatformTabs>

## Ethereum Library

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
  <WagmiHooks />
</PlatformTabItem>

<PlatformTabItem value="ethers">
  <EthersHooks />
</PlatformTabItem>

<PlatformTabItem value="ethers5">
  <Ethers5Hooks />
</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/appkit/react-native/core/installation.mdx">
---
title: Installation
---

import CloudBanner from '../../../components/CloudBanner'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'
import YoutubeEmbed from '../../../components/YoutubeEmbed'

import WagmiInstallation from '../wagmi/about/installation.mdx'
import WagmiInstallationExpo from '../wagmi/about/installation-expo.mdx'
import WagmiImplementation from '../wagmi/about/implementation.mdx'
import WagmiCoinbase from '../wagmi/about/coinbase.mdx'

import Ethers5Installation from '../ethers5/about/installation.mdx'
import Ethers5InstallationExpo from '../ethers5/about/installation-expo.mdx'
import Ethers5Implementation from '../ethers5/about/implementation.mdx'
import Ethers5Coinbase from '../ethers5/about/coinbase.mdx'

import EthersInstallation from '../ethers/about/installation.mdx'
import EthersInstallationExpo from '../ethers/about/installation-expo.mdx'
import EthersImplementation from '../ethers/about/implementation.mdx'
import EthersCoinbase from '../ethers/about/coinbase.mdx'

# React Native

## Introduction

AppKit has support for [Wagmi](https://wagmi.sh) and [Ethers](https://docs.ethers.org/v6/). Choose one of these Ethereum libraries to get started.

<CloudBanner />

## Installation

<Tabs groupId="platform">
<TabItem value="rn-cli" label="React Native CLI">

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">

{' '}

<WagmiInstallation />

</PlatformTabItem>

<PlatformTabItem value="ethers">

{' '}

<EthersInstallation />

</PlatformTabItem>

<PlatformTabItem value="ethers5">

{' '}

<Ethers5Installation />

</PlatformTabItem>

</PlatformTabs>

</TabItem>

<TabItem value="expo" label="Expo">

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">

{' '}

<WagmiInstallationExpo />

</PlatformTabItem>


<PlatformTabItem value="ethers">

{' '}

<EthersInstallationExpo />

</PlatformTabItem>

<PlatformTabItem value="ethers5">

{' '}

<Ethers5InstallationExpo />

</PlatformTabItem>

</PlatformTabs>

</TabItem>

</Tabs>

## Implementation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
  <WagmiImplementation />
</PlatformTabItem>

<PlatformTabItem value="ethers">
  <EthersImplementation />
</PlatformTabItem>

<PlatformTabItem value="ethers5">
  <Ethers5Implementation />
</PlatformTabItem>

</PlatformTabs>

## Enable Wallet Detection

:::info Note

Make sure your have `@walletconnect/react-native-compat@2.10.5` or higher.

:::

To enable AppKit to detect wallets installed on the device, you need to make specific changes to the native code of your project.

<Tabs groupId="platform">
  <TabItem value="rn-cli" label="React Native CLI">

<Tabs groupId="native-platform">
<TabItem value="ios" label="iOS">
1. Open your `Info.plist` file.
2. Locate the `<key>LSApplicationQueriesSchemes</key>` section.
3. Add the desired wallet schemes as string entries within the `<array>`. These schemes represent the wallets you want to detect.
4. Refer to our [Info.plist example file](https://github.com/WalletConnect/react-native-examples/blob/main/dapps/ModalUProvider/ios/ModalUProvider/Info.plist) for a detailed illustration.

Example:

```xml
<key>LSApplicationQueriesSchemes</key>
<array>
  <string>metamask</string>
  <string>trust</string>
  <string>safe</string>
  <string>rainbow</string>
  <string>uniswap</string>
  <!-- Add other wallet schemes names here -->
</array>
```
</TabItem>

<TabItem value="android" label="Android">

1. Open your `AndroidManifest.xml` file.
2. Locate the `<queries>` section.
3. Add the desired wallet package names as `<package>` entries within the `<queries>`. These package names correspond to the wallets you want to detect.
4. Refer to our [AndroidManifest.xml example file](https://github.com/WalletConnect/react-native-examples/blob/main/dapps/ModalUProvider/android/app/src/main/AndroidManifest.xml) for detailed guidance.

Example:

```xml
<queries>
  <package android:name="io.metamask"/>
  <package android:name="com.wallet.crypto.trustapp"/>
  <package android:name="io.gnosis.safe"/>
  <package android:name="me.rainbow"/>
  <!-- Add other wallet package names here -->
</queries>
```
</TabItem>
</Tabs>

</TabItem>

<TabItem value="expo" label="Expo">

<Tabs groupId="native-platform">
<TabItem value="ios" label="iOS">
To enable AppKit to detect wallets installed on the device in your Expo project for iOS, follow these steps:

1. Open your `app.json` (or `app.config.js`) file.
2. Locate the ios section within the configuration.
3. Add the `infoPlist` object if it doesn't exist, and within it, include the `LSApplicationQueriesSchemes` array. This array will contain the desired wallet schemes you want to detect.
4. Add the wallet schemes to the `LSApplicationQueriesSchemes` array.

Your configuration should look like this:

```js
{
  "expo": {
    "ios": {
      /* highlight-add-start */
      "infoPlist": {
        "LSApplicationQueriesSchemes": [
          "metamask",
          "trust",
          "safe",
          "rainbow",
          "uniswap"
          // Add other wallet schemes names here
        ]
      }
    /* highlight-add-end */
    }
  }
}
```
</TabItem>
<TabItem value="android" label="Android">
To enable AppKit to detect wallets installed on the device in your Expo project for Android, follow these steps:

1. Open your `app.json` (or `app.config.js`) file.
2. Locate the plugins section within the configuration.
3. Add `queries.js` in the plugins array:
```js
{
  "plugins": [
    // other plugins,
    /* highlight-add-start */
    "./queries.js"
    /* highlight-add-end */
  ],
}
```

4. Create the file `queries.js`:

```js
// based on https://github.com/expo/config-plugins/issues/123#issuecomment-1746757954

const {
  AndroidConfig,
  withAndroidManifest,
  createRunOncePlugin,
} = require("expo/config-plugins");

const queries = {
  package: [
    { $: { "android:name": "com.wallet.crypto.trustapp" } },
    { $: { "android:name": "io.metamask" } },
    { $: { "android:name": "me.rainbow" } },
    { $: { "android:name": "io.zerion.android" } },
    { $: { "android:name": "io.gnosis.safe" } },
    { $: { "android:name": "com.uniswap.mobile" } },
    // Add other wallet package names here
  ]
};


/**
 * @param {import('@expo/config-plugins').ExportedConfig} config
 */
const withAndroidManifestService = (config) => {
  return withAndroidManifest(config, (config) => {
    config.modResults.manifest = {
      ...config.modResults.manifest,
      queries,
    };

    return config;
  });
};

module.exports = createRunOncePlugin(
  withAndroidManifestService,
  "withAndroidManifestService",
  "1.0.0"
);
```


5. Add the wallet package names you want to be detected by your app.
</TabItem>
</Tabs>

</TabItem>

</Tabs>

## Enable Coinbase Wallet

<Tabs groupId="platform">
<TabItem value="rn-cli" label="React Native CLI">

Follow these steps to install Coinbase SDK in your project along with our Coinbase package. Check <a href="https://mobilewalletprotocol.github.io/wallet-mobile-sdk/docs/client-sdk/rn-install">here</a> for more detailed information.

- Note: Coinbase SDK is [not compatible with Expo Go](https://github.com/MobileWalletProtocol/wallet-mobile-sdk/issues/206)

1. Enable Expo Modules in your project running:

```
npx install-expo-modules@latest
```

2. Install Coinbase SDK

```
yarn add @coinbase/wallet-mobile-sdk react-native-mmkv
```

3. Install our custom connector

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
```
yarn add @web3modal/coinbase-wagmi-react-native
```
</PlatformTabItem>

<PlatformTabItem value="ethers">
```
yarn add @web3modal/coinbase-ethers-react-native
```
</PlatformTabItem>

<PlatformTabItem value="ethers5">
```
yarn add @web3modal/coinbase-ethers-react-native
```
</PlatformTabItem>

</PlatformTabs>

4. Run pod-install

```
npx pod-install
```

5. Enable Deeplink handling in your project following <a href="https://reactnative.dev/docs/linking?syntax=ios#enabling-deep-links">React Native docs</a>

6. Add Coinbase package in your AndroidManifest.xml and Info.Plist

```xml
// AndroidManifest.xml

<queries>
  <!-- other queries -->
  <package android:name="org.toshi" />
</queries>
```

```xml
// Info.plist

<key>LSApplicationQueriesSchemes</key>
<array>
  <!-- other schemes -->
  <string>cbwallet</string>
</array>
```

7. Add Coinbase reponse handler in your app. More info <a href="https://mobilewalletprotocol.github.io/wallet-mobile-sdk/docs/client-sdk/rn-setup#listening-for-responses">here</a>

```tsx
import { handleResponse } from '@coinbase/wallet-mobile-sdk'

// Your app's deeplink handling code
useEffect(() => {
  const sub = Linking.addEventListener('url', ({ url }) => {
    const handledBySdk = handleResponse(new URL(url))
    if (!handledBySdk) {
      // Handle other deeplinks
    }
  })

  return () => sub.remove()
}, [])
```

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
  <WagmiCoinbase />
</PlatformTabItem>

<PlatformTabItem value="ethers">
  <EthersCoinbase />
</PlatformTabItem>

<PlatformTabItem value="ethers5">
  <Ethers5Coinbase />
</PlatformTabItem>

</PlatformTabs>

Check <a href="https://mobilewalletprotocol.github.io/wallet-mobile-sdk/docs/client-sdk/rn-install">Coinbase docs</a> for more detailed information.

</TabItem>

<TabItem value="expo" label="Expo">
  Coinbase SDK doesn't support Expo Projects. More info <a href="https://github.com/MobileWalletProtocol/wallet-mobile-sdk/issues/206#issuecomment-1468836345">here</a>
</TabItem>

</Tabs>

## Tutorial

<YoutubeEmbed videoId="R0edIW72fHo" />
</file>

<file path="docs/appkit/react-native/core/options.mdx">
import Table from '../../../components/Table'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Options

The following options can be passed to the `createWeb3Modal` function:

```ts
createWeb3Modal({ projectId, chains, ...options })
```

## defaultChain

You can set a desired chain for the initial connection:

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "ethers5"]}>

<PlatformTabItem value="wagmi">
```ts
import { mainnet } from '@wagmi/core/chains'

createWeb3Modal({
  //...
  defaultChain: mainnet
})
```
</PlatformTabItem>

<PlatformTabItem value="ethers">
```ts
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com',
};

createWeb3Modal({
  //...
  defaultChain: mainnet
})
```

</PlatformTabItem>

<PlatformTabItem value="ethers5">
```ts
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com',
};

createWeb3Modal({
  //...
  defaultChain: mainnet
})
```
</PlatformTabItem>

</PlatformTabs>

## clipboardClient

Use your preferred clipboard library to allow AppKit use the clipboard to copy addresses & URIs

```ts
import * as Clipboard from 'expo-clipboard' // or `@react-native-clipboard/clipboard`

createWeb3Modal({
  //...
  clipboardClient: {
    setString: async (value: string) => {
      await Clipboard.setStringAsync(value)
    }
  }
})
```

## tokens

You can select tokens for AppKit to show the user's balance of. Each key represents the chain id of the token's blockchain.

```ts
createWeb3Modal({
  //...
  tokens: {
    1: {
      address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
    },
    137: {
      address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619'
    }
  }
})
```

## customWallets

Add custom wallets to the modal's main view. `customWallets` is an array of objects, where each object contains specific information of a custom wallet.

```ts
createWeb3Modal({
  //...
  customWallets: [
    {
      id: 'myCustomWallet',
      name: 'My Custom Wallet',
      homepage: 'www.mycustomwallet.com', // Optional
      image_url: 'my_custom_wallet_image', // Optional
      mobile_link: 'mobile_link', // Optional - Deeplink or universal
      desktop_link: 'desktop_link', // Optional - Deeplink
      webapp_link: 'webapp_link', // Optional
      app_store: 'app_store', // Optional
      play_store: 'play_store' // Optional
    }
  ]
})
```

## featuredWalletIds

Select wallets that are going to be shown on the modal's main view. Array of wallet IDs defined will be prioritized (order is respected).
These wallets will also show up first in `All Wallets` view.
You can find the wallets ids in [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet)

```ts
createWeb3Modal({
  //...
  featuredWalletIds: [
    '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369', // Rainbow
    '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0' // Trust
  ]
})
```

## includeWalletIds

Override default recommended wallets that are fetched from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet).
Array of wallet ids defined will be shown (order is respected).
Unlike `featuredWalletIds`, these wallets will be the **only** ones shown in `All Wallets` view and as recommended wallets.
You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card.

```ts
createWeb3Modal({
  //...
  includeWalletIds: [
    '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369', // Rainbow
    '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0' // Trust
  ]
})
```

## excludeWalletIds

Exclude wallets that are fetched from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet).
Array of wallet ids defined will be excluded.
All other wallets will be shown in respective places.
You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card.

```ts
createWeb3Modal({
  //...
  excludeWalletIds: [
    '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0', // Trust
    'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa' // Coinbase
  ]
})
```

## enableAnalytics

Enable analytics to get more insights on your users activity within your [WalletConnect Cloud's dashboard](https://cloud.walletconnect.com)

```ts
createWeb3Modal({
  //...
  enableAnalytics: true
})
```

## chainImages

Add or override the modal's network images.

```ts
createWeb3Modal({
  // ...
  chainImages: {
    1: 'https://my.images.com/eth.png'
  }
})
```
</file>

<file path="docs/appkit/react-native/core/resources.mdx">
# Resources

Main links for AppKit related content.

- [Examples](https://github.com/WalletConnect/react-native-examples/tree/main/dapps)
- [GitHub Repository](https://github.com/WalletConnect/web3modal-react-native)
- [Community Repository](https://github.com/WalletConnect/awesome-walletconnect)
</file>

<file path="docs/appkit/react-native/core/siwe.mdx">
---
title: One-Click Auth / SIWE
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Button from '../../../components/button'

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a new form of authentication that enables users to control their digital identity with their Ethereum account.
SIWE is a standard also known as [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as ["ReCaps"](https://eips.ethereum.org/EIPS/eip-5573). ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary.
WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## Pre-requisites
In order for SIWE to work, you need to have a backend to communicate with. This backend will be used to generate a nonce, verify messages and handle sessions.
More info [here](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-backend)

## Configure your SIWE Client

```ts
// siweConfig.ts

import {
  createSIWEConfig,
  formatMessage,
  type SIWEVerifyMessageArgs,
  type SIWECreateMessageArgs
} from '@web3modal/siwe-react-native';

export const siweConfig = createSIWEConfig({
  getNonce: async (): Promise<string> => {
    // The getNonce method functions as a safeguard
    // against spoofing, akin to a CSRF token.

    return await api.getNonce();
  },
  verifyMessage: async ({ message, signature, cacao }: SIWEVerifyMessageArgs): Promise<boolean> => {
    try {
      // This function ensures the message is valid,
      // has not been tampered with, and has been appropriately
      // signed by the wallet address.
      
      const isValid = await api.verifyMessage({ message, signature, cacao })

      return isValid
    } catch (error) {
      return false
    }
  },
  getSession: async (): Promise<SIWESession | null> => {
    // The backend session should store the associated address and chainId
    // and return it via the `getSession` method.

    const session = await api.getSession()
    if (!session) throw new Error('Failed to get session!')

    const { address, chainId } = session

    return { address, chainId }
  },
  signOut: (): Promise<boolean> => {
    try {
      // The users session must be destroyed when calling `signOut`.

      await api.signOut();
      return true;
    } catch {
      return false
    }
  },
  createMessage: ({ address, ...args }: SIWECreateMessageArgs): string => {
    // Method for generating an EIP-4361-compatible message.

    return formatMessage(args, address)
  },
  getMessageParams: () => {
    // Parameters to create the SIWE message internally.
    // More info in https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-222.method

    return {
      domain: 'your domain',
      uri: 'your uri',
      chains: [1,137], // array of chain ids
      statement: 'Please sign with your account',
      iat: new Date().toISOString()
    }
  },
})
```

## Initialize AppKit with your `siweConfig`
Add the siwe configuration in `createWeb3Modal` initialization

```ts
import { siweConfig } from './siweConfig.ts'

createWeb3Modal({
  //..
  /* highlight-add-start */
  siweConfig
  /* highlight-add-end */
})
```

### SIWE Config reference

```ts
interface SIWEConfig {
  /** Required **/
  getNonce: () => Promise<string>
  createMessage: (args: SIWECreateMessageArgs) => string
  verifyMessage: (args: SIWEVerifyMessageArgs) => Promise<boolean>
  getSession: () => Promise<SIWESession | null>
  signOut: () => Promise<boolean>

  /** Required for One-Click Auth **/
  getMessageParams `() => Promise<{ domain: string, uri: string, chains: number[], statement: string }>


  /** Optional **/
  
  // Callback when user signs in
  onSignIn?: (session?: SIWESession) => void

  // Callback when user signs out
  onSignOut?: () => void
  
  // Defaults to true
  enabled?: boolean
  
  // In milliseconds, defaults to 5 minutes
  nonceRefetchIntervalMs?: number
  
  // In milliseconds, defaults to 5 minutes
  sessionRefetchIntervalMs?: number
  
  // Defaults to true
  signOutOnDisconnect?: boolean
  
  // Defaults to true
  signOutOnAccountChange?: boolean
  
  // Defaults to true
  signOutOnNetworkChange?: boolean
}
```

## Exported functions

### `verifySignature`

Verify a SIWE signature. Internally it calls your backend verification method.

```ts
import { verifySignature } from '@web3modal/siwe-react-native'

const isValid = await verifySignature({ address, message, signature, chainId, projectId })
```

### `getChainIdFromMessage`

Get the chain ID from the SIWE message.

```ts
import { getChainIdFromMessage } from '@web3modal/siwe-react-native'

const chainId = getChainIdFromMessage(message)
```

### `getAddressFromMessage`

Get the address from the SIWE message.

```ts
import { getAddressFromMessage } from '@web3modal/siwe-react-native'

const address = getAddressFromMessage(message)
```
</file>

<file path="docs/appkit/react-native/ethers/about/coinbase.mdx">
8. Initialize `CoinbaseProvider` and add it in the default config

```tsx
import { CoinbaseProvider } from '@web3modal/coinbase-ethers-react-native'

const coinbaseProvider = new CoinbaseProvider({
  redirect: 'YOUR_APP_SCHEME://',
  rpcUrl: mainnet.rpcUrl
})

const config = defaultConfig({
  metadata,
  coinbase: coinbaseProvider
})
```
</file>

<file path="docs/appkit/react-native/ethers/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

Start by importing `createWeb3Modal`, and wagmi packages, then create your configs as shown below.
Finally, pass your configuration to `createWeb3Modal`.

:::info Note

Make sure you import `@walletconnect/react-native-compat` before using our package to avoid any issues.

:::

```tsx
import '@walletconnect/react-native-compat'

import { createWeb3Modal, defaultConfig, Web3Modal } from '@web3modal/ethers-react-native'

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create config
const metadata = {
  name: 'AppKit RN',
  description: 'AppKit RN Example',
  url: 'https://walletconnect.com',
  icons: ['https://avatars.githubusercontent.com/u/37784886'],
  redirect: {
    native: 'YOUR_APP_SCHEME://'
  }
}

const config = defaultConfig({ metadata })

// 3. Define your chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

const polygon = {
  chainId: 137,
  name: 'Polygon',
  currency: 'MATIC',
  explorerUrl: 'https://polygonscan.com',
  rpcUrl: 'https://polygon-rpc.com'
}

const chains = [mainnet, polygon]

// 4. Create modal
createWeb3Modal({
  projectId,
  chains,
  config,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export default function App() {
  return (
    <>
      // Rest of your app...
      <Web3Modal />
    </>
  )
}
```

#### Trigger the modal

To open AppKit modal you can use our **default** button component or build your own logic using our hooks.

<Tabs>
<TabItem value="components" label="Components">
You can use default components to open the modal

```tsx
import { W3mButton } from '@web3modal/ethers-react-native'

export default function ConnectView() {
  return (
    <>
      ...rest of your view
      <W3mButton />
    </>
  )
}
```

Learn more about the AppKit components [here](../../core/components.mdx)

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { Pressable, Text } from 'react-native'
import { useWeb3Modal } from '@web3modal/ethers-react-native'

export default function ConnectView() {
  const { open } = useWeb3Modal()

  return (
    <>
      <Pressable onClick={() => open()}>
        <Text>Open Connect Modal</Text>
      </Pressable>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/react-native/ethers/about/installation-expo.mdx">
import AdditionalExpo from '../../expo/additional-expo48.mdx'

```
npx expo install @web3modal/ethers-react-native ethers
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
npx expo install @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat expo-application
```

<AdditionalExpo />
</file>

<file path="docs/appkit/react-native/ethers/about/installation.mdx">
```
yarn add @web3modal/ethers-react-native ethers
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
yarn add @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```
</file>

<file path="docs/appkit/react-native/ethers/email.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

### Install packages

```
yarn add react-native-webview @web3modal/email-ethers-react-native
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```

### Add the email connector in `defaultConfig`

```ts
/* highlight-add-start */
import { EmailProvider } from '@web3modal/email-ethers-react-native'

const emailProvider = new EmailProvider({ projectId, metadata })
/* highlight-add-end */

const config = defaultConfig({
  metadata,
  /* highlight-add-start */
  extraConnectors: [emailProvider]
  /* highlight-add-end */
})
```
</file>

<file path="docs/appkit/react-native/ethers/hooks.mdx">
import Button from '../../../components/button'

#### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/ethers-react-native'

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()

  //...
}
```

#### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from 'ethers'
import { useWeb3ModalProvider } from '@web3modal/ethers-react-native'

function Components() {
  const { walletProvider } = useWeb3ModalProvider()

  async function onSignMessage() {
    const ethersProvider = new BrowserProvider(walletProvider)
    const signer = await ethersProvider.getSigner()
    const message = 'hello appkit rn + ethers'
    const signature = await signer.signMessage(message)
    console.log(signature.toString())
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>
}
```

#### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/ethers-react-native'

function Components() {
  const { error } = useWeb3ModalError()

  //...
}
```

<Button
  name="Learn More About Ethers"
  url="https://docs.ethers.org/v6/getting-started/#getting-started--contracts"
/>
</file>

<file path="docs/appkit/react-native/ethers5/about/coinbase.mdx">
8. Initialize `CoinbaseProvider` and add it in the default config

```tsx
import { CoinbaseProvider } from '@web3modal/coinbase-ethers-react-native'

const coinbaseProvider = new CoinbaseProvider({
  redirect: 'YOUR_APP_SCHEME://',
  rpcUrl: mainnet.rpcUrl
})

const config = defaultConfig({
  metadata,
  coinbase: coinbaseProvider
})
```
</file>

<file path="docs/appkit/react-native/ethers5/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

Start by importing `createWeb3Modal`, and wagmi packages, then create your configs as shown below.
Finally, pass your configuration to `createWeb3Modal`.

:::info Note

Make sure you import `@walletconnect/react-native-compat` and `@ethersproject/shims` before using our package to avoid any issues.

:::

```tsx
import '@walletconnect/react-native-compat'
import '@ethersproject/shims'

import { createWeb3Modal, defaultConfig, Web3Modal } from '@web3modal/ethers5-react-native'

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create config
const metadata = {
  name: 'AppKit RN',
  description: 'AppKit RN Example',
  url: 'https://walletconnect.com',
  icons: ['https://avatars.githubusercontent.com/u/37784886'],
  redirect: {
    native: 'YOUR_APP_SCHEME://'
  }
}

const config = defaultConfig({ metadata })

// 3. Define your chains
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

const polygon = {
  chainId: 137,
  name: 'Polygon',
  currency: 'MATIC',
  explorerUrl: 'https://polygonscan.com',
  rpcUrl: 'https://polygon-rpc.com'
}

const chains = [mainnet, polygon]

// 4. Create modal
createWeb3Modal({
  projectId,
  chains,
  config,
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export default function App() {
  return (
    <>
      // Rest of your app...
      <Web3Modal />
    </>
  )
}
```

#### Trigger the modal

To open AppKit modal you can use our **default** button component or build your own logic using our hooks.

<Tabs>
<TabItem value="components" label="Components">
You can use default components to open the modal

```tsx
import { W3mButton } from '@web3modal/ethers5-react-native'

export default function ConnectView() {
  return (
    <>
      ...rest of your view
      <W3mButton />
    </>
  )
}
```

Learn more about the AppKit components [here](../../core/components.mdx)

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { Pressable, Text } from 'react-native'
import { useWeb3Modal } from '@web3modal/ethers5-react-native'

export default function ConnectView() {
  const { open } = useWeb3Modal()

  return (
    <>
      <Pressable onClick={() => open()}>
        <Text>Open Connect Modal</Text>
      </Pressable>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/react-native/ethers5/about/installation-expo.mdx">
import AdditionalExpo from '../../expo/additional-expo48.mdx'

```
npx expo install @web3modal/ethers5-react-native ethers@5.7.2
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
npx expo install @ethersproject/shims@5.7.0 @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat expo-application
```

<AdditionalExpo />
</file>

<file path="docs/appkit/react-native/ethers5/about/installation.mdx">
```
yarn add @web3modal/ethers5-react-native ethers@5.7.2
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
yarn add @ethersproject/shims@5.7.0 @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```
</file>

<file path="docs/appkit/react-native/ethers5/hooks.mdx">
import Button from '../../../components/button'

#### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/ethers5-react-native'

function Components() {
  const { address, chainId, isConnected } = useWeb3ModalAccount()

  //...
}
```

#### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { ethers } from 'ethers'
import { useWeb3ModalProvider } from '@web3modal/ethers5-react-native'

function Components() {
  const { walletProvider } = useWeb3ModalProvider()

  async function onSignMessage() {
    const provider = new ethers.providers.Web3Provider(walletProvider)
    const signer = provider.getSigner()
    const signature = await signer?.signMessage('Hello AppKit Ethers')
    console.log(signature)
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>
}
```

#### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/ethers5-react-native'

function Components() {
  const { error } = useWeb3ModalError()

  //...
}
```

<Button
  name="Learn More About Ethers v5"
  url="https://docs.ethers.org/v5/getting-started/#getting-started--contracts"
/>
</file>

<file path="docs/appkit/react-native/expo/additional-expo48.mdx">
<details>
<summary>Additional setup for Expo SDK 48 only</summary>
<div>

If you are using Expo SDK 48, you also need to polyfill `crypto` with expo-crypto library.

1. Add `expo-crypto`

```
npx expo install expo-crypto
```

2. Create a file named `crypto-polyfill.js`

```js
// src/crypto-polyfill.js

// Apply only with Expo SDK 48
import { getRandomValues as expoCryptoGetRandomValues } from 'expo-crypto'

class Crypto {
  getRandomValues = expoCryptoGetRandomValues
}

// eslint-disable-next-line no-undef
const webCrypto = typeof crypto !== 'undefined' ? crypto : new Crypto()

;(() => {
  if (typeof crypto === 'undefined') {
    Object.defineProperty(window, 'crypto', {
      configurable: true,
      enumerable: true,
      get: () => webCrypto
    })
  }
})()
```

3. Import `crypto-polyfill.js` in your App root file

```js
// src/App.js

import './crypto-polyfill.js'
import '@walletconnect/react-native-compat';
...
import { createWeb3Modal } from '@web3modal/...'
```

</div>
</details>
</file>

<file path="docs/appkit/react-native/notifications/authorization-signatures/all-apps.mdx">
# Signing the message: ‚ÄúI further authorize this app to view and manage my notifications for ALL apps‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you may be presented with a signature request that reads the following message:

> I further authorize this app to view and manage my notifications for ALL apps. Read more at https://walletconnect.com/notifications-all-apps

For any signature request, it‚Äôs critical that you always read the message attached before signing in order to fully understand the permissions you‚Äôre granting.

Take caution when signing this request as doing so will allow the app to:

- Subscribe you to notifications from any app
- Manage your notifications for any app
- View your notifications from any app

The app will not be able to:

- Sign blockchain transactions or additional messages

Typically, apps you subscribe to for notifications will send a slightly [different request](this-app) that asks you to only authorize them to manage notifications _for that app only_ upon signing. You should only ever be presented with the message shown in the example above when an app requires wider access to your subscriptions and messages.

A common example of this would be an app that enables you to view notifications and messages from multiple apps, like a wallet or the [Web3Inbox.com app](https://app.web3inbox.com).

Always be cautious when granting this permission to an app, and ensure that you‚Äôre familiar with the app sending the request.

## Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/all-apps/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/all-apps/message.jpg" />
</div>
</file>

<file path="docs/appkit/react-native/notifications/authorization-signatures/overview.mdx">
# Authorization Signatures

When a user wants to enable notifications with an app or wallet, they must sign a SIWE message with their account granting that app access to view and manage their notifications. The SIWE message varies depending on whether the app is requesting access to manage all app notifications, or just that app's notifications. Below are the two possible SIWE messages the user would be requested to sign:

- [I authorize [...] this app](this-app)
- [I authorize [...] all apps](all-apps)
</file>

<file path="docs/appkit/react-native/notifications/authorization-signatures/this-app.mdx">
# Signing the message: ‚ÄúI further authorize this app to send me notifications‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you'll likely be presented with a signature request that reads the following message:

> I further authorize this app to send me notifications. Read more at https://walletconnect.com/notifications

For any signature request, it‚Äôs critical that you always read the message attached before signing to fully understand the permissions you‚Äôre granting.

By signing this request, you‚Äôre allowing the app to:

- Subscribe you to notifications from only this app
- Manage your notifications for only this app
- View your notifications from only this app

The app will not be able to:

- Sign blockchain transactions or additional messages
- Subscribe to, manage, or view notifications from other apps

Most apps that send notifications using Web3Inbox will request for you to sign this message&mdash;this will allow the app to simply interact with you directly. If you wish to opt-in to receive notifications from this app, signing this message will enable you to do so.

If you‚Äôve signed up to notifications but have received a different message, head [here](all-apps) to learn about other scenarios in which you may receive a signature request regarding notifications.

### Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/this-app/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/this-app/message.jpg" />
</div>
</file>

<file path="docs/appkit/react-native/notifications/frontend-integration/api.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CloudBanner from '../../../../components/CloudBanner'

import Initialization from '../../../shared/notifications/frontend-integration/api/initialization/javascript.mdx'
import SettingAccount from '../../../shared/notifications/frontend-integration/api/setting-account/javascript.mdx'
import Registering from '../../../shared/notifications/frontend-integration/api/registering-accounts/javascript.mdx'
import Managing from '../../../shared/notifications/frontend-integration/api/managing-subscription/javascript.mdx'
import ManagingNotifications from '../../../shared/notifications/frontend-integration/api/managing-notifications/javascript.mdx'
import Types from '../../../shared/notifications/frontend-integration/api/types/javascript.mdx'
import RegisteringPush from '../../../shared/notifications/frontend-integration/api/registering-push/javascript.mdx'
import Events from '../../../shared/notifications/frontend-integration/api/events/javascript.mdx'

# API

## Initialization

<Initialization/>

## Managing Account

### Setting account for web3inbox

<SettingAccount/>

### Registering an account

<Registering/>

## Managing Subscription

<Managing/>

## Managing Notifications

<ManagingNotifications/>

## Notification Types

<Types/>

## Registering for Device Push Notifications

<RegisteringPush/>

## Listening For Events

<Events/>
</file>

<file path="docs/appkit/react-native/notifications/frontend-integration/examples.mdx">
# Examples

- Our production [GM App](https://gm.walletconnect.com) which sends daily "gm!" notifications to all subscribers.
- [React GM Dapp](https://github.com/WalletConnect/gm-dapp) - a Web3Inbox Dapp using React, Typescript, Next.js & Ethers.
- Bare bones [template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) demonstrating basic functionality in an easy to base from way.
</file>

<file path="docs/appkit/react-native/notifications/frontend-integration/migration-guide.mdx">
import Migration from '../../../shared/notifications/frontend-integration/migration/javascript.mdx'

# Migration Guide

## General Migration notes

- `isLimited` flag has been removed in favor of `allApps` flag. They essentially mean the opposite thing.
- Deleting messages is no longer possible
- Messages are now stored on notify server and can be paged
- Registration is more flexible since it is now split into 2 functions

## Migrating from 0.x to 1.0.0

<Migration/>
</file>

<file path="docs/appkit/react-native/notifications/frontend-integration/usage.mdx">
import Installation from '../../../shared/notifications/frontend-integration/usage/installation/javascript.mdx'
import Example from '../../../shared/notifications/frontend-integration/usage/example/javascript.mdx'

# Usage

AppKit Notifications provides you the building blocks necessary to allow users to subscribe, receive notifications, and manage notification preferences, all from your app's UI. The Web3Inbox SDK supports both React hooks and JavaScript-based integrations.

Before begin using Web3Inbox, you will first need to [setup your project](../cloud-setup) to send notifications.

## Installation

<Installation/>

## Example Usage

This basic example demonstrates how to use the AppKit Notifications to subscribe to notifications and receive them in your app. Refer to the [API Reference](./api) for more details on the available methods.

<Example/>

## UX Guidelines

For the best user experience we have several recommendations on how to build the Web3Inbox flows into your app:

- Have an explicit opt-in UI to subscribe to notifications. Some users may not want to receive notifications, and enabling notifications requires the user to sign a message with their blockchain account. Enabling notifications should be optional, and if they do enable them they should be told that they will need to sign a message to enable this.
- Have a button to unsubscribe from notifications once they are enabled. Users may want to stop receiving notifications, so you should have a button to unsubscribe from notifications if the user wants to.
- Make use of [notification types](../cloud-setup#notification-types). These allow the user fine-grained control over what types of notifications they want to receive from your app. These allow users to only unsubscribe from the specific notifications they are no longer interested in, rather than needing to unsubscribe from your entire app. Your app should include functionality to manage notification preferences.
</file>

<file path="docs/appkit/react-native/notifications/backend-integration.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Backend Integration

Once an account is subscribed to your app's notifications you can test sending notifications to the account. You can subscribe in your app directly with our [Frontend Integration](frontend-integration/usage), or with one of the below testing options.

We recommend testing notifications with the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to your phone. You can also try one of our sample wallets:

- [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
- [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

## Authentication

To send notifications and access all subscriber information for your dapp, you will need your Notify API Secret and project ID.

You can find the Notify API Secret under the Notify API section of the APIs tab of your project on [WalletConnect Cloud](https://cloud.walletconnect.com). Follow steps on the [Cloud Setup](cloud-setup) page to configure this. This secret allows publishing notifications to any account subscribed to your app, so should not be published and should only be used by your app backend.

## Sending notifications

Only plaintext is supported, and newlines are ignored.

To send a notification notification you can call the `/notify` endpoint. This endpoint supports the following fields:

- `type` - The Notification type ID copied from WalletConnect Cloud.
- `title` - The title of the notification. Max 64 characters.
- `body` - The body of the notification containing more detail. Max 255 characters.
- `url` (optional) - A URL attached to the notification that the user can navigate to. Max 255 characters.
- `accounts` - A list of [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) account IDs for which to send the notification to. Max 500 accounts per request. Also see the [rate limits](#rate-limits) below.
- `notification_id` (optional) - An idempotency key of arbitrary format used to dedup multiple requests. Max 255 characters. Multiple calls with the same `notification_id` will use the first call's `notification` content, but will send to any additional account IDs listed in `accounts`.

```typescript
type RequestBody = {
  notification_id?: string | null
  notification: {
    type: string
    title: string
    body: string
    url?: string | null
  }
  accounts: string[]
}
```

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/notify`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    notification: {
      type: 'a1e53b95-18e5-4af8-9f03-9308ec87b687',
      title: 'The price of Ethereum has risen',
      body: 'The price of Ethereum has gone up 10%',
      url: 'https://app.example.com'
    },
    accounts: ['eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029']
  })
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/<PROJECT_ID>/notify' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "notification": {
      "type": "a1e53b95-18e5-4af8-9f03-9308ec87b687",
      "title": "The price of Ethereum has risen",
      "body": "The price of Ethereum has gone up 10%",
      "url": "https://app.example.com"
    },
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029"
    ]
  }'
```

</TabItem>

</Tabs>

## Get subscribers

You can tell if an account is subscribed and get information about subscribers using the `/v1/<project-id>/subscribers` endpoint. You can provide up to 100 accounts in the request.

If the account is subscribed, it will be returned as a key in the response along with a list of subscribed notification types as the value. If the account is not a subscriber, it will not be returned in the response.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const requestBody: RequestBody = {
  accounts: [
    'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029',
    'eip155:1:0x0000000000000000000000000000000000000000'
  ]
}

const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/subscribers`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
  body: JSON.stringify(requestBody)
})

const subscribers: ResponseBody = await response.json()

type RequestBody = {
  // Max 100 accounts
  accounts: string[]
}
type ResponseBody = {
  [account: string]: Subscriber
}
type Subscriber = {
  notification_types: string[]
}
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029",
      "eip155:1:0x0000000000000000000000000000000000000000"
    ]
  }'
```

</TabItem>

</Tabs>

Example response:

```jsonc
{
  "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029": {
    "notification_types": ["4d1c97ad-c182-4097-8f2c-8f80c0674df2"]
  }
}
```

## Get all subscribers

:::caution
This endpoint will download _all_ subscribers of your app, which is an expensive operation and can take several seconds to complete. Because of this, it has a low rate limit.
:::

You can get a list of all of the currently-subscribed accounts by calling the `/<project-id>/subscribers` endpoint.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/subscribers`, {
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
const subscribers: string[] = await response.json()
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl 'https://notify.walletconnect.com/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Mark all notifications as read

Unless marked as read by an app frontend, notifications will always be "unread". Because of this, when you
initially add support for displaying unread status or unread count to your frontend, users that have received
notifications in the past will have notifications display as "unread" even if they already have seen them.
This can potentially be an undesireable user experience.

To mitigate this problem, you can make a one-time call to the `/v1/<project-id>/mark-all-as-read` API endpoint
which will mark all existing notifications as read. Notifications marked as read in this way will not contribute
to read rate analytics. After you deploy your integration of unread states, you can call this endpoint to
reset the unread state for all of your existing notifications.

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/mark-all-as-read`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/mark-all-as-read' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Rate limits

To protect our system and subscribers, various limits and rate limits are in-place.

Rate limits are implemented as [token bucket](https://en.wikipedia.org/wiki/Token_bucket) and contain both rate and burst amounts. On average, a rate of requests can be made. However, since real-world applications often make requests in bursts, this fixed rate can be surpassed temporarily up to the burst amount, provided the app subsequently makes requests below the average in order to recover its bursting capability.

- `POST /<project-id>/notify`:
  - Each app can send 2 notifications per hour to an account, with a burst up to 50. Accounts that have been rate limited will be returned in the request response. Exceptions may be made on a per-project basis for special circumstances.
  - Each app can call this endpoint 2 times per second with a burst up to 20. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/subscribers`
  - Each app can call this endpoint 100 times per second with a burst up to 100. Rate limited requests will return a 429 status code.
- `GET /<project-id>/subscribers`
  - Each app can call this endpoint 1 time every 5 minutes with a burst up to 2. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/mark-all-as-read`
  - Each app can call this endpoint 1 time per hour with a burst up to 5. Rate limited requests will return a 429 status code.
</file>

<file path="docs/appkit/react-native/notifications/cloud-sending.mdx">
import useBaseUrl from '@docusaurus/useBaseUrl'

# Sending with Cloud

You can send notifications to subscribed users easily in [WalletConnect Cloud](https://cloud.walletconnect.com). Sending to users involves targeting particular [notification types](./cloud-setup#notification-types) who will receive your notification if they have not opted-out. You can specify a title and body for the notification, as well as a call-to-action link which users will be taken to when clicking on the notification.

Users can subscribe to your app in [several places](overview#subscribing-and-receiving-notifications) including the [Web3Inbox.com app](https://app.web3inbox.com), in your app with our [frontend SDK](frontend-integration/usage), or in supporting wallets.

To send notifications, you can use the utility provided in [WalletConnect Cloud](https://cloud.walletconnect.com) under the Notify API section:

1. In the APIs tab of your project, navigate to the Notify API section. You should see a banner with a link to the Send Notification playground.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground.png')} />

1. This allows you to send notifications to your subscribers. After you select the associated project, you can select the notification type, title, body, and link to send to your subscribers.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground-send.png')} />
</file>

<file path="docs/appkit/react-native/notifications/cloud-setup.mdx">
import CloudBanner from '../../../components/CloudBanner'
import useBaseUrl from '@docusaurus/useBaseUrl'

# Cloud Setup

This page explains the configuration required in order to obtain a Notify API Secret and configure your project to send notifications.

For a quick start to experiment with, you can try the [web3inbox template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) and following the steps in the README.

<CloudBanner />

## Domain to use

It is important to understand what domain you are using for your project as you are required to host a static file (the `did.json` file) on this domain before being able to use Notify API. The [WalletConnect Cloud](https://cloud.walletconnect.com) and clients receiving and managing your notifications use this file to authenticate that your domain is associated with the source of the notifications.

You can pick 1 domain and this is configured in the Dapp URL field of the Notify API section of the [WalletConnect Cloud](https://cloud.walletconnect.com). You may change your domain at any time, as long as you properly host the new `did.json` file there. Note that only one project may use a given domain at the same time.

During development it is optional to use your production domain for testing. Instead, you can use a staging domain, or even a entirely separate domain e.g. Vercel test site. However, once you move to production you will need to update your domain to your production domain and host a new file there.

Note that the file must be hosted on a real, publicly accessible, domain in order to verify its legitimacy. The use of `localhost` or other local addresses is not allowed.

## Dapp name, description, and logo

The dapp name, description, and logo are displayed in wallets that integrate Notify API as well as in the [Web3Inbox.com app](https://app.web3inbox.com). These details should be provided for the best user experience and to help the user identify your app.

## Notification types

Notification types are an important feature of Notify API and are a way for a user to have control over what types of notifications they receive. Users can change their notification types at any time in your app, their wallet, or the [Web3Inbox.com app](https://app.web3inbox.com). When sending notifications, you must use one of these configured notification types which you reference in code by its UUID.

Notification types are configured with a name, description, and icon which allow the user understand what types of notifications they would receive for that type. When a user receives a push notification on their device, they will see the icon that is configured with the notification type. Examples of notification types may include "Account updates" or "Service updates".

:::info
By default users are subscribed to all available notification types. However, it's worth nothing that if you add new notification types later users will not be automatically subscribed to them. If you have new notification types available, you may consider sending a notification informing users of this new available notification type and ask users to enable it. You may also add functionality to your app frontend to subscribe the user to the new notification type when they visit your app. Because of the additional effort in subscribing users to notification types after they initially subscribe, it is worth considering in advance what notification types you may need in the future.
:::

## Setup steps

### Navigating to Notify API section

In [WalletConnect Cloud](https://cloud.walletconnect.com), navigate to the APIs tab of your project.

<img className="image-margin" src={useBaseUrl('/img/w3i/1.png')} />

### Configuring Notify API

Under Notify API > Configuration > `DAPP INFORMATION`, fill in the Dapp URL field. This is the domain of your app that you will use to publish notifications.

<img className="image-margin" src={useBaseUrl('/img/w3i/dapp-info.png')} />

### Adding Notification Image and Types

Under the same section, next to Notification types, click on the "Add Notification Type" button and add a title, notification image and description for your notification type. This is the type of notification that your app will publish.

For example, if you are going to send promotional content as notification, you might want to add a notification type called "Promotional" with a description "Promotional content from the XYZ Team.".
You can also add a relevant image for the notification type.

<img className="image-margin" src={useBaseUrl('/img/w3i/notification-type.png')} />

### Saving Changes

Optionally, you can add a logo and description for your project. This will be shown to users when they subscribe to your app. Click "Save" to save your changes.

### Notify Secret

Take note of your new Notify API Secret. You will need this to publish notifications. This secret
allows publishing notifications to any account subscribed to your app, so should not be published
and should only be used by your app backend.

<img className="image-margin" src={useBaseUrl('/img/w3i/3.png')} />

### Hosting did.json file

Next, you will need to host `did.json` file on this page at the `/.well-known/` directory of your public URL. Please also ensure that your application has CORS enabled. An example is linked [here.](https://github.com/WalletConnect/gm-dapp/blob/main/next.config.js)

- Download `did.json` (click on `DID:WEB` section to show the download button ) and host it at, for example, `https://app.example.com/.well-known/did.json`
  <img className="image-margin" src={useBaseUrl('/img/w3i/did.png')} />

### Enabling Welcome Notifications

Welcome Notifications are notifications that are sent to users when they subscribe to your app. This is a great way to welcome users to your app and explain what types of notifications they will receive.

To enable Welcome Notifications, switch on the toggle in the Welcome Notifications section of your WalletConnect Cloud project after adding relevant Notification Type, Title, Body & Link.

<img className="image-margin" src={useBaseUrl('/img/w3i/welcome.png')} />

### Enabling Notify API

Once all changes have been saved and the `did.json` file has been deployed successfully, switch on the toggle switch in the Notify API section of your WalletConnect Cloud project. If everything is configured correctly, you should see a success toast: "Notify configuration successfully verified"

<img className="image-margin" src={useBaseUrl('/img/w3i/5.png')} />
<img className="image-margin" src={useBaseUrl('/img/w3i/6.png')} />

## Send Notifications in Cloud

Once you have completed the setup steps, you can now send notifications to users who have subscribed to your app. [Read more](./cloud-sending)

## Next steps

1. Now you are ready for accounts to subscribe to your app and send notifications to them using your Notify API Secret or with WalletConnect Cloud.

   - Read more on [sending notifications with WalletConnect Cloud](./cloud-sending)
   - Read more on [frontend integration](./frontend-integration/usage)
   - Read more on [backend integration](./backend-integration)

1. If you haven't already, [verify your apps domain](../cloud/verify) for improved security.



1. Navigate to the `Metrics` tab and select Web3Inbox from the dropdown to access analytics for your app. [Learn more about Web3Inbox Analytics](../cloud/analytics#web3inbox).

   <img className="image-margin" src={useBaseUrl('/img/w3i/metrics.png')} />
</file>

<file path="docs/appkit/react-native/notifications/demo.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Demo

## Try AppKit Notifications

The fastest way to try AppKit Notifications is to go to [app.web3inbox.com](https://app.web3inbox.com) and try subscribing to some dapps. The [Web3Inbox.com app](https://app.web3inbox.com) is a universal inbox for web3 users to access all their notifications in one place.

- [Web3Inbox.com app](https://app.web3inbox.com)

Or access the repo at [github.com/WalletConnect/web3inbox](https://github.com/WalletConnect/web3inbox/).

## Native notifications

AppKit Notifications also supports native notifications on iOS and Android. To try native notifications, you can use the [Web3Inbox.com app](https://app.web3inbox.com) and subscribe to dapps or build one of our sample apps.

A wallet that supports Notify is required to receive notifications.

## Wallet notifications

To try wallet notifications on a iOS or Android device, use a wallet that supports Notify. Alternatively, try building one of our sample apps, or grab a sample wallet preview build from Testflight or Firebase.

<PlatformTabs
	groupId="w3iw"
	activeOptions={["ios", "android", "web"]}
>

<PlatformTabItem value="web">
- [React Native](../../../walletkit/react-native/notifications/notify/installation)

</PlatformTabItem>

<PlatformTabItem value="ios">

- [Swift](../../../walletkit/ios/notifications/notify/installation)
- [Testflight](https://testflight.apple.com/join/09bTAryp)

</PlatformTabItem>

<PlatformTabItem value="android">

- [Kotlin](../../../walletkit/android/notifications/notify/installation)
- [Firebase](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/react-native/notifications/overview.mdx">
# Introduction

AppKit Notifications provides a toolkit for integrating Web3 notification features into apps. AppKit Notifications can be used to send notifications from your app directly to wallets.

This SDK utilizes WalletConnect's Notify API and is designed for Web3 scenarios, providing event-based notifications for activities like DAO votes, DeFi transaction alerts, and updates for NFT holders. Apps can send notifications to subscribed accounts, and users can receive and view their notifications in a supporting wallet, in the [Web3Inbox.com app](https://app.web3inbox.com), or in the app's frontend. Users can also discover Notify-compatible apps in their wallet or the [Web3Inbox.com app](https://app.web3inbox.com) to subscribe to.

AppKit Notifications is not to be confused with the [Web3Inbox.com app](https://app.web3inbox.com) which allows users to receive and manage their notifications from all apps, as they would in a wallet.

![Web3Inbox](/assets/web3inbox/w3i-hero.png)

## Getting Started

AppKit Notifications can be added to your app in a few steps:

- [Setup your project](cloud-setup) to send authenticated notifications.
- Use our [frontend SDK](frontend-integration/usage) to enable users to subscribe to notifications in your app.
- Finally, use [WalletConnect Cloud](cloud-sending) or our [API in your backend](backend-integration) to send notifications to subscribed users.

## Overview

Some of the key features of AppKit Notifications include:

- **Device push notifications:** Push notifications to the user's wallet (if it supports Notify API) or the [Web3Inbox.com app](https://app.web3inbox.com).
- **Notification history:** Notifications are stored and can be accessed from any device.
- **Spam protection/subscription control.** Using notification types, subscribers can opt-out of certain notification types they do not want to receive.
- **Tracking read status across devices.**

## Subscribing and receiving notifications

Users can receive notifications in several places:

- In the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to the user's phone
- In your app's frontend using our [frontend SDK](frontend-integration/usage)
- Natively in their wallet if the wallet supports Notify API.
  - You can also test with one of our sample wallets:
    - [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
    - [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

Users can also subscribe to notifications in all of the above locations too. To be discoverable in the Web3Inbox.com app or in wallets, apps must submit an explorer listing.

## Try it out

See the [demo section](demo) for sample apps and the Web3Inbox universal inbox app.

## FAQ

### What chains does AppKit Notifications support?

AppKit Notifications supports EOA accounts on all `eip155` (EVM) chains, and smart accounts on all `eip155` chains that our Blockchain API [supports](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md). We have plans to expand support in the future.
</file>

<file path="docs/appkit/react-native/onboarding/email.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiImplementation from '../wagmi/email.mdx'
import EthersImplementation from '../ethers/email.mdx'

# Email Wallets

AppKit enables passwordless Web3 onboarding and authentication, allowing your users interact with your application by creating a non-custodial wallet with just their emails.

:::info Note

Due to Safari‚Äôs strict third-party cookie policies, the SDK is not preserving sessions after the app is closed. Our team is working to solve this issue soon.

:::

## Integration

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers"]}>


<PlatformTabItem value="wagmi">
   ### Update your Cloud settings
   1. Go to your [Cloud](https://cloud.walletconnect.com) project
   2. Open Dashboard and scroll down to Mobile Application IDs menu
   3. Add your iOS Bundle ID and/or your Android Package Name
   * Changes might take some minutes to impact

   <WagmiImplementation />
</PlatformTabItem>

<PlatformTabItem value="ethers">
   ### Update your Cloud settings
   1. Go to your [Cloud](https://cloud.walletconnect.com) project
   2. Open Dashboard and scroll down to Mobile Application IDs menu
   3. Add your iOS Bundle ID and/or your Android Package Name
   * Changes might take some minutes to impact
   
   <EthersImplementation />
</PlatformTabItem>

</PlatformTabs>

## User Flow

1. Users will be able to connect to you application by simply using an email address. AppKit will send to them a One Time Password (OTP) to copy and paste in the modal, which will help to
   verify the user's authenticity. This will create a non-custodial wallet for your user which will be available in any application that integrates AppKit and email login.

2. Eventually the user can optionally choose to move from a non-custodial wallet to a self-custodial one by pressing "Upgrade Wallet" on AppKit.
   This will open the _([WalletConnect secure website](https://secure.walletconnect.com/dashboard))_ that will walk your user through the upgrading process.
</file>

<file path="docs/appkit/react-native/wagmi/about/coinbase.mdx">
8. Initialize `coinbaseConnector` and add it in `extraConnectors`

```tsx
import { coinbaseConnector } from '@web3modal/coinbase-wagmi-react-native'

const coinbase = coinbaseConnector({
  redirect: 'YOUR_APP_SCHEME://'
})

const wagmiConfig = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  extraConnectors: [coinbase]
})
```
</file>

<file path="docs/appkit/react-native/wagmi/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

Start by importing `createWeb3Modal`, and wagmi packages, then create your configs as shown below.
Finally, pass your configuration to `createWeb3Modal`.

:::info Note

Make sure you import `@walletconnect/react-native-compat` before `wagmi` to avoid any issues.

:::

```tsx
import '@walletconnect/react-native-compat'
import { WagmiProvider } from 'wagmi'
import { mainnet, polygon, arbitrum } from '@wagmi/core/chains'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { createWeb3Modal, defaultWagmiConfig, Web3Modal } from '@web3modal/wagmi-react-native'

// 0. Setup queryClient
const queryClient = new QueryClient()

// 1. Get projectId at https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create config
const metadata = {
  name: 'AppKit RN',
  description: 'AppKit RN Example',
  url: 'https://walletconnect.com',
  icons: ['https://avatars.githubusercontent.com/u/37784886'],
  redirect: {
    native: 'YOUR_APP_SCHEME://',
    universal: 'YOUR_APP_UNIVERSAL_LINK.com'
  }
}

const chains = [mainnet, polygon, arbitrum] as const

const wagmiConfig = defaultWagmiConfig({ chains, projectId, metadata })

// 3. Create modal
createWeb3Modal({
  projectId,
  wagmiConfig,
  defaultChain: mainnet, // Optional
  enableAnalytics: true // Optional - defaults to your Cloud configuration
})

export default function App() {
  return (
    <WagmiProvider config={wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        // Rest of your app...
        <Web3Modal />
      </QueryClientProvider>
    </WagmiProvider>
  )
}
```

#### Trigger the modal

To open AppKit modal you can use our **default** button component or build your own logic using our hooks.

<Tabs>
<TabItem value="components" label="Components">
You can use default components to open the modal

```tsx
import { W3mButton } from '@web3modal/wagmi-react-native'

export default function ConnectView() {
  return (
    <>
      ...rest of your view
      <W3mButton />
    </>
  )
}
```

Learn more about the AppKit components [here](../../core/components.mdx)

</TabItem>
<TabItem value="hooks" label="Hooks">

You can trigger the modal by calling the `open` function from `useWeb3Modal` hook.

```tsx
import { Pressable, Text } from 'react-native'
import { useWeb3Modal } from '@web3modal/wagmi-react-native'

export default function ConnectView() {
  const { open } = useWeb3Modal()

  return (
    <>
      <Pressable onClick={() => open()}>
        <Text>Open Connect Modal</Text>
      </Pressable>
    </>
  )
}
```

Learn more about the AppKit hooks [here](../../core/hooks.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/react-native/wagmi/about/installation-expo.mdx">
import AdditionalExpo from '../../expo/additional-expo48.mdx'

```
npx expo install @web3modal/wagmi-react-native wagmi viem @tanstack/react-query
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
npx expo install @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat expo-application
```

<AdditionalExpo />
</file>

<file path="docs/appkit/react-native/wagmi/about/installation.mdx">
```
yarn add @web3modal/wagmi-react-native wagmi viem @tanstack/react-query
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
yarn add @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```
</file>

<file path="docs/appkit/react-native/wagmi/email.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

### Install packages

```
yarn add @web3modal/email-wagmi-react-native react-native-webview
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```

### Add the email connector in `defaultWagmiConfig`

```ts
/* highlight-add-start */
import { emailConnector } from '@web3modal/email-wagmi-react-native'

const email = emailConnector({ projectId, metadata })
/* highlight-add-end */

const wagmiConfig = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  /* highlight-add-start */
  extraConnectors: [email]
  /* highlight-add-end */
})
```
</file>

<file path="docs/appkit/react-native/wagmi/hooks.mdx">
import Button from '../../../components/button'

You can use [Wagmi hooks](https://wagmi.sh/react/api/hooks) to sign messages, interact with smart contracts, and much more.

#### useAccount

Hook for accessing account data and connection status.

```tsx
import { Text } from 'react-native'
import { useAccount } from 'wagmi'

function App() {
  const { address, isConnecting, isDisconnected } = useAccount()

  if (isConnecting) return <Text>Connecting‚Ä¶</Text>
  if (isDisconnected) return <Text>Disconnected</Text>
  return <Text>{address}</Text>
}
```

#### useSignMessage

Hook for signing messages with connected account.

```tsx
import { View, Text, Pressable } from 'react-native'
import { useSignMessage } from 'wagmi'

function App() {
  const { data, isError, isPending, isSuccess, signMessage } = useSignMessage()

  return (
    <View>
      <Pressable disabled={isPending} onPress={() => signMessage({ message: 'hello world' })}>
        <Text>Sign message</Text>
      </Pressable>
      {isSuccess && <Text>Signature: {data}</Text>}
      {isError && <Text>Error signing message</Text>}
    </View>
  )
}
```

#### useReadContract

Hook for calling a read method on a Contract.

```tsx
import { View, Text } from 'react-native'
import { useReadContract } from './abi'

function App() {
  const { data, isError, isPending, isSuccess } = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply'
  })

  return (
    <View>
      {isPending && <Text>Loading</Text>}
      {isSuccess && <Text>Response: {data?.toString()}</Text>}
      {isError && <Text>Error reading contract</Text>}
    </View>
  )
}
```

<Button name="Learn More" url="https://wagmi.sh/react/api/hooks" />
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/events/javascript.mdx">
This can be used to listen to, for example, messages received in realtime.

```ts
client.on('notify_message', ({ notification }) => {
  console.log(notification.title)
})
```

#### References

- `message`: Notification of type:

```ts
interface NotifyNotification {
  title: string
  sentAt: number
  body: string
  id: string
  url: string | null
  type: string
}
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/events/react.mdx">
This can be used to listen to, for example, messages received in realtime.

```ts
const { data: client } = useWeb3InboxClient()

client.on('notify_message', ({ message }) => {
  console.log(notification.title)
})
```

#### References

- `message`: Notification of type:

```ts
interface NotifyNotification {
  title: string
  sentAt: number
  body: string
  id: string
  url: string | null
  type: string
}
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/initialization/javascript.mdx">
To setup the client you need to configure it with your `projectId` which you can obtain from [WalletConnect Cloud](https://cloud.walletconnect.com).

Furthermore you may need to configure the `domain` and `isLimited` parameters:

- `domain` defaults to `window.location.host` and must be set to the domain setup in Cloud Setup. For example `app.example.com`. Do not add the scheme (`https://`).
- `allApps` determines if your app has access to all of the user's subscriptions, or only the ones that the app is hosted on. By setting it to `true`, it enables setting `domain` to a value other than `window.location.host`. Setting `allApps: true` can be useful during development to allow your localhost-deployed app to access the subscriptions for the domain you setup. Note that most apps do not need to set this in production environments, as they only need access to their own subscriptions. When enabled, the user has to sign a SIWE message granting your app more permissions, and this requires additional consideration from the user.

```ts
const client = await Web3InboxClient.init({ projectId, domain, allApps })
```

#### References

- **projectId:** Your WalletConnect project ID
- **domain _(Optional)_:** Your app's domain. Defaults to `window.location.host`.
- **allApps _(Optional)_:** Set to `false` to request access to all of the user's notification subscriptions for all apps, instead of only `domain`. Defaults to `true`.
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/initialization/react.mdx">
To setup the client you need to configure it with your `projectId` which you can obtain from [WalletConnect Cloud](https://cloud.walletconnect.com).

Furthermore you may need to configure the `domain` and `isLimited` parameters:

- `domain` defaults to `window.location.host` and must be set to the domain setup in Cloud Setup. For example `app.example.com`. Do not add the scheme (`https://`).
- `allApps` determines if your app has access to all of the user's subscriptions, or only the ones that the app is hosted on. By setting it to `true`, it enables setting `domain` to a value other than `window.location.host`. Setting `allApps: true` can be useful during development to allow your localhost-deployed app to access the subscriptions for the domain you setup. Note that most apps do not need to set this in production environments, as they only need access to their own subscriptions. When enabled, the user has to sign a SIWE message granting your app more permissions, and this requires additional consideration from the user.

```ts
initWeb3inboxClient({ projectId, domain, allApps, logLevel })
```

#### References

- **projectId:** Your WalletConnect project ID
- **domain _(Optional)_:** Your app's domain. Defaults to `window.location.host`.
- **allApps _(Optional)_:** Set to `true` to request access to all of the user's notification subscriptions for all apps, instead of only `domain`. Defaults to `false`.
- **logLevel _(Optional)_:** Increase verbosity of console logging. Defaults to `error`. Can be set to `error`, `info`, or `debug`.
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/managing-notifications/javascript.mdx">
You can retrieve notifications using pagination. One approach is to provide the last notification's ID as the starting point:

```ts
const notificationsPage = client.getNotificationHistory({
  limit: 3,
  // The `id` of the last notification, for example:
  startingAfter: 'some-notification-id'
})

const notificationsPerPage = 5
const isInfiniteScroll = true
const unreadFirst = true

let notifications = []

const onUpdate = ({notifications: fetchedNotifications}: GetNotificationsReturn) => {
  notifications = fetchedNotifications
}

const {
  nextPage,
  markNotificationAsRead,
  markAllNotificationsAsRead
} = client.pageNotifications(
  notificationsPerPage,
  isInfiniteScroll,
  specifiedAccount // OR undefined,
  specifiedDomain // OR undefined,
  unreadFirst
)(onUpdate)


// marking a single notification as read
await notifications[0].markAsRead();

// mark specific notifications as read
await markNotificationsAsRead(notifications.slice(2).map(n => n.id));

// mark all notifications as read
await markAllNotificationsAsRead();
```

#### References

- **pageNotifications:**
  - **notificationsPerPage:** Number representing how many notifications to get per fetch
  - **isInfiniteScroll:** Whether or not to keep already fetched notifications when getting next page
  - \*_params:_ (optional) Additional parameters
  - **unreadFirst:** (optional, default `true`, since 1.3.0) Whether or not unread messages should be sorted at the top, regardless of timestamp
- **onUpdate:**: A callback that will be called whenever notifications get updated
- **nextPage:**: A function to be called to fetch the next page of notifications
- **notifications:** Array of notifications, of type
- **notification.markAsRead:** Mark the notification as read
- **markNotificationsAsRead**: Takes an array of notification IDs and marks them as read. Max 1000 IDs
- **markAllNotificationsAsRead**: Mark all notifications as read.

```ts
{
  title: string
  sentAt: number
  body: string
  id: string
  isRead: boolean // since 1.3.0
  url: string | null
  type: string
  read: () => Promise<void> // since 1.3.0
}
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/managing-notifications/react.mdx">
```ts
// watch notifications of current account's subscription to current dapp
const notificationsPerPage = 5
const isInfiniteScroll = true
const unreadFirst = true

const {
  data: notifications,
  nextPage,
  markNotificationsAsRead,
  markAllNotificationsAsRead
} = useNotifications(
  notificationsPerPage,
  isInfiniteScroll,
  account,
  domain,
  unreadFirst,
  onRead // optional function to run whenever messages are read
)

// marking a single notification as read
await notifications[0].markAsRead()

// mark specific notifications as read for default account and under default domain
await markNotificationsAsRead(notifications.slice(2).map(n => n.id))

// mark specific notifications as read for specified account under default domain
await markNotificationsAsRead(
  notifications.slice(2).map(n => n.id),
  differentAccount
)

// mark specific notifications as read for default account under specified domain
await markNotificationsAsRead(
  notifications.slice(2).map(n => n.id),
  undefined,
  differentDomain
)

// mark specific notifications as read for specified account under specified domain
await markNotificationsAsRead(
  notifications.slice(2).map(n => n.id),
  differentAccount,
  differentDomain
)

// mark all notifications as read for default account under default domain
await markAllNotificationsAsRead()

// mark all notifications as read for specified account under default domain
await markAllNotificationsAsRead(differentAccount)

// mark all notifications as read for default account under specified domain
await markAllNotificationsAsRead(undefined, differentDomain)

// mark all notifications as read for specified account under specified domain
await markAllNotificationsAsRead(differentAccount, differentDomain)
```

#### References

- **useNotifications()**
  - **notificationsPerPage:** Number representing how many notifications to get per fetch
  - **isInfiniteScroll:** Whether or not to keep already fetched notifications when getting next page
  - **params:** (optional) Additional parameters
  - **unreadFirst:** (optional, default `true`, since 1.3.0) Whether or not unread messages should be sorted at the top, regardless of timestamp
- **nextPage:** A function to be called to fetch the next page of notifications
- **notifications:** Array of notifications, of type
- **notification.read:** Mark the notification as read
- **markNotificationsAsRead**: Takes an array of notification IDs and marks them as read. Max 1000 IDs
- **markAllNotificationsAsRead**: Mark all notifications as read.

```ts
{
  title: string
  sentAt: number
  body: string
  id: string
  isRead: boolean
  url: string | null
  type: string
  markAsRead: () => Promise<void>
}
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/managing-subscription/javascript.mdx">
Subscribe, Unsubscribe, Get Subscription, Check if Subscribed.

:::note
When using `differentAccount`, the passed account needs to be previously registered.
This use case is for Dapps that have multiple active accounts or wallets with multiple active accounts.
`differentAccount` can be used for all the below hooks and functions that accept `account`
:::

```ts
// check if current account is subscribed to current dapp
const isSubscribed = client.isSubscribedToDapp()

// watch if current account is subscribed to current dapp
client.watchIsSubscribed(isSubbed => console.log({ isSubbed }))

// subscribe to current dapp with current account
await client.subscribeToDapp()

// subscribe to same dapp with different account
await client.subscribeToDapp(differentAccount)

// subscribe to different dapp with current account
await client.subscribeToDapp(undefined, differentDomain)

// subscribe to different dapp with different account
await client.subscribeToDapp(differentAccount, differentDomain)

// unsubscribe from current dapp with current account
await client.unsubscribeFromDapp()

// get current account's subscription to current dapp
const subscription = client.getSubscription()

// watch current account's subscription to current dapp
client.watchSubscription(subscription => console.log({ subscription }))

// get current account's subscriptions
const subscriptions = client.getSubscriptions()

// watch current account's subscriptions
client.watchSubscriptions(subscriptions => console.log({ subscriptions }))
```

#### References

- **account _(Optional)_:** CAIP-10 account
- **domain _(Optional)_:** dapp domain
- **subscription:** _Non-Reactive_ state, returning current subscription information, of type:

```ts
{
  topic: string
  account: string
  relay: relayertypes.protocoloptions
  metadata: Metadata
  scope: ScopeMap
  expiry: number
  symkey: string
  unreadCount: number
}
```

- **subscription:** _Non-Reactive_ state, returning array of current subscriptions
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/managing-subscription/react.mdx">
Subscribe, Unsubscribe, Get Subscription, Check if Subscribed.

:::note
When using `differentAccount`, the passed account needs to be previously registered.
This use case is for Dapps that have multiple active accounts or wallets with multiple active accounts.
`differentAccount` can be used for all the below hooks and functions that accept `account`
:::

```ts
const { subscribe, isLoading: isSubscribing } = useSubscribe()
const { unsubscribe, isLoading: isUnsubscribing } = useUnsubscribe()

// get subscription of current user to current dapp
const { data: subscription, getSubscription } = useSubscription()

// getSubscription can be used to get information about different dapps programatically
const subscriptionToSameDappFromDifferentAccount = getSubscription(differentAccount)
const subscriptionToDifferentDappFromSameAccount = getSubscription(undefined, differentDappDomain)
const subscriptionToDifferentDappFromDifferentAccount = getSubscription(
  differentAccount,
  differentDappDomain
)

// subscribe to current dapp from current user
subscribe()
// subscribe to current dapp from different user
subscribe(differentAccount)
// subscribe to different dapp from current user
subscribe(undefined, differentDappDomain)
// subscribe to different dapp from different user
subscribe(differentAccount, differentDappDomain)

// unsubscribe from current dapp
unsubscribe()

// get all subscriptions for current account
const subscriptions = useAllSubscriptions()

const isSubscribed = Boolean(subscription)
```

#### References

- **account _(Optional)_:** CAIP-10 account
- **domain _(Optional)_:** dapp domain
- **subscribe:** Function to subscribe to current dApp `() => void`
- **unsubscribe:** Function to unsubscribe to current dApp `() => void`
- **isSubscribed:** Reactive state, checking if subscribed to dApp `Boolean`
- **isSubscribing:** If `subscribe()` is in-progress and has not finished yet
- **isUnsubscribing:** If `unsubscribe()` is in-progress and has not finished yet
- **subscription:** Reactive state, returning current subscription information, of type:

```ts
{
  topic: string
  account: string
  relay: relayertypes.protocoloptions
  metadata: Metadata
  scope: ScopeMap
  expiry: number
  symkey: string
  unreadCount: number
}
```

- **subscriptions:** Reactive state, returning array of current subscriptions
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/registering-accounts/javascript.mdx">
**Note**: [EIP-1271 signatures](https://eips.ethereum.org/EIPS/eip-1271) coming from smart wallets are supported in version `1.1.0` and above.

```ts
import { signMessageAsync } from '@wagmi/core'

const { registerParams, signature } = await client.prepareRegistration({
  account
})
const isRegistered = await client.getAccountIsRegistered(account)
const signature = await signMessageAsync({ message })
await register({ registerParams, signature })
```

#### References

- **prepareRegistration:** Prepare registration params
- **register:** Register using a signature and register params
- **getAccountIsRegistered:** Returns if account is registered

Some suggested methods of signing the message:

- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)
- `@wagmi/core` [`signMessage` method](https://wagmi.sh/core/api/actions/signMessage)
- The [`useSignMessage` hook](https://wagmi.sh/react/hooks/useSignMessage) in `@wagmi`
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/registering-accounts/react.mdx">
**Note**: [EIP-1271 signatures](https://eips.ethereum.org/EIPS/eip-1271) coming from smart wallets are supported in version `1.1.0` and above.

```ts
import { useSignMessage } from '@wagmi'
const { signMessageAsync } = useSignMessage()

const { isRegistered } = useW3iAccount('eip155:1:0x9A...')

const { prepareRegistration } = usePrepareRegistration()
const { register, isLoading: isRegistering } = useRegister()

const handleRegistration = async () => {
  try {
    const { message, registerParams } = await prepareRegistration()
    const signature = await signMessageAsync({ message: message })
    await register({ registerParams, signature })
  } catch (registerIdentityError: any) {
    console.error(registerIdentityError)
  }
}
```

#### References

- **isRegistered:** A boolean of whether or not the account currently set is registered
- **prepareRegistration:** Prepare registration params
- **register:** Register using a signature and register params
- **isLoading:** A boolean, representing if an account is being registered

Some suggested methods of signing the message:

- `@wagmi/core` [`signMessage` method](https://wagmi.sh/core/api/actions/signMessage)
- The [`useSignMessage` hook](https://wagmi.sh/react/hooks/useSignMessage) in `@wagmi`
- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/registering-push/javascript.mdx">
If you wish to receive live push notifications to your React Native or Web app, you must integrate with Firebase Messaging. More information about how to integrate with Firebase can be found [here](https://firebase.google.com/docs/cloud-messaging).

Your integration will obtain a token from Firebase and you will need to pass this token to the Web3Inbox SDK using the `registerWithPushServer()` function.

```ts
import { getToken } from 'firebase/messaging

// initialize Firebase's messaging object via Firebase's `getMessaging` function

const firebaseToken = getToken(firebaseMessaging, {
  vapidKey: "YOUR_FIREBASE_VAPID_KEY"
})

// The Client ID that registered with this token, can be used for debugging purposes or logs
const clientId = client.registerWithPushServer(firebaseToken)
```

#### References

- `registerWithPushServer`: `(token: string, platform: 'fcm' | 'apns') => string`

Either APNS or FCM can be used to recieve push notifications. Token here is the respective platform's token.
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/registering-push/react.mdx">
If you wish to receive live push notifications to your React Native or Web app, you must integrate with Firebase Messaging. More information about how to integrate with Firebase can be found [here](https://firebase.google.com/docs/cloud-messaging).

Your integration will obtain a token from Firebase and you will need to pass this token to the Web3Inbox SDK using the `registerWithPushServer()` function.

```ts
import { getToken } from 'firebase/messaging'

const { data: client } = useWeb3InboxClient()

// initialize Firebase's messaging object via Firebase's `getMessaging` function

const firebaseToken = getToken(firebaseMessaging, {
  vapidKey: 'YOUR_FIREBASE_VAPID_KEY'
})

client.registerWithPushServer(firebaseToken)
```

#### References

- `registerWithPushServer`: `(token: string, platform: 'fcm' | 'apns' = 'fcm') => void`

Either APNs or FCM can be used to receive push notifications to the device. The `token` you provide may be a token from either platform, provided the `platform` argument matches.
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/setting-account/javascript.mdx">
```ts
await client.setAccount('eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029')

const account = client.getAccount() // eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029

client.watchAccount(account => {
  console.log({ account }) // eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029
})
```

### References

- **account:** CAIP-10 account currently active in Web3Inbox
- **setAccount:** Change actively managed account in Web3Inbox
- **watchAccount:** Watcher ticks whenever the account updates
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/setting-account/react.mdx">
```ts
const {
  data: account,
  isRegistered,
  identityKey,
  setAccount,
  error,
  isLoading
} = useW3iAccount('eip155:1:0x9A...')
```

### References

- **data:** CAIP-10 account currently active in Web3Inbox
- **setAccount:** Change actively managed account in Web3Inbox. Does not need to be used as you can set the account directly in the params.
- **isRegistered:** A boolean of whether or not the account currently set is registered
- **identityKey:** Currently set account's identity key
- **error:** A string, representing possible error of setting an account.
- **isLoading:** A boolean, representing if an account is being set
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/types/javascript.mdx">
```ts
// get scopes of current account's subscription to current dapp
const types = client.getNotificationTypes()

// watch scopes of specific account's subscription to specific dapp
client.watchNotificationTypes(scp => {
  console.log(scp)
})

client.update(['enabledType-1', 'enabledType-2'])
```

#### References

- **update:** `(enabledScopeNames: string[]) -> void`
- **types:** Map of scopes (Notification types)

```ts
type ScopeMap = Record<
  string,
  {
    name: string
    description: string
    enabled: boolean
  }
>
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/api/types/react.mdx">
```ts
const { data: types, update } = useNotificationTypes()
```

#### References

- **update:** `(enabledScopeNames: string[]) -> void`
- **types:** Map of scopes (Notification types)

```ts
type ScopeMap = Record<
  string,
  {
    name: string
    description: string
    enabled: boolean
  }
>
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/migration/javascript.mdx">
For developers using `@web3inbox/core` without the hooks, there are far less breaking changes.

#### Managing registration

Registration is now split into 2 steps to avoid the opinionated approach of passing `onSign` callback.

```typescript
import { useSignMessage } from '@wagmi'
const { signMessageAsync } = useSignMessage()

/* highlight-delete-start */
client.register(signMessageAsync)
/* highlight-delete-end */
/* highlight-add-start */
const { registerParams, message } = client.prepareRegistration({ account: 'eip155:1:0x..' })
const signature = await signMessageAsync(message)
client.register({ registerParams, signature })
/* highlight-add-end */
```

#### Managing Notifications

- `deleteMessage` has been removed.
- `pageNotifications` has been added to allow paging notifications
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/migration/react.mdx">
There are numerous breaking changes in the stable release.

#### Package rename

`@web3inbox/widget-react` has been renamed to `@web3inbox/react`

`@web3inbox/core` is still named the same.

#### Initializing the client

Previously, a use of hook was required to init the client and a separate hook was required to check for ready status.
Now, there is only a hook for checking ready status which is **recommended** to be used to be sure if web3inbox functionality is ready to use.
However, initiating the client is now done with a simple function call.

```typescript
/* highlight-delete-start */
import { useInitWeb3InboxClient } from '@web3inbox/widget-react'
/* highlight-delete-end */
/* highlight-add-start */
import { initWeb3InboxClient } from '@web3inbox/react'
/* highlight-add-end */

/* highlight-delete-start */
useInitWeb3inboxClient({ projectId, domain, isLimited })
/* highlight-delete-end */
/* highlight-add-start */
initWeb3inboxClient({ projectId, domain, allApps })
/* highlight-add-end */
```

#### Checking for client ready status

```typescript
import { useWeb3InboxClient } from '@web3inbox/react'

const { isLoading: w3iClientIsLoading } = useWeb3InboxClient()
```

#### Managing Accounts

Previously, the account needed to be set using `setAccount` and still had to be passed down to hooks like `useManageSubscriptions`. This is no longer
the case. Also, registration management was included in the same hook. Now they all follow single responsibility principle.

- **Setting accounts**

```typescript
/* highlight-delete-start */
- import { useW3iAccount } from "@web3inbox/widget-react"
/* highlight-delete-end */
/* highlight-add-start */
+ import { useWeb3InboxAccount } from "@web3inbox/react"
/* highlight-add-end */

/* highlight-delete-start */
- const { setAccount } = useW3iAccount()

setAccount(`eip155:1:0x...`)
/* highlight-delete-end */
/* highlight-add-start */
+ const { data: account } = useWeb3InboxAccount(`eip155:1:0x...`)
/* highlight-add-end */
```

- **Handling registration**

```typescript
/* highlight-delete-start */
- const handleRegistration = () => {
-   register(signMessageAsync)
- }
/* highlight-delete-end */
/* highlight-add-start */
+ const { prepareRegistration } = usePrepareRegistration();
+ const { register, isLoading: isLoadingRegister } = useRegister();
+ const handleRegistration = async () => {
+   try {
+     const { message, registerParams } = await prepareRegistration();
+     const signature = await signMessageAsync({ message: message });
+     await register({ registerParams, signature });
+   } catch (registerIdentityError: any) {
+     console.error(registerIdentityError)
+   }
+ };
/* highlight-add-end */
```

#### Managing notifications

Messages (notifications) function a little differently now. One of the big changes is that you can no longer delete messages.
Furthermore, messages can now be paged. For convenience, "infinte scroll" paging functionality is available, as in keeping older pages in the
returned array.

- **Retrieving notifications**

```typescript
/* highlight-delete-start */
- import { useMessages } from "@web3inbox/widget-react"
/* highlight-delete-end */
/* highlight-add-start */
+ import { useNotifications } from "@web3inbox/react"
/* highlight-add-end */

/* highlight-delete-start */
- const { messages } = useMessages()
/* highlight-delete-end */
/* highlight-add-start */
+ const notificationsPerPage = 5
+ const isInfiniteScroll = true
+
+ const { data: notifications, nextPage } = useNotifications(
+   notificationsPerPage,
+   isInfiniteScroll
+ )
+
+ const getMoreNotifications = () => {
+   nextPage()
+ }
/* highlight-add-end */
```

- **Retrieving notification types**

:::info Note

Notification images are retrieved from notification types now.

:::

Sizes of images available are: `sm`, `md` and `lg` for small, medium and large respectively.

```typescript
/* highlight-delete-start */
- import { useSubscriptionScopes } from "@web3inbox/widget-react"
/* highlight-delete-end */
/* highlight-add-start */
+ import { useNotificationTypes } from "@web3inbox/react"
/* highlight-add-end */

/* highlight-delete-start */
- const { scopes } = useSubscriptionScopes()
/* highlight-delete-end */
/* highlight-add-start */
+ const { data: notificationTypes } = useNotificationTypes()
+
+ const notificationImageUrl = notificationTypes[notification.type].imageUrls.md;
/* highlight-add-end */
```

#### Managing Subscriptions

Managing subscriptions has changed considerably. Previously there was a single hook and now there are numerous single responsibility hooks.

```typescript
/* highlight-delete-start */
- import { useManageSubscription } from "@web3inbox/widget-react"
/* highlight-delete-end */
/* highlight-add-start */
+ import { useSubscribe, useUnsubscribe, useSubscription } from "@web3inbox/react"
/* highlight-add-end */

/* highlight-delete-start */
- const { subscribe, unsubscribe, isSubscribed } = useManageSubscription()
/* highlight-delete-end */
/* highlight-add-start */
+ const { subscribe } = useSubscribe()
+ const { unsubscribe } = useUnsubscribe()
+ const { data: subscription } = useSubscription()
/* highlight-add-end */

/* highlight-delete-start */
- const { subscriptions } = useSubscriptions()
/* highlight-delete-end */
/* highlight-add-start */
+ const { data: subscriptions } = useSubscriptions()
/* highlight-add-end */
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/usage/example/javascript.mdx">
```ts
import { Web3InboxClient } from '@web3inbox/core'
import { signMessage } from '@wagmi/core'

const client = await Web3InboxClient.init({ projectId: '...' })

const account = 'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029'

// Set the account to a CAIP-10 account ID
await client.setAccount(account)

const { message, registerParams } = await client.prepareRegistration({ account })
const { signature } = await signMessage(message)
await client.register({ signature, registerParams })

// Get the current notification subscription or watch for updates
const subscription = client.getSubscription()
client.watchSubscription(subscription => console.log({ subscription }))

// Subscribe to the app
await client.subscribeToDapp()

// Get notification history
const notificationsPerPage = 5
const isInfiniteScroll = true

client.pageNotifications(
  notificationsPerPage,
  isInfiniteScroll
)(notifications => {
  // add logic to display notifications here.
  // if isInfiniteScroll is true, notifications will contain all notifications fetched so far, else it will only fetch current page
  // See API docs for more information on `pageNotifications()` and how to use `notifications`
})
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/usage/example/react.mdx">
Below is an example of adding the Web3Inbox SDK to a React project with wagmi. Wagmi is not required to use the Web3Inbox React hooks.

We have separated it so the initialization can be done executed once in the app, and the hooks can be used anywhere in the app.

```tsx
//App.tsx
import { initWeb3InboxClient } from "@web3inbox/react";

...
// The project ID and domain you setup in the Domain Setup section
const projectId = process.env.NEXT_PUBLIC_PROJECT_ID!;
const appDomain = process.env.NEXT_PUBLIC_APP_DOMAIN!;

initWeb3InboxClient({
  projectId,
  domain: appDomain,
  allApps: process.env.NODE_ENV !== "production",
});

```

```tsx
// Index.tsx
import {
  useNotifications,
  usePrepareRegistration,
  useRegister,
  useSubscribe,
  useSubscription,
  useUnsubscribe,
  useWeb3InboxAccount,
  useWeb3InboxClient
} from '@web3inbox/react'
import { useCallback, useEffect } from 'react'
import { useSignMessage, useAccount } from 'wagmi'

import Notifications from './Notifications'

export default function App() {
  // Wagmi Hooks
  const { address } = useAccount()
  const { signMessageAsync } = useSignMessage()

  // W3I Hooks
  const { prepareRegistration } = usePrepareRegistration()
  const { register, isLoading: isRegistering } = useRegister()
  const { data: w3iClient, isLoading: w3iClientIsLoading } = useWeb3InboxClient()
  const { isRegistered } = useWeb3InboxAccount(`eip155:1:${address}`)

  // Registration of your address to allow notifications
  // This is done via a signature of a message (SIWE) and the
  // signMessageAsync function from wagmi
  const handleRegistration = async () => {
    try {
      const { message, registerParams } = await prepareRegistration()
      const signature = await signMessageAsync({ message: message })
      await register({ registerParams, signature })
    } catch (registerIdentityError: any) {
      console.error(registerIdentityError)
    }
  }

  // Subscription to dapp notifications
  // Subscribe can be called as a function post registration
  // Can be moved above but shown for example clarity
  const { subscribe, isLoading: isSubscribing } = useSubscribe()
  const { unsubscribe, isLoading: isUnsubscribing } = useUnsubscribe()
  const { data: subscription } = useSubscription()
  const isSubscribed = Boolean(subscription)

  // Note: We are using AppKit for the dapp <> wallet connection.
  // The <w3m-button /> module is from AppKit. Check AppKit Docs for further info.
  return (
    <>
      <main className={styles.main}>
        {w3iClientIsLoading ? (
          <div>Loading W3I Client</div>
        ) : (
          <div>
            <h1>W3I QuickStart</h1>
            <w3m-button />
            <div className={styles.flexColumn}>
              <button onClick={handleRegistration} disabled={isRegistered}>
                {isRegistered ? 'Registered' : 'Register'}
              </button>
              <button
                onClick={isSubscribed ? unsubscribe : subscribe}
                disabled={isSubscribing || isUnsubscribing}
              >
                {isSubscribed ? 'Unsubscribe' : 'Subscribe'}
              </button>
              <hr />
              {isSubscribed ? <Notifications /> : null}
            </div>
          </div>
        )}
      </main>
    </>
  )
}
```

```tsx
// Notifications.tsx
import { useNotifications } from '@web3inbox/react'
import React from 'react'
import styles from '@/styles/Notifications.module.css'

function Notifications() {
  const { data: subscription } = useSubscription()
  const { data: notifications } = useNotifications(5)

  return (
    <div>
      <h2 className={styles.heading}>Notifications</h2>
      <p>You have {subscription.unreadCount} unread notifications.</p>
      <div className={styles.notificationsContainer}>
        {!notifications?.length ? (
          <p className={styles.fallbackText}>No notifications yet.</p>
        ) : (
          notifications.map(({ id, ...message }) => (
            <div key={id} className={styles.message}>
              <h3>{message.title}</h3>
              <p>{message.body}</p>
              <p>{message.isRead ? 'Read' : 'Unread'}</p>
              <button onClick={message.markAsRead}>Mark as read</button>
            </div>
          ))
        )}
      </div>
      <button onClick={nextPage}>Next page</button>
    </div>
  )
}

export default Notifications
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/usage/installation/javascript.mdx">
```bash npm2yarn
npm i @web3inbox/core
```
</file>

<file path="docs/appkit/shared/notifications/frontend-integration/usage/installation/react.mdx">
```bash npm2yarn
npm i @web3inbox/core @web3inbox/react
```
</file>

<file path="docs/appkit/shared/siwe/code.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```ts
import { SiweMessage } from 'siwe'
import {
    type SIWESession,
    type SIWEVerifyMessageArgs,
    type SIWECreateMessageArgs,
    createSIWEConfig,
    formatMessage,
  } from '@web3modal/siwe'

const BASE_URL = 'http://localhost:8080';

/* Function that returns the user's session - this should come from your SIWE backend */
async function getSession(){
   const res = await fetch(BASE_URL + "/session", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
    credentials: 'include',
  });
  if (!res.ok) {
      throw new Error('Network response was not ok');
  }
  
  const data = await res.json();
  return data == "{}" ?  null : data as SIWESession;
}

/* Use your SIWE server to verify if the message and the signature are valid */
 const verifyMessage = async ({ message, signature }: SIWEVerifyMessageArgs) => {
    try {
        const response = await fetch(BASE_URL + "/verify", {
            method: "POST",
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
            },
            mode: 'cors',
            body: JSON.stringify({ message, signature }),
            credentials: 'include'
        });

        if (!response.ok) {
            return false;
        }
        
        const result = await response.json();
        return result === true;
      } catch (error) {
        return false;
      }
}

// Check the full example for signOut and getNonce functions ... 

/* Create a SIWE configuration object */
const siweConfig = createSIWEConfig({
        getMessageParams: async () => ({
              domain: window.location.host,
              uri: window.location.origin, 
              chains: [1, 2020],
              statement: 'Please sign with your account',
            }),
        createMessage: ({ address, ...args }: SIWECreateMessageArgs) => formatMessage(args, address),
        getNonce,
        getSession,
        verifyMessage,
        signOut,
    })
```


## Server Side 
Setting up a backend server using Express for a web application that interacts with the Siwe protocol.

### Routes:

+ GET '/nonce': Generates and returns a nonce (single-use random number).
+ POST '/verify': Uses the Siwe protocol to verify the message, requiring a signature (the one you are going to approve throw the UX) and a nonce stored in the session.
+ GET '/session': Retrieves the stored Siwe object from the session.
+ GET '/signout': Clears the session.

```ts
import cors from 'cors';
import express from 'express';
import Session from 'express-session';
import { generateNonce,  SiweMessage } from 'siwe';

const app = express();

// configure cors and sessions
app.use(cors({
  origin: 'http://localhost:5173', // frontend URL
  credentials: true,
}))
app.use(express.json())
app.use(Session({
  name: 'siwe-quickstart',
  secret: "siwe-quickstart-secret",
  resave: true,
  saveUninitialized: true,
  cookie: { secure: false, sameSite: true }
}));

app.get('/nonce', function (_, res) {
    res.setHeader('Content-Type', 'text/plain');
    console.log("/nonce");
    res.send(generateNonce());
});

// verify the message
app.post('/verify', async (req, res) => {
    try {
      if (!req.body.message) {
        return res.status(400).json({ error: 'SiweMessage is undefined' });
      }
      let SIWEObject = new SiweMessage(req.body.message);
      const { data: message } = await SIWEObject.verify({ signature: req.body.signature, nonce: req.session.nonce });
      
      const address = message.address;
      const chainId = message.chainId;
      
      // save the session with the address and chainId (SIWESession)
      req.session.siwe = { address, chainId };
      req.session.save(() => res.status(200).send(true));
    } catch (e) {
      // clean the session
      req.session.siwe = null;
      req.session.nonce = null;
      req.session.save(() => res.status(500).json({ message: e.message }));
    }
  });

  /// ... check the github repository for the others endpoints

  // get the session
  app.get('/session', (req, res) => {
    res.setHeader('Content-Type', 'application/json');
    res.send(req.session.siwe);
  });  
```

Check the github full example to see the full flow working: [siwe-quickstart](https://github.com/WalletConnect/web-examples/tree/main/dapps/appkit-siwe/react/)

### `verifySignature`

Verify a SIWE signature.

```ts
import { verifySignature } from '@web3modal/siwe'

const isValid = await verifySignature({ address, message, signature, chainId, projectId })
```

</TabItem>
<TabItem value="legacy" label="Legacy">

With help of the [siwe package](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-frontend) we will create the required configuration for AppKit.

:::note
The nonce and verification process will be implemented in your backend. [Read more.](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-backend)
:::

```ts
import { SiweMessage } from 'siwe'
import { createSIWEConfig } from '@web3modal/siwe'
import type { SIWECreateMessageArgs, SIWEVerifyMessageArgs } from '@web3modal/siwe'

/* Function that creates a SIWE message */
function createMessage({ nonce, address, chainId }: SIWECreateMessageArgs){
  const message = new SiweMessage({
    version: '1',
    domain: window.location.host,
    uri: window.location.origin,
    address,
    chainId,
    nonce,
    statement: 'Sign in With Ethereum.'
  })

  return message.prepareMessage()
}

/* Function that returns the user's session */
async function getSession(){
  //...
}

/* Use your SIWE server to verify if the message and the signature are valid */
async function verifyMessage({ message, signature }: SIWEVerifyMessageArgs){
  try {
    const isValid = await validateMessage({ message, signature })

    return isValid
  } catch (error) {
    return false
  }
},

/* Create a SIWE configuration object */
const siweConfig = createSIWEConfig({
  createMessage,
  getNonce,
  getSession,
  verifyMessage,
  signOut
})
```

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/shared/siwe/parameters.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

#### getMessageParams `() => Promise<{ domain: string, uri: string, chains: number[], statement: string }>`

Parameters to create the SIWE message internally.

#### getNonce `() => Promise<string>`

The getNonce method functions as a safeguard against spoofing, akin to a CSRF token. The siwe package provides a generateNonce() helper, or you can utilize an existing CSRF token from your backend if available.

#### createMessage `(args: SIWECreateMessageArgs) => string`

The official siwe package offers a straightforward method for generating an EIP-4361-compatible message, which can subsequently be authenticated using the same package. The nonce parameter is derived from your getNonce endpoint, while the address and chainId variables are sourced from the presently connected wallet.

#### verifyMessage `(args: SIWEVerifyMessageArgs) => Promise<boolean>`

The function to ensure the message is valid, has not been tampered with, and has been appropriately signed by the wallet address.

#### getSession `() => Promise<SIWESession | null>`

The backend session should store the associated address and chainId and return it via the `getSession` method.

#### signOut `() => Promise<boolean>`

The users session can be destroyed calling `signOut`.

#### onSignIn `(session?: SIWESession) => void`

Callback when user signs in (Optional).

#### onSignOut `() => void`

Callback when user signs out (Optional).

#### signOutOnDisconnect `boolean`

- defaults to `true`

Whether or not to sign out when the user disconnects their wallet (Optional).

</TabItem>
<TabItem value="legacy" label="Legacy">

#### getNonce `() => Promise<string>`

The getNonce method functions as a safeguard against spoofing, akin to a CSRF token. The siwe package provides a generateNonce() helper, or you can utilize an existing CSRF token from your backend if available.

#### createMessage `(args: SIWECreateMessageArgs) => string`

The official siwe package offers a straightforward method for generating an EIP-4361-compatible message, which can subsequently be authenticated using the same package. The nonce parameter is derived from your getNonce endpoint, while the address and chainId variables are sourced from the presently connected wallet.

#### verifyMessage `(args: SIWEVerifyMessageArgs) => Promise<boolean>`

The `verifyMessage` method should lean on the siwe package's new

```js
SiweMessage(message).validate(signature)
```

to ensure the message is valid, has not been tampered with, and has been appropriately signed by the wallet address.

#### getSession `() => Promise<SIWESession | null>`

The backend session should store the associated address and chainId and return it via the `getSession` method.

#### signOut `() => Promise<boolean>`

The users session can be destroyed calling `signOut`.

#### onSignIn `(session?: SIWESession) => void`

Callback when user signs in (Optional).

#### onSignOut `() => void`

Callback when user signs out (Optional).

#### signOutOnDisconnect `boolean`

- defaults to `true`

Whether or not to sign out when the user disconnects their wallet (Optional).

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/shared/components.mdx">
import Table from '../../components/Table'

AppKit's [web components](https://www.webcomponents.org/) are custom and reusable HTML tags. They will work across modern browsers, and can be used with any JavaScript library or framework that works with HTML.

:::info
Web components are global html elements that don't require importing.
:::

### List of optional properties for AppKit web components

### `<w3m-button />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'disabled' },
      description: 'Enable or disable the button.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'balance' },
      description: "Show or hide the user's balance.",
      type: { code: "'show' or 'hide'" }
    },
    {
      variable: { code: 'size' },
      description: 'Default size for the button.',
      type: { code: "'md' or 'sm'" }
    },
    {
      variable: { code: 'label' },
      description: 'The text shown in the button.',
      type: { code: 'string' }
    },
    {
      variable: { code: 'loadingLabel' },
      description: 'The text shown in the button when the modal is open.',
      type: { code: 'string' }
    }
  ]}
/>

### `<w3m-account-button />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'disabled' },
      description: 'Enable or disable the button.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'balance' },
      description: "Show or hide the user's balance.",
      type: { code: "'show' or 'hide'" }
    }
  ]}
/>

### `<w3m-connect-button />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'size' },
      description: 'Default size for the button.',
      type: { code: "'md' or 'sm'" }
    },
    {
      variable: { code: 'label' },
      description: 'The text shown in the button.',
      type: { code: 'string' }
    },
    {
      variable: { code: 'loadingLabel' },
      description: 'The text shown in the button when the modal is open.',
      type: { code: 'string' }
    }
  ]}
/>

### `<w3m-network-button />`

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'disabled' },
      description: 'Enable or disable the button.',
      type: { code: 'boolean' }
    }
  ]}
/>
</file>

<file path="docs/appkit/shared/onramp.mdx">
---
title: On-Ramp
---

AppKit seamlessly incorporates Coinbase Pay, enabling users to sign in to their Coinbase accounts and utilize fiat payment methods for purchasing cryptocurrencies.

:::info Note
On-Ramp is supported in the latest version of AppKit. If you are using an older version, make sure you upgrade.
:::

## Integration

The On-Ramp feature is enabled by default, so no additional configuration is required. 

If you prefer to disable it, set the `enableOnramp` flag to `false` in the configuration of the `createWeb3Modal` function.

:::info Note
On-Ramp is now available on **Solana**. The configuration for On-Ramp on both EVM and Solana is the same. Please refer to the code snippet below.
:::

```ts
const modal = createWeb3Modal({
  //...
  chains: [mainnet],
  projectId,
  /* highlight-add-start */
  enableOnramp: false // Optional - true by default
  /* highlight-add-end */
})
```
</file>

<file path="docs/appkit/shared/options.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import Table from '../../components/Table'
import Button from '../../components/button'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Options

The following options can be passed to the `createWeb3Modal` function:

```ts
createWeb3Modal({ wagmiConfig, projectId, chains, ...options })
```

## defaultChain

You can set a desired chain for the initial connection:

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi","ethers","solana"]}>
<PlatformTabItem value="wagmi">

```ts
import { mainnet } from 'viem/chains'

createWeb3Modal({
  //...
  defaultChain: mainnet
})
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
const mainnet = {
  chainId: 1,
  name: 'Ethereum',
  currency: 'ETH',
  explorerUrl: 'https://etherscan.io',
  rpcUrl: 'https://cloudflare-eth.com'
}

createWeb3Modal({
  //...
  defaultChain: mainnet
})
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```ts
import { solana } from '@web3modal/solana/chains'

createWeb3Modal({
  //...
  defaultChain: solana
})
```

</PlatformTabItem>
</PlatformTabs>

## featuredWalletIds

Select wallets that are going to be shown on the modal's main view. Default wallets are MetaMask and Trust Wallet.
Array of wallet ids defined will be prioritized (order is respected).
These wallets will also show up first in `All Wallets` view.
You can find the wallets ids in [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet)

```ts
createWeb3Modal({
  //...
  featuredWalletIds: [
    '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
    '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
  ]
})
```

## allowUnsupportedChain

Allow users to switch to an unsupported chain.

```ts
createWeb3Modal({
  //...
  allowUnsupportedChain: true
})
```

## tokens

You can select tokens for AppKit to show the user's balance of. Each key represents the chain id of the token's blockchain.

```ts
createWeb3Modal({
  //...
  tokens: {
    1: {
      address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
      image: 'token_image_url' //optional
    },
    137: {
      address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',
      image: 'token_image_url' //optional
    }
  }
})
```

If you would like to remove default wallets completely, you can set the `featuredWalletIds` property to an empty array.

## chainImages

Add or override the modal's network images.

```ts
createWeb3Modal({
  // ...
  chainImages: {
    1: 'https://my.images.com/eth.png'
  }
})
```

## connectorImages

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi","ethers","solana"]}>
<PlatformTabItem value="wagmi">

Set or override the images of any [connector](https://wagmi.sh/core/connectors/injected). The key of each property must match the id of the connector.

```ts
createWeb3Modal({
  connectorImages: {
    coinbaseWallet: 'https://images.mydapp.com/coinbase.png',
    metamask: 'https://images.mydapp.com/metamask.png'
  }
})
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

Set or override the images of any connector.

```ts
createWeb3Modal({
  connectorImages: {
    coinbaseWallet: 'https://images.mydapp.com/coinbase.png',
    walletConnect: 'https://images.mydapp.com/walletconnect.png'
  }
})
```

</PlatformTabItem>
<PlatformTabItem value="solana">

Set or override the images of any connector.

```ts
createWeb3Modal({
  connectorImages: {
    coinbaseWallet: 'https://images.mydapp.com/coinbase.png',
    phantom: 'https://images.mydapp.com/phantom.png',
    walletConnect: 'https://images.mydapp.com/walletconnect.png'
  }
})
```

</PlatformTabItem>
</PlatformTabs>

## termsConditionsUrl

You can add an url for the _terms and conditions_ link.

```ts
createWeb3Modal({
  //...
  termsConditionsUrl: 'https://www.mytermsandconditions.com'
})
```

## privacyPolicyUrl

You can add an url for the _privacy policy_ link.

```ts
createWeb3Modal({
  //...
  privacyPolicyUrl: 'https://www.myprivacypolicy.com'
})
```

## enableAnalytics

Enable analytics to get more insights on your users activity within your [WalletConnect Cloud's dashboard](https://cloud.walletconnect.com)

```ts
createWeb3Modal({
  //...
  enableAnalytics: true
})
```

## enableSwaps

Enable or disable the swap feature in your AppKit. [Swaps](/appkit/react/transactions/swaps) feature is enabled by default.

```ts
createWeb3Modal({
  //...
  enableSwaps: false
})
```

## enableOnramp

Enable or disable the onramp feature in your AppKit. [Onramp](/appkit/react/transactions/onramp) feature is enabled by default.

```ts
createWeb3Modal({
  //...
  enableOnramp: false
})
```

<Button name="Learn More" url="/cloud/analytics" />

## customWallets

Add custom wallets to the modal. `CustomWallets` is an array of objects, where each object contains specific information of a custom wallet.

```ts
createWeb3Modal({
  //...
  customWallets: [
    {
      id: 'myCustomWallet',
      name: 'My Custom Wallet',
      homepage: 'www.mycustomwallet.com', // Optional
      image_url: 'my_custom_wallet_image', // Optional
      mobile_link: 'mobile_link', // Optional - Deeplink or universal
      desktop_link: 'desktop_link', // Optional - Deeplink
      webapp_link: 'webapp_link', // Optional
      app_store: 'app_store', // Optional
      play_store: 'play_store' // Optional
    }
  ]
})
```

## AllWallets

:::caution

If the "All Wallets" button is removed on mobile, all the mobile wallets that were not added on the main view of the modal **won't** be able to connect to your website via WalletConnect protocol.

:::

The `allWallets` parameter allows you to add or remove the "All Wallets" button on the modal.

<Table
  headers={['Value', 'Description']}
  data={[
    {
      value: { code: 'SHOW' },
      description: 'Shows the "All Wallets" button on AppKit.'
    },
    {
      value: { code: 'HIDE' },
      description: 'Removes the "All Wallets" button from AppKit.'
    },
    {
      value: { code: 'ONLY_MOBILE' },
      description: 'Shows the "All Wallets" button on AppKit only on mobile.'
    }
  ]}
/>

```ts
createWeb3Modal({
  //...
  allWallets: 'ONLY_MOBILE'
})
```

## includeWalletIds & excludeWalletIds

:::caution

Wallets that are either not included or excluded **won't** be able to connect to your website on mobile via WalletConnect protocol.

:::

### includeWalletIds

Override default recommended wallets that are fetched from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet).
Array of wallet ids defined will be shown (order is respected).
Unlike `featuredWalletIds`, these wallets will be the **only** ones shown in `All Wallets` view and as recommended wallets.
You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card.

```ts
createWeb3Modal({
  //...
  includeWalletIds: [
    '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
    '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
  ]
})
```

### excludeWalletIds

Exclude wallets that are fetched from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet).
Array of wallet ids defined will be excluded.
All other wallets will be shown in respective places.
You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card.

```ts
createWeb3Modal({
  //...
  excludeWalletIds: [
    '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
    '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
  ]
})
```

### Coinbase Smart Wallet

The Coinbase connector now includes a new flag to customize the Smart Wallet behavior.

:::info Note
To enable the Coinbase Smart Wallet feature, ensure that AppKit is updated to version 4.2.3 or higher. Additionally, if you are using Wagmi, verify that it is on the latest version.
:::

The `preference` (or `coinbasePreference`) flag accepts one of the following string values:

- `eoaOnly`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
- `smartWalletOnly`: Displays Smart Wallet popup.
- `all` (default): Supports both `eoaOnly` and `smartWalletOnly` based on context.

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers"]}>
<PlatformTabItem value="wagmi">

AppKit can be configured in **two** different ways: **Default** or **Custom**

Select your preferred configuration mode below:

<Tabs>
<TabItem value="default" label="Default">

```ts
export const config = defaultWagmiConfig({
  //...
  /* highlight-add-start */
  coinbasePreference: 'smartWalletOnly'
  /* highlight-add-end */
})
```

</TabItem>
<TabItem value="custom" label="Custom">

Learn more about the Coinbase connector in the [Wagmi documentation](https://wagmi.sh/react/api/connectors/coinbaseWallet#preference).

```ts
const config = createConfig({
  //...
  connectors: [
    coinbaseWallet({
      //...
      /* highlight-add-start */
      preference: 'smartWalletOnly'
      /* highlight-add-end */
    })
  ]
})
```

</TabItem>
</Tabs>

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
export const config = defaultConfig({
  //...
  /* highlight-add-start */
  coinbasePreference: 'smartWalletOnly'
  /* highlight-add-end */
})
```

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/shared/resources.mdx">
Main links for AppKit related content.

- [Examples](https://github.com/WalletConnect/web-examples/tree/main/dapps/web3modal)
- [GitHub Repository](https://github.com/WalletConnect/web3modal)
- [Website Laboratory](https://lab.web3modal.com)
</file>

<file path="docs/appkit/shared/smart-accounts.mdx">
## Overview

:::note
üí° Ensure you update Web3Modal to the latest version for optimal compatibility.
:::

Smart Accounts (SAs) are enabled by default within AppKit. These accounts enhance functionality by emitting 1271 and 6492 signatures, which should be taken into account for signature verification processes, such as Sign-In with Ethereum (SIWE).

### Deployment

Smart Accounts are deployed alongside the first transaction. Until deployment, a precalculated address, known as the counterfactual address, is displayed. Despite not being deployed, the account can still sign using 6492 signatures.

### Supported Networks

Smart Accounts are available on the following networks:

- Base Sepolia
- BSC (Binance Smart Chain)
- Fraximal
- Linea
- Mode
- Optimism
- Polygon
- Polygon Mumbai
- Sepolia

### User Eligibility

Smart Accounts are exclusively available for users utilizing email or social logins (any Magic login)

## FAQ

### What is a Smart Account?

A Smart Account in improves the traditional account experience by replacing Externally Owned Accounts (EOAs) with a Smart Contract that follows the [ERC-4337 standard](https://eips.ethereum.org/EIPS/eip-4337). This opens up many use cases that were previously unavailable. 

Smart Accounts do no require Private Keys or Seed Phrases, instead they rely on a key or multiple keys from designated signers to access the smart account and perform actions on chain. The keys can take multiple forms including passkeys and EOA signatures.

### What can I do with a Smart Account?

Smart accounts unlock a host of use cases that were previously unavailable with EOAs. Essentially anything that can be programmed into a smart contract can be used by Smart Accounts.

- **Automated Transactions:** Set up recurring payments or conditional transfers.
- **Multi-Signature Authorization:** Require multiple approvals for a transaction to increase security.
- **Delegated Transactions:** Allow a third party to execute transactions on your behalf under specific conditions.
- **Enhanced Security:** Implement complex security mechanisms such as time-locked transactions and withdrawal limits.
- **Interoperability:** Interact seamlessly with decentralized applications (dApps) and decentralized finance (DeFi) protocols.
- **Custom Logic:** Create custom transaction rules and workflows that align with personal or business requirements.

### How do I get a Smart Account?

Existing AppKit Universal Wallet Users will be given the option to upgrade their account to a smart account. Once you upgrade you will still be able to access your EOA and self-custody your account. 

New AppKit Universal Wallet Users will be given smart accounts by default when they login for the first time.

### Does it cost anything?

There is a small additional cost for activating your smart account. The activation fee is added to the first transaction and covers the network fees required for deploying the new smart contract onchain.

# What are account names?

Smart account addresses start with ‚Äô0x‚Äô followed by 42 characters, this is the unique address of your smart account on the network. ‚Äò0x‚Äô addresses like this are long, unwieldy and unmemorable. AppKit allows you to assign a more memorable name for your smart account using [ENS](https://ens.domains/). 

You can assign a name to your account and this will act as an alias for your account that can be shared publicly and provide a better user experience. AppKit account names are followed by the wcn.id. 
 

## What can I do with my account name?

As AppKit smart account addresses are the same across the supported networks, you only need one account name which can then be used across the networks. 

For example if you want someone to send you USDC on Polygon they can send it to ‚Äújohnsmith.wcn.id‚Äù. If you want someone wants to send you USDC on Optimism they can also use ‚Äújohnsmith.wcn.id‚Äù.
</file>

<file path="docs/appkit/shared/socials.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

To allow users to authenticate using their email or social accounts, you need to configure the `auth` parameter in the `defaultConfig` function.

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "solana"]}>
<PlatformTabItem value="wagmi">

```ts
const wagmiConfig = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  /* highlight-add-start */
  auth: {
    email: true, // default to true
    socials: ['google', 'x', 'github', 'discord', 'apple', 'facebook', 'farcaster'],
    showWallets: true, // default to true
    walletFeatures: true // default to true
  }
  /* highlight-add-end */
})
```

## Wagmi Connector

If you're using the `createConfig` function from Wagmi, you can enable social or email login by importing and adding the `authConnector` function in your configuration.

```ts
/* highlight-add-start */
import { authConnector } from '@web3modal/wagmi'
/* highlight-add-end */

//...

const wagmiConfig = createConfig({
  //...
  connectors: [
    //...

    authConnector({
      chains,
      options: { projectId },
      /* highlight-add-start */
      email: true, // default to true
      socials: ['google', 'x', 'github', 'discord', 'apple', 'facebook', 'farcaster'],
      showWallets: true, // default to true
      walletFeatures: true // default to true
      /* highlight-add-end */
    })
  ]
})
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
const modal = createWeb3Modal({
  ethersConfig: defaultConfig({
    metadata,
    //..
    /* highlight-add-start */
    auth: {
      email: true, // default to true
      socials: ['google', 'x', 'github', 'discord', 'apple', 'facebook', 'farcaster'],
      showWallets: true, // default to true
      walletFeatures: true // default to true
    }
    /* highlight-add-end */
  })
  //...
})
```

:::info

AppKit with ethers v5 does not support the `auth` parameter and social logins. If you're using ethers v5, please consider upgrading to ethers v6 following this [ethers migration guide](https://docs.ethers.org/v6/migrating/) and [AppKit Docs](https://docs.walletconnect.com/appkit/overview)
:::
</PlatformTabItem>

<PlatformTabItem value="solana">

```ts
const solanaConfig = defaultSolanaConfig({
  chains,
  projectId,
  metadata,
  /*highlight-add-start*/
  auth: {
    email: true, // default to true
    socials: ['google', 'x', 'discord', 'farcaster', 'github', 'apple', 'facebook'],
    showWallets: true, // default to true
    walletFeatures: true // default to true
    
  }
  /*highlight-add-end*/
})
```
</PlatformTabItem>
</PlatformTabs>

## Options

- email [boolean]: This boolean defines whether you want to enable email login. Default `true`
- socials [array]: This array contains the list of social platforms that you want to enable for user authentication. The platforms in the example include Google, X, GitHub, Discord, Apple, Facebook and Farcaster. Default `undefined`
- showWallets [boolean]: This boolean defines whether you want to show the wallet options on the first connect screen. If this is false and `socials` are enabled, it will show a button that directs you to a new screen displaying the wallet options. Default `true`
- walletFeatures [boolean]: This boolean defines whether you want to enable wallet features. Wallet features allow users to view their balance, send, receive, and buy funds through a clear user interface. Default `true`

## User flow

1. Users will be able to connect to you application by simply using an email address. AppKit will send to them a One Time Password (OTP) to copy and paste in the modal, which will help to
   verify the user's authenticity. This will create a non-custodial wallet for your user which will be available in any application that integrates AppKit and email login.

2. Eventually the user can optionally choose to move from a non-custodial wallet to a self-custodial one by pressing "Upgrade Wallet" on AppKit.
   This will open the _([WalletConnect secure website](https://secure.walletconnect.com/dashboard))_ that will walk your user through the upgrading process.

## UI Variants

AppKit SDK offers multiple UI variants to customize the user experience for the authentication process.

By configuring the `showWallets` option in the `auth` parameter, you can control the initial connect screen behavior:

- **`showWallets: true`**: When this option is enabled, the initial connect screen will display the available wallet options directly to the user. This allows users to choose their preferred wallet immediately.

<p align="center">
  <img width={300} src="/img/w3m/auth/modal_wallets.webp" />
</p>

- **`showWallets: false`**: If this option is disabled, the initial connect screen will show a button instead. When the user clicks this button, they will be directed to a new screen that lists all the available wallet options. This can help simplify the initial interface and reduce visual clutter.

<p align="center">
  <img width={300} src="/img/w3m/auth/modal_no_wallets.webp" />
</p>

By configuring the `socials` option in the `auth` parameter, you can control the amount of social providers you want to show on the connect screen:

- **`socials: ['google']`**: When you only set one social provider, it will give you a button with `connect with provider.

<p align="center">
  <img width={300} src="/img/w3m/auth/modal_one_social.webp" />
</p>

- **`socials: ['google', 'discord']`**: When you set 2 social provider, it will give you 2 buttons next to each other with the logo of the social provider

<p align="center">
  <img width={300} src="/img/w3m/auth/modal_two_social.webp" />
</p>

- **` socials: ['google', 'x', 'discord', 'apple', 'github']`**: When you set more than 2 social providers, the first provider in the array will get a button with `connect with provider`. The other providers will get a button with the logo of the social provider next to each other.

<p align="center">
  <img width={300} src="/img/w3m/auth/modal_wallets.webp" />
</p>

## Wallet Features

The AppKit SDK offers support for wallet features. By enabling wallet features, users can easily view their balance, send funds, receive payments, and buy additional funds within a clear user interface.
</file>

<file path="docs/appkit/shared/swaps.mdx">
The Swap feature allows users to exchange one cryptocurrency for another directly within the AppKit modal.
This feature is designed to provide a seamless and efficient swapping experience, leveraging our collaboration with [1inch](https://1inch.io/) as the swap provider.

## Availability

- **Requirement**: The Swap feature is available only to users who log in via email or social login. This is consistent with other wallet features such as sending tokens.
- **Transaction Fee**: WalletConnect charges a 0.85% transaction fee on all swaps.
- **Supported Tokens**: The tokens available for swapping are limited to those supported by 1Inch. Note that the availability of tokens may vary depending on the network.
- **Network Availability**: The Swap feature is not available on Sepolia or other testnets at this time.

## How to Use

:::caution
Swaps is currently in Beta. Users may experience changes or improvements in the functionality as we continue to develop and refine this feature.
:::

1. **Connect**: Ensure you are logged in via email or social login.
2. **Access Swap**: Navigate to the Swap feature within the account view.
3. **Select Tokens**: Choose the tokens you wish to swap from the available options.
4. **Type amount**: Enter your desired swap values. You can use the Max button to swap your all tokens or enter any specific number.
5. **See swap details**: Once you type amount value. You'll see the available quote details as received amount, network fee, maximum slippage, or price impact. 
6. **Confirm Swap**: Review the swap details, including the transaction fee, and confirm the swap.

## Integration

The Swaps feature is enabled by default, so no additional configuration is required. 

If you prefer to disable it, set the `enableSwaps` flag to `false` in the configuration of the `createWeb3Modal` function.

```ts
const modal = createWeb3Modal({
  //...
  chains: [mainnet],
  projectId,
  /* highlight-add-start */
  enableSwaps: false // Optional - true by default
  /* highlight-add-end */
})
```
</file>

<file path="docs/appkit/shared/theming.mdx">
import Table from '../../components/Table'

## ThemeMode

By default `themeMode` option will be set to user system settings 'light' or 'dark'. But you can override it like this:

```ts
createWeb3Modal({
  //...
  themeMode: 'light'
})
```

## themeVariables

By default `themeVariables` are undefined. You can set them like this:

```ts
createWeb3Modal({
  //...
  themeVariables: {
    '--w3m-color-mix': '#00BB7F',
    '--w3m-color-mix-strength': 40
  }
})
```

The following list shows the theme variables you can override:

<Table
  headers={['Variable', 'Description', 'Type']}
  data={[
    {
      variable: { code: '--w3m-font-family' },
      description: 'Base font family',
      type: { code: 'string' }
    },
    {
      variable: { code: '--w3m-accent' },
      description: 'Color used for buttons, icons, labels, etc.',
      type: { code: 'string' }
    },
    {
      variable: { code: '--w3m-color-mix' },
      description: 'The color that blends in with the default colors',
      type: { code: 'string' }
    },
    {
      variable: { code: '--w3m-color-mix-strength' },
      description: 'The percentage on how much "--w3m-color-mix" should blend in',
      type: { code: 'number' }
    },
    {
      variable: { code: '--w3m-font-size-master' },
      description: 'The base pixel size for fonts.',
      type: { code: 'string' }
    },
    {
      variable: { code: '--w3m-border-radius-master' },
      description: 'The base border radius in pixels.',
      type: { code: 'string' }
    },
    {
      variable: { code: '--w3m-z-index' },
      description: 'The z-index of the modal.',
      type: { code: 'number' }
    }
  ]}
/>
</file>

<file path="docs/appkit/unity/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/unity/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/unity/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/unity/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/unity/core/actions.mdx">
# Actions

## Modal Actions

### Open Modal

```csharp
// Open default view
Web3Modal.OpenModal();

// Open network selection view
Web3Modal.OpenModal(ViewType.NetworkSearch);

// Open account view
Web3Modal.OpenModal(ViewType.Account);
```

### Close Modal

```csharp
Web3Modal.CloseModal();
```

## Chain Actions

### Set active chain

```csharp
Chain newChain = ChainConstants.Chains.Ethereum;
await Web3Modal.NetworkController.ChangeActiveChainAsync(newChain);
```

### Get active chain

```csharp
Chain activeChain = Web3Modal.NetworkController.ActiveChain;
```

## Account Actions

### Get active account

```csharp
// Get active account in CAIP-10 format
Account account = Web3Modal.GetAccount();

Debug.Log(account.Address); // e.g. '0x12345...'
Debug.Log(account.ChainId); // e.g. 'eip155:1'
Debug.Log(account.AccountId); // e.g. 'eip155:1:0x12345...'
```

### Disconnect

```csharp
await Web3Modal.DisconnectAsync();
```
</file>

<file path="docs/appkit/unity/core/customization.mdx">
# Customization

The AppKit uses Unity's [UI Toolkit](https://docs.unity3d.com/Manual/UIElements.html) system.
By following this guide,you can customize the AppKit to match your game's style, even if you have minimal or no prior
knowledge of UI Toolkit.

![unity-appkit-customization](/assets/unity-appkit-customization.webp)

## Theming

The AppKit relies heavily on [Unity Style Sheet (USS) variables](https://docs.unity3d.com/Manual/UIE-USS-variables.html)
for easy customization of various UI aspects, such as colors, spacing, border radius, and more.

### Preparation

The first step in theming the AppKit is to create a custom panel settings asset, followed by a custom theme file.
Then, link them to the AppKit.

1. In Unity Editor, right-click in the Project window and select **Create -> UI Toolkit -> Panel Settings Asset**.
2. Right-click again in the Project window and select **Create -> UI Toolkit -> TSS Theme File**.
3. Select the newly created Panel Settings Asset, and in the Inspector window, assign the newly created TSS Theme File
to the `Theme Style Sheet` field.
4. In the same Inspector window, set `Reference DPI` to 160. This is the recommended DPI for the AppKit, but feel free
to adjust it to your needs.

![unity-appkit-custom-theme](/assets/unity-appkit-custom-theme.webp)

5. Open the TSS Theme File with your code editor and change the first line to:
```css
@import url("/Packages/com.walletconnect.web3modal/UI Toolkit/WUI Base Theme.tss");
```
6. Under `Web3Modal` prefab instance in your scene or prefab find `Modal` child object and assign the
newly created `Panel Settings Asset` to the `Panel Settings` field of `UI Document` component.

![unity-appkit-panel-settings](/assets/unity-appkit-panel-settings.webp)

Everything is set up, now you can start customizing the AppKit to match your game's style.

### Overriding Variables

To override a variable, simply add it to your TSS Theme File and assign a new value to it.
The example below changes the accent color to a shade of orange and the modal border color to a shade of gray.

```css
@import url("/Packages/com.walletconnect.web3modal/UI Toolkit/WUI Base Theme.tss");

* {
    --wui-color-accent-100: rgb(156, 81, 65);

    --wui-accent-glass-090: rgba(156, 81, 65, 0.9);
    --wui-accent-glass-080: rgba(156, 81, 65, 0.8);
    --wui-accent-glass-020: rgba(156, 81, 65, 0.2);
    --wui-accent-glass-015: rgba(156, 81, 65, 0.15);
    --wui-accent-glass-010: rgba(156, 81, 65, 0.1);
    --wui-accent-glass-005: rgba(156, 81, 65, 0.05);
    --wui-accent-glass-002: rgba(156, 81, 65, 0.02);
}

Modal {
    --wui-modal-border-color: #9a9085;
    --wui-modal-border-width: 3px;
}
```

You can find the list of all available variables in the [WUI Base Theme](https://github.com/WalletConnect/Web3ModalUnity/blob/main/Packages/com.walletconnect.web3modal/UI%20Toolkit/WUI%20Base%20Theme.tss)
file.

:::info
If you find that a variable is missing, please [open a GitHub issue](https://github.com/WalletConnect/Web3ModalUnity/issues/new?assignees=&labels=feature-request&projects=&template=feature-request.yml&title=%5Bfeature%5D+).
We will be happy to add it for you.
:::

### Custom Fonts

To override the default font, you need to add a custom font to your project and reference it in the TSS Theme File.
```css
@import url("/Packages/com.walletconnect.web3modal/UI Toolkit/WUI Base Theme.tss");

* {
    -unity-font-definition: resource("Custom Fonts/Comic Sans SDF Regular");
}
```

From the point of font asset management, the TextCore engine is very similar to TextMesh Pro. Please refer to
the [UI Toolkit documentation](https://docs.unity3d.com/Manual/UIE-get-started-with-text.html) for more information.


## Advanced Customization

The AppKit follows the MVP (Model-View-Presenter) architecture, allowing you to customize the UI and behavior by
replacing the default views and presenters with your own. Views load UXML layout files from the Resources folder and
configure bindings. Presenters handle the business logic and communicate with the views. In some cases, presenters can
build views dynamically and pass them to another view. Below are two examples showing how to customize both static
UXML-based views and dynamic views.

### Dynamic View Customization

The Account view has a list of buttons at the bottom. At the moment of writing, there are only two buttons in the list:
`Network` and `Disconnect`. Because in the future this list will include more buttons, some of which will depend
on project configuration, the list is built dynamically inside of `AccountPresenter`. In this example we will be
adding a custom button that opens OpenSea profile page of connected account.

Let's create a custom presenter and override the method that creates the bottom buttons list.

```csharp
public class CustomAccountPresenter : AccountPresenter
{
    public CustomAccountPresenter(RouterController router, VisualElement parent) : base(router, parent)
    {
    }

    protected override void CreateButtons(VisualElement buttonsListView)
    {
        base.CreateButtons(buttonsListView);
    }
}
```

Let's copy the button creation code from the base presenter and modify it to create an OpenSea button.

```csharp
private void CreateOpenSeaButton(VisualElement buttonsListView)
{
    var openSeaIcon = Resources.Load<Sprite>("OpenSea Logo");
    var openSeaButton = new ListItem(
        "OpenSea",
        openSeaIcon,
        OnOpenSeaButtonClick,
        iconType: ListItem.IconType.Circle,
        iconStyle: ListItem.IconStyle.Accent);

    Buttons.Add(openSeaButton);
    buttonsListView.Add(openSeaButton);
}

private void OnOpenSeaButtonClick()
{
    var address = Web3Modal.AccountController.Address;
    var url = $"https://opensea.io/{address}";
    Application.OpenURL(url);
}
```

Now we need to call `CreateOpenSeaButton` method from `CreateButtons` method. The final presenter should look like this:

```csharp
public class CustomAccountPresenter : AccountPresenter
{
    public CustomAccountPresenter(RouterController router, VisualElement parent) : base(router, parent)
    {
    }

    protected override void CreateButtons(VisualElement buttonsListView)
    {
        CreateOpenSeaButton(buttonsListView);

        base.CreateButtons(buttonsListView);
    }

    private void CreateOpenSeaButton(VisualElement buttonsListView)
    {
        var openSeaIcon = Resources.Load<Sprite>("OpenSea Logo");
        var openSeaButton = new ListItem(
            "OpenSea",
            openSeaIcon,
            OnOpenSeaButtonClick,
            iconType: ListItem.IconType.Circle,
            iconStyle: ListItem.IconStyle.Accent);

        Buttons.Add(openSeaButton);
        buttonsListView.Add(openSeaButton);
    }

    private void OnOpenSeaButtonClick()
    {
        var address = Web3Modal.AccountController.Address;
        var url = $"https://opensea.io/{address}";
        Application.OpenURL(url);
    }
}
```

The last step is to replace the default presenter with the custom one.

All screens in the AppKit modal (e.g. Account, Wallet Search, QR Code, etc.) are called `modal view`. The class that
is responsible for storing, hiding, and showing the modal views is `RouterController`. To replace a modal view implementation
with a custom one, you need to create a custom presenter and pass it to the `RegisterModalView` method of `RouterController`.

```csharp
// Get a reference to ModalController and cast it to ModalControllerUtk.
// ModalControllerUtk is used by UI Toolkit version of the AppKit.
// It's used on all platforms except WebGL.
var modalController = (ModalControllerUtk)Web3Modal.ModalController;
if (modalController != null)
{
    // Get RouterController
    var routerController = modalController.RouterController;

    // Create an instance of the custom presenter and register it as a `Account` modal view.
    var customAccountPresenter = new CustomAccountPresenter(routerController, routerController.RootVisualElement);
    routerController.RegisterModalView(ViewType.Account, customAccountPresenter);
}
```

You can register modal views at any point in the game lifecycle. The `RouterController` will dispose of the previous
presenter and replace it with the new one.

If you find that some parts of the presenter can't be customized, please [open a GitHub issue](https://github.com/WalletConnect/Web3ModalUnity/issues/new?assignees=&labels=feature-request&projects=&template=feature-request.yml&title=%5Bfeature%5D+).

### Static View Customization

All core views in the AppKit accept optional path to the UXML layout file in the constructor.

Let's extend the `CustomAccountPresenter` class we made in the previous example to use a custom UXML layout file.
To do so, override `CreateViewInstance` method and return a new instance of `AccountView` with a custom UXML layout path.

```csharp
protected override AccountView CreateViewInstance()
{
    return new AccountView("UI/CustomAccountView");
}
```

Make sure to link original or custom USS file from your UXML layout file.

## Example

You can find a complete example of the customization in the [Customization](https://github.com/WalletConnect/Web3ModalUnity/tree/main/Samples/Customization)
sample project.
</file>

<file path="docs/appkit/unity/core/events.mdx">
# Events

## Web3Modal Events

```csharp
//Invoked after successful initialization of Web3Modal
Web3Modal.Initialized += (sender, eventArgs) => { };

// Invoked after successful connection of an account
Web3Modal.AccountConnected += (sender, eventArgs) => {
    Account activeAccount = eventArgs.GetAccount();
};

// Invoked after successful disconnection of an account
Web3Modal.AccountDisconnected += (sender, eventArgs) => { };

// Invoked after account has changed
// This happens when the wallet updates a session or the user changes the active chain.
Web3Modal.AccountChanged += (sender, eventArgs) => {
    Account newAccount = eventArgs.Account;
};

// Invoked after active chain has changed
Web3Modal.ChainChanged += (sender, eventArgs) => {
    Chain newChain = eventArgs.Chain;
};
```
</file>

<file path="docs/appkit/unity/core/installation.mdx">
---
title: Installation
---

import CloudBanner from '../../../components/CloudBanner'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Unity

With AppKit, you can easily let people interact with multiple EVM compatible wallets and blockchains.

## Install

Let's get started by installing the package!

### Prerequisites

- Unity 2022.3 or above
- IL2CPP code stripping level: Minimal (or lower)
- Target platform: Android, iOS, Windows, macOS, WebGL
- Gamma color space
    - If you need Linear color space, please [open a GitHub issue](https://github.com/WalletConnect/Web3ModalUnity/issues/new?assignees=&labels=feature-request&projects=&template=feature-request.yml&title=%5Bfeature%5D+)

### Package

<Tabs>
<TabItem value="openupm-cli" label="OpenUPM CLI">

To install packages via OpenUPM, you need to have [Node.js](https://nodejs.org/en/) and [openupm-cli](https://openupm.com/docs/getting-started.html#installing-openupm-cli) installed. Once you have them installed, you can run the following commands:

```bash
openupm add com.walletconnect.web3modal
```

</TabItem>
<TabItem value="pm-openupm" label="Package Manager with OpenUPM">

1. Open `Advanced Project Settings` from the gear ‚öô menu located at the top right of the Package Manager‚Äôs toolbar
2. Add a new scoped registry with the following details:
   - Name: `OpenUPM`
   - URL: `https://package.openupm.com`
   - Scope(s): `com.walletconnect` and `com.nethereum`
3. Press plus ‚ûï and then `Save` buttons
4. In the Package Manager windows open the add ‚ûï menu from the toolbar
5. Select `Add package by name...`
6. Enter the package name:
   - `com.walletconnect.web3modal`
7. Press `Add` button

</TabItem>
</Tabs>

## Configure

The minimum configuration required is filling in a `Project ID` and `Metadata` fields inside of `WalletConnectProjectConfig` scriptable object. The scriptable object is automatically created after package installation. You can find it in the `Assets/WalletConnect/Resources` directory.

<CloudBanner />

- **Id**: The project ID is a unique identifier for your project.
  - If you don‚Äôt have a Project ID, you can create one at [WalletConnect Cloud](https://cloud.walletconnect.com).
- **Name**: The project name is a human-readable name for your project.
- **Description**: The project description is a human-readable description for your project.
- **URL**: The project URL
- **Icons**: At least one icon is required for the project.

Other fields are optional and will be covered in the next sections.

<img width="500px" src="/assets/unity-project-config.jpg" />

## Implement

1. Add `Web3Modal` prefab from `Packages/Web3Modal/Prefabs` to your scene.
2. Initialize Web3Modal from your script

```csharp
public async void Start()
{
    await Web3Modal.InitializeAsync();
}
```

3. Open the modal

```csharp
public void OpenModal()
{
    Web3Modal.OpenModal();
}
```
</file>

<file path="docs/appkit/unity/core/options.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Options

### Explorer included wallets

Allows to set included wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can define a list of wallets ids you'd like to prioritize (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```csharp
await Web3Modal.InitializeAsync(new Web3ModalConfig
{
    includedWalletIds = new []
    {
        "c57ca95...74e97267d96",
    }
});
```

### Explorer excluded wallets

Allows to set excluded wallets that are fetched from [WalletConnect Explorer](https://walletconnect.com/explorer?type=wallet). You can get these ids from the explorer link mentioned before by clicking on a copy icon of your desired wallet card.

```csharp
await Web3Modal.InitializeAsync(new Web3ModalConfig
{
    excludedWalletIds = new []
    {
        "c57ca95...74e97267d96",
    }
});
```

### Enable Installed Wallet Detection

To enable Web3Modal to detect wallets installed on mobile devices, you need to make specific changes to the native side of the project.

<Tabs>
<TabItem value="unity-installed-wallets-android" label="Android">

    1. In Unity [override Android Manifest](https://docs.unity3d.com/Manual/overriding-android-manifest.html).
    2. Add your `<queries>...</queries>` schemes outside of `<application />` scope in the manifest file.
    3. Refer to [Android Specs](https://developer.android.com/guide/topics/manifest/queries-element) for more information.

    Example:

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android">

        <queries>
            <package android:name="io.metamask"/>
            <package android:name="com.wallet.crypto.trustapp"/>
            <package android:name="io.gnosis.safe"/>
            <package android:name="me.rainbow"/>
            <!-- Add other wallet schemes names here -->
        </queries>

        <application>
            ...
        </application>
    </manifest>
    ```

    More wallet package names can be found in [our sample AndroidManifest.xml](https://github.com/WalletConnect/WalletConnectUnity/blob/project/modal-sample/Assets/Plugins/Android/AndroidManifest.xml).

</TabItem>
<TabItem value="unity-installed-wallets-ios" label="iOS">

    Wallet detection may produce inaccurate results on iOS Simulator. It is recommended to test on a real device.

    1. Make an iOS build.
    2. In the generated Xcode project, find `Info.plist` file and open it with a external editor (i.e. not Xcode).
    3. Locate or create `<key>LSApplicationQueriesSchemes</key>` section.
    4. Add the desired wallet schemes as string entries within the `<array>`. These schemes represent the wallets you want to detect.

    Example:

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
        <dict>
            ...

            <key>LSApplicationQueriesSchemes</key>
            <array>
                <string>metamask</string>
                <string>trust</string>
                <string>safe</string>
                <string>rainbow</string>
                <string>uniswap</string>
                <string>zerion</string>
                <string>imtokenv2</string>
                <string>spot</string>
                <string>omni</string>
                <string>dfw</string>
                <string>tpoutside</string>
                <string>robinhood-wallet</string>
            </array>

            ...
        </dict>
    </plist>
    ```

</TabItem>
</Tabs>


### Fullscreen in WebGL

The default `unityInstance.SetFullscreen(1)` method enables fullscreen for the canvas node by pushing
it to the [top layer](https://developer.mozilla.org/en-US/docs/Glossary/Top_layer).
This causes the modal to be rendered behind the canvas, making it invisible to the user when fullscreen is enabled.

To fix this, AppKit creates a container around the canvas node and appends the modal UI to it.
By requesting fullscreen on the container, the modal will always be rendered on top of the canvas.

```javascript
// Use this instead of unityInstance.SetFullscreen(1) to enable full screen
document.querySelector('#canvas-container').requestFullscreen();
```
</file>

<file path="docs/appkit/unity/core/usage.mdx">
import Button from '../../../components/button'

# Usage

After you have installed and configured AppKit,
you can start using it to interact with the wallet provider and blockchain.

AppKit comes with the [Nethereum](https://nethereum.com/) and [Wagmi](https://wagmi.sh/) integration out of the box.

To interact with EVM chains use `Web3Modal.Evm`. Internally, AppKit will use Wagmi on WebGL or Nethereum on other platforms.
Nethereum is already preconfigured with RPC URL and interceptor that will route the requests between the wallet provider and RPC node.

## Sending Ether

To send ether, you can use the `SendTransactionAsync` method of the `Web3.Eth` class.

```csharp
const string toAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
BigInteger amount = Web3.Convert.ToWei(0.001);
string result = await Web3Modal.Evm.SendTransactionAsync(toAddress, amount);

Debug.Log("Transaction hash: " + result);
```

This type of transaction uses the default amount of Gas 21000. Gas price is determined by the wallet provider.

## Reading Blockchain State

#### Get Ether Balance

```csharp
Account account = await Web3Modal.GetAccountAsync();
BigInteger balance = await Web3Modal.Evm.GetBalanceAsync(account.Address);

Debug.Log($"Balance: {Web3.Convert.FromWei(balance.Value)} ETH");
```

## Smart Contract Interaction

Use `ReadContractAsync` and `WriteContractAsync` methods of `Web3Modal.Evm` to interact with smart contracts.
To read or write a smart contract function, you need to provide the contract address, ABI, method name, and arguments.

### Get ERC20 Token Balance

To get the balance of an ERC20 token, you need to know the contract address, ERC20 standard contract ABI, and the owner address.
This operation doesn't involve state change on the blockchain, so it's a read-only action that doesn't require a transaction.

```csharp
const string contractAddress = "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984";
const string ownerAddress = "0x3D30B1aB88D487B0F3061F40De76845Bec3F1e94";
const string abi = "..."; // ABI of the ERC20 token contract

var evm = Web3Modal.Evm;
var balance = await evm.ReadContractAsync<BigInteger>(contractAddress, abi, "balanceOf", new object[]
{
    ownerAddress
});
var decimals = await evm.ReadContractAsync<BigInteger>(contractAddress, abi, "decimals");

var finalBalance = tokenBalance / BigInteger.Pow(10, tokenDecimal);
```

###

### Send ERC20 Token

To send an ERC20 token, you need to know the contract address, ERC20 standard contract ABI, recipient address, and the amount of tokens to send.
This operation requires a transaction and gas fees because it changes the state of the blockchain. User will need to confirm the transaction in the wallet.

```csharp
const string contractAddress = "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984";
const string recipientAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
const string abi = "...";  // ABI of the ERC20 token contract

BigInteger amount = 1;

// Arguments for the transfer method. The order of the arguments must match the order in the method signature.
// Method signature: `function transfer(address _to, uint256 _value) public returns (bool success)`
var arguments = new object[]
{
    recipientAddress,
    amount
};
var result = await Web3Modal.Evm.WriteContractAsync(contractAddress, abi, "transfer", arguments);
```
</file>

<file path="docs/appkit/vue/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/appkit/vue/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

import BlockchainAPI from '../../../cloud/blockchain-api.mdx'

<BlockchainAPI />
</file>

<file path="docs/appkit/vue/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/appkit/vue/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/appkit/vue/core/components.mdx">
---
title: Components
---

import Components from '../../shared/components.mdx'

# Web Components

<Components />
</file>

<file path="docs/appkit/vue/core/composables.mdx">
import Table from '../../../components/Table'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiComposables from '../wagmi/composables.mdx'
import EthersComposables from '../ethers/composables.mdx'

# Composables

Composables are functions that will help you control the modal, subscribe to wallet events and interact with them and smart contracts.

## useWeb3Modal

Control the modal with the `useWeb3Modal` function

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers"]}>
<PlatformTabItem value="wagmi">

```ts
import { useWeb3Modal } from '@web3modal/wagmi/vue'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```ts
import { useWeb3Modal } from '@web3modal/ethers5/vue'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
import { useWeb3Modal } from '@web3modal/ethers/vue'

export default function Component() {
  const { open, close } = useWeb3Modal()

  open()

  //...
}
```

</PlatformTabItem>
</PlatformTabs>

You can also select the modal's view when calling the `open` function

```ts
open({ view: 'Account' })
```

List of views you can select

<Table
  headers={['Variable', 'Description']}
  data={[
    {
      variable: { code: 'Connect' },
      description: 'Principal view of the modal - default view when disconnected'
    },
    {
      variable: { code: 'Account' },
      description: 'User profile - default view when connected'
    },
    {
      variable: { code: 'AllWallets' },
      description: 'Shows the list of all available wallets'
    },
    {
      variable: { code: 'Networks' },
      description:
        'List of available networks - you can select and target a specific network before connecting'
    },
    {
      variable: { code: 'WhatIsANetwork' },
      description: '"What is a network" onboarding view'
    },
    {
      variable: { code: 'WhatIsAWallet' },
      description: '"What is a wallet" onboarding view'
    },
    {
      variable: { code: 'OnRampProviders' },
      description: '"On-Ramp main view'
    }
  ]}
/>

## useDisconnect

```ts
const { disconnect } = useDisconnect()

disconnect()
```

## useWalletInfo

Metadata information from the connected wallet

```ts
import { useWalletInfo } from '@web3modal/wagmi/vue'

const { walletInfo } = useWalletInfo()

console.log(walletInfo.name, walletInfo.icon)
```

## Ethereum Library

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers"]}>
<PlatformTabItem value="wagmi">

<WagmiComposables />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersComposables />

</PlatformTabItem>
</PlatformTabs>

## useWeb3ModalState

Get the current value of the modal's state

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers"]}>
<PlatformTabItem value="wagmi">

```ts
import { useWeb3ModalState } from '@web3modal/wagmi/vue'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```ts
import { useWeb3ModalState } from '@web3modal/ethers5/vue'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```ts
import { useWeb3ModalState } from '@web3modal/ethers/vue'

const { open, selectedNetworkId } = useWeb3ModalState()
```

</PlatformTabItem>
</PlatformTabs>

The modal state consists of two reactive values:

<Table
  headers={['Value', 'Description', 'Type']}
  data={[
    {
      variable: { code: 'open' },
      description: 'Open state will be true when the modal is open and false when closed.',
      type: { code: 'boolean' }
    },
    {
      variable: { code: 'selectedNetworkId' },
      description: 'The current chain id selected by the user',
      type: { code: 'number' }
    }
  ]}
/>

## useWeb3ModalTheme

```ts
const { setThemeMode, setThemeVariables, themeMode, themeVariables } = useWeb3ModalTheme()

setThemeMode('dark')

setThemeVariables({
  '--w3m-color-mix': '#00BB7F',
  '--w3m-color-mix-strength': 40
})
```

## Track modal events

```ts
import { useWeb3ModalEvents } from '@web3modal/wagmi/vue'

const events = useWeb3ModalEvents()
```
</file>

<file path="docs/appkit/vue/core/custom-connectors.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Custom connectors

Add custom connectors for Ethers or Wagmi

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers", "solana"]}>
<PlatformTabItem value="wagmi">

If you already have Wagmi integrated into your application or would like more control over Wagmi's configuration, you can integrate Web3Modal on top of it.

```ts
import { createWeb3Modal } from '@web3modal/wagmi'

import { reconnect, http, createConfig } from '@wagmi/core'
import { sepolia } from '@wagmi/core/chains'
import { walletConnect } from '@wagmi/connectors'

const projectId = 'YOUR_PROJECT_ID'

const metadata = {
  //...
}

const config = createConfig({
  chains: [sepolia],
  transports: {
    [sepolia.id]: http()
  },
  connectors: [
    walletConnect({ projectId, metadata, showQrModal: false }), // showQrModal must be false.
    //other connectors...
  ]
})
reconnect(config)

const modal = createWeb3Modal({
  //...
  wagmiConfig: config,
})
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

Coming soon...

</PlatformTabItem>
<PlatformTabItem value="solana">
Add custom wallet adapters for Solana wallets by first installing the wallet adapter package and then including the adapters in the wallets array. You can find a more Solana wallet adapters [here](https://github.com/anza-xyz/wallet-adapter/tree/master/packages/wallets).

```bash npm2yarn
npm install @solana/wallet-adapter-solflare
```

```ts
import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/vue'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  //...
}

const solanaConfig = defaultSolanaConfig({
  chains,
  projectId,
  metadata
})

// 3. Create modal
const modal = createWeb3Modal({
  solanaConfig,
  projectId: projectId,
  metadata: metadata,
  chains,
  enableAnalytics: true,
  termsConditionsUrl: 'https://walletconnect.com/terms',
  privacyPolicyUrl: 'https://walletconnect.com/privacy',
  wallets: [
      new SolflareWalletAdapter(),
    ]
})
```
</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/vue/core/installation.mdx">
---
title: Installation
---

import CloudBanner from '../../../components/CloudBanner'
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

import WagmiImplementation from '../wagmi/about/implementation.mdx'
import WagmiModal from '../wagmi/about/triggermodal.mdx'

import Ethers5Implementation from '../ethers5/implementation.mdx'

import EthersImplementation from '../ethers/about/implementation.mdx'
import EthersModal from '../ethers/about/triggermodal.mdx'
import SolanaImplementation from '../solana/implementation.mdx'
import SolanaModal from '../solana/triggermodal.mdx'
import SolanaPrograms from '../solana/programs.mdx'

# Vue

## Introduction

AppKit has support for [Wagmi](https://wagmi.sh/), [Ethers](https://docs.ethers.org/v6/) and @solana/web3.js on Solana. Choose one of these ethereum libraries or solana to get started.

## Installation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>

<PlatformTabItem value="wagmi">

```bash npm2yarn
npm install @web3modal/wagmi @wagmi/core @wagmi/connectors viem
```

</PlatformTabItem>
<PlatformTabItem value="ethers5">

```bash npm2yarn
npm install @web3modal/ethers5 ethers@5.7.2
```

</PlatformTabItem>
<PlatformTabItem value="ethers">

```bash npm2yarn
npm install @web3modal/ethers ethers
```

</PlatformTabItem>
<PlatformTabItem value="solana">

```bash npm2yarn
npm install @web3modal/solana/vue
```

</PlatformTabItem>
</PlatformTabs>

<CloudBanner />

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

## Implementation

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiImplementation />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<Ethers5Implementation />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersImplementation />

</PlatformTabItem>
<PlatformTabItem value="solana">

<SolanaImplementation />

</PlatformTabItem>
</PlatformTabs>

## Trigger the modal

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers5","ethers","solana"]}>
<PlatformTabItem value="wagmi">

<WagmiModal />

</PlatformTabItem>
<PlatformTabItem value="ethers5">

<EthersModal />

</PlatformTabItem>
<PlatformTabItem value="ethers">

<EthersModal />

</PlatformTabItem>
<PlatformTabItem value="solana">
  <SolanaModal />
</PlatformTabItem>
</PlatformTabs>

## Smart Contract Interaction

<PlatformTabs groupId="eth-lib" activeOptions={["wagmi", "ethers","solana"]}>
<PlatformTabItem value="wagmi">

[Wagmi actions](https://wagmi.sh/core/api/actions/readContract) can help us interact with wallets and smart contracts:

```html
<script setup lang="ts">
  import { readContract } from '@wagmi/core'
  import { USDTAbi } from '../abi/USDTAbi'

  const USDTAddress = '0x...'

  const data = readContract({
    abi: USDTAbi,
    address: USDTAddress,
    functionName: 'symbol'
  })
</script>
```

Read more about Wagmi actions for smart contract interaction [here](https://wagmi.sh/core/actions/readContract).

</PlatformTabItem>
<PlatformTabItem value="ethers">

[Ethers](https://docs.ethers.org/v6/) can help us interact with wallets and smart contracts:

```html
<script setup lang="ts">
  import { BrowserProvider, Contract, formatUnits } from 'ethers'

  const USDTAddress = '0x617f3112bf5397D0467D315cC709EF968D9ba546'

  // The ERC-20 Contract ABI, which is a common contract interface
  // for tokens (this is the Human-Readable ABI format)
  const USDTAbi = [
    'function name() view returns (string)',
    'function symbol() view returns (string)',
    'function balanceOf(address) view returns (uint)',
    'function transfer(address to, uint amount)',
    'event Transfer(address indexed from, address indexed to, uint amount)'
  ]

  const walletProvider = modal.getWalletProvider()

  async function getBalance() {
    if (!isConnected) throw Error('User disconnected')

    const ethersProvider = new BrowserProvider(walletProvider)
    const signer = await ethersProvider.getSigner()
    // The Contract object
    const USDTContract = new Contract(USDTAddress, USDTAbi, signer)
    const USDTBalance = await USDTContract.balanceOf(address)

    console.log(formatUnits(USDTBalance, 18))
  }
</script>
```

</PlatformTabItem>

<PlatformTabItem value="solana">
  <SolanaPrograms />
</PlatformTabItem>

</PlatformTabs>
</file>

<file path="docs/appkit/vue/core/options.mdx">
---
title: Options
---

import Options from '../../shared/options.mdx'

# Options

<Options />
</file>

<file path="docs/appkit/vue/core/resources.mdx">
---
title: Resources
---

import Resources from '../../shared/resources.mdx'

# Resources

<Resources />
</file>

<file path="docs/appkit/vue/core/siwe.mdx">
---
title: One-Click Auth / SIWE
---

import SiweCode from '../../shared/siwe/code.mdx'
import SiweParams from '../../shared/siwe/parameters.mdx'

# Sign In With Ethereum

AppKit provides a simple solution for integrating with "Sign In With Ethereum" (SIWE), a new form of authentication that enables users to control their digital identity with their Ethereum account.
SIWE is a standard also known as [EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361).

## One-Click Auth

**One-Click Auth** represents a key advancement within WalletConnect v2, streamlining the user authentication process in AppKit by enabling them to seamlessly connect with a wallet and sign a SIWE message with just one click.

Connecting a wallet, proving control of an address with an off-chain signature, authorizing specific actions. These are the kinds of authorizations that can be encoded as ["ReCaps"](https://eips.ethereum.org/EIPS/eip-5573). ReCaps are permissions for a specific website or dapp that can be compactly encoded as a long string in the message you sign and translated by any wallet into a straight-forward one-sentence summary.
WalletConnect uses permissions expressed as ReCaps to enable a One-Click Authentication.

## Installation

<Tabs groupId="version">
<TabItem value="one-click-auth" label="One-Click Auth">

```bash npm2yarn
npm i @web3modal/siwe
```

</TabItem>
<TabItem value="legacy" label="Legacy">

:::caution
For a better UX we recommend using One-Click Auth.
:::

Install the AppKit SIWE package, additionally we also recommend installing [siwe](https://docs.login.xyz/) which will abstract a lot of the required logic.

```bash npm2yarn
npm i @web3modal/siwe siwe
```

</TabItem>
</Tabs>

## Configure your SIWE Client

<SiweCode />

## Initialize AppKit with your `siweConfig`

```ts
createWeb3Modal({
  //..
  siweConfig
})
```

## SIWE Config Parameters

<SiweParams />
</file>

<file path="docs/appkit/vue/core/theming.mdx">
import Theming from '../../shared/theming.mdx'

# Theming

<Theming />
</file>

<file path="docs/appkit/vue/ethers/about/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In your `App.vue` file set up the following configuration.

```html
<script setup lang="ts">
  import { createWeb3Modal, defaultConfig } from '@web3modal/ethers/vue'

  // 1. Get projectId from https://cloud.walletconnect.com
  const projectId = 'YOUR_PROJECT_ID'

  // 2. Set chains
  const mainnet = {
    chainId: 1,
    name: 'Ethereum',
    currency: 'ETH',
    explorerUrl: 'https://etherscan.io',
    rpcUrl: 'https://cloudflare-eth.com'
  }

  // 3. Create your application's metadata object
  const metadata = {
    name: 'My Website',
    description: 'My Website description',
    url: 'https://mywebsite.com', // url must match your domain & subdomain
    icons: ['https://avatars.mywebsite.com/']
  }

  // 4. Create Ethers config
  const ethersConfig = defaultConfig({
    /*Required*/
    metadata,

    /*Optional*/
    enableEIP6963: true, // true by default
    enableInjected: true, // true by default
    enableCoinbase: true, // true by default
    rpcUrl: '...', // used for the Coinbase SDK
    defaultChainId: 1, // used for the Coinbase SDK
  })

  // 5. Create a AppKit instance
  const modal = createWeb3Modal({
    ethersConfig,
    chains: [mainnet],
    projectId,
    enableAnalytics: true // Optional - defaults to your Cloud configuration  
  })
</script>

<template> // Rest of your app ... </template>
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/vue/ethers/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with the AppKit [**composables**](../../core/composables.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Components">

```html
<template>
  <w3m-button />
</template>
```

Learn more about the AppKit web components [here](../../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="composables" label="Composables">

You can trigger the modal by calling the `open` method from `useWeb3Modal` composable.

```html
<script setup lang="ts">
  import { useWeb3Modal } from '@web3modal/ethers/vue'
  // 4. Use modal composable
  const modal = useWeb3Modal()
</script>

<template>
  <button @click="modal.open()">Open Connect Modal</button>
  <button @click="modal.open({ view: 'Networks' })">Open Network Modal</button>
</template>
```

Learn more about the Web3Modal composables [here](../../core/composables.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/vue/ethers/composables.mdx">
import Button from '../../../components/button'

### useWeb3ModalAccount

Hook that returns the client's information.

```tsx
import { useWeb3ModalAccount } from '@web3modal/ethers/vue'

const { address, chainId, isConnected } = useWeb3ModalAccount()
```

### useSwitchNetwork

```tsx
import { useSwitchNetwork } from '@web3modal/ethers/vue'

const chainId = 137

const { switchNetwork } = useSwitchNetwork()

switchNetwork(chainId)
```

### useWeb3ModalProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from 'ethers'
import { useWeb3ModalProvider } from '@web3modal/ethers/vue'

const { walletProvider } = useWeb3ModalProvider()

async function onSignMessage() {
  const provider = new BrowserProvider(walletProvider)
  const signer = await provider.getSigner()
  const signature = await signer?.signMessage('Hello AppKit Ethers')
  console.log(signature)
}
```

### useWeb3ModalError

```ts
import { useWeb3ModalError } from '@web3modal/ethers/react'

const { error } = useWeb3ModalError()
```

<Button
  name="Learn More About Ethers"
  url="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="docs/appkit/vue/ethers5/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In your `App.vue` file set up the following configuration.

```html
<script setup lang="ts">
  import { createWeb3Modal, defaultConfig } from '@web3modal/ethers5/vue'

  // 1. Get projectId at https://cloud.walletconnect.com
  const projectId = 'YOUR_PROJECT_ID'

  // 2. Set chains
  const mainnet = {
    chainId: 1,
    name: 'Ethereum',
    currency: 'ETH',
    explorerUrl: 'https://etherscan.io',
    rpcUrl: 'https://cloudflare-eth.com'
  }

  // 3. Create your application's metadata object
  const metadata = {
    name: 'My Website',
    description: 'My Website description',
    url: 'https://mywebsite.com', // url must match your domain & subdomain
    icons: ['https://avatars.mywebsite.com/']
  }

  // 4. Create Ethers config
  const ethersConfig = defaultConfig({
    /*Required*/
    metadata,

    /*Optional*/
    enableEIP6963: true, // true by default
    enableInjected: true, // true by default
    enableCoinbase: true, // true by default
    rpcUrl: '...', // used for the Coinbase SDK
    defaultChainId: 1 // used for the Coinbase SDK
  })

  // 5. Create a AppKit instance
  const modal = createWeb3Modal({
    ethersConfig,
    chains: [mainnet],
    projectId,
    enableAnalytics: true // Optional - defaults to your Cloud configuration  
  })
</script>

<template> // Rest of your app ... </template>
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/vue/ethers5/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../core/components.mdx) or build your own button with the AppKit [**composables**](../core/composables.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Components">

```html
<template>
  <w3m-button />
</template>
```

Learn more about the AppKit web components [here](../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="composables" label="Composables">

You can trigger the modal by calling the `open` method from `useWeb3Modal` composable.

```html
<script setup lang="ts">
  import { useWeb3Modal } from '@web3modal/ethers5/vue'
  // 4. Use modal composable
  const modal = useWeb3Modal()
</script>

<template>
  <button @click="modal.open()">Open Connect Modal</button>
  <button @click="modal.open({ view: 'Networks' })">Open Network Modal</button>
</template>
```

Learn more about the Web3Modal composables [here](../core/composables.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/vue/notifications/authorization-signatures/all-apps.mdx">
# Signing the message: ‚ÄúI further authorize this app to view and manage my notifications for ALL apps‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you may be presented with a signature request that reads the following message:

> I further authorize this app to view and manage my notifications for ALL apps. Read more at https://walletconnect.com/notifications-all-apps

For any signature request, it‚Äôs critical that you always read the message attached before signing in order to fully understand the permissions you‚Äôre granting.

Take caution when signing this request as doing so will allow the app to:

- Subscribe you to notifications from any app
- Manage your notifications for any app
- View your notifications from any app

The app will not be able to:

- Sign blockchain transactions or additional messages

Typically, apps you subscribe to for notifications will send a slightly [different request](this-app) that asks you to only authorize them to manage notifications _for that app only_ upon signing. You should only ever be presented with the message shown in the example above when an app requires wider access to your subscriptions and messages.

A common example of this would be an app that enables you to view notifications and messages from multiple apps, like a wallet or the [Web3Inbox.com app](https://app.web3inbox.com).

Always be cautious when granting this permission to an app, and ensure that you‚Äôre familiar with the app sending the request.

## Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/all-apps/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/all-apps/message.jpg" />
</div>
</file>

<file path="docs/appkit/vue/notifications/authorization-signatures/overview.mdx">
# Authorization Signatures

When a user wants to enable notifications with an app or wallet, they must sign a SIWE message with their account granting that app access to view and manage their notifications. The SIWE message varies depending on whether the app is requesting access to manage all app notifications, or just that app's notifications. Below are the two possible SIWE messages the user would be requested to sign:

- [I authorize [...] this app](this-app)
- [I authorize [...] all apps](all-apps)
</file>

<file path="docs/appkit/vue/notifications/authorization-signatures/this-app.mdx">
# Signing the message: ‚ÄúI further authorize this app to send me notifications‚Äù

When subscribing to notifications from an app that uses Web3Inbox, you'll likely be presented with a signature request that reads the following message:

> I further authorize this app to send me notifications. Read more at https://walletconnect.com/notifications

For any signature request, it‚Äôs critical that you always read the message attached before signing to fully understand the permissions you‚Äôre granting.

By signing this request, you‚Äôre allowing the app to:

- Subscribe you to notifications from only this app
- Manage your notifications for only this app
- View your notifications from only this app

The app will not be able to:

- Sign blockchain transactions or additional messages
- Subscribe to, manage, or view notifications from other apps

Most apps that send notifications using Web3Inbox will request for you to sign this message&mdash;this will allow the app to simply interact with you directly. If you wish to opt-in to receive notifications from this app, signing this message will enable you to do so.

If you‚Äôve signed up to notifications but have received a different message, head [here](all-apps) to learn about other scenarios in which you may receive a signature request regarding notifications.

### Example wallet signature requests

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridGap: 16 }}>
  <img src="/assets/web3inbox/authorization-signatures/this-app/sign-this-message.jpg" />
  <img src="/assets/web3inbox/authorization-signatures/this-app/message.jpg" />
</div>
</file>

<file path="docs/appkit/vue/notifications/frontend-integration/api.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CloudBanner from '../../../../components/CloudBanner'

import Initialization from '../../../shared/notifications/frontend-integration/api/initialization/javascript.mdx'
import SettingAccount from '../../../shared/notifications/frontend-integration/api/setting-account/javascript.mdx'
import Registering from '../../../shared/notifications/frontend-integration/api/registering-accounts/javascript.mdx'
import Managing from '../../../shared/notifications/frontend-integration/api/managing-subscription/javascript.mdx'
import ManagingNotifications from '../../../shared/notifications/frontend-integration/api/managing-notifications/javascript.mdx'
import Types from '../../../shared/notifications/frontend-integration/api/types/javascript.mdx'
import RegisteringPush from '../../../shared/notifications/frontend-integration/api/registering-push/javascript.mdx'
import Events from '../../../shared/notifications/frontend-integration/api/events/javascript.mdx'

# API

## Initialization

<Initialization/>

## Managing Account

### Setting account for web3inbox

<SettingAccount/>

### Registering an account

<Registering/>

## Managing Subscription

<Managing/>

## Managing Notifications

<ManagingNotifications/>

## Notification Types

<Types/>

## Registering for Device Push Notifications

<RegisteringPush/>

## Listening For Events

<Events/>
</file>

<file path="docs/appkit/vue/notifications/frontend-integration/examples.mdx">
# Examples

- Our production [GM App](https://gm.walletconnect.com) which sends daily "gm!" notifications to all subscribers.
- [React GM Dapp](https://github.com/WalletConnect/gm-dapp) - a Web3Inbox Dapp using React, Typescript, Next.js & Ethers.
- Bare bones [template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) demonstrating basic functionality in an easy to base from way.
</file>

<file path="docs/appkit/vue/notifications/frontend-integration/migration-guide.mdx">
import Migration from '../../../shared/notifications/frontend-integration/migration/javascript.mdx'

# Migration Guide

## General Migration notes

- `isLimited` flag has been removed in favor of `allApps` flag. They essentially mean the opposite thing.
- Deleting messages is no longer possible
- Messages are now stored on notify server and can be paged
- Registration is more flexible since it is now split into 2 functions

## Migrating from 0.x to 1.0.0

<Migration/>
</file>

<file path="docs/appkit/vue/notifications/frontend-integration/usage.mdx">
import Installation from '../../../shared/notifications/frontend-integration/usage/installation/javascript.mdx'
import Example from '../../../shared/notifications/frontend-integration/usage/example/javascript.mdx'

# Usage

AppKit Notifications provides you the building blocks necessary to allow users to subscribe, receive notifications, and manage notification preferences, all from your app's UI. The Web3Inbox SDK supports both React hooks and JavaScript-based integrations.

Before begin using Web3Inbox, you will first need to [setup your project](../cloud-setup) to send notifications.

## Installation

<Installation/>

## Example Usage

This basic example demonstrates how to use the AppKit Notifications to subscribe to notifications and receive them in your app. Refer to the [API Reference](./api) for more details on the available methods.

<Example/>

## UX Guidelines

For the best user experience we have several recommendations on how to build the Web3Inbox flows into your app:

- Have an explicit opt-in UI to subscribe to notifications. Some users may not want to receive notifications, and enabling notifications requires the user to sign a message with their blockchain account. Enabling notifications should be optional, and if they do enable them they should be told that they will need to sign a message to enable this.
- Have a button to unsubscribe from notifications once they are enabled. Users may want to stop receiving notifications, so you should have a button to unsubscribe from notifications if the user wants to.
- Make use of [notification types](../cloud-setup#notification-types). These allow the user fine-grained control over what types of notifications they want to receive from your app. These allow users to only unsubscribe from the specific notifications they are no longer interested in, rather than needing to unsubscribe from your entire app. Your app should include functionality to manage notification preferences.
</file>

<file path="docs/appkit/vue/notifications/backend-integration.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Backend Integration

Once an account is subscribed to your app's notifications you can test sending notifications to the account. You can subscribe in your app directly with our [Frontend Integration](frontend-integration/usage), or with one of the below testing options.

We recommend testing notifications with the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to your phone. You can also try one of our sample wallets:

- [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
- [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

## Authentication

To send notifications and access all subscriber information for your dapp, you will need your Notify API Secret and project ID.

You can find the Notify API Secret under the Notify API section of the APIs tab of your project on [WalletConnect Cloud](https://cloud.walletconnect.com). Follow steps on the [Cloud Setup](cloud-setup) page to configure this. This secret allows publishing notifications to any account subscribed to your app, so should not be published and should only be used by your app backend.

## Sending notifications

Only plaintext is supported, and newlines are ignored.

To send a notification notification you can call the `/notify` endpoint. This endpoint supports the following fields:

- `type` - The Notification type ID copied from WalletConnect Cloud.
- `title` - The title of the notification. Max 64 characters.
- `body` - The body of the notification containing more detail. Max 255 characters.
- `url` (optional) - A URL attached to the notification that the user can navigate to. Max 255 characters.
- `accounts` - A list of [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) account IDs for which to send the notification to. Max 500 accounts per request. Also see the [rate limits](#rate-limits) below.
- `notification_id` (optional) - An idempotency key of arbitrary format used to dedup multiple requests. Max 255 characters. Multiple calls with the same `notification_id` will use the first call's `notification` content, but will send to any additional account IDs listed in `accounts`.

```typescript
type RequestBody = {
  notification_id?: string | null
  notification: {
    type: string
    title: string
    body: string
    url?: string | null
  }
  accounts: string[]
}
```

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/notify`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    notification: {
      type: 'a1e53b95-18e5-4af8-9f03-9308ec87b687',
      title: 'The price of Ethereum has risen',
      body: 'The price of Ethereum has gone up 10%',
      url: 'https://app.example.com'
    },
    accounts: ['eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029']
  })
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/<PROJECT_ID>/notify' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "notification": {
      "type": "a1e53b95-18e5-4af8-9f03-9308ec87b687",
      "title": "The price of Ethereum has risen",
      "body": "The price of Ethereum has gone up 10%",
      "url": "https://app.example.com"
    },
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029"
    ]
  }'
```

</TabItem>

</Tabs>

## Get subscribers

You can tell if an account is subscribed and get information about subscribers using the `/v1/<project-id>/subscribers` endpoint. You can provide up to 100 accounts in the request.

If the account is subscribed, it will be returned as a key in the response along with a list of subscribed notification types as the value. If the account is not a subscriber, it will not be returned in the response.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const requestBody: RequestBody = {
  accounts: [
    'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029',
    'eip155:1:0x0000000000000000000000000000000000000000'
  ]
}

const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/subscribers`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
  body: JSON.stringify(requestBody)
})

const subscribers: ResponseBody = await response.json()

type RequestBody = {
  // Max 100 accounts
  accounts: string[]
}
type ResponseBody = {
  [account: string]: Subscriber
}
type Subscriber = {
  notification_types: string[]
}
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>' \
  --header 'Content-Type: application/json' \
  --data '{
    "accounts": [
      "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029",
      "eip155:1:0x0000000000000000000000000000000000000000"
    ]
  }'
```

</TabItem>

</Tabs>

Example response:

```jsonc
{
  "eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029": {
    "notification_types": ["4d1c97ad-c182-4097-8f2c-8f80c0674df2"]
  }
}
```

## Get all subscribers

:::caution
This endpoint will download _all_ subscribers of your app, which is an expensive operation and can take several seconds to complete. Because of this, it has a low rate limit.
:::

You can get a list of all of the currently-subscribed accounts by calling the `/<project-id>/subscribers` endpoint.

Example usage:

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/${PROJECT_ID}/subscribers`, {
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
const subscribers: string[] = await response.json()
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl 'https://notify.walletconnect.com/<PROJECT_ID>/subscribers' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Mark all notifications as read

Unless marked as read by an app frontend, notifications will always be "unread". Because of this, when you
initially add support for displaying unread status or unread count to your frontend, users that have received
notifications in the past will have notifications display as "unread" even if they already have seen them.
This can potentially be an undesireable user experience.

To mitigate this problem, you can make a one-time call to the `/v1/<project-id>/mark-all-as-read` API endpoint
which will mark all existing notifications as read. Notifications marked as read in this way will not contribute
to read rate analytics. After you deploy your integration of unread states, you can call this endpoint to
reset the unread state for all of your existing notifications.

<Tabs queryString={'api-client'}>

<TabItem value="javascript" label="JavaScript">

```typescript
const PROJECT_ID = '<PROJECT_ID>'
const NOTIFY_API_SECRET = '<NOTIFY_API_SECRET>'
const response = await fetch(`https://notify.walletconnect.com/v1/${PROJECT_ID}/mark-all-as-read`, {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${NOTIFY_API_SECRET}`
  }
})
```

</TabItem>

<TabItem value="curl" label="cURL">

```bash
curl -X POST 'https://notify.walletconnect.com/v1/<PROJECT_ID>/mark-all-as-read' \
  --header 'Authorization: Bearer <NOTIFY_API_SECRET>'
```

</TabItem>

</Tabs>

## Rate limits

To protect our system and subscribers, various limits and rate limits are in-place.

Rate limits are implemented as [token bucket](https://en.wikipedia.org/wiki/Token_bucket) and contain both rate and burst amounts. On average, a rate of requests can be made. However, since real-world applications often make requests in bursts, this fixed rate can be surpassed temporarily up to the burst amount, provided the app subsequently makes requests below the average in order to recover its bursting capability.

- `POST /<project-id>/notify`:
  - Each app can send 2 notifications per hour to an account, with a burst up to 50. Accounts that have been rate limited will be returned in the request response. Exceptions may be made on a per-project basis for special circumstances.
  - Each app can call this endpoint 2 times per second with a burst up to 20. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/subscribers`
  - Each app can call this endpoint 100 times per second with a burst up to 100. Rate limited requests will return a 429 status code.
- `GET /<project-id>/subscribers`
  - Each app can call this endpoint 1 time every 5 minutes with a burst up to 2. Rate limited requests will return a 429 status code.
- `POST /v1/<project-id>/mark-all-as-read`
  - Each app can call this endpoint 1 time per hour with a burst up to 5. Rate limited requests will return a 429 status code.
</file>

<file path="docs/appkit/vue/notifications/cloud-sending.mdx">
import useBaseUrl from '@docusaurus/useBaseUrl'

# Sending with Cloud

You can send notifications to subscribed users easily in [WalletConnect Cloud](https://cloud.walletconnect.com). Sending to users involves targeting particular [notification types](./cloud-setup#notification-types) who will receive your notification if they have not opted-out. You can specify a title and body for the notification, as well as a call-to-action link which users will be taken to when clicking on the notification.

Users can subscribe to your app in [several places](overview#subscribing-and-receiving-notifications) including the [Web3Inbox.com app](https://app.web3inbox.com), in your app with our [frontend SDK](frontend-integration/usage), or in supporting wallets.

To send notifications, you can use the utility provided in [WalletConnect Cloud](https://cloud.walletconnect.com) under the Notify API section:

1. In the APIs tab of your project, navigate to the Notify API section. You should see a banner with a link to the Send Notification playground.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground.png')} />

1. This allows you to send notifications to your subscribers. After you select the associated project, you can select the notification type, title, body, and link to send to your subscribers.

   <img className="image-margin" src={useBaseUrl('/img/w3i/notify-playground-send.png')} />
</file>

<file path="docs/appkit/vue/notifications/cloud-setup.mdx">
import CloudBanner from '../../../components/CloudBanner'
import useBaseUrl from '@docusaurus/useBaseUrl'

# Cloud Setup

This page explains the configuration required in order to obtain a Notify API Secret and configure your project to send notifications.

For a quick start to experiment with, you can try the [web3inbox template](https://github.com/WalletConnect/web3inbox-client/tree/main/apps/web) and following the steps in the README.

<CloudBanner />

## Domain to use

It is important to understand what domain you are using for your project as you are required to host a static file (the `did.json` file) on this domain before being able to use Notify API. The [WalletConnect Cloud](https://cloud.walletconnect.com) and clients receiving and managing your notifications use this file to authenticate that your domain is associated with the source of the notifications.

You can pick 1 domain and this is configured in the Dapp URL field of the Notify API section of the [WalletConnect Cloud](https://cloud.walletconnect.com). You may change your domain at any time, as long as you properly host the new `did.json` file there. Note that only one project may use a given domain at the same time.

During development it is optional to use your production domain for testing. Instead, you can use a staging domain, or even a entirely separate domain e.g. Vercel test site. However, once you move to production you will need to update your domain to your production domain and host a new file there.

Note that the file must be hosted on a real, publicly accessible, domain in order to verify its legitimacy. The use of `localhost` or other local addresses is not allowed.

## Dapp name, description, and logo

The dapp name, description, and logo are displayed in wallets that integrate Notify API as well as in the [Web3Inbox.com app](https://app.web3inbox.com). These details should be provided for the best user experience and to help the user identify your app.

## Notification types

Notification types are an important feature of Notify API and are a way for a user to have control over what types of notifications they receive. Users can change their notification types at any time in your app, their wallet, or the [Web3Inbox.com app](https://app.web3inbox.com). When sending notifications, you must use one of these configured notification types which you reference in code by its UUID.

Notification types are configured with a name, description, and icon which allow the user understand what types of notifications they would receive for that type. When a user receives a push notification on their device, they will see the icon that is configured with the notification type. Examples of notification types may include "Account updates" or "Service updates".

:::info
By default users are subscribed to all available notification types. However, it's worth nothing that if you add new notification types later users will not be automatically subscribed to them. If you have new notification types available, you may consider sending a notification informing users of this new available notification type and ask users to enable it. You may also add functionality to your app frontend to subscribe the user to the new notification type when they visit your app. Because of the additional effort in subscribing users to notification types after they initially subscribe, it is worth considering in advance what notification types you may need in the future.
:::

## Setup steps

### Navigating to Notify API section

In [WalletConnect Cloud](https://cloud.walletconnect.com), navigate to the APIs tab of your project.

<img className="image-margin" src={useBaseUrl('/img/w3i/1.png')} />

### Configuring Notify API

Under Notify API > Configuration > `DAPP INFORMATION`, fill in the Dapp URL field. This is the domain of your app that you will use to publish notifications.

<img className="image-margin" src={useBaseUrl('/img/w3i/dapp-info.png')} />

### Adding Notification Image and Types

Under the same section, next to Notification types, click on the "Add Notification Type" button and add a title, notification image and description for your notification type. This is the type of notification that your app will publish.

For example, if you are going to send promotional content as notification, you might want to add a notification type called "Promotional" with a description "Promotional content from the XYZ Team.".
You can also add a relevant image for the notification type.

<img className="image-margin" src={useBaseUrl('/img/w3i/notification-type.png')} />

### Saving Changes

Optionally, you can add a logo and description for your project. This will be shown to users when they subscribe to your app. Click "Save" to save your changes.

### Notify Secret

Take note of your new Notify API Secret. You will need this to publish notifications. This secret
allows publishing notifications to any account subscribed to your app, so should not be published
and should only be used by your app backend.

<img className="image-margin" src={useBaseUrl('/img/w3i/3.png')} />

### Hosting did.json file

Next, you will need to host `did.json` file on this page at the `/.well-known/` directory of your public URL. Please also ensure that your application has CORS enabled. An example is linked [here.](https://github.com/WalletConnect/gm-dapp/blob/main/next.config.js)

- Download `did.json` (click on `DID:WEB` section to show the download button ) and host it at, for example, `https://app.example.com/.well-known/did.json`
  <img className="image-margin" src={useBaseUrl('/img/w3i/did.png')} />

### Enabling Welcome Notifications

Welcome Notifications are notifications that are sent to users when they subscribe to your app. This is a great way to welcome users to your app and explain what types of notifications they will receive.

To enable Welcome Notifications, switch on the toggle in the Welcome Notifications section of your WalletConnect Cloud project after adding relevant Notification Type, Title, Body & Link.

<img className="image-margin" src={useBaseUrl('/img/w3i/welcome.png')} />

### Enabling Notify API

Once all changes have been saved and the `did.json` file has been deployed successfully, switch on the toggle switch in the Notify API section of your WalletConnect Cloud project. If everything is configured correctly, you should see a success toast: "Notify configuration successfully verified"

<img className="image-margin" src={useBaseUrl('/img/w3i/5.png')} />
<img className="image-margin" src={useBaseUrl('/img/w3i/6.png')} />

## Send Notifications in Cloud

Once you have completed the setup steps, you can now send notifications to users who have subscribed to your app. [Read more](./cloud-sending)

## Next steps

1. Now you are ready for accounts to subscribe to your app and send notifications to them using your Notify API Secret or with WalletConnect Cloud.

   - Read more on [sending notifications with WalletConnect Cloud](./cloud-sending)
   - Read more on [frontend integration](./frontend-integration/usage)
   - Read more on [backend integration](./backend-integration)

1. If you haven't already, [verify your apps domain](../cloud/verify) for improved security.



1. Navigate to the `Metrics` tab and select Web3Inbox from the dropdown to access analytics for your app. [Learn more about Web3Inbox Analytics](../cloud/analytics#web3inbox).

   <img className="image-margin" src={useBaseUrl('/img/w3i/metrics.png')} />
</file>

<file path="docs/appkit/vue/notifications/demo.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Demo

## Try AppKit Notifications

The fastest way to try AppKit Notifications is to go to [app.web3inbox.com](https://app.web3inbox.com) and try subscribing to some dapps. The [Web3Inbox.com app](https://app.web3inbox.com) is a universal inbox for web3 users to access all their notifications in one place.

- [Web3Inbox.com app](https://app.web3inbox.com)

Or access the repo at [github.com/WalletConnect/web3inbox](https://github.com/WalletConnect/web3inbox/).

## Native notifications

AppKit Notifications also supports native notifications on iOS and Android. To try native notifications, you can use the [Web3Inbox.com app](https://app.web3inbox.com) and subscribe to dapps or build one of our sample apps.

A wallet that supports Notify is required to receive notifications.

## Wallet notifications

To try wallet notifications on a iOS or Android device, use a wallet that supports Notify. Alternatively, try building one of our sample apps, or grab a sample wallet preview build from Testflight or Firebase.

<PlatformTabs
	groupId="w3iw"
	activeOptions={["ios", "android", "web"]}
>

<PlatformTabItem value="web">
- [React Native](../../../walletkit/react-native/notifications/notify/installation)

</PlatformTabItem>

<PlatformTabItem value="ios">

- [Swift](../../../walletkit/ios/notifications/notify/installation)
- [Testflight](https://testflight.apple.com/join/09bTAryp)

</PlatformTabItem>

<PlatformTabItem value="android">

- [Kotlin](../../../walletkit/android/notifications/notify/installation)
- [Firebase](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/appkit/vue/notifications/overview.mdx">
# Introduction

AppKit Notifications provides a toolkit for integrating Web3 notification features into apps. AppKit Notifications can be used to send notifications from your app directly to wallets.

This SDK utilizes WalletConnect's Notify API and is designed for Web3 scenarios, providing event-based notifications for activities like DAO votes, DeFi transaction alerts, and updates for NFT holders. Apps can send notifications to subscribed accounts, and users can receive and view their notifications in a supporting wallet, in the [Web3Inbox.com app](https://app.web3inbox.com), or in the app's frontend. Users can also discover Notify-compatible apps in their wallet or the [Web3Inbox.com app](https://app.web3inbox.com) to subscribe to.

AppKit Notifications is not to be confused with the [Web3Inbox.com app](https://app.web3inbox.com) which allows users to receive and manage their notifications from all apps, as they would in a wallet.

![Web3Inbox](/assets/web3inbox/w3i-hero.png)

## Getting Started

AppKit Notifications can be added to your app in a few steps:

- [Setup your project](cloud-setup) to send authenticated notifications.
- Use our [frontend SDK](frontend-integration/usage) to enable users to subscribe to notifications in your app.
- Finally, use [WalletConnect Cloud](cloud-sending) or our [API in your backend](backend-integration) to send notifications to subscribed users.

## Overview

Some of the key features of AppKit Notifications include:

- **Device push notifications:** Push notifications to the user's wallet (if it supports Notify API) or the [Web3Inbox.com app](https://app.web3inbox.com).
- **Notification history:** Notifications are stored and can be accessed from any device.
- **Spam protection/subscription control.** Using notification types, subscribers can opt-out of certain notification types they do not want to receive.
- **Tracking read status across devices.**

## Subscribing and receiving notifications

Users can receive notifications in several places:

- In the [Web3Inbox.com app](https://app.web3inbox.com) which supports push notifications and can be installed to the user's phone
- In your app's frontend using our [frontend SDK](frontend-integration/usage)
- Natively in their wallet if the wallet supports Notify API.
  - You can also test with one of our sample wallets:
    - [iOS sample wallet](https://testflight.apple.com/join/09bTAryp)
    - [Android sample wallet](https://appdistribution.firebase.dev/i/d2c86e879abd5a86)

Users can also subscribe to notifications in all of the above locations too. To be discoverable in the Web3Inbox.com app or in wallets, apps must submit an explorer listing.

## Try it out

See the [demo section](demo) for sample apps and the Web3Inbox universal inbox app.

## FAQ

### What chains does AppKit Notifications support?

AppKit Notifications supports EOA accounts on all `eip155` (EVM) chains, and smart accounts on all `eip155` chains that our Blockchain API [supports](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md). We have plans to expand support in the future.
</file>

<file path="docs/appkit/vue/onboarding/ens.mdx">
# ENS Provider
</file>

<file path="docs/appkit/vue/onboarding/graduation.mdx">
# Graduation
</file>

<file path="docs/appkit/vue/onboarding/smart-accounts.mdx">
---
title: Smart Accounts
---

import SmartAccount from '../../shared/smart-accounts.mdx'

<SmartAccount />
</file>

<file path="docs/appkit/vue/onboarding/socials.mdx">
---
title: Email & Socials
---

import Socials from '../../shared/socials.mdx'

<Socials />
</file>

<file path="docs/appkit/vue/solana/about/implementation.mdx">
In your `App.vue` file set up the following configuration

```html
<script setup>
  
  import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/vue'
  import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'
  import { reconnect } from '@wagmi/core'

  // 1. Define constants
  const projectId = process.env.VUE_APP_PROJECT_ID // get it from cloud.walletconnect.com

  // 2. Create wagmiConfig
  const metadata = {
    name: 'Appkit Solana',
    description: 'Appkit Solana Example',
    url: 'https://web3modal.com', // origin must match your domain & subdomain
    icons: ['https://avatars.githubusercontent.com/u/37784886']
  }

  const chains = [solana, solanaTestnet, solanaDevnet]
  const solanaConfig = defaultSolanaConfig({
    metadata,
    chains,
    projectId
  })

  reconnect(solanaConfig)

  // 3. Create modal
  createWeb3Modal({
    solanaConfig,
    chains,
    projectId
  })
</script>

<template>
  // Rest of your app ...
</template>

```
</file>

<file path="docs/appkit/vue/solana/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**composables**](../../core/composables.mdx#useweb3modal).
In this example we are going to use the `<w3m-button>` component.

Web components are global html elements that don't require importing.

```html
<template>
  <w3m-button />
</template>
```

Learn more about the AppKit web components [here](../../core/components.mdx)
</file>

<file path="docs/appkit/vue/solana/implementation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

In your `App.vue` file set up the following configuration.

```html
<script setup lang="ts">
import { createWeb3Modal, defaultSolanaConfig } from '@web3modal/solana/vue'
import { solana, solanaTestnet, solanaDevnet } from '@web3modal/solana/chains'

// 0. Setup chains
const chains = [solana, solanaTestnet, solanaDevnet]

// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create solanaConfig
const metadata = {
  name: 'Web3Modal',
  description: 'Web3Modal Solana Example',
  url: 'https://web3modal.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/37784886']
}

// 4. Create Solana config
const solanaConfig = defaultSolanaConfig({
  metadata,
  chains,
  projectId
})

// 5. Create a Web3Modal instance
createWeb3Modal({
  solanaConfig,
  chains,
  projectId,
  wallets: [
      // Solana wallet adapters (check Custom connectors for more info)
  ]
})

</script>

<template> // Rest of your app ... </template>
```

:::note IMPORTANT
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify.mdx) to tell wallets if your application has been verified or not.
:::
</file>

<file path="docs/appkit/vue/solana/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to this [demo app](https://appkit-solana.vercel.app/).

```tsx
import { ref } from 'vue';
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js';
import { useWeb3ModalAccount, useWeb3ModalProvider } from '@web3modal/solana/react';

export default {
  setup() {
    const counterMessage = ref('');
    const { address, currentChain } = useWeb3ModalAccount();
    const { walletProvider, connection } = useWeb3ModalProvider();

    function deserializeCounterAccount(data) {
      if (data?.byteLength !== 8) {
        throw Error('Need exactly 8 bytes to deserialize counter');
      }

      return {
        count: Number(data[0])
      };
    }

    async function onIncrementCounter() {
      try {
        const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy');

        const counterKeypair = Keypair.generate();
        const counter = counterKeypair.publicKey;

        const balance = await connection.getBalance(walletProvider.publicKey);
        if (balance < LAMPORTS_PER_SOL / 100) {
          throw Error('Not enough SOL in wallet');
        }

        const COUNTER_ACCOUNT_SIZE = 8;
        const allocIx = SystemProgram.createAccount({
          fromPubkey: walletProvider.publicKey,
          newAccountPubkey: counter,
          lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
          space: COUNTER_ACCOUNT_SIZE,
          programId: PROGRAM_ID
        });

        const incrementIx = new TransactionInstruction({
          programId: PROGRAM_ID,
          keys: [
            {
              pubkey: counter,
              isSigner: false,
              isWritable: true
            }
          ],
          data: Buffer.from([0x0])
        });

        const tx = new Transaction().add(allocIx).add(incrementIx);

        tx.feePayer = walletProvider.publicKey;
        tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash;

        await walletProvider.signAndSendTransaction(tx, [counterKeypair]);

        const counterAccountInfo = await connection.getAccountInfo(counter, {
          commitment: 'confirmed'
        });

        if (!counterAccountInfo) {
          throw new Error('Expected counter account to have been created');
        }

        const counterAccount = deserializeCounterAccount(counterAccountInfo?.data);

        if (counterAccount.count !== 1) {
          throw new Error('Expected count to have been 1');
        }

        counterMessage.value = `[alloc+increment] count is: ${counterAccount.count}`;
      } catch (error) {
        console.error(error);
        counterMessage.value = `Error: ${error.message}`;
      }
    }

    return {
      onIncrementCounter,
      counterMessage
    };
  }
};
```
</file>

<file path="docs/appkit/vue/solana/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open Web3Modal you can use our [**web component**](../core/components.mdx) or build your own button with the Web3Modal [**composables**](../core/composables.mdx#useweb3modal).

<Tabs>
<TabItem value="components" label="Web Components">

```html
<template>
  <w3m-button />
</template>
```

Learn more about the Web3Modal web components [here](../core/components.mdx)

:::note
Web components are global html elements that don't require importing.
:::

</TabItem>
<TabItem value="composables" label="Composables">

You can trigger the modal by calling the `open` method from `useWeb3Modal` composable.

```html
<script setup lang="ts">
  import { useWeb3Modal } from '@web3modal/solana/vue'
  // 4. Use modal composable
  const modal = useWeb3Modal()
</script>

<template>
  <button @click="modal.open()">Open Connect Modal</button>
  <button @click="modal.open({ view: 'Networks' })">Open Network Modal</button>
</template>
```

Learn more about the Web3Modal composables [here](../core/composables.mdx)

</TabItem>
</Tabs>
</file>

<file path="docs/appkit/vue/transactions/onramp.mdx">
---
title: On-Ramp
---

import Onramp from '../../shared/onramp.mdx'

# On-Ramp

<Onramp />
</file>

<file path="docs/appkit/vue/transactions/swaps.mdx">
import Swaps from '../../shared/swaps.mdx'

# Swaps

<Swaps/>
</file>

<file path="docs/appkit/vue/transactions/transaction-history.mdx">
# Transaction History
</file>

<file path="docs/appkit/vue/wagmi/about/implementation.mdx">
For a quick integration you can use `defaultWagmiConfig` function which wraps Wagmi's [`createConfig`](https://wagmi.sh/core/api/createConfig) function with a predefined configuration.
This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api.mdx) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

:::info
If you're using Nuxt, you can set wagmi's `ssr` option to true and call the `reconnect` function after your application mounts.
:::

In your `App.vue` file set up the following configuration

```html
<script setup>
  import { createWeb3Modal, defaultWagmiConfig } from '@web3modal/wagmi/vue'

  import { mainnet, arbitrum } from 'viem/chains'
  import { reconnect } from '@wagmi/core'

  // 1. Define constants
  const projectId = 'YOUR_PROJECT_ID'

  // 2. Create wagmiConfig
  const metadata = {
    name: 'AppKit',
    description: 'AppKit Example',
    url: 'https://web3modal.com', // origin must match your domain & subdomain
    icons: ['https://avatars.githubusercontent.com/u/37784886']
  }

  const chains = [mainnet, arbitrum]
  const config = defaultWagmiConfig({
    chains,
    projectId,
    metadata,
    ...wagmiOptions // Optional - Override createConfig parameters
  })

  reconnect(config)
  // 3. Create modal
  createWeb3Modal({
    wagmiConfig: config,
    projectId,
    enableAnalytics: true // Optional - defaults to your Cloud configuration  
  })
</script>

<template> // Rest of your app ... </template>
```
</file>

<file path="docs/appkit/vue/wagmi/about/triggermodal.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

To open AppKit you can use our [**web component**](../../core/components.mdx) or build your own button with AppKit [**composables**](../../core/composables.mdx#useweb3modal).
In this example we are going to use the `<w3m-button>` component.

Web components are global html elements that don't require importing.

```html
<template>
  <w3m-button />
</template>
```

Learn more about the AppKit web components [here](../../core/components.mdx)
</file>

<file path="docs/appkit/vue/wagmi/composables.mdx">
import Button from '../../../components/button'

You can use [Wagmi actions](https://wagmi.sh/core/actions/getAccount) to sign messages, interact with smart contracts, and much more.

### getAccount

Action for accessing account data and connection status.

```tsx
import { getAccount } from '@wagmi/core'

const account = getAccount()
```

### signMessage

Action for signing messages with connected account.

```ts
import { signMessage } from '@wagmi/core'

const signature = await signMessage({
  message: 'gm wagmi frens'
})
```

<Button name="Learn More" url="https://wagmi.sh/core/actions/readContract" />
</file>

<file path="docs/appkit/overview.mdx">
---
pagination_next: appkit/features/socials
title: Overview
---

import Container from '../components/Container.js'
import Wrapper from '../components/Home/Wrapper.js'
import Button from '../components/button/index.js'
import W3MQuickStart from '../components/W3MQuickStart.js'

import reactLogo from '../../static/assets/home/reactLogo.png'
import nextjsLogo from '../../static/assets/home/nextjsLogo.png'
import htmlLogo from '../../static/assets/home/htmlLogo.png'
import vueLogo from '../../static/assets/home/vueLogo.png'
import androidLogo from '../../static/assets/home/androidLogo.png'
import iosLogo from '../../static/assets/home/iosLogo.png'
import rnLogo from '../../static/assets/home/rnLogo.png'
import flutterLogo from '../../static/assets/home/flutterLogo.png'
import unityLogo from '../../static/assets/home/unityLogo.png'
import javascriptLogo from '../../static/assets/home/javascriptLogo.png'

# AppKit

With a layered feature stack spanning onboarding to transactions, messaging and more, AppKit enables apps to build powerful top-to-bottom web3 experiences made to last, all through one seamless integration.

{/* <W3MQuickStart /> */}

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'React',
      type: 'react',
      description: 'Get started with AppKit in React.',
      icon: reactLogo,
      href: './react/core/installation'
    },
    {
      name: 'Next.js',
      type: 'next',
      description: 'Get started with AppKit in Next.js.',
      icon: nextjsLogo,
      href: './next/core/installation',
      isWhite: true
    },
    {
      name: 'Vue',
      type: 'vue',
      description: 'Get started with AppKit in Vue.',
      icon: vueLogo,
      href: './vue/core/installation'
    },
    {
      name: 'JavaScript',
      type: 'javascript',
      description: 'Get started with AppKit in JavaScript.',
      icon: javascriptLogo,
      href: './javascript/core/installation'
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with AppKit in React Native.',
      icon: rnLogo,
      href: './react-native/core/installation'
    },
    {
      name: 'Flutter',
      type: 'flutter',
      description: 'Get started with AppKit in Flutter.',
      icon: flutterLogo,
      href: './flutter/core/installation'
    },
    {
      name: 'Android',
      type: 'android',
      description: 'Get started with AppKit in Android.',
      icon: androidLogo,
      href: './android/core/installation'
    },
    {
      name: 'iOS',
      type: 'ios',
      description: 'Get started with AppKit in iOS.',
      icon: iosLogo,
      href: './ios/core/installation',
      isWhite: true
    },
    {
      name: 'Unity',
      type: 'unity',
      description: 'Get started with AppKit in Unity.',
      icon: unityLogo,
      href: './unity/core/installation',
      isWhite: true
    }
  ]}
/>

## Features

![AppKit banner](../../static/img/appkit.png)

Some of the key features of the AppKit SDK include:

- **Support for multiple frameworks.** Easily integrate with React, Vue, Svelte, vanilla JavaScript, and more.
- **[EIP-6963.](https://eips.ethereum.org/EIPS/eip-6963) support** for browser extension wallets.
- **Email Wallets.** Allow users to seamlessly connect to dapps with their email address.
- **On-Ramp.** Enable users to buy crypto with fiat currency.
- **Customizable UI**. Choose between light and dark modes and accent colors, or even infuse it with your own branding.
- **Multi-chain ready.** Easily set up support for any EVM chain.
- **Hundreds of Wallets.** Connect with MetaMask, Rainbow, Coinbase and many more.
- **Transaction History.** View all transactions from the account view.
</file>

<file path="docs/appkit/upgrade.mdx">
---
pagination_next: appkit/react/core/installation
title: Upgrade Guide
---

import PlatformTabs from '../components/PlatformTabs'
import PlatformTabItem from '../components/PlatformTabItem'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Upgrade Guide

## AppKit v2 to AppKit v5 Upgrade Guide

This guide is useful for those that have used a previous AppKit V2 version and are looking to upgrade to AppKit v5.

<img src="/img/appkit.png" />

### Installation

<PlatformTabs
	groupId="w3m"
	activeOptions={["react", "javascript"]}
>
<PlatformTabItem value="react">

To upgrade from AppKit v2 to AppKit v4 start by removing AppKit v2 dependencies `@web3modal/ethereum` and `@web3modal/react`. Now you can install AppKit library and update `Wagmi` and `Viem`.

```bash npm2yarn
npm install @web3modal/wagmi@latest wagmi@2.x viem@2.x @tanstack/react-query@5.x
```

</PlatformTabItem>
<PlatformTabItem value="javascript">

To upgrade from AppKit v2 to AppKit v4 start by removing AppKit v2 dependencies `@web3modal/ethereum` and `@web3modal/react`. Now you can install AppKit library and update `@wagmi/core` and `Viem`.

```bash npm2yarn
npm install @web3modal/wagmi@latest @wagmi/connectors @wagmi/core@2.x viem@2.x
```

</PlatformTabItem>
</PlatformTabs>

### Implementation

<PlatformTabs
	groupId="w3m"
	activeOptions={["react", "javascript"]}
>
<PlatformTabItem value="react">

You can start the AppKit configuration by using either the **default** or **advanced** mode.

Default mode will implement WalletConnect, Browser Wallets (injected) and Coinbase options in addition to Wagmi's public clients and [WalletConnect's provider](../cloud/blockchain-api.mdx).
:::note
Make sure to set your configuration outside React components to avoid unwanted rerenders.
:::

<Tabs>
<TabItem value="default" label="Default">

Start by importing `createWeb3Modal`, `defaultWagmiConfig` and wagmi packages

```tsx
/* highlight-delete-start */
- import { EthereumClient, w3mConnectors, w3mProvider } from '@web3modal/ethereum'
- import { Web3Modal } from '@web3modal/react'
/* highlight-delete-end */
/* highlight-add-start */
+ import { createWeb3Modal } from '@web3modal/wagmi/react'
+ import { defaultWagmiConfig } from '@web3modal/wagmi/react/config'
+ import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
/* highlight-add-end */

import { WagmiConfig } from 'wagmi'
import { arbitrum, mainnet } from 'viem/chains'
```

Then create `wagmiConfig` using `defaultWagmiConfig` function as shown below

```tsx
const chains = [arbitrum, mainnet]
const projectId = 'YOUR_PROJECT_ID'

/* Create Wagmi Config */
/* highlight-delete-start */
- const { publicClient } = configureChains(chains, [w3mProvider({ projectId })])
- const wagmiConfig = createConfig({
-   autoConnect: true,
-   connectors: w3mConnectors({ projectId, chains }),
-   publicClient
- })
/* highlight-delete-end */
/* highlight-add-start */
+ const queryClient = new QueryClient()

+ const metadata = {
+   name: 'AppKit',
+   description: 'AppKit Example',
+   url: 'https://web3modal.com',
+   icons: ['https://avatars.githubusercontent.com/u/37784886']
+ }

+ const wagmiConfig = defaultWagmiConfig({ chains, projectId, metadata })
/* highlight-add-end */

```

Finally, pass `config` to `createWeb3Modal`

```tsx
/* Call createWeb3Modal function */
/* highlight-delete-start */
- const ethereumClient = new EthereumClient(wagmiConfig, chains)
/* highlight-delete-end */
/* highlight-add-start */
+ createWeb3Modal({ wagmiConfig, projectId, chains })
/* highlight-add-end */

export default function App() {
  return (
    <>
      <WagmiConfig config={wagmiConfig}>
/* highlight-add-start */
+       <QueryClientProvider client={queryClient}>
/* highlight-add-end */
          <HomePage />
/* highlight-add-start */
+       </QueryClientProvider>
/* highlight-add-end */
      </WagmiConfig>

      /* highlight-delete-start */
-     <Web3Modal projectId={projectId} ethereumClient={ethereumClient} />
      /* highlight-delete-end */
    </>
  )
}
```

</TabItem>
<TabItem value="custom" label="Advanced">

Start by importing `createWeb3Modal` and wagmi packages

```tsx
/* highlight-delete-start */
- import { EthereumClient, w3mConnectors, w3mProvider } from '@web3modal/ethereum'
- import { Web3Modal } from '@web3modal/react'
/* highlight-delete-end */
/* highlight-add-start */
+ import { createWeb3Modal } from '@web3modal/wagmi/react'
/* highlight-add-end */

import { WagmiConfig, configureChains, createConfig } from 'wagmi'
import { mainnet } from 'viem/chains'
/* highlight-add-start */
+ import { http, createConfig, WagmiProvider } from 'wagmi'
+ import { mainnet, sepolia } from 'wagmi/chains'
+ import { walletConnect, injected, coinbaseWallet } from 'wagmi/connectors'

+ import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
/* highlight-add-end */
```

Then create `wagmiConfig` using your own settings

```tsx
// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create wagmiConfig
/* highlight-delete-start */
- const { chains, publicClient } = configureChains([mainnet], [w3mProvider({ projectId })])

- const wagmiConfig = createConfig({
-   autoConnect: true,
-   connectors: w3mConnectors({ projectId, chains }),
-   publicClient
- })
/* highlight-delete-end */
/* highlight-add-start */
+ const metadata = {
+   name: 'AppKit',
+   description: 'AppKit Example',
+   url: 'https://web3modal.com', // origin must match your domain & subdomain
+   icons: ['https://avatars.githubusercontent.com/u/37784886']
+ }

+ const wagmiConfig = createConfig({
+   chains: [mainnet, sepolia],
+   transports: {
+     [mainnet.id]: http(),
+     [sepolia.id]: http()
+   },
+   connectors: [
+     walletConnect({ projectId, metadata, showQrModal: false }),
+     injected({ shimDisconnect: true }),
+     coinbaseWallet({
+       appName: metadata.name,
+       appLogoUrl: metadata.icons[0]
+     })
+   ]
+ })
/* highlight-add-end */
```

Finally, pass `wagmiConfig` to `createWeb3Modal`

```tsx
/* Call createWeb3Modal function */
/* highlight-delete-start */
- const ethereumClient = new EthereumClient(wagmiConfig, chains)
/* highlight-delete-end */
/* highlight-add-start */
+ createWeb3Modal({
+   wagmiConfig,
+   projectId,
+   enableAnalytics: true // Optional - defaults to your Cloud configuration
+ })
/* highlight-add-end */

export default function App() {
  return (
    <>
      <WagmiConfig config={wagmiConfig}>
/* highlight-add-start */
+       <QueryClientProvider client={queryClient}>
           <HomePage />
+       </QueryClientProvider>
/* highlight-add-end */
      </WagmiConfig>

      /* highlight-delete-start */
-     <Web3Modal projectId={projectId} ethereumClient={ethereumClient} />
      /* highlight-delete-end */
    </>
  )
}
```

</TabItem>
</Tabs>

</PlatformTabItem>
<PlatformTabItem value="javascript">

Start by importing AppKit and wagmi packages, then create wagmi config using your own settings or our default presets as shown below. Finally, pass wagmi config to AppKit as ethereumClient.

<Tabs>
<TabItem value="default" label="Default">

Start by importing `createWeb3Modal`, `defaultWagmiConfig` and wagmi packages

```ts
/* highlight-delete-start */
- import { EthereumClient, w3mConnectors, w3mProvider } from '@web3modal/ethereum'
- import { Web3Modal } from '@web3modal/html'
/* highlight-delete-end */
/* highlight-add-start */
+ import { createWeb3Modal, defaultWagmiConfig } from '@web3modal/wagmi/react'
/* highlight-add-end */


/* highlight-delete-start */
import { configureChains } from '@wagmi/core'
/* highlight-delete-end */
import { createConfig } from '@wagmi/core'
import { arbitrum, mainnet } from 'viem/chains'
```

Then create `wagmiConfig` using `defaultWagmiConfig` function as shown below

```tsx
const chains = [arbitrum, mainnet]
const projectId = 'YOUR_PROJECT_ID'

/* Create Wagmi Config */
/* highlight-delete-start */
- const { publicClient } = configureChains(chains, [w3mProvider({ projectId })])
- const wagmiConfig = createConfig({
-   autoConnect: true,
-   connectors: w3mConnectors({ projectId, chains }),
-   publicClient
- })
/* highlight-delete-end */
/* highlight-add-start */
+ const metadata = {
+   name: 'AppKit',
+   description: 'AppKit Example',
+   url: 'https://web3modal.com',
+   icons: ['https://avatars.githubusercontent.com/u/37784886']
+ }
+ const wagmiConfig = defaultWagmiConfig({ chains, projectId, appName: metadata.name })
/* highlight-add-end */
```

Finally, pass `wagmiConfig` to `createWeb3Modal`

```ts
/* highlight-delete-start */
- const ethereumClient = new EthereumClient(wagmiConfig, chains)
/* highlight-delete-end */
/* highlight-add-start */
+ createWeb3Modal({
+   wagmiConfig,
+   projectId,
+   enableAnalytics: true // Optional - defaults to your Cloud configuration
+ })
/* highlight-add-end */
```

</TabItem>
<TabItem value="custom" label="Advanced">

Start by importing AppKit and wagmi packages

```tsx
/* highlight-delete-start */
- import { EthereumClient, w3mConnectors, w3mProvider } from '@web3modal/ethereum'
- import { Web3Modal } from '@web3modal/react'
/* highlight-delete-end */
/* highlight-add-start */
+ import { Web3Modal, walletConnectProvider } from '@web3modal/wagmi'
/* highlight-add-end */

/* highlight-delete-start */
import { configureChains } from '@wagmi/core'
/* highlight-delete-end */
import { createConfig } from '@wagmi/core'
import { mainnet } from 'viem/chains'
/* highlight-add-start */
import { reconnect, http, createConfig } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'
import { coinbaseWallet, walletConnect, injected } from '@wagmi/connectors'
/* highlight-add-end */
```

Then create `wagmiConfig` using your own settings

```tsx
// 1. Get projectId from https://cloud.walletconnect.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create wagmiConfig
/* highlight-delete-start */
- const { chains, publicClient } = configureChains([mainnet], [w3mProvider({ projectId })])
/* highlight-delete-end */

/* highlight-delete-start */
- const wagmiConfig = createConfig({
-   autoConnect: true,
-   connectors: w3mConnectors({ projectId, chains }),
-   publicClient
- })
/* highlight-delete-end */
/* highlight-add-start */
+ const metadata = {
+   name: 'AppKit',
+   description: 'AppKit Example',
+   url: 'https://web3modal.com',
+   icons: ['https://avatars.githubusercontent.com/u/37784886']
+ }
/* highlight-add-end */

/* highlight-add-start */
+ const wagmiConfig = createConfig({
+   chains: [mainnet, sepolia],
+   transports: {
+     [mainnet.id]: http(),
+     [sepolia.id]: http()
+   },
+   connectors: [
+     walletConnect({ projectId, metadata, showQrModal: false }),
+     injected({ shimDisconnect: true }),
+     coinbaseWallet({
+       appName: metadata.name,
+       appLogoUrl: metadata.icons[0]
+     })
+   ]
+ })
+ reconnect(wagmiConfig)
/* highlight-add-end */
```

Finally, pass `wagmiConfig` to `createWeb3Modal`

```tsx
/* highlight-delete-start */
- const ethereumClient = new EthereumClient(wagmiConfig, chains)
/* highlight-delete-end */
/* highlight-add-start */
+ createWeb3Modal({
+   wagmiConfig,
+   projectId,
+   enableAnalytics: true // Optional - defaults to your Cloud configuration
+ })
/* highlight-add-end */
```

</TabItem>
</Tabs>

</PlatformTabItem>
</PlatformTabs>

### Trigger the modal

<PlatformTabs
	groupId="w3m"
	activeOptions={["react", "javascript"]}
>
<PlatformTabItem value="react">

```tsx
/* highlight-delete-start */
- import { useWeb3Modal } from '@web3modal/react'
/* highlight-delete-end */
/* highlight-add-start */
+ import { useWeb3Modal } from '@web3modal/wagmi/react'
/* highlight-add-end */

function HomePage() {
  const { open } = useWeb3Modal()

  return <button onClick={() => open()}>Connect</button>
}
```

Learn more about AppKit v4 [here](./react/core/installation.mdx)

</PlatformTabItem>
<PlatformTabItem value="javascript">

Use your own button with to open the modal

```js
document.getElementById('my-button').addEventListener('click', () => {
/* highlight-delete-start */
-   web3modal.openModal()
/* highlight-delete-end */
/* highlight-add-start */
+   modal.open()
/* highlight-add-end */
})

<button id="my-button">Connect Wallet</button>
```

Learn more about AppKit v4 JavaScript [here](./javascript/core/installation.mdx)

</PlatformTabItem>
</PlatformTabs>
</file>

<file path="docs/cloud/chains/chain-list.mdx">
import List from '../../components/List.js'

# Supported Chains

## Overview

This page provides a list of chains on the [WalletConnect Explorer](https://explorer.walletconnect.org/). WalletConnect Explorer is a tool that allows users to discover wallets and dapps that support their preferred blockchain.

On this page, you can:

- Filter chains by Mainnet / Testnet
- Search for chains by name
- Click on a chain to copy its Chain ID

<List />
</file>

<file path="docs/cloud/chains/overview.md">
# Chain Onboarding

The WalletConnect protocol is multi-chain by design. By using the [CAIP-25 standard](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md), WalletConnect aims to provide a standardized process for onboarding new chains into our ecosystem. To get started, follow the following steps.

## Register Chain with the Explorer

:::info
**Registering a chain with the Explorer does not impact or improve the ability for wallets and dapps to support your chain.** It is simply a way for users to discover wallets and dapps that support your chain by:

- Browsing the [Chains List](./chain-list.mdx)
- Filtering results programmatically via the [Explorer API](../../cloud/explorer.md)

**It is still up to wallets and dapps to provide concrete support for your chain once it is listed as part of the Explorer.**
:::

If you don't see your chain listed in this [list](./chain-list.mdx), then you will need to create an issue in GitHub to to get the process started.
You can do so by clicking [here](https://github.com/WalletConnect/walletconnect-monorepo/issues/new?assignees=&labels=type%3A+new+chain+request&template=new_chain_to_explorer.md&title=). Once your chain is added to this list, wallets & dapps will be able to indicate support for your chain via WalletConnect's [Cloud](https://cloud.walletconnect.com).

## CASA

To register a chain, you must know both its native representation (the chainID used with that kind of blockchain) _and_ its Chain Agnostic Standards Alliance representation, which can be found reading the relevant CAIP-2 profiles on the [CASA Namespaces Project Docs](https://namespaces.chainagnostic.org/). If no such profile yet exists, you can collaborate with an expert in the respective chain's tooling and submit a [namespaces PR](https://github.com/ChainAgnostic/namespaces/?tab=readme-ov-file#namespaces) to add one.

## Add RPC Methods

Integrate RPC method support into the example wallets and dapp.

**Example Wallet**

- [Demo](https://react-web3wallet.vercel.app/)
- [GitHub](https://github.com/WalletConnect/web-examples/tree/main/advanced/wallets/react-web3wallet)

**Example Dapp**

- [Demo](https://react-app.walletconnect.com/)
- [GitHub](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2)

## Promote

For a chain to benefit users, its prominent wallets and dApps must be registered in the Explorer. Encourage them to join the API, allowing users to view the wallets as options when connecting to a dApp.

## Wagmi & Viem

If the chain you are registering is EVM compliant, we highly recommend you to integrate it with [Viem](https://viem.sh/docs/clients/chains.html), an ethereum library used by Wagmi and AppKit. To accomplish this you will need to open a GitHub Pull Request in the Viem repository.

- [Viem GitHub Repository](https://github.com/wagmi-dev/viem/tree/main/src/chains/definitions)
</file>

<file path="docs/cloud/analytics.mdx">
---
title: Analytics
---

import Table from '../components/Table'

## Accessing WalletConnect Analytics

To access WalletConnect Analytics and explore these insightful features, follow these simple steps:

1. Log In to your Cloud Account [here](https://cloud.walletconnect.com/sign-in).
2. Click on your Project.
3. Click the Analytics Tab.
4. Select the Analytics section of your choice.

By following these steps, you can easily access and leverage WalletConnect Analytics to track your project's progress and make informed decisions to take your project to the next level.

## Understanding WalletConnect Analytics

WalletConnect Cloud now includes Analytics to help you better understand your project's performance. Let's break down some terms and explore the new analytics sections in a simple manner.

## Analytics Sections

:::info Definitions

Refer to [Definitions](#definitions) for the meaning of terms used in WalletConnect Analytics.

:::

### Relay

#### Overview - Wallet/Dapp Sessions

Displays the total count of established connections between your project and WalletConnect SDK.

<img src="/img/analytics/relay/1.png" />

#### Overview - Clients

Indicates the total number of connections established from clients (device or browser if connecting on the web).

<img src="/img/analytics/relay/2.png" />

#### Overview - Messages

Shows the total messages exchanged between the configured WalletConnect SDK and the Relay Server.

<img src="/img/analytics/relay/3.png" />

#### Wallet/Dapp Sessions

Shows the daily trend of established sessions over a 30 day period.

<img src="/img/analytics/relay/4.png" />

#### Clients

Shows the daily trend of client connections over a 30 day period.

<img src="/img/analytics/relay/5.png" />

#### All Messages

Shows the daily trend of messages connections over a 30 day period.

<img src="/img/analytics/relay/6.png" />

#### Projects

Lists the top ranked wallets/Dapps connected to your project.

<img src="/img/analytics/relay/7.png" />

#### Countries and Continents

Provides insights into user connections by displaying the countries and continents with the most connections.

<img src="/img/analytics/relay/8.png" />

Learn more about the Relay [here](./relay.mdx)

### RPC

#### Overview RPC Requests

Represents the total count of remote procedure calls (RPC) made to the blockchain API for the last 30 days.

<img src="/img/analytics/rpc/1.png" />

#### RPC Request Volumes

Displays the daily trend of API requests made to the blockchain API.

<img src="/img/analytics/rpc/2.png" />

#### RPC Chain

Shows the top chain requests made by Chain ID.

<img src="/img/analytics/rpc/3.png" />

#### RPC Method

Highlights the top-ranked methods called by your users.

<img src="/img/analytics/rpc/4.png" />

#### Countries

Illustrates user connections by displaying the countries with the most connections.

<img src="/img/analytics/rpc/5.png" />

Learn more about the Blockchain API [here](./blockchain-api.mdx)

### AppKit

#### Avg. Daily Visitors

Indicates the daily average of unique visitors to your app‚Äôs AppKit.

<img src="/img/analytics/web3modal/1.png" />

#### Avg. Daily Sessions

Indicates the daily average of sessions.

<img src="/img/analytics/web3modal/2.png" />

#### Avg. Daily Connections

Indicates the daily average of connections made through AppKit.

<img src="/img/analytics/web3modal/3.png" />

#### Sessions

Indicates the total count of sessions.

<img src="/img/analytics/web3modal/4.png" />

#### Successful connections

Total count of all connections made between a wallet and your app.

<img src="/img/analytics/web3modal/5.png" />

#### Countries

Ranks the top countries with the highest user connections.

<img src="/img/analytics/web3modal/6.png" />

#### Wallets Breakdown

Ranks the top wallets that your users are connecting from.

<img src="/img/analytics/web3modal/7.png" />

#### All Events

This table and chart shows the count of various events that are triggered as the users interact with AppKit.

<img src="/img/analytics/web3modal/8.png" />

#### Platform Sessions

Provides a breakdown of sessions that have been created by device platform.

<img src="/img/analytics/web3modal/9.png" />

#### Visitors

Shows the daily trend of unique visitors to your app‚Äôs AppKit.

<img src="/img/analytics/web3modal/10.png" />

#### Sessions

Shows the daily trend of sessions created when the user signs a message with their connected wallet.

<img src="/img/analytics/web3modal/11.png" />

#### Successful connections

Shows the daily trend of successful connections to your app.

<img src="/img/analytics/web3modal/12.png" />

### Web3Inbox

#### Subscribers - All Time

Total count of all subscribers to your project.

<img src="/img/analytics/web3inbox/1.png" />

#### Notifications - All Time

Total count of all notifications sent from your project.

<img src="/img/analytics/web3inbox/2.png" />

#### Subscribers

Daily trend chart illustrating the growth of subscribers.

<img src="/img/analytics/web3inbox/3.png" />

#### Notifications

Daily trend chart of total notifications received by your subscribers.

<img src="/img/analytics/web3inbox/4.png" />

#### Messaged Accounts

Daily trend chart of unique wallets that received the notification.

<img src="/img/analytics/web3inbox/5.png" />

#### Subscribers by notification type

This table shows the total count of subscribers by notification type over a 30 day period.

<img src="/img/analytics/web3inbox/6.png" />

### Definitions

Definitions of terms used in WalletConnect Analytics.

<Table
  headers={['Term', 'Description']}
  data={[
    [
      'Relay:Session',
      'A session within the context of Relay analytics denotes meaningful user actions, like signing transactions for NFT sales or trades, within a wallet or dapp. It emphasizes core SDK functionality.'
    ],
    [
      'AppKit:Session',
      'A session within the context of AppKit analytics represents the connection established between your project and your user‚Äôs device (includes browsers). Sessions are created when the user interacts with AppKit on your app. If user events are tracked within 30min range they will be considered within the same session.'
    ],
    [
      'Message',
      'Messages are data exchanges between the WalletConnect SDK and the Relay Server, facilitating communication between your project and connected clients.'
    ],
    ['Client', 'A client is a device or browser connected to your project.'],
    [
      'Blockchain API',
      'The interface that allows your project to interact with the blockchain. Remote Procedure Calls (RPC) are used to request information or execute operations on the blockchain through this API.'
    ],
    [
      'Chain ID',
      'Chain ID identifies a specific blockchain network. Different blockchain networks, such as Ethereum Mainnet or a testnet, have unique Chain IDs.'
    ]
  ]}
/>
</file>

<file path="docs/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

The Blockchain API is the RPC service that powers AppKit's blockchain functions such as account balances, ENS resolution, transaction history, and more.

:::info
Blockchain API is not the same as the WalletConnect protocol. WalletConnect protocol supports wallets on all chains using the [CAIP-25](https://chainagnostic.org/CAIPs/caip-25) standard. We do not accept requests for new chains to be added to our Blockchain API. Please see your SDK's relevant documentation on how to add RPC URLs for chains you want to use that Blockchain API does not.
:::

## Features

- AppKit built-in integration
- Multi-chain mainnet and testnets
- HTTP RPC support
- Cloud metrics and reporting
- The Identity API with near-instant ENS resolution
- Transaction history

## Supported Chains

The Blockchain API supports popular chains such as Ethereum, Binance Smart Chain, Solana, and more. See the full list of [supported chains](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md).

## Using the Blockchain API

No config or setup is needed for AppKit integrations. For other usage, see the [Usage](https://github.com/walletconnect/blockchain-api#usage) section.

## Limits

The Blockchain API is free for 6 million requests per 30 days.

## Links

- [Supported chains](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md)
- [The Blockchain API GitHub repo](https://github.com/WalletConnect/blockchain-api)
</file>

<file path="docs/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import useBaseUrl from '@docusaurus/useBaseUrl'
import Table from '../components/Table'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

import PlatformTabs from '../components/PlatformTabs'
import PlatformTabItem from '../components/PlatformTabItem'

:::info Note

Submitting a project to the WalletConnect Cloud Explorer is recommended but optional. You can still use WalletConnect services without submitting your project.
However, doing so ensures that your project is listed under [WalletConnect Explorer](https://walletconnect.com/explorer?utm_source=walletconnect-docs&utm_medium=cloud&utm_campaign=explorer-submission) and [Cloud Explorer API](./explorer.md).

:::

## Creating a New Project

- Head over to [cloud.walletconnect.com](https://cloud.walletconnect.com/) and create a new project by clicking the "New Project" button in top right corner of the dashboard.
- Give a suitable name to your project, select whether its an App or Wallet and click the "Create" button. (You can change this later)
  <img className="image-margin" src={useBaseUrl('/img/cloud/1.png')} />

## Project Details

- Go to the "Explorer" tab and fill in the details of your project.
  <img className="image-margin" src={useBaseUrl('/img/cloud/2.png')} />

<Table
  headers={['Field', 'Description', 'Required']}
  data={[
    {
      field: 'Name',
      description: 'The name to display in the explorer',
      required: 'yes'
    },
    {
      field: 'Description',
      description: 'A short description explaining your project (dapp/wallet)',
      required: 'yes'
    },
    {
      field: 'Type',
      description: 'Whether your project is a dapp or a wallet',
      required: 'yes'
    },
    {
      field: 'Category',
      description:
        'Appropriate category for your project. This field is dependent on the type of your project',
      required: 'yes'
    },
    {
      field: 'Homepage',
      description: 'The URL of your project',
      required: 'yes'
    },
    {
      field: 'Web App',
      description: 'The URL of your web app. This field is only applicable for dapps',
      required: 'yes'
    },
    {
      field: 'Supports Sign v2',
      description:
        'Indicates v2 support for WalletConnect Sign SDK. Detailed testing instructions are provided in the explorer submission form',
      required: 'yes'
    },
    {
      field: 'Supports Auth v1',
      description:
        'Indicates v1 support for WalletConnect Auth SDK. Detailed testing instructions are provided in the explorer submission form',
      required: 'yes'
    },
    {
      field: 'Chains',
      description: 'Chains supported by your project',
      required: 'yes'
    },
    {
      field: 'Logo',
      description:
        'The logo of your project. Further requirements are provided in the explorer submission form',
      required: 'yes'
    },
    {
      field: 'Testing Instructions',
      description: 'Instructions on how to test your WalletConnect Integration',
      required: 'yes'
    },
    {
      field: 'Download Links',
      description: 'Links to download your project (if applicable)',
      required: 'no'
    },
    {
      field: 'Mobile Linking',
      description:
        'Required for mobile wallets targeting AppKit. Deep Link is recommended over Universal Link',
      required: 'no'
    },
    {
      field: 'Desktop Linking',
      description: 'Required for desktop wallets targeting AppKit.',
      required: 'no'
    },
    {
      field: 'Injected Wallet Identifiers',
      description:
        'Required for injected wallets targeting AppKit. RDNS (from EIP-6963 metadata) is recommended over Provider Flags(Legacy)',
      required: 'no'
    },
    {
      field: 'Metadata',
      description: 'User facing UI metadata for your project. Only Short Name is required.',
      required: 'no'
    }
  ]}
/>

## Project Submission

- Once you've filled the applicable fields, click the "Submit" button to submit your project for review. Alternatively, you can save your changes and submit later. Additional information will be visible in the modal that appears after clicking the "Submit" button.
  <img className="image-margin" src={useBaseUrl('/img/cloud/3.png')} />

## How do we test wallets?

In order to offer a great user experience in our APIs and SDKs every Cloud submission goes through a QA process to make sure that the integration of the WalletConnect protocol is working correctly.

The following list details our QA flow and how to reproduce it:

<Table
  headers={['Test Case', 'Steps', 'Expected Results']}
  data={[
    {
      testCase: 'Set Up',
      steps: `1. Download the wallet
              2. Install the wallet app
              3. Sign up for an account with the wallet app
              4. Create one or more accounts`,
      expectedResults: `1. N/A
                        2. The app is installed
                        3. I have an account
                        4. I have one or more accounts`
    },
    {
      testCase: 'Connect to dapp via web browser',
      steps: `1. Open the WalletConnect connection page https://lab.web3modal.com/ or https://react-app.walletconnect.com/ from a PC
              2. Press on the ‚ÄúConnect Wallet‚Äù button and select the ‚ÄúWalletConnect‚Äù option.
              3. Open the wallet app and use the scan QR option to connect.
              4. Accept on the wallet the connection request`,
      expectedResults: `1. The app has been correctly set-up
                        2. A modal with wallet options is opened
                        3. A QR code is shown on the website and the wallet is able to scan it.
                        4. The connection is successfully established. The wallet data is now shown in the website.`
    },
    {
      testCase: 'Connect to dapp via mobile browser (Deep-link)',
      steps: `1. Open https://lab.web3modal.com/ in your mobile device.
              2. Select one of the default options (e.g. Wagmi for EVM chains). Press the "Custom Wallet" button from the navbar. Fill in the wallet‚Äôs name and it‚Äôs deeplink (Mobile Link) in the ‚ÄúAdd a Custom Wallet‚Äù form. Press ‚ÄúAdd Wallet‚Äù. After the website reloads press the ‚ÄúConnect Wallet‚Äù button and select the new created wallet.
              3. Accept the connection request in the wallet application.`,
      expectedResults: `1. N/A
                        2. A form should show up in the website to fill in the wallet‚Äôs data. After the changes are applied the modal should show the new created wallet on the main view.
                        3. The user should be redirected to the wallet application and a modal with a connection request should show up on the wallet application. The wallet should connect successfully. On an Android devices the user should be redirected back to the website after accepting the connection request.`
    },
    {
      testCase: 'Switch chains - dapp side',
      steps: `1. Once the wallet is connected press on the modal button on the top right of the website.
              2. Press the first button of the modal to switch the chain.
              3. Select any available chain, close the modal and press the ‚ÄúSend Transaction‚Äù button`,
      expectedResults: `1. A modal with the account information should pop up on the website.
                        2. A new view with supported chains should show up.
                        3. The transaction request that pops up on the wallet should show in their information the correct chain that we previously selected.`
    },
    {
      testCase: 'Switch Chains - wallet side (if supported)',
      steps: `1. Check if the wallet supports chain switching. If so select a different chain to the connected one.`,
      expectedResults: `1. The chain change should be reflected on the website. The first card shows the current chain ID.`
    },
    {
      testCase: 'Accounts Switching - wallet side',
      steps: `1. In the wallet app switch from one account to the other.`,
      expectedResults: `1. The account switch event should be reflected in the modal‚Äôs account view on the website.`
    },
    {
      testCase: ' Disconnect a wallet',
      steps: `1. Select "Disconnect" button from the Wallet App (Ideally wallets should have a section where users could see all their existing dApp connections, and give the user the ability to manage connections / disconnect from dapps in one spot - this is not always true so if this is not possible just skip this)
              2. Repeat above steps and press "Disconnect" button from the dApp (this should be always available)`,
      expectedResults: `1. The related session should disappear from dApp and from the Wallet App
                        2. The related session should disappear from dApp and from the Wallet App`
    },
    {
      testCase: 'Verify API',
      steps: `1. Open https://malicious-app-verify-simulation.vercel.app/
              2. Select a supported chain by the wallet (some wallets don‚Äôt support testnets) and press the ‚ÄúConnect‚Äù button.
              3. Scan with the wallet the generated QR code.`,
      expectedResults: `1. N/A
                        2. A modal should show up with a QR code to scan.
                        3. The connection request in the wallet should flag the website as malicious. `
    }
  ]}
/>

### Chain Specific

The following test cases only apply for wallets supporting a particular set of chains.

<PlatformTabs groupId="chains" activeOptions={["evm", "solana"]}>
<PlatformTabItem value="evm">

<Table
  headers={['Test Case', 'Steps', 'Expected Results']}
  data={[
    {
      testCase: 'Supporting personal_sign',
      steps: `1. Connect the wallet.
              2. Press the ‚ÄúSign Message‚Äù button.
              3. Accept the signature request on the wallet.`,
      expectedResults: `1. N/A
                        2. A modal should popup on the wallet app requesting for a signature.
                        3. Once accepted and signed the hash should show up on the website.`
    },
    {
      testCase: 'Supporting eth_signTypedData_v4',
      steps: `1. Connect the wallet.
              2. Press the ‚ÄúSign Typed Data‚Äù button.
              3. Accept the signature request on the wallet.`,
      expectedResults: `1. N/A
                        2. A modal should popup on the wallet app requesting for a signature.
                        3. Once accepted and signed the hash should show up on the website.`
    },
    {
      testCase: 'Supporting eth_sendTransaction',
      steps: `1. Connect the wallet.
              2. Press the ‚ÄúSend Transaction‚Äù button.`,
      expectedResults: `1. N/A
                        2. A modal should popup on the wallet app requesting for a signature.`
    }
  ]}
/>

</PlatformTabItem>

<PlatformTabItem value="solana">

<Table
  headers={['Test Case', 'Steps', 'Expected Results']}
  data={[
    {
      testCase: 'Supporting solana_signMessage',
      steps: `1. Connect the wallet to https://lab.web3modal.com/library/solana
              2. Press the ‚ÄúSign Message‚Äù button.
              3. Accept the signature request on the wallet.`,
      expectedResults: `1. N/A
                        2. A modal should popup on the wallet app requesting for a signature.
                        3. Once accepted and signed the hash should show up on the website.`
    },
    {
      testCase: 'Supporting solana_signTransaction',
      steps: `1. Connect the wallet to https://lab.web3modal.com/library/solana
              2. Press the ‚ÄúSign Transaction‚Äù.
              3. Accept the signature request on the wallet.`,
      expectedResults: `1. N/A
                        2. A modal should popup on the wallet app requesting for a signature.
                        3. Once accepted and signed the hash should show up on the website.`
    },
    {
      testCase: 'Supporting v0 Transactions',
      steps: `1. Connect the wallet to https://lab.web3modal.com/library/solana
              2. Press the ‚ÄúSign Versioned Transaction" button.
              3. Accept the signature request on the wallet.`,
      expectedResults: `1. N/A
                        2. A modal should popup on the wallet app requesting for a signature.
                        3. Once accepted and signed the hash should show up on the website.`
    }
  ]}
/>

</PlatformTabItem>
</PlatformTabs>

## What's Next?

Now depending on whether or not your submission met all parameters, you will receive an email from the WalletConnect team with the status of your submission. This change will also be reflected with more directions in the "Explorer" tab of your project.
If your submission was not accepted, you can make the necessary changes and resubmit your project for review. The reason for rejection will be mentioned in the email and in the "Explorer" tab of your project.

In case of any questions, feel free to ask on [Github Discussions](https://github.com/orgs/WalletConnect/discussions/categories/explorer-support)
</file>

<file path="docs/cloud/explorer.md">
---
title: Explorer API
---

The Cloud Explorer API currently offers the following functionality:

- [Listings](#listings) - Allows for fetching of wallets and dApps listed in the [WalletConnect Cloud Explorer](https://walletconnect.com/explorer).
- [Logos](#logos) - Provides logo assets in different sizes for a given Cloud explorer entry.

### Listings

By default listings endpoints return all data for provided type. You can use following query params to return paginated data or search for a specific listing by its name:

| Param       | Required? | Description                                                                                                              |
| ----------- | --------- | ------------------------------------------------------------------------------------------------------------------------ |
| projectId   | Required  | Your WalletConnect Cloud Project ID (from [cloud.walletconnect.com](https://cloud.walletconnect.com/))                   |
| entries     |           | Specifies how many entries will be returned (must be used together with page param)                                      |
| page        |           | Specifies current page (must be used with entries param)                                                                 |
| search      |           | Returns listings whose name matches provided search query                                                                |
| ids         |           | Returns listings whose id matches provided ids (e.g. `&ids=LISTING_ID1,LISTING_ID2`)                                     |
| chains      |           | Returns listings that support at least one of the provided chains<br/>(e.g. `?chains=eip155:1,eip155:137`)               |
| platforms   |           | Returns listings that support at least one of the provided platforms<br/>(e.g. `?platforms=ios,android,mac,injected`)    |
| sdks        |           | Returns listings that support at least one of the provided WalletConnect SDKs<br/>(e.g. `?sdks=sign_v1,sign_v2,auth_v1`) |
| standards   |           | Returns listings that support at least one of the provided standards<br/>(e.g. `?standards=eip-712,eip-3085`)            |
| ~~version~~ |           | Deprecated - replaced by `sdks` param. Specifies supported Sign version (1 or 2)                                         |

#### `GET /v3/wallets`

Returns a JSON object containing all wallets listed in the cloud explorer.

Examples:

- `GET https://explorer-api.walletconnect.com/v3/wallets?projectId=YOUR_PROJECT_ID&entries=5&page=1` (will return the first 5 wallets from the first page)
- `GET https://explorer-api.walletconnect.com/v3/wallets?projectId=YOUR_PROJECT_ID&platforms=injected` (will only return injected wallets)

#### `GET /v3/dapps`

Returns a JSON object containing all dApps listed in the public cloud explorer.

Examples:

- `GET https://explorer-api.walletconnect.com/v3/dapps?projectId=YOUR_PROJECT_ID&entries=5&page=1`

#### `GET /v3/hybrid`

Returns a JSON object containing all hybrids listed in the public cloud explorer.

Examples:

- `GET https://explorer-api.walletconnect.com/v3/hybrid?projectId=YOUR_PROJECT_ID&entries=5&page=1`

#### `GET /v3/all`

Returns a JSON object containing all entries listed in the public cloud explorer.

Examples:

- `GET https://explorer-api.walletconnect.com/v3/all?projectId=YOUR_PROJECT_ID&entries=5&page=1`

#### `GET /v3/all?projectId=YOUR_PROJECT_ID&ids=LISTING_ID1,LISTING_ID2`

Returns a JSON object containing the entry listings by ID, which can be useful for allowlisting purposes. <br/>
You can find and copy listing ids from our [Explorer](https://walletconnect.com/explorer)

Examples:

- `GET https://explorer-api.walletconnect.com/v3/all?projectId=YOUR_PROJECT_ID&ids=be49f0a78d6ea1beed3804c3a6b62ea71f568d58d9df8097f3d61c7c9baf273d,4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0`

### Chains

By default chains endpoint returns all chains registered under [CASA Namespace](https://github.com/ChainAgnostic/CASA) and that were approved by following our [Add Chain issue template](https://github.com/WalletConnect/walletconnect-monorepo/issues/new?assignees=&labels=type%3A+new+chain+request&template=new_chain_to_explorer.md&title=)

#### Query Parameters

You can use following query params to query chains by its namespace and exclude testnets:

| Param      | Description                                                                                                                  |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------- |
| testnets   | Determines if testnets should be included in the response <br/> (e.g. `?testnets=false`, defaults to `true` if not provided) |
| namespaces | Returns chains that belong to one of the provided namespaces<br/>(e.g. `?namespaces=eip155,cosmos,solana`)                   |

#### `GET /v3/chains`

Returns all chains registered under [CASA Namespace](https://github.com/ChainAgnostic/CASA) and that were approved by following our [Add Chain issue template](https://github.com/WalletConnect/walletconnect-monorepo/issues/new?assignees=&labels=type%3A+new+chain+request&template=new_chain_to_explorer.md&title=)

Examples:

- `GET https://explorer-api.walletconnect.com/v3/chains?projectId=YOUR_PROJECT_ID`
- `GET https://explorer-api.walletconnect.com/v3/chains?projectId=YOUR_PROJECT_ID&testnets=false`
- `GET https://explorer-api.walletconnect.com/v3/chains?projectId=YOUR_PROJECT_ID&namespaces=eip155,cosmos`

### Logos

#### Path Parameters

| Param | Description                                                                              |
| ----- | ---------------------------------------------------------------------------------------- |
| size  | Determines resolution of returned image can be one of: `sm`, `md` or `lg`                |
| id    | Corresponds to a Cloud Explorer entry's `image_id` field as returned by the Listings API |

#### Query Parameters

| Param     | Required? | Description                                                                                            |
| --------- | --------- | ------------------------------------------------------------------------------------------------------ |
| projectId | Required  | Your WalletConnect Cloud Project ID (from [cloud.walletconnect.com](https://cloud.walletconnect.com/)) |

#### `GET /v3/logo/:size/:image_id`

Returns the image source of the logo for `image_id` sized according `size`.

Examples:

- `GET https://explorer-api.walletconnect.com/v3/logo/md/32a77b79-ffe8-42c3-61a7-3e02e019ca00?projectId=YOUR_PROJECT_ID`
</file>

<file path="docs/cloud/relay.mdx">
---
title: Relay
---

## Project ID

The Project ID is consumed through URL parameters.

URL parameters used:

- `projectId`: Your Project ID can be obtained from [walletconnect.com](https://walletconnect.com)

Example URL:

`https://relay.walletconnect.com/?projectId=c4f79cc821944d9680842e34466bfbd`

This can be instantiated from the client with the `projectId` in the `SignClient` constructor.

```javascript
import SignClient from '@walletconnect/sign-client'
const signClient = await SignClient.init({
  projectId: 'c4f79cc821944d9680842e34466bfb'
})
```

## Allowlist

To help prevent malicious use of your project ID you are strongly encouraged to set an allowlist of [origins](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) or application/bundle ids for mobile applications where the project ID is used. Requests from other origins will be denied.

- Allowlist supports a list of origins in the format `[scheme://]<hostname[:port]`.
- [Application ID](https://developer.android.com/build/configure-app-module#set-application-id)/[Bundle IDs](https://developer.apple.com/documentation/appstoreconnectapi/bundle_ids) typically are defined using the [reverse domain name notation](https://en.wikipedia.org/wiki/Reverse_domain_name_notation)

Using `localhost` (or `127.0.0.1`) is always permitted, and if empty all origins are allowed. Updates take 15 minutes to apply.

If scheme or port is specified, it must match exactly. Hostname must also match exactly, but wildcards can be used for individual labels within the hostname.

Example of possible origins in the allowlist:

- `example.com` - allows `https://example.com` or `http://example.com` but not `https://www.example.com`
- `https://example.com` - allows `https://example.com` but not `http://example.com`
- `https://www.example.com` - allows `https://www.example.com` but not `https://example.com`
- `https://example.com:8080` - allows `https://example.com:8080` but not `https://example.com`
- `https://*.example.com` - allows `https://www.example.com` but not `https://example.com`
- `https://*.*.example.com` - allows `https://www.subdomain.example.com` but not `https://www.example.com` or `https://example.com`
- `https://www.*.example.com` - allows `https://www.subdomain.example.com` but not `https://www.example.com`
- `https://www-*.example.com` - invalid; `*` must be the full label

## Error Codes

| Reason                                     | Error Code |
| ------------------------------------------ | ---------- |
| Project ID doesn't exist OR JWT is expired | 401        |
| Exists and is invalid                      | 403        |
| Too many requests                          | 1013       |

## Websocket Close Codes

| Code | Description                                                                  | Reconnect   |
| ---- | ---------------------------------------------------------------------------- | ----------- |
| 1001 | Server terminating                                                           | Yes         |
| 4008 | Client stale: connected without a prior subscription and is not sending data | When needed |
| 4010 | Load Rebalancing                                                             | Yes         |

## Best Practices

- Create a new `projectId` for each project. This allows for more granular control, dedicated explorer listings, and project metrics.
- Don't reuse a `projectId`.
- Use the AllowList to limit unauthorized usage.
- Avoid committing projects keys to the repo. Use env variables instead.
</file>

<file path="docs/cloud/verify.mdx">
---
title: Verify
---

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.

Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).

## Cloud Verification

In order to verify your app domain in WalletConnect Cloud follow these steps:

1. Head over to [cloud.walletconnect.com](https://cloud.walletconnect.com)

2. Create a new project or click on the project you would like to verify.

3. On the settings tab, head over to the 'Domain verification' section and fill in the website URL that you wish to verify.

<!-- ![create-push-url](/assets/verify/tab.png) -->

<p align="center">
  <img src="/assets/verify/verify-domain.png" />
</p>

4. Click on the copy button and head over to your domain Name Registrar/Provider to edit your DNS records.
   Alternatively, if you can't manage DNS records for your project (eg: ENS or vercel.app) you can host a static file
   under `/.well-known/walletconnect.txt` which contains the entire verification code that you copied. If you are using the static file method, you can jump over step 7.

5. Under `Type`, select `TXT`. In the ‚ÄúAnswer‚Äù section, paste the text you copied from the cloud dashboard. This field may vary across DNS dashboards. If you‚Äôre trying to register a subdomain, add it under `Host`. Feel free to leave TTL at its default value.

<!-- ![create-push-url](/assets/verify/dns-record.png) -->

<p align="center">
  <img src="/assets/verify/dns-record.png" />
</p>

6. Depending on your DNS settings, this might take a while to reflect. You can check out DNS settings for your website with CLI tools like Dig or with websites like [MXToolbox](https://mxtoolbox.com/SuperTool.aspx?action=txt)

7. Once this is done and you have confirmed this change is reflected, head on back to your Cloud Dashboard and click on Verify.

<p align="center">
  <img src="/assets/verify/verify-btn.png" />
</p>

8. You should see a toast pop up in the bottom right section of your screen and the domain verification section should have a green tick next to it.

<p align="center">
  <img src="/assets/verify/verified.png" />
</p>
</file>

<file path="docs/components/button/index.js">
import React from 'react'
import s from './styles.module.css'
import Link from '@docusaurus/Link'

const Button = ({ name, url }) => {
  return (
    <div className={s.container}>
      <Link to={url}>
        {name}
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={2}
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75"
          />
        </svg>
      </Link>
    </div>
  )
}

export default Button
</file>

<file path="docs/components/button/styles.module.css">
.container {
  height: 40px;
  width: fit-content;
  border: 1px solid var(--ifm-border-color);
  border-radius: 14px;
  background: linear-gradient(135deg, var(--ifm-box-bg-color) 0, transparent 100%);
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.container:hover {
  border-color: var(--ifm-color-primary);
}

.container a {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.3rem;
  padding: 1rem;
  border-bottom: none;
}

.container a svg {
  width: 1.25rem;
  height: 1.25rem;
  transition: transform 0.2s ease-in-out;
}
.container a:hover > svg {
  transform: translateX(0.25rem);
}
</file>

<file path="docs/components/GettingStarted/Card.js">
import React from 'react'
import Link from '@docusaurus/Link'
import useBaseUrl from '@docusaurus/useBaseUrl'

const typeToImageMap = {
  react: 'assets/home/reactLogo.png',
  nextjs: 'assets/home/nextjsLogo.png',
  vue: 'assets/home/vueLogo.png',
  javascript: 'assets/home/javascriptLogo.png',
  ios: 'assets/home/iosLogo.png',
  android: 'assets/home/androidLogo.png',
  rn: 'assets/home/rnLogo.png',
  web: 'assets/home/webLogo.png',
  flutter: 'assets/home/flutterLogo2.png',
  csharp: 'assets/home/csharpLogo.png'
}

const productToLinkMap = {
  w3m: './appkit/overview',
  w3w: './walletkit/overview',
}

export const Card = ({ title, description, links, product, children, image }) => {
  return (
    <div className={`gs__wrapper gs__wrapper--${product}`}>
      <div className="gs__text-container">
        <h2>{title}</h2>
        <p>{description}</p>
      </div>
      <div className="gs__text">{children}</div>
      <div className="gs__platform__wrapper">
        {links.map(({ type, url }) => (
          <Link key={type} className="gs__platform" to={url}>
            <img
              className="gs__platform--image"
              src={useBaseUrl(typeToImageMap[type])}
              alt={`${type} logo`}
            />
          </Link>
        ))}
        {product && (
          <Link className="gs__platform gs__platform--lm" to={productToLinkMap[product]}>
            Learn More
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth={2}
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75"
              />
            </svg>
          </Link>
        )}
      </div>
      <img className="gs__image" src={useBaseUrl(image)} alt="cloud illustration" />
    </div>
  )
}

export default Card
</file>

<file path="docs/components/Home/Banner.js">
import React from 'react'
import logo from '../../../static/assets/wc-logo-glass-big.webp'
import styles from '../../../src/css/banner.module.css'
import Link from '@docusaurus/Link'

const Banner = () => {
  return (
    <div className={styles.banner__container}>
      <div className={styles.banner__text}>
        <h2>WalletConnect Docs</h2>
        <p>
        WalletConnect gives developers the tools to build user experiences that make digital ownership effortless, intuitive, and secure.
        </p>
        {/* <Link to="/getting-started">
          Get Started
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth={2}
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75"
            />
          </svg>
        </Link> */}
      </div>
      <div className={styles.banner__backdrop} />
      <img className={styles.banner__image} src={logo} alt="WalletConnect Logo" />
    </div>
  )
}

export default Banner
</file>

<file path="docs/components/Home/LargeContainer.js">
import Link from '@docusaurus/Link'
import React from 'react'

const LargeContainer = ({ href, name, icon, description, fit, isWhite }) => {

  return (
    <Link to={href} className="home__large-container">
      {fit ? (
        <img src={icon} alt={name} />
      ) : (
        <div className="home__large-container--nofit">
          <img src={icon} alt={name} className={isWhite ? `white` : undefined} />
          <img className={`blur ${isWhite ? `white` : undefined}`} src={icon} alt={name} />
        </div>
      )}

      <div className="home__large-container--text">
        <h4>{name}</h4>
        <p>{description}</p>
      </div>
    </Link>
  )
}

export default LargeContainer
</file>

<file path="docs/components/Home/SmallContainer.js">
import Link from '@docusaurus/Link'
import React from 'react'

const SmallContainer = ({ href, name, icon, isWhite }) => {
  return (
    <Link to={href} className="home__small-container">
      <span>{name}</span>
      <img src={icon} alt={name} className={isWhite ? `white` : undefined} />
    </Link>
  )
}

export default SmallContainer
</file>

<file path="docs/components/Home/Wrapper.js">
import React from 'react'
import SmallContainer from './SmallContainer'
import LargeContainer from './LargeContainer'

const Wrapper = ({ items, type, fit = true, ...props }) => {
  return (
    <div
      {...props}
      className="home__wrapper"
      style={{
        paddingTop: !fit ? '1rem' : 'inherit',
        ...props.style
      }}
    >
      {type === 'small'
        ? items.map((item, index) => (
            <SmallContainer
              key={index}
              href={item.href}
              type={item.type}
              name={item.name}
              icon={item.icon}
              isWhite={item.isWhite || false}
            />
          ))
        : items.map((item, index) => (
            <LargeContainer
              key={index}
              href={item.href}
              type={item.type}
              name={item.name}
              icon={item.icon}
              fit={fit}
              isWhite={item.isWhite || false}
              description={item.description}
            />
          ))}
    </div>
  )
}

export default Wrapper
</file>

<file path="docs/components/Tabs/index.js">
import React, { cloneElement } from 'react'
import clsx from 'clsx'
import { useScrollPositionBlocker, useTabs } from '@docusaurus/theme-common/internal'
import useIsBrowser from '@docusaurus/useIsBrowser'
import styles from './styles.module.css'
function TabList({ className, block, selectedValue, selectValue, tabValues }) {
  const tabRefs = []
  const { blockElementScrollPositionUntilNextRender } = useScrollPositionBlocker()
  const handleTabChange = event => {
    const newTab = event.currentTarget
    const newTabIndex = tabRefs.indexOf(newTab)
    const newTabValue = tabValues[newTabIndex].value
    if (newTabValue !== selectedValue) {
      blockElementScrollPositionUntilNextRender(newTab)
      selectValue(newTabValue)
    }
  }
  const handleKeydown = event => {
    let focusElement = null
    switch (event.key) {
      case 'Enter': {
        handleTabChange(event)
        break
      }
      case 'ArrowRight': {
        const nextTab = tabRefs.indexOf(event.currentTarget) + 1
        focusElement = tabRefs[nextTab] ?? tabRefs[0]
        break
      }
      case 'ArrowLeft': {
        const prevTab = tabRefs.indexOf(event.currentTarget) - 1
        focusElement = tabRefs[prevTab] ?? tabRefs[tabRefs.length - 1]
        break
      }
      default:
        break
    }
    focusElement?.focus()
  }
  return (
    <ul
      role="tablist"
      aria-orientation="horizontal"
      className={clsx(
        'tabs',
        {
          'tabs--block': block
        },
        className
      )}
    >
      {tabValues.map(({ value, label, attributes }) => (
        <li
          // TODO extract TabListItem
          role="tab"
          tabIndex={selectedValue === value ? 0 : -1}
          aria-selected={selectedValue === value}
          key={value}
          ref={tabControl => tabRefs.push(tabControl)}
          onKeyDown={handleKeydown}
          onClick={handleTabChange}
          {...attributes}
          className={clsx('tabs__item', styles.tabItem, attributes?.className, {
            'tabs__item--active': selectedValue === value
          })}
        >
          {label ?? value}
        </li>
      ))}
    </ul>
  )
}
function TabContent({ lazy, children, selectedValue }) {
  const childTabs = (Array.isArray(children) ? children : [children]).filter(Boolean)
  if (lazy) {
    const selectedTabItem = childTabs.find(tabItem => tabItem.props.value === selectedValue)
    if (!selectedTabItem) {
      // fail-safe or fail-fast? not sure what's best here
      return null
    }
    return cloneElement(selectedTabItem, { className: 'platform-tabs--container' })
  }
  return (
    <div className="platform-tabs--container">
      {childTabs.map((tabItem, i) =>
        cloneElement(tabItem, {
          key: i,
          hidden: tabItem.props.value !== selectedValue
        })
      )}
    </div>
  )
}
function TabsComponent(props) {
  const tabs = useTabs(props)
  return (
    <div className={clsx('tabs-container', styles.tabList)}>
      <TabList {...props} {...tabs} />
      <TabContent {...props} {...tabs} />
    </div>
  )
}
export default function Tabs(props) {
  const isBrowser = useIsBrowser()
  return (
    <TabsComponent
      // Remount tabs after hydration
      // Temporary fix for https://github.com/facebook/docusaurus/issues/5653
      key={String(isBrowser)}
      {...props}
    />
  )
}
</file>

<file path="docs/components/Tabs/styles.module.css">
.tabList {
  margin-bottom: var(--ifm-leading);
}

.tabItem {
  margin-top: 0 !important;
}
</file>

<file path="docs/components/Box.js">
import Link from '@docusaurus/Link'
import React from 'react'
import { useHistory } from 'react-router-dom'

const Box = ({ name, description, url }) => {
  let history = useHistory()

  const handleClick = e => {
    e.preventDefault()
    if (url.includes('https://')) {
      window.open(url, '_blank')
    } else {
      history.push(url)
    }
  }

  return (
    <div className="box">
      <Link to={url} onClick={handleClick}>
        <h1 style={{ fontSize: '20px' }}>{name}</h1>
        <p>{description}</p>
      </Link>
    </div>
  )
}

export default Box
</file>

<file path="docs/components/ChainCard.js">
import React, { useState } from 'react'

const ChainCard = ({ chainName, namespace }) => {
  const [copied, setCopied] = useState(false)
  const handleCopy = () => {
    navigator.clipboard.writeText(namespace)
    setCopied(true)
    setTimeout(() => {
      setCopied(false)
    }, 3000)
    console.log(chainName, namespace)
  }
  return (
    <button className="card__small-container" onClick={handleCopy}>
      {copied ? <span>Chain ID copied!</span> : <span>{chainName}</span>}
    </button>
  )
}

export default ChainCard
</file>

<file path="docs/components/CloudBanner.js">
import React from 'react'
import wcGlassImage from '../../static/assets/wc-logo-glass.png'
import Link from '@docusaurus/Link'

export const CloudBanner = props => {
  const handleAnalytics = () => {
    const props = {
      path: window.location.pathname
    }
    plausible('cloud-banner-click', {
      props
    })
  }
  return (
    <div className="cloud__wrapper">
      <div className="cloud__text-container">
        <h2>Don't have a project ID?</h2>
        <p>Head over to WalletConnect Cloud and create a new project now!</p>
      </div>
      <Link to="https://cloud.walletconnect.com" target="_blank" onClick={handleAnalytics}>
        Get started
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          height={20}
          width={20}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M17.25 8.25L21 12m0 0l-3.75 3.75M21 12H3"
          />
        </svg>
      </Link>
      <img className="cloud__image" src={wcGlassImage} alt="cloud illustration" />
    </div>
  )
}

export default CloudBanner
</file>

<file path="docs/components/Container.js">
import React from 'react'
import Box from './Box'

export const Container = props => {
  return (
    <div className="boxContainer">
      {props.items.map((product, i) => (
        <Box name={product.name} description={product.description} url={product.url} key={i} />
      ))}
    </div>
  )
}

export default Container
</file>

<file path="docs/components/List.js">
import React, { useRef } from 'react'
import { useEffect, useState } from 'react'
import ChainCard from './ChainCard'

const List = () => {
  const [chains, setChains] = useState([])
  const [originalChainsArray, setOriginalChainsArray] = useState([])
  const [isMainnetSelected, setIsMainnetSelected] = useState(false)
  const [isTestnetSelected, setIsTestnetSelected] = useState(false)
  const inputRef = useRef(null)

  useEffect(() => {
    fetch(
      'https://explorer-api.walletconnect.com/v3/chains?projectId=8e998cd112127e42dce5e2bf74122539'
    )
      .then(response => response.json())
      .then(data => {
        setChains(data.chains)
        setOriginalChainsArray(
          Object.keys(data.chains).map(key => ({ ...data.chains[key], namespace: key }))
        )
      })
      .catch(error => console.error(error))
  }, [])

  const chainsArray = Object.keys(chains).map(key => ({
    ...chains[key],
    namespace: chains[key].namespace || key
  }))

  useEffect(() => {
    if (isTestnetSelected && isMainnetSelected) {
      setChains(originalChainsArray)
    }
  }, [isTestnetSelected, isMainnetSelected])

  useEffect(() => {
    inputRef.current.value = ''
    if (isMainnetSelected) {
      const filteredChains = originalChainsArray.filter(chain => {
        return !chain.testnet
      })
      setChains(filteredChains)
    } else {
      setChains(originalChainsArray)
    }
  }, [isMainnetSelected])

  useEffect(() => {
    inputRef.current.value = ''
    if (isTestnetSelected) {
      const filteredChains = originalChainsArray.filter(chain => {
        return chain.testnet
      })
      setChains(filteredChains)
    } else {
      setChains(originalChainsArray)
    }
  }, [isTestnetSelected])

  return (
    <div className="chain-list">
      <div className="chain-list__header">
        <div className="chains-list__search__container">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
            />
          </svg>

          <input
            type="text"
            name="search"
            className="chain-list__search"
            placeholder="Search for a chain..."
            ref={inputRef}
            onChange={e => {
              const search = e.target.value
              const filteredChains = originalChainsArray
                .filter(item => {
                  if (isTestnetSelected && isMainnetSelected) {
                    return true
                  }
                  if (isTestnetSelected) {
                    return item.testnet
                  }
                  if (isMainnetSelected) {
                    return !item.testnet
                  }
                  return true
                })
                .filter(chain => {
                  return chain.name.toLowerCase().includes(search.toLowerCase())
                })
              setChains(filteredChains)
            }}
          />
        </div>
        <div className="chains-list__checkbox__wrapper">
          <p
            style={{
              fontSize: '1rem',
              display: 'flex',
              alignItems: 'center',
              gap: '0.5rem',
              justifyContent: 'space-between',
              color: 'var(--ifm-color-gray-700)',
              margin: 0,
              whiteSpace: 'nowrap'
            }}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth="1.5"
              width={20}
              height={20}
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.568a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z"
              />
            </svg>
            Filter By
          </p>
          <div className="chains-list__checkbox__container">
            <button
              style={{
                borderColor: isTestnetSelected
                  ? 'var(--ifm-color-primary)'
                  : 'var(--ifm-border-color)',
                backgroundColor: isTestnetSelected
                  ? 'var(--ifm-color-primary-darkest)'
                  : 'var(--ifm-hover-overlay)',
                color: isTestnetSelected ? 'var(--ifm-color-white)' : 'inherit'
              }}
              className="chains-list__checkbox chains-list__checkbox--testnet"
              onClick={e => {
                setIsTestnetSelected(!isTestnetSelected)
              }}
            >
              Testnet
            </button>
            <button
              style={{
                borderColor: isMainnetSelected
                  ? 'var(--ifm-color-primary)'
                  : 'var(--ifm-border-color)',
                backgroundColor: isMainnetSelected
                  ? 'var(--ifm-color-primary-darkest)'
                  : 'var(--ifm-hover-overlay)',
                color: isMainnetSelected ? 'var(--ifm-color-white)' : 'inherit'
              }}
              className="chains-list__checkbox chains-list__checkbox--mainnet"
              onClick={e => {
                setIsMainnetSelected(!isMainnetSelected)
              }}
            >
              Mainnet
            </button>
          </div>
        </div>
      </div>
      <div className="chain-card-container">
        {chainsArray?.map((chain, index) => (
          <ChainCard key={index} chainName={chain.name} namespace={chain.namespace} />
        ))}
      </div>
    </div>
  )
}

export default List
</file>

<file path="docs/components/PlatformTabItem.js">
import React from 'react'
import TabItem from '@theme-original/TabItem'

export default function PlatformTabItem(props) {
  return (
    <>
      <TabItem className="platform-tabs--items" {...props} />
    </>
  )
}
</file>

<file path="docs/components/PlatformTabs.js">
import React from 'react'
import Tabs from './Tabs'

const PLATFORM_MAP = [
  {
    value: 'web',
    label: 'Web'
  },
  {
    value: 'ios',
    label: 'iOS'
  },
  {
    value: 'android',
    label: 'Android'
  },
  {
    value: 'flutter',
    label: 'Flutter'
  },
  {
    value: 'react',
    label: 'React'
  },
  {
    value: 'vue',
    label: 'Vue'
  },
  {
    value: 'html',
    label: 'HTML'
  },
  {
    value: 'javascript',
    label: 'JavaScript'
  },
  {
    value: 'react-native',
    label: 'React Native'
  },
  {
    value: 'unity',
    label: 'Unity'
  },
  {
    value: 'csharp',
    label: 'C#'
  },
  {
    value: 'mobile',
    label: 'Mobile'
  },
  {
    value: 'wagmi',
    label: 'Wagmi'
  },
  {
    value: 'wagmi1',
    label: 'Wagmi v1'
  },
  {
    value: 'other',
    label: 'Other'
  },
  {
    value: 'viem',
    label: 'Viem'
  },
  {
    value: 'ethers',
    label: 'Ethers'
  },
  {
    value: 'ethers5',
    label: 'Ethers v5'
  },
  {
    value: 'web3js',
    label: 'Web3.js'
  },
  {
    value: 'evm',
    label: 'EVM'
  },
  {
    value: 'solana',
    label: 'Solana'
  }
]

const valuesBuilder = activeOptions => {
  const values = PLATFORM_MAP.filter(({ value }) => activeOptions.includes(value))
  return values.length ? values : PLATFORM_MAP
}

export default function PlatformTabs(props) {
  const values = valuesBuilder(props.activeOptions)
  return (
    <>
      <Tabs
        className="platform-tabs"
        queryString={props.queryString || 'platform'}
        values={values}
        {...props}
      />
    </>
  )
}
</file>

<file path="docs/components/SolanaBanner.js">
import React from 'react'
import Link from '@docusaurus/Link'

export const SolanaBanner = () => {
  const title = 'AppKit Solana'
  const description = 'AppKit now supports Solana. Learn how to integrate it into your project.'
  const href = '/web3modal/features/solana'

  return (
    <div className="cloud__wrapper cloud__wrapper--special cloud__wrapper--solana">
      <div className="cloud__text-container">
        <h2>{title}</h2>
        <p>{description}</p>
      </div>
      <Link to={href}>
        Learn More
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          height={20}
          width={20}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M17.25 8.25L21 12m0 0l-3.75 3.75M21 12H3"
          />
        </svg>
      </Link>
    </div>
  )
}

export default SolanaBanner
</file>

<file path="docs/components/Table.js">
import React from 'react'

export const Table = ({ headers, data }) => {
  return (
    <table className="tableMatrix">
      <thead>
        <tr>
          {headers.map((header, index) => (
            <th key={`${index}-th-${header}`}>{header}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((row, index) => (
          <tr key={`${index}-tr`}>
            {Object.values(row).map(cell => (
              <td key={`${index}-td-${cell.code ?? cell}`}>
                {cell.code ? (
                  <code>{cell.code}</code>
                ) : (
                  cell.split(/\r\n|\r|\n/g).map(line => (
                    <>
                      {line}
                      <br />
                    </>
                  ))
                )}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  )
}

export default Table
</file>

<file path="docs/components/W3MQuickStart.js">
import React from 'react'
import wcGlassImage from '../../static/assets/wc-logo-glass.png'
import Link from '@docusaurus/Link'
import CodeBlock from '@theme/CodeBlock'

export const CloudBanner = props => {
  const handleAnalytics = () => {
    const props = {
      path: window.location.pathname
    }
    plausible('cloud-banner-click', {
      props
    })
  }
  return (
    <div className="w3m-qs__wrapper">
      <div className="w3m-qs__text-container">
        <h2>‚ö°Ô∏è QuickStart</h2>
        <p>Setup a dapp with AppKit in minutes!</p>
      </div>
      <CodeBlock
        className="w3m-qs__code-block"
        language="bash"
      >{`npm create alpha@latest`}</CodeBlock>
    </div>
  )
}

export default CloudBanner
</file>

<file path="docs/components/WhatsNewBanner.js">
import React from 'react'
import wcGlassImage from '../../static/assets/wc-logo-glass-full.webp'
import Link from '@docusaurus/Link'

export const CloudBanner = ({ title, description, href, image = wcGlassImage }) => {
  return (
    <div className="cloud__wrapper cloud__wrapper--special">
      <div className="cloud__text-container">
        <h2>{title}</h2>
        <p>{description}</p>
      </div>
      <Link to={href}>
        Learn More
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          height={20}
          width={20}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M17.25 8.25L21 12m0 0l-3.75 3.75M21 12H3"
          />
        </svg>
      </Link>
      {image === wcGlassImage ? (
        <img
          style={{
            transform: 'scale(1.5) scaleX(-1)'
          }}
          className="cloud__image"
          src={image}
          alt="cloud illustration"
        />
      ) : (
        <img
          className="cloud__image"
          src={image}
          alt="cloud illustration"
          style={{
            transform: 'scale(0.75)'
          }}
        />
      )}
    </div>
  )
}

export default CloudBanner
</file>

<file path="docs/components/YoutubeEmbed.js">
import React from 'react'

const YoutubeEmbed = ({ videoId }) => (
  <div className="youtube-embed-container">
    <iframe
      src={`https://www.youtube.com/embed/${videoId}`}
      title="Youtube video player"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen
    ></iframe>
  </div>
)

export default YoutubeEmbed
</file>

<file path="docs/walletkit/android/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/walletkit/android/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import ExplorerSubmission from '../../../cloud/explorer-submission.mdx'

<ExplorerSubmission />
</file>

<file path="docs/walletkit/android/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/walletkit/android/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/walletkit/android/notifications/notify/installation.mdx">
# Installation

Add the `jitpack.io` Maven repository to your `root/build.gradle.kts` file. For example:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

In `app/build.gradle.kts` add the notify package and its dependencies:

```gradle
implementation(platform("com.walletconnect:android-bom:release_version"))
implementation("com.walletconnect:android-core")
implementation("com.walletconnect:notify")
```

#### Requirements

- Android API level minimum 23
- Java minimum version 11

## Next Steps

Now that you've installed WalletConnect Notify, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the Notify API.
</file>

<file path="docs/walletkit/android/notifications/notify/overview.mdx">
# Overview

:::info
For those integrating notifications related to wallet pairing and sign requests, please check [here](../push.mdx).
:::

The WalletConnect Notify API is designed to enhance the interaction between wallet users and dapps by offering a robust notification system. This API empowers wallet developers to implement a dynamic notification experience directly within their wallets. It provides the functionality for users to opt-in to notifications, ensuring they stay informed about critical events and interactions.

The Notify API is versatile, with support for both iOS and Android platforms, making it an ideal choice for cross-platform wallet applications.

Coupled with the [AppKit Notifications](../../../../appkit/features/notifications.mdx), the Notify API forms part of a comprehensive toolkit that enables seamless integration of web3 communication and messaging features into dapps. This ensures a more connected and interactive experience for users in the decentralized ecosystem.

## Features

Some of the key features of the Notify API include:

- **Push Notifications for Desktop and Native Platforms**: This feature enables dapps to directly send vital notifications to user wallets, ensuring timely and relevant communication.
- **Robust Spam Protection**: Users have complete authority over which dapps can send them notifications, effectively eliminating any unsolicited messages from unknown sources. Furthermore, users can fine-tune their preferences to only receive notifications types they are interested in, like new features or some important events occurence.
- **Chain Agnostic Architecture**: The Notify API is built to be compatible with any blockchain, allowing seamless multi-chain support without the need for writing additional integration code. **As of November 2023, the Notify Server and Clients are equipped to support EVM chains. Plans to extend support to non-EVM chains are in progress and are a significant part of our upcoming development roadmap.**

_Example integration_
![Web3Inbox](/assets/web3inbox/w3i-hero.png)
</file>

<file path="docs/walletkit/android/notifications/notify/resources.mdx">
# Resources

Valuable assets for developers interested in integrating Notify API into their wallet.

- [Web3Inbox.com app](https://app.web3inbox.com) - Inbox web app that simulates wallet experience.
- [GM dapp](https://gm.walletconnect.com/) - Example dapp that sends notification every hour.
- [GM hackers](https://github.com/WalletConnect/gm-hackers) - Template used in hackathons sponsored by WalletConnect.

## Wallet Resources

To check more in details go and visit our¬†[WalletKit Kotlin implementation app](https://github.com/WalletConnect/WalletConnectKotlinV2/tree/develop/sample/wallet). Sample Wallet .apk files can be found under the latest release tag in¬†[Kotlin's V2 repository](https://github.com/WalletConnect/WalletConnectKotlinV2/tags)

If you need to test your app's integration, you can use one [our GM dapp.](https://gm.walletconnect.com/)

## Need Technical Support?

If you require technical support along the way, please drop a message on the [WalletConnect GitHub](https://github.com/orgs/WalletConnect/discussions/) and our team will get back to you as soon as possible.
</file>

<file path="docs/walletkit/android/notifications/notify/spam-protection.mdx">
# Spam Protection

Users play a critical role in web3. That‚Äôs why, with Web3Inbox, we‚Äôre committed to ensuring users can enjoy a safe, seamless, and reliable experience that puts them in the driver‚Äôs seat. As part of that pledge, Web3Inbox provides a number of user-first, anti-spam features and elements that ensure users are always in control of their web3 communications.

## How are users protected from spam with Web3Inbox?

### Becoming a Web3Inbox customer

When a wallet offers app notifications to their users via Web3Inbox, the feature will always be optional. If users decide they want to receive notifications from selected apps via their wallet, they‚Äôll be able to ‚Äòopt-in‚Äô and subscribe to an app‚Äôs notifications by signing a message request. Similarly, when accessing notifications through the [Web3Inbox.com app](https://app.web3inbox.com), users will be met with the same request for each application they choose to subscribe to. This feature not only enables users to experience a customized, ‚Äòapp-by-app‚Äô approach to staying connected in web3, but also ensures they only ever hear from the apps they choose to ‚Äî no unsolicited notifications or spam from unknown senders. Its their curated inbox, connected with only those they choose.

### Setting customized notification preferences

Once users have subscribed to their chosen apps, they have the option to define and set which types of notifications they receive from those apps. For example, a user may wish to receive only information regarding changes to their portfolio from a DEX, or, they might want to receive notifications from an NFT marketplace ‚Äî but only notifications regarding their own NFT collections. In these scenarios, they‚Äôll have the ability to disable other notification types, like marketing updates, and ensure their feed is curated to show only information that‚Äôs meaningful to them. As apps set their own notification types, they have unlimited optionality to really build out a notification structure they know can support their users‚Äô needs ‚Äî no ‚Äòone size fits all‚Äô approach, but a personable, community-oriented structure that puts both app and user needs‚Äô at the forefront of communication.

### Rate limiting

Apps are limited to a maximum number of notifications they‚Äôre able to send to their community. Specifically, apps may send accounts notifications twice an hour on average, but may exceeed that average in bursts of up to 50 at a time.

## Our continued pledge on spam protection

We‚Äôre constantly working on improving and growing our products, and we have a number of impactful anti-spam features and functions in the works set to increase the overall protection and user experience of Web3Inbox users:

### User reporting

Users will have the ability to report applications that appear to be acting or engaging with their community in a malicious or suspicious manner. Projects that are flagged as malicious may be removed from the Web3Inbox discover page and have notification functionality disabled.
</file>

<file path="docs/walletkit/android/notifications/notify/usage.mdx">
import CloudBanner from '../../../../components/CloudBanner'

# Usage

In this section, we showcase the aspects of using the Notify API. We'll guide you through the initial steps of initializing the Notify client and logging in a blockchain account. You'll also learn how to manage your subscriptions and messages. Additionally, we cover the process of setting up and displaying push notifications on your preferred platform. To ensure a good user experience, we include best practices for spam protection, helping you to enable the users to maintain control over the notifications wallet receives.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out¬†Extra (Platform Specific)¬†under this section.

- [Initialization](#initialization):
  Creating a new Notify Client instance and initializing it with a projectId from¬†[Cloud](https://cloud.walletconnect.com/).
- [Account login](#account-login):
  A SIWE message must be signed by the user in order to authorize the client to use Notify API
- [Subscribing to a new dapp](#subscribing-to-a-new-dapp):
  Opt-in to receive notifications from dapp
- [Fetching active subscriptions](#fetching-active-subscriptions):
  Get active subscriptions
- [Fetching subscription‚Äôs notification](#fetching-subscriptions-notifications):
  Get notifications of a subscription
- [Fetching available notification types](#fetching-available-notification-types):
  Get latest notification types
- [Updating subscriptions notification settings](#updating-subscriptions-notification-settings):
  Change allowed notification types sent by dapp
- [Unsubscribe from a dapp](#unsubscribe-from-a-dapp):
  Opt-out from receiving notifications from a dapp
- [Account logout](#account-logout):
  To stop receiving notifications to this client, accounts can logout of using Notify API
- [Push Notification best practices](#push-notification-best-practices):
  Guidelines on how to implement Push Notifications across different platforms
- [Firebase Cloud Messaging setup **(Android)**](#firebase-cloud-messaging-setup):
  Configuring Android app in order to decrypt notifications
- [NotifyClient.Delegate **(Android)**](#notifyclientdelegate):
  Setting and overriding functions through NotifyDelegate.

## Initialization

<CloudBanner />

To initialize the Notify client, create a `Notify.Params.Init` object in the Android Application class with the Core Client passed as a parameter. The `Notify.Params.Init` object will then be passed to the `Notify.initialize` function. There is also an `onError` callback that will need to be provided which will return an instance of `Notify.Model.Error` if there's an issue initializing the client.

**Note:** The CoreClient used here will be the same instance of the CoreClient used in other WalletConnect Kotlin SDKs

```kotlin
val projectId = PROJECT_ID
val appMetaData = Core.Model.AppMetaData(
    name = /* The name of your project as a String */,
    description = /* A description of your project as a String */,
    url = /* A url for your project as a String */,
    icons = /* A list of URLs to icons related to your project as Strings */,
    redirect = /* A redirect URI used by Dapps to deeplink back to your wallet. This is a String value  */
)

CoreClient.initialize(projectId = projectId, connectionType = ConnectionType.AUTOMATIC, application = this, metaData = appMetaData)

Notify.initialize(init = Notify.Params.Init(core = CoreClient) { error: Notify.Model.Error ->
    // Error will be thrown if there's an issue during initialization
}
```

## Account login

In order to register account in Notify API to be able to subscribe to any dapp to start receving notifications, account needs to sign SIWE message to prove ownership. Developers can check if an account is registered by calling **`isRegistered()`** function. If the account is not registered, developers should call **`prepareRegistration()`** and then **`register()`** function to register the account.

Snippet below shows how to check if an account is registered and how to register an account if it's not registered yet. Developers could use `CacaoSigner` to sign the message or use their own signing method.

```kotlin
val account: String = ""// The CAIP-10 account i.e. "eip155:1:0xAbC1234567890DefABC1234567890dEFABC12345"
val domain = BuildConfig.APPLICATION_ID

// Caution: This function is blocking and runs on the current thread. It is advised that this function be called from background operation
val isRegistered = NotifyClient.isRegistered(params = Notify.Params.IsRegistered(account = account, domain = domain))

if (!isRegistered) {
    NotifyClient.prepareRegistration(
        params = Notify.Params.PrepareRegistration(account = account, domain = domain),
        onSuccess = { cacaoPayloadWithIdentityPrivateKey, message ->

            // Pick one of the following methods to sign the message:

            // 1. Using CacaoSigner to sign the message
            val signature = CacaoSigner.sign(
              message,
              PRIVATE_KEY, // Private key used to signing a message,
              SignatureType.EIP191
            )

            // 2. Alternatively, you can use your own signing method
            /** Add imports:
                import com.walletconnect.android.cacao.signature.SignatureType
                import com.walletconnect.android.internal.common.signing.signature.Signature
                import com.walletconnect.android.internal.common.signing.signature.toCacaoSignature
             */

            val signature: String = // Here developers provide signed message using their own signing method
            val cacaoSignature = Notify.Model.Cacao.Signature(SignatureType.EIP191.header, Signature.fromString(signature).toCacaoSignature())

            // Once the message has been signed, call the register function

            NotifyClient.register(
                params = Notify.Params.Register(cacaoPayloadWithIdentityPrivateKey = cacaoPayloadWithIdentityPrivateKey, signature = signature),
                onSuccess = {
                  // Registration was successful
                 },
                onError = {
                  // There was an error while trying to register the account
                }
            )

        },
        onError = {
          // There was an error while trying to prepare the registration
        }
    )
} else {
  // Great! Account is already registered
}
```

## Subscribing to a new dapp

To begin receiving notifications from a dapp, users must opt-in by subscribing. This subscription process grants permission for the dapp to send notifications to the user. These notifications can serve a variety of purposes, such as providing updates on the user's blockchain account activities or informing them about ongoing campaigns within the dapp. Upon initial subscription, clients will be automatically enrolled to receive all types of notifications as defined by the dapp at that moment. Users have the flexibility to modify their notification settings later, allowing them to tailor the types of alerts they receive according to their preferences.

```kotlin
val appDomain: Uri = // Dapp uri. e.g. gm.walletconnect.com
val account: String = // CAIP-10 account
val timeout: Duration? = // Optional. Timeout - min 5 sec, max 60 sec, default 60 sec
val params = Notify.Params.Subscribe(appDomain, account, timeout)

NotifyClient.subscribe(params = params).let { result ->
    when (result) {
        is Notify.Result.Subscribe.Success -> {
          // callback for when the subscription request was successful
        }

        is Notify.Result.Subscribe.Error -> {
          // callback for when the subscription request has failed
        }

    }
}
```

## Fetching active subscriptions

To fetch the current list of subscriptions an account has, call **`getActiveSubscriptions()`**.

Method will return a map with the topic as the key and `Notify.Model.Subscription` as the value.

```kotlin
val account: String = // CAIP-10 account
val timeout: Duration? = // Optional. Timeout - min 5 sec, max 60 sec, default 60 sec
val params = Notify.Params.GetActiveSubscriptions(account, timeout)

try {
  val result: Map<String, Notify.Model.Subscription> = NotifyClient.getActiveSubscriptions(params)
} catch (e: Exception) {
  // callback for when the get active subscriptions request has failed
}
```

## Fetching subscription‚Äôs notifications

To fetch subscription‚Äôs notifications by calling **`getNotificationHistory()`**.

```kotlin
val topic: String = // active subscription topic
val limit: Int? = // Optional. Limit - min 1, max 50, default 10
val startingAfter: String? = // Optional. Id of the notification to start after
val timeout: Duration? = // Optional. Timeout - min 5 sec, max 60 sec, default 60 sec

val params = Notify.Params.GetNotificationHistory(topic, limit, startingAfter, timeout)

NotifyClient.getNotificationHistory(params).let { result ->
    when (result) {
        is Notify.Result.GetNotificationHistory.Success -> {
          // callback for when the get notification history request was successful
        }

        is Notify.Result.GetNotificationHistory.Error -> {
          // callback for when the get notification history request has failed
        }
    }
}
```

## Fetching available notification types

Developers can fetch latest notification types specified by dapp by calling **`getNotificationTypes()`**¬†function.

Method will return a map with the notification type id as the key and `Notify.Model.NotificationType` as the value.

```kotlin
val appMetadata: Core.Model.AppMetaData = // App Metadata could be fetched from NotifyClient.getActiveSubscriptions()
val appDomain: String = URI(appMetadata.url).host
val timeout: Duration? = // Optional. Timeout - min 5 sec, max 60 sec, default 60 sec

val params = Notify.Params.NotificationTypes(appDomain, timeout)
try {
  val result: Map<String, Notify.Model.NotificationType> = NotifyClient.getNotificationTypes(params)
} catch (e: Exception) {
  // callback for when the get notification types request has failed
}
```

## Updating subscriptions notification settings

Users can alter their notification settings to filter out unwanted alerts from a dapp. During this process, they review and select the types of notifications they wish to receive, based on the latest options provided by the dapp. Available notification types fetching is shown in the [next section](#fetching-available-notification-types).

```kotlin
val topic: String = // active subscription topic
val scope: List<String> = // list of notification types
val timeout: Duration? = // Optional. Timeout - min 5 sec, max 60 sec, default 60 sec
val params = Notify.Params.UpdateSubscription(topic, scope, timeout)

NotifyClient.update(params).let { result ->
    when (result) {
        is Notify.Result.UpdateSubscription.Success -> {
          // callback for when the update request was successful
        }
        is Notify.Result.UpdateSubscription.Error -> {
          // callback for when the update request has failed
        }
    }
}
```

## Unsubscribe from a dapp

To opt-out of receiving notifications from a dap, a user can decide to unsubscribe from dapp.

```kotlin
val topic: String = // active subscription topic
val timeout: Duration? = // Optional. Timeout - min 5 sec, max 60 sec, default 60 sec
val params = Notify.Params.DeleteSubscription(topic)

NotifyClient.deleteSubscription(params).let { result ->
    when (result) {
        is Notify.Result.DeleteSubscription.Success -> {
          // callback for when the delete request was successful
        }

        is Notify.Result.DeleteSubscription.Error -> {
          // callback for when the delete request has failed
        }
    }
}
```

## Account logout

If an account is removed from the client or a user no longer wants to receive notifications for this account, you can logout the account from Notify API by calling **`unregister()`**. This will remove all subscriptions and messages for this account from the client‚Äôs storage.

```kotlin
val params = Notify.Params.Unregistration(/*CAIP-10 account*/)
NotifyClient.unregister(
  params,
  onSuccess = {
      // callback for when the unregistration was successful
  },
  onError = { error ->
    // callback for when the unregistration has failed
  }
)
```

## Push Notification best practices

To create a good user experience and to guide users into unsubscribing from the correct dapp, there are certain best practices when displaying push notifications.

`Core.Model.Message` contains a `type` field, which is a unique id of the notification type. It is recommended to use this field as a notification channel id. By doing so it will create a channel for each notification type. To allow users to granularly control which notifications they want to receive within system settings, it is recommended to create a separate channel for every dapp and every notification type they might have. By doing so user would be able to turn off notifications for specific notification type per every subscribed dapp.

```kotlin
class SampleFirebaseService: PushMessagingService() {
  //...
  override fun onMessage(message: Core.Model.Message, originalMessage: RemoteMessage) {
      if (message is Core.Model.Message.Notify) {
        val account: String = // CAIP-10 account
        val appMetadata = NotifyClient.getActiveSubscriptions(Notify.Params.GetActiveSubscriptions(account))[topic]?.metadata
            ?: throw IllegalStateException("No active subscription for topic: $topic")

        val appDomain = URI(appMetadata.url).host
            ?: throw IllegalStateException("Unable to parse domain from $appMetadata.url")

        val notificationType = NotifyClient.getNotificationTypes(Notify.Params.GetNotificationTypes(appDomain))[channelId]
            ?: throw IllegalStateException("No notification type for topic:${topic} and type: $channelId")

        val channelName = appMetadata.name + ": " + notificationType.name
        val channelId = message.type

        val notificationBuilder = NotificationCompat.Builder(this, channelId)
            .setContentTitle(message.title)
            .setSmallIcon(android.R.drawable.ic_popup_reminder) // specify icon for notification
            .setContentText(message.body)
            .setAutoCancel(true) // clear notification after click
            .setSound(defaultSoundUri) // specify sound for notification
            .setContentIntent(pendingIntent) // specify pendingIntent

        // Since android Oreo notification channel is needed.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH)
            notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(message.hashCode(), notificationBuilder.build()) // specify id of notification
      }
  }
//...
```

### Firebase Cloud Messaging setup

To setup Firebase Cloud Messaging please follow our [Push Notifications docs](../push.mdx).

### NotifyClient.Delegate

`NotifyClient` needs a `NotifyClient.Delegate` passed to it for it to be able to expose asynchronous updates sent from the dapp. It's recommended to set the delegate in the `onCreate` function of the `Application` class.

```kotlin
val walletDelegate = object : NotifyClient.Delegate {

    override fun onNotifySubscription(notifySubscribe: Notify.Event.Subscription) {
        // Triggered when a wallet initiated subscription has been created
    }

    override fun onNotifyNotification(notifyNotification: Notify.Event.Notification) {
        // Triggered when a message has been sent by the Dapp. The message contains the title, body, icon, and url
    }

    override fun onError(error: Notify.Model.Error) {
        // Triggered when there's an error inside the SDK
    }
}

NotifyClient.setDelegate(walletDelegate)
```
</file>

<file path="docs/walletkit/android/notifications/push.mdx">
import PlatformTabs from '../../../components/PlatformTabs'
import PlatformTabItem from '../../../components/PlatformTabItem'

# Push Notifications

WalletKit provides the functionality for wallets to receive push notifications through Firebase Cloud Messaging (FCM) and Apple Push Notification Service (APNs) via the Push Server. This feature ensures that wallets are promptly notified of incoming signature requests. Each push notification contains the encrypted details of the signature request. Upon receiving the notification, it can be decrypted and presented to the developer, allowing for customization of the message according to their requirements.

## Server setup

For the push notifications to be forwarded to FCM or APNs, the [Push Server](../../../advanced/push-server) will need to be configured with your FCM or APNs server API credentials.

## App setup

### Register the device token

To enable a device for push notifications, it's essential to register the device token using `Web3Wallet.registerDeviceToken`. This token can be obtained from either FCM or APNS, depending on the platform used.

This method enables wallets to receive push notifications from WalletConnect's Push Server via Firebase Cloud Messaging. This means you will have to setup your project with Firebase before being able to call `registerDeviceToken()` method.

To register a wallet to receive WalletConnect push notifications, call `Web3Wallet.registerDeviceToken` and pass the Firebase Access Token.

```kotlin
val firebaseAccessToken: String = //FCM access token received through the Firebase Messaging SDK
val enableEncrypted: Boolean = true //Flag that enables receiveing the detailed notifications

Web3Wallet.registerDeviceToken(
    firebaseAccessToken = firebaseAccessToken,
    enableEncrypted = enableEncrypted,
    onSuccess = {
        // callback triggered once registered successfully with the Push Server
    },
    onError = { error: Wallet.Model.Error ->
        // callback triggered if there's an exception thrown during the registration process
    })
```

### Receiving push notifications

After the device token is registered, the next step involves setting up the notification service specific to the platform being used. This service will decrypt the incoming requests and forward them to the developer for further processing and integration.

The `PushMessagingService` is a wrapper around the `FirebaseMessagingService`. The `PushMessagingService` class needs to be implemented for WalletKit to be able to decrypt and notify wallets of a push notification sent from the Dapp in the background. This service also needs to be registered in the `AndroidManifest.xml` file similar to the example in the FCM documentation.

```kotlin
class SampleFirebaseService: PushMessagingService() {

    override fun newToken(token: String) {
        // Triggered when Firebase Cloud Messaging creates a new token
    }

    override fun registeringFailed(token: String, throwable: Throwable) {
        // Triggered when Firebase Cloud Messaging if there is an error with registering with the Push Server with a new token
    }

    override fun onMessage(message: Core.Model.Message, originalMessage: RemoteMessage) {
        // Triggered when a message is sent from the Push Server through Firebase Cloud Messaging and the message contains `Core.Model.Message`. The original FCM RemoteMessage is also returned
    }

    override fun onDefaultBehavior(message: RemoteMessage) {
        // Triggered when a message is sent from the Push Server through Firebase Cloud Messaging and the message does not contain `Core.Model.Message` in the payload. The original FCM RemoteMessage returned instead
    }

    override fun onError(throwable: Throwable, defaultMessage: RemoteMessage) {
        // Triggered when there is an error that occurs when a message is received from the Push Server
    }
}
```

```xml
<application...>
    <service android:name=".SampleFirebaseService">
        <intent-filter>
            <action android:name="com.google.firebase.MESSAGING_EVENT" />
        </intent-filter>
    </service>
</application>
```
</file>

<file path="docs/walletkit/android/best-practices.mdx">
# Best Practices

The purpose of this guide is to show the best practices in regards of the WalletKit client usage. The goal is to provide the best user experience that just works in every circumstances.

:::note
In order to ensure the best user experience and flawless connection flow, please make sure that WalletKit is initialized immediately after your app launch, especially if launched via a WalletConnect Deep Link. It guarantees that websocket connection is opened immediately and all requests are received by your wallet
:::

## Pairing

A pairing is a connection between a wallet and a dapp that has fixed permissions to only allow a dapp to propose a session through it. Dapp can propose infinite number of sessions on one pairing. Wallet must use a pair method from WalletKit client to pair with dapp.

```kotlin
val pairingParams = Wallet.Params.Pair(pairingUri)
Web3Wallet.pair(pairingParams, 
    onSuccess = {
        //Subscribed on the pairing topic successfully. Wallet should await for a session proposal
    },
    onError = { error ->
        //Some error happens while pairing - check Expected errors section
    }
}
```

### Pairing State

A pairing state is a primitive exposed by the WalletKit client for a wallet to indicate whether it should await a session proposal. The pairing state is `true` when a wallet scans a QR and awaits a session proposal. Once the session proposal is received by the wallet, the pairing state is changed to `false`.
When `true` wallet should show a loading indicator awaiting a session proposal, when changed to `false` a proposal dialog should be displayed.

```kotlin
val coreDelegate = object : CoreClient.CoreDelegate {
    override fun onPairingState(pairingState: Core.Model.PairingState) {
        //Here a pairing state is triggered
    }
    ...other callbacks
}

CoreClient.setDelegate(coreDelegate)
````

### Pairing Expiry

A pairing expiry event is triggered whenever a pairing is expired. The expiry for inactive pairing is 5 mins, whereas for active pairing is 30 days. A pairing becomes active when a session proposal is received and user successfully approves it. This event helps to know when given pairing expires and update UI accordingly.

```kotlin
val coreDelegate = object : CoreClient.CoreDelegate {
    override fun onPairingExpired(expiredPairing: Core.Model.ExpiredPairing) {
        //Here a pairing expiry is triggered
    }
    ...other callbacks
}

CoreClient.setDelegate(coreDelegate)

````

### Expected User flow

### Pairing Flow

![](/assets/pairing.gif)

### Pairing Error

![](/assets/pairing_error.gif)

### Expected Errors

While pairing the following errors might occur:

- No Internet connection error or pairing timeout when scanning QR with no Internet connection
  - User should pair again with Internet connection
- Pairing expired error when scanning a QR code with expired pairing
  - User should refresh a QR code and scan again
- Pairing with existing pairing is not allowed
  - User should refresh a QR code and scan again. I usually happens when user scans an already paired QR code.

## Session Proposal

A session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Whenever a user wants to establish a connection between a wallet and a dapp, one should approve a session proposal.

### User Action Feedback

Whenever user approves or rejects a session proposal, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

Session approve

```kotlin
 Web3Wallet.approveSession(approveProposal,
    onSuccess = {
        //Session approval response was sent successfully - update your UI
    }
    onError = { error ->
        //Error while sending session approval - update your UI
    })
```

Session reject

```kotlin
 Web3Wallet.rejectSession(reject,
    onSuccess = {
        //Session rejection response was sent successfully - update your UI
    },
    onError = { error ->
          //Error while sending session rejection - update your UI
    })
```

### Session Proposal Expiry

A session proposal expiry is 5 mins. It means a given proposal is stored for 5 mins in the SDK storage and user has 5 mins for approval or rejection decision. After that time the below event is emitted and proposal modal should be removed from the app's UI.

```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
    override fun onProposalExpired(proposal: Wallet.Model.ExpiredProposal) {
            //Here this event is triggered when a proposal expires - update your UI
    }
    ...other callbacks
}
Web3Wallet.setWalletDelegate(walletDelegate)
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/pairing.gif)

### Error Handling

![](/assets/proposal_error.gif)

### Expected Errors

While approving or rejecting a session proposal the following errors might occurs:

- No Internet connection
  - It happens when a user tries to approve or reject session proposal with no Internet connection
- Session proposal expired
  - It happens when users tries to approve or reject expired session proposal
- Invalid namespaces
  - It happens when a validation of session namespaces fails
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Session Request

A session request represents the request sent by a dapp to a wallet.

### User Action Feedback

Whenever user approves or rejects a session request, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

```kotlin
Web3Wallet.respondSessionRequest(Wallet.Params.SessionRequestResponse,
    onSuccess = {
        //Session request response was sent successfully - update your UI
    },
    onError = { error ->
        //Error while sending session response - update your UI
    })
```

### Session Request Expiry

A session request expiry is defined by a dapp. It's value must be between now() + 5mins and now() + 7 days. After the session request expires the below event is emitted and session request modal should be removed from the app's UI.

```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
    override fun onRequestExpired(request: Wallet.Model.ExpiredRequest) {
        //Here this event is triggered when a session request expires - update your UI
    }
    ...other callbacks
}
Web3Wallet.setWalletDelegate(walletDelegate)
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/session_request.gif)

### Error Handling

![](/assets/session_request_error.gif)

### Expected Errors

While approving or rejecting a session request the following error might occur:

- Invalid session
  - This error might happen when user approves or rejects a session request on expired session
- Session request expired
  - This error might happen when user approves or rejects a session request that already expires
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Web Socket Connection State

The Web Socket connection state tracks the connection with the relay server, event is emitted whenever a connection state changes.

```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
    override fun onConnectionStateChange(state: Wallet.Model.ConnectionState) {
        //Here this event is triggered when a connection state has changed
    }
    ...other callbacks
}
Web3Wallet.setWalletDelegate(walletDelegate)
````

### Expected User flow

### Connection State

![](/assets/connection_state.gif)
</file>

<file path="docs/walletkit/android/eip5792.mdx">
# Wallet Call API

WalletConnect supports [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792#atomicbatch-capability), which defines new JSON-RPC methods that enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.
Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.

- `wallet_sendCalls`: Requests that a wallet submits a batch of calls.
- `wallet_getCallsStatus`: Returns the status of a call batch that was sent via wallet_sendCalls.
- `wallet_showCallsStatus`: Requests that a wallet shows information about a given call bundle that was sent with wallet_sendCalls.
- `wallet_getCapabilities`: This RPC allows an application to request capabilities from a wallet (e.g. batch transactions, paymaster communication).
</file>

<file path="docs/walletkit/android/installation.mdx">
# Installation

Add the `jitpack.io` Maven repository to your `root/build.gradle.kts` file. For example:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

In `app/build.gradle.kts` add the WalletKit package and its dependencies:

```gradle
implementation("com.walletconnect:android-core:release_version")
implementation("com.walletconnect:web3wallet:release_version")
```

## Next Steps

Now that you've installed WalletKit, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the SDK.
</file>

<file path="docs/walletkit/android/link-mode.mdx">
# Link Mode

WalletKit link mode is a low latency mechanism for transporting One-Click Auth requests and session requests over universal links, reducing the need for a WebSocket connection with the Relay. This significantly enhances the user experience when connecting native dApps to native wallets by reducing the latency associated with networking connections, especially when the user has an unstable internet connection.

To support link mode add universal link for your wallet in Cloud project configuration dashboard, configure your AppMetaData `appLink` with a valid universal link and set the `linkMode` property to `true`:

```kotlin
 val appMetaData = Core.Model.AppMetaData(
    ...
    appLink = "https://example.com/example_wallet",
    linkMode = true
)

CoreClient.initialize(
   metaData: appMetaData,
    ...
)

Web3Wallet.initialize(Wallet.Params.Init(core = CoreClient))
```

Once link mode and app link are properly configured and the user interacts with a link mode supporting dApp, your wallet will receive requests over app links. You must pass these requests to WalletKit so it can process them:

```kotlin
val url = intent.dataString
Web3Wallet.dispatchEnvelope(url) { error -> 
    //handle error
}
```

Ensure to handle incoming app links in your Activity onCreate method and in onNewIntent callback.

Ensure that your App Link is properly configured in your app's Manifest file with the `autoVerify` set to `true`:

```
<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />

    <data
        android:host="your_host"
        android:scheme="https">
</intent-filter>
```

For more information on how to configure app links for your app, refer to the [Android Documentation](https://developer.android.com/training/app-links/verify-android-applinks).

For enabling links to app content check [this](https://developer.android.com/training/app-links/deep-linking) documentation page. 

For more information on how to interact with other apps using intents, see [Android Intent Documentation](https://developer.android.com/training/basics/intents).
</file>

<file path="docs/walletkit/android/mobile-linking.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import HowToTest from '../shared/mobile-linking.mdx'

# Mobile Linking

:::info Note

This feature is only relevant to native platforms.

:::

## Usage

Mobile Linking allows your wallet to automatically redirect back to the Dapp allowing for less user interactions and hence a better UX for your users.

### Establishing Communication Between Mobile Wallets and Apps

When integrating a wallet with a mobile application, it's essential to understand how they communicate. The process involves two main steps:

1. **QR Code Handshake:** The mobile app (Dapp) generates a unique URI (Uniform Resource Identifier) and displays it as a QR code. This URI acts like a secret handshake. When the user scans the QR code using their wallet app, they establish a connection. It's like saying, "Hey, let's chat!"
2. **Deep Links and Universal Links:** The URI from the QR code allows the wallet app to create a [deep link](https://support.google.com/google-ads/answer/10023042?hl=en#:~:text=Deep%20links%20send%20mobile%20device,%2C%20Shopping%2C%20and%20Display%20campaigns.) or [universal link](https://developer.apple.com/ios/universal-links/). These links work on both Android and iOS. They enable seamless communication between the wallet and the app.

:::tip

**Developers should prefer Deep Linking over Universal Linking.**

In the case of Universal Linking, the user may be redirected to the browser, which may not be the desired behavior. Deep Linking ensures that the user is redirected to the app, providing a seamless experience.

:::

The connection and sign request flows are similar across platforms.
The next section provides a high-level overview of both flows.

### Connection Flow

- **Dapp Prompts User:** The Dapp asks the user to connect.
- **User Chooses Wallet:** The user selects a wallet from a list of compatible wallets.
- **Redirect to Wallet:** The user is redirected to their chosen wallet.
- **Wallet Approval:** The wallet prompts the user to approve or reject the session (similar to granting permission).
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reunites with Dapp:** After all the interactions, the user ends up back in the Dapp.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking-dark.png')
  }}
/>

### Sign Request Flow

When the Dapp needs the user to sign something (like a transaction), a similar pattern occurs:

- **Automatic Redirect:** The Dapp automatically sends the user to their previously chosen wallet.
- **Approval Prompt:** The wallet asks the user to approve or reject the request.
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reconnects:** Eventually, the user returns to the Dapp.

<ThemedImage
  alt="Mobile Linking Sign Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking_sign-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking_sign-dark.png')
  }}
/>

## Platform preparations

In order for Dapps to be able to trigger your wallet for a connection or sign request using deep links you first need to add your own wallet to the Explorer by login to your [WalletConnect Cloud](https://cloud.walletconnect.com/sign-in) account, declare a deep link and define an [`<intent-filter>`](https://developer.android.com/training/app-links/deep-linking#adding-filters) in your wallet's Manifest.xml with the same deep link added in Explorer:

```xml
<intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="examplewallet" /> <!-- your own custom scheme -->
</intent-filter>
```

:::tip

Dapps developers must do the same for their own custom schemes if they want the wallet to be able to navigate back after a session approval or a sign request response

:::

<HowToTest/>

## Integration

#### Wallet Support

**Disclaimer:** The below solution is designed for the communication between native Android Dapps and native Android wallets. In the case of mobile browser Dapps and native Android wallets communication, we recommend moving wallets into the background after both approving and rejecting sessions or approving and rejecting requests to persist smooth deep-link UX.

In order to add support for mobile linking within your wallet and receive session proposals, register following deep link in your mobile wallet using intent filters in your Activity/Fragment or deepLink tag in your navigation graph.

To support universal native modal and WalletConnectModal register: `wc://`

Deep link example: `examplewallet://wc?uri={pairingUri}`

To receive signing request in your Wallet, you'll need to initialize Kotlin SDK with the `Redirect` object where you pass a deep link that redirects to your wallet when it comes to receiving signing request from Dapp.

```kotlin
val redirect = "examplewallet://request" //should be unique for your wallet

val appMetaData = Core.Model.AppMetaData(
    name = "Wallet Name",
    description = "Wallet Description",
    url = "Wallet Url",
    icons = listOfIconUrlStrings,
    redirect = redirect
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = application, metaData = appMetaData)

val init = Wallet.Params.Init(coreClient = CoreClient)
Web3Wallet.initialize(init)
```

Redirect when responding to a session proposal:

```kotlin
 Web3Wallet.approveSession(approveProposal,
        onSuccess = {
            // trigger deeplink: proposal.redirect
    }
)
```

Redirect when responding to a request:

```kotlin
val redirect = Web3Wallet.getActiveSessionByTopic(sessionRequest.topic)?.redirect?.toUri()
Web3Wallet.respondSessionRequest(response,
        onSuccess = {
        // trigger deeplink: redirect
    }
)
```

**Heads-up:** To make this flow working well, Wallet must register one of its Android components with the same deep link that it initialized with.

To check the flow implementation described above have a look on our sample wallet:
https://github.com/WalletConnect/WalletConnectKotlinV2/tree/master/sample/wallet

#### Dapp Support

To send session proposals to mobile wallet user the pairing URI as deep link that triggers a wallet to open and consume pairing URI

```kotlin
requireActivity().startActivity(Intent(Intent.ACTION_VIEW, deeplinkPairingUri.toUri()))
```

In order to add support for mobile linking within your Dapp and receive signing request responses from wallet, you'll need to initialize Kotlin SDK with the `Redirect` object where you pass a deep link that redirects to your Dapp when it comes to receiving signing request responses from wallet.

```kotlin
val redirect = "kotlin-dapp-wc://request" //should be unique for your Dapp

val appMetaData = Core.Model.AppMetaData(
    name = "Dapp Name",
    description = "Dapp Description",
    url = "Dapp URL",
    icons = listOfIconUrlStrings,
    redirect = redirect
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = application, metaData = appMetaData)

val init = Sign.Params.Init(core = CoreClient)
SignClient.initialize(init)
```

**Heads-up:** To make this flow working well, Dapp must register one of its Android components with the same deep link that it initialized with.

To check the flow implementation described above have a look on our Sample Dapp:
https://github.com/WalletConnect/WalletConnectKotlinV2/tree/master/sample/dapp

#### References

- https://developer.android.com/guide/navigation/navigation-deep-link#implicit
- https://developer.android.com/training/app-links#deep-links
</file>

<file path="docs/walletkit/android/one-click-auth.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import Button from '../../components/button'

# One-click Auth

## Introduction

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a [Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361) (SIWE) message, enhanced by [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities).

This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/authenticatedSessions-light.png'),
    dark: useBaseUrl('/img/w3w/authenticatedSessions-dark.png')
  }}
/>

## Handling Authentication Requests

To handle incoming authentication requests, set up Web3Wallet.WalletDelegate. The onSessionAuthenticate callback will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```kotlin
override val onSessionAuthenticate: ((Wallet.Model.SessionAuthenticate, Wallet.Model.VerifyContext) -> Unit)
  get() = { sessionAuthenticate, verifyContext ->
      // Triggered when wallet receives the session authenticate sent by a Dapp
      // Process the authentication request here
      // This involves displaying UI to the user
}
```

## Authentication Objects/Payloads

#### Responding to Authentication Requests

To interact with authentication requests, build authentication objects (Wallet.Model.Cacao). It involves the following steps:

- **Creating an Authentication Payload Params** - Generate an authentication payload params that matches your application's supported chains and methods.
- **Formatting Authentication Messages** - Format the authentication message using the payload and the user's account.
- **Signing the Authentication Message** - Sign the formatted message to create a verifiable authentication object.

Example:

```kotlin
ooverride val onSessionAuthenticate: ((Wallet.Model.SessionAuthenticate, Wallet.Model.VerifyContext) -> Unit)
  get() = { sessionAuthenticate, verifyContext ->
  val auths = mutableListOf<Wallet.Model.Cacao>()

  val authPayloadParams =
    Web3Wallet.generateAuthPayloadParams(
      sessionAuthenticate.payloadParams,
      supportedChains = listOf("eip155:1", "eip155:137", "eip155:56"), // Note: Only EVM chains are supported
      supportedMethods = listOf("personal_sign", "eth_signTypedData", "eth_sign")
  )

  authPayloadParams.chains.forEach { chain ->
    val issuer = "did:pkh:$chain:$address"
    val formattedMessage = Web3Wallet.formatAuthMessage(Wallet.Params.FormatAuthMessage(authPayloadParams, issuer))

    val signature = signMessage(message: formattedMessage, privateKey: privateKey) //Note: Assume `signMessage` is a function you've implemented to sign messages.
    val auth = Web3Wallet.generateAuthObject(authPayloadParams, issuer, signature)
    auths.add(auth)
  }
}
```

## Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

:::

To approve an authentication request, construct Wallet.Model.Cacao instances for each supported chain, sign the authentication messages, generate AuthObjects and call approveSessionAuthenticate with the request ID and the authentication objects.

```kotlin
 val approveAuthenticate = Wallet.Params.ApproveSessionAuthenticate(id = sessionAuthenticate.id, auths = auths)
Web3Wallet.approveSessionAuthenticate(approveProposal,
  onSuccess = {
    //Redirect back to the dapp if redirect is set: sessionAuthenticate.participant.metadata?.redirect
  },
  onError = { error ->
      //Handle error
  }
)
```

## Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSessionAuthenticate method.

```kotlin
val rejectParams = Wallet.Params.rejectSessionAuthenticate(
    id = sessionAuthenticate.id,
    reason = "Reason"
)

Web3Wallet.rejectSessionAuthenticate(rejectParams,
  onSuccess = {
        //Success
  },
  onError = { error ->
      //Handle error
  }
)
```

## Testing One-click Auth

You can use [AppKit Lab](https://lab.web3modal.com/library/ethers-siwe/) to test and verify that your wallet supports One-click Auth properly.

<Button name="Test One-click Auth" url="https://lab.web3modal.com/library/ethers-siwe/" />
</file>

<file path="docs/walletkit/android/resources.mdx">
# Resources

Valuable assets for developers and users interested in integrating WalletKit into their applications.

- [Awesome WalletConnect](https://github.com/WalletConnect/awesome-walletconnect) - Community-curated collection of WalletConnect-enabled wallets, libraries, and tools.
- [AppKit Laboratory](https://lab.web3modal.com) - A place to test your wallet integrations against various setups of AppKit.
- [WalletKit GitHub](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet) - WalletKit GitHub repository.

### Wallet Resources

To check more in details go and visit our [WalletKit Kotlin implementation app](https://github.com/WalletConnect/WalletConnectKotlinV2/tree/develop/sample/wallet). Sample Wallet and Dapp .apk files can be found under the latest release tag in [Kotlin's V2 repository](https://github.com/WalletConnect/WalletConnectKotlinV2/tags)

If you need to test your app's integration, you can use one of our following demo dapps.

**Sign**

- [React dApp (with standalone client) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2) ([Demo](https://react-app.walletconnect.com/))
- [React dApp (with EthereumProvider + Ethers.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-ethers) ([Demo](https://react-dapp-v2-with-ethers.vercel.app/))
- [React dApp (with EthereumProvider + web3.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-web3js) ([Demo](https://react-dapp-v2-with-web3js.vercel.app/))
- [React dApp (with CosmosProvider) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-cosmos-provider) ([Demo](https://react-dapp-v2-cosmos-provider.vercel.app/))

### Dapp Resources

Sample Wallet and Dapp .apk files can be found under the latest release tag in [Kotlin's V2 repository](https://github.com/WalletConnect/WalletConnectKotlinV2/tags)

**Sign**

- [React dApp (with standalone client) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2) ([Demo](https://react-app.walletconnect.com/))
- [React dApp (with EthereumProvider + Ethers.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-ethers) ([Demo](https://react-dapp-v2-with-ethers.vercel.app/))
- [React dApp (with EthereumProvider + web3.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-web3js) ([Demo](https://react-dapp-v2-with-web3js.vercel.app/))
- [React dApp (with CosmosProvider) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-cosmos-provider) ([Demo](https://react-dapp-v2-cosmos-provider.vercel.app/))

**Auth**

- [React dApp (with auth client)](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-auth) ([Demo](https://react-auth-dapp.vercel.app/))
</file>

<file path="docs/walletkit/android/usage.mdx">
import CloudBanner from '../../components/CloudBanner'

# Usage

This section provides instructions on how to initialize the WalletKit client, approve sessions with supported namespaces, and respond to session requests, enabling easy integration of Web3 wallets with dapps through a simple and intuitive interface.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out **Extra (Platform Specific)** under this section.

**[Initialization](#initialization)**: Creating a new WalletKit instance and initializing it with a projectId from [Cloud](https://cloud.walletconnect.com).

**Session**: Connection between a dapp and a wallet.

- [Namespace Builder](#namespace-builder):
  Namespace Builder is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns a ready-to-use object
- [Session Approval](#session-approval):
  Approving a session sent from a dapp
- [Session Rejection](#session-rejection):
  Rejecting a session sent from a dapp
- [Responding to Session Requests](#responding-to-session-requests):
  Responding to session requests sent from a dapp
- [Updating a Session](#updating-a-session):
  Updating a session sent between a dapp and wallet
- [Extending a Session](#extending-a-session):
  Extending a session between a dapp and wallet
- [Session Disconnect](#session-disconnect):
  Disconnecting a session between a dapp and wallet
- [Register Device Token](#register-device-token)
  Enabling Wallet Push Notifications by registering a device token.
- [Web3Wallet.WalletDelegate](#web3walletwalletdelegate)
  Setting and overriding functions through WalletKit delegate. Also includes instructions about VerifyContext.
- [Format Message](#format-message)
  Receiving formatted SIWE message

To check the full list of platform specific instructions for your preferred platform, go to [Extra (Platform Specific)](#extra-platform-specific) and select your platform.

<CloudBanner />

## Initialization

```kotlin
val projectId = "" // Get Project ID at https://cloud.walletconnect.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val telemetryEnabled: Boolean = true
val appMetaData = Core.Model.AppMetaData(
    name = "Wallet Name",
    description = "Wallet Description",
    url = "Wallet URL",
    icons = /*list of icon url strings*/,
    redirect = "kotlin-wallet-wc:/request" // Custom Redirect URI
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData, telemetryEnabled = telemetryEnabled)

val initParams = Wallet.Params.Init(core = CoreClient)

Web3Wallet.initialize(initParams) { error ->
    // Error will be thrown if there's an issue during initialization
}
```

The WalletKit client will always be responsible for exposing accounts (CAIP10 compatible) to a Dapp and therefore is also in charge of signing.
To initialize the WalletKit client, create a `Wallet.Params.Init` object in the Android Application class with the Core Client. The `Wallet.Params.Init` object will then be passed to the `Web3Wallet`initialize function.

The telemetry feature aims to improve the reliability and observability of connection flows between decentralized applications (dapps) and wallets.
It focuses solely on collecting data about code execution and error codes, without tracking any sensitive user information like amounts, accounts etc.

It provides a comprehensive tracing system for three key use cases:

- Subscribing to a Pairing Topic
- Approving a Session
- Approving an Authenticated Session

Each execution trace consists of:

- Trace Events: Collected to verify the proper execution of code.
- Error Events: Captured when errors occur during the trace, halting the execution trace.

When an error event is encountered, it is stored locally within the SDK along with all preceding trace events.
These stored events are then transmitted to the server whenever the SDK is initialized.

Error event tracing is enabled by default.

Telemetry Enabled (telemetryEnabled = true):

- The SDK stores events and sends them to the server.

Telemetry Disabled (telemetryEnabled = false):

- The SDK stops storing new events and deletes all unsent events from local storage upon the next initialization.

Important Note: Since the SDK only stores abstract trace and error data, user identification is not possible.

Example of the error events:

```json
[
  {
    "eventId": "69e53f11-fd4b-4efc-8d36-1f60a9ac8207",
    "bundleId": "com.wallet.example",
    "timestamp": 1689611327943,
    "props": {
      "event": "ERROR",
      "type": "pairing_already_exists",
      "properties": {
        "topic": "topic1",
        "trace": [
          "pairing_started",
          "pairing_uri_validation_success",
          "pairing_uri_not_expired",
          "existing_pairing",
          "pairing_not_expired",
          "pairing_not_expired"
        ]
      }
    }
  },
  {
    "eventId": "69e53f11-fd4b-4efc-8d36-2321312fds",
    "bundleId": "com.wallet.example",
    "timestamp": 16896113234323,
    "props": {
      "event": "ERROR",
      "type": "session_approve_namespace_validation_failure",
      "properties": {
        "topic": "topic2",
        "trace": ["session_approve_started", "proposal_not_expired"]
      }
    }
  }
]
```

## Session

A session is a connection between a dapp and a wallet. It is established when a user approves a session proposal from a dapp. A session is active until the user disconnects from the dapp or the session expires.

### Namespace Builder

With WalletKit 1.7.0 we've published a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your wallet's chains, methods, events, and accounts (supported namespaces) and returns ready-to-use namespaces object that has to be passed into `Wallet.Params.SessionApprove` when approving a session.

```kotlin
val supportedNamespaces: Wallet.Model.Namespaces.Session = /* a map of all supported namespaces created by a wallet */
val sessionProposal: Wallet.Model.SessionProposal =  /* an object received by `fun onSessionProposal(sessionProposal: Wallet.Model.SessionProposal)` in `Web3Wallet.WalletDelegate` */
val sessionNamespaces = Web3Wallet.generateApprovedNamespaces(sessionProposal, supportedNamespaces)

val approveParams: Wallet.Params.SessionApprove = Wallet.Params.SessionApprove(proposerPublicKey, sessionNamespaces)
Web3Wallet.approveSession(approveParams) { error -> /*callback for error while approving a session*/ }
```

Examples of supported namespaces:

```kotlin
 val supportedNamespaces = mapOf(
    "eip155" to Wallet.Model.Namespace.Session(
        chains = listOf("eip155:1", "eip155:137", "eip155:3"),
        methods = listOf("personal_sign", "eth_sendTransaction", "eth_signTransaction"),
        events = listOf("chainChanged"),
        accounts = listOf("eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092", "eip155:137:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092", "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092")
    )
)

 val anotherSupportedNamespaces = mapOf(
    "eip155" to Wallet.Model.Namespace.Session(
        chains = listOf("eip155:1", "eip155:2", "eip155:4"),
        methods = listOf("personal_sign", "eth_sendTransaction", "eth_signTransaction"),
        events = listOf("chainChanged", "accountsChanged"),
        accounts = listOf("eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092", "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092", "eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092")
    ),
    "cosmos" to Wallet.Model.Namespace.Session(
        chains = listOf("cosmos:cosmoshub-4"),
        methods = listOf("cosmos_method"),
        events = listOf("cosmos_event"),
        accounts = listOf("cosmos:cosmoshub-4:cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02")
    )
)

```

### EVM methods & events

In @walletconnect/ethereum-provider, (our abstracted EVM SDK for apps) we support by default the following Ethereum methods and events:

```ts
{
  //...
  methods: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_getCapabilities",
  ],
  events: [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect",
  ]
}
```

### Session Approval

:::info Note

Addresses provided in `accounts` array should follow [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)
semantics.

:::

```kotlin
val proposerPublicKey: String = /*Proposer publicKey from SessionProposal object*/
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val accounts: List<String> = /*List of accounts on chains*/
val methods: List<String> = /*List of methods that wallet approves*/
val events: List<String> = /*List of events that wallet approves*/
val namespaces: Map<String, Wallet.Model.Namespaces.Session> = mapOf(namespace, Wallet.Model.Namespaces.Session(accounts, methods, events))

val approveParams: Wallet.Params.SessionApprove = Wallet.Params.SessionApprove(proposerPublicKey, namespaces)
Web3Wallet.approveSession(approveParams) { error -> /*callback for error while approving a session*/ }
```

To send an approval, pass a Proposer's Public Key along with the map of namespaces to the `Web3Wallet.approveSession` function.

### Session Rejection

```kotlin
val proposerPublicKey: String = /*Proposer publicKey from SessionProposal object*/
val rejectionReason: String = /*The reason for rejecting the Session Proposal*/
val rejectionCode: String = /*The code for rejecting the Session Proposal*/
For reference use CAIP-25: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md

val rejectParams: Wallet.Params.SessionReject = SessionReject(proposerPublicKey, rejectionReason, rejectionCode)
Web3Wallet.rejectSession(rejectParams) { error -> /*callback for error while rejecting a session*/ }
```

To send a rejection for the Session Proposal, pass a proposerPublicKey, rejection reason and rejection code to
the `Web3Wallet.rejectSession` function.

### Responding to Session requests

```kotlin
val sessionTopic: String = /*Topic of Session*/
val jsonRpcResponse: Wallet.Model.JsonRpcResponse.JsonRpcResult = /*Active Session Request ID along with request data*/
val result = Wallet.Params.SessionRequestResponse(sessionTopic = sessionTopic, jsonRpcResponse = jsonRpcResponse)

Web3Wallet.respondSessionRequest(result) { error -> /*callback for error while responding session request*/ }
```

To respond to JSON-RPC method that were sent from Dapps for a session, submit a `Wallet.Params.SessionRequestResponse` with the session's topic and request
ID along with the respond data to the `Web3Wallet.respondSessionRequest` function.

### Updating a Session

NOTE: addresses provided in `accounts` array should follow [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)
semantics.

```kotlin
val sessionTopic: String = /*Topic of Session*/
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val accounts: List<String> = /*List of accounts on chains*/
val methods: List<String> = /*List of methods that wallet approves*/
val events: List<String> = /*List of events that wallet approves*/
val namespaces: Map<String, Wallet.Model.Namespaces.Session> = mapOf(namespace, Wallet.Model.Namespaces.Session(accounts, methods, events))
val updateParams = Wallet.Params.SessionUpdate(sessionTopic, namespaces)

Web3Wallet.updateSession(updateParams) { error -> /*callback for error while sending session update*/ }
```

To update a session with namespaces, submit a `Wallet.Params.SessionUpdate` object with the session's topic and namespaces to update session with
to `Web3Wallet.updateSession`.

### Extending a Session

```kotlin
val sessionTopic: String = /*Topic of Session*/
val extendParams = Wallet.Params.SessionExtend(sessionTopic = sessionTopic)

Web3Wallet.extendSession(extendParams) { error -> /*callback for error while extending a session*/ }
```

To extend a session, create a `Wallet.Params.SessionExtend` object with the session's topic to update the session with to `Web3Wallet.extendSession`. Session is
extended by 7 days.

### Emitting a Session

To emit an event, call emitSessionEvent() as follows:

```kotlin
val sessionTopic: String = /*Topic of Session*/
val event: Wallet.Model.SessiomEvent = SessionEvent(name = "accountsChanged", data = "0x000000000")

val sessionEmit = Wallet.Params.SessionEmit(topic = sessionTopic, chainId = "eip155:1", event = event)

Web3Wallet.emitSessionEvent(sessionEmit) { error -> /*callback for error while emiting an event*/ }
```

### Session Disconnect

```kotlin
val disconnectionReason: String = /*The reason for disconnecting the Session*/
val disconnectionCode: String = /*The code for disconnecting the Session*/
val sessionTopic: String = /*Topic from the Session*/
For reference use CAIP-25: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md
val disconnectParams = Wallet.Params.SessionDisconnect(sessionTopic, disconnectionReason, disconnectionCode)

Web3Wallet.disconnectSession(disconnectParams) { error -> /*callback for error while disconnecting a session*/ }
```

To disconnect from un active session, pass a disconnection reason with code and the Session topic to the `Web3Wallet.disconnectSession`
function.

## Extra (Platform Specific)

#### Web3Wallet.WalletDelegate

```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
    override fun onSessionProposal(sessionProposal: Wallet.Model.SessionProposal, verifyContext: Wallet.Model.VerifyContext) {
        // Triggered when wallet receives the session proposal sent by a Dapp
    }

    fun onSessionAuthenticate(sessionAuthenticate: Wallet.Model.SessionAuthenticate, verifyContext: Wallet.Model.VerifyContext) {
      // Triggered when wallet receives the session authenticate sent by a Dapp
    }

    override fun onSessionRequest(sessionRequest: Wallet.Model.SessionRequest, verifyContext: Wallet.Model.VerifyContext) {
        // Triggered when a Dapp sends SessionRequest to sign a transaction or a message
    }

    override fun onAuthRequest(authRequest: Wallet.Model.AuthRequest, verifyContext: Wallet.Model.VerifyContext) {
        // Triggered when Dapp / Requester makes an authorization request
    }

    override fun onSessionDelete(sessionDelete: Wallet.Model.SessionDelete) {
        // Triggered when the session is deleted by the peer
    }

    override fun onSessionSettleResponse(settleSessionResponse: Wallet.Model.SettledSessionResponse) {
        // Triggered when wallet receives the session settlement response from Dapp
    }

    override fun onSessionUpdateResponse(sessionUpdateResponse: Wallet.Model.SessionUpdateResponse) {
        // Triggered when wallet receives the session update response from Dapp
    }

    override fun onConnectionStateChange(state: Wallet.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Wallet.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}
Web3Wallet.setWalletDelegate(walletDelegate)
```

`Wallet.Event.VerifyContext` provides a domain verification information about SessionProposal, SessionRequest and AuthRequest. It consists of origin of a Dapp from where the request has been sent, validation Enum that says whether origin is VALID, INVALID or UNKNOWN and verify url server.

```kotlin
data class VerifyContext(
    val id: Long,
    val origin: String,
    val validation: Model.Validation,
    val verifyUrl: String
)

enum class Validation {
    VALID, INVALID, UNKNOWN
}
```

The Web3Wallet needs a `Web3Wallet.WalletDelegate` passed to it for it to be able to expose asynchronous updates sent from the Dapp.

#

#### Format message

To receive formatted SIWE message, call formatMessage method with following parameters:

```kotlin
val payloadParams: Wallet.Params.PayloadParams = //PayloadParams received in the onAuthRequest callback
val issuer = //MUST be the same as send with the respond methods and follows: https://github.com/w3c-ccg/did-pkh/blob/main/did-pkh-method-draft.md
val formatMessage = Wallet.Params.FormatMessage(event.payloadParams, issuer)

Web3Wallet.formatMessage(formatMessage)
```

#### Register Device Token

This method enables wallets to receive push notifications from WalletConnect's Push Server via [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging). This means you will have to setup your project with Firebase before being able to call registerDeviceToken method.

Make sure that a service extending the FirebaseMessagingService is added to your manifest as per the [Firebase FCM documentation](https://firebase.google.com/docs/cloud-messaging/android/client#manifest) as well as any other setup Firebase requires [Firebase setup documentation](https://firebase.google.com/docs/android/setup).

To register a wallet to receive WalletConnect push notifications, call `Web3Wallet.registerDeviceToken` and pass the Firebase Access Token.

```kotlin
val firebaseAccessToken: String = //FCM access token received through the Firebase Messaging SDK

Web3Wallet.registerDeviceToken(
    firebaseAccessToken,
    onSuccess = {
        // callback triggered once registered successfully with the Push Server
    },
    onError = { error: Wallet.Model.Error ->
        // callback triggered if there's an exception thrown during the registration process
    })
```
</file>

<file path="docs/walletkit/android/verify.mdx">
# Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.
Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).
For those looking to enable Verify on the app side, check out our reference guide [here.](./cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

These are:

![Verify Banner](/img/verify-banner.png)

## Disclaimer

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

## Domain risk detection

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either `VALID`, `INVALID` or `UNKNOWN`.

- Domain match: The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `VALID`.
- Unverified: The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `UNKNOWN`.
- Mismatch: The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `INVALID`
- Threat: This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The `verifyContext` included in the request will contain parameter `isScam` with value `true`.

### Implementation

Wallet.Event.VerifyContext provides a domain verification information about SessionProposal, SessionRequest and AuthRequest.

It consists of origin of an app from where the request has been sent, validation Enum that says whether origin is `VALID`, `INVALID` or `UNKNOWN` and verify url server.

```kotlin
data class VerifyContext(
    val id: Long,
    val origin: String,
    val validation: Model.Validation,
    val verifyUrl: String
)

enum class Validation {
    VALID, INVALID, UNKNOWN
}
```
</file>

<file path="docs/walletkit/c-sharp/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/walletkit/c-sharp/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import ExplorerSubmission from '../../../cloud/explorer-submission.mdx'

<ExplorerSubmission />
</file>

<file path="docs/walletkit/c-sharp/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/walletkit/c-sharp/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/walletkit/c-sharp/installation.mdx">
# Installation

Install the WalletConnect client package via Nuget.

```bash
dotnet add package WalletConnect.Web3Wallet
```

## Next Steps

Now that you've installed Web3Wallet SDK, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the SDK.
</file>

<file path="docs/walletkit/c-sharp/usage.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Usage

This section provides instructions on how to initialize the Web3Wallet client, approve sessions with supported namespaces, and respond to session requests, enabling easy integration of Web3 wallets with dapps through a simple and intuitive interface.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out **Extra (Platform Specific)** under this section.

**[Initialization](#initialization)**: Creating a new Web3Wallet instance and initializing it with a projectId from [Cloud](https://cloud.walletconnect.com).

**Session**: Connection between a dapp and a wallet.

- [Namespace Builder](#namespace-builder):
  Namespace Builder is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns a ready-to-use object
- [Session Approval](#session-approval):
  Approving a session sent from a dapp
- [Session Rejection](#session-rejection):
  Rejecting a session sent from a dapp
- [Responding to Session Requests](#responding-to-session-requests):
  Responding to session requests sent from a dapp
- [Updating a Session](#updating-a-session):
  Updating a session sent between a dapp and wallet
- [Extending a Session](#extending-a-session):
  Extending a session between a dapp and wallet
- [Session Disconnect](#session-disconnect):
  Disconnecting a session between a dapp and wallet

<CloudBanner />

## Initialization

First you must setup a `WalletConnectCore` instance with a specific `Name` and `ProjectId`. You may optionally specify other `CoreOption`
values, such as `RelayUrl` and `Storage`

```csharp
var options = new CoreOptions()
{
    ProjectId = "...",
    Name = "my-app",
}

var core = new WalletConnectCore(options);
```

Next, you must define a `Metadata` object which describes your Wallet. This includes a `Name`, `Description`, `Url` and `Icons` url.

```csharp
var metadata = new Metadata()
{
    Description = "An example wallet to showcase WalletConnectSharpv2",
    Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
    Name = $"wallet-csharp-test",
    Url = "https://walletconnect.com",
};
```

Once you have both the `WalletConnectCore` and `Metadata` objects, you can initialize the `Web3WalletClient`

```csharp
var sdk = await Web3WalletClient.Init(core, metadata, metadata.Name);
```

## Session

A session is a connection between a dapp and a wallet. It is established when a user approves a session proposal from a dapp. A session is active until the user disconnects from the dapp or the session expires.

### Namespace Builder

To build a namespace mapping for either proposing a session **OR** approving a session, you can use C# dictionary + class constructors
directly, or use the built-in builder methods

### C# Constructor Style

```csharp
var TestNamespaces = new Namespaces()
{
    {
        "eip155", new Namespace()
            {
                Accounts = new [] { "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb" },
                Chains = new []{ "eip155:1" },
                Methods = new[] { "eth_signTransaction" },
                Events = new[] { "chainChanged" }
            }
    },
};
```

### Builder Style

```csharp
var TestNamespaces = new Namespaces()
  .WithNamespace("eip155", new Namespace()
      .WithChain("eip155:1")
      .WithMethod("eth_signTransaction")
      .WithEvent("chainChanged")
      .WithAccount("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")
  );
```

The `Namespaces` mapping is required when approving a proposed session from a dApp. Because of this, you may
also construct a `Namespaces` from a `RequiredNamespaces`, which auto-populates all `Methods`, `Events` and
`Chains` from the given `RequiredNamespaces`. This is provided for convenience.

### RequiredNamespaces

```csharp
sdk.SessionProposed += async (sender, @event) =>
{
    var proposal = @event.Proposal;
    var requiredNamespaces = proposal.RequiredNamespaces;
    var approvedNamespaces = new Namespaces(requiredNamespaces);
    approvedNamespaces["eip155"].WithAccount("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb");
});
```

The `RequiredNamespaces` is required when setting up a session between a dApp and Wallet. The
dApp will provide a `RequiredNamespaces` when proposing the session. The `RequiredNamespaces` and
`ProposedNamespace` use the same style constructors + builder functions as `Namespaces` and `Namespace`.

### EVM methods & events

In @walletconnect/ethereum-provider, (our abstracted EVM SDK for apps) we support by default the following Ethereum methods and events:

```ts
{
  //...
  methods: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_getCapabilities",
  ],
  events: [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect",
  ]
}
```

### Session Approval

Wallets can pair an incoming session using the session's Uri. Pairing a session lets the Wallet obtain the connection proposal which can then be approved or denied.

```csharp
var uri = "...";
ProposalStruct proposal = await sdk.Pair(uri);
```

The wallet can then approve the proposal by constructing an approved `Namespaces`. The approved
`Namespaces` should include the `RequiredNamespaces` under `proposal.RequiredNamespaces`, and may optionally include any optional namespaces
specified under `proposal.OptionalNamespaces`

```csharp
sdk.SessionProposed += async (sender, @event) =>
{
    var proposal = @event.Proposal;
    var requiredNamespaces = proposal.RequiredNamespaces;
    var approvedNamespaces = new Namespaces(requiredNamespaces);
    approvedNamespaces["eip155"].WithAccount("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb");

    var sessionData = await sdk.ApproveSession(proposal.Id, approvedNamespaces);
    var sessionTopic = sessionData.Topic;
});
```

You may also just provide the addresses that will connect, and the SDK will create this approved
`Namespaces` for you. This function **will not approve optional namespaces**

```csharp
sdk.SessionProposed += async (sender, @event) =>
{
    var proposal = @event.Proposal;

    var sessionData = await sdk.ApproveSession(proposal, new[] { "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb" });
    var sessionTopic = sessionData.Topic;
});
```

or

```csharp
sdk.SessionProposed += async (sender, @event) =>
{
    var proposal = @event.Proposal;

    var sessionData = await sdk.ApproveSession(proposal, "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb");
    var sessionTopic = sessionData.Topic;
});
```

### Session Rejection

The wallet can reject the proposal using the following:

```csharp
sdk.SessionProposed += async (sender, @event) =>
{
    var proposal = @event.Proposal;
    await sdk.Reject(proposal, "User rejected");
});
```

### Responding to Session requests

Responding to session requests is very similar to sending session requests. See dApp usage on how sending session requests works. All custom session requests requires a request class **and** response class to be created that matches the `params` field type in the custom session request. C# is a static typed language, so these types must be given whenever you do a session request (or do any querying for session requests).

Currently, **WalletConnectSharp does not automatically assume the object type for `params` is an array**. This is very important, since most EVM RPC requests have `params` as an array type. **Use `List<T>` to workaround this**. For example, for `eth_sendTransaction`, use `List<Transaction>` instead of `Transaction`.

Newtonsoft.Json is used for JSON serialization/deserialization, therefore you can use Newtonsoft.Json attributes when defining fields in your request/response classes.

### Building a Response type

Create a class for the response and populate it with the JSON properties the response object has. For this example, we will use `eth_getTransactionReceipt`

The `params` field for `eth_getTransactionReceipt` has the object type

```csharp
using Newtonsoft.Json;
using System.Numerics;

[RpcMethod("eth_getTransactionReceipt"), RpcRequestOptions(Clock.ONE_MINUTE, 99995)]
public class TransactionReceipt
{
    [JsonProperty("transactionHash")]
    public string TransactionHash;

    [JsonProperty("transactionIndex")]
    public BigInteger TransactionIndex;

    [JsonProperty("blockHash")]
    public string BlockHash;

    [JsonProperty("blockNumber")]
    public BigInteger BlockNumber;

    [JsonProperty("from")]
    public string From;

    [JsonProperty("to")]
    public string To;

    [JsonProperty("cumulativeGasUsed")]
    public BigInteger CumulativeGasUsed;

    [JsonProperty("effectiveGasPrice ")]
    public BigInteger EffectiveGasPrice ;

    [JsonProperty("gasUsed")]
    public BigInteger GasUsed;

    [JsonProperty("contractAddress")]
    public string ContractAddress;

    [JsonProperty("logs")]
    public object[] Logs;

    [JsonProperty("logsBloom")]
    public string LogBloom;

    [JsonProperty("type")]
    public BigInteger Type;

    [JsonProperty("status")]
    public BigInteger Status;
}
```

The `RpcMethod` class attributes defines the rpc method this response uses, this is optional. The `RpcResponseOptions` class attributes define the expiry time and tag attached to the response, **this is required**.

### Sending a response

To respond to requests from a dApp, you must define the class representing the request object type. The request type for `eth_getTransactionReceipt` is the following:

```csharp
[RpcMethod("eth_getTransactionReceipt"), RpcRequestOptions(Clock.ONE_MINUTE, 99994)]
public class EthGetTransactionReceipt : List<string>
{
    public EthGetTransactionReceipt(params string[] hashes) : base(hashes)
    {
    }

    // needed for proper json deserialization
    public EthGetTransactionReceipt()
    {
    }
}
```

We can handle the `eth_getTransactionReceipt` session request by doing the following:

```csharp
walletClient.Engine.SessionRequestEvents<EthGetTransactionReceipt, TransactionReceipt>().OnRequest += OnEthTransactionReceiptRequest;

private Task OnEthTransactionReceiptRequest(RequestEventArgs<EthGetTransactionReceipt, TransactionReceipt> e)
{
    // logic for request goes here
    // set e.Response to return a response
}
```

The callback function gets invoked whenever the wallet receives the `eth_getTransactionReceipt` request from a connected dApp. You may optionally filter further which requests are handled using the `FilterRequests` function

```csharp
walletClient.Engine.SessionRequestEvents<EthGetTransactionReceipt, TransactionReceipt>()
    .FilterRequests(r => r.Topic == sessionTopic)
    .OnRequest += OnEthTransactionReceiptRequest;
```

The callback returns a `Task`, so the callback can be made async. To return a response, **you must** set the `Response` field in `RequestEventArgs<T, TR>` with the desired response.

```csharp
private async Task OnEthTransactionReceiptRequest(RequestEventArgs<EthGetTransactionReceipt, TransactionReceipt> e)
{
    var txHash = e.Request.Params[0];
    var receipt = await EthGetTransactionReceipt(txHash);
    e.Response = receipt;
}
```

### Updating a Session

Update a session, adding/removing additional namespaces in the given topic.

```csharp
var newNamespaces = new Namespaces(...);
var request = await walletClient.UpdateSession(sessionTopic, newNamespaces);
await request.Acknowledged();
```

### Extending a Session

Extend a session's expiry time so the session remains open

```csharp
var request = await walletClient.Extend(sessionTopic);
await request.Acknowledged();
```

### Session Disconnect

To disconnect a session, use the `Disconnect` function. You may optional provide a reason for the disconnect.

Disconnecting requires the `topic` of the session to be given. This can be found in the `SessionStruct` object given when a session has been given approval by the Wallet.

```csharp
var sessionTopic = sessionData.Topic;
await walletClient.Disconnect(sessionTopic);

// or

await walletClient.Disconnect(sessionTopic, Error.FromErrorType(ErrorType.USER_DISCONNECTED));
```
</file>

<file path="docs/walletkit/c-sharp/verify.mdx">
import Container from '../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'

# Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.
Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).
For those looking to enable Verify on the app side, check out our reference guide [here.](./cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

These are:

![Verify Banner](/img/verify-banner.png)

## Disclaimer

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

## Domain risk detection

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either `VALID`, `INVALID` or `UNKNOWN`.

- Domain match: The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `VALID`.
- Unverified: The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `UNKNOWN`.
- Mismatch: The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `INVALID`
- Threat: This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The `verifyContext` included in the request will contain parameter `isScam` with value `true`.

### Implementation

`WalletConnectSharp.Core.Models.Verify.VerifiedContext` provides a domain verification information about `SessionProposal`, `SessionRequest` and `AuthRequest`.

It consists of origin of an app from where the request has been sent, validation Enum that says whether origin is `VALID`, `INVALID` or `UNKNOWN` and verify url server.

```csharp
public class VerifiedContext
{
    [JsonProperty("origin")]
    public string Origin;

    [JsonProperty("validation")]
    private string _validation;

    public string ValidationString => _validation;

    public Validation Validation
    {
        get
        {
            return FromString();
        }
        set
        {

            _validation = AsString(value);
        }
    }

    [JsonProperty("verifyUrl")]
    public string VerifyUrl { get; set; }

    private Validation FromString()
    {
        switch (ValidationString.ToLowerInvariant())
        {
            case "VALID":
                return Validation.Valid;
            case "INVALID":
                return Validation.Invalid;
            default:
                return Validation.Unknown;
        }
    }

    private string AsString(Validation str)
    {
        switch (str)
        {
            case Validation.Invalid:
                return "INVALID";
            case Validation.Valid:
                return "VALID";
            default:
                return "UNKNOWN";
        }
    }
}

public enum Validation
{
    Unknown,
    Valid,
    Invalid,
}
```
</file>

<file path="docs/walletkit/features/notifications.mdx">
import Wrapper from '../../components/Home/Wrapper'

import androidLogo from '../../../static/assets/home/androidLogo.png'
import iosLogo from '../../../static/assets/home/iosLogo.png'
import rnLogo from '../../../static/assets/home/rnLogo.png'
import flutterLogo from '../../../static/assets/home/flutterLogo.png'
import csharpLogo from '../../../static/assets/home/csharpLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# Notifications

Enrich your wallet experience with Web3 Notifications and provide your community with direct access to critical and powerful updates from their favorite apps.
Build in-wallet notification features that allow users to subscribe, set permissions, and receive notifications from their favorite apps.

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'Android',
      type: 'android',
      description: 'Get started with WalletKit in Android.',
      icon: androidLogo,
      href: '../android/notifications/notify/overview'
    },
    {
      name: 'iOS',
      type: 'ios',
      description: 'Get started with WalletKit in iOS.',
      icon: iosLogo,
      href: '../ios/notifications/notify/overview',
      isWhite: true
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with WalletKit in React Native.',
      icon: rnLogo,
      href: '../react-native/notifications/notify/overview'
    }
  ]}
/>
</file>

<file path="docs/walletkit/features/one-click-auth.mdx">
import Wrapper from '../../components/Home/Wrapper'

import androidLogo from '../../../static/assets/home/androidLogo.png'
import iosLogo from '../../../static/assets/home/iosLogo.png'
import rnLogo from '../../../static/assets/home/rnLogo.png'
import flutterLogo from '../../../static/assets/home/flutterLogo.png'
import csharpLogo from '../../../static/assets/home/csharpLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# One-Click Auth

Enable your users to connect to web3 through a single tap with One-Click Auth, improving connectivity speeds and creating all-around better UX and friction-free user journeys.
With one-tap multi-chain and multi-account signing, let users authenticate multiple chains and accounts simultaneously.

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'Web',
      type: 'javascript',
      description: 'Get started with WalletKit in Web.',
      icon: javascriptLogo,
      href: '../web/one-click-auth'
    },
    {
      name: 'Android',
      type: 'android',
      description: 'Get started with WalletKit in Android.',
      icon: androidLogo,
      href: '../android/one-click-auth'
    },
    {
      name: 'iOS',
      type: 'ios',
      description: 'Get started with WalletKit in iOS.',
      icon: iosLogo,
      href: '../ios/one-click-auth',
      isWhite: true
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with WalletKit in React Native.',
      icon: rnLogo,
      href: '../react-native/one-click-auth'
    },
    {
      name: 'Flutter',
      type: 'flutter',
      description: 'Get started with WalletKit in Flutter.',
      icon: flutterLogo,
      href: '../flutter/one-click-auth'
    }
  ]}
/>
</file>

<file path="docs/walletkit/features/verify.mdx">
import Wrapper from '../../components/Home/Wrapper'

import androidLogo from '../../../static/assets/home/androidLogo.png'
import iosLogo from '../../../static/assets/home/iosLogo.png'
import rnLogo from '../../../static/assets/home/rnLogo.png'
import flutterLogo from '../../../static/assets/home/flutterLogo.png'
import csharpLogo from '../../../static/assets/home/csharpLogo.png'
import javascriptLogo from '../../../static/assets/home/javascriptLogo.png'

# Verify API

App Verification is a first-of-its-kind layered security solution that enables wallets to help users protect themselves from phishing attacks, with robust architecture enabling wallets to support users in better identifying the veracity of a domain they are attempting to connect to.

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'Android',
      type: 'android',
      description: 'Get started with WalletKit in Android.',
      icon: androidLogo,
      href: '../android/verify'
    },
    {
      name: 'iOS',
      type: 'ios',
      description: 'Get started with WalletKit in iOS.',
      icon: iosLogo,
      href: '../ios/verify',
      isWhite: true
    },
    {
      name: 'Flutter',
      type: 'flutter',
      description: 'Get started with WalletKit in Flutter.',
      icon: flutterLogo,
      href: '../flutter/verify'
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with WalletKit in React Native.',
      icon: rnLogo,
      href: '../react-native/verify'
    },
    {
      name: 'Web',
      type: 'javascript',
      description: 'Get started with WalletKit in Web.',
      icon: javascriptLogo,
      href: '../web/verify'
    },
    {
      name: 'C#',
      type: 'c-sharp',
      description: 'Get started with WalletKit in C#.',
      icon: csharpLogo,
      href: '../c-sharp/verify'
    },
  ]}
/>
</file>

<file path="docs/walletkit/flutter/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/walletkit/flutter/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import ExplorerSubmission from '../../../cloud/explorer-submission.mdx'

<ExplorerSubmission />
</file>

<file path="docs/walletkit/flutter/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/walletkit/flutter/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/walletkit/flutter/eip5792.mdx">
# Wallet Call API

WalletConnect supports [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792#atomicbatch-capability), which defines new JSON-RPC methods that enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.
Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.

- `wallet_sendCalls`: Requests that a wallet submits a batch of calls.
- `wallet_getCallsStatus`: Returns the status of a call batch that was sent via wallet_sendCalls.
- `wallet_showCallsStatus`: Requests that a wallet shows information about a given call bundle that was sent with wallet_sendCalls.
- `wallet_getCapabilities`: This RPC allows an application to request capabilities from a wallet (e.g. batch transactions, paymaster communication).
</file>

<file path="docs/walletkit/flutter/installation.mdx">
# Installation

```dart
flutter pub add walletconnect_flutter_v2
```

:::info

Depending on your platform, you will have to add different permissions to get the package to work.

**MacOS**

Add the following to your `DebugProfile.entitlements` and `Release.entitlements` files so that it can connect to the WebSocket server.

```xml
<key>com.apple.security.network.client</key>
<true/>
```

:::

## Next Steps

Now that you've installed Web3Wallet SDK, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the SDK.
</file>

<file path="docs/walletkit/flutter/mobile-linking.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import HowToTest from '../shared/mobile-linking.mdx'

# Mobile Linking

:::info Note

This feature is only relevant to native platforms.

:::

## Usage

Mobile Linking allows your wallet to automatically redirect back to the Dapp allowing for less user interactions and hence a better UX for your users.

### Establishing Communication Between Mobile Wallets and Apps

When integrating a wallet with a mobile application, it's essential to understand how they communicate. The process involves two main steps:

1. **QR Code Handshake:** The mobile app (Dapp) generates a unique URI (Uniform Resource Identifier) and displays it as a QR code. This URI acts like a secret handshake. When the user scans the QR code using their wallet app, they establish a connection. It's like saying, "Hey, let's chat!"
2. **Deep Links and Universal Links:** The URI from the QR code allows the wallet app to create a [deep link](https://support.google.com/google-ads/answer/10023042?hl=en#:~:text=Deep%20links%20send%20mobile%20device,%2C%20Shopping%2C%20and%20Display%20campaigns.) or [universal link](https://developer.apple.com/ios/universal-links/). These links work on both Android and iOS. They enable seamless communication between the wallet and the app.

:::tip

**Developers should prefer Deep Linking over Universal Linking.**

In the case of Universal Linking, the user may be redirected to the browser, which may not be the desired behavior. Deep Linking ensures that the user is redirected to the app, providing a seamless experience.

:::

The connection and sign request flows are similar across platforms.
The next section provides a high-level overview of both flows.

### Connection Flow

- **Dapp Prompts User:** The Dapp asks the user to connect.
- **User Chooses Wallet:** The user selects a wallet from a list of compatible wallets.
- **Redirect to Wallet:** The user is redirected to their chosen wallet.
- **Wallet Approval:** The wallet prompts the user to approve or reject the session (similar to granting permission).
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reunites with Dapp:** After all the interactions, the user ends up back in the Dapp.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking-dark.png')
  }}
/>

### Sign Request Flow

When the Dapp needs the user to sign something (like a transaction), a similar pattern occurs:

- **Automatic Redirect:** The Dapp automatically sends the user to their previously chosen wallet.
- **Approval Prompt:** The wallet asks the user to approve or reject the request.
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reconnects:** Eventually, the user returns to the Dapp.

<ThemedImage
  alt="Mobile Linking Sign Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking_sign-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking_sign-dark.png')
  }}
/>

## Platform preparations

<PlatformTabs groupId="" activeOptions={["ios","android","flutter"]}>
<PlatformTabItem value="ios">

In order for Dapps to be able to trigger your wallet for a connection or sign request using deep links you first need to add your custom scheme under [`CFBundleURLTypes`](https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundleurltypes) key in your Info.plist file.

For instance, if your Wallet's name is Example Wallet, your custom scheme would be more likely as `examplewallet://`, therefor you will add the following in your iOS's Info.plist file:

```ruby
<key>CFBundleURLTypes</key>
<array>
	<dict>
		<key>CFBundleTypeRole</key>
		<string>Editor</string>
		<key>CFBundleURLName</key>
		<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
		<key>CFBundleURLSchemes</key>
		<array>
			<string>examplewallet</string> <!-- your custom scheme goes here -->
		</array>
	</dict>
</array>
```

</PlatformTabItem>
<PlatformTabItem value="android">
In order for Dapps to be able to trigger your wallet for a connection or sign request using deep links you first need to declare an [`<intent-filter>`](https://developer.android.com/training/app-links/deep-linking#adding-filters) in your wallet's Manifest.xml as follows:

For instance, if your Wallet's name is Example Wallet, your custom scheme would be more likely as `examplewallet://`, therefor you will add the following intent filter in your Android's Manifest.xml file:

```xml
<intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="examplewallet" /> <!-- your own custom scheme -->
</intent-filter>
```

</PlatformTabItem>
<PlatformTabItem value="flutter">

Since Flutter leverages on native APIs, you must follow iOS and Android steps for each native platform.

**Additionally**, you would have to set FlutterDeepLinkingEnabled key to true on iOS's Info.plist file.

```xml
<key>FlutterDeepLinkingEnabled</key>
<true/>
```

More information in official documentation: https://docs.flutter.dev/ui/navigation/deep-linking

</PlatformTabItem>
</PlatformTabs>

:::tip

Dapps developers must do the same for their own custom schemes if they want the wallet to be able to navigate back after a session approval or a sign request response

:::

<HowToTest/>

## Integration

Either you are approving a session proposal or responding to a session request, redirecting back to the Dapp is as simply as launching requester's `redirect` object in `PairingMetadata`, the same way as Dapps would call your wallet's `redirect` object on their side:

A dapp would call `examplewallet://wc?uri={pairingUri}` from their side when they request to connect with your wallet, and given the fact that `examplewallet` is your registered custom scheme then your wallet will be opened.

**Redirecting back to dapp (proposer) after session approval:**

```dart
// subscribe to onSessionProposal with a handler
_web3Wallet!.onSessionProposal.subscribe(_onSessionProposal);
//
void _onSessionProposal(SessionProposalEvent? event) async {
  if (event != null) {
    // Process session proposal
    // ....
    // Redirect back to proposer dapp
    final scheme = event.params.proposer.metadata.redirect?.native ?? '';
    launchUrlString(scheme, mode: LaunchMode.externalApplication);
  }
}

// If your wallet supports One-Click Auth
_web3Wallet!.onSessionAuthRequest.subscribe(_onSessionAuthRequest);
//
void _onSessionAuthRequest(SessionAuthRequest? event) async {
  if (event != null) {
    // Process session authentication
    // ....
    // Redirect back to requester dapp
    final scheme = event.requester.metadata.redirect?.native ?? '';
    launchUrlString(scheme, mode: LaunchMode.externalApplication);
  }
}
```

A dapp would call `examplewallet://` (or even better `session.peer?.metadata.redirect?.native` object) from their side when they request to sign a transaction, and given the fact that `session.peer?.metadata.redirect?.native` contains your registered custom scheme (`examplewallet://`) then your wallet will be opened.

**Redirecting back to dapp (proposer) after responding to a sign request:**

```dart
// Your registered request handler for the given requested method will be triggered
Future<void> personalSignRequestHandler(String topic, dynamic parameters) async {
  // Process signing requests
  // ...
  // With the given topic with retrieve the current session data
  final session = web3Wallet.sessions.get(topic);
  // And we get the peer metadata to trigger dapp's redirect value
  final scheme = session?.peer.metadata.redirect?.native ?? '';
  launchUrlString(scheme, mode: LaunchMode.externalApplication);
}
```

:::note

`launchUrlString()` from [url_launcher](https://pub.dev/packages/url_launcher) oficial package was used as an example to explain the mechanism, you can choose whatever other package you would like.

:::
</file>

<file path="docs/walletkit/flutter/one-click-auth.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import Button from '../../components/button'

# One-click Auth

## Introduction

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a [Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361) (SIWE) message, enhanced by [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities).

This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/authenticatedSessions-light.png'),
    dark: useBaseUrl('/img/w3w/authenticatedSessions-dark.png')
  }}
/>

## Handling Authentication Requests

To handle incoming authentication requests, subscribe to the `onSessionAuthRequest` event. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```dart
// subscribe to onSessionAuthRequest with a handler
_web3Wallet!.onSessionAuthRequest.subscribe(_onSessionAuthRequest);
//
void _onSessionAuthRequest(SessionAuthRequest? args) {
  if (args != null) {
    // Process the authentication request here.
    // Steps include:
    // 1. Populate the authentication payload with the supported chains and methods
    // 2. Format the authentication message using the payload and the user's account
    // 3. Present the authentication message to the user
    // 4. Sign the authentication message(s) to create a verifiable authentication object(s)
    // 5. Approve the authentication request with the authentication object(s)
  }
}
```

## Authentication Objects/Payloads

```dart
final supportedChains = ['eip155:1', 'eip155:10', 'eip155:137'];
final supportedMethods = ['personal_sign', 'eth_sendTransaction'];
final SessionAuthPayload authPayload = AuthSignature.populateAuthPayload(
  authPayload: args.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
);
final cacaoRequestPayload = CacaoRequestPayload.fromSessionAuthPayload(
  newAuthPayload,
);

// Prepare the user's address in CAIP10(https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) format
final iss = 'eip155:1:0x59e2f66C0E96803206B6486cDb39029abAE834c0';
// Now you can use the authPayload to format the authentication message
final message = _web3Wallet!.formatAuthMessage(
  iss: iss,
  cacaoPayload: cacaoRequestPayload,
);

// Present the authentication message to the user
...
```

## Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

:::

```dart
// Approach 1
// Sign the authentication message(s) to create a verifiable authentication object(s)
final credentials = EthPrivateKey.fromHex('$privateKey');
final signature = credentials.signPersonalMessageToUint8List(
  Uint8List.fromList(message.codeUnits),
);
final hexSignature = bytesToHex(signature, include0x: true);
// Build the authentication object(s)
final cacao = AuthSignature.buildAuthObject(
  requestPayload: cacaoRequestPayload,
  signature: CacaoSignature(
    t: CacaoSignature.EIP191,
    s: hexSignature,
  ),
  iss: iss,
);

// Approve
await _web3Wallet!.approveSessionAuthenticate(
  id: args.id,
  auths: [cacao],
);

// Approach 2
// Note that you can also sign multiple messages for every requested chain/address pair
final List<Cacao> cacaos = [];
for (var chain in newAuthPayload.chains) {
  final message = _web3Wallet!.formatAuthMessage(
    iss: iss,
    cacaoPayload: cacaoRequestPayload,
  );
  final credentials = EthPrivateKey.fromHex('$privateKey');
  final signature = credentials.signPersonalMessageToUint8List(
    Uint8List.fromList(message.codeUnits),
  );
  final hexSignature = bytesToHex(signature, include0x: true);
  final cacao = AuthSignature.buildAuthObject(
    requestPayload: cacaoRequestPayload,
    signature: CacaoSignature(
      t: CacaoSignature.EIP191,
      s: hexSignature,
    ),
    iss: iss,
  );
  cacaos.add(cacao)
}

// Approve
await _web3Wallet!.approveSessionAuthenticate(
  id: args.id,
  auths: cacaos,
);
```

## Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```dart
await _web3Wallet!.rejectSessionAuthenticate(
  id: args.id,
  reason: Errors.getSdkError(Errors.USER_REJECTED_AUTH),
);
```

## Testing One-click Auth

You can use [AppKit Lab](https://lab.web3modal.com/library/ethers-siwe/) to test and verify that your wallet supports One-click Auth properly.

<Button name="Test One-click Auth" url="https://lab.web3modal.com/library/ethers-siwe/" />
</file>

<file path="docs/walletkit/flutter/usage.mdx">
import CloudBanner from '../../components/CloudBanner'

# Usage

This section provides instructions on how to initialize the Web3Wallet client, approve sessions with supported namespaces, and respond to session requests, enabling easy integration of Web3 wallets with dapps through a simple and intuitive interface.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out **Extra (Platform Specific)** under this section.

**[Initialization](#initialization)**: Creating a new Web3Wallet instance and initializing it with a projectId from [Cloud](https://cloud.walletconnect.com).

**Session**: Connection between a dapp and a wallet.

- [Namespace Builder](#namespace-builder):
  Namespace Builder is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns a ready-to-use object
- [Session Approval](#session-approval):
  Approving a session sent from a dapp
- [Session Rejection](#session-rejection):
  Rejecting a session sent from a dapp
- [Responding to Session Requests](#responding-to-session-requests):
  Responding to session requests sent from a dapp
- [Updating a Session](#updating-a-session):
  Updating a session sent between a dapp and wallet
- [Extending a Session](#extending-a-session):
  Extending a session between a dapp and wallet
- [Session Disconnect](#session-disconnect):
  Disconnecting a session between a dapp and wallet

<CloudBanner />

## Initialization

To create an instance of Web3Wallet, you need to pass in the `core` and `metadata` parameters.

```dart
final web3Wallet = await Web3Wallet.createInstance(
  projectId: '123.....',
  metadata: const PairingMetadata(
    name: 'Wallet Name',
    description: 'Wallet Description',
    url: 'https://your_wallet_url.com/',
    icons: [
      'https://your_wallet_icon.png'
    ],
    redirect: Redirect(
      native: 'yourwalletscheme://',
      universal: 'https://your_wallet_url.com',
    ),
  ),
);

```

## Session

A session is a connection between a dapp and a wallet. It is established when a user approves a session proposal from a dapp. A session is active until the user disconnects from the dapp or the session expires.

### Namespace Builder

On flutter you don't need to worry about Namespace Builder as Flutter SDK would handle that for you and generate a namespace object with the supported ones.

All you have to do is make sure you are registering

1. **events emitters** with `web3Wallet.registerEventEmitter()` for events you want to support on your wallet
2. **request handlers** with `web3Wallet.registerRequestHandler()` for methods you want to support on your wallet
3. **wallet's accounts** with `web3Wallet.registerAccount()` for accounts you want these events and methods to be enabled on

for every **chain** you want to support.

When a dApp propose a session, with declared required and/or optional namespaces, your wallet will be able to approve an **already generated set of namespaces** based on your registered events, methods and accounts.

You can access this object in **SessionProposalEvent** during `onSessionProposal` event by querying `event.params.generatedNamespaces`. (See next section)

However, if you decide not to use `web3Wallet.registerRequestHandler()` and, instead, you decide to handle session requests by subscribing to the `web3Wallet.onSessionRequest` events then all you have to do is construct your approved namespaces as follows:

```dart
final approvedNamespaces = {
  'eip155': const Namespace(
    accounts: [ // every account you want to support
      'eip155:1:0x76..........',
      'eip155:137:0x76..........',
    ],
    methods: [ // every method you want to support
      'personal_sign',
      'eth_sendTransaction',
    ],
    events: [ // every event you want to support
      'chainChanged',
      'accountsChanged',
    ],
  ),
};
```

Flutter SDK provides a handy `MethodsConstants` and `EventsConstants` for already defined set of required and optional values.

### EVM methods & events

In @walletconnect/ethereum-provider, (our abstracted EVM SDK for apps) we support by default the following Ethereum methods and events:

```ts
{
  //...
  methods: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_getCapabilities",
  ],
  events: [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect",
  ]
}
```

### Session Approval

As mentioned before, the `SessionProposalEvent` is emitted when a dapp initiates a new session with your wallet. The event object will include the information about the dapp and requested namespaces. The wallet should display a prompt for the user to approve or reject the session.

To approve a session, call `approveSession()` and pass in the `event.id` and your approved namespaces.

- If you decide to use the `registerRequestHandler()` method to register handlers for supported methods, as explained in previous section, you would use the `generatedNamespaces` object in the `approveSession`
- If you decide to handle session requests by subscribing to the `onSessionRequest` event, you would need to pass your own set of approved namespaces.

Either way you decide you would subscribe to the `onSessionProposal` event and use `approveSession()` as follows:

```dart
web3Wallet.onSessionProposal.subscribe((SessionProposalEvent? event) {
  // display a prompt for the user to approve or reject the session
  // ....
  // If approved
  web3Wallet.approveSession(
    id: event.id,
    namespaces: // event.params.generatedNamespaces! or approvedNamespaces,
  );
});
```

#### Pairing

The `pair` method initiates a WalletConnect pairing process with a dapp using the given `uri` (QR code from the dapps). To learn more about pairing, checkout out the [docs](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/).

Scan the QR code and parse the URI, and pair with the dapp.  
Upon the first pairing, you will immediately receive `onSessionProposal` and `onAuthRequest` events.

```dart
Uri uri = Uri.parse(scannedUriString);
await web3Wallet.pair(uri: uri);
```

### Session Rejection

To reject the request, pass in an error code and reason. They can be found [here](https://specs.walletconnect.com/2.0/specs/clients/sign/error-codes).

To reject a session:

```dart
web3Wallet.onSessionProposal.subscribe((SessionProposalEvent? event) {
  // display a prompt for the user to approve or reject the session
  // ....
  // If rejected
  web3Wallet.rejectSession(
    id: event.id,
    reason: Errors.getSdkError(Errors.USER_REJECTED),
  );
});
```

### Responding to Session requests

To handle a session request, such as `personal_sign`, you have two ways and they are mutually exclusive, so, you use either one way or the other:

1. The default one is subscribing to onSessionRequest events and handle the request based on the method that is firing the event

```dart
web3Wallet.onSessionRequest.subscribe(_onSessionRequest);

void _onSessionRequest(SessionRequestEvent? event) async {
  if (event != null) {
    final id = event.id;
    final topic = event.topic;
    final method = event.method;
    final chainId = event.chainId;
    final params = event.params as List;

    // message should arrive encoded
    final decoded = hex.decode(params.first.substring(2));
    final message = utf8.decode(decoded);

    // display a prompt for the user to approve or reject the request
    // if approved
    if (approved) {
      // Your code to sign the message here
      final signature = ...

      return web3Wallet.respondSessionRequest(
        topic: topic,
        response: JsonRpcResponse(
          id: id,
          jsonrpc: '2.0',
          result: signature,
        ),
      );
    }
    // if rejected
    return web3Wallet.respondSessionRequest(
      topic: topic,
      response: JsonRpcResponse(
        id: id,
        jsonrpc: '2.0',
        error: const JsonRpcError(code: 5001, message: 'User rejected method'),
      ),
    );
  }
}
```

2. The second way is to register a request handler for the methods and chains you want to support. So let's say your wallet supports `eip155:1` and `eip155:137`. This would translate to:

```dart
final supportedChains = ['eip155:1', 'eip155:137'];
Map<String, dynamic Function(String, dynamic)> supportedMethods = {
  'personal_sign': _personalSignHandler,
  'eth_sendTransaction': _ethSendTransactionHandler,
};
for (var chainId in supportedChains) {
  for (var method in supportedMethods.entries) {
    web3Wallet.registerRequestHandler(
      chainId: chainId,
      method: method.key,
      handler: method.value,
    );
  }
}

Future<void> _personalSignHandler(String topic, dynamic params) async {
  final id = web3Wallet.pendingRequests.getAll().first;

  // message should arrive encoded
  final decoded = hex.decode(params.first.substring(2));
  final message = utf8.decode(decoded);

  // display a prompt for the user to approve or reject the request
  // if approved
  if (approved) {
    // Your code to sign the message here
    final signature = ...

    return web3Wallet.respondSessionRequest(
      topic: topic,
      response: JsonRpcResponse(
        id: id,
        jsonrpc: '2.0',
        result: signature,
      ),
    );
  }
  // if rejected
  return web3Wallet.respondSessionRequest(
    topic: topic,
    response: JsonRpcResponse(
      id: id,
      jsonrpc: '2.0',
      error: const JsonRpcError(code: 5001, message: 'User rejected method'),
    ),
  );
}

Future<void> _ethSendTransactionHandler(String topic, dynamic params) async {
  // ...
}
```

Once you have your handlers registered, this are going to be triggered **INSTEAD OF** the `onSessionRequest` event.

The main difference between these 2 ways of handling session requests is that the default one, using `onSessionRequest` events, carry more useful information such as the **request id** and the **chain id** which are not carried when using the request handlers registration.

### Updating a Session

If you wish to include new accounts or chains or methods in an existing session, `updateSession` allows you to do so.
You need pass in the `topic` and a new `Namespaces` object that contains all of the existing namespaces as well as the new data you wish to include.

After you update the session, the dapp connected to your wallet will receive a `SessionUpdate` event.

```dart
await web3Wallet.updateSession(topic: 'topic', namespaces: '{}')
```

### Extending a Session

To extend the session, call the `extendSession` method and pass in the new `topic`. The `SessionUpdate` event will be emitted from the wallet.

```dart
await web3Wallet.extendSession(topic: 'topic')
```

### Session Disconnect

To initiate a session disconnect, call the `disconnectSession` method and pass in the `topic` and a `reason`.

When either the dapp or the wallet disconnects from a session, a `SessionDelete` event will be emitted. It's important to subscribe to this event so you could keep your state up-to-date.

```dart
await web3Wallet.disconnectSession(
  topic: session.topic,
  reason: Errors.getSdkError(Errors.USER_DISCONNECTED),
);
```

Using `disconnectSession()` alone will make the pairing topic persist, i.e, it can be re-used until it expires. If you want to disconnect (remove) the pairing topic as well you would have add another call as follows:

```dart
await web3Wallet.core.pairing.disconnect(
  topic: pairing.topic,
);
```

#### Supporting session events

In order to support session events, such as `chainChanged` or `accountChanged`, you would have to to register an event emitter for such events, for every chain you want to emit an event for (similar to request handlers).

```dart
final supportedChains = ['eip155:1', 'eip155:137'];
const supportedEvents = ['chainChanged', 'accountChanged'];
for (var chainId in supportedChains) {
  for (var event in supportedEvents) {
    _web3Wallet.registerEventEmitter(
      chainId: chainId,
      event: event,
    );
  }
}
```

And to emit an event, call `emitSessionEvent()` as follows:

```dart
await web3wallet.emitSessionEvent(
  topic: session.topic,
  chainId: 'eip155:1',
  event: SessionEventParams(
    name: 'chainChanged',
    data: 1,
  ),
);
```

For a better understanding please check out the [example wallet](https://github.com/WalletConnect/WalletConnectFlutterV2/blob/master/example/wallet/lib/) and, in particular, the [EVMService](https://github.com/WalletConnect/WalletConnectFlutterV2/blob/master/example/wallet/lib/dependencies/chains/evm_service.dart) inside of it.
</file>

<file path="docs/walletkit/flutter/verify.mdx">
# Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.
Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).
For those looking to enable Verify on the app side, check out our reference guide [here.](./cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

These are:

![Verify Banner](/img/verify-banner.png)

## Disclaimer

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

## Domain risk detection

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either `VALID`, `INVALID` or `UNKNOWN`.

- Domain match: The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `VALID`.
- Unverified: The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `UNKNOWN`.
- Mismatch: The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `INVALID`
- Threat: This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The `verifyContext` included in the request will contain parameter `isScam` with value `true`.

### Implementation

To check the Verify API validations and whether or not your user is interacting with potentially malicious dapp, you can do so by accessing the `verifyContext` included in the `SessionProposalEvent`:

```dart
_web3Wallet!.onSessionProposal.subscribe((SessionProposalEvent? args) {
  if (args != null) {
    final scamApp = args.verifyContext?.validation.scam;
    final invalidApp = args.verifyContext?.validation.invalid;
    final validApp = args.verifyContext?.validation.valid;
    final unknown = args.verifyContext?.validation.unknown;
  }
});
```
</file>

<file path="docs/walletkit/ios/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/walletkit/ios/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import ExplorerSubmission from '../../../cloud/explorer-submission.mdx'

<ExplorerSubmission />
</file>

<file path="docs/walletkit/ios/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/walletkit/ios/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/walletkit/ios/notifications/notify/installation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Installation

Notify API is available via [Swift Package Manager](https://swift.org/package-manager/) or [Cocoapods](https://cocoapods.org/).

<Tabs
queryString="ios-method"
	values={[
		{ label: 'SwiftPackageManager', value: 'spm', },
		{ label: 'Cocoapods', value: 'cocoa', },
	]}
>
<TabItem value="spm">

You can add the WalletConnect Notify package to your project with the Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package
5. Select `WalletConnectNotify` check mark

</TabItem>
<TabItem value="cocoa">

1. Update Cocoapods spec repos. Type in terminal `pod repo update`
2. Initialize Podfile if needed with `pod init`
3. Add pod to your Podfile:

```ruby
pod 'WalletConnectSwiftV2/WalletConnectNotify'
```

4. Install pods with `pod install`

If you encounter any problems during package installation, you can specify the exact path to the repository

```ruby
pod 'WalletConnectSwiftV2/WalletConnectNotify', :git => 'https://github.com/WalletConnect/WalletConnectSwiftV2.git', :tag => '1.8.0'
```

</TabItem>
</Tabs>

## Next Steps

Now that you've installed WalletConnect Notify, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the Notify API.
</file>

<file path="docs/walletkit/ios/notifications/notify/overview.mdx">
# Overview

:::info
For those integrating notifications related to wallet pairing and sign requests, please check [here](../push.mdx).
:::

The WalletConnect Notify API is designed to enhance the interaction between wallet users and dapps by offering a robust notification system. This API empowers wallet developers to implement a dynamic notification experience directly within their wallets. It provides the functionality for users to opt-in to notifications, ensuring they stay informed about critical events and interactions.

The Notify API is versatile, with support for both iOS and Android platforms, making it an ideal choice for cross-platform wallet applications.

Coupled with the [AppKit Notifications](../../../../appkit/features/notifications), the Notify API forms part of a comprehensive toolkit that enables seamless integration of web3 communication and messaging features into dapps. This ensures a more connected and interactive experience for users in the decentralized ecosystem.

## Features

Some of the key features of the Notify API include:

- **Push Notifications for Desktop and Native Platforms**: This feature enables dapps to directly send vital notifications to user wallets, ensuring timely and relevant communication.
- **Robust Spam Protection**: Users have complete authority over which dapps can send them notifications, effectively eliminating any unsolicited messages from unknown sources. Furthermore, users can fine-tune their preferences to only receive notifications types they are interested in, like new features or some important events occurence.
- **Chain Agnostic Architecture**: The Notify API is built to be compatible with any blockchain, allowing seamless multi-chain support without the need for writing additional integration code. **As of November 2023, the Notify Server and Clients are equipped to support EVM chains. Plans to extend support to non-EVM chains are in progress and are a significant part of our upcoming development roadmap.**

_Example integration_
![Web3Inbox](/assets/web3inbox/w3i-hero.png)
</file>

<file path="docs/walletkit/ios/notifications/notify/resources.mdx">
# Resources

Valuable assets for developers interested in integrating Notify API into their wallet.

- [Web3Inbox.com app](https://app.web3inbox.com) - Inbox web app that simulates wallet experience.
- [GM dapp](https://gm.walletconnect.com/) - Example dapp that sends notification every hour.
- [GM hackers](https://github.com/WalletConnect/gm-hackers) - Template used in hackathons sponsored by WalletConnect.

## Wallet Resources

To check more in details go and visit our¬†[WalletKit Swift implementation app](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example/WalletApp). Sample Wallet sample apps can be found under the Example directory in¬†[Swift's V2 repository](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example)

If you need to test your app's integration, you can use one [our GM dapp.](https://gm.walletconnect.com/)

## Need Technical Support?[](https://docs.walletconnect.com/web3wallet/namespaces#need-technical-support)

If you require technical support along the way, please drop a message on the [WalletConnect GitHub](https://github.com/orgs/WalletConnect/discussions/categories/web3inbox-sdk-support) and our team will get back to you as soon as possible.
</file>

<file path="docs/walletkit/ios/notifications/notify/spam-protection.mdx">
# Spam Protection

Users play a critical role in web3. That‚Äôs why, with Web3Inbox, we‚Äôre committed to ensuring users can enjoy a safe, seamless, and reliable experience that puts them in the driver‚Äôs seat. As part of that pledge, Web3Inbox provides a number of user-first, anti-spam features and elements that ensure users are always in control of their web3 communications.

## How are users protected from spam with Web3Inbox?

### Becoming a Web3Inbox customer

When a wallet offers app notifications to their users via Web3Inbox, the feature will always be optional. If users decide they want to receive notifications from selected apps via their wallet, they‚Äôll be able to ‚Äòopt-in‚Äô and subscribe to an app‚Äôs notifications by signing a message request. Similarly, when accessing notifications through the [Web3Inbox.com app](https://app.web3inbox.com), users will be met with the same request for each application they choose to subscribe to. This feature not only enables users to experience a customized, ‚Äòapp-by-app‚Äô approach to staying connected in web3, but also ensures they only ever hear from the apps they choose to ‚Äî no unsolicited notifications or spam from unknown senders. Its their curated inbox, connected with only those they choose.

### Setting customized notification preferences

Once users have subscribed to their chosen apps, they have the option to define and set which types of notifications they receive from those apps. For example, a user may wish to receive only information regarding changes to their portfolio from a DEX, or, they might want to receive notifications from an NFT marketplace ‚Äî but only notifications regarding their own NFT collections. In these scenarios, they‚Äôll have the ability to disable other notification types, like marketing updates, and ensure their feed is curated to show only information that‚Äôs meaningful to them. As apps set their own notification types, they have unlimited optionality to really build out a notification structure they know can support their users‚Äô needs ‚Äî no ‚Äòone size fits all‚Äô approach, but a personable, community-oriented structure that puts both app and user needs‚Äô at the forefront of communication.

### Rate limiting

Apps are limited to a maximum number of notifications they‚Äôre able to send to their community. Specifically, apps may send accounts notifications twice an hour on average, but may exceeed that average in bursts of up to 50 at a time.

## Our continued pledge on spam protection

We‚Äôre constantly working on improving and growing our products, and we have a number of impactful anti-spam features and functions in the works set to increase the overall protection and user experience of Web3Inbox users:

### User reporting

Users will have the ability to report applications that appear to be acting or engaging with their community in a malicious or suspicious manner. Projects that are flagged as malicious may be removed from the Web3Inbox discover page and have notification functionality disabled.
</file>

<file path="docs/walletkit/ios/notifications/notify/usage.mdx">
import CloudBanner from '../../../../components/CloudBanner'

# Usage

In this section, we showcase the aspects of using the Notify API. We'll guide you through the initial steps of initializing the Notify client and logging in a blockchain account. You'll also learn how to manage your subscriptions and messages. Additionally, we cover the process of setting up and displaying push notifications on your preferred platform. To ensure a good user experience, we include best practices for spam protection, helping you to enable the users to maintain control over the notifications wallet receives.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out¬†Extra (Platform Specific)¬†under this section.

- [Initialization](#initialization):
  Creating a new Notify Client instance and initializing it with a projectId from¬†[Cloud](https://cloud.walletconnect.com/).
- [Account login](#account-login):
  A SIWE message must be signed by the user in order to authorize the client to use Notify API
- [Subscribing to a new dapp](#subscribing-to-a-new-dapp):
  Opt-in to receive notifications from dapp
- [Fetching active subscriptions](#fetching-active-subscriptions):
  Get active subscriptions
- [Fetching subscription‚Äôs notification](#fetching-subscriptions-notifications):
  Get notifications of a subscription
- [Updating subscriptions notification settings](#updating-subscriptions-notification-settings):
  Change allowed notification types sent by dapp
- [Unsubscribe from a dapp](#unsubscribe-from-a-dapp):
  Opt-out from receiving notifications from a dapp
- [Account logout](#account-logout):
  To stop receiving notifications to this client, accounts can logout of using Notify API
- [Apple Push Notification service setup](?platform=ios#apple-push-notification-service-setup):
  Configuring iOS app in order to decrypt notifications

## Initialization

<CloudBanner />

Important: Confirm you have configured the [Network Client](../../../../api/core/relay.mdx) first.

Configure the `Notify` instance with:

```swift
try Notify.configure(environment: APNSEnvironment, crypto: CryptoProvider)
```

`environment` - Use `debug` environment for debug builds and `release` for release and TestFlight builds.

`crypto` - CryptoProvider is a protocol, you are required to provide an implementation of `recoverPubKey` and `keccak256` methods.

## Account login

In order to register account in Notify API to be able to subscribe to any dapp to start receiving notifications, account needs to sign SIWE message to prove ownership. Developers can check if an account is registered by calling **`isRegistered()`** function. If the account is not registered, developers should call **`prepareRegistration()`** and then **`register()`** function to register the account.

To login to manage notifications, you must request message to sign with `prepareRegistration()` method and register signature with `register()` method. Once logged in, cross-device syncing will be enabled.

```swift
let params = try await Notify.instance.prepareRegistration(account: account, domain: "com.YOURAPPDOMAIN")
let signature = onSign(message: params.message) // Sign message with your signer
try await Notify.instance.register(params: params, signature: signature)
```

- `account` - An CAIP-10 account that the identity key will be issued for
- `domain` - A domain of your wallet, you should use your bundle ID

Provide your own sign function implementation that returns CacaoSignature. If SIWE is not implemented on your app you can always use our [MessageSignerFactory](https://github.com/WalletConnect/WalletConnectSwiftV2/blob/main/Sources/WalletConnectSigner/Signer/MessageSignerFactory.swift) and [DefaultSignerFactory](https://github.com/WalletConnect/WalletConnectSwiftV2/blob/main/Example/Shared/DefaultSignerFactory.swift) from our sample app that uses Web3 SPM package.

```swift
func onSign(message: String) -> CacaoSignature {
    let privateKey = Data(hex: privateKey)
    let signer = MessageSignerFactory(signerFactory: DefaultSignerFactory()).create()
    let signature = try! signer.sign(message: message, privateKey: privateKey, type: .eip191)
    return signature
}
```

## Subscribing to a new dapp

To begin receiving notifications from a dapp, users must opt-in by subscribing. This subscription process grants permission for the dapp to send notifications to the user. These notifications can serve a variety of purposes, such as providing updates on the user's blockchain account activities or informing them about ongoing campaigns within the dapp. Upon initial subscription, clients will be automatically enrolled to receive all types of notifications as defined by the dapp at that moment. Users have the flexibility to modify their notification settings later, allowing them to tailor the types of alerts they receive according to their preferences.

```swift
public func subscribe(appDomain: String, account: Account) async throws
```

`appDomain` - dapp domain fetched from WalletConnect explorer

`account` - an account you want to associate a sebscription with

#### Combine event

```swift
public var subscriptionsPublisher: AnyPublisher<[NotifySubscription], Never>
```

## Fetching active subscriptions

To fetch the current list of subscriptions an account has, call **`getActiveSubscriptions()`**.

Method will return an array of NotifySubscription objects that indicates actual subscriptions state

```swift
public func getActiveSubscriptions(account: Account) -> [NotifySubscription]
```

`account` - subscriptions owner account

## Fetching subscription‚Äôs notifications

To fetch subscription‚Äôs notifications by calling **`getNotificationHistory()`**.

Method will return an array of NotifyMessageRecord objects that indicates current notify messages state. This do not include old messages that aren't loaded yet. Useful for displaying initial notifications view state. For more info about pagination, check `fetchHistory` method.

Use this method together with:

- `messagesPublisher(topic: String)`
- `fetchHistory`

```swift
public func getMessageHistory(topic: String) -> [NotifyMessageRecord]
```

`topic` - unique subscription's topic

#### Combine events

Publisher that send messages update event for specific topic only

```swift
public func messagesPublisher(topic: String) -> AnyPublisher<[NotifyMessageRecord], Never>
```

Publisher that send event on every messages update (for all subscriptions)

```swift
public var messagesPublisher: AnyPublisher<[NotifyMessageRecord], Never>
```

## Updating subscriptions notification settings

Users can alter their notification settings to filter out unwanted alerts from a dapp. During this process, they review and select the types of notifications they wish to receive, based on the latest options provided by the dapp.

```swift
public func update(topic: String, scope: Set<String>) async throws
```

`topic` - topic of the subscription to update

`scope` - The new space delimited list of scopes

## Unsubscribe from a dapp

To opt-out of receiving notifications from a dap, a user can decide to unsubscribe from dapp.

```swift
try await Notify.instance.deleteSubscription(topic: String)
```

`topic` - subscription's topic

## Account logout

If an account is removed from the client or a user no longer wants to receive notifications for this account, you can logout the account from Notify API by calling **`unregister()`**. This will remove all subscriptions and messages for this account from the client‚Äôs storage.

```swift
public func unregister(account: Account) async throws
```

`account` - account ot unregister

## Fetch notification history (Pagination)

Method that fetches notification history and saves it to SDK's database. When async method finishes execution, `messagesPublisher(topic: String)` will send the event with actual Notify messages for the specified topic.

```swift
func fetchHistory(subscription: NotifySubscription, after: String?, limit: Int) async throws -> Bool
```

`subscription` - subscription for which notification history is requested
`after?` - id of last notification loaded. Recent notifications will be loaded if provided nil
`limit` - notifications to load count

`Returns` - Returns True if there are still not fetched notifications

## Apple Push Notification service setup

To setup Apple Push Notification service please follow our [Push Notifications docs](../push.mdx).
</file>

<file path="docs/walletkit/ios/notifications/push.mdx">
# Push Notifications

WalletKit provides the functionality for wallets to receive push notifications through Firebase Cloud Messaging (FCM) and Apple Push Notification Service (APNs) via the Push Server. This feature ensures that wallets are promptly notified of incoming signature requests. Each push notification contains the encrypted details of the signature request. Upon receiving the notification, it can be decrypted and presented to the developer, allowing for customization of the message according to their requirements.

## Server setup

For the push notifications to be forwarded to FCM or APNs, the [Push Server](../../../advanced/push-server) will need to be configured with your FCM or APNs server API credentials.

## App setup

### Register the device token

To enable a device for push notifications, it's essential to register the device token using `Web3Wallet.registerDeviceToken`. This token can be obtained from either FCM or APNS, depending on the platform used.

In your AppDelegate, you need to register your device token for push notifications. To enable encrypted push notifications, set the `enableEncrypted` flag to `true`.

```Swift
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    Task(priority: .high) {
        try await Web3Wallet.instance.register(deviceToken: deviceToken, enableEncrypted: true)
    }
}
```

### Receiving push notifications

After the device token is registered, the next step involves setting up the notification service specific to the platform being used. This service will decrypt the incoming requests and forward them to the developer for further processing and integration.

When using encrypted push notifications via APNs, the payload will look like this:

```json
{
  "aps": {
    "content-available": 1,
    "mutable-content": 1
  },
  "message": "String", // Encrypted payload
  "topic": "String", // Subscription topic
  "tag": "String" // Tag of the associated relay message
}
```

To decrypt a push notification, follow these steps:

1. Instantiate [UNNotificationServiceExtension](https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension)

2. Modify the content of newly delivered notifications.
   Learn more about [modifying content in newly delivered notifications](https://developer.apple.com/documentation/usernotifications/modifying_content_in_newly_delivered_notifications).

3. Create a Shared [Keychain Group](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps)

Ensure you have a keychain group that is shared between your wallet application and the notification service. This is set in the app during the Networking Client configuration as shown below:

```Swift
Networking.configure(
    groupIdentifier: "group.com.walletconnect.sdk",
    projectId: InputConfig.projectId,
    socketFactory: DefaultSocketFactory()
)
```

4. Instantiate Web3WalletDecryptionService

Use the same group name inside your notification service extension.

```Swift
override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
        self.contentHandler = contentHandler
        self.bestAttemptContent = request.content

        if let content = bestAttemptContent,
           let topic = content.userInfo["topic"] as? String,
           let ciphertext = content.userInfo["message"] as? String,
           let tag = content.userInfo["tag"] as? UInt {

            if Web3WalletDecryptionService.canHandle(tag: tag) {
                let mutableContent = handleWeb3WalletNotification(content: content, topic: topic, tag: tag, ciphertext: ciphertext)
                contentHandler(mutableContent)
            } else if NotifyDecryptionService.canHandle(tag: tag) {
                let mutableContent = handleNotifyNotification(content: content, topic: topic, ciphertext: ciphertext)
                contentHandler(mutableContent)
            } else {
                let mutableContent = content.mutableCopy() as! UNMutableNotificationContent
                mutableContent.title = "Error: unknown message tag"
            }
        }
    }
```

`handleWeb3WalletNotification` and `handleNotifyNotification` methods can be found in our [Sample App](https://github.com/WalletConnect/WalletConnectSwiftV2/blob/main/Example/PNDecryptionService/NotificationService.swift)
</file>

<file path="docs/walletkit/ios/best-practices.mdx">
# Best Practices

The purpose of this guide is to show the best practices in regards of the WalletKit client usage. The goal is to provide the best user experience that just works in every circumstances.

:::note
In order to ensure the best user experience and flawless connection flow, please make sure that WalletKit is initialized immediately after your app launch, especially if launched via a WalletConnect Deep Link. It guarantees that websocket connection is opened immediately and all requests are received by your wallet
:::

## Pairing

A pairing is a connection between a wallet and a dapp that has fixed permissions to only allow a dapp to propose a session through it. Dapp can propose infinite number of sessions on one pairing. Wallet must use a pair method from the WalletKit client to pair with dapp.

```swift
let uri = WalletConnectURI(string: urlString)

if let uri {
Task {
try await Web3Wallet.instance.pair(uri: uri)
}
}

```

### Pairing State

A pairing state is a primitive exposed by the WalletKit client for a wallet to indicate whether it should await a session proposal. The pairing state is `true` when a wallet scans a QR and awaits a session proposal. Once the session proposal is received by the wallet, the pairing state is changed to `false`.
When `true` wallet should show a loading indicator awaiting a session proposal, when changed to `false` a proposal dialog should be displayed.

```swift
Web3Wallet.instance.pairingStatePublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] isPairing in
    self?.showPairingLoading = isPairing
}.store(in: &disposeBag)
```

### Pairing Expiry

A pairing expiry event is triggered whenever a pairing is expired. The expiry for inactive pairing is 5 mins, whereas for active pairing is 30 days. A pairing becomes active when a session proposal is received and user successfully approves it. This event helps to know when given pairing expires and update UI accordingly.

```Swift
Web3Wallet.instance.pairingExpirationPublisher
    .receive(on: DispatchQueue.main)
    .sink { pairing in
    guard !pairing.active else { return }
    // let user know that pairing has expired
}.store(in: &publishers)
```

### Expected User flow

### Pairing Flow

![](/assets/pairing.gif)

### Pairing Error

![](/assets/pairing_error.gif)

### Expected Errors

While pairing the following errors might occur:

- No Internet connection error or pairing timeout when scanning QR with no Internet connection
  - User should pair again with Internet connection
- Pairing expired error when scanning a QR code with expired pairing
  - User should refresh a QR code and scan again
- Pairing with existing pairing is not allowed
  - User should refresh a QR code and scan again. I usually happens when user scans an already paired QR code.

## Session Proposal

A session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Whenever a user wants to establish a connection between a wallet and a dapp, one should approve a session proposal.

### User Action Feedback

Whenever user approves or rejects a session proposal, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

Session Approve
```swift
do {
    try await Web3Wallet.instance.approve(proposalId: proposal.id, namespaces: sessionNamespaces, sessionProperties: proposal.sessionProperties)
    // Update UI, remove loader
} catch {
    // present error
}
```

Session Reject

```swift
do {
    try await Web3Wallet.instance.reject(proposalId: proposal.id, reason: .userRejected)
    // Update UI, remove loader
} catch {
    // present error
}
```

### Session Proposal Expiry

A session proposal expiry is 5 mins. It means a given proposal is stored for 5 mins in the SDK storage and user has 5 mins for approval or rejection decision. After that time the below event is emitted and proposal modal should be removed from the app's UI.

```swift
Web3Wallet.instance.sessionProposalExpirationPublisher.sink { _ in
    // let user know that session proposal has expired, update UI
}.store(in: &publishers)
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/pairing.gif)

### Error Handling

![](/assets/proposal_error.gif)

### Expected Errors

While approving or rejecting a session proposal the following errors might occurs:

- No Internet connection
  - It happens when a user tries to approve or reject session proposal with no Internet connection
- Session proposal expired
  - It happens when users tries to approve or reject expired session proposal
- Invalid namespaces
  - It happens when a validation of session namespaces fails
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Session Request

A session request represents the request sent by a dapp to a wallet.

### User Action Feedback

Whenever user approves or rejects a session request, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

```swift
do {
    try await Web3Wallet.instance.respond(requestId: request.id, signature: signature, from: account)
    // update UI -> remove the loader
} catch {
    // present error to the user
}
```

### Session Request Expiry

A session request expiry is defined by a dapp. It's value must be between now() + 5mins and now() + 7 days. After the session request expires the below event is emitted and session request modal should be removed from the app's UI.

```swift
Web3Wallet.instance.requestExpirationPublisher.sink { _ in
    // let user know that request has expired
}.store(in: &publishers)
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/session_request.gif)

### Error Handling

![](/assets/session_request_error.gif)

### Expected Errors

While approving or rejecting a session request the following error might occur:

- Invalid session
  - This error might happen when user approves or rejects a session request on expired session
- Session request expired
  - This error might happen when user approves or rejects a session request that already expires
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Web Socket Connection State

The Web Socket connection state tracks the connection with the relay server, event is emitted whenever a connection state changes.

```swift
Web3Wallet.instance.socketConnectionStatusPublisher
    .receive(on: DispatchQueue.main)
    .sink { status in
    switch status {
    case .connected:
        // ...
    case .disconnected:
        // ...
    }
}.store(in: &publishers)
```

### Expected User flow

### Connection State

![](/assets/connection_state.gif)
</file>

<file path="docs/walletkit/ios/eip5792.mdx">
# Wallet Call API

WalletConnect supports [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792#atomicbatch-capability), which defines new JSON-RPC methods that enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.
Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.

- `wallet_sendCalls`: Requests that a wallet submits a batch of calls.
- `wallet_getCallsStatus`: Returns the status of a call batch that was sent via wallet_sendCalls.
- `wallet_showCallsStatus`: Requests that a wallet shows information about a given call bundle that was sent with wallet_sendCalls.
- `wallet_getCapabilities`: This RPC allows an application to request capabilities from a wallet (e.g. batch transactions, paymaster communication).
</file>

<file path="docs/walletkit/ios/installation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Installation

WalletConnect SDK is available via [Swift Package Manager](https://swift.org/package-manager/) or [Cocoapods](https://cocoapods.org/).

<Tabs
queryString="ios-method"
	values={[
		{ label: 'SwiftPackageManager', value: 'spm', },
		{ label: 'Cocoapods', value: 'cocoa', },
	]}
>
<TabItem value="spm">

You can add a WalletConnect SDK to your project with Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package
5. Select WalletConnect check mark

</TabItem>
<TabItem value="cocoa">

1. Update Cocoapods spec repos. Type in terminal `pod repo update`
2. Initialize Podfile if needed with `pod init`
3. Add pod to your Podfile:

```ruby
pod 'WalletConnectSwiftV2'
```

4. Install pods with `pod install`

If you encounter any problems during package installation, you can specify the exact path to the repository

```ruby
pod 'WalletConnectSwiftV2', :git => 'https://github.com/WalletConnect/WalletConnectSwiftV2.git', :tag => '1.0.5'
```

</TabItem>
</Tabs>

## Next Steps

Now that you've installed WalletKit, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the SDK.
</file>

<file path="docs/walletkit/ios/link-mode.mdx">
# Link Mode

WalletKit link mode is a low latency mechanism for transporting 1-click auth requests and session requests over universal links, eliminating the need for a WebSocket connection with the Relay. This significantly enhances the user experience when connecting native dApps to native wallets by reducing the latency associated with networking connections, especially when the user has an unstable internet connection.

To support link mode add universal link for your wallet in Cloud project configuration dashboard, configure your `AppMetadata.Redirect` with a valid universal link and set the `linkMode` property to `true`:

```swift
let metadata = AppMetadata(
    ...
    redirect: try! AppMetadata.Redirect(native: "exampleApp://", universal: "https://example.com/example_wallet", linkMode: true)
)

Web3Wallet.configure(
    metadata: metadata,
    ...
)

For more information on how to configure universal links for your app, refer to the [Apple Documentation](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc).

For a debugging guide, visit the [Debugging Universal Links](https://developer.apple.com/documentation/technotes/tn3155-debugging-universal-links) page.

Once link mode and universal linking are properly configured and the user interacts with a link mode supporting dApp, your wallet will receive requests over universal linking. You must pass these requests to WalletKit so it can process them:

```swift
try Web3Wallet.instance.dispatchEnvelope(url.absoluteString)
```

Ensure to handle incoming universal links in different methods of `AppDelegate` or `SceneDelegate`. 

For more information on how to configure universal links for your app, refer to the [Apple Documentation](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc).

For a debugging guide, visit the [Debugging Universal Links](https://developer.apple.com/documentation/technotes/tn3155-debugging-universal-links) page.

You can also find thiss [article](https://developer.apple.com/documentation/xcode/supporting-universal-links-in-your-app?language=objc) helpful.
</file>

<file path="docs/walletkit/ios/mobile-linking.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import HowToTest from '../shared/mobile-linking.mdx'

# Mobile Linking

:::info Note

This feature is only relevant to native platforms.

:::

## Usage

Mobile Linking allows your wallet to automatically redirect back to the Dapp allowing for less user interactions and hence a better UX for your users.

### Establishing Communication Between Mobile Wallets and Apps

When integrating a wallet with a mobile application, it's essential to understand how they communicate. The process involves two main steps:

1. **QR Code Handshake:** The mobile app (Dapp) generates a unique URI (Uniform Resource Identifier) and displays it as a QR code. This URI acts like a secret handshake. When the user scans the QR code using their wallet app, they establish a connection. It's like saying, "Hey, let's chat!"
2. **Deep Links and Universal Links:** The URI from the QR code allows the wallet app to create a [deep link](https://support.google.com/google-ads/answer/10023042?hl=en#:~:text=Deep%20links%20send%20mobile%20device,%2C%20Shopping%2C%20and%20Display%20campaigns.) or [universal link](https://developer.apple.com/ios/universal-links/). These links work on both Android and iOS. They enable seamless communication between the wallet and the app.

:::tip

**Developers should prefer Deep Linking over Universal Linking.**

In the case of Universal Linking, the user may be redirected to the browser, which may not be the desired behavior. Deep Linking ensures that the user is redirected to the app, providing a seamless experience.

:::

The connection and sign request flows are similar across platforms.
The next section provides a high-level overview of both flows.

### Connection Flow

- **Dapp Prompts User:** The Dapp asks the user to connect.
- **User Chooses Wallet:** The user selects a wallet from a list of compatible wallets.
- **Redirect to Wallet:** The user is redirected to their chosen wallet.
- **Wallet Approval:** The wallet prompts the user to approve or reject the session (similar to granting permission).
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reunites with Dapp:** After all the interactions, the user ends up back in the Dapp.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking-dark.png')
  }}
/>

### Sign Request Flow

When the Dapp needs the user to sign something (like a transaction), a similar pattern occurs:

- **Automatic Redirect:** The Dapp automatically sends the user to their previously chosen wallet.
- **Approval Prompt:** The wallet asks the user to approve or reject the request.
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reconnects:** Eventually, the user returns to the Dapp.

<ThemedImage
  alt="Mobile Linking Sign Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking_sign-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking_sign-dark.png')
  }}
/>

## Platform preparations

In order for Dapps to be able to trigger your wallet for a connection or sign request using deep links you first need to add your custom scheme under [`CFBundleURLTypes`](https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundleurltypes) key in your Info.plist file.

```ruby
<key>CFBundleURLTypes</key>
<array>
	<dict>
		<key>CFBundleTypeRole</key>
		<string>Editor</string>
		<key>CFBundleURLName</key>
		<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
		<key>CFBundleURLSchemes</key>
		<array>
			<string>examplewallet</string> <!-- your custom scheme goes here -->
		</array>
	</dict>
</array>
```

:::tip

Dapps developers must do the same for their own custom schemes if they want the wallet to be able to navigate back after a session approval or a sign request response

:::

<HowToTest/>

## Integration

### iOS Wallet Support

iOS has some more caveats to the integration but we ensure to make it as straightforward as possible. Since its operating system is not designed to handle multiple applications subscribing to the same deep linking schema, we've designed the AppKit to list supporting wallets on our [Explorer](https://walletconnect.com/explorer) and target specific deep links or universal links for each wallet.

To add your own wallet to the Explorer, login to your [WalletConnect Cloud](https://cloud.walletconnect.com/sign-in) account.

```bash
# For deep links
examplewallet://wc?uri=wc:94caa59c77dae0dd234b5818fb7292540d017b27d41f7f387ee75b22b9738c94@2?relay-protocol=irn&symKey=ce3a2c7724c03cf1769ba8b1bdedad5414cc7b920aa3fb72112b997d1916266f

# For universal links
https://example.wallet/wc?uri=wc:94caa59c77dae0dd234b5818fb7292540d017b27d41f7f387ee75b22b9738c94@2?relay-protocol=irn&symKey=ce3a2c7724c03cf1769ba8b1bdedad5414cc7b920aa3fb72112b997d1916266f
```

Additionally when there is a signing request triggered by the Dapp it will hit the deep link with an incomplete URI, this should be ignored and not considered valid as it's only used for automatically redirecting the users to approve or reject a signing request.

```bash
# For deep links
examplewallet://wc?uri=wc:00e46b69-d0cc-4b3e-b6a2-cee442f97188@2

# For universal links
https://example.wallet/wc?uri=wc:00e46b69-d0cc-4b3e-b6a2-cee442f97188@2
```

---

### WalletConnectRouter

### Overview

WalletConnectRouter simplifies navigation by automatically redirecting users back to the DApp after they've interacted with a wallet via a deep link. This eliminates the need for users to manually navigate back after approving a session or confirming a transaction.

### Key Features

**Automatic Redirection:** By invoking WalletConnectRouter.goBack(uri: "example://")‚Äîwhere "example://" is the DApp's custom scheme as declared in their AppMetadata redirect field‚Äîusers are seamlessly returned to the DApp.

### Important Consideration

**Mandatory redirect Field:** Starting with WalletConnect SDK version 1.9.5, specifying the redirect field in the AppMetadata object is mandatory to avoid redirection issues.

### Installation and Usage

```swift
import WalletConnectRouter

try await Sign.instance.approve(proposalId: <proposalId>, namespaces: <namespaces>)

if let uri = proposal.proposer.redirect?.native {
    WalletConnectRouter.goBack(uri: uri)
} else {
    // Inform the user to manually return to the DApp
}
```

---

### Limitations

This section outlines some of the known limitations and constraints when using WalletConnect on iOS.

### Redirects on iOS 17 and Above

Automatic redirection to browser-based DApps after wallet interaction is not possible from iOS 17 onwards. Developers should adjust their app's UI to inform users about manual navigation back to the browser.

For iOS versions below 17, `WalletConnectRouter.goBack(uri: uri)` facilitates automatic redirection.

![Redirect](/img/ios-redirect.png)

### iOS Universal Links Constraints

:::caution

**Developers should prefer Deep Linking over Universal Linking.**

In the case of Universal Linking, the user may be redirected to the browser, which may not be the desired behavior. Deep Linking ensures that the user is redirected to the app, providing a seamless experience.

:::

When using WalletConnect on iOS and triggering a wallet interaction (e.g. when sending a transaction or signing a message), you may experience issues where the native app is not opened as expected and a browser navigation occurs instead.

This issue occurs because Universal Links (app links) on iOS will only open the native app when the following rules are followed:

- **The wallet interaction must be triggered by a user-initiated event,** e.g. in a click handler rather than on page load or in an asynchronous callback.
- **The wallet interaction must be triggered as soon as possible within the event handler.** Any preceding asynchronous work (e.g. estimating gas, resolving an ENS name, fetching a nonce) should have already completed before the event handler fires. This may require you to design the user experience around this constraint, preventing users from initiating a wallet interaction until it's ready rather than doing the work lazily.

**Note that even if your own code follows these rules, libraries you depend on may be running their own asynchronous logic before triggering a wallet interaction.** For example, [Ethers asynchronously populates transactions before sending them.](https://docs.ethers.io/v5/api/signer/#Signer-sendTransaction) Known workarounds are documented below, but if you're still experiencing these issues, you should raise them with the relevant library maintainers.

### For Ethers v5 (Legacy)

These are the known workarounds for avoiding app linking issues on iOS when using [Ethers v5](https://docs.ethers.io/v5).

### When sending a transaction

1. **[`signer.sendTransaction`](https://docs.ethers.io/v5/api/signer/#Signer-sendTransaction)
   should be avoided in favor of
   [`signer.sendUncheckedTransaction`](https://docs.ethers.io/v5/api/providers/jsonrpc-provider/#JsonRpcSigner-sendUncheckedTransaction)**
   <br />
   &nbsp;This avoids an asynchronous call to retrieve the internal block number which Ethers uses to
   resolve a complete [`TransactionResponse`](https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse)
   object.
   <br />
   &nbsp;Note that as a result of this optimization, `sendUncheckedTransaction` returns a mock transaction
   response that only contains the `hash` property and a `wait` method. All other properties are `null`.
1. **The transaction's `to` property should be a plain address rather than an ENS name**
   <br />
   This avoids an asynchronous call to automatically resolve ENS names during the send process.
   <br />
   &nbsp;If you still want to support ENS name resolution, you should manually run [`provider.resolveName`](https://docs.ethers.io/v5/api/providers/provider/#Provider-ResolveName)
   ahead of time, storing the result before the user attempts to send a transaction. Do not resolve ENS
   names in the event handler.
1. **The transaction's `gasLimit` property should be set**
   <br />
   This avoids the asynchronous work performed in `sendTransaction` which automatically estimates the
   gas limit if it's missing.
   <br />
   &nbsp;If you still want to use the same gas limit estimation logic from `sendTransaction`, you should
   manually run [`provider.estimateGas`](https://docs.ethers.io/v5/api/providers/provider/#Provider-estimateGas)
   ahead of time, storing the result before the user attempts to send the transaction. Do not estimate
   gas in the event handler.

### When calling a write method on a contract

1. **[`contract.METHOD_NAME`](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend)
   should be avoided if favor of calling
   [`contract.populateTransaction.METHOD_NAME`](https://docs.ethers.io/v5/api/contract/contract/#contract-populateTransaction)
   ahead of time, then sending the populated transaction with
   [`signer.sendUncheckedTransaction`](https://docs.ethers.io/v5/api/providers/jsonrpc-provider/#JsonRpcSigner-sendUncheckedTransaction).**

1. When sending the populated transaction, you should [follow the same guidelines as regular
   transactions](#when-sending-a-transaction) to avoid any asynchronous logic breaking the app link
   navigation. Do not populate the contract transaction in the event handler.

### When signing a message

If the message depends on the result of an asynchronous call (e.g. retrieving a nonce when implementing [Sign-In With Ethereum](https://login.xyz)), you should do this work ahead of time, storing the result before the user attempts to sign the message. Do not perform this asynchronous work in the event handler.
</file>

<file path="docs/walletkit/ios/one-click-auth.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import Button from '../../components/button'

# One-click Auth

## Introduction

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a [Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361) (SIWE) message, enhanced by [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities).

This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/authenticatedSessions-light.png'),
    dark: useBaseUrl('/img/w3w/authenticatedSessions-dark.png')
  }}
/>

## Handling Authentication Requests

To handle incoming authentication requests, subscribe to the authenticateRequestPublisher. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```swift
Web3Wallet.instance.authenticateRequestPublisher
    .receive(on: DispatchQueue.main)
    .sink { result in
        // Process the authentication request here.
        // This involves displaying UI to the user.
    }
    .store(in: &subscriptions) // Assuming `subscriptions` is where you store your Combine subscriptions.
```

## Authentication Objects/Payloads

To interact with authentication requests, first build authentication objects (AuthObject). These objects are crucial for approving authentication requests. This involves:

- **Creating an Authentication Payload** - Generate an authentication payload that matches your application's supported chains and methods.
- **Formatting Authentication Messages** - Format the authentication message using the payload and the user's account.
- **Signing the Authentication Message** - Sign the formatted message to create a verifiable authentication object.

Example Implementation:

```swift
func buildAuthObjects(request: AuthenticationRequest, account: Account, privateKey: String) throws -> [AuthObject] {
    let requestedChains = Set(request.payload.chains.compactMap { Blockchain($0) })
    let supportedChains: Set<Blockchain> = [Blockchain("eip155:1")!, Blockchain("eip155:137")!, Blockchain("eip155:69")!]
    let commonChains = requestedChains.intersection(supportedChains)
    let supportedMethods = ["personal_sign", "eth_sendTransaction"]

    var authObjects = [AuthObject]()
    for chain in commonChains {
        let accountForChain = Account(blockchain: chain, address: account.address)!
        let supportedAuthPayload = try Web3Wallet.instance.buildAuthPayload(
            payload: request.payload,
            supportedEVMChains: Array(commonChains),
            supportedMethods: supportedMethods
        )
        let formattedMessage = try Web3Wallet.instance.formatAuthMessage(payload: supportedAuthPayload, account: accountForChain)
        let signature = // Assume `signMessage` is a function you've implemented to sign messages.
            signMessage(message: formattedMessage, privateKey: privateKey)

        let authObject = try Web3Wallet.instance.buildSignedAuthObject(
            authPayload: supportedAuthPayload,
            signature: signature,
            account: accountForChain
        )
        authObjects.append(authObject)
    }
    return authObjects
}

```

## Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

:::

To approve an authentication request, construct AuthObject instances for each supported blockchain, sign the authentication messages, build AuthObjects and call approveSessionAuthenticate with the request ID and the authentication objects.

```swift
let session = try await Web3Wallet.instance.approveSessionAuthenticate(requestId: requestId, auths: authObjects)
```

## Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```swift
try await Web3Wallet.instance.rejectSession(requestId: requestId)
```

## Testing One-click Auth

You can use [AppKit Lab](https://lab.web3modal.com/library/ethers-siwe/) to test and verify that your wallet supports One-click Auth properly.

<Button name="Test One-click Auth" url="https://lab.web3modal.com/library/ethers-siwe/" />
</file>

<file path="docs/walletkit/ios/resources.mdx">
# Resources

Valuable assets for developers and users interested in integrating WalletKit into their applications.

- [Awesome WalletConnect](https://github.com/WalletConnect/awesome-walletconnect) - Community-curated collection of WalletConnect-enabled wallets, libraries, and tools.
- [AppKit Laboratory](https://lab.web3modal.com) - A place to test your wallet integrations against various setups of AppKit.
- [WalletKit GitHub](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet) - WalletKit GitHub repository.

### Wallet Resources

To check more in details go and visit our [WalletKit Swift implementation app](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example/WalletApp). Sample Wallet and Dapp sample apps can be found under the Example directory in [Swift's V2 repository](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example)

If you need to test your app's integration, you can use one of our following demo dapps.

**Sign**

- [React dApp (with standalone client) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2) ([Demo](https://react-app.walletconnect.com/))
- [React dApp (with EthereumProvider + Ethers.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-ethers) ([Demo](https://react-dapp-v2-with-ethers.vercel.app/))
- [React dApp (with EthereumProvider + web3.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-web3js) ([Demo](https://react-dapp-v2-with-web3js.vercel.app/))
- [React dApp (with CosmosProvider) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-cosmos-provider) ([Demo](https://react-dapp-v2-cosmos-provider.vercel.app/))

### Dapp Resources

Sample Dapp can be found under the Example directory in [Swift's V2 repository](https://github.com/WalletConnect/WalletConnectSwiftV2/tree/main/Example)

You can test your integration against Swift Sample Wallet that is included in the same repo or use the following JS React Wallet:

- [React Wallet Ethers - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/wallets/react-wallet-v2) ([Demo](https://react-wallet.walletconnect.com/))
</file>

<file path="docs/walletkit/ios/usage.mdx">
import CloudBanner from '../../components/CloudBanner'

# Usage

This section provides instructions on how to initialize the WalletKit client, approve sessions with supported namespaces, and respond to session requests, enabling easy integration of Web3 wallets with dapps through a simple and intuitive interface.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out **Extra (Platform Specific)** under this section.

**[Initialization](#initialization)**: Creating a new WalletKit instance and initializing it with a projectId from [Cloud](https://cloud.walletconnect.com).

**Session**: Connection between a dapp and a wallet.

- [Namespace Builder](#namespace-builder):
  Namespace Builder is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns a ready-to-use object
- [Session Approval](#session-approval):
  Approving a session sent from a dapp
- [Session Rejection](#session-rejection):
  Rejecting a session sent from a dapp
- [Responding to Session Requests](#responding-to-session-requests):
  Responding to session requests sent from a dapp
- [Updating a Session](#updating-a-session):
  Updating a session sent between a dapp and wallet
- [Extending a Session](#extending-a-session):
  Extending a session between a dapp and wallet
- [Session Disconnect](#session-disconnect):
  Disconnecting a session between a dapp and wallet
- [Register Device Token](#register-device-token)
  Enabling Wallet Push Notifications by registering a device token.
- [Subscribe for WalletKit Publishers](#subscribe-for-web3wallet-publishers)
  Publishers available to subscribe to for WalletKit

<CloudBanner />

## Initialization

Confirm you have configured the [Network Client](../../api/core/relay.mdx) first.

Starting from WalletConnect SDK version 1.9.5, the `redirect` field in the `AppMetadata` object is mandatory. Ensure that the provided value matches your app's URL scheme to prevent redirection-related issues.

Once you're done, in order to initialize a client just call a `configure` method from the Web3Wallet instance wrapper

```swift
let metadata = AppMetadata(
    name: "Example Wallet",
    description: "Wallet description",
    url: "example.wallet",
    icons: ["https://avatars.githubusercontent.com/u/37784886"],
    redirect: AppMetadata.Redirect(native: "example://", universal: nil)
)

Web3Wallet.configure(
    metadata: metadata,
    crypto: DefaultCryptoProvider(),
    // Used for the Push: "echo.walletconnect.com" will be used by default if not provided
    pushHost: "echo.walletconnect.com",
    // Used for the Push: "APNSEnvironment.production" will be used by default if not provided
    environment: .production
)
```

In order to allow users to receive push notifications you have to communicate with Apple Push Notification service and receive unique device token. Register that token with following method:

```swift
try await Web3Wallet.instance.register(deviceToken: deviceToken)
```

## Session

A session is a connection between a dapp and a wallet. It is established when a user approves a session proposal from a dapp. A session is active until the user disconnects from the dapp or the session expires.

### Namespace Builder

`AutoNamespaces` is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns ready-to-use `SessionNamespace` object.

```swift
public static func build(
    sessionProposal: Session.Proposal,
    chains: [Blockchain],
    methods: [String],
    events: [String],
    accounts: [Account]
) throws -> [String: SessionNamespace]
```

Example usage

```swift
do {
    sessionNamespaces = try AutoNamespaces.build(
        sessionProposal: proposal,
        chains: [Blockchain("eip155:1")!, Blockchain("eip155:137")!],
        methods: ["eth_sendTransaction", "personal_sign"],
        events: ["accountsChanged", "chainChanged"],
        accounts: [
            Account(blockchain: Blockchain("eip155:1")!, address: "0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!,
            Account(blockchain: Blockchain("eip155:137")!, address: "0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
        ]
    )
} catch let error as AutoNamespacesError {
    // reject session proposal if AutoNamespace build function threw
    try await reject(proposal: proposal, reason: RejectionReason(from: error))
    return
}
// approve session with sessionNamespaces
try await Web3Wallet.instance.approve(proposalId: proposal.id, namespaces: sessionNamespaces)

```

### EVM methods & events

In @walletconnect/ethereum-provider, (our abstracted EVM SDK for apps) we support by default the following Ethereum methods and events:

```ts
{
  //...
  methods: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_getCapabilities",
  ],
  events: [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect",
  ]
}
```

### Session Approval

```swift
 Web3Wallet.instance.approve(
    proposalId: "proposal_id",
    namespaces: sessionNamespaces
)
```

When session is successfully approved `sessionsPublishers` will publish a `Session`

```swift
Web3Wallet.instance.sessionsPublishers
    .receive(on: DispatchQueue.main)
    .sink { [weak self] _ in
        self?.reloadSessions()
    }.store(in: &publishers)
```

`Session` object represents an active session connection with a dapp. It contains dapp‚Äôs metadata (that you may want to use for displaying an active session to the user), namespaces, and expiry date. There is also a topic property that you will use for linking requests with related sessions.

You can always query settled sessions from the client later with:

```swift
Web3Wallet.instance.getSessions()
```

#### Connect Clients

Your Wallet should allow users to scan a QR code generated by dapps. You are responsible for implementing it on your own.
For testing, you can use our test dapp at: https://react-app.walletconnect.com/, which is v2 protocol compliant.
Once you derive a URI from the QR code call `pair` method:

```swift
try await Web3Wallet.instance.pair(uri: uri)
```

if everything goes well, you should handle following event:

```swift
Web3Wallet.instance.sessionProposalPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] session in
        self?.verifyDapp(session.context)
        self?.showSessionProposal(session.proposal)
    }.store(in: &publishers)
```

Session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Handshake procedure is defined by [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md).
`Session.Proposal` object conveys set of required and optional `ProposalNamespaces` that contains blockchains methods and events. Dapp requests with methods and wallet will emit events defined in namespaces.

`VerifyContext` provides a domain verification information about `Session.Proposal` and `Request`. It consists of origin of a Dapp from where the request has been sent, validation enum that says whether origin is **unknown**, **valid** or **invalid** and verify URL server.

To enable or disable verification find the **Verify SDK** toggle in your project [cloud](https://cloud.walletconnect.com).

```swift
public struct VerifyContext: Equatable, Hashable {
   public enum ValidationStatus {
       case unknown
       case valid
       case invalid
   }

   public let origin: String?
   public let validation: ValidationStatus
   public let verifyUrl: String
}
```

The user will either approve the session proposal (with session namespaces) or reject it. Session namespaces must at least contain requested methods, events and accounts associated with proposed blockchains.

Accounts must be provided according to [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md) specification and be prefixed with a chain identifier. chain_id + : + account_address. You can find more on blockchain identifiers in [CAIP2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md). Our `Account` type meets the criteria.

```
let account = Account("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
```

Accounts sent in session approval must at least match all requested blockchains.

Example proposal namespaces request:

```json
{
  "eip155": {
    "chains": ["eip155:137", "eip155:1"],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "chains": ["cosmos:cosmoshub-4"],
    "methods": ["cosmos_signDirect"],
    "events": ["someCosmosEvent"]
  }
}
```

Example session namespaces response:

```json
{
  "eip155": {
    "accounts": [
      "eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb",
      "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"
    ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "accounts": ["cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"],
    "methods": ["cosmos_signDirect", "personal_sign"],
    "events": ["someCosmosEvent", "proofFinalized"]
  }
}
```

#### Track Sessions

When your `Web3Wallet` instance receives requests from a peer it will publish a related event. Set a subscription to handle them.

To track sessions subscribe to `sessionsPublisher` publisher

```swift
Web3Wallet.instance.sessionsPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] sessions in
        // Reload UI
    }.store(in: &publishers)
```

### Session Rejection

```swift
try await Web3Wallet.instance.reject(requestId: request.id)
```

### Responding to Session requests

After the session is established, a dapp will request your wallet's users to sign a transaction or a message. Requests will be delivered by the following publisher.

```swift
Web3Wallet.instance.sessionRequestPublisher
  .receive(on: DispatchQueue.main)
  .sink { [weak self] session in
      self?.verifyDapp(session.context)
      self?.showSessionRequest(session.request)
  }.store(in: &publishers)
```

When a wallet receives a session request, you probably want to show it to the user. It‚Äôs method will be in scope of session namespaces. And it‚Äôs params are represented by `AnyCodable` type. An expected object can be derived as follows:

```swift
if sessionRequest.method == "personal_sign" {
    let params = try! sessionRequest.params.get([String].self)
} else if method == "eth_signTypedData" {
    let params = try! sessionRequest.params.get([String].self)
} else if method == "eth_sendTransaction" {
    let params = try! sessionRequest.params.get([EthereumTransaction].self)
}
```

Now, your wallet (as it owns your user‚Äôs private keys) is responsible for signing the transaction. After doing it, you can send a response to a dapp.

```swift
let response: AnyCodable = sign(request: sessionRequest) // Implement your signing method
try await Web3Wallet.instance.respond(topic: request.topic, requestId: request.id, response: .response(response))
```

### Updating a Session

If you want to update user session's chains, accounts, methods or events you can use session update method.

```swift
try await Web3Wallet.instance.update(topic: session.topic, namespaces: newNamespaces)
```

### Extending a Session

By default, session lifetime is set for 7 days and after that time user's session will expire. But if you consider that a session should be extended you can call:

```swift
try await Web3Wallet.instance.extend(topic: session.topic)
```

Above method will extend a user's session to a week.

### Session Disconnect

For good user experience your wallet should allow users to disconnect unwanted sessions. In order to terminate a session use `disconnect` method.

```swift
try await Web3Wallet.instance.disconnect(topic: session.topic)
```

### Subscribe for Web3Wallet Publishers

The following publishers are available to subscribe:

```swift
public var sessionProposalPublisher: AnyPublisher<(proposal: Session.Proposal, context: VerifyContext?), Never>
public var sessionRequestPublisher: AnyPublisher<(request: Request, context: VerifyContext?), Never>
public var authRequestPublisher: AnyPublisher<(request: AuthRequest, context: VerifyContext?), Never>
public var sessionPublisher: AnyPublisher<[Session], Never>
public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
public var sessionSettlePublisher: AnyPublisher<Session, Never>
public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
public var sessionResponsePublisher: AnyPublisher<Response, Never>
```

### Register Device Token

To register a wallet to receive WalletConnect push notifications, call `register` method and pass the device token received from the `didRegisterForRemoteNotificationsWithDeviceToken` method in the `AppDelegate`.

```swift

Web3Wallet.instance.register(deviceToken: deviceToken, enableEncrypted: true)

```
</file>

<file path="docs/walletkit/ios/verify.mdx">
# Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.
Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).
For those looking to enable Verify on the app side, check out our reference guide [here.](./cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

These are:

![Verify Banner](/img/verify-banner.png)

## Disclaimer

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

## Domain risk detection

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either `VALID`, `INVALID` or `UNKNOWN`.

- Domain match: The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `VALID`.
- Unverified: The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `UNKNOWN`.
- Mismatch: The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `INVALID`
- Threat: This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The `verifyContext` included in the request will contain parameter `isScam` with value `true`.

### Implementation

VerifyContext provides a domain verification information about Session.Proposal and Request and is relevant to the `verifyDapp` function.

It consists of origin of an app from where the request has been sent, validation enum that says whether origin is unknown, valid or invalid and verify URL server.

```swift
public struct VerifyContext: Equatable, Hashable {
   public enum ValidationStatus {
       case unknown
       case valid
       case invalid
   }

   public let origin: String?
   public let validation: ValidationStatus
   public let verifyUrl: String
}
```
</file>

<file path="docs/walletkit/react-native/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/walletkit/react-native/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import ExplorerSubmission from '../../../cloud/explorer-submission.mdx'

<ExplorerSubmission />
</file>

<file path="docs/walletkit/react-native/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/walletkit/react-native/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/walletkit/react-native/notifications/notify/installation.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Installation

Install the WalletConnect NotifyClient package.

```
yarn add @walletconnect/notify-client @walletconnect/react-native-compat
```

You will need to polyfill crypto depending on your environment. See instructions below.

<Tabs
queryString="rn-method"
	values={[
		{ label: 'Expo', value: 'expo', },
		{ label: 'React Native CLI', value: 'rn-cli', },
	]}
>
<TabItem value="expo">

```
yarn add expo-crypto
```

1. Create a file called `expo-crypto-shim.js` at the root of your project
2. Go to `expo-crypto-shim.js`and paste the following snippet into it.

```js
import { digest } from 'expo-crypto'

// eslint-disable-next-line no-undef
const webCrypto = typeof crypto !== 'undefined' ? crypto : new Crypto()
webCrypto.subtle = {
  digest: (algo, data) => {
    const buf = Buffer.from(data)
    return digest(algo, buf)
  }
}
;(() => {
  if (typeof crypto === 'undefined') {
    Object.defineProperty(window, 'crypto', {
      configurable: true,
      enumerable: true,
      get: () => webCrypto
    })
  }
})()
```

3. Then head over your `index.js` file at the root of your project and add the following imports.

```js
import '@walletconnect/react-native-compat'
import './expo-crypto-shim.js'
```

</TabItem>
<TabItem value="rn-cli">

```
yarn add react-native-quick-crypto react-native-quick-base64 stream-browserify @craftzdog/react-native-buffer babel-plugin-module-resolver
```

For iOS only

```bash
cd ios && pod install
```

1. Go to your `index.js` file at the root of your project and add the following polyfill

```js
import { AppRegistry } from 'react-native'
import App from './App'
import { name as appName } from './app.json'
import crypto from 'react-native-quick-crypto'

const polyfillDigest = async (algorithm, data) => {
  const algo = algorithm.replace('-', '').toLowerCase()
  const hash = crypto.createHash(algo)
  hash.update(data)
  return hash.digest()
}

globalThis.crypto = crypto
globalThis.crypto.subtle = {
  digest: polyfillDigest
}

AppRegistry.registerComponent(appName, () => App)
```

2. Update your `babel.config.js` with the following configuration

```js
module.exports = {
  presets: ['module:metro-react-native-babel-preset'],
  plugins: [
   [
     'module-resolver',
     {
       alias: {
         'crypto': 'react-native-quick-crypto',
         'stream': 'stream-browserify',
         'buffer': '@craftzdog/react-native-buffer',
       },
     },
   ],
    ...
  ],
};
```

</TabItem>
</Tabs>

## Next Steps

Now that you've installed WalletConnect Notify, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the Notify API.
</file>

<file path="docs/walletkit/react-native/notifications/notify/overview.mdx">
# Overview

:::info
For those integrating notifications related to wallet pairing and sign requests, please check [here](../push.mdx).
:::

The WalletKit Notify API is designed to enhance the interaction between wallet users and dapps by offering a robust notification system. This API empowers wallet developers to implement a dynamic notification experience directly within their wallets. It provides the functionality for users to opt-in to notifications, ensuring they stay informed about critical events and interactions.

The Notify API is versatile, with support for both iOS and Android platforms, making it an ideal choice for cross-platform wallet applications.

Coupled with the [AppKit Notifications](../../../../appkit/react-native/notifications/overview), the Notify API forms part of a comprehensive toolkit that enables seamless integration of web3 communication and messaging features into dapps. This ensures a more connected and interactive experience for users in the decentralized ecosystem.

## Features

Some of the key features of the Notify API include:

- **Push Notifications for Desktop and Native Platforms**: This feature enables dapps to directly send vital notifications to user wallets, ensuring timely and relevant communication.
- **Robust Spam Protection**: Users have complete authority over which dapps can send them notifications, effectively eliminating any unsolicited messages from unknown sources. Furthermore, users can fine-tune their preferences to only receive notifications types they are interested in, like new features or some important events occurence.
- **Chain Agnostic Architecture**: The Notify API is built to be compatible with any blockchain, allowing seamless multi-chain support without the need for writing additional integration code. **As of November 2023, the Notify Server and Clients are equipped to support EVM chains. Plans to extend support to non-EVM chains are in progress and are a significant part of our upcoming development roadmap.**

_Example integration_
![Web3Inbox](/assets/web3inbox/w3i-hero.png)
</file>

<file path="docs/walletkit/react-native/notifications/notify/spam-protection.mdx">
# Spam Protection

Users play a critical role in web3. That‚Äôs why, with Web3Inbox, we‚Äôre committed to ensuring users can enjoy a safe, seamless, and reliable experience that puts them in the driver‚Äôs seat. As part of that pledge, Web3Inbox provides a number of user-first, anti-spam features and elements that ensure users are always in control of their web3 communications.

## How are users protected from spam with Web3Inbox?

### Becoming a Web3Inbox customer

When a wallet offers app notifications to their users via Web3Inbox, the feature will always be optional. If users decide they want to receive notifications from selected apps via their wallet, they‚Äôll be able to ‚Äòopt-in‚Äô and subscribe to an app‚Äôs notifications by signing a message request. Similarly, when accessing notifications through the [Web3Inbox.com app](https://app.web3inbox.com), users will be met with the same request for each application they choose to subscribe to. This feature not only enables users to experience a customized, ‚Äòapp-by-app‚Äô approach to staying connected in web3, but also ensures they only ever hear from the apps they choose to ‚Äî no unsolicited notifications or spam from unknown senders. Its their curated inbox, connected with only those they choose.

### Setting customized notification preferences

Once users have subscribed to their chosen apps, they have the option to define and set which types of notifications they receive from those apps. For example, a user may wish to receive only information regarding changes to their portfolio from a DEX, or, they might want to receive notifications from an NFT marketplace ‚Äî but only notifications regarding their own NFT collections. In these scenarios, they‚Äôll have the ability to disable other notification types, like marketing updates, and ensure their feed is curated to show only information that‚Äôs meaningful to them. As apps set their own notification types, they have unlimited optionality to really build out a notification structure they know can support their users‚Äô needs ‚Äî no ‚Äòone size fits all‚Äô approach, but a personable, community-oriented structure that puts both app and user needs‚Äô at the forefront of communication.

### Rate limiting

Apps are limited to a maximum number of notifications they‚Äôre able to send to their community. Specifically, apps may send accounts notifications twice an hour on average, but may exceeed that average in bursts of up to 50 at a time.

## Our continued pledge on spam protection

We‚Äôre constantly working on improving and growing our products, and we have a number of impactful anti-spam features and functions in the works set to increase the overall protection and user experience of Web3Inbox users:

### User reporting

Users will have the ability to report applications that appear to be acting or engaging with their community in a malicious or suspicious manner. Projects that are flagged as malicious may be removed from the Web3Inbox discover page and have notification functionality disabled.
</file>

<file path="docs/walletkit/react-native/notifications/notify/usage.mdx">
import CloudBanner from '../../../../components/CloudBanner'

# Usage

In this section, we showcase the aspects of using the Notify API. We'll guide you through the initial steps of initializing the Notify client and logging in a blockchain account. You'll also learn how to manage your subscriptions and messages. Additionally, we cover the process of setting up and displaying push notifications on your preferred platform. To ensure a good user experience, we include best practices for spam protection, helping you to enable the users to maintain control over the notifications wallet receives.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out¬†Extra (Platform Specific)¬†under this section.

- [Initialization](#initialization):
  Creating a new Notify Client instance and initializing it with a projectId from¬†[Cloud](https://cloud.walletconnect.com/).
- [Account login](#account-login):
  A SIWE message must be signed by the user in order to authorize the client to use Notify API
- [Subscribing to a new dapp](#subscribing-to-a-new-dapp):
  Opt-in to receive notifications from dapp
- [Fetching active subscriptions](#fetching-active-subscriptions):
  Get active subscriptions
- [Fetching subscription‚Äôs notification](#fetching-subscriptions-notifications):
  Get notifications of a subscription
- [Fetching available notification types](#fetching-available-notification-types):
  Get latest notification types
- [Updating subscriptions notification settings](#updating-subscriptions-notification-settings):
  Change allowed notification types sent by dapp
- [Unsubscribe from a dapp](#unsubscribe-from-a-dapp):
  Opt-out from receiving notifications from a dapp
- [Account logout](#account-logout):
  To stop receiving notifications to this client, accounts can logout of using Notify API
- [Push Notification Setup](#push-notification-setup):
  Configuring app in order to decrypt notifications

## Initialization

<CloudBanner />

#### Initialize the SDK clients

```javascript
import { NotifyClient } from '@walletconnect/notify-client'

const notifyClient = await NotifyClient.init({
  projectId: '<YOUR PROJECT ID>'
})
```

## Add listeners for relevant events

```javascript
// Handle response to a `notifyClient.subscribe(...)` call
notifyClient.on('notify_subscription', async ({ params }) => {
  const { error } = params

  if (error) {
    // Setting up the subscription failed.
    // Inform the user of the error and/or clean up app state.
    console.error('Setting up subscription failed: ', error)
  } else {
    // New subscription was successfully created.
    // Inform the user and/or update app state to reflect the new subscription.
    console.log(`Subscribed successfully.`)
  }
})

// Handle an incoming notification
notifyClient.on('notify_message', ({ params }) => {
  const { message } = params
  // e.g. build a notification using the metadata from `message` and show to the user.
})

// Handle response to a `notifyClient.update(...)` call
notifyClient.on('notify_update', ({ params }) => {
  const { error } = params

  if (error) {
    // Updating the subscription's scope failed.
    // Inform the user of the error and/or clean up app state.
    console.error('Setting up subscription failed: ', error)
  } else {
    // Subscription's scope was updated successfully.
    // Inform the user and/or update app state to reflect the updated subscription.
    console.log(`Successfully updated subscription scope.`)
  }
})

// Handle a change in the existing subscriptions (e.g after a subscribe or update)
notifyClient.on('notify_subscriptions_changed', ({ params }) => {
  const { subscriptions } = params
  // `subscriptions` will contain any *changed* subscriptions since the last time this event was emitted.
  // To get a full list of subscriptions for a given account you can use `notifyClient.getActiveSubscriptions({ account: 'eip155:1:0x63Be...' })`
})
```

## Account login

In order to register account in Notify API to be able to subscribe to any dapp to start receving notifications, account needs to sign SIWE message to prove ownership. Developers can check if an account is registered by calling **`isRegistered()`** function. If the account is not registered, developers should call **`prepareRegistration()`** and then **`register()`** function to register the account.

:::note
This is a one-time action per account. It does not need to be repeated after initial registration of the new account.
:::

### Registering as a wallet

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`
const domain =  'app.mydomain.com', // pass the domain (i.e. the hostname) where your dapp is hosted.
const allApps =  true // The user will be prompted to authorize this wallet to send and receive messages on their behalf for ALL domains using their WalletConnect identity.

// No need to register and sign message if already registered.
if (notifyClient.isRegistered({ account, domain, allApps })) return;

const {registerParams, message}  = notifyClient.prepareRegistration({
  account,
  domain,
  allApps
});

const signature = await ethersWallet.signMessage(message);

await notifyClient.register({
  registerParams,
  signature,
})
```

## Subscribing to a new dapp

To begin receiving notifications from a dapp, users must opt-in by subscribing. This subscription process grants permission for the dapp to send notifications to the user. These notifications can serve a variety of purposes, such as providing updates on the user's blockchain account activities or informing them about ongoing campaigns within the dapp. Upon initial subscription, clients will be automatically enrolled to receive all types of notifications as defined by the dapp at that moment. Users have the flexibility to modify their notification settings later, allowing them to tailor the types of alerts they receive according to their preferences.

:::info
To identify dapps that can be subscribed to via Notify, we can query the following Explorer API endpoint:

https://explorer-api.walletconnect.com/v3/dapps?projectId=YOUR_PROJECT_ID&is_notify_enabled=true
:::

```javascript
// Get the domain of the target dapp from the Explorer API response
const appDomain = new URL(fetchedExplorerDapp.platform_browser).hostname

// Subscribe to `fetchedExplorerDapp` by passing the account to be subscribed and the domain of the target dapp.
await notifyClient.subscribe({
  account,
  appDomain
})

// -> Success/Failure will be received via the `notify_update` event registered previously.
// -> New subscription will be emitted via the `notify_subscriptions_changed` watcher event.
```

## Fetching active subscriptions

To fetch the current list of subscriptions an account has, call **`getActiveSubscriptions()`**.

```javascript
// Will return all active subscriptions for the provided account, keyed by subscription topic.
const accountSubscriptions = notifyClient.getActiveSubscriptions({
  account: `eip155:1:0x63Be...`
})
```

## Fetching subscription‚Äôs notifications

To fetch subscription‚Äôs notifications by calling **`getNotificationHistory()`**.

```javascript
const notifications = notifyClient.getNotificationHistory(account)
```

## Fetching available notification types

Developers can fetch latest notification types specified by dapp by calling **`getNotificationTypes()`**¬†function.

You can use the `scope` object of the subscription to get the available notification types.

```typescript
// get notification types by accessing `scope` member of a dapp's subscription
const notificationTypes = notifyClient
  .getActiveSubscriptions({ account })
  .filter(subscription => subscription.topic === topic).scope
```

## Updating subscriptions notification settings

Users can alter their notification settings to filter out unwanted alerts from a dapp. During this process, they review and select the types of notifications they wish to receive, based on the latest options provided by the dapp. Available notification types fetching is shown in the [next section](#fetching-available-notification-types).

```javascript
// `topic` - subscription topic of the subscription that should be updated.
// `scope` - an array of notification types that should be enabled going forward. The current scopes can be found under `subscription.scope`.
await notifyClient.update({
  topic,
  scope: ['alerts']
})
```

## Unsubscribe from a dapp

To opt-out of receiving notifications from a dap, a user can decide to unsubscribe from dapp.

```javascript
notifyClient.deleteSubscription({ topic: 'subscription_topic_to_unsubscribe_from' })
```

## Account logout

If an account is removed from the client or a user no longer wants to receive notifications for this account, you can logout the account from Notify API by calling **`unregister()`**. This will remove all subscriptions and messages for this account from the client‚Äôs storage.

```javascript
const account = `eip155:1:0x63Be2c680685d2A9620c11b0068291261aa62d76`

await notifyClient.unregister({
  account
})
```

## Fetch notification history (Pagination)

There might be different approaces to implement pagination in your app depending on your needs. You can see the following example implemented with `FlatList` which introduces infinite scroll functionality with a basic example:

Please make sure you have better handling of the notify client instance which handles worst cases by checking initialization status, account status, for production ready apps.

```javascript
export default function SubscriptionDetailsScreen() {
  const {topic} = useRoute().params as {topic: string};
  const [notifications, setNotifications] = React.useState([]);
  const [hasMore, setHasMore] = React.useState(false);
  const [isLoading, setIsLoading] = React.useState(false);

  const lastItem = notifications?.[notifications.length - 1]?.id;

  async function getNotificationHistory(startingAfter?: string) {
    setIsLoading(true);

    const notificationHistory = await notifyClient.getNotificationHistory({
      topic,
      limit: 15,
      startingAfter,
    });

    setNotifications(
      prevNotifications => prevNotifications.concat(notificationHistory.notifications),
    );
    setHasMore(notificationHistory.hasMore);
    setIsLoading(false);

    return notificationHistory;
  }

  React.useEffect(() => {
    getNotificationHistory();
  }, [topic]);

  return (
    <FlatList
      data={sortedByDate}
      keyExtractor={item => item.sentAt.toString()}
      onEndReached={() => {
        if (hasMore && lastItem) {
          getNotificationHistory(lastItem)
        }
      }}
      ListFooterComponent={() => {
        if (!isLoading) return null
        return <NotifcationItemSkeleton />
      }}
      renderItem={({item}) => (
        <NotificationItem key={item.id} item={item} />
      )}
    />
  );
}
```

### Push Notification Setup

Install [`@react-native-firebase/app`](https://www.npmjs.com/package/@react-native-firebase/app), [`@react-native-firebase/messaging`](https://www.npmjs.com/package/@react-native-firebase/messaging) and [`@notifee/react-native`](https://www.npmjs.com/package/@notifee/react-native) to handle Push Notifications.
Please refer to the respective package documentation to configure them properly.

```
yarn add @notifee/react-native @react-native-firebase/app @react-native-firebase/messaging
```

Update your `index.js` file to include the following logic.

```js
import { AppRegistry } from 'react-native'
import { name as appName } from './app.json'
import crypto from 'react-native-quick-crypto'

import messaging from '@react-native-firebase/messaging'
import notifee, { AndroidImportance, AndroidVisibility, EventType } from '@notifee/react-native'
import { NotifyClient } from '@walletconnect/notify-client'
import { decryptMessage } from '@walletconnect/notify-message-decrypter'

import App from './src/App'

const polyfillDigest = async (algorithm, data) => {
  const algo = algorithm.replace('-', '').toLowerCase()
  const hash = crypto.createHash(algo)
  hash.update(data)
  return hash.digest()
}

globalThis.crypto = crypto
globalThis.crypto.subtle = {
  digest: polyfillDigest
}

// Create notification channel (Android only feature)
notifee.createChannel({
  id: 'default',
  name: 'Default Channel',
  lights: false,
  vibration: true,
  importance: AndroidImportance.HIGH,
  visibility: AndroidVisibility.PUBLIC
})

let notifyClient

const projectId = process.env.ENV_PROJECT_ID

async function registerAppWithFCM() {
  // This is expected to be automatically handled on iOS. See https://rnfirebase.io/reference/messaging#registerDeviceForRemoteMessages
  if (Platform.OS === 'android') {
    await messaging().registerDeviceForRemoteMessages()
  }
}

async function registerClient(deviceToken, clientId) {
  const body = JSON.stringify({
    client_id: clientId,
    token: deviceToken,
    type: 'fcm',
    always_raw: true
  })

  const requestOptions = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body
  }

  return fetch(`https://echo.walletconnect.com/${projectId}/clients`, requestOptions)
    .then(response => response.json())
    .then(result => console.log('>>> registered client', result))
    .catch(error => console.log('>>> error while registering client', error))
}

async function handleGetToken(token) {
  const status = await messaging().requestPermission()
  const enabled =
    status === messaging.AuthorizationStatus.AUTHORIZED ||
    status === messaging.AuthorizationStatus.PROVISIONAL

  if (enabled) {
    notifyClient = await NotifyClient.init({ projectId })
    const clientId = await notifyClient.core.crypto.getClientId()
    return registerClient(token, clientId)
  }
}

messaging().getToken().then(handleGetToken)
messaging().onTokenRefresh(handleGetToken)

async function onMessageReceived(remoteMessage) {
  if (!remoteMessage.data?.blob || !remoteMessage.data?.topic) {
    console.log('Missing blob or topic on notification message.')
    return
  }

  const decryptedMessage = await decryptMessage({
    topic: remoteMessage.data?.topic,
    encryptedMessage: remoteMessage.data?.blob
  })

  return notifee.displayNotification({
    title: decryptedMessage.title,
    body: decryptedMessage.body,
    id: 'default',
    android: {
      channelId: 'default',
      importance: AndroidImportance.HIGH,
      visibility: AndroidVisibility.PUBLIC,
      smallIcon: 'ic_launcher', // optional, defaults to 'ic_launcher'.
      // pressAction is needed if you want the notification to open the app when pressed. See https://notifee.app/react-native/docs/ios/interaction#press-action
      pressAction: {
        id: 'default'
      }
    }
  })
}

messaging().onMessage(onMessageReceived)
messaging().setBackgroundMessageHandler(onMessageReceived)

notifee.onBackgroundEvent(async ({ type, detail }) => {
  const { notification, pressAction } = detail

  // Check if the user pressed the "Mark as read" action
  if (type === EventType.ACTION_PRESS && pressAction.id === 'mark-as-read') {
    // Remove the notification
    await notifee.cancelNotification(notification.id)
  }
})

function HeadlessCheck({ isHeadless }) {
  if (isHeadless) {
    // App has been launched in the background by iOS, ignore
    return null
  }

  // Render the app component on foreground launch
  return <App />
}

AppRegistry.registerComponent(appName, () => HeadlessCheck)
```
</file>

<file path="docs/walletkit/react-native/notifications/push.mdx">
# Push Notifications

WalletKit provides the functionality for wallets to receive push notifications through Firebase Cloud Messaging (FCM) and Apple Push Notification Service (APNs) via the Push Server. This feature ensures that wallets are promptly notified of incoming signature requests. Each push notification contains the encrypted details of the signature request. Upon receiving the notification, it can be decrypted and presented to the developer, allowing for customization of the message according to their requirements.

## Server setup

For the push notifications to be forwarded to FCM or APNs, the [Push Server](../../../advanced/push-server) will need to be configured with your FCM or APNs server API credentials.

## App setup

### Register the device token

To enable a device for push notifications, it's essential to register the device token using `Web3Wallet.registerDeviceToken`. This token can be obtained from either FCM or APNS, depending on the platform used.

To receive push notifications from WalletConnect's Push Server via Firebase Cloud Messaging, you will need to setup Firebase in your project. 
You can follow their docummentation - [Firebase documentation](https://rnfirebase.io/messaging/usage#installation). 
Once you have Firebase configured, you can obtain the device token by calling `messaging().getToken()`. This unique token is used to identify each device.

```ts
import messaging from '@react-native-firebase/messaging'

const token = await messaging().getToken()
```

The device token will be used to register for WalletConnect push notifications by calling `Web3Wallet.registerDeviceToken` and passing the token as an argument.
The `registerDeviceToken` should be called every time the client is initialized.

```ts
web3wallet.registerDeviceToken({
  token: await messaging().getToken(), // device token
  clientId: await web3wallet.core.crypto.getClientId(), //your instance clientId
  notificationType: 'fcm', // notification type
  enableEncrypted: true // flag that enabled detailed notifications
})
```

With that the base setup is complete and you can start receiving push notifications from WalletConnect's Push Server for your sessions.

Note, that from time to time, the device token is refreshed, so you must make sure to register it again.

```ts
impoprt messaging from '@react-native-firebase/messaging';

messaging().onTokenRefresh(async token => {
    await web3wallet.registerDeviceToken({
        token: await messaging().getToken(), // device token
        clientId: await web3wallet.core.crypto.getClientId(), //your instance clientId
        notificationType: 'fcm', // notification type
        enableEncrypted: true // flag that enabled detailed notifications
    });
});
```

### Receiving push notifications

After the device token is registered, the next step involves setting up the notification service specific to the platform being used. This service will decrypt the incoming requests and forward them to the developer for further processing and integration.

To receive the actual push notifications, you will need to subscribe to firebase messaging events.

```ts
import messaging from '@react-native-firebase/messaging';

// emitted when the app is open and a notification is received
messaging().onMessage(async notification => {
    ...
});

// emitted when the app is in the background or closed and a notification is received
messaging().setBackgroundMessageHandler(async notification => {
    ...
});

```

Now that we have the notifications listeners setup, we can start processing the incoming notifications.

```ts
import { Web3Wallet } from '@walletconnect/web3wallet';
import messaging from '@react-native-firebase/messaging';

messaging().onMessage(async notification => {
    // get the topic, encrypted message & tag from the notification payload
    const { topic, message, tag } = notification.data;

    // decrypt the message
    // note this is static method and can be called without initializing the Web3Wallet
    const decryptedMessage = await Web3wallet.notifications.decryptMessage({
    topic,
    encryptedMessage: message,
  });

    /*
    * `decryptedMessage` is JsonRpcRequest object, with the full payload of the incoming request such as method, params, id, etc.
    * You can use it to emit local push notification with the request to the user and ask for their approval.
    **/

   /*
   * the metadata contains name, description, icon and url of the dapp that initiated the request
   * note that only notifications with tag `1108`(session requests) will have metadata,
   **/
   let metadata

   if(tag == 1108) {
        metadata = await Web3Wallet.notifications.getMetadata({ topic });
   } else {
        // session proposals contain metadata in the request itself
        metadata = decryptedMessage.params.proposer.metadata
   }

    // with this information you can show a local push notification to the user
   ...
});
```
</file>

<file path="docs/walletkit/react-native/best-practices.mdx">
# Best Practices

The purpose of this guide is to show the best practices in regards of the WalletKit client usage. The goal is to provide the best user experience that just works in every circumstances.

:::note
In order to ensure the best user experience and flawless connection flow, please make sure that WalletKit is initialized immediately after your app launch, especially if launched via a WalletConnect Deep Link. It guarantees that websocket connection is opened immediately and all requests are received by your wallet
:::

## Pairing

A pairing is a connection between a wallet and a dapp that has fixed permissions to only allow a dapp to propose a session through it. Dapp can propose infinite number of sessions on one pairing. Wallet must use a pair method from the WalletKit client to pair with dapp.

```typescript
const uri = 'xxx'; // pairing uri
try {
    await web3Wallet.pair({ uri });
} catch (error) {
    // some error happens while pairing - check Expected errors section
}
``` 

### Pairing Expiry

A pairing expiry event is triggered whenever a pairing is expired. The expiry for inactive pairing is 5 mins, whereas for active pairing is 30 days. A pairing becomes active when a session proposal is received and user successfully approves it. This event helps to know when given pairing expires and update UI accordingly.

```typescript
core.pairing.events.on("pairing_expire", (event) => {
    // pairing expired before user approved/rejected a session proposal
    const { topic } = topic;
});
```
### Expected User flow

### Pairing Flow

![](/assets/pairing.gif)

### Pairing Error

![](/assets/pairing_error.gif)

### Expected Errors

While pairing the following errors might occur:

- No Internet connection error or pairing timeout when scanning QR with no Internet connection
  - User should pair again with Internet connection
- Pairing expired error when scanning a QR code with expired pairing
  - User should refresh a QR code and scan again
- Pairing with existing pairing is not allowed
  - User should refresh a QR code and scan again. I usually happens when user scans an already paired QR code.

## Session Proposal

A session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Whenever a user wants to establish a connection between a wallet and a dapp, one should approve a session proposal.

### User Action Feedback

Whenever user approves or rejects a session proposal, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

Approving session
```typescript
    try {
        await web3Wallet.approveSession(params);
        // update UI -> remove the loader
    } catch (error) {
        // present error to the user
    }
```
Rejecting session
```typescript
    try {
        await web3Wallet.rejectSession(params);
        // update UI -> remove the loader
    } catch (error) {
        // present error to the user
    }
```

### Session Proposal Expiry

A session proposal expiry is 5 mins. It means a given proposal is stored for 5 mins in the SDK storage and user has 5 mins for approval or rejection decision. After that time the below event is emitted and proposal modal should be removed from the app's UI.

```typescript
web3wallet.on("proposal_expire", (event) => {
    // proposal expired and any modal displaying it should be removed
    const { id } = event;
});
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/pairing.gif)

### Error Handling

![](/assets/proposal_error.gif)

### Expected Errors

While approving or rejecting a session proposal the following errors might occurs:

- No Internet connection
  - It happens when a user tries to approve or reject session proposal with no Internet connection
- Session proposal expired
  - It happens when users tries to approve or reject expired session proposal
- Invalid namespaces
  - It happens when a validation of session namespaces fails
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Session Request

A session request represents the request sent by a dapp to a wallet.

### User Action Feedback

Whenever user approves or rejects a session request, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

```typescript
    try {
        await web3Wallet.respondSessionRequest(params);
        // update UI -> remove the loader
    } catch (error) {
        // present error to the user
    }
```

### Session Request Expiry

A session request expiry is defined by a dapp. It's value must be between now() + 5mins and now() + 7 days. After the session request expires the below event is emitted and session request modal should be removed from the app's UI.

```typescript
web3wallet.on("session_request_expire", (event) => {
    // request expired and any modal displaying it should be removed
    const { id } = event;
});
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/session_request.gif)

### Error Handling

![](/assets/session_request_error.gif)

### Expected Errors

While approving or rejecting a session request the following error might occur:

- Invalid session
  - This error might happen when user approves or rejects a session request on expired session
- Session request expired
  - This error might happen when user approves or rejects a session request that already expires
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Web Socket Connection State

The Web Socket connection state tracks the connection with the relay server, event is emitted whenever a connection state changes.

```typescript
core.relayer.on("relayer_connect", () => {
    // connection to the relay server is established
})

core.relayer.on("relayer_disconnect", () => {
// connection to the relay server is lost
})

```

### Expected User flow

### Connection State

![](/assets/connection_state.gif)
</file>

<file path="docs/walletkit/react-native/eip5792.mdx">
# Wallet Call API

WalletConnect supports [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792#atomicbatch-capability), which defines new JSON-RPC methods that enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.
Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.

- `wallet_sendCalls`: Requests that a wallet submits a batch of calls.
- `wallet_getCallsStatus`: Returns the status of a call batch that was sent via wallet_sendCalls.
- `wallet_showCallsStatus`: Requests that a wallet shows information about a given call bundle that was sent with wallet_sendCalls.
- `wallet_getCapabilities`: This RPC allows an application to request capabilities from a wallet (e.g. batch transactions, paymaster communication).
</file>

<file path="docs/walletkit/react-native/installation.mdx">
# Installation

Install WalletKit package.

```
yarn add @walletconnect/web3wallet @walletconnect/react-native-compat
```

Additionally add these extra packages to help with async storage, polyfills and the instance of ethers.

```
yarn add @react-native-async-storage/async-storage @react-native-community/netinfo react-native-get-random-values fast-text-encoding
```

<details>
<summary>Additional setup for Expo</summary>
<div>
```
npx expo install expo-application
```
</div>
</details>

For those using Typescript, we recommend adding these dev dependencies:

```
yarn add @walletconnect/jsonrpc-types --dev
```

## Next Steps

Now that you've installed WalletKit, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the SDK.
</file>

<file path="docs/walletkit/react-native/mobile-linking.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import HowToTest from '../shared/mobile-linking.mdx'

# Mobile Linking

:::info Note

This feature is only relevant to native platforms.

:::

## Usage

Mobile Linking allows your wallet to automatically redirect back to the Dapp allowing for less user interactions and hence a better UX for your users.

### Establishing Communication Between Mobile Wallets and Apps

When integrating a wallet with a mobile application, it's essential to understand how they communicate. The process involves two main steps:

1. **QR Code Handshake:** The mobile app (Dapp) generates a unique URI (Uniform Resource Identifier) and displays it as a QR code. This URI acts like a secret handshake. When the user scans the QR code using their wallet app, they establish a connection. It's like saying, "Hey, let's chat!"
2. **Deep Links and Universal Links:** The URI from the QR code allows the wallet app to create a [deep link](https://support.google.com/google-ads/answer/10023042?hl=en#:~:text=Deep%20links%20send%20mobile%20device,%2C%20Shopping%2C%20and%20Display%20campaigns.) or [universal link](https://developer.apple.com/ios/universal-links/). These links work on both Android and iOS. They enable seamless communication between the wallet and the app.

:::tip

**Developers should prefer Deep Linking over Universal Linking.**

In the case of Universal Linking, the user may be redirected to the browser, which may not be the desired behavior. Deep Linking ensures that the user is redirected to the app, providing a seamless experience.

:::

The connection and sign request flows are similar across platforms.
The next section provides a high-level overview of both flows.

### Connection Flow

- **Dapp Prompts User:** The Dapp asks the user to connect.
- **User Chooses Wallet:** The user selects a wallet from a list of compatible wallets.
- **Redirect to Wallet:** The user is redirected to their chosen wallet.
- **Wallet Approval:** The wallet prompts the user to approve or reject the session (similar to granting permission).
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reunites with Dapp:** After all the interactions, the user ends up back in the Dapp.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking-dark.png')
  }}
/>

### Sign Request Flow

When the Dapp needs the user to sign something (like a transaction), a similar pattern occurs:

- **Automatic Redirect:** The Dapp automatically sends the user to their previously chosen wallet.
- **Approval Prompt:** The wallet asks the user to approve or reject the request.
- **Return to Dapp:**
  - **Manual Return:** The wallet asks the user to manually return to the Dapp.
  - **Automatic Return:** Alternatively, the wallet automatically takes the user back to the Dapp.
- **User Reconnects:** Eventually, the user returns to the Dapp.

<ThemedImage
  alt="Mobile Linking Sign Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking_sign-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking_sign-dark.png')
  }}
/>

## Platform preparations

Since React Native leverages on native APIs, you must follow iOS and Android steps for each native platform

More information in official documentation: https://reactnative.dev/docs/linking?syntax=android#enabling-deep-links

:::tip

Dapps developers must do the same for their own custom schemes if they want the wallet to be able to navigate back after a session approval or a sign request response

:::

<HowToTest/>

## Integration

In order to redirect to the Dapp, you'll need to use `Linking` from `react-native` and call `openURL()` method with the Dapp scheme that comes in the proposal metadata.

```js
import { Linking } from 'react-native'

async function onApprove(proposal, namespaces) {
  const session = await web3wallet.approveSession({ id: proposal.id, namespaces })

  const dappScheme = session.peer.metadata.redirect?.native

  if (dappScheme) {
    Linking.openURL(dappScheme)
  } else {
    // Inform the user to manually return to the DApp
  }
}
```
</file>

<file path="docs/walletkit/react-native/one-click-auth.mdx">
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import Button from '../../components/button'

# One-click Auth

## Introduction

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a [Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361) (SIWE) message, enhanced by [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities).

This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/authenticatedSessions-light.png'),
    dark: useBaseUrl('/img/w3w/authenticatedSessions-dark.png')
  }}
/>

## Handling Authentication Requests

To handle incoming authentication requests, subscribe to the `session_authenticate` event. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```typescript
web3wallet.on('session_authenticate', async payload => {
  // Process the authentication request here.
  // Steps include:
  // 1. Populate the authentication payload with the supported chains and methods
  // 2. Format the authentication message using the payload and the user's account
  // 3. Present the authentication message to the user
  // 4. Sign the authentication message(s) to create a verifiable authentication object(s)
  // 5. Approve the authentication request with the authentication object(s)
})
```

## Authentication Payload

```typescript
import { populateAuthPayload } from "@walletconnect/utils";

// EVM chains that your wallet supports
const supportedChains = ["eip155:1", "eip155:2", 'eip155:137'];
// EVM methods that your wallet supports
const supportedMethods = ["personal_sign", "eth_sendTransaction", "eth_signTypedData"];
// Populate the authentication payload with the supported chains and methods
const authPayload = populateAuthPayload({
  authPayload: payload.params.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
});
// Prepare the user's address in CAIP10(https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) format
const iss = `eip155:1:0x0Df6d2a56F90e8592B4FfEd587dB3D5F5ED9d6ef`;
// Now you can use the authPayload to format the authentication message
const message = web3wallet.formatAuthMessage({
  request: authPayload,
  iss
});

// Present the authentication message to the user
...
```

## Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

:::

```typescript
// Approach 1
// Sign the authentication message(s) to create a verifiable authentication object(s)
const signature = await cryptoWallet.signMessage(message, privateKey)
// Build the authentication object(s)
const auth = buildAuthObject(
  authPayload,
  {
    t: 'eip191',
    s: signature
  },
  iss
)

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths: [auth]
})

// Approach 2
// Note that you can also sign multiple messages for every requested chain/address pair
const auths = []
authPayload.chains.forEach(async chain => {
  const message = web3wallet.formatAuthMessage({
    request: authPayload,
    iss: `${chain}:${cryptoWallet.address}`
  })
  const signature = await cryptoWallet.signMessage(message)
  const auth = buildAuthObject(
    authPayload,
    {
      t: 'eip191', // signature type
      s: signature
    },
    `${chain}:${cryptoWallet.address}`
  )
  auths.push(auth)
})

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths
})
```

## Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```typescript
import { getSdkError } from '@walletconnect/utils'

await web3wallet.rejectSessionAuthenticate({
  id: payload.id,
  reason: getSdkError('USER_REJECTED') // or choose a different reason if applicable
})
```

## Testing One-click Auth

You can use [AppKit Labs](https://lab.web3modal.com/library/ethers-siwe/) to test and verify that your wallet supports One-click Auth properly.

<Button name="Test One-click Auth" url="https://lab.web3modal.com/library/ethers-siwe/" />
</file>

<file path="docs/walletkit/react-native/resources.mdx">
# Resources

Valuable assets for developers and users interested in integrating Web3Wallet into their applications.

- [Awesome WalletConnect](https://github.com/WalletConnect/awesome-walletconnect) - Community-curated collection of WalletConnect-enabled wallets, libraries, and tools.
- [AppKit Laboratory](https://lab.web3modal.com) - A place to test your wallet integrations against various setups of AppKit.
- [WalletKit GitHub](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet) - WalletKit GitHub repository.

### Wallet Resources

[WalletKit](https://medium.com/walletconnect/simplifying-integration-for-wallet-developers-with-the-new-web3wallet-sdk-8706b69e149c) simplifies the integration process for wallet developers by combining our Sign and Auth APIs. Please note that only V2 [WCURIs](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri) will work with this SDK, as V1 is being deprecated by June 28th, 2023.

#### Expo

Experimental: For Expo, we have an unofficial npx starter command. `newWallet` represents the name of your project.

```bash
npx create-wc-wallet-expo@latest newWallet
```

This downloads an Expo template with WalletKit installed. More information available in this [tutorial](https://medium.com/walletconnect/how-to-build-a-wallet-in-react-native-with-the-web3wallet-sdk-b6f57bf02f9a)

### Dapp Resources

If you need to test your app's integration, you can use one of our following demo wallets and/or dapps.

**Sign**

- [React dApp (with standalone client) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2) ([Demo](https://react-app.walletconnect.com/))
- [React dApp (with EthereumProvider + Ethers.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-ethers) ([Demo](https://react-dapp-v2-with-ethers.vercel.app/))
- [React dApp (with EthereumProvider + web3.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-web3js) ([Demo](https://react-dapp-v2-with-web3js.vercel.app/))
- [React dApp (with CosmosProvider) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-cosmos-provider) ([Demo](https://react-dapp-v2-cosmos-provider.vercel.app/))
</file>

<file path="docs/walletkit/react-native/usage.mdx">
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CloudBanner from '../../components/CloudBanner'

# Usage

This section provides instructions on how to initialize the Web3Wallet client, approve sessions with supported namespaces, and respond to session requests, enabling easy integration of Web3 wallets with dapps through a simple and intuitive interface.

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

<CloudBanner />

## Initialization

:::info Note

`@walletconnect/react-native-compat` must be installed and imported before any `@walletconnect/*` dependencies¬†for proper React Native polyfills.

```ts
import '@walletconnect/react-native-compat'
// Other imports
```

:::

Create a new instance from `Core` and initialize it with your `projectId`. Next, create a Web3Wallet instance by calling `init` on `Web3Wallet`. Passing in the options object containing metadata about the app.

In this code example, we wrapped it in a `createWeb3Wallet` function as this will be easier to call from your `App.tsx` or an initialization function as seen [here.](https://github.com/WalletConnect/react-native-examples/blob/main/wallets/rn_cli_wallet_068_5/src/utils/Web3WalletClient.ts)

The `pair` function will help us pair between the dapp and wallet and will be used shortly.

```javascript
import { Core } from '@walletconnect/core'
import { Web3Wallet } from '@walletconnect/web3wallet'

const core = new Core({
  projectId: process.env.PROJECT_ID
})

const web3wallet = await Web3Wallet.init({
  core, // <- pass the shared `core` instance
  metadata: {
    name: 'Demo React Native Wallet',
    description: 'Demo RN Wallet to interface with Dapps',
    url: 'www.walletconnect.com',
    icons: ['https://your_wallet_icon.png'],
    redirect: {
      native: 'yourwalletscheme://'
    }
  }
})
```

## Session

A session is a connection between a dapp and a wallet. It is established when a user approves a session proposal from a dapp. A session is active until the user disconnects from the dapp or the session expires.

### Namespace Builder

With Web3Wallet v1.5.1 (and @walletconnect/utils v2.6.1) we've published a helper utility that greatly reduces the complexity of parsing the `required` and `optional` namespaces. It accepts as parameters a `session proposal` along with your user's `chains/methods/events/accounts` and returns ready-to-use `namespaces` object.

```javascript
// util params
{
  proposal: ProposalTypes.Struct; // the proposal received by `.on("session_proposal")`
  supportedNamespaces: Record< // your Wallet's supported namespaces
    string, // the supported namespace key e.g. eip155
    {
      chains: string[]; // your supported chains in CAIP-2 format e.g. ["eip155:1", "eip155:2", ...]
      methods: string[]; // your supported methods e.g. ["personal_sign", "eth_sendTransaction"]
      events: string[]; // your supported events e.g. ["chainChanged", "accountsChanged"]
      accounts: string[] // your user's accounts in CAIP-10 format e.g. ["eip155:1:0x453d506b1543dcA64f57Ce6e7Bb048466e85e228"]
      }
  >;
};
```

Example usage

```javascript
// import the builder util
import { Web3Wallet, Web3WalletTypes } from '@walletconnect/web3wallet'
import { buildApprovedNamespaces, getSdkError } from '@walletconnect/utils'

async function onSessionProposal({ id, params }: Web3WalletTypes.SessionProposal){
  try{
    // ------- namespaces builder util ------------ //
    const approvedNamespaces = buildApprovedNamespaces({
      proposal: params,
      supportedNamespaces: {
        eip155: {
          chains: ['eip155:1', 'eip155:137'],
          methods: ['eth_sendTransaction', 'personal_sign'],
          events: ['accountsChanged', 'chainChanged'],
          accounts: [
            'eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb',
            'eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb'
          ]
        }
      }
    })
    // ------- end namespaces builder util ------------ //

    const session = await web3wallet.approveSession({
      id,
      namespaces: approvedNamespaces
    })
  }catch(error){
    // use the error.message to show toast/info-box letting the user know that the connection attempt was unsuccessful
   ....

    await web3wallet.rejectSession({
      id: proposal.id,
      reason: getSdkError("USER_REJECTED")
    })
  }
}


web3wallet.on('session_proposal', onSessionProposal)
```

If your wallet supports multiple namespaces e.g. `eip155`,`cosmos` & `near`
Your `supportedNamespaces` should look like the following example.

```javascript
// ------- namespaces builder util ------------ //
const approvedNamespaces = buildApprovedNamespaces({
    proposal: params,
    supportedNamespaces: {
        eip155: {...},
        cosmos: {...},
        near: {...}
    },
});
// ------- end namespaces builder util ------------ //
```

### Get Active Sessions

You can get the wallet active sessions using the `getActiveSessions` function.

```js
const activeSessions = web3wallet.getActiveSessions()
```

### EVM methods & events

In @walletconnect/ethereum-provider, (our abstracted EVM SDK for apps) we support by default the following Ethereum methods and events:

```ts
{
  //...
  methods: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_getCapabilities",
  ],
  events: [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect",
  ]
}
```

### Session Approval

In order to connect with a dapp, you will need to receive a WalletConnect URI (WCURI) and this will talk to our protocol to facilitate a pairing session. Therefore, you will need a test dapp in order to communicate with the wallet. We recommend testing with our [React V2 Dapp](https://react-app.walletconnect.com/) as this is the most up-to-date development site.

In order to capture the WCURI, recommend having some sort of state management you will pass through a `TextInput` or QRcode instance.

The `session_proposal` event is emitted when a dapp initiates a new session with a user's wallet. The event will include a `proposal` object with information about the dapp and requested permissions. The wallet should display a prompt for the user to approve or reject the session. If approved, call `approveSession` and pass in the `proposal.id` and requested `namespaces`.

The `pair` method initiates a WalletConnect pairing process with a dapp using the given `uri` (QR code from the dapps). To learn more about pairing, checkout out the [docs](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/).

```javascript
import { getSdkError } from '@walletconnect/utils'

// Approval: Using this listener for sessionProposal, you can accept the session
web3wallet.on('session_proposal', async proposal => {
  const session = await web3wallet.approveSession({
    id: proposal.id,
    namespaces
  })
})

// Call this after WCURI is received
await web3wallet.pair({ wcuri })
```

### Session Rejection

You can use the `getSDKError` function, which is available in the `@walletconnect/utils` for the rejection function [library](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/utils).

```javascript
import { getSdkError } from '@walletconnect/utils'

// Reject: Using this listener for sessionProposal, you can reject the session
web3wallet.on('session_proposal', async proposal => {
  await web3wallet.rejectSession({
    id: proposal.id,
    reason: getSdkError('USER_REJECTED_METHODS')
  })
})

// Call this after WCURI is received
await web3wallet.core.pairing.pair({ wcuri })
```

### Responding to Session requests

![session-request-example](/assets/SessionRequestExample.png)

The `session_request` event is triggered by a dapp when it needs the wallet to perform a specific action, such as signing a transaction. The event contains a `topic` and a `request` object, which will vary depending on the action requested.

To respond to the request, the wallet can access the `topic` and `request` object by destructuring them from the event payload. To see a list of possible `request` and `response` objects, refer to the relevant JSON-RPC Methods for [Ethereum](../../advanced/multichain/rpc-reference/ethereum-rpc.md), [Solana](../../advanced/multichain/rpc-reference/solana-rpc.md), [Cosmos](../../advanced/multichain/rpc-reference/cosmos-rpc.md), or [Stellar](../../advanced/multichain/rpc-reference/stellar-rpc.md).

As an example, if the dapp requests a `personal_sign` method, the wallet can extract the `params` array from the `request` object. The first item in the array is the hex version of the message to be signed, which can be converted to UTF-8 and assigned to a `message` variable. The second item in `params` is the user's wallet address.

To sign the message, the wallet can use the `wallet.signMessage` method and pass in the message. The signed message, along with the `id` from the event payload, can then be used to create a `response` object, which can be passed into `respondSessionRequest`.

The wallet then signs the message. `signedMessage`, along with the `id` from the event payload, can then be used to create a `response` object, which can be passed into `respondSessionRequest`.

```javascript
web3wallet.on('session_request', async event => {
  const { topic, params, id } = event
  const { request } = params
  const requestParamsMessage = request.params[0]

  // convert `requestParamsMessage` by using a method like hexToUtf8
  const message = hexToUtf8(requestParamsMessage)

  // sign the message
  const signedMessage = await wallet.signMessage(message)

  const response = { id, result: signedMessage, jsonrpc: '2.0' }

  await web3wallet.respondSessionRequest({ topic, response })
})
```

To reject a session request, the response should be similar to this.

```javascript
const response = {
  id,
  jsonrpc: '2.0',
  error: {
    code: 5000,
    message: 'User rejected.'
  }
}
```

### Updating a Session

The `session_update` event is emitted from the wallet when the session is updated by calling `updateSession`. To update a session, pass in the [topic](../../advanced/glossary#topics) and the new namespace.

```javascript
await web3wallet.updateSession({ topic, namespaces: newNs })
```

### Extending a Session

To extend the session, call the `extendSession` method and pass in the new `topic`. The `session_update` event will be emitted from the wallet.

```javascript
await web3wallet.extendSession({ topic })
```

### Session Disconnect

When either the dapp or the wallet disconnects from a session, a `session_delete` event will be emitted. It's important to subscribe to this event so you could keep your state up-to-date.

To initiate a session disconnect, call the `disconnectSession` method and pass in the `topic` and `reason`. You can use the `getSDKError` utility function, which is available in the `@walletconnect/utils` [library](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/utils).

```javascript
await web3wallet.disconnectSession({
  topic,
  reason: getSdkError('USER_DISCONNECTED')
})
```

### Emitting Session Events

To emit session events, call the `emitSessionEvent` and pass in the params. If you wish to switch to chain/account that is not approved (missing from `session.namespaces`) you will have to update the session first. In the following example, the wallet will emit `session_event` that will instruct the dapp to switch the active accounts.

```javascript
await web3wallet.emitSessionEvent({
  topic,
  event: {
    name: 'accountsChanged',
    data: ['0xab16a96D359eC26a11e2C2b3d8f8B8942d5Bfcdb']
  },
  chainId: 'eip155:1'
})
```

In the following example, the wallet will emit `session_event` when the wallet switches chains.

```javascript
await web3wallet.emitSessionEvent({
  topic,
  event: {
    name: 'chainChanged',
    data: 1
  },
  chainId: 'eip155:1'
})
```
</file>

<file path="docs/walletkit/react-native/verify.mdx">
# Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.
Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).
For those looking to enable Verify on the app side, check out our reference guide [here.](./cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

These are:

![Verify Banner](/img/verify-banner.png)

## Disclaimer

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

## Domain risk detection

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either `VALID`, `INVALID` or `UNKNOWN`.

- Domain match: The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `VALID`.
- Unverified: The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `UNKNOWN`.
- Mismatch: The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `INVALID`
- Threat: This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The `verifyContext` included in the request will contain parameter `isScam` with value `true`.

### Implementation

To check the Verify API validations and whether or not your user is interacting with potentially malicious app, you can do so by accessing the `verifyContext` included in the request payload.

```javascript
...
web3wallet.on("auth_request", async (authRequest) => {
  const { verifyContext } = authRequest
  const validation = verifyContext.verified.validation // can be VALID, INVALID or UNKNOWN
  const origin = verifyContext.verified.origin // the actual verified origin of the request
  const isScam = verifyContext.verified.isScam // true if the domain is flagged as malicious

  // if the domain is flagged as malicious, you should warn the user as they may lose their funds - check the `Threat` case for more info
  if(isScam) {
    // show a warning screen to the user
    // and proceed only if the user accepts the risk
  }

  switch(validation) {
    case "VALID":
      // proceed with the request - check the `Domain match` case for more info
      break
    case "INVALID":
      // show a warning dialog to the user - check the `Mismatch` case for more info
      // and proceed only if the user accepts the risk
      break
    case "UNKNOWN":
      // show a warning dialog to the user - check the `Unverified` case for more info
      // and proceed only if the user accepts the risk
      break
  }
})
```

For live demo examples of the intended Verify API flows, check out our demo apps:

- [Demo Web Wallet](https://react-wallet.walletconnect.com)
- [Demo React Native Wallet](https://github.com/WalletConnect/react-native-examples/tree/main/wallets/rn_cli_wallet)
- [Demo App](https://react-app.walletconnect.com/) - you can toggle between the verify states by clicking on the `gear` & selecting the decided Validation before connecting to the wallet
- [Demo Malicious App](https://malicious-app-verify-simulation.vercel.app/) - this app is flagged as malicious and will have the `isScam` parameter set to `true` in the `verifyContext` of the request
</file>

<file path="docs/walletkit/shared/mobile-linking.mdx">
### How to test

Before submitting your project to the Cloud Explorer you can test mobile linking in our sample Dapp:

1. On your mobile device, visit the appropriate link:
- For EVM: https://lab.web3modal.com/library/wagmi/
- For Solana: https://lab.web3modal.com/library/solana/

2. Click the "Custom Wallet" button and fill in the form with your wallet information. The website will reload and your wallet will be stored locally.
3. Click the "Connect Wallet" button and choose your mobile wallet. It _should_ automatically open and redirect to your wallet.

Learn more about mobile linking in the [Best Practices section](../best-practices#2-mobile-linking).
</file>

<file path="docs/walletkit/web/cloud/analytics.mdx">
---
title: Analytics
---

import Analytics from '../../../cloud/analytics.mdx'

<Analytics />
</file>

<file path="docs/walletkit/web/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

import ExplorerSubmission from '../../../cloud/explorer-submission.mdx'

<ExplorerSubmission />
</file>

<file path="docs/walletkit/web/cloud/relay.mdx">
---
title: Relay
---

import Relay from '../../../cloud/relay.mdx'

<Relay />
</file>

<file path="docs/walletkit/web/cloud/verify.mdx">
---
title: Verify
---

import Verify from '../../../cloud/verify.mdx'

<Verify />
</file>

<file path="docs/walletkit/web/best-practices.mdx">
# Best Practices

The purpose of this guide is to show the best practices in regards of the WalletKit client usage. The goal is to provide the best user experience that just works in every circumstances.

:::note
In order to ensure the best user experience and flawless connection flow, please make sure that WalletKit is initialized immediately after your app launch, especially if launched via a WalletConnect Deep Link. It guarantees that websocket connection is opened immediately and all requests are received by your wallet
:::

## Pairing

A pairing is a connection between a wallet and a dapp that has fixed permissions to only allow a dapp to propose a session through it. Dapp can propose infinite number of sessions on one pairing. Wallet must use a pair method from Web3Wallet client to pair with dapp.

```typescript
const uri = 'xxx'; // pairing uri
try {
    await web3Wallet.pair({ uri });
} catch (error) {
    // some error happens while pairing - check Expected errors section
}
```

### Pairing Expiry

A pairing expiry event is triggered whenever a pairing is expired. The expiry for inactive pairing is 5 mins, whereas for active pairing is 30 days. A pairing becomes active when a session proposal is received and user successfully approves it. This event helps to know when given pairing expires and update UI accordingly.

```typescript
core.pairing.events.on("pairing_expire", (event) => {
    // pairing expired before user approved/rejected a session proposal
    const { topic } = topic;
});
```
### Expected User flow

### Pairing Flow

![](/assets/pairing.gif)

### Pairing Error

![](/assets/pairing_error.gif)

### Expected Errors

While pairing the following errors might occur:

- No Internet connection error or pairing timeout when scanning QR with no Internet connection
  - User should pair again with Internet connection
- Pairing expired error when scanning a QR code with expired pairing
  - User should refresh a QR code and scan again
- Pairing with existing pairing is not allowed
  - User should refresh a QR code and scan again. I usually happens when user scans an already paired QR code.

## Session Proposal

A session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Whenever a user wants to establish a connection between a wallet and a dapp, one should approve a session proposal.

### User Action Feedback

Whenever user approves or rejects a session proposal, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

Approving session
```typescript
    try {
        await web3Wallet.approveSession(params);
        // update UI -> remove the loader
    } catch (error) {
        // present error to the user
    }
```
Rejecting session
```typescript
    try {
        await web3Wallet.rejectSession(params);
        // update UI -> remove the loader
    } catch (error) {
        // present error to the user
    }
```

### Session Proposal Expiry

A session proposal expiry is 5 mins. It means a given proposal is stored for 5 mins in the SDK storage and user has 5 mins for approval or rejection decision. After that time the below event is emitted and proposal modal should be removed from the app's UI.

```typescript
web3wallet.on("proposal_expire", (event) => {
    // proposal expired and any modal displaying it should be removed
    const { id } = event;
});
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/pairing.gif)

### Error Handling

![](/assets/proposal_error.gif)

### Expected Errors

While approving or rejecting a session proposal the following errors might occurs:

- No Internet connection
  - It happens when a user tries to approve or reject session proposal with no Internet connection
- Session proposal expired
  - It happens when users tries to approve or reject expired session proposal
- Invalid namespaces
  - It happens when a validation of session namespaces fails
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Session Request

A session request represents the request sent by a dapp to a wallet.

### User Action Feedback

Whenever user approves or rejects a session request, wallet should show loading indicators in a moment of the button press until Relay acknowledgement is received for any of this actions.

```typescript
    try {
        await web3Wallet.respondSessionRequest(params);
        // update UI -> remove the loader
    } catch (error) {
        // present error to the user
    }
```

### Session Request Expiry

A session request expiry is defined by a dapp. It's value must be between now() + 5mins and now() + 7 days. After the session request expires the below event is emitted and session request modal should be removed from the app's UI.

```typescript
web3wallet.on("session_request_expire", (event) => {
    // request expired and any modal displaying it should be removed
    const { id } = event;
});
```

### Expected User flow

### Approve or Reject Session Proposal

![](/assets/session_request.gif)

### Error Handling

![](/assets/session_request_error.gif)

### Expected Errors

While approving or rejecting a session request the following error might occur:

- Invalid session
  - This error might happen when user approves or rejects a session request on expired session
- Session request expired
  - This error might happen when user approves or rejects a session request that already expires
- Timeout
  - It happens when Relay doesn't acknowledge session settle publish within 10s

## Web Socket Connection State

The Web Socket connection state tracks the connection with the relay server, event is emitted whenever a connection state changes.

```typescript
core.relayer.on("relayer_connect", () => {
    // connection to the relay server is established
})

core.relayer.on("relayer_disconnect", () => {
// connection to the relay server is lost
})

```

### Expected User flow

### Connection State

![](/assets/connection_state.gif)
</file>

<file path="docs/walletkit/web/eip5792.mdx">
# Wallet Call API

WalletConnect supports [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792#atomicbatch-capability), which defines new JSON-RPC methods that enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.
Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.

- `wallet_sendCalls`: Requests that a wallet submits a batch of calls.
- `wallet_getCallsStatus`: Returns the status of a call batch that was sent via wallet_sendCalls.
- `wallet_showCallsStatus`: Requests that a wallet shows information about a given call bundle that was sent with wallet_sendCalls.
- `wallet_getCapabilities`: This RPC allows an application to request capabilities from a wallet (e.g. batch transactions, paymaster communication).
</file>

<file path="docs/walletkit/web/installation.mdx">
# Installation

Install WalletKit using npm or yarn.

```bash npm2yarn
npm install @walletconnect/web3wallet @walletconnect/utils @walletconnect/core
```
## Next Steps

Now that you've installed WalletKit, you're ready to start integrating it. The next section will walk you through the process of setting up your project to use the SDK.
</file>

<file path="docs/walletkit/web/one-click-auth-siws.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import Button from '../../components/button'

# One-click Auth / SIWS

## Introduction

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a [Sign-In with Solana](https://github.com/phantom/sign-in-with-solana) (SIWS) message, enhanced by [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities).

This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWS messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWS messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Solana ecosystem.

## Handling Authentication Requests

To handle incoming authentication requests, subscribe to the `session_authenticate` event. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```typescript
web3wallet.on('session_authenticate', async payload => {
  // Process the authentication request here.
  // Steps include:
  // 1. Populate the authentication payload with the supported chains and methods
  // 2. Format the authentication message using the payload and the user's account
  // 3. Present the authentication message to the user
  // 4. Sign the authentication message(s) to create a verifiable authentication object(s)
  // 5. Approve the authentication request with the authentication object(s)
})
```

## Authentication Objects/Payloads

```typescript
import { populateAuthPayload } from "@walletconnect/utils";

// Solana chains that your wallet supports
const supportedChains = [ "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp", "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ" ]
// Solana methods that your wallet supports
const supportedMethods = ["solana_signMessage", "solana_signTransaction"];
// Populate the authentication payload with the supported chains and methods
const authPayload = populateAuthPayload({
  authPayload: payload.params.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
});
// Prepare the user's address in CAIP10(https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) format
const iss = `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp:8nJ694gNrHx76L2eyJzQw7JBGRoW8Fdtrxf588pEqyYh`;
// Now you can use the authPayload to format the authentication message
const message = web3wallet.formatAuthMessage({
  request: authPayload,
  iss
});

// Present the authentication message to the user
...
```

## Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWS (Sign-In with Solana) message for each chain and account. However, at a minimum, one SIWS message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

:::

```typescript
// Approach 1
// Sign the authentication message(s) to create a verifiable authentication object(s)
const signature = await cryptoWallet.signMessage(message, privateKey)
// Build the authentication object(s)
const auth = buildAuthObject(
  authPayload,
  {
    t: 'caip122',
    s: signature
  },
  iss
)

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths: [auth]
})

// Approach 2
// Note that you can also sign multiple messages for every requested chain/address pair
const auths = []
authPayload.chains.forEach(async chain => {
  const message = web3wallet.formatAuthMessage({
    request: authPayload,
    iss: `${chain}:${cryptoWallet.address}`
  })
  const signature = await cryptoWallet.signMessage(message)
  const auth = buildAuthObject(
    authPayload,
    {
      t: 'caip122', // signature type
      s: signature
    },
    `${chain}:${cryptoWallet.address}`
  )
  auths.push(auth)
})

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths
})
```

## Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```typescript
import { getSdkError } from '@walletconnect/utils'

await web3wallet.rejectSessionAuthenticate({
  id: payload.id,
  reason: getSdkError('USER_REJECTED') // or choose a different reason if applicable
})
```

## Testing One-click Auth

You can use [Web3Modal Labs](https://lab.web3modal.com/library/solana-siws/) to test and verify that your wallet supports One-click Auth properly.

<Button name="Test One-click Auth" url="https://lab.web3modal.com/library/solana-siws/" />
</file>

<file path="docs/walletkit/web/one-click-auth.mdx">
import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import Button from '../../components/button'

# One-click Auth

## Introduction

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a [Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361) (SIWE) message, enhanced by [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities).

This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/authenticatedSessions-light.png'),
    dark: useBaseUrl('/img/w3w/authenticatedSessions-dark.png')
  }}
/>

## Handling Authentication Requests

To handle incoming authentication requests, subscribe to the `session_authenticate` event. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```typescript
web3wallet.on('session_authenticate', async payload => {
  // Process the authentication request here.
  // Steps include:
  // 1. Populate the authentication payload with the supported chains and methods
  // 2. Format the authentication message using the payload and the user's account
  // 3. Present the authentication message to the user
  // 4. Sign the authentication message(s) to create a verifiable authentication object(s)
  // 5. Approve the authentication request with the authentication object(s)
})
```

## Authentication Objects/Payloads

```typescript
import { populateAuthPayload } from "@walletconnect/utils";

// EVM chains that your wallet supports
const supportedChains = ["eip155:1", "eip155:2", 'eip155:137'];
// EVM methods that your wallet supports
const supportedMethods = ["personal_sign", "eth_sendTransaction", "eth_signTypedData"];
// Populate the authentication payload with the supported chains and methods
const authPayload = populateAuthPayload({
  authPayload: payload.params.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
});
// Prepare the user's address in CAIP10(https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) format
const iss = `eip155:1:0x0Df6d2a56F90e8592B4FfEd587dB3D5F5ED9d6ef`;
// Now you can use the authPayload to format the authentication message
const message = web3wallet.formatAuthMessage({
  request: authPayload,
  iss
});

// Present the authentication message to the user
...
```

## Approving Authentication Requests

:::info Note

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

:::

```typescript
// Approach 1
// Sign the authentication message(s) to create a verifiable authentication object(s)
const signature = await cryptoWallet.signMessage(message, privateKey)
// Build the authentication object(s)
const auth = buildAuthObject(
  authPayload,
  {
    t: 'eip191',
    s: signature
  },
  iss
)

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths: [auth]
})

// Approach 2
// Note that you can also sign multiple messages for every requested chain/address pair
const auths = []
authPayload.chains.forEach(async chain => {
  const message = web3wallet.formatAuthMessage({
    request: authPayload,
    iss: `${chain}:${cryptoWallet.address}`
  })
  const signature = await cryptoWallet.signMessage(message)
  const auth = buildAuthObject(
    authPayload,
    {
      t: 'eip191', // signature type
      s: signature
    },
    `${chain}:${cryptoWallet.address}`
  )
  auths.push(auth)
})

// Approve
await web3wallet.approveSessionAuthenticate({
  id: payload.id,
  auths
})
```

## Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```typescript
import { getSdkError } from '@walletconnect/utils'

await web3wallet.rejectSessionAuthenticate({
  id: payload.id,
  reason: getSdkError('USER_REJECTED') // or choose a different reason if applicable
})
```

## Testing One-click Auth

You can use [AppKit Lab](https://lab.web3modal.com/library/ethers-siwe/) to test and verify that your wallet supports One-click Auth properly.

<Button name="Test One-click Auth" url="https://lab.web3modal.com/library/ethers-siwe/" />
</file>

<file path="docs/walletkit/web/resources.mdx">
# Resources

Valuable assets for developers and users interested in integrating WalletKit into their applications.

- [Awesome WalletConnect](https://github.com/WalletConnect/awesome-walletconnect) - Community-curated collection of WalletConnect-enabled wallets, libraries, and tools.
- [AppKit Laboratory](https://lab.web3modal.com) - A place to test your wallet integrations against various setups of AppKit.
- [WalletKit GitHub](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet) - WalletKit GitHub repository.

### Wallet Resources

We have a set of official examples in our [web-examples](https://github.com/WalletConnect/web-examples) repository to help you get started.

**WalletKit**

This wallet can be used with any dapp using Sign v2 or Auth.

- [React WalletKit](https://github.com/WalletConnect/web-examples/tree/main/advanced/wallets/react-web3wallet) ([Demo](https://react-web3wallet.vercel.app))

**Sign**

- [React Wallet Ethers - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/wallets/react-wallet-v2) ([Demo](https://react-wallet.walletconnect.com/))

### Dapp Resources

If you need to test your app's integration, you can use one of our following demo wallets and/or dapps.

**Sign**

- [React dApp (with standalone client) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2) ([Demo](https://react-app.walletconnect.com/))
- [React dApp (with EthereumProvider + Ethers.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-ethers) ([Demo](https://react-dapp-v2-with-ethers.vercel.app/))
- [React dApp (with EthereumProvider + web3.js) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-web3js) ([Demo](https://react-dapp-v2-with-web3js.vercel.app/))
- [React dApp (with CosmosProvider) - v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-cosmos-provider) ([Demo](https://react-dapp-v2-cosmos-provider.vercel.app/))
</file>

<file path="docs/walletkit/web/usage.mdx">
import CloudBanner from '../../components/CloudBanner'

# Usage

This section provides instructions on how to initialize the WalletKit client, approve sessions with supported namespaces, and respond to session requests, enabling easy integration of Web3 wallets with dapps through a simple and intuitive interface.

## Cloud Configuration

Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain a new project ID.

<CloudBanner />

## Initialization

Create a new instance from Core and initialize it with a projectId created from installation. Next, create web3Wallet instance by calling init on Web3Wallet. Passing in the options object containing metadata about the app and an optional relay URL.

```javascript
import { Core } from '@walletconnect/core'
import { Web3Wallet } from '@walletconnect/web3wallet'

const core = new Core({
  projectId: process.env.PROJECT_ID
})

const web3wallet = await Web3Wallet.init({
  core, // <- pass the shared `core` instance
  metadata: {
    name: 'Demo app',
    description: 'Demo Client as Wallet/Peer',
    url: 'www.walletconnect.com',
    icons: []
  }
})
```

## Session

A session is a connection between a dapp and a wallet. It is established when a user approves a session proposal from a dapp. A session is active until the user disconnects from the dapp or the session expires.

### Namespace Builder

With Web3Wallet v1.5.1 (and @walletconnect/utils v2.6.1) we've published a helper utility that greatly reduces the complexity of parsing the `required` and `optional` namespaces. It accepts as parameters a `session proposal` along with your user's `chains/methods/events/accounts` and returns ready-to-use `namespaces` object.

```javascript
// util params
{
  proposal: ProposalTypes.Struct; // the proposal received by `.on("session_proposal")`
  supportedNamespaces: Record< // your Wallet's supported namespaces
    string, // the supported namespace key e.g. eip155
    {
      chains: string[]; // your supported chains in CAIP-2 format e.g. ["eip155:1", "eip155:2", ...]
      methods: string[]; // your supported methods e.g. ["personal_sign", "eth_sendTransaction"]
      events: string[]; // your supported events e.g. ["chainChanged", "accountsChanged"]
      accounts: string[] // your user's accounts in CAIP-10 format e.g. ["eip155:1:0x453d506b1543dcA64f57Ce6e7Bb048466e85e228"]
      }
  >;
};
```

Example usage

```javascript
// import the builder util
import { Web3Wallet, Web3WalletTypes } from '@walletconnect/web3wallet'
import { buildApprovedNamespaces, getSdkError } from '@walletconnect/utils'

async function onSessionProposal({ id, params }: Web3WalletTypes.SessionProposal){
  try{
    // ------- namespaces builder util ------------ //
    const approvedNamespaces = buildApprovedNamespaces({
      proposal: params,
      supportedNamespaces: {
        eip155: {
          chains: ['eip155:1', 'eip155:137'],
          methods: ['eth_sendTransaction', 'personal_sign'],
          events: ['accountsChanged', 'chainChanged'],
          accounts: [
            'eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb',
            'eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb'
          ]
        }
      }
    })
    // ------- end namespaces builder util ------------ //

    const session = await web3wallet.approveSession({
      id,
      namespaces: approvedNamespaces
    })
  }catch(error){
    // use the error.message to show toast/info-box letting the user know that the connection attempt was unsuccessful
    ....
    await web3wallet.rejectSession({
      id: proposal.id,
      reason: getSdkError("USER_REJECTED")
    })
  }
}


web3wallet.on('session_proposal', onSessionProposal)
```

If your wallet supports multiple namespaces e.g. `eip155`,`cosmos` & `near`
Your `supportedNamespaces` should look like the following example.

```javascript
// ------- namespaces builder util ------------ //
const approvedNamespaces = buildApprovedNamespaces({
    proposal: params,
    supportedNamespaces: {
        eip155: {...},
        cosmos: {...},
        near: {...}
    },
});
// ------- end namespaces builder util ------------ //
```

### Get Active Sessions

You can get the wallet active sessions using the `getActiveSessions` function.

```js
const activeSessions = web3wallet.getActiveSessions()
```

### EVM methods & events

In @walletconnect/ethereum-provider, (our abstracted EVM SDK for apps) we support by default the following Ethereum methods and events:

```ts
{
  //...
  methods: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_getCapabilities",
  ],
  events: [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect",
  ]
}
```

### Session Approval

The `session_proposal` event is emitted when a dapp initiates a new session with a user's wallet. The event will include a `proposal` object with information about the dapp and requested permissions. The wallet should display a prompt for the user to approve or reject the session. If approved, call `approveSession` and pass in the `proposal.id` and requested `namespaces`.

The `pair` method initiates a WalletConnect pairing process with a dapp using the given `uri` (QR code from the dapps). To learn more about pairing, checkout out the [docs](../../api/core/pairing.mdx).

```javascript
web3wallet.on('session_proposal', async proposal => {
  const session = await web3wallet.approveSession({
    id: proposal.id,
    namespaces
  })
})
await web3wallet.pair({ uri })
```

### üõ†Ô∏è Usage examples

- [in a demo wallet app](https://github.com/WalletConnect/web-examples/blob/a50c8eb5a10666f25911713c5358e78f1ca576d6/advanced/wallets/react-wallet-v2/src/views/SessionProposalModal.tsx#L264)
- [in integration tests](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/packages/web3wallet/test/sign.spec.ts#L55)

### ‚ö†Ô∏è Expected Errors

- `No matching key. proposal id doesn't exist: 1`

This rejection means the SDK can't find a record with the given `proposal.id` - in this example `1`.
This can happen when the proposal has expired (by default 5 minutes) or if you attempt to respond to a proposal that has already been approved/rejected.
If you are seeing this error, please make sure that you are calling `approveSession` with the correct `proposal.id` that is available within the proposal payload.

- `Error: Missing or invalid. approve(), namespaces should be an object with data`

This error means that the `namespaces` parameter passed to `approveSession` is either missing or invalid. Please check that you are passing a valid `namespaces` object that satisfies all required properties.

- `Non conforming namespaces. approve() namespaces <property> don't satisfy required namespaces.`

This error indicates that some value(s) in your `namespaces` object do not satisfy the required namespaces requested by the dapp.
To provide additional guidance, the message might include info about the exact property that is missing or invalid e.g. `Required: eip155:1 Approved: eip155:137`.
Please check [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md) to familiarize yourself with the standard and it's nuances.
Additionally, we highly recommend you to use our `namespace` builder utility that would greatly simplify the process of parsing & building a valid `namespaces` object.

### Session Rejection

In the event you want to reject the session proposal, call the `rejectSession` method. The `getSDKError` function comes from the `@walletconnect/utils` [library](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/utils).

```javascript
web3wallet.on('session_proposal', async proposal => {
  await web3wallet.rejectSession({
    id: proposal.id,
    reason: getSdkError('USER_REJECTED_METHODS')
  })
})
```

### üõ†Ô∏è Usage examples

- [in a demo wallet app](https://github.com/WalletConnect/web-examples/blob/a50c8eb5a10666f25911713c5358e78f1ca576d6/advanced/wallets/react-wallet-v2/src/views/SessionProposalModal.tsx#L287)
- [in integration tests](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/packages/web3wallet/test/sign.spec.ts#L79)

### ‚ö†Ô∏è Expected Errors

- `No matching key. proposal id doesn't exist: 1`

This rejection means the SDK can't find a record with the given `proposal.id` - in this example `1`.
This can happen when the proposal has expired (by default 5 minutes) or if you attempt to respond to a proposal that has already been approved/rejected.
If you are seeing this error, please make sure that you are calling `rejectSession` with the correct `proposal.id` that is available within the proposal payload.

- `Error: Missing or invalid. reject() reason:`

This rejection means the `reason` parameter passed to `rejectSession` is either missing or invalid.
We recommend using the `getSDKError` function from the `@walletconnect/utils` library that will populate & format the parameter for you.

### Responding to Session requests

The `session_request` event is emitted when the SDK received a request from the peer and it needs the wallet to perform a specific action, such as signing a transaction. The event contains a `topic` and a `request` object, which will vary depending on the action requested.

To respond to the request, you can access the `topic` and `request` object by destructuring them from the event payload. To see a list of possible `request` and `response` objects, refer to the relevant JSON-RPC Methods for [Ethereum](../../advanced/multichain/rpc-reference/ethereum-rpc.md), [Solana](../../advanced/multichain/rpc-reference/solana-rpc.md), [Cosmos](../../advanced/multichain/rpc-reference/cosmos-rpc.md), or [Stellar](../../advanced/multichain/rpc-reference/stellar-rpc.md).

As an example, if the dapp requests a `personal_sign` method, you can extract the `params` array from the `request` object. The first item in the array is the hex version of the message to be signed, which can be converted to UTF-8 and assigned to a `message` variable. The second item in `params` is the user's wallet address.

To sign the message, you can use your wallet's `signMessage` method and pass in the message. The signed message, along with the `id` from the event payload, can then be used to create a `response` object, which can be passed into `respondSessionRequest`.

```javascript
web3wallet.on('session_request', async event => {
  const { topic, params, id } = event
  const { request } = params
  const requestParamsMessage = request.params[0]

  // convert `requestParamsMessage` by using a method like hexToUtf8
  const message = hexToUtf8(requestParamsMessage)

  // sign the message
  const signedMessage = await wallet.signMessage(message)

  const response = { id, result: signedMessage, jsonrpc: '2.0' }

  await web3wallet.respondSessionRequest({ topic, response })
})
```

To reject a session request, the response should be similar to this.

```javascript
const response = {
  id,
  jsonrpc: '2.0',
  error: {
    code: 5000,
    message: 'User rejected.'
  }
}
```

### üõ†Ô∏è Usage examples

- [in a demo wallet app](https://github.com/WalletConnect/web-examples/blob/a50c8eb5a10666f25911713c5358e78f1ca576d6/advanced/wallets/react-wallet-v2/src/views/SessionSignModal.tsx#L36)
- [in integration tests](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/packages/web3wallet/test/sign.spec.ts#L165)

### ‚ö†Ô∏è Expected Errors

- `Error: No matching key. session topic doesn't exist: 'xyz...'`

This rejection means the SDK can't find a session with the given `topic` - in this example `xyz...`.
This can happen when the session has been disconnected by either the wallet or the dapp while the session request was being processed or if a session with such topic doesn't exist.
If you are seeing this error, please make sure that you are using a correct topic that is available within the request payload.

- `Error: Missing or invalid. respond() response:`

This rejection means the `response` parameter passed to `respondSessionRequest` is either missing or invalid. The response should be a valid [JSON-RPC 2.0](https://www.jsonrpc.org/specification) response object.
We recommend you to use our `formatJsonRpcResult` utility from `"@walletconnect/jsonrpc-utils"` that will format the response for you.

Example usage:
`id` argument being the request id from the request payload.

```javascript
import { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils'

const signature = await cryptoWallet.signTransaction(signTransaction)
const response = await web3wallet.respondSessionRequest({
  topic: session.topic,
  response: formatJsonRpcResult(id, signature)
})
```

### Updating a Session

If you wish to include new accounts or chains or methods in an existing session, `updateSession` allows you to do so.
You need pass in the `topic` and a new `Namespaces` object that contains all of the existing namespaces as well as the new data you wish to include.
After you update the session, the other peer will receive a `session_update` event.

An example adding a new account to an existing session:

```javascript
const namespaces = session.namespaces
const accounts = [
  'eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb',
  'eip155:1:0x1234567890123456789012345678901234567890'
]
const updatedNamespaces = {
  ...namespaces,
  eip155: {
    ...namespaces.eip155,
    accounts
  }
}
const { acknowledged } = await web3wallet.updateSession({
  topic: session.topic,
  namespaces: updatedNamespaces
})
// If you wish to be notified when the dapp acknowledges the update.
// note that if the dapp is offline `acknowledged` will not resolve until it comes back online
await acknowledged()
```

An example adding a new chain to an existing session:

```javascript
const namespaces = session.namespaces
const chains = ['eip155:1', 'eip155:137']
const accounts = [
  'eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb',
  'eip155:137:0x1234567890123456789012345678901234567890'
]
const updatedNamespaces = {
  ...namespaces,
  eip155: {
    ...namespaces.eip155,
    accounts,
    chains
  }
}
await web3wallet.updateSession({ topic: session.topic, namespaces: updatedNamespaces })
```

### üõ†Ô∏è Usage examples

- [in a demo wallet app](https://github.com/WalletConnect/web-examples/blob/a50c8eb5a10666f25911713c5358e78f1ca576d6/advanced/wallets/react-wallet-v2/src/pages/session.tsx#L77)
- [in integration tests](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/packages/web3wallet/test/sign.spec.ts#L98)

### ‚ö†Ô∏è Expected Errors

Note that all `namespaces` validation applies and you still have to satisfy the required namespaces requested by the dapp.

- `Error: No matching key. session topic doesn't exist: 'xyz...'`

This rejection means the SDK can't find a session with the given `topic` - in this example `xyz...`.
This can happen when the session you're trying to update has already been disconnected by either the wallet or the dapp or if a session with such topic doesn't exist.
If you are seeing this error, please make sure that you are using a correct topic of an active session.

- `Error: Missing or invalid. update(), namespaces should be an object with data`

This error means that the `namespaces` parameter passed to `updateSession` is either missing or invalid. Please check that you are passing a valid `namespaces` object that satisfies all required properties.

- `Non conforming namespaces. update() namespaces <property> don't satisfy required namespaces.`

This error indicates that some value(s) in your `namespaces` object do not satisfy the required namespaces requested by the dapp.
To provide additional guidance, the message might include info about the exact property that is missing or invalid e.g. `Required: eip155:1 Approved: eip155:137`.
Please check [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md) to familiarize yourself with the standard and it's nuances.
Additionally, we highly recommend you to use our `namespace` builder utility that would greatly simplify the process of parsing & building a valid `namespaces` object.

### Extending a Session

Sessions have a default expiry of 7 days. To extend a session by an additional 7 days, call `.extendSession` method and pass in the `topic` of the session you wish to extend.

```javascript
const { acknowledged } = await web3wallet.extendSession({ topic })
// if you wish to be notified when the dapp acks the extend
// note that if the dapp is offline `acknowledged` will not resolve until it comes back online
await acknowledged()
```

### üõ†Ô∏è Usage examples

- [in integration tests](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/packages/web3wallet/test/sign.spec.ts#L130)

### ‚ö†Ô∏è Expected Errors

- `Error: No matching key. session topic doesn't exist: 'xyz...'`

This rejection means the SDK can't find a session with the given `topic` - in this example `xyz...`.
This can happen when the session you're trying to update has already been disconnected by either the wallet or the dapp or if a session with such topic doesn't exist.
If you are seeing this error, please make sure that you are using a correct topic of an active session.

### Session Disconnect

To initiate disconnect from a session(think session delete), call `.disconnectSession` by passing a `topic` & `reason` for the disconnect.
The other peer will receive a `session_delete` and be notified that the session has been disconnected.

:::info Note
It's important that you're subscribed to the `session_delete` event as well, to be notified when the other peer initiates a disconnect.
:::
:::note Tip
We recommend using the `getSDKError` utility function, that will provide ready-to-use `reason` payloads and is available in the `@walletconnect/utils` [library](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/utils).
:::

```javascript
await web3wallet.disconnectSession({
  topic,
  reason: getSdkError('USER_DISCONNECTED')
})
```

### üõ†Ô∏è Usage examples

- [in integration tests](https://github.com/WalletConnect/walletconnect-monorepo/blob/v2.0/packages/web3wallet/test/sign.spec.ts#L222)

### ‚ö†Ô∏è Expected Errors

- `Error: No matching key. session topic doesn't exist: 'xyz...'`

This rejection means the SDK can't find a session with the given `topic` - in this example `xyz...`.
This can happen when the session you're trying to update has already been disconnected by either the wallet or the dapp or if a session with such topic doesn't exist.
If you are seeing this error, please make sure that you are using a correct topic of an active session.

### Emitting Session Events

To emit session events, call the `emitSessionEvent` and pass in the params. If you wish to switch to chain/account that is not approved (missing from `session.namespaces`) you will have to update the session first. In the following example, the wallet will emit `session_event` that will instruct the dapp to switch the active accounts.

```javascript
await web3wallet.emitSessionEvent({
  topic,
  event: {
    name: 'accountsChanged',
    data: ['0xab16a96D359eC26a11e2C2b3d8f8B8942d5Bfcdb']
  },
  chainId: 'eip155:1'
})
```

In the following example, the wallet will emit `session_event` when the wallet switches chains.

```javascript
await web3wallet.emitSessionEvent({
  topic,
  event: {
    name: 'chainChanged',
    data: 1
  },
  chainId: 'eip155:1'
})
```
</file>

<file path="docs/walletkit/web/verify.mdx">
# Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.
Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and [Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1).
For those looking to enable Verify on the app side, check out our reference guide [here.](./cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

These are:

![Verify Banner](/img/verify-banner.png)

## Disclaimer

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

## Domain risk detection

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either `VALID`, `INVALID` or `UNKNOWN`.

- Domain match: The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `VALID`.
- Unverified: The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `UNKNOWN`.
- Mismatch: The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The `verifyContext` included in the request will have a validation of `INVALID`
- Threat: This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The `verifyContext` included in the request will contain parameter `isScam` with value `true`.

### Implementation

To check the Verify API validations and whether or not your user is interacting with potentially malicious app, you can do so by accessing the `verifyContext` included in the request payload.

```javascript
...
web3wallet.on("auth_request", async (authRequest) => {
  const { verifyContext } = authRequest
  const validation = verifyContext.verified.validation // can be VALID, INVALID or UNKNOWN
  const origin = verifyContext.verified.origin // the actual verified origin of the request
  const isScam = verifyContext.verified.isScam // true if the domain is flagged as malicious

  // if the domain is flagged as malicious, you should warn the user as they may lose their funds - check the `Threat` case for more info
  if(isScam) {
    // show a warning screen to the user
    // and proceed only if the user accepts the risk
  }

  switch(validation) {
    case "VALID":
      // proceed with the request - check the `Domain match` case for more info
      break
    case "INVALID":
      // show a warning dialog to the user - check the `Mismatch` case for more info
      // and proceed only if the user accepts the risk
      break
    case "UNKNOWN":
      // show a warning dialog to the user - check the `Unverified` case for more info
      // and proceed only if the user accepts the risk
      break
  }
})
```

For live demo examples of the intended Verify API flows, check out our demo apps:

- [Demo Wallet](https://react-wallet.walletconnect.com)
- [Demo App](https://react-app.walletconnect.com/) - you can toggle between the verify states by clicking on the `gear` & selecting the decided Validation before connecting to the wallet
- [Demo Malicious App](https://malicious-app-verify-simulation.vercel.app/) - this app is flagged as malicious and will have the `isScam` parameter set to `true` in the `verifyContext` of the request
</file>

<file path="docs/walletkit/best-practices.mdx">
---
title: Best Practices
---

import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'
import PlatformTabs from '../components/PlatformTabs'
import PlatformTabItem from '../components/PlatformTabItem'


# Best Practices for Wallets

To ensure the smoothest and most seamless experience for our users, WalletConnect is committed to working closely with wallet providers to encourage the adoption of our recommended best practices.

By implementing these guidelines, we aim to optimize performance and minimize potential challenges, even in suboptimal network conditions.

We are actively partnering with wallet developers to optimize performance in scenarios such as:

1. **Success and Error Messages** - Users need to know what‚Äôs going on, at all times. Too much communication is better than too little. The less users need to figure out themselves or assume what‚Äôs going on, the better.
2. **(Perceived) Latency** - A lot of factors can influence latency (or perceived latency), e.g. network conditions, position in the boot chain, waiting on the wallet to connect or complete a transaction and not knowing if or when it has done it.
3. **Old SDK Versions** - Older versions can have known and already fixed bugs, leading to unnecessary issues to users, which can be simply and quickly solved by updating to the latest SDK.

To take all of the above into account and to make experience better for users, we've put together some key guidelines for wallet providers. These best practices focus on the most important areas for improving user experience.

Please follow these best practices and make the experience for your users and yourself a delightful and quick one.

## Checklist Before Going Live

To make sure your wallet adheres to the best practices, we recommend implementing the following checklist before going live. You can find more detailed information on each point below.

1. **Success and Error Messages**
   - ‚úÖ Display clear and concise messages for all user interactions
   - ‚úÖ Provide feedback for all user actions
     - ‚úÖ Connection success
     - ‚úÖ Connection error
     - ‚úÖ Loading indicators for waiting on connection, transaction, etc.
   - ‚úÖ Ensure that users are informed of the status of their connection and transactions
   - ‚úÖ Implement status indicators internet availability
   - ‚úÖ Make sure to provide feedback not only to users but also back to the dapp (e.g., if there's an error or a user has not enough funds to pay for gas, don't just display the info message to the user, but also send the error back to the dapp so that it can change the state accordingly)
2. **Mobile Linking**
   - ‚úÖ Implement mobile linking to allow for automatic redirection between the wallet and the dapp
   - ‚úÖ Use deep linking over universal linking for a better user experience
   - ‚úÖ Ensure that the user is redirected back to the dapp after completing a transaction
3. **Latency**
   - ‚úÖ Optimize performance to minimize latency
   - ‚úÖ Latency for connection in normal conditions: under 5 seconds
   - ‚úÖ Latency for connection in poor network (3G) conditions: under 15 seconds
   - ‚úÖ Latency for signing in normal conditions: under 5 seconds
   - ‚úÖ Latency for signing in poor network (3G) conditions: under 10 seconds
4. **Verify API**
   - ‚úÖ Present users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious (Domain match, Unverified, Mismatch, Threat)
5. **Latest SDK Version**
   - ‚úÖ Ensure that you are using the latest SDK version
   - ‚úÖ Update your SDK regularly to benefit from the latest features and bug fixes
   - ‚úÖ Subscribe to SDK updates to stay informed about new releases

## 1. Success and Error Messages

Users often face ambiguity in determining whether their connection or transactions were successful. They are also not guided to switching back into the dapp or automatically switched back when possible, causing unnecessary user anxiety. Additionally, wallets typically lack status indicators for connection and internet availability, leaving users in the dark.

![](/assets/connection-successful.png)

<center>_An example of a successful connection message in a Rainbow wallet_</center>

### Pairing

A pairing is a connection between a wallet and a dapp that has fixed permissions to only allow a dapp to propose a session through it. Dapp can propose infinite number of sessions on one pairing. Wallet must use a pair method from Web3Wallet client to pair with dapp.

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```jsx
const uri = 'xxx'; // pairing uri
try {
    await web3Wallet.pair({ uri });
} catch (error) {
    // some error happens while pairing - check Expected errors section
}
```
</PlatformTabItem>
<PlatformTabItem value="react-native" label="React Native">
```jsx
const uri = 'xxx'; // pairing uri
try {
    await web3Wallet.pair({ uri });
} catch (error) {
    // some error happens while pairing - check Expected errors section
}
```
</PlatformTabItem>
<PlatformTabItem value="ios" label="iOS">
```swift
let uri = WalletConnectURI(string: urlString)

if let uri {
Task {
try await Web3Wallet.instance.pair(uri: uri)
}
}

````
</PlatformTabItem>
<PlatformTabItem value="android" label="Android">
```kotlin
val pairingParams = Wallet.Params.Pair(pairingUri)
Web3Wallet.pair(pairingParams,
    onSuccess = {
        //Subscribed on the pairing topic successfully. Wallet should await for a session proposal
    },
    onError = { error ->
        //Some error happens while pairing - check Expected errors section
    }
}
````

</PlatformTabItem>
</PlatformTabs>

#### Pairing Expiry

A pairing expiry event is triggered whenever a pairing is expired. The expiry for inactive pairing is 5 mins, whereas for active pairing is 30 days. A pairing becomes active when a session proposal is received and user successfully approves it. This event helps to know when given pairing expires and update UI accordingly.

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
core.pairing.events.on("pairing_expire", (event) => {
    // pairing expired before user approved/rejected a session proposal
    const { topic } = topic;
});
```
  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
core.pairing.events.on("pairing_expire", (event) => {
    // pairing expired before user approved/rejected a session proposal
    const { topic } = topic;
});
```
  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```Swift
Web3Wallet.instance.pairingExpirationPublisher
    .receive(on: DispatchQueue.main)
    .sink { pairing in
    guard !pairing.active else { return }
    // let user know that pairing has expired
}.store(in: &publishers)
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
val coreDelegate = object : CoreClient.CoreDelegate {
    override fun onPairingExpired(expiredPairing: Core.Model.ExpiredPairing) {
        // Here a pairing expiry is triggered
    }
    // ...other callbacks
}

CoreClient.setDelegate(coreDelegate)

````
</PlatformTabItem>
</PlatformTabs>

#### Pairing messages

1. Consider displaying a successful pairing message when pairing is successful. Before that happens, wallet should show a loading indicator.
2. Display an error message when a pairing fails.

#### Expected Errors

While pairing, the following errors might occur:

- **No Internet connection error or pairing timeout when scanning QR with no Internet connection**
  - User should pair again with Internet connection
- **Pairing expired error when scanning a QR code with expired pairing**
  - User should refresh a QR code and scan again
- **Pairing with existing pairing is not allowed**
  - User should refresh a QR code and scan again. It usually happens when user scans an already paired QR code.

### Session Proposal

A session proposal is a handshake sent by a dapp and its purpose is to define session rules. Whenever a user wants to establish a connection between a wallet and a dapp, one should approve a session proposal.

Whenever user approves or rejects a session proposal, a wallet should show a loading indicator the moment the button is pressed, until Relay acknowledgement is received for any of these actions.

#### Approving session

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
try {
    await web3Wallet.approveSession(params);
    // update UI -> remove the loader
} catch (error) {
    // present error to the user
}
````

  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
try {
    await web3Wallet.approveSession(params);
    // update UI -> remove the loader
} catch (error) {
    // present error to the user
}
```
  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```swift
do {
    try await Web3Wallet.instance.approve(proposalId: proposal.id, namespaces: sessionNamespaces, sessionProperties: proposal.sessionProperties)
    // Update UI, remove loader
} catch {
    // present error
}
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
Web3Wallet.approveSession(approveProposal,
  onSuccess = {
    //Session approval response was sent successfully - update your UI
  }
    onError = { error ->
      //Error while sending session approval - update your UI
  })
```
</PlatformTabItem>
</PlatformTabs>

#### Rejecting session

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
try {
    await web3Wallet.rejectSession(params);
    // update UI -> remove the loader
} catch (error) {
    // present error to the user
}
```
  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
try {
    await web3Wallet.rejectSession(params);
    // update UI -> remove the loader
} catch (error) {
    // present error to the user
}
```
  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```swift
do {
    try await Web3Wallet.instance.reject(proposalId: proposal.id, reason: .userRejected)
    // Update UI, remove loader
} catch {
    // present error
}
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
Web3Wallet.rejectSession(reject,
  onSuccess = {
      //Session rejection response was sent successfully - update your UI
  },
  onError = { error ->
        //Error while sending session rejection - update your UI
  })
```
</PlatformTabItem>
</PlatformTabs>

#### Session proposal expiry

A session proposal expiry is 5 minutes. It means a given proposal is stored for 5 minutes in the SDK storage and user has 5 minutes for the approval or rejection decision. After that time, the below event is emitted and proposal modal should be removed from the app's UI.

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
web3wallet.on("proposal_expire", (event) => {
    // proposal expired and any modal displaying it should be removed
    const { id } = event;
});
```
  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
web3wallet.on("proposal_expire", (event) => {
    // proposal expired and any modal displaying it should be removed
    const { id } = event;
});
```
  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```swift
Web3Wallet.instance.sessionProposalExpirationPublisher.sink { _ in
    // let user know that session proposal has expired, update UI
}.store(in: &publishers)
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
  override fun onProposalExpired(proposal: Wallet.Model.ExpiredProposal) {
          // Here this event is triggered when a proposal expires - update your UI
  }
  // ...other callbacks
}
Web3Wallet.setWalletDelegate(walletDelegate)
```
</PlatformTabItem>
</PlatformTabs>

#### Session Proposal messages

1. Consider displaying a successful session proposal message before redirecting back to the dapp. Before the success message is displayed, wallet should show a loading indicator.
2. Display an error message when session proposal fails.

#### Expected errors

While approving or rejecting a session proposal, the following errors might occur:

- **No Internet connection**
  - It happens when a user tries to approve or reject a session proposal with no Internet connection
- **Session proposal expired**
  - It happens when a user tries to approve or reject an expired session proposal
- **Invalid [namespaces](../advanced/glossary#namespaces)**
  - It happens when a validation of session namespaces fails
- **Timeout**
  - It happens when Relay doesn't acknowledge session settle publish within 10s

### Session Request

A session request represents the request sent by a dapp to a wallet.

Whenever user approves or rejects a session request, a wallet should show a loading indicator the moment the button is pressed, until Relay acknowledgement is received for any of these actions.

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
try {
    await web3Wallet.respondSessionRequest(params);
    // update UI -> remove the loader
} catch (error) {
    // present error to the user
}
```
  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
try {
    await web3Wallet.respondSessionRequest(params);
    // update UI -> remove the loader
} catch (error) {
    // present error to the user
}
```
  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```swift
do {
    try await Web3Wallet.instance.respond(requestId: request.id, signature: signature, from: account)
    // update UI -> remove the loader
} catch {
    // present error to the user
}
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
Web3Wallet.respondSessionRequest(Wallet.Params.SessionRequestResponse,
  onSuccess = {
      //Session request response was sent successfully - update your UI
  },
  onError = { error ->
      //Error while sending session response - update your UI
  })
```
</PlatformTabItem>
</PlatformTabs>

#### Session request expiry

A session request expiry is defined by a dapp. Its value must be between `now() + 5mins` and `now() + 7 days`. After the session request expires, the below event is emitted and session request modal should be removed from the app's UI.

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
web3wallet.on("session_request_expire", (event) => {
  // request expired and any modal displaying it should be removed
  const { id } = event;
});
```
  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
web3wallet.on("session_request_expire", (event) => {
  // request expired and any modal displaying it should be removed
  const { id } = event;
});
```
  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```swift
Web3Wallet.instance.requestExpirationPublisher.sink { _ in
    // let user know that request has expired
}.store(in: &publishers)
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
  override fun onRequestExpired(request: Wallet.Model.ExpiredRequest) {
      // Here this event is triggered when a session request expires - update your UI
  }
  // ...other callbacks
}
Web3Wallet.setWalletDelegate(walletDelegate)
```
</PlatformTabItem>
</PlatformTabs>

#### Expected errors

While approving or rejecting a session request, the following errors might occur:

- **Invalid session**
  - This error might happen when a user approves or rejects a session request on an expired session
- **Session request expired**
  - This error might happen when a user approves or rejects a session request that already expired
- **Timeout**
  - It happens when Relay doesn't acknowledge session settle publish within 10 seconds

### Connection state

The Web Socket connection state tracks the connection with the Relay server. An event is emitted whenever a connection state changes.

<PlatformTabs activeOptions={["web","ios","android", "react-native"]}>
  <PlatformTabItem value="web" label="Web">
```typescript
core.relayer.on("relayer_connect", () => {
  // connection to the relay server is established
})

core.relayer.on("relayer_disconnect", () => {
// connection to the relay server is lost
})

````
  </PlatformTabItem>
  <PlatformTabItem value="react-native" label="React Native">
```typescript
core.relayer.on("relayer_connect", () => {
  // connection to the relay server is established
})

core.relayer.on("relayer_disconnect", () => {
  // connection to the relay server is lost
})
````

  </PlatformTabItem>
  <PlatformTabItem value="ios" label="iOS">
```swift
Web3Wallet.instance.socketConnectionStatusPublisher
  .receive(on: DispatchQueue.main)
  .sink { status in
  switch status {
  case .connected:
    // ...
  case .disconnected:
    // ...
  }
}.store(in: &publishers)
```
  </PlatformTabItem>
  <PlatformTabItem value="android" label="Android">
```kotlin
val walletDelegate = object : Web3Wallet.WalletDelegate {
  override fun onConnectionStateChange(state: Wallet.Model.ConnectionState) {
    // Here this event is triggered when a connection state has changed
  }
  // ...other callbacks
}
Web3Wallet.setWalletDelegate(walletDelegate)
```
</PlatformTabItem>
</PlatformTabs>

#### Connection state messages

When the connection state changes, show a message in the UI. For example, display a message when the connection is lost or re-established.

## 2. Mobile Linking

### Why use Mobile Linking?

Mobile Linking uses the mobile device‚Äôs native OS to automatically redirect between the native wallet app and a native app. This results in few user actions a better UX.

#### Establishing Communication Between Mobile Wallets and Apps

When integrating a wallet with a mobile application, it's essential to understand how they communicate. The process involves two main steps:

1. **QR Code Handshake:**¬†The mobile app (Dapp) generates a unique URI (Uniform Resource Identifier) and displays it as a QR code. This URI acts like a secret handshake. When the user scans the QR code or copy/pastes the URI using their wallet app, they establish a connection. It's like saying, "Hey, let's chat!"
2. **Deep Links and Universal Links:**¬†The URI from the QR code allows the wallet app to create a¬†[deep link](https://support.google.com/google-ads/answer/10023042)¬†or¬†[universal link](https://developer.apple.com/ios/universal-links/). These links work on both Android and iOS. They enable seamless communication between the wallet and the app.

:::tip

**Developers should prefer Deep Linking over Universal Linking.**<br />
In the case of Universal Linking, the user may be redirected to the browser, which may not be the desired behavior. Deep Linking ensures that the user is redirected to the app, providing a seamless experience.

:::

### Connection Flow

1. **Dapp prompts user:**¬†The Dapp asks the user to connect.
2. **User chooses wallet:**¬†The user selects a wallet from a list of compatible wallets.
3. **Redirect to wallet:**¬†The user is redirected to their chosen wallet.
4. **Wallet approval:**¬†The wallet prompts the user to approve or reject the session (similar to granting permission).
5. **Return to dapp:**
   - **Manual return:**¬†The wallet asks the user to manually return to the Dapp.
   - **Automatic return:**¬†Alternatively, the wallet automatically takes the user back to the Dapp.
6. **User reunites with dapp:**¬†After all the interactions, the user ends up back in the Dapp.

<ThemedImage
  alt="Mobile Linking Connect Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking-dark.png')
  }}
/>

### Sign Request Flow

When the Dapp needs the user to sign something (like a transaction), a similar pattern occurs:

1. **Automatic redirect:**¬†The Dapp automatically sends the user to their previously chosen wallet.
2. **Approval prompt:**¬†The wallet asks the user to approve or reject the request.
3. **Return to dapp:**
   - **Manual return:**¬†The wallet asks the user to manually return to the Dapp.
   - **Automatic return:**¬†Alternatively, the wallet automatically takes the user back to the Dapp.
4. **User reconnects:**¬†Eventually, the user returns to the Dapp.

<ThemedImage
  alt="Mobile Linking Sign Flow"
  sources={{
    light: useBaseUrl('/img/w3w/mobileLinking_sign-light.png'),
    dark: useBaseUrl('/img/w3w/mobileLinking_sign-dark.png')
  }}
/>

### Platform Specific Preparation

<PlatformTabs activeOptions={["ios","android", "flutter", "react-native"]}>
  <PlatformTabItem value="ios" label="iOS">
  Read the specific steps for iOS here: [Platform preparations](./ios/mobile-linking#platform-preparations)
  </PlatformTabItem>

  <PlatformTabItem value="android" label="Android">
  Read the specific steps for Android here: [Platform preparations](./android/mobile-linking#platform-preparations)
  </PlatformTabItem>

  <PlatformTabItem value="flutter" label="Flutter">
  Read the specific steps for Flutter here: [Platform preparations](./flutter/mobile-linking#platform-preparations)
  </PlatformTabItem>

  <PlatformTabItem value="react-native" label="React Native">
  Read the specific steps for React Native here: [Platform preparations](./react-native/mobile-linking#platform-preparations)
  </PlatformTabItem>
</PlatformTabs>

### How to Test

To experience the desired behavior, try our Sample Wallet and Dapps which use our Mobile linking best practices. These are available on all platforms.

Once you have completed your integration, you can test it against our sample apps to see if it is working as expected. Download the app and and try your mobile linking integration on your device.

<PlatformTabs activeOptions={["ios","android", "flutter", "react-native"]}>
  <PlatformTabItem value="ios" label="iOS">
  - [Sample Wallet](https://testflight.apple.com/join/09bTAryp) - on TestFlight
  - [Sample App](https://testflight.apple.com/join/7S1GYcjC) - on TestFlight
  </PlatformTabItem>

  <PlatformTabItem value="android" label="Android">
  - [Sample Wallet](https://appdistribution.firebase.dev/i/6f9437a5f9bf4eec) - on Firebase
  - [Sample App](https://appdistribution.firebase.dev/i/5e4fe4b30c8a208d) - on Firebase
  </PlatformTabItem>

  <PlatformTabItem value="flutter" label="Flutter">
  - Sample Wallet:
    - [Sample Wallet for iOS](https://testflight.apple.com/join/Uv0XoBuD)
    - [Sample Wallet for Android](https://appdistribution.firebase.dev/i/2b8b3dce9e2831cd)
  - Sample App:
    - [Sample App for iOS](https://testflight.apple.com/join/ClqbHc17)
    - [Sample App for Android](https://appdistribution.firebase.dev/i/a8efff56e3f0fdb0)
  - AppKit Dapp:
    - [AppKit Dapp for iOS](https://testflight.apple.com/join/ClqbHc17)
    - [AppKit Dapp for Android](https://appdistribution.firebase.dev/i/a8efff56e3f0fdb0)
  </PlatformTabItem>

  <PlatformTabItem value="react-native" label="React Native">
  - Sample Wallet:
    - [Sample Wallet for Android](https://appdistribution.firebase.dev/i/e7711e780547234e)
  - Sample App:
    - [Sample App for iOS](https://testflight.apple.com/join/Ivd8bg7s)
    - [Sample App for Android](https://appdistribution.firebase.dev/i/0297fbd3de8f1e3f)
  </PlatformTabItem>
</PlatformTabs>


## 3. Latency

Our SDK‚Äôs position in the boot chain can lead to up to 15 seconds in throttled network conditions. Lack of loading indicators exacerbates the perceived latency issues, impacting user experience negatively. Additionally, users often do not receive error messages or codes when issues occur or timeouts happen.

### Target latency

For **connecting**, the target latency is:

- **Under 5 seconds** in normal conditions
- **Under 15 seconds** when throttled (3G network speed)

For **signing**, the target latency is:

- **Under 5 seconds** in normal conditions
- **Under 10 seconds** when throttled (3G network speed)

### How to test

To test latency under suboptimal network conditions, you can enable throttling on your mobile phone. You can simulate different network conditions to see how your app behaves in various scenarios.

For example, on iOS you need to enable Developer Mode and then go to **Settings > Developer > Network Link Conditioner**. You can then select the network condition you want to simulate. For 3G, you can select **3G** from the list, for no network or timeout simulations, choose **100% Loss**.

Check this article for how to simulate slow internet connection on iOS & Android, with multiple options for both platforms: [How to simulate slow internet connection on iOS & Android](https://www.browserstack.com/guide/how-to-simulate-slow-network-conditions).

## 4. Verify API

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry. Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of WalletConnect‚Äôs domain registry and¬†[Blowfish's domain scanner](https://docs.blowfish.xyz/reference/scan-domain-1). For those looking to enable Verify on the app side, check out our reference guide¬†[here.](https://docs.walletconnect.com/walletkit/web/cloud/verify)

When a user initiates a connection with an application, Verify API enables wallets to present their users with four key states that can help them determine whether the domain they‚Äôre about to connect to might be malicious.

Possible states:

- Domain match
- Unverified
- Mismatch
- Threat

![Verify States](/img/verify-states-1.png)
![Verify States](/img/verify-states-2.png)

:::info Note

Verify API is not designed to be bulletproof but to make the impersonation attack harder and require a somewhat sophisticated attacker. We are working on a new standard with various partners to close those gaps and make it bulletproof.

:::

### Domain risk detection[](https://docs.walletconnect.com/walletkit/web/verify#domain-risk-detection)

The Verify security system will discriminate session proposals & session requests with distinct validations that can be either¬†`VALID`,¬†`INVALID`¬†or¬†`UNKNOWN`.

- **Domain match:** The domain linked to this request has been verified as this application's domain.
  - This interface appears when the domain a user is attempting to connect to has been ‚Äòverified‚Äô in our domain registry as the registered domain of the application the user is trying to connect to, and the domain has not returned as suspicious from either of the security tools we work with. The¬†`verifyContext`¬†included in the request will have a validation of¬†`VALID`.
- **Unverified:** The domain sending the request cannot be verified.
  - This interface appears when the domain a user is attempting to connect to has not been verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The¬†`verifyContext`¬†included in the request will have a validation of¬†`UNKNOWN`.
- **Mismatch:** The application's domain doesn't match the sender of this request.
  - This interface appears when the domain a user is attempting to connect to has been flagged as a different domain to the one this application has verified in our domain registry, but the domain has not returned as suspicious from either of the security tools we work with. The¬†`verifyContext`¬†included in the request will have a validation of¬†`INVALID`
- **Threat:** This domain is flagged as malicious and potentially harmful.
  - This interface appears when the domain a user is attempting to connect to has been flagged as malicious on one or more of the security tools we work with. The¬†`verifyContext`¬†included in the request will contain parameter¬†`isScam`¬†with value¬†`true`.

### Verify API Implementation

To see how to implement Verify API for your framework, see [Verify API](./features/verify) page and select your platform to see code examples.

### How to test

To test Verify API with a malicious domain, you can check out the [Malicious React dapp](https://malicious-app-verify-simulation.vercel.app/), created specifically for testing. This app is flagged as malicious and will have the `isScam` parameter set to `true` in the `verifyContext` of the request. You can use this app to test how your wallet behaves when connecting to a malicious domain.

### Error messages

![Verify API flagged domain](/assets/verify-api-flagged-domain.png)

_A sample error warning when trying to connect to a malicious domain_

## 5. Latest SDK

Numerous features have been introduced, bugs have been identified and fixed over time, stability has improved, but many dapps and wallets continue to use older SDK versions with known issues, affecting overall reliability.

Make sure you are using the latest version of the SDK for your platform

<PlatformTabs activeOptions={["ios","android", "flutter", "react-native"]}>
  <PlatformTabItem value="ios" label="iOS">
  - **WalletConnectSwiftV2**: [Latest release](https://github.com/WalletConnect/WalletConnectSwiftV2/releases/latest/)
  </PlatformTabItem>

  <PlatformTabItem value="android" label="Android">
  - **WalletConnectKotlinV2**: [Latest release](https://github.com/WalletConnect/WalletConnectKotlinV2/releases/latest)
  </PlatformTabItem>

  <PlatformTabItem value="flutter" label="Flutter">
  - **WalletConnectFlutterV2**: [Latest release](https://github.com/WalletConnect/WalletConnectFlutterV2/releases/latest)
  </PlatformTabItem>

  <PlatformTabItem value="react-native" label="React Native">
  - **AppKit for React Native**: [Latest release](https://github.com/WalletConnect/web3modal-react-native/releases/latest)
  </PlatformTabItem>
</PlatformTabs>

### Subscribe to updates

To stay up to date with the latest SDK releases, you can use GitHub's native feature to subscribe to releases. This way, you will be notified whenever a new release is published. You can find the "Watch" button on the top right of the repository page. Click on it, then select "Custom" and "Releases only". You'll get a helpful ping whenever a new release is out.

![Subscribe to releases](/assets/subsribe-to-release-updates.png)

## Resources

- [React Wallet](https://react-wallet.walletconnect.com/) - for testing dapps, features, Verify API messages, etc.
- [React dapp](https://react-app.walletconnect.com/) - for testing wallets
- [Malicious React dapp](https://malicious-app-verify-simulation.vercel.app/) - for testing Verify API with malicious domain
</file>

<file path="docs/walletkit/overview.mdx">
---
pagination_next: walletkit/features/notifications
title: Overview
---

import Wrapper from '../components/Home/Wrapper.js'

import androidLogo from '../../static/assets/home/androidLogo.png'
import iosLogo from '../../static/assets/home/iosLogo.png'
import rnLogo from '../../static/assets/home/rnLogo.png'
import flutterLogo from '../../static/assets/home/flutterLogo.png'
import csharpLogo from '../../static/assets/home/csharpLogo.png'
import javascriptLogo from '../../static/assets/home/javascriptLogo.png'

# WalletKit

Unlock powerful wallet-native features and provide a simple, secure way for your wallet users to easily connect with thousands of apps and enjoy unbeaten experiences across connectivity, security, and communication.

## Get Started

<Wrapper
  type="large"
  fit={false}
  items={[
    {
      name: 'Android',
      type: 'android',
      description: 'Get started with WalletKit in Android.',
      icon: androidLogo,
      href: './android/installation'
    },
    {
      name: 'iOS',
      type: 'ios',
      description: 'Get started with WalletKit in iOS.',
      icon: iosLogo,
      href: './ios/installation',
      isWhite: true
    },
    {
      name: 'React Native',
      type: 'react-native',
      description: 'Get started with WalletKit in React Native.',
      icon: rnLogo,
      href: './react-native/installation'
    },
    {
      name: 'Flutter',
      type: 'flutter',
      description: 'Get started with WalletKit in Flutter.',
      icon: flutterLogo,
      href: './flutter/installation'
    },
    {
      name: 'Web',
      type: 'javascript',
      description: 'Get started with WalletKit in Web.',
      icon: javascriptLogo,
      href: './web/installation'
    },
    {
      name: 'C#',
      type: 'csharp',
      description: 'Get started with WalletKit in C#.',
      icon: csharpLogo,
      href: './c-sharp/installation',
      isWhite: true
    }
  ]}
/>

### Features

![WalletKit banner](../../static/img/walletkit.png)

Some of the key features of WalletKit include:

- **Sign API**: Allows dapps to request that the user sign a transaction or message.
- **Auth API**: Allows dapps to verify wallet address ownership through a single signature request, realizing login in one action.
- **Chain agnostic**: WalletKit is designed to work with any blockchain, so you can easily support multiple chains without having to write separate integration code.
</file>

<file path="docs/web3modal/v2/_partials/customisation/customChainImages.mdx">
AppKit tries to provide default images for most wagmi chain defaults,
but if image for your chain is missing or you want to override it, you can use `chainImages` options:
</file>

<file path="docs/web3modal/v2/_partials/customisation/customChainProviders.mdx">
Wagmi requires that one or more providers (RPCs) are configured that support all your target chains. AppKit provides WalletConnect RPC via `w3mProvider` helper.
WalletConnect RPC `https://rpc.walletconnect.com` is free to use (rate limit may be applied to specific users if abuse is detected). WalletConnect RPC currently supports following chains:

```
1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 280, 324, 420, 42161, 42220, 43114, 80001, 421611, 421613, 1313161554, 1313161555
```

Please refer to [wagmi providers](https://wagmi.sh/react/providers/configuring-chains) documentation to see how to configure alternative providers, combine or prioritize them.

Below is a simplified example of how to combine WalletConnect RPC and Infura one:
</file>

<file path="docs/web3modal/v2/_partials/customisation/customDefaultChain.mdx">
By default AppKit will connect to the chain that was set by user's wallet.
If you want user to be connected to a specific chain by default, you can set it via `defaultChain` option:
</file>

<file path="docs/web3modal/v2/_partials/customisation/customExplorerWallets.mdx">
You can manage wallets fetched from explorer via `explorerRecommendedWalletIds` and `explorerExcludedWalletIds` options to prioritize, include or exclude them.
To fully disable explorer wallets, use `enableExplorer` options.

You can get all wallet id's from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet) (click copy icon on chosen wallets).

Below is an example of how to prioritize MetaMask, Rainbow and TrustWallet in that specific order:
</file>

<file path="docs/web3modal/v2/_partials/customisation/customManualWallets.mdx">
If your WalletConnect enabled wallet is not present in [WalletConnect explorer](https://walletconnect.com/explorer) or is still pending approval,
you can add it manually via `mobileWallets` and `desktopWallets` options.
</file>

<file path="docs/web3modal/v2/_partials/customisation/customWagmiChains.mdx">
AppKit's chain configuration happens entirely via wagmi.
Please refer to [wagmi chains](https://wagmi.sh/react/chains) documentation to see which defaults are available and how to create your own chain.

Below is a simplified example that sets up mainnet, avalanche and arbitrum chains:
</file>

<file path="docs/web3modal/v2/_partials/customisation/customWagmiConnectors.mdx">
You can add any wagmi connector as you normally would in wagmi's [`createConfig`](https://wagmi.sh/react/config) function. However, for AppKit to work correctly [WalletConnectConnector](https://wagmi.sh/react/connectors/walletConnect) is required.
Below is a simplified example of how to use [CoinbaseWalletConnector](https://wagmi.sh/react/connectors/coinbaseWallet) together with defaults from `w3mConnectors` helper:
</file>

<file path="docs/web3modal/v2/_partials/customisation/customWagmiWalletsIntro.mdx">
AppKit includes wallets from 3 sources: [WalletConnect explorer](https://walletconnect.com/explorer), wagmi connectors and manually defined wallets.
Below are defaults for each source:

1. All WalletConnect explorer wallets that satisfy your options
2. When using `w3mConnectors` helper, modal includes [WalletConnectConnector](https://wagmi.sh/react/connectors/walletConnect) and [InjectedConnector](https://wagmi.sh/react/connectors/injected)
3. No manual wallets are defined by default

Wallets are ordered with following priority: wagmi connectors, manual wallets, explorer wallets.
</file>

<file path="docs/web3modal/v2/_partials/customisation/customWalletImages.mdx">
If your wallet's logo is not supported by AppKit or you want to override default one, you can use `walletImages` option.
</file>

<file path="docs/web3modal/v2/_partials/options/chainImages.mdx">
Array of chain id's and their logo mappings. This will override default logos. You can find detailed chain data at [chainlist.org](https://chainlist.org) Defaults to `undefined`.

```ts
chainImages: {
  1: "/images/ethereum.webp",
  137: "/images/polygon.webp",
};
```
</file>

<file path="docs/web3modal/v2/_partials/options/chains.mdx">
Array of [CAIP-2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md) compliant chains modal should work with.

```ts
chains: [
  'eip155:1',
  'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
  'cosmos:cosmoshub-4',
  'polkadot:91b171bb158e2d3848fa23a9f1c25182'
]
```
</file>

<file path="docs/web3modal/v2/_partials/options/defaultChain.mdx">
Before the user establishes a connection, the default wagmi chain can be set prompting user to switch in their wallet if they were on a different one. Defaults to `undefined`.

```ts
defaultChain: polygon
```
</file>

<file path="docs/web3modal/v2/_partials/options/desktopWallets.mdx">
You can define an array of custom desktop or web based wallets. Note: you will also need to add appropriate wallet images in `walletImages`. Native link represents deeplinking URL like `ledgerlive://` and Universal link represents webpage link that can redirect to the app or fallback page. Defaults to `undefined`.

```ts
desktopWallets: [
  {
    id: string,
    name: string,
    links: {
      native: string
      universal: string,
    },
  },
];
```
</file>

<file path="docs/web3modal/v2/_partials/options/enableAccountView.mdx">
Option to enable or disable the modal's account view. The default setting is set to `true`.

```ts
enableAccountView: false
```
</file>

<file path="docs/web3modal/v2/_partials/options/enableAuthMode.mdx">
Option to enable auth only mode for modal, will adjust which wallets are fetched from explorer. Defaults to `false`.

```ts
enableAuthMode: true
```
</file>

<file path="docs/web3modal/v2/_partials/options/enableExplorer.mdx">
Option to enable or disable wallet fetching from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet). Defaults to `true`.

```ts
enableExplorer: false
```
</file>

<file path="docs/web3modal/v2/_partials/options/enableNetworkView.mdx">
If more than 1 chain was provided in modal or wagmi configuration, users will be show network selection view before selecting a wallet. This option can enable or disable this behavior. Defaults to `false`.

```ts
enableNetworkView: true
```
</file>

<file path="docs/web3modal/v2/_partials/options/explorerExcludedWalletIds.mdx">
Allows to exclude wallets that are fetched from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. If you want to exclude all wallets, you can set this option to `ALL`, however if `explorerRecommendedWalletIds` were defined, they will still be fetched. Defaults to `undefined`.

```ts
explorerExcludedWalletIds: [
  '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
]
// -- or -- //
explorerExcludedWalletIds: 'ALL'
```
</file>

<file path="docs/web3modal/v2/_partials/options/explorerRecommendedWalletIds.mdx">
Allows to override default recommended wallets that are fetched from [WalletConnect explorer](https://walletconnect.com/explorer?type=wallet). You can define an array of wallet ids you'd like to prioritise (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. If you want to completely disable recommended wallets, you can set this option to `NONE`. Defaults to `undefined`.

```ts
explorerRecommendedWalletIds: [
  '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
]
// -- or -- //
explorerRecommendedWalletIds: 'NONE'
```
</file>

<file path="docs/web3modal/v2/_partials/options/metadata.mdx">
Information about your dapp that will be displayed to users during request approvals within wallets.

```ts
metadata: {
  name: string;
  description: string;
  url: string;
  icons: string[];
};
```
</file>

<file path="docs/web3modal/v2/_partials/options/mobileWallets.mdx">
You can define an array of custom mobile wallets. Note: you will also need to add appropriate wallet images in `walletImages`. Native link represents deeplinking URL like `rainbow://` and Universal link represent webpage link that can redirect to the app or fallback page. Defaults to `undefined`.

```ts
mobileWallets: [
  {
    id: string,
    name: string,
    links: {
      native: string
      universal: string,
    },
  },
];
```
</file>

<file path="docs/web3modal/v2/_partials/options/privacyPolicyUrl.mdx">
String URL to your privacy policy page, if specified will append special "legal info" footer to the modal. Defaults to `undefined`.

```ts
privacyPolicyUrl: 'https://example.com/privacy-policy'
```
</file>

<file path="docs/web3modal/v2/_partials/options/projectId.mdx">
Your project's unique identifier that can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com). Enables following functionalities within AppKit: wallet and chain logos, optional WalletConnect RPC, support for all wallets from [WalletConnect explorer](https://walletconnect.com/explorer) and WalletConnect v2 support. Defaults to `undefined`.

```ts
projectId: string
```
</file>

<file path="docs/web3modal/v2/_partials/options/termsOfServiceUrl.mdx">
String URL to your terms of service page, if specified will append special "legal info" footer to the modal. Defaults to `undefined`.

```ts
termsOfServiceUrl: 'https://example.com/terms-and-conditions'
```
</file>

<file path="docs/web3modal/v2/_partials/options/themeMode.mdx">
Puts AppKit into dark or light mode. Defaults to user's system preference.

```ts
themeMode: 'dark' | 'light'
```
</file>

<file path="docs/web3modal/v2/_partials/options/themeVariables.mdx">
Allows to override AppKit's css styles. See theming section for all available options.

```ts
themeVariables: {
  "--w3m-font-family": "Roboto, sans-serif",
  "--w3m-accent-color": "#F5841F",
  // ...
};
```
</file>

<file path="docs/web3modal/v2/_partials/options/tokenContracts.mdx">
Allows to override default token(s) address for each chain to show custom balances in account view. Defaults to `undefined`.

```ts
tokenContracts: {
  1: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
  137: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
}
```
</file>

<file path="docs/web3modal/v2/_partials/options/tokenImages.mdx">
Array of token symbols and their logo mappings. Defaults to `undefined`.

```ts
tokenImages: {
  ETH: "/images/eth.webp",
  AVAX: "/images/avax.webp",
};
```
</file>

<file path="docs/web3modal/v2/_partials/options/walletImages.mdx">
Array of wallet id's and their logo mappings. This will override default logos. Id's in this case can be: [WalletConnect explorer](https://walletconnect.com/explorer) id's, wallet id's you provided in `mobileWallets` or `desktopWallets` and [wagmi](https://wagmi.sh) connector id's. Defaults to `undefined`.

```ts
walletImages: {
  rainbow: "/images/rainbow.webp",
  metaMask: "/images/metamask.webp",
};
```
</file>

<file path="docs/web3modal/v2/_partials/obtainProjectId.mdx">
Every project using WalletConnect SDKs needs to obtain `projectId` from [cloud.walletconnect.com](https://cloud.walletconnect.com/),
this is absolutely free and only takes a few minutes.
</file>

<file path="docs/web3modal/v2/_partials/themeMode.mdx">
By default `themeMode` option will be set to user system settings i.e. 'light' or 'dark',
however you can easily override it to match design of your dapp.
</file>

<file path="docs/web3modal/v2/_partials/themeVariables.mdx">
AppKit's theming is done via css variables. You can override any of them to match your dapp's design via `themeVariables` option.
</file>

<file path="docs/web3modal/v2/_partials/themeVariablesTable.mdx">
import Table from '../../../components/Table'

#### General style variables

<Table
  headers={['Variable', 'Description', 'Example']}
  data={[
    {
      variable: { code: '--w3m-font-family' },
      description: 'Base font family',
      example: { code: 'Roboto, sans-serif' }
    },
    {
      variable: { code: '--w3m-font-feature-settings' },
      description: 'Base font features settings',
      example: { code: 'tnum' }
    },
    {
      variable: { code: '--w3m-overlay-background-color' },
      description: 'Modal overlay background color',
      example: { code: 'rgba(0, 0, 0, 0.3)' }
    },
    {
      variable: { code: '--w3m-overlay-backdrop-filter' },
      description: 'Modal overlay backdrop filter',
      example: { code: 'blur(5px)' }
    },
    {
      variable: { code: '--w3m-z-index' },
      description: 'Z-index position',
      example: { code: '10' }
    },
    {
      variable: { code: '--w3m-accent-color' },
      description: 'Color used for buttons, icons, labels, etc.',
      example: { code: '#FFFFFF' }
    },
    {
      variable: { code: '--w3m-accent-fill-color' },
      description: 'Color used for text and icons inside elements with accent color background',
      example: { code: '#000000' }
    },
    {
      variable: { code: '--w3m-background-color' },
      description: 'Background color to be used instead of default animated gradient',
      example: { code: '#CECECE' }
    },
    {
      variable: { code: '--w3m-background-image-url' },
      description: 'Background image URL to be used instead of default animated gradient',
      example: { code: 'https://...' }
    },
    {
      variable: { code: '--w3m-logo-image-url' },
      description: 'Image URL to be used instead of WalletConnect logo',
      example: { code: 'https://...' }
    },
    {
      variable: { code: '--w3m-background-border-radius' },
      description: 'Border radius applied to the modal background',
      example: { code: '12px' }
    },
    {
      variable: { code: '--w3m-container-border-radius' },
      description: 'Border radius applied to main modal content area',
      example: { code: '24px' }
    },
    {
      variable: { code: '--w3m-wallet-icon-border-radius' },
      description: 'Border radius applied to wallet icons',
      example: { code: '2em' }
    },
    {
      variable: { code: '--w3m-wallet-icon-large-border-radius' },
      description: 'Border radius applied to large wallet icons',
      example: { code: '3em' }
    },
    {
      variable: { code: '--w3m-wallet-icon-small-border-radius ' },
      description: 'Border radius applied to small wallet icons',
      example: { code: '1em' }
    },
    {
      variable: { code: '--w3m-input-border-radius' },
      description: 'Border radius applied to text inputs',
      example: { code: '50%' }
    },
    {
      variable: { code: '--w3m-notification-border-radius' },
      description: 'Border radius applied to toast notification',
      example: { code: '2rem' }
    },
    {
      variable: { code: '--w3m-button-border-radius' },
      description: "Border radius applied to primary buttons like 'Connect' or 'Account'",
      example: { code: '8px' }
    },
    {
      variable: { code: '--w3m-secondary-button-border-radius' },
      description: 'Border radius applied to secondary buttons, ones inside modal views',
      example: { code: '8px' }
    },
    {
      variable: { code: '--w3m-icon-button-border-radius' },
      description: "Border radius applied to icon only buttons like 'Copy' or 'Disconnect'",
      example: { code: '50%' }
    },
    {
      variable: { code: '--w3m-button-hover-highlight-border-radius' },
      description: 'Border radius applied to hover highlight on wallet or chain buttons',
      example: { code: '2rem' }
    }
  ]}
/>

#### Text style variables

Granular text style variables for when `--w3m-font-family` is not enough.

<Table
  headers={['Variable', 'Description', 'Example']}
  data={[
    {
      variable: { code: '--w3m-text-big-bold-size' },
      description: 'Font size of big-bold text variant (modal and page titles)',
      example: { code: '2rem' }
    },
    {
      variable: { code: '--w3m-text-big-bold-weight' },
      description: 'Font weight of big-bold text variant (modal and page titles)',
      example: { code: 'bold' }
    },
    {
      variable: { code: '--w3m-text-big-bold-line-height' },
      description: 'Line height of big-bold text variant (modal and page titles)',
      example: { code: '14px' }
    },
    {
      variable: { code: '--w3m-text-big-bold-letter-spacing' },
      description: 'Letter spacing of big-bold text variant (modal and page titles)',
      example: { code: '1px' }
    },
    {
      variable: { code: '--w3m-text-big-bold-text-transform' },
      description: 'Text transform of big-bold text variant (modal and page titles)',
      example: { code: 'uppercase' }
    },
    {
      variable: { code: '--w3m-text-big-bold-font-family' },
      description: 'Font family of big-bold text variant (modal and page titles)',
      example: { code: 'Helvetica, sans-serif' }
    },
    {
      variable: { code: '--w3m-text-medium-regular-size' },
      description: 'Font size of medium-regular text variant (button and data labels)',
      example: { code: '1rem' }
    },
    {
      variable: { code: '--w3m-text-medium-regular-weight' },
      description: 'Font weight of medium-regular text variant (button and data labels)',
      example: { code: 'normal' }
    },
    {
      variable: { code: '--w3m-text-medium-regular-line-height' },
      description: 'Line height of medium-regular text variant (button and data labels)',
      example: { code: '14px' }
    },
    {
      variable: { code: '--w3m-text-medium-regular-letter-spacing' },
      description: 'Letter spacing of medium-regular text variant (button and data labels)',
      example: { code: '1px' }
    },
    {
      variable: { code: '--w3m-text-medium-regular-text-transform' },
      description: 'Text transform of medium-regular text variant (button and data labels)',
      example: { code: 'capitalize' }
    },
    {
      variable: { code: '--w3m-text-medium-regular-font-family' },
      description: 'Font family of medium-regular text variant (button and data labels)',
      example: { code: 'Arial, sans-serif' }
    },
    {
      variable: { code: '--w3m-text-small-regular-size' },
      description:
        'Font size of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: '0.75rem' }
    },
    {
      variable: { code: '--w3m-text-small-regular-weight' },
      description:
        'Font weight of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: 'normal' }
    },
    {
      variable: { code: '--w3m-text-small-regular-line-height' },
      description:
        'Line height of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: '14px' }
    },
    {
      variable: { code: '--w3m-text-small-regular-letter-spacing' },
      description:
        'Letter spacing of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: '1px' }
    },
    {
      variable: { code: '--w3m-text-small-regular-text-transform' },
      description:
        'Text transform of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: 'capitalize' }
    },
    {
      variable: { code: '--w3m-text-small-regular-font-family' },
      description:
        'Font family of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: 'Helvetica, sans-serif' }
    },
    {
      variable: { code: '--w3m-text-small-thin-size' },
      description: 'Font size of small-thin text variant (input placeholder and help text)',
      example: { code: '0.65rem' }
    },
    {
      variable: { code: '--w3m-text-small-thin-weight' },
      description: 'Font weight of small-thin text variant (input placeholder and help text)',
      example: { code: 'lighter' }
    },
    {
      variable: { code: '--w3m-text-small-thin-line-height' },
      description: 'Line height of small-thin text variant (input placeholder and help text)',
      example: { code: '0.8rem' }
    },
    {
      variable: { code: '--w3m-text-small-thin-letter-spacing' },
      description: 'Letter spacing of small-thin text variant (input placeholder and help text)',
      example: { code: '0.01em' }
    },
    {
      variable: { code: '--w3m-text-small-thin-text-transform' },
      description: 'Text transform of small-thin text variant (input placeholder and help text)',
      example: { code: 'none' }
    },
    {
      variable: { code: '--w3m-text-small-thin-font-family' },
      description: 'Font family of small-thin text variant (input placeholder and help text)',
      example: { code: 'Arial, sans-serif' }
    },
    {
      variable: { code: '--w3m-text-xsmall-bold-size' },
      description: 'Font size of xsmall-bold text variant (sub-labels)',
      example: { code: '0.5rem' }
    },
    {
      variable: { code: '--w3m-text-xsmall-bold-weight' },
      description: 'Font weight of xsmall-bold text variant (sub-labels)',
      example: { code: 'bold' }
    },
    {
      variable: { code: '--w3m-text-xsmall-bold-line-height' },
      description: 'Line height of xsmall-bold text variant (sub-labels)',
      example: { code: '10px' }
    },
    {
      variable: { code: '--w3m-text-xsmall-bold-letter-spacing' },
      description: 'Letter spacing of xsmall-bold text variant (sub-labels)',
      example: { code: '-0.03em' }
    },
    {
      variable: { code: '--w3m-text-xsmall-bold-text-transform' },
      description: 'Text transform of xsmall-bold text variant (sub-labels)',
      example: { code: 'uppercase' }
    },
    {
      variable: { code: '--w3m-text-xsmall-bold-font-family' },
      description: 'Font family of xsmall-bold text variant (sub-labels)',
      example: { code: 'Arial, sans-serif' }
    },
    {
      variable: { code: '--w3m-text-xsmall-regular-size' },
      description: 'Font size of xsmall-regular text variant (wallet and network button labels)',
      example: { code: '0.5rem' }
    },
    {
      variable: { code: '--w3m-text-xsmall-regular-weight' },
      description: 'Font weight of xsmall-regular text variant (wallet and network button labels)',
      example: { code: 'normal' }
    },
    {
      variable: { code: '--w3m-text-xsmall-regular-line-height' },
      description: 'Line height of xsmall-regular text variant (wallet and network button labels)',
      example: { code: '10px' }
    },
    {
      variable: { code: '--w3m-text-xsmall-regular-letter-spacing' },
      description:
        'Letter spacing of xsmall-regular text variant (wallet and network button labels)',
      example: { code: '0.1em' }
    },
    {
      variable: { code: '--w3m-text-xsmall-regular-text-transform' },
      description:
        'Text transform of xsmall-regular text variant (wallet and network button labels)',
      example: { code: 'none' }
    },
    {
      variable: { code: '--w3m-text-xsmall-regular-font-family' },
      description: 'Font family of xsmall-regular text variant (wallet and network button labels)',
      example: { code: 'Helvetica, sans-serif' }
    }
  ]}
/>
</file>

<file path="docs/web3modal/v2/_partials/wcModalThemeVariablesTable.mdx">
import Table from '../../../components/Table'

#### General style variables

<Table
  headers={['Variable', 'Description', 'Example']}
  data={[
    {
      variable: { code: '--wcm-font-family' },
      description: 'Base font family',
      example: { code: 'Roboto, sans-serif' }
    },
    {
      variable: { code: '--wcm-font-feature-settings' },
      description: 'Base font features settings',
      example: { code: 'tnum' }
    },
    {
      variable: { code: '--wcm-overlay-background-color' },
      description: 'Modal overlay background color',
      example: { code: 'rgba(0, 0, 0, 0.3)' }
    },
    {
      variable: { code: '--wcm-overlay-backdrop-filter' },
      description: 'Modal overlay backdrop filter',
      example: { code: 'blur(5px)' }
    },
    {
      variable: { code: '--wcm-z-index' },
      description: 'Z-index position',
      example: { code: '10' }
    },
    {
      variable: { code: '--wcm-accent-color' },
      description: 'Color used for buttons, icons, labels, etc.',
      example: { code: '#FFFFFF' }
    },
    {
      variable: { code: '--wcm-accent-fill-color' },
      description: 'Color used for text and icons inside elements with accent color background',
      example: { code: '#000000' }
    },
    {
      variable: { code: '--wcm-background-color' },
      description: 'Background color to be used instead of default animated gradient',
      example: { code: '#CECECE' }
    },
    {
      variable: { code: '--wcm-background-border-radius' },
      description: 'Border radius applied to the modal background',
      example: { code: '12px' }
    },
    {
      variable: { code: '--wcm-container-border-radius' },
      description: 'Border radius applied to main modal content area',
      example: { code: '24px' }
    },
    {
      variable: { code: '--wcm-wallet-icon-border-radius' },
      description: 'Border radius applied to wallet icons',
      example: { code: '2em' }
    },
    {
      variable: { code: '--wcm-wallet-icon-large-border-radius' },
      description: 'Border radius applied to large wallet icons',
      example: { code: '3em' }
    },
    {
      variable: { code: '--wcm-wallet-icon-small-border-radius ' },
      description: 'Border radius applied to small wallet icons',
      example: { code: '1em' }
    },
    {
      variable: { code: '--wcm-input-border-radius' },
      description: 'Border radius applied to text inputs',
      example: { code: '50%' }
    },
    {
      variable: { code: '--wcm-notification-border-radius' },
      description: 'Border radius applied to toast notification',
      example: { code: '2rem' }
    },
    {
      variable: { code: '--wcm-button-border-radius' },
      description: "Border radius applied to primary buttons like 'Connect' or 'Account'",
      example: { code: '8px' }
    },
    {
      variable: { code: '--wcm-secondary-button-border-radius' },
      description: 'Border radius applied to secondary buttons, ones inside modal views',
      example: { code: '8px' }
    },
    {
      variable: { code: '--wcm-icon-button-border-radius' },
      description: "Border radius applied to icon only buttons like 'Copy' or 'Disconnect'",
      example: { code: '50%' }
    },
    {
      variable: { code: '--wcm-button-hover-highlight-border-radius' },
      description: 'Border radius applied to hover highlight on wallet or chain buttons',
      example: { code: '2rem' }
    }
  ]}
/>

#### Text style variables

Granular text style variables for when `--wcm-font-family` is not enough.

<Table
  headers={['Variable', 'Description', 'Example']}
  data={[
    {
      variable: { code: '--wcm-text-big-bold-size' },
      description: 'Font size of big-bold text variant (modal and page titles)',
      example: { code: '2rem' }
    },
    {
      variable: { code: '--wcm-text-big-bold-weight' },
      description: 'Font weight of big-bold text variant (modal and page titles)',
      example: { code: 'bold' }
    },
    {
      variable: { code: '--wcm-text-big-bold-line-height' },
      description: 'Line height of big-bold text variant (modal and page titles)',
      example: { code: '14px' }
    },
    {
      variable: { code: '--wcm-text-big-bold-letter-spacing' },
      description: 'Letter spacing of big-bold text variant (modal and page titles)',
      example: { code: '1px' }
    },
    {
      variable: { code: '--wcm-text-big-bold-text-transform' },
      description: 'Text transform of big-bold text variant (modal and page titles)',
      example: { code: 'uppercase' }
    },
    {
      variable: { code: '--wcm-text-big-bold-font-family' },
      description: 'Font family of big-bold text variant (modal and page titles)',
      example: { code: 'Helvetica, sans-serif' }
    },
    {
      variable: { code: '--wcm-text-medium-regular-size' },
      description: 'Font size of medium-regular text variant (button and data labels)',
      example: { code: '1rem' }
    },
    {
      variable: { code: '--wcm-text-medium-regular-weight' },
      description: 'Font weight of medium-regular text variant (button and data labels)',
      example: { code: 'normal' }
    },
    {
      variable: { code: '--wcm-text-medium-regular-line-height' },
      description: 'Line height of medium-regular text variant (button and data labels)',
      example: { code: '14px' }
    },
    {
      variable: { code: '--wcm-text-medium-regular-letter-spacing' },
      description: 'Letter spacing of medium-regular text variant (button and data labels)',
      example: { code: '1px' }
    },
    {
      variable: { code: '--wcm-text-medium-regular-text-transform' },
      description: 'Text transform of medium-regular text variant (button and data labels)',
      example: { code: 'capitalize' }
    },
    {
      variable: { code: '--wcm-text-medium-regular-font-family' },
      description: 'Font family of medium-regular text variant (button and data labels)',
      example: { code: 'Arial, sans-serif' }
    },
    {
      variable: { code: '--wcm-text-small-regular-size' },
      description:
        'Font size of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: '0.75rem' }
    },
    {
      variable: { code: '--wcm-text-small-regular-weight' },
      description:
        'Font weight of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: 'normal' }
    },
    {
      variable: { code: '--wcm-text-small-regular-line-height' },
      description:
        'Line height of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: '14px' }
    },
    {
      variable: { code: '--wcm-text-small-regular-letter-spacing' },
      description:
        'Letter spacing of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: '1px' }
    },
    {
      variable: { code: '--wcm-text-small-regular-text-transform' },
      description:
        'Text transform of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: 'capitalize' }
    },
    {
      variable: { code: '--wcm-text-small-regular-font-family' },
      description:
        'Font family of small-regular text variant (secondary buttons, toast notification and labels)',
      example: { code: 'Helvetica, sans-serif' }
    },
    {
      variable: { code: '--wcm-text-small-thin-size' },
      description: 'Font size of small-thin text variant (input placeholder and help text)',
      example: { code: '0.65rem' }
    },
    {
      variable: { code: '--wcm-text-small-thin-weight' },
      description: 'Font weight of small-thin text variant (input placeholder and help text)',
      example: { code: 'lighter' }
    },
    {
      variable: { code: '--wcm-text-small-thin-line-height' },
      description: 'Line height of small-thin text variant (input placeholder and help text)',
      example: { code: '0.8rem' }
    },
    {
      variable: { code: '--wcm-text-small-thin-letter-spacing' },
      description: 'Letter spacing of small-thin text variant (input placeholder and help text)',
      example: { code: '0.01em' }
    },
    {
      variable: { code: '--wcm-text-small-thin-text-transform' },
      description: 'Text transform of small-thin text variant (input placeholder and help text)',
      example: { code: 'none' }
    },
    {
      variable: { code: '--wcm-text-small-thin-font-family' },
      description: 'Font family of small-thin text variant (input placeholder and help text)',
      example: { code: 'Arial, sans-serif' }
    },
    {
      variable: { code: '--wcm-text-xsmall-bold-size' },
      description: 'Font size of xsmall-bold text variant (sub-labels)',
      example: { code: '0.5rem' }
    },
    {
      variable: { code: '--wcm-text-xsmall-bold-weight' },
      description: 'Font weight of xsmall-bold text variant (sub-labels)',
      example: { code: 'bold' }
    },
    {
      variable: { code: '--wcm-text-xsmall-bold-line-height' },
      description: 'Line height of xsmall-bold text variant (sub-labels)',
      example: { code: '10px' }
    },
    {
      variable: { code: '--wcm-text-xsmall-bold-letter-spacing' },
      description: 'Letter spacing of xsmall-bold text variant (sub-labels)',
      example: { code: '-0.03em' }
    },
    {
      variable: { code: '--wcm-text-xsmall-bold-text-transform' },
      description: 'Text transform of xsmall-bold text variant (sub-labels)',
      example: { code: 'uppercase' }
    },
    {
      variable: { code: '--wcm-text-xsmall-bold-font-family' },
      description: 'Font family of xsmall-bold text variant (sub-labels)',
      example: { code: 'Arial, sans-serif' }
    },
    {
      variable: { code: '--wcm-text-xsmall-regular-size' },
      description: 'Font size of xsmall-regular text variant (wallet and network button labels)',
      example: { code: '0.5rem' }
    },
    {
      variable: { code: '--wcm-text-xsmall-regular-weight' },
      description: 'Font weight of xsmall-regular text variant (wallet and network button labels)',
      example: { code: 'normal' }
    },
    {
      variable: { code: '--wcm-text-xsmall-regular-line-height' },
      description: 'Line height of xsmall-regular text variant (wallet and network button labels)',
      example: { code: '10px' }
    },
    {
      variable: { code: '--wcm-text-xsmall-regular-letter-spacing' },
      description:
        'Letter spacing of xsmall-regular text variant (wallet and network button labels)',
      example: { code: '0.1em' }
    },
    {
      variable: { code: '--wcm-text-xsmall-regular-text-transform' },
      description:
        'Text transform of xsmall-regular text variant (wallet and network button labels)',
      example: { code: 'none' }
    },
    {
      variable: { code: '--wcm-text-xsmall-regular-font-family' },
      description: 'Font family of xsmall-regular text variant (wallet and network button labels)',
      example: { code: 'Helvetica, sans-serif' }
    }
  ]}
/>
</file>

<file path="docs/readme.mdx">
---
title: Welcome
---

import WhatsNewBanner from './components/WhatsNewBanner'
import Banner from './components/Home/Banner'
import Wrapper from './components/Home/Wrapper'
import twitterLogo from '../static/assets/home/logo-white.png'
import discordLogo from '../static/assets/home/discord.png'
import telegramLogo from '../static/assets/home/telegram.png'
import web3modalLogo from '../static/assets/home/web3modalLogo.png'
import web3walletLogo from '../static/assets/home/web3walletLogo.png'
import web3inboxLogo from '../static/assets/home/web3inboxLogo.png'
import bookLogo from '../static/assets/home/bookLogo.png'
import githubLogo from '../static/assets/home/githubLogo.png'
import universalProviderLogo from '../static/assets/home/universalProviderLogo.png'
import ethereumProviderLogo from '../static/assets/home/ethereumProviderLogo.png'
import wcmLogo from '../static/assets/home/wcmLogo.png'
import w3iLogo from '../static/assets/home/web3inboxLogo_high.png'
import Link from '@docusaurus/Link'

<Banner />

## WalletConnect SDKs

Effortlessly integrate our suite of SDKs

<Wrapper
  type="large"
  items={[
    {
      name: 'AppKit',
      icon: web3modalLogo,
      href: '/appkit/overview',
      description: 'The all-in-one stack to build apps for the new internet.'
    },
    {
      name: 'WalletKit',
      icon: web3walletLogo,
      href: '/walletkit/overview',
      description: 'The ultimate toolkit for building and connecting wallets.'
    }
  ]}
/>

<hr className="home__divider" />

## Advanced

Utility tools for advanced usage with WalletConnect

<Wrapper
  type="large"
  items={[
    {
      name: 'Ethereum Provider',
      icon: ethereumProviderLogo,
      href: '/advanced/providers/ethereum',
      description: 'EVM Compatible Provider for WalletConnect.'
    },
    {
      name: 'Universal Provider',
      icon: universalProviderLogo,
      href: '/advanced/providers/universal',
      description: 'Chain Agnostic Provider for WalletConnect.'
    }
  ]}
/>

<hr className="home__divider" />

## Join our community

Share your experience, contribute, or ask questions

<Wrapper
  type="small"
  items={[
    {
      name: 'X',
      icon: twitterLogo,
      href: 'https://twitter.com/walletconnect',
      isWhite: true
    },
    {
      name: 'Discord',
      icon: discordLogo,
      href: 'https://discord.com/invite/kdTQHQ6AFQ',
      isWhite: true
    },
    {
      name: 'Telegram',
      icon: telegramLogo,
      href: 'https://t.me/walletconnect',
      isWhite: true
    },
    {
      name: 'GitHub',
      icon: githubLogo,
      href: 'https://github.com/orgs/WalletConnect/discussions/',
      isWhite: true
    }
  ]}
/>

<hr className="home__divider" />

## How to contribute

<div className="cloud__wrapper" style={{ padding: '1.67rem' }}>
  Every page footer has an <strong>Edit this page</strong> link.
  <br /> Change the Markdown, open a Pull Request and we‚Äôll merge it!
  <Link to="https://github.com/WalletConnect/walletconnect-docs/" target="_blank">
    Docs Repo
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      strokeWidth={1.5}
      stroke="currentColor"
      height={20}
      width={20}
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        d="M17.25 8.25L21 12m0 0l-3.75 3.75M21 12H3"
      />
    </svg>
  </Link>
</div>
</file>

<file path="src/css/banner.module.css">
.container {
  padding-left: 2rem !important;
}

.banner__container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background:
    linear-gradient(to right, var(--ifm-background-color), var(--ifm-background-color)) padding-box,
    linear-gradient(to right, transparent, transparent, var(--ifm-color-gray-600)) border-box;
  border-radius: 0 1.5rem 1.5rem 0;
  border: 1px solid transparent;
  overflow: hidden;
  min-height: 15rem;
  max-height: 25rem;
  width: 100%;
  margin-top: 1rem;
  position: relative;
  isolation: isolate;
}

.banner__text {
  position: relative;
  z-index: 2;
}

.banner__text h2,
.banner__text p,
.banner__text a {
  margin: 0 !important;
}

.banner__text p {
  margin-top: 0.5rem !important;
  max-width: 24rem;
}

.banner__text a {
  width: fit-content;
  white-space: pre;
  padding: 0.5rem 1.125rem;
  border-radius: 0.875rem;
  border: none;
  background: linear-gradient(
    180deg,
    var(--ifm-color-primary-lighter) 0%,
    var(--ifm-color-primary-dark) 100%
  );
  box-shadow: 0px 0px 8px -1px var(--ifm-color-primary-darker) inset;
  color: white !important;
  font-weight: 700;
  letter-spacing: 0.25px;
  display: flex;
  align-items: center;
  gap: 5rem;
  margin-top: 1.25rem !important;
  transition: background 0.2s ease-in-out;
}

.banner__text a:hover {
  background: linear-gradient(
    180deg,
    var(--ifm-color-primary-light) 0%,
    var(--ifm-color-primary-darker) 100%
  );
}

.banner__text a > svg {
  width: 1.25rem;
  height: 1.25rem;
  transition: transform 0.2s ease-in-out;
}

.banner__text a:hover > svg {
  transform: translateX(0.25rem);
}

.banner__text h2 {
  font-size: 2.5rem;
}

.banner__backdrop {
  position: absolute;
  inset: 0;
  z-index: 1;
  background: linear-gradient(
    90deg,
    var(--ifm-background-color) 0%,
    var(--ifm-background-color) 33%,
    transparent 100%
  );
}

.banner__image {
  border: none;
  border-radius: 0;
  height: 100%;
  position: absolute;
  right: 0;
  top: 0;
  z-index: 0;
  object-fit: cover;
}

@media screen and (max-width: 996px) {
  .banner__container {
    height: fit-content;
  }
  .container {
    padding-left: 1rem !important;
  }
  .banner__text p {
    max-width: fit-content;
  }
}

@media screen and (max-width: 660px) {
  .banner__image {
    display: none;
  }
  .banner__container {
    height: fit-content;
    border-radius: 0;
    border: none !important;
  }
  .banner__backdrop {
    display: none;
  }
  .banner__text a {
    margin-left: 1rem;
    margin-right: 1rem;
    margin-bottom: 1rem;
    width: calc(100% - 1rem);
  }
  .banner__text a > svg {
    margin-left: auto;
  }
}
</file>

<file path="src/css/custom.css">
@import url(fonts.css);

:root {
  /*Code block highlight*/
  --ifm-color-primary: #1c8aff;
  --ifm-link-hover-color: #006eff;
  --ifm-heading-font-family: 'ABC Diatype Bold', sans-serif;
  --ifm-heading-font-weight: bold;
  --ifm-font-family-base: 'ABC Diatype', sans-serif;
  --ifm-heading-color: #1d2d35;
  --ifm-color-gray-800: hsla(0, 0%, 100%, 0.1);
  --ifm-nav-bg-color: rgba(255, 255, 255, 0.4);
  --ifm-font-color-base: #29404b;
  --ifm-border-color: hsla(210, 3%, 54%, 0.5);
  --ifm-article-text: #000;
  --ifm-footer-title-color: #1d2d35;
  --ifm-table-alternate-bg-color: rgba(255, 255, 255, 0.8);
  --ifm-table-bg-color: rgba(235, 237, 243, 0.8);
  --ifm-box-bg-color: rgba(223, 227, 236, 0.4);
  --ifm-box-shadow-color: rgb(20, 20, 20);
  --ifm-pagination-bg-color: rgba(0, 0, 0, 0.02);
  --ifm-pagination-border-color: rgba(0, 0, 0, 0.1);
  --ifm-theme-code-border-color: rgba(0, 0, 0, 0.15);
  --ifm-close-color: white;
  --ifm-list-before-color: rgba(0, 0, 0, 0.4);
  --ifm-navbar-show-bg-color: rgba(235, 235, 235, 1);
  --ifm-background-color: #fff;
  --ifm-platform-tabs-color-active-border: rgb(28, 138, 255, 0.5);
  --ifm-platform-bg-color: rgb(28, 138, 255, 0.1);
  --ifm-cloud-button-bg-color: rgba(0, 55, 113, 0.1);
  --ifm-cloud-bg-primary: #0e0f11;
  --ifm-cloud-bg-secondary: var(--ifm-color-primary-darkest);
  --ifm-feedback-heading: var(--ifm-color-gray-900);
  --ifm-container-background-color: #fff;
}

:where(.MarkpromptSearchBoxTrigger) {
  border-radius: 1000rem !important;
}

.dropdown_placeholder {
  height: 120px;
}

.kill {
  margin: 10px;
  visibility: hidden;
}

@media (max-width: 996px) {
  .kill {
    display: none;
  }
}

.MarkpromptSearchBoxTriggerContent {
  margin: 0;
  transition: all var(--ifm-transition-fast) var(--ifm-transition-timing-default);
  align-items: center;
  border-radius: 40px;
  color: var(--docsearch-muted-color);
  cursor: pointer;
  display: flex;
  font-weight: 500;
  height: 30px;
  justify-content: space-between;
  padding: 0 8px;
  -webkit-user-select: none;
  user-select: none;
  background-color: var(--ifm-color-gray-800) !important;
  border: 1px solid var(--ifm-border-color) !important;
  box-shadow: none !important;
  width: fit-content;
  gap: 1rem;
}

.MarkpromptSearchBoxTriggerContent:hover {
  border-color: var(--ifm-color-gray-600) !important;
  color: var(--ifm-color-gray-200) !important;
}

.MarkpromptSearchBoxTriggerContent > kbd {
  background-color: var(--ifm-color-gray-900) !important;
  border: 1px solid var(--ifm-color-gray-700) !important;
}

.MarkpromptSearchBoxTriggerContent > kbd > svg {
  color: var(--ifm-color-gray-200) !important;
}

.MarkpromptSearchBoxTriggerText > svg {
  stroke: var(--markprompt-foreground);
  stroke-width: 2;
}

.MarkpromptSearchResults {
  padding-left: 0;
}

:where([aria-selected='true'] .MarkpromptSearchResultLink) {
  background-color: #6366f15a !important;
}

:where([aria-selected='true'] .MarkpromptSearchResultHeading) {
  color: var(--markprompt-primaryForeground);
}

.theme-code-block-highlighted-delete {
  display: block;
  border-left: 3px solid #ff000080;
  background-color: #ff000020;
  margin: 0 calc(-1 * var(--ifm-pre-padding));
  padding: 0 var(--ifm-pre-padding);
}

.theme-code-block-highlighted-add {
  display: block;
  border-left: 3px solid rgba(0, 255, 0, 0.502);
  background-color: rgba(0, 255, 0, 0.125);
  margin: 0 calc(-1 * var(--ifm-pre-padding));
  padding: 0 var(--ifm-pre-padding);
}

html[data-theme='dark'] {
  --ifm-navbar-show-bg-color: rgba(20, 20, 20, 1);
  --ifm-list-before-color: rgba(255, 255, 255, 0.4);
  --ifm-close-color: black;
  --ifm-theme-code-border-color: rgba(255, 255, 255, 0.1);
  --ifm-pagination-border-color: rgba(255, 255, 255, 0.07);
  --ifm-pagination-bg-color: rgba(255, 255, 255, 0.04);
  --ifm-box-bg-color: var(--ifm-color-gray-800);
  --ifm-box-shadow-color: var(--ifm-color-gray-800);
  --ifm-pre-background: var(--prism-background-color);
  --ifm-table-bg-color: var(--ifm-color-gray-900);
  --ifm-table-alternate-bg-color: rgba(255, 255, 255, 0.05);
  --ifm-footer-title-color: var(--ifm-color-white);
  --ifm-color-primary: #66b0ff;
  --ifm-link-hover-color: #3396ff;
  --ifm-article-text: #fffff;
  --ifm-nav-bg-color: rgba(20, 20, 20, 0.4);
  --ifm-background-color: #141414;
  --ifm-heading-color: #ffffff;
  --ifm-font-color-base: #c9cfcf;
  --ifm-border-color: hsla(0, 0%, 100%, 0.1);
  --ifm-cloud-bg-secondary: rgb(16, 36, 69);
  --ifm-feedback-heading: var(--ifm-color-gray-500);
  --ifm-container-background-color: #141414;
}

html[data-theme='light'] {
  --ifm-blockquote-color: var(--ifm-color-gray-900);
}

[data-theme='light'] img[src$='#dark-mode-only'],
[data-theme='dark'] img[src$='#light-mode-only'] {
  display: none;
}

[data-theme='light'] .alert--secondary {
  --ifm-alert-border-color: var(--ifm-color-secondary-darkest);
  --ifm-alert-background-color-highlight: rgba(210, 212, 215, 0.2);
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-feature-settings: 'case', 'ss02', 'ss04', 'ss06';
  font-family: 'ABC Diatype Bold', sans-serif;
  letter-spacing: -0.03em;
}

h1 {
  position: relative;
  padding-bottom: 20px;
}

h2 {
  margin-top: 50px !important;
  margin-bottom: 10px !important;
}

h1::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 1px;
  bottom: 0;
  left: 0;
  background-image: linear-gradient(45deg, var(--ifm-border-color), transparent);
}

/* Docusaurus */
.navbar {
  background-color: var(--ifm-nav-bg-color);
  border-bottom: 1px solid var(--ifm-border-color);
  backdrop-filter: blur(20px) saturate(180%);
}

.thin-scrollbar {
  scrollbar-width: none;
}

.thin-scrollbar::-webkit-scrollbar-track,
.thin-scrollbar::-webkit-scrollbar-thumb {
  display: none;
}

.navbar__inner {
  max-width: var(--ifm-container-width-xl);
  margin: 0 auto;
}

.navbar__items--right {
  min-width: calc(3 / 12 * 100%);
  justify-content: flex-start;
}

.navbar__items div:nth-child(3) {
  margin-left: 0.75rem;
}

.navbar__items .navbar__brand,
.navbar__items .navbar__item:nth-child(3) {
  display: none;
}

[data-theme='light'] .header-github-link:before {
  filter: invert(0.8);
}

@media (max-width: 1170px) {
  :root {
    --doc-sidebar-width: 225px !important;
  }
  .DocSearch-Button-Keys,
  .DocSearch-Button-Placeholder {
    display: none !important;
  }
}

@media (max-width: 996px) {
  .navbar__items .navbar__brand,
  .navbar__items .navbar__item:nth-child(3) {
    display: flex !important;
  }
}

.navbar__brand {
  font-weight: bold;
  color: var(--ifm-heading-color);
}

.navbar__brand span {
  text-transform: uppercase;
  font-family: 'Office Code Pro', monospace;
  font-weight: normal;
  color: var(--ifm-color-primary);
  margin-left: 5px;
}

.navbar--fixed-top {
  --normal-width: calc(100% - var(--doc-sidebar-width));
  position: sticky;
  margin-left: auto;
  width: var(--normal-width);
}

article nav[aria-label='Breadcrumbs'] {
  display: none;
}

.navbar__items > nav {
  margin-bottom: 0;
}

@media (max-width: 996px) {
  .navbar--fixed-top {
    width: 100vw;
  }
}

.navbar-sidebar--show {
  backdrop-filter: none;
  background-color: var(--ifm-navbar-show-bg-color);
}

.navbar__logo {
  display: flex;
  align-items: center;
}

.navbar__logo img {
  width: 30px;
  height: 18px;
}

.footer {
  background-color: var(--ifm-background-color);
  border-top: 1px solid var(--ifm-border-color);
  padding-top: 50px;
  padding-bottom: 50px;
}

.footer__bottom {
  margin-top: 50px;
  color: var(--ifm-color-gray-700);
}

.theme-doc-sidebar-container {
  border: none !important;
  position: sticky;
  background-color: var(--ifm-background-color);
  z-index: 200;
}

.theme-doc-sidebar-container > div > div {
  padding-top: 0;
}

.theme-doc-sidebar-container > div::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: 1px;
  height: 100%;
  background: linear-gradient(180deg, var(--ifm-border-color) 0, transparent 80%);
}

.hash-link {
  border: none;
  color: var(--ifm-color-primary);
}

.hash-link:hover {
  color: var(--ifm-link-hover-color);
}

.theme-doc-footer-edit-meta-row a {
  border-bottom: none;
  color: var(--ifm-color-primary);
}

.theme-doc-footer-edit-meta-row a:hover {
  color: var(--ifm-link-hover-color);
}

.pagination-nav__link {
  background-color: var(--ifm-pagination-bg-color);
  border-color: var(--ifm-pagination-border-color);
}

.theme-code-block {
  border: 1px solid var(--ifm-theme-code-border-color);
}

table {
  display: table;
  width: 100%;
}

table tr,
table th,
table td {
  border-color: var(--ifm-border-color);
}

table thead tr {
  border-bottom: none !important;
}

table thead,
table tr:nth-child(2n) {
  background-color: var(--ifm-table-alternate-bg-color) !important;
}

img[alt='create-push-url'] {
  width: 400px;
}

img[alt='web3modal-customisation'] {
  width: 700px;
}

.close {
  color: var(--ifm-close-color);
}

.header-github-link:hover {
  opacity: 0.6;
}

.header-github-link:before {
  content: '';
  width: 24px;
  height: 24px;
  display: flex;
  background: url("data:image/svg+xml,%3Csvg viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12'/%3E%3C/svg%3E")
    no-repeat;
}

.menu_outer_list {
  padding-top: 5px;
  position: relative;
}

.menu_outer_list:not(:nth-child(2))::before {
  content: '';
  display: block;
  position: absolute;
  left: 12px;
  top: 0;
  height: 1px;
  width: 100%;
  background: linear-gradient(90deg, var(--ifm-border-color) 0, transparent 100%);
}

.menu_outer_list--margin-top {
  margin-top: 21px;
}

.menu_outer_list > div a {
  text-transform: uppercase;
  font-size: 13px;
  color: var(--ifm-color-gray-600) !important;
  font-family: 'Office Code Pro', 'Courier New', Courier, monospace;
}

.menu_outer_list > div:hover {
  background-color: transparent;
}

.menu_outer_list > ul {
  padding-left: 0 !important;
}

.table-of-contents {
  border: none;
  position: relative;
}

.table-of-contents::before {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  width: 1px;
  height: 100%;
  background: linear-gradient(180deg, var(--ifm-border-color) 0, transparent 100%);
}

.theme-doc-footer {
  position: relative;
  padding-top: 40px;
}

.theme-doc-footer::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background-image: linear-gradient(90deg, var(--ifm-border-color) 0, transparent 100%);
}

.DocSearch-Button {
  background-color: var(--ifm-color-gray-800) !important;
  border: 1px solid var(--ifm-border-color) !important;
  box-shadow: none !important;
}

.DocSearch-Button:hover {
  border: 1px solid var(--ifm-color-gray-600) !important;
}

.theme-doc-sidebar-item-link-level-5 {
  position: relative;
}

.theme-doc-sidebar-item-link-level-5 .menu__link::before {
  content: '';
  position: absolute;
  left: 0;
  top: 10%;
  width: 1px;
  height: 80%;
  background-color: var(--ifm-color-gray-700);
}

.menu__link:hover,
.menu__link--active {
  background-color: transparent !important;
}

.menu__link--active::before {
  background-color: var(--ifm-color-primary) !important;
}

.menu__link::after {
  background-size: contain;
}

/* Custom Components */
.boxContainer {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100%, 1fr));
  grid-gap: 1rem;
  margin-bottom: 1rem;
}

.box {
  min-height: 33%;
  border: 1px solid var(--ifm-border-color);
  border-radius: 14px;
  background: linear-gradient(135deg, var(--ifm-box-bg-color) 0, transparent 100%);
  padding-inline: 1em;
  padding-top: 1em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.box h1 {
  transition: all 0.2s ease-in-out;
}

.box:hover {
  border-color: var(--ifm-color-primary);
}

.box:hover h1 {
  color: var(--ifm-color-primary);
}

article a {
  color: var(--ifm-article-text);
  border-bottom: 1px solid rgba(51, 150, 255, 0.5);
  transition: all 0.2s ease-in-out;
}

article a:hover {
  color: var(--ifm-article-text);
  text-decoration: none;
  border-color: rgba(51, 150, 255, 1);
}

article ul {
  padding-left: 15px;
  list-style: none;
}

article ul li:not([role='tab'])::before {
  content: '‚Üí';
  color: var(--ifm-list-before-color);
  font-weight: bold;
  font-size: 12px;
  display: inline-block;
  width: 1em;
  margin-left: -1em;
  margin-right: 0.5em;
}

article img {
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.navbar__item.dropdown {
  background-color: rgba(51, 150, 255, 0.2);
  border-radius: 40px;
  border: 1px solid rgba(51, 150, 255, 0.3);
  cursor: pointer;
  transition: all 0.2s ease;
}

.navbar__item.dropdown:hover {
  background-color: rgba(51, 150, 255, 0.3);
  border: 1px solid rgba(51, 150, 255, 0.5);
}

.navbar__item.dropdown a {
  font-size: 14px;
  color: var(--ifm-color-primary);
}

.navbar__item.dropdown a::after {
  border-width: 0.25em 0.25em 0;
  top: 0;
  margin-left: 0.5em;
}

@media only screen and (min-width: 660px) {
  .boxContainer {
    grid-template-columns: repeat(3, minmax(33%, 1fr));
  }
}

@media only screen and (min-width: 900px) {
  .boxContainer {
    grid-template-columns: repeat(2, minmax(50%, 1fr));
  }
}

@media only screen and (min-width: 1100px) {
  .boxContainer {
    grid-template-columns: repeat(3, minmax(33%, 1fr));
  }
}

.tableMatrix {
  border-radius: 14px;
  background: linear-gradient(135deg, var(--ifm-table-bg-color) 0, transparent 100%);
  box-shadow: inset 0 0 0 1px var(--ifm-box-shadow-color);
  overflow: hidden;
}

.chain-list {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 0.5rem;
}

.chain-list__header {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 0.75rem;
}

.chain-card-container {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 0.5rem;
  width: 100%;
}

.chain-list__search {
  width: 100%;
  padding: 0.75rem 1.25rem;
  border-radius: 0.5rem;
  border: 1.5px solid var(--ifm-border-color);
  background-color: var(--ifm-container-background-color);
  color: var(--ifm-article-text);
  font-size: 1rem;
  padding-left: 2.5rem;
}

.chains-list__checkbox__container {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.chains-list__checkbox__container .chains-list__checkbox {
  all: unset;
  cursor: pointer;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  border: 1px solid var(--ifm-border-color);
  background: var(--ifm-hover-overlay);
  padding: 0.25rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
}

.chains-list__checkbox__container .chains-list__checkbox:hover {
  background: var(--ifm-color-gray-800);
}

.card__small-container {
  border-radius: 0.5rem;
  border: 1.5px solid var(--ifm-border-color);
  padding: 0.75rem 1.25rem;
  min-height: 4rem;
  display: grid;
  place-items: center;
  background-color: var(--ifm-container-background-color);
  color: var(--ifm-article-text);
  position: relative;
  overflow: hidden;
  text-align: center;
  font-size: 1rem;
  cursor: pointer;
}

.card__small-container:hover {
  background-color: var(--ifm-hover-overlay);
}

.card__small-container span {
  padding: 0;
  margin: 0;
}

.chains-list__search__container {
  flex: 1;
  position: relative;
  width: 100%;
  align-self: center;
}

.chains-list__checkbox__wrapper {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.25rem;
}

.chains-list__search__container svg {
  width: 1rem;
  height: 1rem;
  position: absolute;
  top: 50%;
  left: 0.875rem;
  transform: translateY(-50%);
}

@media screen and (max-width: 768px) {
  .chain-card {
    width: calc(50% - 20px);
  }
  .chain-card-container {
    grid-template-columns: repeat(1, minmax(0, 1fr));
    width: 100%;
  }
  .card__small-container {
    width: 100%;
    text-align: left;
  }
}

.chain-card {
  display: flex;
  flex-direction: column;
  justify-content: center;
  text-align: center;
  align-items: center;
  background: linear-gradient(135deg, var(--ifm-color-gray-800) 0, transparent 100%);
  border-radius: 4px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin: 10px;
  width: calc(25% - 20px);
  font-size: 10px;
}

@media screen and (max-width: 768px) {
  .chain-card {
    width: calc(50% - 20px);
  }
}

.theme-admonition a {
  text-decoration: none;
}

.tabs {
  position: relative;
  isolation: isolate;
  --ifm-tabs-padding-vertical: 0.5rem;
  --ifm-tabs-padding-horizontal: 1.25rem;
}

.tabs:not(.platform-tabs) {
  padding-bottom: 1px;
}

.tabs:not(.platform-tabs):before {
  content: '';
  z-index: -1;
  position: absolute;
  bottom: 0;
  left: 0;
  height: 1px;
  width: 100%;
  background: linear-gradient(90deg, var(--ifm-border-color) 0%, transparent 100%);
}

.tabs__item {
  background-color: var(--ifm-hover-overlay);
  border: 2px solid transparent;
  border-radius: 0;
  font-size: var(--ifm-h5-font-size);
  font-weight: var(--ifm-heading-font-weight);
}

.tabs__item--active {
  background: var(--ifm-platform-bg-color);
  color: var(--ifm-color-primary);
  border-color: var(--ifm-platform-tabs-color-active-border);
}

.tabs__item:first-child,
.tabs__item--active:first-child {
  border-top-left-radius: 0.75rem;
  border-bottom-left-radius: 0rem;
}

.tabs__item:last-child,
.tabs__item--active:last-child {
  border-top-right-radius: 0.75rem;
  border-bottom-right-radius: 0rem;
}

/* Start - Platform Tabs */

.platform-tabs {
  --ifm-tabs-padding-vertical: 0.25rem;
  --ifm-tabs-padding-horizontal: 1rem;
  background-color: var(--ifm-hover-overlay);
  border-radius: 0.5rem 0.5rem 0 0;
  width: fit-content;
  margin-top: 1rem;
}

.platform-tabs--items h4 {
  font-size: 1.375rem;
}

.platform-tabs .tabs__item {
  display: grid;
  place-items: center;
  border: 2px solid transparent;
  border-radius: 0;
  font-size: var(--ifm-h5-font-size);
  font-weight: var(--ifm-heading-font-weight);
}

.platform-tabs .tabs__item--active {
  background: var(--ifm-platform-bg-color);
  color: var(--ifm-color-primary);
  border-color: var(--ifm-platform-tabs-color-active-border);
}

.platform-tabs .tabs__item--active:first-child {
  border-top-left-radius: 0.5rem;
}

.platform-tabs .tabs__item--active:last-child {
  border-top-right-radius: 0.5rem;
}

.platform-tabs--items {
  border: 1px solid var(--ifm-border-color);
  border-radius: 0 0.5rem 0.5rem 0.5rem;
  padding: 1.25rem 0.75rem;
}

/* End - Platform Tabs */

/* Start - Cloud Banner */

.cloud__wrapper {
  position: relative;
  background: linear-gradient(
    135deg,
    var(--ifm-cloud-bg-primary) 0%,
    var(--ifm-cloud-bg-secondary) 100%
  );
  border-radius: 1rem;
  padding: 2.5rem 1.67rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  isolation: isolate;
  overflow: hidden;
  margin: 1.5rem 0;
  gap: 1rem;
  border: 2px solid #31363c;
}

.cloud__wrapper h2,
.cloud__wrapper p {
  margin: 0 !important;
}

.cloud__wrapper .cloud__image {
  position: absolute;
  right: 0;
  top: 0;
  border: none;
  border-radius: 0;
  object-fit: cover;
  height: 100%;
  z-index: -1;
}

.cloud__wrapper .cloud__text-container {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  position: relative;
  z-index: 1;
}

.cloud__wrapper .cloud__text-container p {
  color: rgb(201, 207, 207);
  max-width: 30rem;
}

.cloud__wrapper .cloud__text-container h2 {
  color: white;
  margin-top: 0 !important;
}

.cloud__wrapper a {
  font-size: 1rem;
  font-weight: 700;
  padding: 0.5rem 1rem;
  border-radius: 0.75rem;
  border: 1px solid var(--ifm-color-primary-lightest);
  border: none;
  color: white;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  display: flex;
  align-items: center;
  gap: 1.25rem;
  box-shadow:
    rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,
    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,
    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;
  min-width: 11rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cloud__wrapper a:hover {
  background: rgba(255, 255, 255, 0.25);
  color: white;
}

.cloud__wrapper a svg {
  transition: transform 0.2s ease-in-out;
}

.cloud__wrapper a:hover svg {
  transform: translateX(0.25rem);
}

.cloud__wrapper--special {
  background: linear-gradient(135deg, hsla(161.45, 25%, 10%, 1) 0%, hsla(161.45, 66%, 16%, 1) 100%);
  border: none;
  box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.1);
}

.cloud__wrapper--solana {
  background: linear-gradient(0deg, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)),
    linear-gradient(45deg, #9945ff 0%, #14f195 100%);
}

[data-theme='light'] .cloud__wrapper--special {
  background: linear-gradient(135deg, hsla(161.45, 25%, 88%, 1) 0%, hsla(161.45, 66%, 40%, 1) 100%);
  box-shadow: none;
  border: none;
}

[data-theme='light'] .cloud__wrapper {
  background: linear-gradient(135deg, hsl(217.36, 62%, 95%) 0%, hsl(217.36, 62%, 68.5%) 100%);
  box-shadow: none;
  border: none;
}

[data-theme='light'] .cloud__wrapper--solana {
  background: linear-gradient(0deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.5)),
    linear-gradient(45deg, #9945ff 0%, #14f195 100%);
}

[data-theme='light'] .cloud__wrapper:not(.cloud__wrapper--special) .cloud__image {
  opacity: 0.66;
}

[data-theme='light'] .cloud__wrapper .cloud__text-container p {
  color: #2a2b2c;
  max-width: 30rem;
}

[data-theme='light'] .cloud__wrapper .cloud__text-container h2 {
  color: #1a1b1c;
  margin-top: 0 !important;
}

[data-theme='light'] .cloud__wrapper a {
  border: 1px solid var(--ifm-color-primary-lightest);
  border: none;
  color: white;
  background: rgba(0, 0, 0, 0.15);
  box-shadow:
    rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,
    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,
    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;
  min-width: 11rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* End - Cloud Banner */

/* Start - Getting Started Banner */

.gs__wrapper {
  position: relative;
  border-radius: 1rem;
  padding: 3.25rem 1.67rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
  isolation: isolate;
  overflow: hidden;
  margin: 1.5rem 0;
  gap: 0.5rem;
  border: none;
  box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.1);
}

.gs__wrapper h2,
.gs__wrapper p {
  margin: 0 !important;
}

.gs__wrapper .gs__image {
  position: absolute;
  right: 0;
  top: 0;
  border: none;
  border-radius: 1rem;
  height: 100%;
  z-index: -1;
  margin-right: 1rem;
  margin-block: 1rem;
  min-width: 12.5rem;
  object-fit: cover;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
  object-position: top;
}

.gs__platform__wrapper {
  display: flex;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.gs__platform {
  height: 1.75rem;
  width: 1.75rem;
  display: grid;
  place-items: center;
  border-radius: 0.375rem;
  padding: 0.25rem;
  border: none;
  background: var(--ifm-color-gray-800);
  box-shadow:
    rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,
    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,
    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;
}

.gs__platform--lm {
  width: fit-content;
  font-size: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.5rem;
  background: hsla(0, 0%, 100%, 0.2);
  color: white;
}

.gs__platform--lm svg {
  height: 0.75rem;
  width: 0.75rem;
}

.gs__platform--lm:hover {
  background: hsla(0, 0%, 100%, 0.25) !important;
  color: white !important;
}

.gs__platform:hover {
  background: hsla(0, 0%, 100%, 0.2);
  filter: saturate(1.5) grayscale(0);
}

.gs__platform:hover .gs__platform--image {
  filter: grayscale(0);
}

.gs__platform--image {
  border: none;
  border-radius: 0;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
  filter: grayscale(0.1);
}

[data-theme='light'] .gs__platform,
[data-theme='light'] .gs__platform-lm {
  background: hsla(0, 0%, 0%, 0.2);
  box-shadow: none;
}

[data-theme='light'] .gs__platform:hover,
[data-theme='light'] .gs__platform-lm:hover {
  background: hsla(0, 0%, 0%, 0.3) !important;
  box-shadow: none;
}

.gs__wrapper .gs__text-container {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  position: relative;
  z-index: 1;
}

.gs__wrapper .gs__text-container p {
  color: var(--gs-pill-color);
  max-width: 30rem;
  font-size: 0.75rem;
  background: var(--gs-pill-bg);
  padding: 0.375rem 0.675rem;
  line-height: 1;
  border-radius: 1000rem;
  box-shadow:
    rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,
    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,
    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;
}

[data-theme='light'] .gs__wrapper .gs__text-container p {
  box-shadow: none;
}

.gs__wrapper .gs__text-container h2 {
  color: white;
  margin-top: 0 !important;
}

[data-theme='light'] .gs__wrapper .gs__text-container h2 {
  color: #1a1b1c;
  margin-top: 0 !important;
}

.gs__text {
  max-width: 25rem;
  font-size: 0.875rem;
  opacity: 0.875;
  color: #c9cfcf;
}

[data-theme='light'] .gs__text {
  color: #2a2b2c;
}

.gs__wrapper--w3m {
  --gs-pill-bg: rgba(82, 101, 223, 0.5);
  --gs-pill-color: #f5f9fc;
  background: linear-gradient(135deg, hsla(250, 25%, 10%, 1) 0%, hsla(233.65, 64%, 32%, 1) 100%);
}

.gs__wrapper--w3w {
  --gs-pill-bg: rgba(135, 70, 223, 0.5);
  --gs-pill-color: #faf5fc;
  background: linear-gradient(135deg, hsla(260, 25%, 10%, 1) 0%, hsla(260, 68%, 31%, 1) 100%);
}

.gs__wrapper--w3i {
  --gs-pill-bg: rgba(39, 115, 101, 0.5);
  --gs-pill-color: #f2fafa;
  background: linear-gradient(135deg, hsla(161.45, 25%, 10%, 1) 0%, hsla(161.45, 66%, 16%, 1) 100%);
}

[data-theme='light'] .gs__wrapper--w3m {
  --gs-pill-bg: rgba(82, 101, 223, 0.5);
  --gs-pill-color: #f5f9fc;

  background: linear-gradient(135deg, hsla(250, 25%, 88%, 1) 0%, hsla(233.65, 64%, 50%, 1) 100%);
}

[data-theme='light'] .gs__wrapper--w3w {
  --gs-pill-bg: rgba(135, 70, 223, 0.5);
  --gs-pill-color: #faf5fc;
  background: linear-gradient(135deg, hsla(260, 25%, 88%, 1) 0%, hsla(260, 68%, 50%, 1) 100%);
}

[data-theme='light'] .gs__wrapper--w3i {
  --gs-pill-bg: rgba(39, 115, 101, 0.5);
  --gs-pill-color: #f2fafa;
  background: linear-gradient(135deg, hsla(161.45, 25%, 88%, 1) 0%, hsla(161.45, 66%, 40%, 1) 100%);
}

@media screen and (max-width: 660px) {
  .gs__wrapper {
    flex-direction: column;
    padding: 1.5rem 1.67rem;
  }
  .gs__wrapper .gs__image {
    position: relative;
    width: 100%;
    height: 100%;
    margin: 0;
    margin-top: 1.25rem;
    margin-bottom: 1rem;
    border-radius: 1.75rem;
  }
  .gs__wrapper .gs__text-container {
    gap: 0.5rem;
    margin-bottom: 0.5rem;
    margin-top: 1rem;
  }
  .gs__wrapper .gs__text-container p {
    max-width: 100%;
  }
  .gs__wrapper .gs__text-container h2 {
    margin-top: 0 !important;
  }
  .gs__wrapper .gs__platform__wrapper {
    flex-wrap: wrap;
  }
}

/* End - Getting Started Banner */

/* Start - HomePage */

.docs-doc-id-readme .markdown h1:first-child {
  display: none;
}

.docs-doc-id-readme .container {
  padding-left: 2rem;
}

.docs-doc-id-readme .feedback {
  display: none;
}
.home__divider {
  background: linear-gradient(90deg, var(--ifm-border-color) 0, transparent 100%);
  margin-top: 2rem !important;
  margin-bottom: 0 !important;
}

.docs-doc-id-readme h2 {
  margin-top: 2rem !important;
}

.home__small-container {
  border-radius: 0.5rem;
  border: 1.5px solid var(--ifm-border-color);
  padding: 0.75rem 1.25rem;
  width: 12rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--ifm-container-background-color);
  color: var(--ifm-article-text);
  position: relative;
  overflow: hidden;
}

[data-theme='light'] .home__small-container__img-container {
  border: 2px solid var(--ifm-border-color);
}

.home__small-container img {
  border: none;
  height: 1.25rem;
  width: 1.25rem;
  border-radius: 0;
}

[data-theme='light'] .home__small-container img.white {
  filter: invert(1);
}

.home__large-container {
  border-radius: 1rem;
  border: 1.5px solid var(--ifm-border-color);
  padding: 0;
  padding-left: 0;
  width: 24.75rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--ifm-container-background-color);
  color: white;
  overflow: hidden;
}

.home__large-container img {
  border: none;
  height: 7rem;
  width: 7rem;
  border-radius: 0;
  flex-shrink: 0;
}

.home__large-container--nofit {
  width: 7rem;
  height: 7rem;
  display: grid;
  place-items: center;
  position: relative;
  isolation: isolate;
  border-radius: 0;
  flex-shrink: 0;
}

.home__large-container--nofit img {
  height: fit-content;
  width: fit-content;
  position: relative;
  z-index: 1;
}

.home__large-container--nofit img.blur {
  height: fit-content;
  width: fit-content;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 0;
  filter: blur(20px);
  pointer-events: none;
}

[data-theme='light'] .home__large-container--nofit img.white {
  filter: invert(1);
}

[data-theme='light'] .home__large-container--nofit img.white.blur {
  display: none;
}

.home__large-container--text {
  padding-right: 1rem;
  width: 100%;
}

.home__large-container--text h4,
.home__large-container--text p {
  margin: 0;
}

.home__large-container--text h4 {
  font-size: 1.5rem;
  margin-bottom: 0.25rem;
}

.home__large-container--text p {
  line-height: 1.333;
  color: var(--ifm-color-gray-600);
  font-size: 0.875rem;
}

.home__wrapper {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  flex-wrap: wrap;
}

.docs-doc-id-readme h2#how-to-contribute {
  margin-bottom: 1.5rem !important;
}

.header-cloud-link {
  height: 1.675rem;
  padding: 0 0.75rem;
  border-radius: 0.25rem;
  background: var(--ifm-hover-overlay);
  display: flex;
  align-items: center;
  box-shadow:
    rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,
    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,
    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;
  font-size: 0.875rem;
  margin-right: 1rem;
}

.header-cloud-link:hover {
  background: #1a1b1c;
}

[data-theme='light'] .header-cloud-link {
  background: rgba(0, 0, 0, 0.1);
  box-shadow: none;
  border: none;
}

[data-theme='light'] .header-cloud-link:hover {
  color: var(--ifm-color-primary-lightest);
}

.header-cloud-link svg {
  display: none;
}

@media (max-width: 996px) {
  .header-cloud-link {
    display: none;
  }
}

:where(.MarkpromptContentDialog) {
  z-index: 200;
}

/* End - HomePage */

/* Start - Sidebar */

.sidebar__logo {
  background-repeat: no-repeat;
  background-size: 16px 16px;
  background-position-y: 7.5px;
  background-position-x: 12px;
  padding-left: 24px;
}

.sidebar__logo--appkit .menu__list-item-collapsible {
  margin-left: -24px;
  padding-left: 24px;
}

.sidebar__logo--walletkit {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAHMSURBVHgBXZM/TlwxEMZnJotQlAaSIlKUKAs9NDQUFNByACoKGk5ARcMN6GgQBQeg5wQUFPQ0FCAQICTYxy4I9B72YM/4zyxe7do7tn/zzWcb784H/ebaHb6PfJ8dAHvQhqxd+IQoYOi6D7htX7utpc2/p/Cl4cVJc9ZcdQvuIyzn+GXpKeyMYyGAdvHr2DfU6/1fXP81tKBeN+J57r6BTyDZIBrGmy9zNDX5u/0ZQmMgPN56agf3bqJsZKlHoDZEBv424JMA9V3nrp5H7zvbpzOXvebWw+ODqwQ7Yh0hVSjpkiWK2sLE9PT3f+H/CuXMwU71KEGkTNI6MdERUcynFIxrf0zRsiTIgXRESZP6IbDkT5bKWTHWdQpKM1mFnBpUYBwQ5g2scdRrIgpTrYT4hY7GJ1NWpvrkhSbjkpDUU707WZkFSLjIY83MSWW6rgJikzrXb73IPnFRBEWR9ZeKiczF4AIBs0n6oMhchby2lgb1KUQPRDYbBGeHsL5F85y0NIdDcZ8hvbEA89lMTAcARlNtUoEDJ6CJSd7PR4plUE8yH0L2xPoTEzaPbq9M7a7ebLwMuS8zxoPxRupPLI3kB1rX3s/9mT1YO0L3Ca5Z6DLMZdUkAAAAAElFTkSuQmCC');
}

.sidebar__logo--appkit {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIHSURBVHgBbVM9a1VBED0zd+/NC0HRVwRFAiqCjQH1B9jaamwsTaXgb1AQGytbWxHxLyjWigg2YmFhorGQh40YArnfO5n9uB957y3cnd25M2fOmd2lR8//bX7fLV+3li4QAGI3i7ekSxF4yzoZI7snU7nz4tmZn5gbZud3+aYo5QpIkzWYbbBoReEGIPfVDV3Vgi/VfWMBqCjsZQ2DZ+NdYXbGNkBjlY1nx2B1J5Y3sGSYbtFV7ofuKwWqamB9PcH0tJMNTDI59ert7J4LSVPKiwP5vH377B7duj+rmlbSQJ/CpwnWEvYPLNKMcXfLqtIonV2/ImndJyx7bV5ccynAWFJPiDyb6VQiiIuQjmxvtez5Mlu5pOAcpYnHCgkBtKoFdTtKpQFhDJzUWGWJjGjcoLi0tuNGITn+6q7FAKVy+9U8bYkricEUIHv/OLpuwEKLfok9YR5DD5oEnbR40qmJjOgYTq8uMx3Y4POEJNrwCFBZEaa4kXFgoIUsFcz+CP7vD7KJxvKBw7L98XDr3AdjZfEyig2XbyVzTot37xlrayHdGPv3+mZ1M0v1cp5A8RFfdrxfU+zAStA9XAeemvBYXZWmIj1Fjcgof/zg4lfMDa4q+wkYGIWjDY1IEnLPAK56lgGrE4Zh+oYlQ2vW23lOT5OEN3xfObSV5i6fozpJ6ddhWT9ZBnQEtwrdfyxdC2MAAAAASUVORK5CYII=');
}

.sidebar__logo--react {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYoSURBVHgB7VhdUttIEO4ZS4R9WucEq1RtIHlac4KYEwROgM3uO3ACmxMEXwCUEwROgHMCzFMqUFtWThDvUyhLmt6vR5It2/oxkMd0lUuyZrqnp/++niH6Rc8jtc6kzpibOoqOmKltmRSNjOMM/FcqWIf/n/uwbYjeg7+VLKoC4zZO1+GvVbAz/uGpsHGNqd4qs/KrFhLFYqYeXtsFSwfsNnbAO6EK0lRDOnR7ohwTDdh1XnIcvWLiLhEHeHZUGI0P78PeMh++fYBy16lyQ9Zq3/Ljh/8D8Ht6Gh3XrV9rwe7ddIxpTY6dHf/toqU6d9MOBNgNKKZLs+F0rdAw+mQVUzRho7r+tnO5wIeQUVE0JlaTiy3nFT1VQSsojL7jdXix5e4WzvmCEGg4olBL3EZkKA2HITbVXd7UfOPhjfCIRavc7FAFOVHUiikJ6rI5/tvfZGyn+3XqY+KBna3o8vy1u18lm5hvMbFFD9TEv1IFa2NwHZJEgl7v5murllh/LWYn8qqGKxWMHK7MsIxUKC5OEgnafZQEQGhcr8OLRQJ6qoL0EFsF2cQvy6ZItuLRErf6W+7xxfZGB/+H8u3wzo4Vk1J/2OcmVRqhPovvw+9l2fb3v9MjE6szvE4U8clMKOuJUfwp0YP6iMfTYrlESL6X9CwF02zTjDqm+R2SFK7kFlb26HE0QikK8LxFGo3SDZRWh1oFE3gLO4CnoyIUmQlA/WPF3xQvlgp8ayq4Efx7VL58oMicGtcdlqGRWlXshyfogQX24IJ8Jo5guQFBWMOE71PX1loAHrBookx8YrQektaeMubD8qbLYFPPFeOmBDwyciwQJt+w+1O876Qimv7Who/MIROThSgpxFRDgMauRRTd6GFzgf/nHFUS2TxYgM276CJfolRmtXlDABCH2RNlFq3AinYRiwciTJT3t91+NucQsAe/vk+k8tV5jv/wa9gHbw+LnWlFVxajjbm6ePNi5v48bKaNxK5YU+WVs3XMdfrL0HN4Pz1G8f0gpSSJKRXkszrbQJ5HYvN8O0GTOfZSM5MhDUfeCLN5YdTH61GmpJ51K2IR1LEiXDSO61s3pQEvFl6wXEE7BYvtpWMkMqGQ5ck2uKxcNg8xfSy62G4njHvaJoMw5NxVxAitPqa2WRDOpA7K+NjwzIX+640z2aSVkBTyUrK6iEGI99IkqcdNZNnvhd8VrQWHyTIpdDJ/W3euJsNXeDaLms6F+WTa6ZuXuS79/7mUR6tZxiY8yrPfFR1VNROJLugxSV1q4GzfpjlTX7CziDETLgGeKKt72bxzcV2xy4aLoWBbf0plNBFfKwU8K3Wii4SSiRunWvo5juPdpBbRsQrjm0ULWam2fBjbqq+261Ksk2MADW2W4j1fwHMW8VMZUgMPlo2gwvAGyh3bDI5RZt4K0mTaS2esGwjOLOgxqNg3zFcQfJOVllzJIHTDO3Uns6SMOeP8oukxwnNQqGNsXgyTodZyqVuFuhVFZ2YMNNOJViYIFaALdZEeAXXI6JPNF+7lNAzbyHzUueQIOpMuZxpNA/+1O1z4XiZYFKVGoz2v7sUkgvG4XRnQJFnvzZoFyfZFbCdrVWUGhDpbdi5Zp91KLIC4QtH0OGntZaEWPYaYA6XViFFiGE2DMrbdGsEDO1VsTq1gBUWYJkWVvwOMRVLY7EyTJONpIm57YjFxrf/GZvoCIQ4DTKzdZGXLb0tJ4pZR0XiKPoNEJ3Ugm5CfJvXOKoexIuXsfKWszM4X9qiCqi348NCkhlN57BTsRBiI29vSKiEoM8weCbaX8cGy/0lRTE91AT1FQcdxPLRGtYRys2trGAxCdr4tKfv0E6j62BlFAa1BkoGK0C2nJM1A2Y3CY6naxZubEwojsoekEkp7uE+Y086uPsSScLtca+yXFvLs2Pmcc3FSmzjAq1eE0XK9Jq6l7AYL12nsujsp3rYAm9crsEmzmwh7l1Nn6do6mG/XjevYptPe2eTu/Wy2LiVEvgTlT2/4M8FlaE8wV7D5fKv6XLPGBaa4UKykvILhIZQ/XYanGW8pbCZKZ9hMz1FwaaEkbohvWanLMsUK+RsN6VL+stxMn2nDOau7Xf1FP4P+B2wTguyCQQlTAAAAAElFTkSuQmCC');
}

.sidebar__logo--react-native {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAY6SURBVHgB7VhLWttIEK5qGT8yizgnGOUEY58AcoLA0mQBDrA2nMDmBOD1jLGzALLDnADnBMAJUE4QZhPbstU1VS3Jlm09PJBl6vvAUqsff//17Ab4La8TXKdT94bKMJo2CGjLDEJ4APLa9VrJWWv89WQLkD4SQUXeCcBR4J2uMz4TYPd6aGtSd/xor47GXtpCAow31STyN7Ykjirlq/UdfIYUUZAhGlRTwPFCbZ7wnUL9HlDXZQEg2mfwTwykuQLuyj3TpO8EHCIOmLUdM57/uK0tc+qf7nHW+pkMdq7GT/xTZmDVZaY618N9IH8DvNW+KuQFONBocmNYI3gmhPrhbqG/AL5LZZ13n3j154Pdwnt4KUAzUcH9IQx8ruU/xPZhEyCybphhsS8naLZlDIJXT1L/xaV7T0gVYTRNzTlIk+K0IhZN84VXJABQ/edq2ENQe0Fznze0kzY1O80j/6/ACMr8mwgw0wbXEWGRwW1GmirG89eQKYzstO+pACeaUj0sFFExBI5EoL+Y5+Hkbp2xOSg68FKAG8ozAHnRd0l9xFsD++sf7haPD3dL+77XUqX71T1LnBzxT/NbhFQSsr34cvwjydsYQENrOgexIcKTcLuK1LMG78Y8o2rVaxunCfMCz/sOXgNw5m1g7YDSmxrIBskIFBO4UxfCB1LkgAePCq0H2UBadJiPSxAxcj0c73OXBkAKGI5/qOk70WKoQKQygVHjNiQLB3s8VcobJIWjFYAmtUn20DwxQnnekRlAr81aHABaH0W16zBwce3e+amOTjyaDhRusMfD2cqmE9LmzEmEMT89qSdW3760cao69WhSlWc2+vJBrdQz7ZqOfdBeHTLE9CFxBGxuvPnDiWYVmRvBpL1Z2uxcu91oiMIZa/OCwOHdnB7U8r1lFjTqD0qCMW9AwB99KrXCPp1LTnuW+uivjLcHn+bj2SFavFJTKTxnld6aHI10e1grztS/kDalkOC1hE0VBRcUBNUoOMMe6VtDN6lGwK4TBScbAFRdYxbGNKjb+Tq5Cb8rN38uLArzDK7hM6MW8rNoR43z1VkhwZgEmwqrFWFE4lhcXlTjQs9XU2DwzHCUudhySuvtzqW7L4/1Oj5rpHCMzOEskxD2O/xUlE2cGkxgNZXZ8RIjcQPZVr4ErwuTo7L2ksaR0jMVHu0Wz4NNygYHkCIGi/Ql2g6dJDNvksK3se20Xjr0gQUAOSyt21cRGvsqxxWdi0hgK3iyQ9UFH74lrzG3M+NEYWhBaKQVEwEWm5nuKwuhxS8O670luTNuYGRyf0GkZtjvgFWHMSqTtgU7QxUSIHOU9c/JSgCfhzrdguDcoowrs0sbkOJlQ/d+kSEzuQkfHGbaceW6CdZ8DAiA9hldPRrAI4z0ZA5/SthbJkHW5lR6DJEwg/NJhrZH0IoUndxJ9SZ6fGvhxr28S8EQKdch7hiwwoofxp6ii3auRvyOtsphlWMmZyV9HGYtCXVWqdAKo0lsqlsCCjPAYJ1ATjvTqd5SgGf/J9UxMyc5LPQ1TLaQoBGUaHPhnM6qbR/VSoNoM6buHNgx5tE9XnhiqVBWmi18yyYj43xbk7CBK9HCAZMcCr2kc0l2uRUmezlqamWjwk1erLzCQJag5Ft44Hj6XYMcqOCG/x4+7xaqacNyWfOSZiBSsAaFQlT+vhy2VOid/lk5GIRl/msKY6JaE6SXhO3Q4XIsc5OpJb84hCzCtvYQ910ifuDV3M3ak034G2GW0bDcjgPniz9n99qYQaJkHDtHzIRKPXZK7ry4cjfFDKRUUlIUAG1L/chen3hzwOr9l+cNT3UOvAgg5Gy5/MgSHG98oIJ7b2o6v8lB9HbgF0jGuXjqwBoixQRTMpg1cPhZ9+YrS9IZHBWfoeByZkv2WElPs7uYUFXMJKu9IiwmApVjJ9/HvepcbJgBYm8DOy5Hy/WapKfwBkuKXSk6+VNfwpAUnStpE4L7HO3f5dRr6KRhWOdcPC/XC8H5djStRO/9xFul2I2OWwhBkdMbFFkrw0nT5FzOzVxQ1F8FMLjhklxsrwxm1jyuOJbT02xscto0oMPcDK8BGF2ID9z+dQXpRw+pnwQsbjyfm5kx9Ze8e9r7lntTPM+6Xf0tv0L+A4LqsVGg9U5IAAAAAElFTkSuQmCC');
}

.sidebar__logo--javascript {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAe1BMVEUAAAD/1gAAAAGqjwAHBgEaFQH0zQA+NAELCQHivQBuXAEDAgHSsAC+oABZSgFQQwElHwEgGwHbuAB5ZgFkVAE3LgEyKgErJAH60gDwyQDtxwDmwQC0lwCYfwCQeQB8aAFcTQFHPAEUEAHUsgDNrADIqAC7nQCiiACHcQBq8HVPAAAAAXRSTlMAQObYZgAAAMZJREFUSMft08luwyAQgOHOnwEb73b2pOm+vf8TdiyfHU2lHiLF/wU4fAiQeFjyJ44WsIB7BcDKhqoJZXh5d4NaGctrL+hB94a2TlBBWUnqiugENehBJLovnYA2/eWVXgHdDH5w3mGVm+gFEtc51v7kBNbpJwCFG1jHLYQrILWPIoMBG7534+mfQOfBKkeLS2agkgayJEdb9PNgyJnqxq2toMB6Hkg9Cf2y+TNTWbwC5Fz0ZWg/ZOyz6fQtuxxu4cf9D1hy9wvxdgtkiqc6zgAAAABJRU5ErkJggg==');
}

.sidebar__logo--vue {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEDCAMAAAC4WcmkAAAC91BMVEVHcExBuIRAt4FBuIJEvoVAtoJBuYM2oHk5uYFAt4RAt4JAtoFBt4JAuINBuoRAt4JBuINBuINCtYFAt4I1U2FAt4NHwoVCvIVAuIM7fXNBuoRAtII2UGJBtoJCvIZAuYNAuIJBt4M/tYJAuIJDvYdAt4I/uYRAt4JAt4FAt4JAuINAt4I/toJAtoE+toBAt4JAt4M2U2FCvYdAtoJCvYZBu4RAt4I3p3k/toFBt4JBuoRAtoJBuoRAt4JAt4JAuINAuIM1VGI2XWQ2UWE2UWJBu4U2cmxBuoQ2aGg7n3I2V2JAt4JBuoRBvIVAuIJAuII3d2xBt4FAt4JAuINAt4JAuIQ2UGA3Zmc8kHE2WmM7fW5Bu4U1W2NBt4NAt4JAuIJCvYZAt4JAt4JAt4NAtoFAtoE2X2U2VWE3Z2c+toBAtoI2UmFAt4JDvog5bmlAt4JAtoE2YmY2W2M1V2I5a2g1UmE3a2g3YGY1VmI1UmFBuIM2WWNEtoM2T2FAuII/t4M2XWQ2YmU2WWI2WWM4ZWtCu4U4cGtBuoU2T2JAtoE+n3o+m3k1SF5BuIM1SV40QVs1Rl00Qlw0Q1xCvoVFw4tBuoRBvIQ0RFw1RFxCv4VBuYNEwIk0RF1BuoNBu4RCu4VDvYdEwYpDv4hCvIY5T2U1R100QltCwIZGxo1BvYU0RV1Cv4ZFxItFxIw1R144TWQ9mnk3YWY1SV9ArX8+nXo2VmI6em46fnA4UGRBt4NDvodGxYw5bmo7hnI4amk3UGNFwopCvYVEwopBvYRBtoJFxYw5c2xAsYFBuYRBvoU6fG83S2E2SV8+o3w5dW09lHc/qX4+oHs1T2BAr4A3WWM4ZGc2UmE3XmU3W2Q/p302VGJGxY0/q385bGo8jXU1TmA7g3E9l3g2U2E5cWtCuoU9mHg8inM1S19As4FAtII7gHE1TF84TGM2SmE2UGA1Sl49kXY7iHM4ZWg9knY8kHU6d20/pn1Ev4g4Z2g8jHRBuIREw4s4ZWeFrX0EAAAAinRSTlMAGG4kCZPmAQMW0aIhPO6y3y8OfdrGBvXYE/AL+oPyMT5Mjs79XyxKsMPKvomlELlX0/pP+OloBXJj7IDxrFzj3ct06/b8JeRACbSf9vw5Nx5CtVMpR/FOD5QZ+I1rl9T7wHlaJpxtwkgTd+iO+S6qNFyErjreMmG64tqkHvm7RXxVnpws+jH8/KhO0lmEAAARs0lEQVR42u1dd0BT9xY+IggIOLDioO6J26Li1k5ttVpXl9rWWbW29nXX2vHa53t9bQIJJEASRgADCAH3gDgARXHviVprqbNqWwe2fX+8PxwVyLj3+917k9zk/E/uz8+bk+985/udQ8MLlWDErVVHA7H785HEHi9/eBV5eOyxS1r032scRuMM6F+nHFqTiBz4l8ej2MGasgR5dL5quQ7FqixtElH9vALwz7POxCqQIy95ghmrfz21G3ly5oYtehSsvJ5E1LBJBvjnWv2RTOTIV598gREr//eXIQ/O+eHEUhSrjMXvEhH5WdAPyF0dbYJera8ZwZqzeSX0Yq2Dv4RKix8REc0dZgA/QF+8NwY59MpvP2DCKuzxX5DHJq7ZnoJilT6i1t1nDygqQ9/NU0dzoBz/ZgALWLOXILlSkXQmC8XqT3P/e88OiPgL/RDdWTV07vUfM2D16lsYbTiihGlDUbvw+09v3T4VpQ+XjsciB9/1aTMcrFcg2mAyrY5DsapIj/z78d3L4VdrXw5GH6bAWP0bpA3blsK0wVL/oefXHmxEc3z8JojHX33qHRSs5yDaoDq4vxjm7qMnPnyAFjB9iNtzRYUcftlzIFYvgbThLE4byrtVOUGP4WnwF3EtxEx3b34JwurZ3rug7H74IkwbDA16VD1DB5g+xB9akwDl+EfCEbCegLK7IulGLlwUagZUP0RXM/phWefBEvEr6WiD+o42Gf33mSNqkMKxfVD6oFWuwHL8i89IRhuiD8AZK/Wx1jWP8Rqc43XL8/OhV+sz3lh99DlEG2JuwRRLWdrdyjlq9UVlQH3xTzFYjp/DE6uATzC14egqWG0w1qtt7ST94ay1dP9BiD7wlgH/uT4aog0bcdqQN8h6LV+3BC8RIfqgWDKbJ22A1IbY41th2lDS1Nf6Wdqko/Qh5eJxSGG++tar/GgD8rNryvkR15INE2wdpj78Rcy9kYTJgK/wwOqFJzHasCkFpg15422ehkFh1t7BWj2P8pABv4Fog+rCHvin8J6WbD3ml8Il4oForET8hLMM+MGjGG1YG4erDX52zoMrzGgXUbH+H1zBAmnDyVXxsJZcJ9DegXCFeemhc0lQifhhM1FpQ+x5WEtWmn3ss77GGrxEVIspA778CEYbjhXgtKGur/0zMSjMW1dACjNHGfArrChULYfVhorKSEeHCsK7iD+rMPrARQZ85kWINsRsyICze2lnh6eq3RwuEeM3QDk+mosM+BlGG67cxrXklhMdH2sQTh9u/4CViL0dyoAjv8WaFOvgL6GyvAWHF77HQpg+ZK3DXi2HTpGoN6HsnrBmO0wbamjJ1mMoTB9Sth+GFOarTzqQAT+GaIMi9g+YNpSldeBmUemZB+f4mwkYffjaAW2AmhRqhha0JsKfG/17dzJaIiZrf4e+iCsftesGfA9TGxSrYbWhon1rroWFH96gBk1Iy+zJgCht2FaMO9eCOJf3iwamS2xCil4/W2jakHPwBEwbCpvX5i6G+JSi/yeoCcmODDgSUxvUl+EvoT6vEQ+ZzbduEUwfNmLqg00ZMOBNSG2IPY63oNOa8ur/tkmvQGXArcegEnH3Ux/Zog2It0GR8CtMG7S2tWShFWbdjyqoi7jsE+u04VOMNvxeBtOGvJ48O3S4wqyPP40ZTa3LgO9J3oLO6NOKb++3Wzb6sB2gCWnXIy8LRxv2iqQl21CYG8Alom4nWCK+V/MY72O04eipLejpK+vU4m/B6KCR2oRkxSkyZzNGGzbiRaHGB7nFEIErzOg9lfeFMbwztaDb+SK2sXFvwCYk/RGsi1hdBpwNqQ2mxH1wdtcWRhIUQQwlogKiD9VkwGYgbdiUgmf3IaDVlUFh3rENKxGryoBTILVBdQVvQRsHTwTBokFw82LL/mtgifjQhbGPQMP7Wty5xklLtqEwD8cV5rNQ0aNY8g2r4T3n3CoGLXkufvGjVxqsMIP3VHb/LQO+9C1UFMb+BtMGvaYDjhWTwrwPU5gfXBgL6422oIX0JfOJVrgJKQW7pxJ9/8IYSBtUuHMt9Y3WxBR+cIkYt2clViK+1eyu4R2jDafjcdoQxIYV1RoBK8y6tSB9mIIb3lVXbuO0oV4w6z13H1jYij90EjIh7f78HaJ3MMN75k7cl5w9j3koAIOHGTUhLXsOpQ2Jaw7BtCHt9XBmsKhNISo5JhesAHP8nJGbMdrwB4OWHEkCBD4lQ7fcBHURd/XujfmSV+AtaDu+ZF4Kc0sj/IuI3VNRXIB+CU0mfHhKRpNWgoDFoDAXg/dUsMj8CW9Bl/sJgxWLwpx1WS0ZVqof8FvQ6YiWbENhZjEhJUr2YjG0oM0+JFhE4Ndcf01USINV0mHcufbQjAv2CIEV5uTkO9J8ERWJN3GDUeGXJGAE4SXigesmKcBS/y8ZVhvKFwiJFQXXg6dkxN2KkQArUzTuXDPyMRhxiUawsJWx6lyC+GDFbMNb0NkthMWKQpvCUzKyzmeKnuNV107Bt6DTFoYKDBZNSIMHKRZgJiQ+2V19Fm9Bl3QQGivyH2+GS8Sfc0R+tRicawWcfcm8SsTJuAlpQ6a4L1YS3oJOXRxCIoRfNvpqbQHvqfBoQcO0gVlLtqEw10EVZmXuOjGZqWrlnh2wL7lvbVHAYlCY0XsqHGkDy/CUeeJgRb7tcA/zrwmi5fiEk6vQbKosqRsuEljUqRD2MIP3VDj9FP6GG4yE0ZKtR2eYx8etvp4vElbHcOdaaX3xsKKZTWCFWbdXnFdLwdCCzmjSUESwGAYpbgHvqTjM7qfjYdqQ7ScmVhSKm5B0G2NFyPGqKzhtcDDjQgCFGfYwp2wVo0SM2alD1YYyIbVk6yXiNNjDrPsxxyQ8bYBb0AUlXcJEBotCHkMVZvSeilgt6PbjSPQIknxYrh3asKIAFY4KLN3Fx4qC68Ee5tydwtKHfIYWtHFwbQnAYlCY4w+tSRISLDXD/g5LCymwIl9cYdadEbKLqLpyAr7OZBgeKglYNMGA0odk/REB6YN6HcMSnaHSYEX+DNdcVysEow8JDC1oDZsvmZeHGVeYi7cJpTArEm4yaMljSLKYD1+BKt5/TSD6wDI8JW+UdFhRYJ1KWAY8Kwx9yGdoQacPrCUhWOSTxzAsVxD6wNCCLivtLyVWFNYFn8O8Twj6kHNtP9yCLqkbJilY1AmekqHXbhLgi6jG93doKyNJ4hhiQbuIO/ZcYM7xsccvwVqypbPUWNFE3MOsW8v6apkSbsBqg8hastAKc/yhk4xdxMw7yTBtsPhJjxWTh/k8m8Kcf/0A3FYV0JfMJ/BBitqCFUwlYswtmDboNVOdgRWTwrzcxNBFzDm6ClYbNF2inAIWhTwNK8zgPpV7P4Ub8XnJGePISTEKLhGXMtxTYWlBS6IlC60wK7Muo68WSwtaIi3ZhsIM04eUi4fBHK/elFIGv1iNnIcVhb0uuQmJZXiKYWGoE8GiyEqUHGpT7kBfxJi1eAtaM4OcGvVL0RIx7sB1IMfn4C1opaarv3PBYlCYdcg9FYb9HanPh5CTYz58BWrLqnO8TUjqFUqcNsxyNlZUawSuMP/Gd5SBSYW3oAv7LnI6WDTVjCZc/iakTIb9HXn9nY8V+TIozDz3qbAMTxHRl8xLYW4PK8wZG3jl+JidcFGoTW9DLhEL8GuuJ/iYkJIY9nfkdXYNrKh2c1xh5nFPRZFwBvclT27oImDRIFh9iN/O3YSkPqKHteTy+a6CFcsgxdwzXEtEllvQlc7Rkm0ozCW4Cel/HOlDDD48pczcj1wopsFuQN133Pap5FzDh6doGvu7Elghb8MKcxy3fSqZl/Gi8O3W5FIxCm5QLz11jcO4moTD2+Fb0E7Ukm3Qh4G4wsxhn4oiCd/fYWw+08XAonnwpr+US45LxMw7Wnyp4yBXw4p8cYVZt8/RKANTNN6CTmsa6nJgUZt0eJBi/GkHX8RMfH+HdL5kfgozTB/ibtsvEXOO4regNV2jXBGshqPhf1HuTrse5ky8BS3SjAsBFGaWEjHBnnMNb0Fnv+aaWNFcfEpGlp0SMV+FD09Jd6WisGr0g6+5apW296moN8GDuPV5Pq6KFYXhUzJ03ytsvFqqC3sYtOQwlwWLvsyAFeY4W/tUMvHhKRWFnciFYwHcoLZ1TyWRoQVtqe/KWNFM3MOcdTbG6i1ofH9HccuGLg0Ww6oe6/tUYo8V4FpyW9fGikIZlsFbKRHzVT/jtGFYLRcHi4bCgxT1VvapxGyAacOfmgGujhX5d8VLxBr3VFRXbjNoyQEuDxaN+U8qjFb1fSoM+ztS3wghN4hZ+CSkQyerKMwJa2AtWVke5A5YUfBAfJBilX0qLMNTCgcGuwVY1B9eBp9SZZ8Ky/4Op/qS+SnM+JSM5fkPuogmxfdwxjIsDHcTsCgSVpj18X/fU1HjLWitYQa5TeAK89IT9++pqA7iw1PMXf3dB6yO8KY/pe7+PhX1ZQaD0Vhyo2gLK8wpF+/uU0k8fFF+WrL1CBwGe5hzbySaoqMVSTdh2uDCWrLQCrNee0cdHa3+XZuMfoDZx72womcbwwpz3IGVKlX0d7iW3OVZNwOLxrXHS8RbMTF75aolW4/usIc5ftXBK6dg2uAyvmQ+gS+DV+rO4rTBOLqjG4JFg8rhdt/WrbjBaL47YkWhC+ESUQ9jZRgW6JZg0QzYwwxHmaaDe2JFAV01UoOlaRzlpmDRmMWp0mLFvJDdqQpzubRgWYLcFyuq1bdQSqyMzYPdGCzqny0lWKWN3BkrCseXwSNacqhbg0Vt4CkZgC+5F7l5DIGXwfOmDV8EuDtYDZsUS4NVxuJW5PYxX6Ic72Zasi2FOV0KrNxOSxZaYZa1lmw9ohpLUCIWtQuTBVg0zlghNlbayk4kk+gueolo6SwXrCi4ucglorFJR9mAxTBIkWOTopt8sKLQpgYxsaps0ENGYNGMNBHpQ5l5gJywIv8vzKKViAWaiChZgUVjnhZNYU59LIRkFq+JluNdYPCh8ApzpThYFdarLTuwqH+eXpwXq5H8sKLwukViYOWSMy6EUJhFKBHL0maQLKNzqQjcfbw8sWLxMNukDYvflSlY1FZw+pDtJ1esaO4wgUvEyjqBsgWL+hUJWiKWOWmJjkQRIajC/FeXKDmD1bq9gCWitn0nknUECZfjCyxD5I0Vy6qeGi3o0R1lDhZNF4yZWrrJHSsWD3M1g5G8tGTr0UsYhbmsaID8saKArmYhwNJMi/IAsGhsnwwhisIQ8ogQQmG2jPIMrCiwL7MJqXDgIg8Bi3zMrDlellqyjRzfjtHDnNY03GPAoklsJiRtei/yoMCXwctaS7YeHfFBikplRp9WHgUWdWOgDy4/+FBw+oB7mGXiS+YTA1CFuUzTz9OwogDUw1zSLsrjwKLWmAmpwjiJPDBGQfdUZK8lWw9IYTYOnuiRYNF0YJCipYVnYkXhTXkrzIYGoR4KFk0w8Lzmqi0Z6qlYkX9Pfh7mAvM08twYy28ZfMbTYzwYLPLL5vNqlc7yZKxoUZ1CPlpysEeDRT55PGSs6Z6NFflyX9UjU18yn5hUWMFVS44kj48hHJ0i5p5erKgjt01/GZNbebEi6sbpBnV2Wy9SRDS3AQcPs6x9yXyig+MGtSdqyTZKxAiHJWJJlzAvTncj5G0HOT6l/ZdelO7HqPIC+77kBV6MHkSw/WXwHqslW4/pdhvU5S28CD0UdhVmw/AeXoQejl6GMtu+5KFefKpEQE+bHmYXXcjuzGhlS2FOXTzGi0718LPRoC6f5cWmRgSOSPdwXzKfmGp1Skb5PC8y1nJ8FysKc9rr4V5krMUkYw0Tktbg1ZJtRA0Pc4FlvBcVGzGxuofZ2LKjFxVb0a1a88Li1ZJtx9zhVRTmyhFeLdlODNDoH56XPNWLiJ2IinioRCzq4i0K7caY5x/QB23hJC8e9mPWgxxv+a8XDQex6L7CbBw804uGo5huuZvjs71asuO4tww+bWGoFwvHMcGglcUSHWlifJ5Saf7CiwOn6Dg5I3XxWC8O3MLPYvFqyVwjcGBzr5bMOXxcc8bF/wGGS1aI18W9iAAAAABJRU5ErkJggg==');
}

.sidebar__logo--flutter {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAPoCAMAAAB6fSTWAAAAIVBMVEVMaXFOw/hCt+8BV5tUxfhUxfgBV5sptvYBTosBQXIALE/GWTR8AAAABXRSTlMAuhC1gNiI0uIAAAAJcEhZcwAACxMAAAsTAQCanBgAABwxSURBVHic7d0LdhpZEkXRQqZVJc9/wL2wfnwC2ZZAGXHf3t0D6JUvT19IEP7nHwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAqx52XNi7YcjysPsf53Zbnwrcls4LOieMzgs6J4zOC96fE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRecGeE0bnBXtOGJ0X7DlhdF6w54TRuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/n9px8Orfn5NO5PSefzu05+XRuz8mnc3tOPp3bc/Lp3J6TT+f2nHw6t+fk07k9J5/O7Tn5dG7Pyadze04+ndtz8uncnpNP5/acfDq35+TTuT0nn87tOfl0bs/Jp3N7Tj6d23Py6dyek0/nnff8Yc+Fh61PZSKdd95zp9P5dCZxJ7Xe8131P29xu61PZSJ3Uuc7yel0Pp1J3EkFe97ZfutmJtJ558VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nEndS58VwOp1PZxJ3UufFcDqdT2cSd1LnxXA6nU9nFLdS48VwOJ1PZxg3U9vFcDSdT2cct1PTxXAwnU9nIDdUy8VwLJ1PZyS3VMPFcCidT2coN1W7xXAknU9nLLdVs8VwIJ1PZzA3VqvFcBydT2c0t1ajxXAYnU9nODdXm8VwFJ1PZ7zVb682i7H6QfQ+nQBr32BtFmPtY+h+OhFWvsXaLMbKh9D/dEKse5O1WYx1j2DC6cRY9TZrsxirHsCM0wmy5o3WZjHWvPxTTifKirdam8VY8eLPOZ0w691sbRZjvUs/6XTirHa7tVmM1S78rNMJtNYN12Yx1rrs004n0kq3XJvFWOmizzudUOvcdG0WY51LPvF0Yq1y27VZjFUu+MzTCbbGjddmMda43FNPJ9oKt16bxVjhYs89nXD5N1+bxci/1JNPJ1767ddmMdIv9Ke0OZ0FZN+AbRYj+zJPP50lJN+CbRYj+SLPP51F5N6EbRYj9xInnM4yUm/DNouReoEzTmchmTdim8XIvLwpp7OUxFuxzWIkXtyc01lM3s3YZjHyLm3S6Swn7XZssxhpFzbrdBaUdUO2WYysy5p2OktKuiXbLEbSRc07nUXl3JRtFiPnkiaezrJSbss2i5FyQTNPZ2EZN2abxci4nKmns7SEW7PNYiRczNzTWdz8m7PNYsy/lMmns7zpt2ebxZh+IbNPh+E3aJvFmH0Z00+H4bdom8WYfBHzT4fhN2mbxZh7CVc4HYbfpm0WY+oFXON0GH6jtlmMmZdvldNh+K3aZjEmXrx1TofhN2ubxZh36VY6HYbfrm0WY9qFW+t0GH7DtlmMWZdttdNh+C3bZjEmXbT1TofhN22bxZhzyVY8HYbftm0WY8oFW/N0GH7jtlmMGZdr1dNh+K3bZjEmXKx1T4fhN2+bxeh/qVY+HYbfvm0Wo/uFWvt0GH4Dt1mM3pdp9dNh+C3cZjE6X6TN7LY+FUJu4jaL0fcSbWi/9akQchu3WYyuF2hTu61PhZAbuc1i9Lw8G9tvfSqE3MptFqPjxdncbutTIeRmbrMY/S5NA/utT4WQ27nNYnS7MC3stj4VQm7oNovR67I0sd/6VAi5pdssRqeL0sZu61Mh5KZusxgPu3+3vhb97Lc+FUJKb7MYD7t//1V619NheOn7Vp0rvenpMLz0XbPOld7ydBhe+r5d50pveDoML33XsHOltzsdhpe+b9m50pudDsNL3zXtXOmtTofhpe/bdq70RqfD8NJ3jTtX+m7rUyGk9H3rzlcvvc3pMLz0XfPO1y69zekwvPR9+85XLr3N6TC89N2Aztctvc3pMLz0/YjOVy29zekwvPTdkM7XLL3N6TC89P2Yzlcsvc3pMLz03aDO1yu9zekwvPT9qM5XK73N6TC89N2wztcqvc3pMLz0/bjOVyq9zekwvPTdwM7XKb3N6TC89P3Izlcpvc3pMLz03dDO1yi9zekwvPT92M5XKL3N6TC89N3gzvNLb3M6DC99P7rz9NLbnA7DS98N7zy79Danw/DS9+M7Ty69zekwvPRdQOe5pbc5HYaXvo/oPLX0NqfD8NJ3IZ1nlt7mdBhe+j6m88TS25wOw0vfBXWeV3qb02F46fuoztNKb3M6DC99F9Z5VultTofhpe/jOk8qvc3pMLz0XWDnOaW3OR2Gl76P7Dyl9Danw/DSd6GdZ5Te5nQYXvo+tvOE0tucDsNL3wV3Pr/0NqfD8NL30Z1PL73N6TC89F1457NLb3M6DC99H9/55NLbnA7DS98t0Pnc0tucDsNL3y/R+dTS25wOw0vfLdL5zNLbnA7DS98v0/nE0tucDsNL3y3U+bzS25wOw0vfL9X5tNLbnA7DS98t1vms0tucDsNL3y/X+aTS25wOw0vfLdj5nNDbnA7DS9+v2PmY1NucDsNL3y3a+YzS25wOw0vfL9v5hNLbnA7DS98t3Hn/0tucDsNL3y/deffS25wOw0vfLd5579LbnA7DS29zJ23WeefS7Tm3KV3nnUNvczoML73NnbThnvdN3Z5zm9J13rn0NqfD8NLb3Ekb73nP0u05tyld551Lb3M6DC+9zZ3UYM8P/teKPec2peu8c+ltTofRHnZt7qQme37wvzbsObfx0OVCNuq8T+ht/l8Y8jpvk7o9J0yzznuUbs8J067zDqXbc8I07Hz70u05YVp2vnXp9pwwTTvftnR7Tpi2nW9Zuj0nTOPOtwvdnhOmc+ebpW7PCdO8821Kt+eEad/5FqXbc8IM6Pz7S7fnhBnR+XeXbs8JM6Tz7y3dnhNmTOffWbo9J8ygzr8vdHtOmEmdf1vq9pwwwzr/ntLtOWHGdf4dpdtzwgzs/P6l23PCjOz83qXbc8IM7fy+pdtzwozt/J6l23PCDO78fqHbc8JM7vxuqdtzwgzv/D6l23PCjO/8HqXbc8IEdH770u05YSI6v3Xp9pwwIZ3ftnR7TpiYzm9Zuj0nTFDntwvdnhMmqfObpW7PCRPW+W1Kt+eEiev8FqXbc8IEdv710u05YSI7/2rp9pwwoZ1/LXR7TpjUzr+Uuj0nTHDnny/dnhMmuvPPlm7PCRPe+edKt+eEie/8M6Xbc8Is0Pnfh27PCbNC53+duj0nzCKd/13p9pwwy3T+N6Xbc8Is1Pmfl27PCbNU539auj0nzGKd/1no9pwwq3X+R6nbc8Is2PnvS7fnhFmy89+Vbs8Js2jnH5duzwmzbOcflW7PCbNw59dDt+eEWbnzq6nbc8Is3nlduj0nzPKdV6Xbc8LovCjdnhNG58Wrd50TRudF6DonjM6LJ3I6J4zOi2fvOieMzotP2XROGJ0Xn6frnDA6L745o3PC6Lygc9II/dLjj61PBW5N6RedPz0pnThKv+hc6QRS+kXn//1n04mj9PPOlU4ipR93/t8zm04cpZ/tudKJpPSLzh9tOnmU/vYc7rXzR5+nk0fpZ3v++Kh0Aq1e+q/ncK+D/qh0Uq1d+sXr9meevRNn5dJf9vzpbc5fU1c6cdYt/WTPjwZd6SRatfTjPf+VudKJtmbp5+/PjzO36SRasfSTPb/IXOkkWq/0i+ftZy/dlU6i1Uo/f39+OehKJ9Fapf/a86PvyTxezLnSybRS6eedX1l0n6cTaJ3Sf/O8XelEW6X0lz0/ft5+PXXfkSPOGqVXz9s/oHTirFD6xZ4/d27TWUh+6dXfq3086TadPOmln+75b57EKZ1Y2aW/7Pnr6/Y/qdymEym59Oc9P33l/vFDd6WTKrf0s78//9M9t+lESi39dc9fv+D+R1uudGJlln7ye69HH6B7n86qEks/e3/+B1+Vsemkyyv97e9YXl64/13k3qeTKa308/fnr3tu01lbVuknf5f6mdftNp1QSaUXe371xyaUzlpySn/d89//pIzSWU9K6ad7/vFPyiid9WSUfrbnbw/iPpm6v08nTkLpr3+vVv7WxGdiVzpx5pd+7Xsyn590pZNneukvnb+/QX8p/bORK51Ms0s/3/PjB3FfaN2rd+JMLv39efvRX6w9v3D/WuxKJ87c0s8/V3vJ/K1umw7zS399f370k69vH6594VmcTSfUzNIv9vz1/fnXClc6sSaWfrHnJ4v+1Y/YvE8n0bzS3z5XO3rg/vc/K6N01jKt9KPPz4uX7hexf657z96JM6v0y+/JnL1D/92/rah0FjWp9Menn2+v3M+euH/9e3E2nWhzSn9/DvfBot/mzbpX78SZUvrjz8v35xeL/vnfnlA64WaU/tr5lQ/Wbvay/YVNJ86E0qvOLxf9ht+dUTpx+pf+1vkh8/cfj7r19+KUTrTupR86/1m9Q6/G3Pt0GFn6f/Xr9qPWv/IjUjaddXQu/fHnz/dP0ItFP1r1T/xDLUpnJX1L/+/n8Rv0kwdx7990f2n7xm/VPZEjTtfSD50fv3QvB/39BfyXfvRZ6eTrWfr7nr//o6mXPxZ37QHcl4O36cTpWPp/Pz9+g376Rv1Gf9WidKL1K/14zy8fuZ9VfvI9d3/hAlNKv9zzs6+5H396ftt35++8eidOr9KP9rwa9F8v3U+fw93s2zJKJ1qn0g97/tGgXzx5v0vmNp1EfUq//rnaydO4s9+EvEvrXr0Tp0vpz3t+POjV47jLT9Ff3LZ1pROnR+m/nsNde93+/geqF0/d7/I8TukE6lD66fvz15fu1edr71+Cve0frymddNuXfvK52ts79GrSb/tzE0pnJVuX/rrnbz8TV6X+/tz99Ivux0/llA5tSz/b86sv3Is/U73nrHsiR5wtS/+150eD/r7op/8U09kr+ONvv97i31BWOgvYrvSz1+3nvxRXfI5+krpNh7+wVenPe37xKO7Dl+/H79PvMeVvvHonzjalP73v+cmjuKt/unbxqxN3HXWlE2eL0n91fvbK/e3bMiffmXl76H724v2Xuzx2VzqZvr/0585P36AfvXYvJv3oafvJv8t0NzadON9d+sueH79wP/4UvXyLfv8/XlM66b639Op1+1vn54v+/MMTV/5O9a6123TifGfpr3v+XHrxHr14Jnf0l6rn34i7z2fpSifS95V+9Lr9dNCvvUd//nHIk+/G3fzfcFA6i/iu0t/2/PQd+q/CXz9fu4j97PO178ncq3cSfU/pJ3t+8sz9+OO1iydxZ5l/z+M4pZPoO0p/3/OXL8Ud/+REnfpb5id/wHb0jzN5Ige9Sj953X7yyv38b1ou/vm18t9v+IZR9+ydOPcu/XzPT/9E9frvy1z8+2vf9MJd6WS6b+lne378yv3kmXvxz6kefzfu+D269+nQrPTjPa+/L3P1edzRP9dy9A+2fNeqe/VOnPuV/tHr9rMfmLnyPO7sj1q+7cW70slzr9JP9/yp/F5c/Sb99RuwV/8mXenQpPSny8yLRb/2SfrlP+Hwzbx6J849Sj97f/4652fP4o6/BHv2PO7kD1s2oHTi3L706jnclffol3+n+vzTE1tWrnQi3br08z2/Mukf/fTE68O47dh04ty29Cuv24s36PUH6a/P3DftXOkEumXpxZ4Xg37xs+7nr943jVzpZLpd6Zedv362dnD2LdhrX417bMGrd+LcqvRqz9++MlNlXj1070LpxLlN6X/0HK5+7d6t8gOlE+cWpV/Z8/cHcsdfjXv/gO0t9sdulE6cr5f+9IeRn7947zjmL5ROnK+WfnXP357GXXyO/v4O/bEppRPna6V/uOcXD+NOFv2xMaUT5yulf7Dn75+vFe/RW1d+oHTifL70D5/DXfkZ2AGVHyidOJ8t/cM9v/wHFp9LfxxC6cT5XOkfdX78Hv3opfuYzJVOos+Ufr3zK/8i06TKD2w6cf6+9I9ft/96k3782H1a5QdK55/VS//N+/PTRZ9Y+YHSWbz0371uf3vsPrfyA6WzdOl/sue/Mp9c+YHSWbj033X+6/15QOZKZ+XSf/+8PaTyA5vOoqX/wev2lMoPlM6SpT+tVPmB0lmw9Ke1Kj9QOsuV/rRa5QdKZ7HSn9ar/EDpLFX69b9LHfdN9r+jdBYq/drvOieP+Quls0zpV343Kr/yA6WzSOlP61Z+oHSWKP1p5coPfmx9KnD/0p/Wrvzgh/uM9NLPOl+v8oMfW58K3Lf0p8XH/MUP9xnJpT+dfWL+/N8F/dj6VOB+pb91/uufTFs18l+UTmzpT8eVH/6zsh9bnwrcp/SXX4F7/+dPlQ5xpT8dV7726/ZnNp04D7vnX3J9D335zh+VTp6H538a8X3QeVQ6eR5+nL9uV/ujV+/EefjhdfuFH1ufCtyndM/hTiid4NJ5o3QiS/fm/IzSifPwwzO4C0onsnTOKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Si8onThKLyidOEovKJ04Slc6K1B6waYTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUTR+kFpRNH6QWlE0fpBaUT5+EHFx62PhUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/lnQ/wEgjixBSUCNiAAAAABJRU5ErkJggg==');
}

.sidebar__logo--android {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJjSURBVHgB7ZZLbhpBEIaruoc9NwhIibeQbRKT4QbhBnACYBnZElg28hLnBJAT2DfIRImyJdnGtuAGYW+qK9WNjWw8D8AezGK+xQzMo/9/uuvRABkZGRkZkfh/e2VImSQNFXXj3bhXJsWjD5fHPqTE/lWvbjXiTEYa/FU8+C2nAJUa+ONuHlIAETpyHAZ7Tms9gxatdQOYC2amW/DMVK57HZaxtVZHcc/FGgyKnyfIfMSIzeecRX98WpBTnYG/WI24Zz1IQHl0RsZrEuX68rexEJG4Ic2+LFEJgcvA+OADRHwi96aA/F0TBveXkch0AEVce2dJ+ggr8P76pKUY+hq4ZlCVRLwlDtabUcSJvBNoNl8J8ZtcaPx4fTBMek3BCuSUvpBPmRLgucRNd21zFok3OdTn5mx8q2CV1xINVsa9JhkabWQqBiIa7V+eJCZf5BLbpJC4G8hXf4JUwaHWN+2g2J2G3oVQc6cFY0iWE1LvJHMXONFKVcMyGh+b6+aNyY3YxcwWcSZv3i7P5KMYJPLOt27OIppWe/nyA4O2usvJh5fDX06chUEbd66EhCA9U4qsrYHQhifCtjMxV+djholB/7bTOBadxFX3CBRhI9g7dANWro4LDNiEjcDhzzeHXftLdkltvK2Jy0gJkuoBVadtD77bUnE9atgZmkUNZFCvYHMW4yT0WP9um+eyWPZlgziDrk1JY5d+W4p9biVwKP35D8oqxCcjXkgrrOG8IHv/YPeYaj0rKiLtw26SB/Gm8GXLSixGvMkuysbVjoL4UUmabKffboDsBQoeG65BRkZGRsbO8h8F0/5P/vmvRwAAAABJRU5ErkJggg==');
}

[data-theme='dark'] .sidebar__logo--unity {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAQAAAAm93DmAAABZklEQVR42sWWYW3DMBBGB8EQDKEQAqEMZgYrg4RBy8Bj0DEwhEEwBEN4k6xJnxqd7Fz2Y+9PKsV6lT/dXe5tDiu3/kz9+TdYqMDWf29AJZ2XRQodCTuZ6JcF7gA7obi7pHzQYCR0XJ6Fb4QtlHQ5lNox4SRRAisNi0L8/btPbFbCXpckG12KRAWEnSgZi2YXMjds6ZeOWMk9CJZucPkyFI6LguQXQiXahUUBt9AuCoLy9glFYx0UlleoomChIhzCxnEadS7cVBQTnkS2sVB9e6EyotA76JBw3GbqIJ+wg64k2aYOcggFF0Bc9OasMAIi/ruwcXUJF+pIqMDnQr1/GEINeq9Q8xEJySwvX+RMnAmJ5JdziWzvMU0zxhLu5k7lNttjRCVZQq7GuT0EnlgUEiDeKVg87GDPklUde2nFS5mtI2ki9S9MBDYmaO7Y+BN9Ek+uw/7UHIlqWnuxm59Zar5Ey7HUfgB4eY0YKpIASgAAAABJRU5ErkJggg==');
}

[data-theme='light'] .sidebar__logo--unity {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAmmVYSWZNTQAqAAAACAAGARIAAwAAAAEAAQAAARoABQAAAAEAAABWARsABQAAAAEAAABeASgAAwAAAAEAAgAAATEAAgAAABUAAABmh2kABAAAAAEAAAB8AAAAAAAAAEgAAAABAAAASAAAAAFQaXhlbG1hdG9yIFBybyAzLjUuOAAAAAKgAgAEAAAAAQAAACigAwAEAAAAAQAAACgAAAAAcae2+wAAAAlwSFlzAAALEwAACxMBAJqcGAAAA2xpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NDA8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NDA8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPlBpeGVsbWF0b3IgUHJvIDMuNS44PC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMjQtMDQtMjNUMTI6MTg6NTMrMDM6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4Kh3z99wAAAj9JREFUWIXFmOFx2zAMhb/LdQCNwGzQbKBskExQdoKmE1idIM0EdieIN5A2aDawN7A2SH+AShSFIgFKur473FkyAL4jQAAirIMd8DB69pPn/4YaOAGvQDN634R3J4RsMa4K7RzQBnEZvX2QlN4srAQr4BHZmdpg54PNI4VENfgBXJDQxaQZ6TYJPVPYNTtYA3+B38gOLoVDQq6KQoqg4z3Pvi7nNevfnJ8VUjZS4ZzK9LA44GCwfw1rZiPkjcRyYfK8lyGtPz/nbG9wdMFWiB+MRI8xJ63SuPSwOPRhbwejkkL9AvQFdmegK7B7g3YHh1xxBt+10X8bc2JxMEiuRFTYcnt1gsOB2UWI7bBVhM0IjsPu+TjhlMobwS8xphP06E6tQ8KpRR/EpZQ0p/gJuAb+GBbP4QjcaHxqy8wZCd9N+F2KDrgF7rV+rHXwBdnN79oFAnrgJ0KusyxYOlEfwmK/Mnp90LlGOpAZmkMyhzMymB6ReTGGW2TXi1G6g2Ok2l5JS/yANQhuihzBnoUhyqAjc9hSBIfkjs5mK6FD8vRJozy0uhbbpOKYb1lWPwcmrW6MPfHxffgWnptcrAQd6Y95j6FlTieS2OSiJRibcE4U3uHUpCeSYXLRErwz+EuiAp4TjmJjkU/8/w3bGKfqNg77N+0assf4MeZYPnhqo1BbiE3hNyKqzjsNKtI3Vha5BF9rXER9gmNZfj6z4f3gGDW2sC/Os1J40kStdzibwCH1a0quYaM8K4VD8rNlxTz7Bzjs/g0YMafyAAAAAElFTkSuQmCC');
}

[data-theme='dark'] .sidebar__logo--ios {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAHjSURBVHgBzZiPVcIwEMYPJ2CEugFu0A1kA7uBbgBOgE4ATIBMUJwAN0g3wA0+70zUGpImpTTt7717vNcmj6/J/cmFqGcATNme2Eq2E40JFpSzKdSgscBaFjjnSGOAhczh5oWGhkVk9rbWyGhoWEThEbekMSB+NlrfExzidmxTGgPG/34oZbupIxNqiXH07HvyZHJwvM/5p+J3lTVnxiYrWdnvOwOdcNdsJ88WFo45M+hcqOBGnj+iS2RDl6kV4lDmI1Zme2NRbHNqixF3RDoe2goskRaF2GiH9o3U4max4ppKVV/iMp+eG8eznEwaScRzq5SDtL5XhvT4VjAV29CAfwIR66jX4y00wF7BpEWdfe8zNOaGhiMoThhSoFSq4I7ZAqO+6ooEfd4WWFFa8tCAs/MgdHOdKlhkx26bgsXlgx+UDlmIddMAl8A9pUV66EX0aOiT8BDIyTyz9Uw8IqVG5jQMd+yTv27my4PvNAxVXZwX6OP+CekpbC3OFTRh/0ppqdgO9sOmUic3USkry7Z1rwx9M5oCRZcCHf59k9GlQAeMQn8sqSvQybuPqN6E/jv68gi6HdiRu+OTYJL8tae/wJLx9+TvECUoCrom0D3zpraapWwRGg6e0BdPMkcZkzkFRfIFK061Z74gD/kAAAAASUVORK5CYII=');
}
[data-theme='light'] .sidebar__logo--ios {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAE3MAABNzAG2nloDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAo5QTFRF////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoqtv5wAAANl0Uk5TAAECAwQFBgcICQsMDQ8QERITFBUWFxkaGxwdHiAhIyQlJicoKSorLC0uLzAxMzQ2Nzg5Ojs8PT4/QEFCREVGR0hKS05PUlNUVVZXWFlaW1xdX2FjZGVmZ2lrbG5vcHFydHV2eHl7fH1+f4GCg4SFh4qMjY6PkJGSlJWWl5iZnZ6foaKjpKWmp6ipqqutrq+wsrO0tre5uru8vb6/wMHDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onr7O3u7/Dx8vP09fb3+Pn6+/z9/rLcTGIAAAQsSURBVBgZzcGJX5MFGAfw3zYOOVVEIZPEKIhGZCaYmVooaWkJGZok5FFqeRSmkVl2WFhm5FXikUWFlZGaRxheHKIoKoYy9vtv6pMfkm2w99n2Pi99v4CCqPFLd11biX7ieHLPDf5jGfpF3EuneMti9IOo16+yWymsl3uCt82D1WLedrOHIljsrpP0kA9rpTfSgzsBlsq+QE+/wlIPXKGXN2Gl+D/pLQ9WqqS3zlhYqJQ+PoSFMm7SmysVFqqkj49hoWz66EqDhXbQx0ZY6GH6ODMIFtpAb65cWOksvb0KK91Lb3scsFIJvfwYC0vtoKeDA2GtS/RwJAEWc7GnnYmwWAR76CixwWrxvO1wJqyXzG77nxuAfpDKf51blYr+kbhgdv6ErBF2/L+EDYqAqZImlW74ZvfWTze89Xwa/EsvKtt6vJO8efH04c+KM+0IXdaaJvbQ8mXJcPQha+Uxerq0fdGDCEX8wkP04f7uxSR4s41+4yR7dWCaHUGKWtTK3nXtmOJADzlrz7Bvf8yJRBBsRQ304+yy4bhl6KITNND8AgKWXEUjP68ofOyptTWdFNgci8BMb6W5jmUgEKtouvZZELOVU0MxhOwfUEXno5Apo5ILKZAopJrfYmDsoQ7qWQNDcQ3U83ksDK2nms5SGBvrppaGHBiLOEIte4dCYC61bHFAwFFHJfsiITGDSmrjIHKQOtpHQWQslcyDTDl1fAUZexNVuDMgM546KiG0jjqyIVRLFfshFO2iioUQGkcdaRBaQBV1kNpEFe9D6luqWAKpeqp4BlIdVDEGQgnUcQeEMqgjGUJO6rgTQk7qSIGQkzpSIeSkDieEnNQxHUJ3U8cSCEVTx0ZItVLFT5CqpYquBAhto45CCL1DHVsg9DJ1XI2GzAwqmQ+ZUVRyOgwitjYqKYDMPiqpj4FIGbWsh8hMqpkIiVFU05wOAdt5qmm5HwIfUU9rNow9S0WXx8DQEDcVXX0Ehg5Q0/UF4TCwgrqOjId/o6mtYhj8OkZtV0rD4MdiqutMhB/JXdS2DX7tpLZ8+PU0lbWEw6/IZupaAwPzqSsTBiLPUlMVDM2hpgkwFFZHPT9AoIB6pkDA/ju1HLJBYhq1PAER2y/UsRlCeVTRlgSp76mhGGJjXDRfjR1yr9F0riwEwFFNs61GQFLaaK4zMQhMAc01FYGqoJm+QMDiTtE85xIQuBwXzeLKRTCW0yyvIChh1TTH13YEJ7GOZjgxBMEaeZ6haxiB4GVfYagu3YdQZDXRr8uH693053oOQpNynL1rq5g98Z4YAFHOmcu332DvmichVIOr6Kvx3ckR6Cl+9u4u+vpkMEww6zw9/LVpsh2+hpXU0FPTVJgjfl07u3XsnRuHvoxcepT/ubhuIEwzIO+9RvLarqXjIuFfyuTi8p1Hqzevfjwcxv4GpnoAvFsCMI0AAAAASUVORK5CYII=');
}

[data-theme='dark'] .sidebar__logo--nextjs {
  background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 256 256' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' preserveAspectRatio='xMidYMid'%3E%3Cg%3E%3Cpath d='M119.616813,0.0688905149 C119.066276,0.118932037 117.314565,0.294077364 115.738025,0.419181169 C79.3775171,3.69690087 45.3192571,23.3131775 23.7481916,53.4631946 C11.7364614,70.2271045 4.05395894,89.2428829 1.15112414,109.384595 C0.12512219,116.415429 0,118.492153 0,128.025062 C0,137.557972 0.12512219,139.634696 1.15112414,146.665529 C8.10791789,194.730411 42.3163245,235.11392 88.7116325,250.076335 C97.0197458,252.753556 105.778299,254.580072 115.738025,255.680985 C119.616813,256.106338 136.383187,256.106338 140.261975,255.680985 C157.453763,253.779407 172.017986,249.525878 186.382014,242.194795 C188.584164,241.068861 189.00958,240.768612 188.709286,240.518404 C188.509091,240.36828 179.124927,227.782837 167.86393,212.570214 L147.393939,184.922273 L121.743891,146.965779 C107.630108,126.098464 96.0187683,109.034305 95.9186706,109.034305 C95.8185728,109.009284 95.7184751,125.873277 95.6684262,146.465363 C95.5933529,182.52028 95.5683284,183.971484 95.1178886,184.82219 C94.4672532,186.048207 93.9667644,186.548623 92.915738,187.099079 C92.114956,187.499411 91.4142717,187.574474 87.6355816,187.574474 L83.3063539,187.574474 L82.1552297,186.848872 C81.4044966,186.373477 80.8539589,185.747958 80.4785924,185.022356 L79.9530792,183.896422 L80.0031281,133.729796 L80.0782014,83.5381493 L80.8539589,82.5623397 C81.25435,82.0369037 82.1051808,81.3613431 82.7057674,81.0360732 C83.7317693,80.535658 84.1321603,80.4856165 88.4613881,80.4856165 C93.5663734,80.4856165 94.4172043,80.6857826 95.7434995,82.1369867 C96.1188661,82.5373189 110.007429,103.454675 126.623656,128.650581 C143.239883,153.846488 165.962072,188.250034 177.122972,205.139048 L197.392766,235.839522 L198.418768,235.163961 C207.502639,229.259062 217.112023,220.852086 224.719453,212.09482 C240.910264,193.504394 251.345455,170.835585 254.848876,146.665529 C255.874878,139.634696 256,137.557972 256,128.025062 C256,118.492153 255.874878,116.415429 254.848876,109.384595 C247.892082,61.3197135 213.683675,20.9362052 167.288368,5.97379012 C159.105376,3.32158945 150.396872,1.49507389 140.637341,0.394160408 C138.234995,0.143952798 121.693842,-0.131275573 119.616813,0.0688905149 L119.616813,0.0688905149 Z M172.017986,77.4831252 C173.219159,78.0836234 174.195112,79.2345784 174.545455,80.435575 C174.74565,81.0861148 174.795699,94.9976579 174.74565,126.348671 L174.670577,171.336 L166.73783,159.17591 L158.780059,147.01582 L158.780059,114.313685 C158.780059,93.1711423 158.880156,81.2862808 159.030303,80.7108033 C159.430694,79.3096407 160.306549,78.2087272 161.507722,77.5581875 C162.533724,77.0327515 162.909091,76.98271 166.837928,76.98271 C170.541544,76.98271 171.19218,77.0327515 172.017986,77.4831252 Z' fill='%23fff'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
}

[data-theme='light'] .sidebar__logo--nextjs {
  background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 256 256' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' preserveAspectRatio='xMidYMid'%3E%3Cg%3E%3Cpath d='M119.616813,0.0688905149 C119.066276,0.118932037 117.314565,0.294077364 115.738025,0.419181169 C79.3775171,3.69690087 45.3192571,23.3131775 23.7481916,53.4631946 C11.7364614,70.2271045 4.05395894,89.2428829 1.15112414,109.384595 C0.12512219,116.415429 0,118.492153 0,128.025062 C0,137.557972 0.12512219,139.634696 1.15112414,146.665529 C8.10791789,194.730411 42.3163245,235.11392 88.7116325,250.076335 C97.0197458,252.753556 105.778299,254.580072 115.738025,255.680985 C119.616813,256.106338 136.383187,256.106338 140.261975,255.680985 C157.453763,253.779407 172.017986,249.525878 186.382014,242.194795 C188.584164,241.068861 189.00958,240.768612 188.709286,240.518404 C188.509091,240.36828 179.124927,227.782837 167.86393,212.570214 L147.393939,184.922273 L121.743891,146.965779 C107.630108,126.098464 96.0187683,109.034305 95.9186706,109.034305 C95.8185728,109.009284 95.7184751,125.873277 95.6684262,146.465363 C95.5933529,182.52028 95.5683284,183.971484 95.1178886,184.82219 C94.4672532,186.048207 93.9667644,186.548623 92.915738,187.099079 C92.114956,187.499411 91.4142717,187.574474 87.6355816,187.574474 L83.3063539,187.574474 L82.1552297,186.848872 C81.4044966,186.373477 80.8539589,185.747958 80.4785924,185.022356 L79.9530792,183.896422 L80.0031281,133.729796 L80.0782014,83.5381493 L80.8539589,82.5623397 C81.25435,82.0369037 82.1051808,81.3613431 82.7057674,81.0360732 C83.7317693,80.535658 84.1321603,80.4856165 88.4613881,80.4856165 C93.5663734,80.4856165 94.4172043,80.6857826 95.7434995,82.1369867 C96.1188661,82.5373189 110.007429,103.454675 126.623656,128.650581 C143.239883,153.846488 165.962072,188.250034 177.122972,205.139048 L197.392766,235.839522 L198.418768,235.163961 C207.502639,229.259062 217.112023,220.852086 224.719453,212.09482 C240.910264,193.504394 251.345455,170.835585 254.848876,146.665529 C255.874878,139.634696 256,137.557972 256,128.025062 C256,118.492153 255.874878,116.415429 254.848876,109.384595 C247.892082,61.3197135 213.683675,20.9362052 167.288368,5.97379012 C159.105376,3.32158945 150.396872,1.49507389 140.637341,0.394160408 C138.234995,0.143952798 121.693842,-0.131275573 119.616813,0.0688905149 L119.616813,0.0688905149 Z M172.017986,77.4831252 C173.219159,78.0836234 174.195112,79.2345784 174.545455,80.435575 C174.74565,81.0861148 174.795699,94.9976579 174.74565,126.348671 L174.670577,171.336 L166.73783,159.17591 L158.780059,147.01582 L158.780059,114.313685 C158.780059,93.1711423 158.880156,81.2862808 159.030303,80.7108033 C159.430694,79.3096407 160.306549,78.2087272 161.507722,77.5581875 C162.533724,77.0327515 162.909091,76.98271 166.837928,76.98271 C170.541544,76.98271 171.19218,77.0327515 172.017986,77.4831252 Z' fill='%23000000'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
}

.image-margin {
  margin-top: 0.5rem;
}

/* End - Sidebar */

.w3m-qs__wrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 2rem;
  width: 100%;
  background: var(--ifm-color-emphasis-100);
  border-radius: 1rem;
  padding: 2.5rem 1.67rem;
  border: 1px solid var(--ifm-color-emphasis-300);
  isolation: isolate;
  z-index: 0;
  overflow: hidden;
}

.w3m-qs__wrapper:after {
  content: '';
  position: absolute;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  background: linear-gradient(to right, var(--ifm-color-emphasis-100), transparent);
}

.w3m-qs__text-container h2,
.w3m-qs__text-container p {
  margin: 0 !important;
}

.w3m-qs__text-container p {
  margin-top: 0.125rem !important;
}

.w3m-qs__code-block {
  margin-bottom: 0 !important;
}

.youtube-embed-container {
  margin: 2rem 0;
}

.youtube-embed-container iframe {
  aspect-ratio: 16 / 9;
  width: 100%;
}

@media screen and (max-width: 1320px) {
  .home__contribute--text {
    padding-right: 1.5rem;
  }
}

@media screen and (max-width: 996px) {
  nav[aria-label='Breadcrumbs'] {
    display: none;
  }
  .platform-tabs {
    width: 100%;
  }
  .platform-tabs .tabs__item--active:last-child {
    border-top-right-radius: 0;
  }
  .platform-tabs--items {
    border-top-right-radius: 0;
    border-top: none;
  }

  .home__contribute {
    flex-direction: column;
    align-items: start;
    height: auto;
  }
  .home__contribute img {
    height: 7rem;
    width: 7rem;
  }
  .home__contribute--text {
    padding-right: 2rem;
    max-width: 100%;
  }
  .docs-doc-id-readme .container {
    padding-left: 0.75rem;
  }
  .home__contribute a {
    margin-bottom: 1.25rem;
    margin-left: 1rem;
    margin-right: 1rem;
    margin-top: 0.25rem;
    width: calc(100% - 2rem);
  }
}

@media screen and (max-width: 660px) {
  .home__contribute--text {
    padding-top: 1.5rem;
    padding-bottom: 1.5rem;
  }
  .home__large-container {
    width: 100%;
  }
  .home__small-container {
    width: calc(50% - 0.375rem);
  }
  .cloud__wrapper a {
    min-width: 100%;
  }
  .cloud__wrapper a > svg {
    margin-left: auto;
  }
  .cloud__wrapper {
    padding: 1.5rem 1rem;
    padding-bottom: 1rem;
    flex-direction: column;
    align-items: flex-start;
  }
  .cloud__wrapper::before {
    content: '';
    position: absolute;
    inset: 0;
    z-index: 0;
    background: linear-gradient(90deg, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.2) 100%);
  }
  .cloud__text-container h2 {
    font-size: 1.25rem;
  }
  .cloud__text-container p {
    font-size: 0.875rem;
    line-height: 1.333;
  }

  .w3m-qs__wrapper {
    flex-direction: column;
    width: fit-content;
    padding: 2rem 1.5rem;
  }

  .w3m-qs__code-block {
    margin-top: 1rem !important;
  }
}
</file>

<file path="src/css/feedback.module.css">
.feedback {
  border-radius: 0.75rem;
  margin: 0 auto;
  margin-top: 3rem;
  width: clamp(20rem, 50%, 30rem);
  border: 1.5px solid var(--ifm-border-color);
  padding: 0.75rem 1.25rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.feedback__text {
  margin: 0;
}

.feedback__options {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.feedback__option,
.feedback__detailed__option {
  all: unset;
  border: 1.5px solid var(--ifm-border-color);
  padding: 0.25rem 0.75rem !important;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.375rem;
  font-weight: 500;
  cursor: pointer;
}

.feedback__option:hover {
  background: var(--ifm-hover-overlay);
  color: var(--ifm-article-text);
}

.feedback__option--yes:hover svg {
  color: var(--ifm-color-primary);
}

.feedback__option--no:hover svg {
  color: var(--ifm-color-warning);
}

.feedback__option svg {
  width: 0.875rem;
  height: 0.875rem;
  opacity: 0.75;
}

.feedback__detailed {
  padding: 0.25rem 0;
  width: 100%;
}

.feedback__detailed__text {
  margin-bottom: 0.75rem;
  font-size: 1rem;
  color: var(--ifm-feedback-heading);
}

.feedback__detailed__option {
  color: var(--ifm-color-gray-600);
  transition: all 0.2s ease-in-out;
}

.feedback__detailed__text--positive {
  margin: 0 auto;
  align-self: center;
  margin-bottom: 0;
  font-size: 1rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
}

.feedback__detailed__text--positive > svg {
  height: 1rem;
  width: 1rem;
  color: var(--ifm-color-primary);
}

.feedback__detailed__option:hover {
  background: var(--ifm-hover-overlay);
  color: var(--ifm-article-text);
}

.feedback__detailed__option:active {
  background: var(--ifm-color-gray-900);
  color: var(--ifm-article-text);
}

.feedback__detailed__options {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.feedback__detailed__other {
  margin-top: 0.5rem;
}

.feedback__detailed__option--other {
  background: var(--ifm-hover-overlay);
}

.feedback__detailed__other textarea {
  width: 100%;
  border: 1.5px solid var(--ifm-border-color);
  border-radius: 0.5rem;
  padding: 0.5rem 0.75rem;
  font-size: 1rem;
  background: transparent;
  resize: vertical;
  min-height: 5rem;
  max-height: 10rem;
  color: var(--ifm-color-gray-600);
  font-family: inherit;
  color: white;
  margin-top: 0.25rem;
}

.feedback__detailed__other button {
  all: unset;
  background: var(--ifm-hover-overlay);
  border: 1.5px solid var(--ifm-hover-overlay);
  padding: 0.25rem 0;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  text-align: center;
  width: 100%;
  margin-top: 0.5rem;
  margin-bottom: 0.125rem;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.feedback__detailed__other textarea:focus {
  outline: 1px solid var(--ifm-color-primary-darker) !important;
}

.feedback__detailed__other button:hover {
  background: var(--ifm-color-primary-dark);
}

.feedback__detailed__other button:focus {
  outline: 1px solid var(--ifm-color-primary-darker);
}

.feedback__detailed__other button:disabled {
  color: var(--ifm-color-gray-600);
  pointer-events: none;
}

@media screen and (max-width: 996px) {
  .feedback {
    width: 100%;
    margin-left: 0;
    margin-right: 0;
    margin-top: 2.75rem;
  }
}
</file>

<file path="src/css/fonts.css">
@font-face {
  font-family: 'ABC Diatype';
  src: url(./fonts/ABCDiatype-Regular.woff2) format('woff2');
  font-weight: normal;
  font-style: normal;
}

@font-face {
  font-family: 'ABC Diatype Bold';
  src: url(./fonts/ABCDiatype-Bold.woff2) format('woff2');
  font-weight: bold;
  font-style: normal;
}

@font-face {
  font-family: 'ABC Diatype Thin';
  src: url(./fonts/ABCDiatype-Thin.woff2) format('woff2');
  font-weight: lighter;
  font-style: normal;
}

@font-face {
  font-family: 'Office Code Pro';
  src: url(./fonts/OfficeCodePro-Regular.woff2) format('woff2');
  font-weight: normal;
  font-style: normal;
}
</file>

<file path="src/css/sidebar.css">
:root {
  /*Code block highlight*/
  --ifm-color-primary: #1c8aff;
  --ifm-link-hover-color: #006eff;
  --ifm-heading-font-family: 'ABC Diatype Bold', sans-serif;
  --ifm-heading-font-weight: bold;
  --ifm-font-family-base: 'ABC Diatype', sans-serif;
  --ifm-heading-color: #1d2d35;
  --ifm-color-gray-800: hsla(0, 0%, 100%, 0.1);
  --ifm-nav-bg-color: rgba(255, 255, 255, 0.4);
  --ifm-font-color-base: #29404b;
  --ifm-border-color: hsla(210, 3%, 54%, 0.5);
  --ifm-article-text: #000;
  --ifm-footer-title-color: #1d2d35;
  --ifm-table-alternate-bg-color: rgba(255, 255, 255, 0.8);
  --ifm-table-bg-color: rgba(235, 237, 243, 0.8);
  --ifm-box-bg-color: rgba(223, 227, 236, 0.4);
  --ifm-box-shadow-color: rgb(20, 20, 20);
  --ifm-pagination-bg-color: rgba(0, 0, 0, 0.02);
  --ifm-pagination-border-color: rgba(0, 0, 0, 0.1);
  --ifm-theme-code-border-color: rgba(0, 0, 0, 0.15);
  --ifm-close-color: white;
  --ifm-list-before-color: rgba(0, 0, 0, 0.4);
  --ifm-navbar-show-bg-color: rgba(235, 235, 235, 1);
  --ifm-background-color: #fff;
  --ifm-platform-tabs-color-active-border: rgb(28, 138, 255, 0.5);
  --ifm-platform-bg-color: rgb(28, 138, 255, 0.1);
  --ifm-cloud-button-bg-color: rgba(0, 55, 113, 0.1);
  --ifm-cloud-bg-primary: #0e0f11;
  --ifm-cloud-bg-secondary: var(--ifm-color-primary-darkest);
  --ifm-feedback-heading: var(--ifm-color-gray-900);
  --ifm-container-background-color: #fff;
}

html[data-theme='dark'] {
  --ifm-navbar-show-bg-color: rgba(20, 20, 20, 1);
  --ifm-list-before-color: rgba(255, 255, 255, 0.4);
  --ifm-close-color: black;
  --ifm-theme-code-border-color: rgba(255, 255, 255, 0.1);
  --ifm-pagination-border-color: rgba(255, 255, 255, 0.07);
  --ifm-pagination-bg-color: rgba(255, 255, 255, 0.04);
  --ifm-box-bg-color: var(--ifm-color-gray-800);
  --ifm-box-shadow-color: var(--ifm-color-gray-800);
  --ifm-pre-background: var(--prism-background-color);
  --ifm-table-bg-color: var(--ifm-color-gray-900);
  --ifm-table-alternate-bg-color: rgba(255, 255, 255, 0.05);
  --ifm-footer-title-color: var(--ifm-color-white);
  --ifm-color-primary: #66b0ff;
  --ifm-link-hover-color: #3396ff;
  --ifm-article-text: #fffff;
  --ifm-nav-bg-color: rgba(20, 20, 20, 0.4);
  --ifm-background-color: #141414;
  --ifm-heading-color: #ffffff;
  --ifm-font-color-base: #c9cfcf;
  --ifm-border-color: hsla(0, 0%, 100%, 0.1);
  --ifm-cloud-bg-secondary: rgb(16, 36, 69);
  --ifm-feedback-heading: var(--ifm-color-gray-500);
  --ifm-container-background-color: #141414;
}

html[data-theme='light'] {
  --ifm-blockquote-color: var(--ifm-color-gray-900);
}

[data-theme='light'] img[src$='#dark-mode-only'],
[data-theme='dark'] img[src$='#light-mode-only'] {
  display: none;
}

[data-theme='light'] .alert--secondary {
  --ifm-alert-border-color: var(--ifm-color-secondary-darkest);
  --ifm-alert-background-color-highlight: rgba(210, 212, 215, 0.2);
}

.custom-list__logo {
  position: absolute;
  list-style: none;
  margin: 0;
  padding: 0.8rem 0 0 1.25rem;
  z-index: 200;
  background-color: var(--ifm-background-color);
}

@media (max-width: 996px) {
  .navbar__brand {
    display: flex !important;
  }
}

.navbar__brand {
  font-weight: bold;
  color: var(--ifm-heading-color);
}

.navbar__brand span {
  text-transform: uppercase;
  font-family: 'Office Code Pro', monospace;
  font-weight: normal;
  color: var(--ifm-color-primary);
  margin-left: 5px;
}

.navbar__logo {
  display: flex;
  align-items: center;
}

.navbar__logo img {
  width: 30px;
  height: 18px;
}
.menu__list-item-collapsible {
  margin-left: -24px;
  padding-left: 24px;
}
</file>

<file path="src/theme/Admonition/index.js">
import React from 'react'
import clsx from 'clsx'
import { ThemeClassNames } from '@docusaurus/theme-common'
import Translate from '@docusaurus/Translate'
import styles from './styles.module.css'
function NoteIcon() {
  return (
    <svg viewBox="0 0 14 16">
      <path
        fillRule="evenodd"
        d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"
      />
    </svg>
  )
}
function TipIcon() {
  return (
    <svg viewBox="0 0 24 24">
      <path
        d="M10.940 0.699 C 9.369 0.917,7.922 1.537,6.720 2.508 C 6.327 2.826,5.593 3.585,5.311 3.967 C 4.439 5.146,3.904 6.455,3.700 7.907 C 3.623 8.455,3.623 9.506,3.700 10.094 C 3.822 11.023,4.109 11.934,4.559 12.820 C 4.861 13.414,5.052 13.710,5.461 14.220 C 6.067 14.976,6.754 15.585,7.603 16.121 C 8.186 16.489,8.520 16.811,8.703 17.180 C 8.825 17.426,8.846 17.513,8.874 17.902 C 8.911 18.421,8.997 18.619,9.245 18.758 C 9.544 18.926,10.060 18.905,10.328 18.714 C 10.605 18.517,10.701 17.996,10.584 17.324 C 10.396 16.251,9.812 15.478,8.579 14.670 C 7.576 14.012,7.037 13.497,6.493 12.673 C 5.448 11.089,5.126 9.220,5.583 7.392 C 6.068 5.454,7.313 3.928,9.133 3.040 C 9.678 2.774,10.065 2.640,10.657 2.510 C 11.009 2.434,11.180 2.422,12.000 2.422 C 12.820 2.422,12.991 2.434,13.343 2.510 C 13.935 2.640,14.322 2.774,14.864 3.039 C 16.042 3.613,17.030 4.501,17.648 5.540 C 18.517 6.999,18.818 8.691,18.495 10.300 C 18.340 11.077,17.962 11.983,17.507 12.673 C 16.963 13.497,16.424 14.012,15.421 14.670 C 14.188 15.478,13.604 16.251,13.416 17.324 C 13.300 17.993,13.395 18.517,13.669 18.712 C 13.991 18.941,14.557 18.932,14.840 18.694 C 15.037 18.528,15.091 18.380,15.126 17.904 C 15.152 17.546,15.179 17.423,15.278 17.212 C 15.446 16.853,15.797 16.502,16.314 16.176 C 18.471 14.818,19.811 12.849,20.262 10.380 C 20.365 9.817,20.386 8.518,20.302 7.933 C 20.084 6.414,19.548 5.107,18.665 3.940 C 18.361 3.537,17.673 2.826,17.280 2.509 C 16.068 1.528,14.609 0.907,13.025 0.698 C 12.500 0.629,11.445 0.629,10.940 0.699 M10.083 11.750 C 9.881 11.853,9.732 12.066,9.658 12.355 C 9.569 12.705,9.605 12.921,9.786 13.121 C 9.954 13.307,10.191 13.403,10.730 13.504 L 11.120 13.576 11.120 15.861 C 11.120 18.367,11.126 18.436,11.354 18.654 C 11.482 18.777,11.776 18.880,12.000 18.880 C 12.224 18.880,12.518 18.777,12.646 18.654 C 12.874 18.436,12.880 18.367,12.880 15.861 L 12.880 13.576 13.270 13.504 C 13.809 13.403,14.046 13.307,14.214 13.121 C 14.395 12.921,14.431 12.705,14.342 12.355 C 14.234 11.931,13.964 11.680,13.616 11.680 C 13.526 11.680,13.274 11.719,13.056 11.767 C 12.738 11.837,12.530 11.854,12.000 11.854 C 11.470 11.854,11.262 11.837,10.944 11.767 C 10.464 11.662,10.264 11.658,10.083 11.750 M9.360 19.205 C 9.089 19.313,8.915 19.616,8.888 20.029 C 8.866 20.370,8.913 20.511,9.105 20.679 C 9.274 20.827,9.503 20.893,10.240 21.007 C 10.742 21.084,10.979 21.096,12.000 21.096 C 13.021 21.096,13.258 21.084,13.760 21.007 C 14.499 20.893,14.726 20.827,14.897 20.677 C 15.076 20.520,15.135 20.334,15.111 20.004 C 15.079 19.563,14.850 19.236,14.529 19.175 C 14.436 19.157,14.140 19.181,13.745 19.238 C 12.565 19.408,11.367 19.410,10.293 19.242 C 9.716 19.152,9.512 19.144,9.360 19.205 M10.080 21.605 C 9.834 21.703,9.695 21.921,9.645 22.289 C 9.582 22.746,9.721 23.050,10.064 23.205 C 10.515 23.408,13.434 23.417,13.912 23.218 C 14.233 23.083,14.378 22.838,14.368 22.444 C 14.356 21.979,14.137 21.637,13.814 21.576 C 13.732 21.561,13.268 21.570,12.783 21.597 C 12.136 21.632,11.740 21.634,11.300 21.603 C 10.567 21.552,10.212 21.552,10.080 21.605 "
        fill-rule="evenodd"
      ></path>
    </svg>
  )
}
function DangerIcon() {
  return (
    <svg viewBox="0 0 12 16">
      <path
        fillRule="evenodd"
        d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"
      />
    </svg>
  )
}
function InfoIcon() {
  return (
    <svg viewBox="0 0 14 16">
      <path
        fillRule="evenodd"
        d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"
      />
    </svg>
  )
}
function CautionIcon() {
  return (
    <svg viewBox="0 0 16 16">
      <path
        fillRule="evenodd"
        d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"
      />
    </svg>
  )
}
// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style
const AdmonitionConfigs = {
  note: {
    infimaClassName: 'secondary',
    iconComponent: NoteIcon,
    label: (
      <Translate
        id="theme.admonition.note"
        description="The default label used for the Note admonition (:::note)"
      >
        note
      </Translate>
    )
  },
  tip: {
    infimaClassName: 'success',
    iconComponent: TipIcon,
    label: (
      <Translate
        id="theme.admonition.tip"
        description="The default label used for the Tip admonition (:::tip)"
      >
        tip
      </Translate>
    )
  },
  danger: {
    infimaClassName: 'danger',
    iconComponent: DangerIcon,
    label: (
      <Translate
        id="theme.admonition.danger"
        description="The default label used for the Danger admonition (:::danger)"
      >
        danger
      </Translate>
    )
  },
  info: {
    infimaClassName: 'info',
    iconComponent: InfoIcon,
    label: (
      <Translate
        id="theme.admonition.info"
        description="The default label used for the Info admonition (:::info)"
      >
        info
      </Translate>
    )
  },
  caution: {
    infimaClassName: 'warning',
    iconComponent: CautionIcon,
    label: (
      <Translate
        id="theme.admonition.caution"
        description="The default label used for the Caution admonition (:::caution)"
      >
        caution
      </Translate>
    )
  }
}
// Legacy aliases, undocumented but kept for retro-compatibility
const aliases = {
  secondary: 'note',
  important: 'info',
  success: 'tip',
  warning: 'danger'
}
function getAdmonitionConfig(unsafeType) {
  const type = aliases[unsafeType] ?? unsafeType
  const config = AdmonitionConfigs[type]
  if (config) {
    return config
  }
  console.warn(`No admonition config found for admonition type "${type}". Using Info as fallback.`)
  return AdmonitionConfigs.info
}
// Workaround because it's difficult in MDX v1 to provide a MDX title as props
// See https://github.com/facebook/docusaurus/pull/7152#issuecomment-1145779682
function extractMDXAdmonitionTitle(children) {
  const items = React.Children.toArray(children)
  const mdxAdmonitionTitle = items.find(
    item => React.isValidElement(item) && item.props?.mdxType === 'mdxAdmonitionTitle'
  )
  const rest = <>{items.filter(item => item !== mdxAdmonitionTitle)}</>
  return {
    mdxAdmonitionTitle,
    rest
  }
}
function processAdmonitionProps(props) {
  const { mdxAdmonitionTitle, rest } = extractMDXAdmonitionTitle(props.children)
  return {
    ...props,
    title: props.title ?? mdxAdmonitionTitle,
    children: rest
  }
}
export default function Admonition(props) {
  const { children, type, title, icon: iconProp } = processAdmonitionProps(props)
  const typeConfig = getAdmonitionConfig(type)
  const titleLabel = title ?? typeConfig.label
  const { iconComponent: IconComponent } = typeConfig
  const icon = iconProp ?? <IconComponent />
  return (
    <div
      className={clsx(
        ThemeClassNames.common.admonition,
        ThemeClassNames.common.admonitionType(props.type),
        'alert',
        `alert--${typeConfig.infimaClassName}`,
        styles.admonition
      )}
    >
      <div className={styles.admonitionHeading}>
        <span className={styles.admonitionIcon}>{icon}</span>
        <span className={styles.admonitionTitle}>{titleLabel}</span>
      </div>
      <div className={styles.admonitionContent}>{children}</div>
    </div>
  )
}
</file>

<file path="src/theme/Admonition/styles.module.css">
.admonition {
  margin-bottom: 1em;
  overflow: hidden;
  border: none;
  padding: 0;
  --ifm-alert-padding-vertical: 0.75rem;
  --ifm-alert-padding-horizontal: 0.75rem;
  border-radius: 0.75rem;
}

.admonitionHeading {
  font: var(--ifm-heading-font-weight) var(--ifm-h5-font-size) / var(--ifm-heading-line-height)
    var(--ifm-heading-font-family);
  text-transform: uppercase;
  border: var(--ifm-alert-border-width) solid var(--ifm-alert-border-color);
  padding: 0.5rem 0.75rem;
  background: var(--ifm-alert-border-color);
  color: var(--ifm-alert-background-color);
  display: flex;
  align-items: center;
  box-shadow:
    rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,
    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,
    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;
}

.admonitionHeading code {
  text-transform: none;
}

.admonitionIcon {
  display: flex;
  margin-right: 0.25em;
}

.admonitionTitle {
  padding-top: 0.105rem;
  font-size: 0.75rem;
}

.admonitionIcon svg {
  display: inline-block;
  height: 1em;
  width: 1em;
  fill: var(--ifm-alert-background-color);
}

.admonitionContent {
  padding: var(--ifm-alert-padding-vertical) var(--ifm-alert-padding-horizontal);
}

.admonitionContent > :last-child {
  margin-bottom: 0;
}
</file>

<file path="src/theme/DocBreadcrumbs/Items/Home/index.js">
import React from 'react'
import Link from '@docusaurus/Link'
import useBaseUrl from '@docusaurus/useBaseUrl'
import { translate } from '@docusaurus/Translate'
import IconHome from '@theme/Icon/Home'
import styles from './styles.module.css'
export default function HomeBreadcrumbItem() {
  const homeHref = useBaseUrl('/')
  return (
    <li className="breadcrumbs__item">
      <Link
        aria-label={translate({
          id: 'theme.docs.breadcrumbs.home',
          message: 'Home page',
          description: 'The ARIA label for the home page in the breadcrumbs'
        })}
        className="breadcrumbs__link"
        href={homeHref}
      >
        <IconHome className={styles.breadcrumbHomeIcon} />
      </Link>
    </li>
  )
}
</file>

<file path="src/theme/DocBreadcrumbs/Items/Home/styles.module.css">
.breadcrumbHomeIcon {
  position: relative;
  top: 1px;
  vertical-align: top;
  height: 1.1rem;
  width: 1.1rem;
}
</file>

<file path="src/theme/DocBreadcrumbs/index.js">
import React from 'react'
import clsx from 'clsx'
import { ThemeClassNames } from '@docusaurus/theme-common'
import { useSidebarBreadcrumbs, useHomePageRoute } from '@docusaurus/theme-common/internal'
import Link from '@docusaurus/Link'
import { translate } from '@docusaurus/Translate'
import HomeBreadcrumbItem from '@theme/DocBreadcrumbs/Items/Home'
import styles from './styles.module.css'
// TODO move to design system folder
function BreadcrumbsItemLink({ children, href, isLast }) {
  const className = 'breadcrumbs__link'
  if (isLast) {
    return (
      <span className={className} itemProp="name">
        {children}
      </span>
    )
  }
  return href ? (
    <Link className={className} href={href} itemProp="item">
      <span itemProp="name">{children}</span>
    </Link>
  ) : (
    // TODO Google search console doesn't like breadcrumb items without href.
    // The schema doesn't seem to require `id` for each `item`, although Google
    // insist to infer one, even if it's invalid. Removing `itemProp="item
    // name"` for now, since I don't know how to properly fix it.
    // See https://github.com/facebook/docusaurus/issues/7241
    <span className={className}>{children}</span>
  )
}
// TODO move to design system folder
function BreadcrumbsItem({ children, active, index, addMicrodata }) {
  return (
    <li
      {...(addMicrodata && {
        itemScope: true,
        itemProp: 'itemListElement',
        itemType: 'https://schema.org/ListItem'
      })}
      className={clsx('breadcrumbs__item', {
        'breadcrumbs__item--active': active
      })}
    >
      {children}
      <meta itemProp="position" content={String(index + 1)} />
    </li>
  )
}
export default function DocBreadcrumbs() {
  if (typeof window === 'undefined') {
    return null
  }
  const breadcrumbs = useSidebarBreadcrumbs()
  const homePageRoute = useHomePageRoute()
  if (!breadcrumbs) {
    return null
  }
  const revisedBreadcrumb = breadcrumbs.filter(item => item.className !== 'menu_outer_list')
  return (
    <nav
      className={clsx(ThemeClassNames.docs.docBreadcrumbs, styles.breadcrumbsContainer)}
      aria-label={translate({
        id: 'theme.docs.breadcrumbs.navAriaLabel',
        message: 'Breadcrumbs',
        description: 'The ARIA label for the breadcrumbs'
      })}
    >
      <ul className="breadcrumbs" itemScope itemType="https://schema.org/BreadcrumbList">
        {homePageRoute && <HomeBreadcrumbItem />}
        {revisedBreadcrumb.map((item, idx) => {
          const isLast = idx === revisedBreadcrumb.length - 1
          return (
            <BreadcrumbsItem key={idx} active={isLast} index={idx} addMicrodata={!!item.href}>
              <BreadcrumbsItemLink href={item.href} isLast={isLast}>
                {item.label}
              </BreadcrumbsItemLink>
            </BreadcrumbsItem>
          )
        })}
      </ul>
    </nav>
  )
}
</file>

<file path="src/theme/DocBreadcrumbs/styles.module.css">
.breadcrumbsContainer {
  --ifm-breadcrumb-size-multiplier: 0.8;
  margin-bottom: 0.8rem;
}
</file>

<file path="src/theme/DocItem/Footer/index.js">
import React from 'react'
import clsx from 'clsx'
import { ThemeClassNames } from '@docusaurus/theme-common'
import { useDoc } from '@docusaurus/theme-common/internal'
import LastUpdated from '@theme/LastUpdated'
import EditThisPage from '@theme/EditThisPage'
import TagsListInline from '@theme/TagsListInline'
import styles from './styles.module.css'
function TagsRow(props) {
  return (
    <div className={clsx(ThemeClassNames.docs.docFooterTagsRow, 'row margin-bottom--sm')}>
      <div className="col">
        <TagsListInline {...props} />
      </div>
    </div>
  )
}
function EditMetaRow({ editUrl, lastUpdatedAt, lastUpdatedBy, formattedLastUpdatedAt }) {
  return (
    <div className={clsx(ThemeClassNames.docs.docFooterEditMetaRow, 'row')}>
      <div className="col">{editUrl && <EditThisPage editUrl={editUrl} />}</div>

      <div className={clsx('col', styles.lastUpdated)}>
        {(lastUpdatedAt || lastUpdatedBy) && (
          <LastUpdated
            lastUpdatedAt={lastUpdatedAt}
            formattedLastUpdatedAt={formattedLastUpdatedAt}
            lastUpdatedBy={lastUpdatedBy}
          />
        )}
      </div>
    </div>
  )
}
export default function DocItemFooter() {
  const { metadata } = useDoc()
  const { editUrl, lastUpdatedAt, formattedLastUpdatedAt, lastUpdatedBy, tags } = metadata
  const canDisplayTagsRow = tags.length > 0
  const canDisplayEditMetaRow = !!(editUrl || lastUpdatedAt || lastUpdatedBy)
  const canDisplayFooter = canDisplayTagsRow || canDisplayEditMetaRow
  if (!canDisplayFooter) {
    return null
  }
  return (
    <footer className={clsx(ThemeClassNames.docs.docFooter, 'docusaurus-mt-lg')}>
      {canDisplayTagsRow && <TagsRow tags={tags} />}
      {canDisplayEditMetaRow && (
        <EditMetaRow
          editUrl={editUrl}
          lastUpdatedAt={lastUpdatedAt}
          lastUpdatedBy={lastUpdatedBy}
          formattedLastUpdatedAt={formattedLastUpdatedAt}
        />
      )}
    </footer>
  )
}
</file>

<file path="src/theme/DocItem/Footer/styles.module.css">
.lastUpdated {
  margin-top: 0.2rem;
  font-style: italic;
  font-size: smaller;
}

@media (min-width: 997px) {
  .lastUpdated {
    text-align: right;
  }
}
</file>

<file path="src/theme/DocSidebar/constants.js">
export const appKit_environments = [
  'react',
  'next',
  'vue',
  'javascript',
  'react-native',
  'flutter',
  'android',
  'ios',
  'unity'
]
export const walletKit_environments = ['web', 'ios', 'android', 'flutter', 'react-native', 'c-sharp']
</file>

<file path="src/theme/DocSidebar/index.js">
import React from 'react'
import DocSidebar from '@theme-original/DocSidebar'
import Dropdown from '../Dropdown'
import '../../css/sidebar.css'
import { useLocation } from 'react-router-dom'
import { appKit_environments, walletKit_environments } from './constants'

export default function DocSidebarWrapper(props) {
  return (
    <>
      <li className="custom-list__logo">
        <a className="navbar__brand" href="/">
          <div className="navbar__logo menu__list-item-collapsible">
            <img src="/img/walletconnect-logo-white.svg#dark-mode-only" alt="WalletConnect Logo" />
            <img src="/img/walletconnect-logo-black.svg#light-mode-only" alt="WalletConnect Logo" />
          </div>
          WalletConnect<span>Docs</span>
        </a>
      </li>
      <FrameworksMenu />
      <DocSidebar {...props} />
    </>
  )
}

export const FrameworksMenu = () => {
  const location = useLocation()

  if (
    location.pathname.includes('/appkit/overview') ||
    location.pathname.includes('/appkit/features') ||
    location.pathname.includes('/appkit/migration') ||
    location.pathname.includes('/appkit/upgrade') ||
    location.pathname.includes('/walletkit/overview') ||
    location.pathname.includes('/walletkit/features') ||
    location.pathname.includes('/walletkit/best-practices')
  ) {
    return
  }

  if (location.pathname.includes('/appkit/')) {
    return (
      <Dropdown
        list={appKit_environments}
      />
    )
  }

  if (location.pathname.includes('/walletkit/')) {
    return (
      <Dropdown
        list={walletKit_environments}
        isWalletKit
      />
    )
  }
}
</file>

<file path="src/theme/Dropdown/utils/index.js">
export function parseEnvironment(env) {
  if (!env) return ''
  if(env === 'c-sharp'){
    return "C#"
  }
  if (env === 'ios') {
    return 'iOS'
  }
  if(env === 'javascript'){
    return "JavaScript"
  }
  if (env.includes('-')) {
    const env_array = env.split('-')
    return env_array
      .map(item => {
        if (item === 'ios') {
          return 'iOS'
        }
        if(item === 'javascript'){
          return "JavaScript"
        }
        return capitalize(item)
      })
      .join(' ')
  }
  return capitalize(env)
}

function capitalize(item) {
  return item.charAt(0).toUpperCase() + item.slice(1)
}

export function isIconWhite(icon){
  if(icon === 'ios' || icon === 'next' || icon === 'unity') return true
}

export function getEnvFromCurrentPath(list){
  if(location.pathname.includes('react-native')){
    return 'react-native'
  }else{
    return list.find(item => location.pathname.includes(item))
  }
}
</file>

<file path="src/theme/Dropdown/icons.js">
import react from '../../../static/assets/home/reactLogo.png'
import next from '../../../static/assets/home/nextjsLogo.png'
import vue from '../../../static/assets/home/vueLogo.png'
import android from '../../../static/assets/home/androidLogo.png'
import ios from '../../../static/assets/home/iosLogo.png'
import reactNative from '../../../static/assets/home/rnLogo.png'
import flutter from '../../../static/assets/home/flutterLogo.png'
import unity from '../../../static/assets/home/unityLogo.png'
import csharp from '../../../static/assets/home/csharpLogo.png'
import javascript from '../../../static/assets/home/javascriptLogo.png'

export const env_icons = {
  react,
  next,
  vue,
  javascript,
  "react-native": reactNative,
  flutter,
  android,
  ios,
  unity,
  "c-sharp":csharp,
  web: javascript
}
</file>

<file path="src/theme/Dropdown/index.js">
import { useState, useRef, useEffect } from 'react'
import { useLocation, useHistory } from 'react-router-dom'
import s from './styles.module.css'
import { getEnvFromCurrentPath, isIconWhite, parseEnvironment } from './utils'
import { env_icons } from './icons'

/**
 * This Dropdown Menu is meant to be for a list of Frameworks and Programming languages.
 *  The selected item will mutate the current URL
 */
export default function Dropdown({ list, isWalletKit }) {
  const location = useLocation()
  const history = useHistory()

  const [selected, setSelected] = useState('')
  const [isOpen, setIsOpen] = useState(false)

  if (!selected) {
  if(typeof window === 'undefined') return true
    const environment = getEnvFromCurrentPath(list)
    if (!environment) {
      throw Error("The current path doesn't contain any environment.")
    }
    setSelected(environment)
  }

  function handleItem(new_environment) {
    const current_environment = getEnvFromCurrentPath(list)
    if (!current_environment) {
      throw Error("The current path doesn't contain any environment.")
    }
    setSelected(new_environment)
    setIsOpen(false)
    const new_path =
      location.pathname.slice(0, location.pathname.indexOf(current_environment)) +
      new_environment +
      `${isWalletKit ? '/installation' : '/core/installation'}`

    history.push(new_path)
  }

  const menuRef = useRef(null)

  useEffect(() => {
    function handleClickOutside(event) {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [menuRef])

  return (
    <div className={s.container} ref={menuRef}>
      <div className={s.dropdownButton} onClick={() => setIsOpen(p => !p)}>
        <img className={`${s.envIcon} ${isIconWhite(selected) && s.invertOnLightMode}`} src={env_icons[selected]} alt={selected} />
        {parseEnvironment(selected)}
        <span className={`${s.dropdownArrow} ${isOpen && s.rotateArrow}`} />
      </div>
      {isOpen && <div className={`${s.dropdownContainer} ${isWalletKit && s.walletKit}`}>
        {list
          .filter(i => i !== selected)
          .map(item => (
            <span className={s.item} onClick={() => handleItem(item)}>
              <img className={`${s.envIcon} ${isIconWhite(item) && s.invertOnLightMode}`} src={env_icons[item]} alt={item} />
              {parseEnvironment(item)}
            </span>
          ))}
      </div>}
    </div>
  )
}
</file>

<file path="src/theme/Dropdown/styles.module.css">
.container {
  position: relative;
  padding-top: 60px !important;
  padding-left: 20px;
  display: flex;
  align-items: center;
}

.dropdownContainer {
  position: absolute;
  transform: translateY(50%);
  top: -28%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 5px;
  border-radius: 0.5rem;
  border: 1px solid #202020;
  padding: 0.75rem 1.25rem;
  border-color: var(--ifm-pagination-nav-color-hover);
  background-color: var(--ifm-container-background-color);
  color: var(--ifm-article-text);
  width: 11rem;
  z-index: 100;
}

.walletKit{
  top: 20%;
}

.item {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 11px;
}

.item:hover {
  color: var(--ifm-link-hover-color);
}

.kill {
  display: none;
}

.dropdownButton {
  border-radius: 0.5rem;
  border: 1.5px solid var(--ifm-border-color);
  padding: 0.5rem 1.25rem;
  max-width: 13rem;
  min-width: 11rem;
  display: flex;
  align-items: center;
  gap: 11px;
  justify-content: space-between;
  background-color: var(--ifm-container-background-color);
  color: var(--ifm-link-hover-color);
  position: relative;
  overflow: hidden;
  cursor: pointer;

  background-size: contain;
}

.dropdownArrow {
  content: '';
  margin-left: auto;
  min-width: 1.25rem;
  background: var(--ifm-menu-link-sublist-icon) 50% / 1.5rem 1.5rem;
  filter: var(--ifm-menu-link-sublist-icon-filter);
  height: 1.25rem;
  width: 1.25rem;
  transform: rotate(90deg);
}

.rotateArrow {
  transform: rotate(180deg);
}

[data-theme='light'] .dropdownButton__img-container {
  border: 2px solid var(--ifm-border-color);
}

.dropdownButton img {
  border: none;
  height: 1.25rem;
  width: 1.25rem;
  border-radius: 0;
}

[data-theme='light'] .invertOnLightMode {
  filter: invert(1);
}

.envIcon{
  border: none;
  height: 1.25rem;
  width: 1.25rem;
  border-radius: 0;
}

@media (max-width: 996px){
  .container{
    padding-top: 0 !important;
    padding-bottom: 10px;
  }
  .dropdownContainer{
    background-color: var(--ifm-navbar-background-color);
    top: -160%;
  }
  .dropdownButton{
    background-color: var(--ifm-navbar-background-color);
  }
    
  .walletKit{
    top: -70%;
  }
}
</file>

<file path="src/theme/Navbar/ColorModeToggle/index.js">
import React from 'react'
import { useColorMode, useThemeConfig } from '@docusaurus/theme-common'
import ColorModeToggle from '@theme/ColorModeToggle'
import styles from './styles.module.css'
export default function NavbarColorModeToggle({ className }) {
  const navbarStyle = useThemeConfig().navbar.style
  const disabled = useThemeConfig().colorMode.disableSwitch
  const { colorMode, setColorMode } = useColorMode()
  if (disabled) {
    return null
  }
  return (
    <ColorModeToggle
      className={className}
      buttonClassName={navbarStyle === 'dark' ? styles.darkNavbarColorModeToggle : undefined}
      value={colorMode}
      onChange={setColorMode}
    />
  )
}
</file>

<file path="src/theme/Navbar/ColorModeToggle/styles.module.css">
.darkNavbarColorModeToggle:hover {
  background: var(--ifm-color-gray-800);
}
</file>

<file path="src/theme/Navbar/Content/index.js">
import React from 'react'
import { useThemeConfig, ErrorCauseBoundary } from '@docusaurus/theme-common'
import { splitNavbarItems, useNavbarMobileSidebar } from '@docusaurus/theme-common/internal'
import NavbarItem from '@theme/NavbarItem'
import NavbarColorModeToggle from '@theme/Navbar/ColorModeToggle'
import SearchBar from '@theme/SearchBar'
import NavbarMobileSidebarToggle from '@theme/Navbar/MobileSidebar/Toggle'
import NavbarLogo from '@theme/Navbar/Logo'
import NavbarSearch from '@theme/Navbar/Search'
import DocBreadcrumbs from '@theme/DocBreadcrumbs'
import { DocsSidebarProvider } from '@docusaurus/theme-common/internal'
import styles from './styles.module.css'

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback
    }

    return this.props.children
  }
}

function useNavbarItems() {
  // TODO temporary casting until ThemeConfig type is improved
  return useThemeConfig().navbar.items
}
function NavbarItems({ items }) {
  return (
    <>
      {items.map((item, i) => (
        <ErrorCauseBoundary
          key={i}
          onError={error =>
            new Error(
              `A theme navbar item failed to render.
Please double-check the following navbar item (themeConfig.navbar.items) of your Docusaurus config:
${JSON.stringify(item, null, 2)}`,
              { cause: error }
            )
          }
        >
          <NavbarItem {...item} />
        </ErrorCauseBoundary>
      ))}
    </>
  )
}
function NavbarContentLayout({ left, right }) {
  return (
    <div className="navbar__inner">
      <div className="navbar__items">
        <ErrorBoundary fallback={<a href="/">üè† Back to home</a>}>
          <DocBreadcrumbs />
        </ErrorBoundary>
        {left}
      </div>
      <div className="navbar__items navbar__items--right">{right}</div>
    </div>
  )
}
export default function NavbarContent() {
  const mobileSidebar = useNavbarMobileSidebar()
  const items = useNavbarItems()
  const [leftItems, rightItems] = splitNavbarItems(items)
  const searchBarItem = items.find(item => item.type === 'search')
  return (
    <NavbarContentLayout
      left={
        // TODO stop hardcoding items?
        <>
          {!mobileSidebar.disabled && <NavbarMobileSidebarToggle />}
          <NavbarLogo />
          <NavbarItems items={leftItems} />
        </>
      }
      right={
        // TODO stop hardcoding items?
        // Ask the user to add the respective navbar items => more flexible
        <>
          <NavbarItems items={rightItems} />
          <NavbarColorModeToggle className={styles.colorModeToggle} />
          {!searchBarItem && (
            <NavbarSearch>
              <SearchBar />
            </NavbarSearch>
          )}
        </>
      }
    />
  )
}
</file>

<file path="src/theme/Navbar/Content/styles.module.css">
/*
Hide color mode toggle in small viewports
 */
@media (max-width: 996px) {
  .colorModeToggle {
    display: none;
  }
}
</file>

<file path="src/theme/Navbar/Layout/index.js">
import React from 'react'
import clsx from 'clsx'
import { useThemeConfig } from '@docusaurus/theme-common'
import { useHideableNavbar, useNavbarMobileSidebar } from '@docusaurus/theme-common/internal'
import { translate } from '@docusaurus/Translate'
import NavbarMobileSidebar from '@theme/Navbar/MobileSidebar'
import styles from './styles.module.css'
function NavbarBackdrop(props) {
  return (
    <div
      role="presentation"
      {...props}
      className={clsx('navbar-sidebar__backdrop', props.className)}
    />
  )
}
export default function NavbarLayout({ children }) {
  const {
    navbar: { hideOnScroll, style }
  } = useThemeConfig()
  const mobileSidebar = useNavbarMobileSidebar()
  const { navbarRef, isNavbarVisible } = useHideableNavbar(hideOnScroll)
  return (
    <nav
      ref={navbarRef}
      aria-label={translate({
        id: 'theme.NavBar.navAriaLabel',
        message: 'Main',
        description: 'The ARIA label for the main navigation'
      })}
      className={clsx(
        'navbar',
        'navbar--fixed-top',
        hideOnScroll && [styles.navbarHideable, !isNavbarVisible && styles.navbarHidden],
        {
          'navbar--dark': style === 'dark',
          'navbar--primary': style === 'primary',
          'navbar-sidebar--show': mobileSidebar.shown
        }
      )}
    >
      {children}
      <NavbarBackdrop onClick={mobileSidebar.toggle} />
      <NavbarMobileSidebar />
    </nav>
  )
}
</file>

<file path="src/theme/Navbar/Layout/styles.module.css">
.navbarHideable {
  transition: transform var(--ifm-transition-fast) ease;
}

.navbarHidden {
  transform: translate3d(0, calc(-100% - 2px), 0);
}
</file>

<file path="src/theme/Navbar/Logo/index.js">
import React from 'react'
import Logo from '@theme/Logo'
export default function NavbarLogo() {
  return (
    <Logo
      className="navbar__brand"
      imageClassName="navbar__logo"
      titleClassName="navbar__title text--truncate"
    />
  )
}
</file>

<file path="src/theme/Navbar/MobileSidebar/Header/index.js">
import React from 'react'
import { useNavbarMobileSidebar } from '@docusaurus/theme-common/internal'
import { translate } from '@docusaurus/Translate'
import NavbarColorModeToggle from '@theme/Navbar/ColorModeToggle'
import IconClose from '@theme/Icon/Close'
import NavbarLogo from '@theme/Navbar/Logo'
function CloseButton() {
  const mobileSidebar = useNavbarMobileSidebar()
  return (
    <button
      type="button"
      aria-label={translate({
        id: 'theme.docs.sidebar.closeSidebarButtonAriaLabel',
        message: 'Close navigation bar',
        description: 'The ARIA label for close button of mobile sidebar'
      })}
      className="clean-btn navbar-sidebar__close"
      onClick={() => mobileSidebar.toggle()}
    >
      <IconClose color="var(--ifm-color-emphasis-600)" />
    </button>
  )
}
export default function NavbarMobileSidebarHeader() {
  return (
    <div className="navbar-sidebar__brand">
      <NavbarLogo />
      <NavbarColorModeToggle className="margin-right--md" />
      <CloseButton />
    </div>
  )
}
</file>

<file path="src/theme/Navbar/MobileSidebar/Layout/index.js">
import React from 'react'
import clsx from 'clsx'
import { useNavbarSecondaryMenu } from '@docusaurus/theme-common/internal'
export default function NavbarMobileSidebarLayout({ header, primaryMenu, secondaryMenu }) {
  const { shown: secondaryMenuShown } = useNavbarSecondaryMenu()
  return (
    <div className="navbar-sidebar">
      {header}
      <div
        className={clsx('navbar-sidebar__items', {
          'navbar-sidebar__items--show-secondary': secondaryMenuShown
        })}
      >
        <div className="navbar-sidebar__item menu">{primaryMenu}</div>
        <div className="navbar-sidebar__item menu">{secondaryMenu}</div>
      </div>
    </div>
  )
}
</file>

<file path="src/theme/Navbar/MobileSidebar/SecondaryMenu/index.js">
import React from 'react'
import { useNavbarSecondaryMenu } from '@docusaurus/theme-common/internal'
import { FrameworksMenu } from '@site/src/theme/DocSidebar'

export default function NavbarMobileSidebarSecondaryMenu() {
  const secondaryMenu = useNavbarSecondaryMenu()
  return (
    <>
      <FrameworksMenu />
      {secondaryMenu.content}
    </>
  )
}
</file>

<file path="src/theme/Navbar/MobileSidebar/Toggle/index.js">
import React from 'react'
import { useNavbarMobileSidebar } from '@docusaurus/theme-common/internal'
import { translate } from '@docusaurus/Translate'
import IconMenu from '@theme/Icon/Menu'
export default function MobileSidebarToggle() {
  const { toggle, shown } = useNavbarMobileSidebar()
  return (
    <button
      onClick={toggle}
      aria-label={translate({
        id: 'theme.docs.sidebar.toggleSidebarButtonAriaLabel',
        message: 'Toggle navigation bar',
        description: 'The ARIA label for hamburger menu button of mobile navigation'
      })}
      aria-expanded={shown}
      className="navbar__toggle clean-btn"
      type="button"
    >
      <IconMenu />
    </button>
  )
}
</file>

<file path="src/theme/Navbar/MobileSidebar/index.js">
import React from 'react'
import { useLockBodyScroll, useNavbarMobileSidebar } from '@docusaurus/theme-common/internal'
import NavbarMobileSidebarLayout from '@theme/Navbar/MobileSidebar/Layout'
import NavbarMobileSidebarHeader from '@theme/Navbar/MobileSidebar/Header'
import NavbarMobileSidebarSecondaryMenu from '@theme/Navbar/MobileSidebar/SecondaryMenu'
export default function NavbarMobileSidebar() {
  const mobileSidebar = useNavbarMobileSidebar()
  useLockBodyScroll(mobileSidebar.shown)
  if (!mobileSidebar.shouldRender) {
    return null
  }
  return (
    <NavbarMobileSidebarLayout
      header={<NavbarMobileSidebarHeader />}
      secondaryMenu={<NavbarMobileSidebarSecondaryMenu />}
    />
  )
}
</file>

<file path="src/theme/Navbar/Search/index.js">
import React from 'react'
import clsx from 'clsx'
import styles from './styles.module.css'
export default function NavbarSearch({ children, className }) {
  return <div className={clsx(className, styles.searchBox)}>{children}</div>
}
</file>

<file path="src/theme/Navbar/Search/styles.module.css">
@media (max-width: 996px) {
  .searchBox {
    position: absolute;
    right: var(--ifm-navbar-padding-horizontal);
  }
}

@media (min-width: 997px) {
  .searchBox {
    padding: var(--ifm-navbar-item-padding-vertical) var(--ifm-navbar-item-padding-horizontal);
  }
}
</file>

<file path="src/theme/Navbar/index.js">
import React from 'react'
import NavbarLayout from '@theme/Navbar/Layout'
import NavbarContent from '@theme/Navbar/Content'
export default function Navbar() {
  return (
    <NavbarLayout>
      <NavbarContent />
    </NavbarLayout>
  )
}
</file>

<file path="src/theme/Root.js">
import React, { useEffect } from 'react'
import { DocsSidebarProvider } from '@docusaurus/theme-common/internal'

export default function Root({ children }) {
  useEffect(() => {
    // Need to replace the consent preferences button after render due
    // to the loading order of docusaurus scripts and footer tags.
    // The server rendered tags are present before the termly script
    // finishes loading. Making the tags not trigger the termly modal.
    setTimeout(() => {
      const termlyATag = document.createElement('a')
      termlyATag.href = '#'
      termlyATag.className = 'termly-display-preferences footer__link-item'
      termlyATag.innerHTML = 'Consent Preferences'
      document.getElementById('termly-display-preferences')?.parentElement.append(termlyATag)
      document.getElementById('termly-display-preferences')?.remove()
    }, 0)
  }, [])

  return (
    <>
      <noscript>
        <iframe
          src="https://www.googletagmanager.com/ns.html?id=GTM-5557TG59"
          height="0"
          width="0"
          style={{
            display: 'none',
            visibility: 'hidden'
          }}
        ></iframe>
      </noscript>
      <DocsSidebarProvider>{children}</DocsSidebarProvider>
    </>
  )
}
</file>

<file path="static/img/walletconnect-logo-black.svg">
<svg height="185" viewBox="0 0 300 185" width="300" xmlns="http://www.w3.org/2000/svg"><path d="m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z" fill="#3b99fc"/></svg>
</file>

<file path="static/img/walletconnect-logo-white.svg">
<svg height="185" viewBox="0 0 300 185" width="300" xmlns="http://www.w3.org/2000/svg"><path d="m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z" fill="#fff"/></svg>
</file>

<file path="static/img/walletconnect-logo.svg">
<svg height="185" viewBox="0 0 300 185" width="300" xmlns="http://www.w3.org/2000/svg"><path d="m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z" fill="#3b99fc"/></svg>
</file>

<file path=".gitignore">
# Dependencies
/node_modules

# Production
/build

# Generated files
.docusaurus
.cache-loader

# Misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
.vercel

# Environment variables
.env

.vscode
</file>

<file path=".prettierrc.json">
{
  "arrowParens": "avoid",
  "printWidth": 100,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "none",
  "singleAttributePerLine": false,
  "semi": false
}
</file>

<file path="babel.config.js">
module.exports = {
  presets: [require.resolve('@docusaurus/core/lib/babel/preset')]
}
</file>

<file path="docusaurus.config.js">
// @ts-check
// Note: type annotations allow type checking and IDEs autocompletion

const { themes } = require('prism-react-renderer')
const lightCodeTheme = themes.github
const darkCodeTheme = themes.dracula

const projectKey =
  process.env.NODE_ENV === 'production'
    ? 'Uuv6kG5tEsMxJaTbj66ljUoei91qg1La'
    : 'sk_test_uH7GmxPmqXDxpn4x6EXi4V5Hg4PsQFFh'

/** @type {import('@docusaurus/types').Config} */
const config = {
  headTags: [
    {
      tagName: 'script',
      attributes: {
        type: 'text/javascript',
        src: 'https://app.termly.io/resource-blocker/22740907-ba21-41a3-bbd9-106afc077eab?autoBlock=on'
      }
    },
    {
      tagName: 'script',
      attributes: {
        defer: 'true',
        type: 'text/javascript',
        src: 'https://www.googletagmanager.com/gtag/js?id=G-T8KHTQMBG8'
      }
    },
    {
      tagName: 'script',
      attributes: {
        type: 'text/javascript',
        defer: 'true'
      },
      innerHTML: `
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-T8KHTQMBG8');
      `
    },
    {
      tagName: 'script',
      attributes: {
        type: 'text/javascript',
        defer: 'true'
      },
      innerHTML: `
        (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-5557TG59');
      `
    }
  ],
  title: 'WalletConnect Docs',
  tagline: 'WalletConnect is an open protocol to communicate securely between Dapps and Wallets.',
  url: 'https://docs.walletconnect.com/',
  baseUrl: '/',
  onBrokenLinks: 'throw',
  onBrokenMarkdownLinks: 'throw',
  favicon: 'img/favicon.ico',
  organizationName: 'walletconnect',
  projectName: 'walletconnect-docs',
  staticDirectories: ['static'],
  scripts: [
    {
      src: 'https://plausible.io/js/plausible.js',
      defer: 'true',
      'data-domain': 'docs.walletconnect.com'
    }
  ],
  presets: [
    [
      'classic',
      /** @type {import('@docusaurus/preset-classic').Options} */
      {
        docs: {
          breadcrumbs: true,
          routeBasePath: '/',
          sidebarPath: require.resolve('./sidebars.js'),
          showLastUpdateTime: true,
          editUrl: 'https://github.com/WalletConnect/walletconnect-docs/blob/main/',
          remarkPlugins: [
            [
              require('@docusaurus/remark-plugin-npm2yarn'),
              {
                sync: true,
                converters: [
                  'yarn',
                  [
                    'Bun',
                    code => code.replace(/npm i /g, 'bun a ').replace(/npm install /g, 'bun add ')
                  ],
                  'pnpm'
                ]
              }
            ]
          ]
        },
        theme: {
          customCss: require.resolve('./src/css/custom.css')
        }
      }
    ]
  ],

  themeConfig: {
    /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
    algolia: {
      appId: 'KEO8ND6AUT',
      apiKey: '5921626237dc9040afc258af25d4e77d',
      indexName: 'walletconnect',
      contextualSearch: true
    },
    image: 'img/Docs-OG.png',
    metadata: [{ name: 'twitter:card', content: 'summary_large_image' }],
    navbar: {
      items: [
        {
          type: 'html',
          value:
            '<a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/walletconnect-logo-white.svg#dark-mode-only"  alt="WalletConnect Logo"><img src="/img/walletconnect-logo-black.svg#light-mode-only"  alt="WalletConnect Logo"></div>WalletConnect<span>Docs<span></a>'
        },
        {
          label: 'Dashboard',
          href: 'https://cloud.walletconnect.com/?utm_source=website&utm_medium=docs&utm_campaign=walletconnectdocs',
          position: 'right',
          className: 'header-cloud-link',
          'aria-label': 'Cloud'
        },
        {
          href: 'https://github.com/walletconnect/',
          position: 'right',
          className: 'header-github-link',
          'aria-label': 'GitHub repository'
        }
      ]
    },
    footer: {
      links: [
        {
          title: 'Docs',
          items: [
            {
              label: 'AppKit',
              to: '/appkit/overview'
            },
            {
              label: 'WalletKit',
              to: '/walletkit/overview'
            }
          ]
        },
        {
          title: 'Community',
          items: [
            {
              label: 'GitHub Discussions',
              href: 'https://github.com/WalletConnect/walletconnect-monorepo/discussions'
            },
            {
              label: 'Discord',
              href: 'https://discord.com/invite/kdTQHQ6AFQ'
            },
            {
              label: 'Telegram',
              href: 'https://t.me/walletconnect'
            },
            {
              label: 'X',
              href: 'https://twitter.com/walletconnect'
            }
          ]
        },
        {
          title: 'More',
          items: [
            {
              label: 'Blog',
              href: 'https://medium.com/walletconnect'
            },
            {
              label: 'GitHub',
              href: 'https://github.com/walletconnect/walletconnect-docs/'
            },
            {
              label: 'Farcaster',
              href: 'https://warpcast.com/walletconnect/'
            }
          ]
        },
        {
          title: 'Privacy',
          items: [
            {
              href: '#',
              id: 'termly-display-preferences',
              class: 'termly-display-preferences footer__link-item',
              label: 'Consent Preferences'
            }
          ]
        }
      ],
      copyright: `Copyright ¬© ${new Date().getFullYear()} WalletConnect, Inc.`
    },
    colorMode: {
      defaultMode: 'dark',
      disableSwitch: false,
      respectPrefersColorScheme: true
    },
    prism: {
      darkTheme: darkCodeTheme,
      theme: lightCodeTheme,
      additionalLanguages: ['swift', 'kotlin', 'dart', 'csharp', 'gradle', 'ruby'],
      magicComments: [
        {
          className: 'theme-code-block-highlighted-delete',
          line: 'highlight-delete',
          block: { start: 'highlight-delete-start', end: 'highlight-delete-end' }
        },
        {
          className: 'theme-code-block-highlighted-add',
          line: 'highlight-add',
          block: { start: 'highlight-add-start', end: 'highlight-add-end' }
        }
      ]
    }
    // announcementBar: {
    //   id: 'support_us',
    //   content:
    //     'It‚Äôs shipping szn üö¢ Explore AppKit‚Äôs latest features: Email Wallets and On-ramp! <a rel="noopener noreferrer" href="/web3modal/features/onramp">Read the docs</a>',
    //   backgroundColor: '#3182ce',
    //   textColor: '#fff',
    //   isCloseable: true
    // }
  }
}

module.exports = config
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2021 WalletConnect, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "walletconnect-docs",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "docusaurus": "docusaurus",
    "dev": "docusaurus start",
    "start": "docusaurus start",
    "build": "docusaurus build",
    "swizzle": "docusaurus swizzle",
    "deploy": "docusaurus deploy",
    "clear": "docusaurus clear",
    "serve": "docusaurus serve",
    "format": "pnpm exec prettier . --write",
    "write-translations": "docusaurus write-translations",
    "write-heading-ids": "docusaurus write-heading-ids",
    "typecheck": "tsc"
  },
  "dependencies": {
    "@docusaurus/core": "^3.4.0",
    "@docusaurus/cssnano-preset": "^3.4.0",
    "@docusaurus/plugin-debug": "^3.4.0",
    "@docusaurus/plugin-google-analytics": "^3.4.0",
    "@docusaurus/plugin-google-gtag": "^3.4.0",
    "@docusaurus/plugin-sitemap": "^3.4.0",
    "@docusaurus/preset-classic": "^3.4.0",
    "@docusaurus/remark-plugin-npm2yarn": "^3.4.0",
    "@docusaurus/theme-classic": "^3.4.0",
    "@docusaurus/theme-common": "^3.4.0",
    "@docusaurus/theme-search-algolia": "^3.4.0",
    "@mdx-js/react": "3.0.0",
    "@types/react-router-dom": "^5.3.3",
    "clsx": "2.1.0",
    "prism-react-renderer": "2.3.1",
    "react": "^18.2.0",
    "react-dom": "18.2.0",
    "react-router-dom": "^5.3.4"
  },
  "devDependencies": {
    "@docusaurus/module-type-aliases": "^3.4.0",
    "@docusaurus/tsconfig": "^3.4.0",
    "@docusaurus/types": "^3.4.0",
    "prettier": "3.2.2",
    "typedoc-plugin-markdown": "3.17.1",
    "typescript": "5.3.3"
  },
  "browserslist": {
    "production": [
      ">0.5%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="README.mdx">
# WalletConnect Docs

This repo runs [docs.walletconnect.com](https://docs.walletconnect.com).

Source can be viewed in [`docs`](./docs/) directory.

## Running Locally

1. `pnpm install`
2. `pnpm start`
3. Open `http://localhost:3000/`

## Adding a New Page

1. Create a new file in `docs/`
2. Configure `sidebars.js` to create the sidebar link.

## Editing a Page

1. Open the file in `docs/`

Older versions are available in `versioned_docs/`.

## Modifying routes

Whenever a route is changed DocSearch needs to crawl the website in order to keep the search engine working properly, this is scheduled once a week, it is therefore
recommended to use redirects to avoid broken links. See [link](https://vercel.com/docs/concepts/projects/project-configuration#redirects).

## Customize Settings & Theme

1. Open `docusaurus.config.js`

# Tab Components

> [!IMPORTANT]
> While creating titles inside a tab it is recommended to use **four** number signs (#) to avoid overpopulating the table of content.

### Platform Tabs

In your mdx file first import `PlatformTabs` and `PlatformTabItem` from `docs/components/PlatformTabs` and `docs/components/PlatformTabItem` relatively and wrap your content around them

You can find the supported platform in `docs/components/PlatformTabs.js`, they are grouped in an array called `PLATFORM_MAP`

```mdx
import PlatformTabs from '../components/PlatformTabs'
import PlatformTabItem from '../components/PlatformTabItem'

<PlatformTabs
	groupId="anyId"
	activeOptions={["web","ios","android"]}
>
<PlatformTabItem value="web">

#### Heading here

Information related to web

</PlatformTabItem>
<PlatformTabItem value="ios">

#### Heading here

Information related to ios

</PlatformTabItem>
<PlatformTabItem value="android">

#### Heading here

Information related to android

</PlatformTabItem>
</PlatformTabs>
```

### Custom Tabs

In your mdx file first import Tabs and TabItem and wrap your content around them

```mdx
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs>
<TabItem value="custom-a" label="Custom A">

#### Heading here

Here you can add all the information related to Custom A

</TabItem>
<TabItem value="custom-b" label="Custom B">

#### Heading here

Here you can add all the information related to Custom B

</TabItem>
</Tabs>
```

## More

For more options, check the [Docusaurus docs](https://docusaurus.io/).

Archived v1.0 docs can be viewed in the [v1.0 branch](https://github.com/WalletConnect/walletconnect-docs/tree/v1.0).
</file>

<file path="sidebars.js">
// @ts-check

/* Global Sections */
const dropdown_placeholder = {
  type: 'html',
  value: '<div class="dropdown_placeholder"></div>',
  defaultStyle: true
}

const cloud = {
  type: 'category',
  label: 'Cloud',
  collapsible: false,
  className: 'menu_outer_list',
  items: [
    'cloud/explorer',
    'cloud/explorer-submission',
    {
      type: 'category',
      label: 'Explorer Chains',
      items: ['cloud/chains/overview', 'cloud/chains/chain-list']
    },
    'cloud/verify',
    'cloud/relay',
    'cloud/blockchain-api',
    'cloud/analytics'
  ]
}

const advanced = {
  type: 'category',
  label: 'Advanced',
  collapsible: false,
  className: 'menu_outer_list',
  items: [
    {
      type: 'category',
      label: 'Multi-Chain',
      items: [
        {
          type: 'category',
          label: 'RPC Reference',
          items: [
            'advanced/multichain/rpc-reference/cosmos-rpc',
            'advanced/multichain/rpc-reference/ethereum-rpc',
            'advanced/multichain/rpc-reference/solana-rpc',
            'advanced/multichain/rpc-reference/near-rpc',
            'advanced/multichain/rpc-reference/starknet-rpc',
            'advanced/multichain/rpc-reference/stellar-rpc',
            'advanced/multichain/rpc-reference/hedera-rpc',
            'advanced/multichain/rpc-reference/tezos-rpc',
            'advanced/multichain/rpc-reference/xrpl-rpc',
            'advanced/multichain/rpc-reference/casper-rpc',
            'advanced/multichain/rpc-reference/everscale-rpc',
            'advanced/multichain/rpc-reference/bitcoin-rpc',
            'advanced/multichain/rpc-reference/litecoin-rpc',
            'advanced/multichain/rpc-reference/dogecoin-rpc'
          ]
        },
        {
          type: 'category',
          label: 'Examples',
          items: [
            ,
            {
              type: 'category',
              label: 'Polkadot',
              items: [
                'advanced/multichain/polkadot/dapp-integration-guide',
                'advanced/multichain/polkadot/namespaces-guide',
                'advanced/multichain/polkadot/wallet-integration-guide'
              ]
            }
          ]
        }
      ]
    },
    {
      type: 'category',
      label: 'Providers & Adapters',
      collapsible: true,
      collapsed: true,
      items: [
        'advanced/providers/ethereum',
        'advanced/providers/universal',
        'advanced/providers/solana-adapter'
      ]
    },
    {
      type: 'category',
      label: 'APIs',
      collapsed: true,
      collapsible: true,
      items: [
        {
          type: 'category',
          label: 'Core',
          items: ['api/core/pairing', 'api/core/relay', 'api/core/shared-core']
        },
        {
          type: 'category',
          label: 'Notify',
          items: ['api/notify/about']
        },
        {
          type: 'category',
          label: 'Sign',
          items: [
            'api/sign/overview',
            'api/sign/dapp-usage',
            'api/sign/wallet-usage',
            'api/sign/smart-contract-wallet-usage'
          ]
        }
      ]
    },
    {
      type: 'category',
      label: 'Security',
      collapsed: true,
      collapsible: true,
      items: ['advanced/security/content-security-policy']
    },
    'advanced/push-server'
  ]
}

const specs = {
  type: 'category',
  label: 'Technical Reference',
  collapsible: false,
  className: 'menu_outer_list',
  items: [
    {
      type: 'link',
      label: 'Specs',
      href: 'https://specs.walletconnect.com/'
    },
    'advanced/faq'
  ]
}

const welcome = {
  type: 'category',
  label: 'INTRODUCTION',
  collapsible: false,
  className: 'menu_outer_list',
  items: [
    {
      type: 'link',
      label: 'Welcome',
      href: '/'
    }
  ]
}

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */

module.exports = {
  WCM: [
    {
      type: 'doc',
      label: 'Home',
      className: 'kill',
      id: 'readme'
    },
    {
      type: 'link',
      label: 'Welcome',
      href: '/'
    },
    {
      type: 'category',
      label: 'WalletConnectModal',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'advanced/walletconnectmodal/about',
        'advanced/walletconnectmodal/usage',
        'advanced/walletconnectmodal/options',
        'advanced/walletconnectmodal/theming',
        'advanced/walletconnectmodal/resources'
      ]
    }
  ],
  mainSidebar: [
    {
      type: 'doc',
      label: 'Home',
      className: 'kill',
      id: 'readme'
    },
    {
      type: 'category',
      label: 'INTRODUCTION',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'link',
          label: 'Welcome',
          href: '/'
        },
        {
          type: 'link',
          label: 'System Status',
          href: 'https://status.walletconnect.com'
        }
      ]
    },
    {
      type: 'category',
      label: 'SDKs',
      collapsible: false,
      className: 'menu_outer_list menu_outer_list--margin-top',
      items: [
        {
          type: 'category',
          label: 'AppKit',
          collapsed: false,
          collapsible: true,
          className: 'sidebar__logo sidebar__logo--appkit',
          items: [
            'appkit/overview',
            {
              type: 'category',
              label: 'Features',
              collapsed: false,
              collapsible: true,
              items: [
                { type: 'doc', label: 'Swaps', id: 'appkit/features/swaps' },
                { type: 'doc', label: 'Email & Socials', id: 'appkit/features/socials' },
                { type: 'doc', label: 'Smart Accounts', id: 'appkit/features/smart-accounts' },
                { type: 'doc', label: 'One-Click Auth', id: 'appkit/features/one-click-auth' },
                { type: 'doc', label: 'On-Ramp', id: 'appkit/features/onramp' },
                { type: 'doc', label: 'Notifications', id: 'appkit/features/notifications' },
                { type: 'doc', label: 'Solana', id: 'appkit/features/solana' }
              ]
            },
            'appkit/upgrade',
            {
              type: 'category',
              label: 'Migration',
              collapsed: true,
              collapsible: true,
              items: [
                { type: 'doc', label: 'From RainbowKit', id: 'appkit/migration/from-rainbowkit-next' },
                { type: 'doc', label: 'From Anza Adapter', id: 'appkit/migration/from-anza-adapter-react' },
              ]
            },
          ]
        },
        {
          type: 'category',
          label: 'WalletKit',
          collapsed: false,
          collapsible: true,
          className: 'sidebar__logo sidebar__logo--walletkit',
          items: [
            'walletkit/overview',
            {
              type: 'category',
              label: 'Features',
              collapsed: false,
              collapsible: true,
              items: [
                { type: 'doc', label: 'One-Click Auth', id: 'walletkit/features/one-click-auth' },
                { type: 'doc', label: 'Notifications', id: 'walletkit/features/notifications' },
                { type: 'doc', label: 'Verify', id: 'walletkit/features/verify' }
              ]
            },
            'walletkit/best-practices'
          ]
        }
      ]
    },
    cloud,
    advanced,
    specs,
    dropdown_placeholder
  ],
  AppKit_React: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/react/core/installation',
            'appkit/react/core/hooks',
            'appkit/react/core/options',
            'appkit/react/core/components',
            'appkit/react/core/custom-connectors',
            'appkit/react/core/siwe',
            'appkit/react/core/theming',
            'appkit/react/core/resources'
          ]
        },
        {
          type: 'category',
          label: 'Onboarding',
          items: ['appkit/react/onboarding/socials', 'appkit/react/onboarding/smart-accounts']
        },
        {
          type: 'category',
          label: 'Transactions',
          items: ['appkit/react/transactions/onramp', 'appkit/react/transactions/swaps']
        },
        {
          type: 'category',
          label: 'Notifications',
          items: [
            'appkit/react/notifications/overview',
            'appkit/react/notifications/cloud-setup',
            'appkit/react/notifications/cloud-sending',
            {
              type: 'category',
              label: 'Frontend Integration',
              items: [
                'appkit/react/notifications/frontend-integration/usage',
                'appkit/react/notifications/frontend-integration/api',
                'appkit/react/notifications/frontend-integration/examples',
                'appkit/react/notifications/frontend-integration/migration-guide'
              ]
            },
            'appkit/react/notifications/backend-integration',
            'appkit/react/notifications/demo',
            {
              type: 'category',
              label: 'Authorization Signatures',
              items: [
                {
                  type: 'doc',
                  label: 'About',
                  id: 'appkit/react/notifications/authorization-signatures/overview'
                },
                {
                  type: 'doc',
                  label: 'This App',
                  id: 'appkit/react/notifications/authorization-signatures/this-app'
                },
                {
                  type: 'doc',
                  label: 'All Apps',
                  id: 'appkit/react/notifications/authorization-signatures/all-apps'
                }
              ]
            }
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/react/cloud/verify',
            'appkit/react/cloud/relay',
            'appkit/react/cloud/blockchain-api',
            'appkit/react/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_Next: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/next/core/installation',
            'appkit/next/core/hooks',
            'appkit/next/core/options',
            'appkit/next/core/components',
            'appkit/next/core/custom-connectors',
            'appkit/next/core/siwe',
            'appkit/next/core/theming',
            'appkit/next/core/resources'
          ]
        },
        {
          type: 'category',
          label: 'Onboarding',
          items: ['appkit/next/onboarding/socials', 'appkit/next/onboarding/smart-accounts']
        },
        {
          type: 'category',
          label: 'Transactions',
          items: ['appkit/next/transactions/onramp', 'appkit/next/transactions/swaps']
        },
        {
          type: 'category',
          label: 'Notifications',
          items: [
            'appkit/next/notifications/overview',
            'appkit/next/notifications/cloud-setup',
            'appkit/next/notifications/cloud-sending',
            {
              type: 'category',
              label: 'Frontend Integration',
              items: [
                'appkit/next/notifications/frontend-integration/usage',
                'appkit/next/notifications/frontend-integration/api',
                'appkit/next/notifications/frontend-integration/examples',
                'appkit/next/notifications/frontend-integration/migration-guide'
              ]
            },
            'appkit/next/notifications/backend-integration',
            'appkit/next/notifications/demo',
            {
              type: 'category',
              label: 'Authorization Signatures',
              items: [
                {
                  type: 'doc',
                  label: 'About',
                  id: 'appkit/next/notifications/authorization-signatures/overview'
                },
                {
                  type: 'doc',
                  label: 'This App',
                  id: 'appkit/next/notifications/authorization-signatures/this-app'
                },
                {
                  type: 'doc',
                  label: 'All Apps',
                  id: 'appkit/next/notifications/authorization-signatures/all-apps'
                }
              ]
            }
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/next/cloud/verify',
            'appkit/next/cloud/relay',
            'appkit/next/cloud/blockchain-api',
            'appkit/next/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_Vue: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/vue/core/installation',
            'appkit/vue/core/composables',
            'appkit/vue/core/options',
            'appkit/vue/core/components',
            'appkit/vue/core/custom-connectors',
            'appkit/vue/core/siwe',
            'appkit/vue/core/theming',
            'appkit/vue/core/resources'
          ]
        },
        {
          type: 'category',
          label: 'Onboarding',
          items: ['appkit/vue/onboarding/socials', 'appkit/vue/onboarding/smart-accounts']
        },
        {
          type: 'category',
          label: 'Transactions',
          items: ['appkit/vue/transactions/onramp', 'appkit/vue/transactions/swaps']
        },
        {
          type: 'category',
          label: 'Notifications',
          items: [
            'appkit/vue/notifications/overview',
            'appkit/vue/notifications/cloud-setup',
            'appkit/vue/notifications/cloud-sending',
            {
              type: 'category',
              label: 'Frontend Integration',
              items: [
                'appkit/vue/notifications/frontend-integration/usage',
                'appkit/vue/notifications/frontend-integration/api',
                'appkit/vue/notifications/frontend-integration/examples',
                'appkit/vue/notifications/frontend-integration/migration-guide'
              ]
            },
            'appkit/vue/notifications/backend-integration',
            'appkit/vue/notifications/demo',
            {
              type: 'category',
              label: 'Authorization Signatures',
              items: [
                {
                  type: 'doc',
                  label: 'About',
                  id: 'appkit/vue/notifications/authorization-signatures/overview'
                },
                {
                  type: 'doc',
                  label: 'This App',
                  id: 'appkit/vue/notifications/authorization-signatures/this-app'
                },
                {
                  type: 'doc',
                  label: 'All Apps',
                  id: 'appkit/vue/notifications/authorization-signatures/all-apps'
                }
              ]
            }
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/vue/cloud/verify',
            'appkit/vue/cloud/relay',
            'appkit/vue/cloud/blockchain-api',
            'appkit/vue/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_JS: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/javascript/core/installation',
            'appkit/javascript/core/actions',
            'appkit/javascript/core/options',
            'appkit/javascript/core/components',
            'appkit/javascript/core/custom-connectors',
            'appkit/javascript/core/siwe',
            'appkit/javascript/core/theming',
            'appkit/javascript/core/resources'
          ]
        },
        {
          type: 'category',
          label: 'Onboarding',
          items: [
            'appkit/javascript/onboarding/socials',
            'appkit/javascript/onboarding/smart-accounts'
          ]
        },
        {
          type: 'category',
          label: 'Transactions',
          items: ['appkit/javascript/transactions/onramp', 'appkit/javascript/transactions/swaps']
        },
        {
          type: 'category',
          label: 'Notifications',
          items: [
            'appkit/javascript/notifications/overview',
            'appkit/javascript/notifications/cloud-setup',
            'appkit/javascript/notifications/cloud-sending',
            {
              type: 'category',
              label: 'Frontend Integration',
              items: [
                'appkit/javascript/notifications/frontend-integration/usage',
                'appkit/javascript/notifications/frontend-integration/api',
                'appkit/javascript/notifications/frontend-integration/examples',
                'appkit/javascript/notifications/frontend-integration/migration-guide'
              ]
            },
            'appkit/javascript/notifications/backend-integration',
            'appkit/javascript/notifications/demo',
            {
              type: 'category',
              label: 'Authorization Signatures',
              items: [
                {
                  type: 'doc',
                  label: 'About',
                  id: 'appkit/javascript/notifications/authorization-signatures/overview'
                },
                {
                  type: 'doc',
                  label: 'This App',
                  id: 'appkit/javascript/notifications/authorization-signatures/this-app'
                },
                {
                  type: 'doc',
                  label: 'All Apps',
                  id: 'appkit/javascript/notifications/authorization-signatures/all-apps'
                }
              ]
            }
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/javascript/cloud/verify',
            'appkit/javascript/cloud/relay',
            'appkit/javascript/cloud/blockchain-api',
            'appkit/javascript/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_React_Native: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/react-native/core/installation',
            'appkit/react-native/core/options',
            'appkit/react-native/core/hooks',
            'appkit/react-native/core/components',
            'appkit/react-native/core/siwe',
            'appkit/react-native/core/resources'
          ]
        },
        {
          type: 'category',
          label: 'Onboarding',
          items: ['appkit/react-native/onboarding/email']
        },
        {
          type: 'category',
          label: 'Notifications',
          items: [
            'appkit/react-native/notifications/overview',
            'appkit/react-native/notifications/cloud-setup',
            'appkit/react-native/notifications/cloud-sending',
            {
              type: 'category',
              label: 'Frontend Integration',
              items: [
                'appkit/react-native/notifications/frontend-integration/usage',
                'appkit/react-native/notifications/frontend-integration/api',
                'appkit/react-native/notifications/frontend-integration/examples',
                'appkit/react-native/notifications/frontend-integration/migration-guide'
              ]
            },
            'appkit/react-native/notifications/backend-integration',
            'appkit/react-native/notifications/demo',
            {
              type: 'category',
              label: 'Authorization Signatures',
              items: [
                {
                  type: 'doc',
                  label: 'About',
                  id: 'appkit/react-native/notifications/authorization-signatures/overview'
                },
                {
                  type: 'doc',
                  label: 'This App',
                  id: 'appkit/react-native/notifications/authorization-signatures/this-app'
                },
                {
                  type: 'doc',
                  label: 'All Apps',
                  id: 'appkit/react-native/notifications/authorization-signatures/all-apps'
                }
              ]
            }
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/react-native/cloud/verify',
            'appkit/react-native/cloud/relay',
            'appkit/react-native/cloud/blockchain-api',
            'appkit/react-native/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_Flutter: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/flutter/core/installation',
            'appkit/flutter/core/usage',
            'appkit/flutter/core/siwe',
            'appkit/flutter/core/options',
            'appkit/flutter/core/actions',
            'appkit/flutter/core/events',
            'appkit/flutter/core/theming',
            'appkit/flutter/core/custom-chains'
          ]
        },
        {
          type: 'category',
          label: 'Onboarding',
          items: ['appkit/flutter/onboarding/email']
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/flutter/cloud/verify',
            'appkit/flutter/cloud/relay',
            'appkit/flutter/cloud/blockchain-api',
            'appkit/flutter/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_iOS: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/ios/core/installation',
            'appkit/ios/core/usage',
            'appkit/ios/core/options',
            'appkit/ios/core/actions',
            'appkit/ios/core/one-click-auth',
            'appkit/ios/core/custom-chains'
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/ios/cloud/verify',
            'appkit/ios/cloud/relay',
            'appkit/ios/cloud/blockchain-api',
            'appkit/ios/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_Android: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/android/core/installation',
            'appkit/android/core/usage',
            'appkit/android/core/options',
            'appkit/android/core/actions',
            'appkit/android/core/one-click-auth',
            'appkit/android/core/components',
            'appkit/android/core/theming'
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/android/cloud/verify',
            'appkit/android/cloud/relay',
            'appkit/android/cloud/blockchain-api',
            'appkit/android/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  AppKit_Unity: [
    welcome,
    {
      type: 'category',
      label: 'AppKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        {
          type: 'category',
          label: 'Core',
          items: [
            'appkit/unity/core/installation',
            'appkit/unity/core/usage',
            'appkit/unity/core/options',
            'appkit/unity/core/actions',
            'appkit/unity/core/events',
            'appkit/unity/core/customization'
          ]
        },
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'appkit/unity/cloud/verify',
            'appkit/unity/cloud/relay',
            'appkit/unity/cloud/blockchain-api',
            'appkit/unity/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  walletKit_Android: [
    welcome,
    {
      type: 'category',
      label: 'WalletKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'walletkit/android/installation',
        'walletkit/android/usage',
        'walletkit/android/one-click-auth',
        'walletkit/android/mobile-linking',
        'walletkit/android/link-mode',
        'walletkit/android/verify',
        'walletkit/android/eip5792',
        {
          type: 'category',
          label: 'Notifications',
          items: [
            {
              type: 'category',
              label: 'Notify',
              items: [
                'walletkit/android/notifications/notify/overview',
                'walletkit/android/notifications/notify/installation',
                'walletkit/android/notifications/notify/usage',
                'walletkit/android/notifications/notify/spam-protection',
                'walletkit/android/notifications/notify/resources'
              ]
            },
            'walletkit/android/notifications/push'
          ]
        },
        'walletkit/android/best-practices',
        'walletkit/android/resources',
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'walletkit/android/cloud/explorer-submission',
            'walletkit/android/cloud/verify',
            'walletkit/android/cloud/relay',
            'walletkit/android/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  walletKit_iOS: [
    welcome,
    {
      type: 'category',
      label: 'WalletKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'walletkit/ios/installation',
        'walletkit/ios/usage',
        'walletkit/ios/one-click-auth',
        'walletkit/ios/mobile-linking',
        'walletkit/ios/link-mode',
        'walletkit/ios/verify',
        'walletkit/ios/eip5792',
        {
          type: 'category',
          label: 'Notifications',
          items: [
            {
              type: 'category',
              label: 'Notify',
              items: [
                'walletkit/ios/notifications/notify/overview',
                'walletkit/ios/notifications/notify/installation',
                'walletkit/ios/notifications/notify/usage',
                'walletkit/ios/notifications/notify/spam-protection',
                'walletkit/ios/notifications/notify/resources'
              ]
            },
            'walletkit/ios/notifications/push'
          ]
        },
        'walletkit/ios/best-practices',
        'walletkit/ios/resources',
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'walletkit/ios/cloud/explorer-submission',
            'walletkit/ios/cloud/verify',
            'walletkit/ios/cloud/relay',
            'walletkit/ios/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  walletKit_Flutter: [
    welcome,
    {
      type: 'category',
      label: 'WalletKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'walletkit/flutter/installation',
        'walletkit/flutter/usage',
        'walletkit/flutter/one-click-auth',
        'walletkit/flutter/mobile-linking',
        'walletkit/flutter/verify',
        'walletkit/flutter/eip5792',
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'walletkit/flutter/cloud/explorer-submission',
            'walletkit/flutter/cloud/verify',
            'walletkit/flutter/cloud/relay',
            'walletkit/flutter/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  walletKit_React_Native: [
    welcome,
    {
      type: 'category',
      label: 'WalletKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'walletkit/react-native/installation',
        'walletkit/react-native/usage',
        'walletkit/react-native/one-click-auth',
        'walletkit/react-native/mobile-linking',
        'walletkit/react-native/verify',
        'walletkit/react-native/eip5792',
        {
          type: 'category',
          label: 'Notifications',
          items: [
            {
              type: 'category',
              label: 'Notify',
              items: [
                'walletkit/react-native/notifications/notify/overview',
                'walletkit/react-native/notifications/notify/installation',
                'walletkit/react-native/notifications/notify/usage',
                'walletkit/react-native/notifications/notify/spam-protection'
              ]
            },
            'walletkit/react-native/notifications/push'
          ]
        },
        'walletkit/react-native/best-practices',
        'walletkit/react-native/resources',
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'walletkit/react-native/cloud/explorer-submission',
            'walletkit/react-native/cloud/verify',
            'walletkit/react-native/cloud/relay',
            'walletkit/react-native/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  walletKit_Web: [
    welcome,
    {
      type: 'category',
      label: 'WalletKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'walletkit/web/installation',
        'walletkit/web/usage',
        'walletkit/web/one-click-auth',
        'walletkit/web/verify',
        'walletkit/web/eip5792',
        'walletkit/web/best-practices',
        'walletkit/web/resources',
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'walletkit/web/cloud/explorer-submission',
            'walletkit/web/cloud/verify',
            'walletkit/web/cloud/relay',
            'walletkit/web/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ],
  walletKit_C_Sharp: [
    welcome,
    {
      type: 'category',
      label: 'WalletKit',
      collapsible: false,
      className: 'menu_outer_list',
      items: [
        'walletkit/c-sharp/installation',
        'walletkit/c-sharp/usage',
        'walletkit/c-sharp/verify',
        {
          type: 'category',
          label: 'Cloud',
          collapsible: false,
          className: 'menu_outer_list',
          items: [
            'walletkit/c-sharp/cloud/explorer-submission',
            'walletkit/c-sharp/cloud/verify',
            'walletkit/c-sharp/cloud/relay',
            'walletkit/c-sharp/cloud/analytics'
          ]
        }
      ]
    },
    specs,
    dropdown_placeholder
  ]
}
</file>

<file path="tsconfig.json">
{
  "extends": "@docusaurus/tsconfig",
  "compilerOptions": {
    "baseUrl": "."
  }
}
</file>

<file path="vercel.json">
{
  "trailingSlash": false,
  "redirects": [
    {
      "source": "/2.0/:path*",
      "destination": "/:path*"
    },
    {
      "source": "/appkit/features/email",
      "destination": "/appkit/features/socials"
    },
    {
      "source": "/web3modal/:path*",
      "destination": "/appkit/overview"
    },
    {
      "source": "/web3inbox/:path*",
      "destination": "/appkit/overview"
    },
    {
      "source": "/web3wallet/:path*",
      "destination": "/walletkit/overview"
    },
    {
      "source": "/advanced/multichain/chain-list",
      "destination": "cloud/chains/chain-list"
    },
    {
      "source": "/advanced/rpc-reference/:path*",
      "destination": "/advanced/multichain/rpc-reference/:path*"
    }
  ]
}
</file>

</files>
