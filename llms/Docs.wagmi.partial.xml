This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .vitepress/**, cli/**, components/**, core/guides/**, core/getting-started.md, core/installation.md, core/typescript.md, core/why.md, dev/**, public/**, snippets/core/**, snippets/vue/**, vue/**, index.md, package.json, tsconfig.json, vercel.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
core/
  api/
    actions/
      call.md
      connect.md
      deployContract.md
      disconnect.md
      estimateFeesPerGas.md
      estimateGas.md
      estimateMaxPriorityFeePerGas.md
      getAccount.md
      getBalance.md
      getBlock.md
      getBlockNumber.md
      getBlockTransactionCount.md
      getBytecode.md
      getCallsStatus.md
      getCapabilities.md
      getChainId.md
      getChains.md
      getClient.md
      getConnections.md
      getConnectorClient.md
      getConnectors.md
      getEnsAddress.md
      getEnsAvatar.md
      getEnsName.md
      getEnsResolver.md
      getEnsText.md
      getFeeHistory.md
      getGasPrice.md
      getProof.md
      getPublicClient.md
      getStorageAt.md
      getToken.md
      getTransaction.md
      getTransactionConfirmations.md
      getTransactionCount.md
      getTransactionReceipt.md
      getWalletClient.md
      multicall.md
      prepareTransactionRequest.md
      readContract.md
      readContracts.md
      reconnect.md
      sendCalls.md
      sendTransaction.md
      showCallsStatus.md
      signMessage.md
      signTypedData.md
      simulateContract.md
      switchAccount.md
      switchChain.md
      verifyMessage.md
      verifyTypedData.md
      waitForCallsStatus.md
      waitForTransactionReceipt.md
      watchAccount.md
      watchAsset.md
      watchBlockNumber.md
      watchBlocks.md
      watchChainId.md
      watchClient.md
      watchConnections.md
      watchConnectors.md
      watchContractEvent.md
      watchPendingTransactions.md
      watchPublicClient.md
      writeContract.md
      writeContracts.md
    connectors/
      coinbaseWallet.md
      injected.md
      metaMask.md
      mock.md
      safe.md
      walletConnect.md
    transports/
      custom.md
      fallback.md
      http.md
      unstable_connector.md
      webSocket.md
    utilities/
      cookieToInitialState.md
      deserialize.md
      normalizeChainId.md
      serialize.md
    actions.md
    chains.md
    connectors.md
    createConfig.md
    createConnector.md
    createStorage.md
    errors.md
    transports.md
react/
  api/
    connectors/
      coinbaseWallet.md
      injected.md
      metaMask.md
      mock.md
      safe.md
      walletConnect.md
    hooks/
      useAccount.md
      useAccountEffect.md
      useBalance.md
      useBlock.md
      useBlockNumber.md
      useBlockTransactionCount.md
      useBytecode.md
      useCall.md
      useCallsStatus.md
      useCapabilities.md
      useChainId.md
      useChains.md
      useClient.md
      useConfig.md
      useConnect.md
      useConnections.md
      useConnectorClient.md
      useConnectors.md
      useDeployContract.md
      useDisconnect.md
      useEnsAddress.md
      useEnsAvatar.md
      useEnsName.md
      useEnsResolver.md
      useEnsText.md
      useEstimateFeesPerGas.md
      useEstimateGas.md
      useEstimateMaxPriorityFeePerGas.md
      useFeeHistory.md
      useGasPrice.md
      useInfiniteReadContracts.md
      usePrepareTransactionRequest.md
      useProof.md
      usePublicClient.md
      useReadContract.md
      useReadContracts.md
      useReconnect.md
      useSendCalls.md
      useSendTransaction.md
      useShowCallsStatus.md
      useSignMessage.md
      useSignTypedData.md
      useSimulateContract.md
      useStorageAt.md
      useSwitchAccount.md
      useSwitchChain.md
      useToken.md
      useTransaction.md
      useTransactionConfirmations.md
      useTransactionCount.md
      useTransactionReceipt.md
      useVerifyMessage.md
      useVerifyTypedData.md
      useWaitForCallsStatus.md
      useWaitForTransactionReceipt.md
      useWalletClient.md
      useWatchAsset.md
      useWatchBlockNumber.md
      useWatchBlocks.md
      useWatchContractEvent.md
      useWatchPendingTransactions.md
      useWriteContract.md
      useWriteContracts.md
    transports/
      custom.md
      fallback.md
      http.md
      unstable_connector.md
      webSocket.md
    utilities/
      cookieToInitialState.md
      deserialize.md
      normalizeChainId.md
      serialize.md
    actions.md
    chains.md
    connectors.md
    createConfig.md
    createStorage.md
    errors.md
    hooks.md
    transports.md
    WagmiProvider.md
  guides/
    chain-properties.md
    connect-wallet.md
    error-handling.md
    ethers.md
    faq.md
    migrate-from-v1-to-v2.md
    read-from-contract.md
    send-transaction.md
    ssr.md
    tanstack-query.md
    testing.md
    viem.md
    write-to-contract.md
  comparisons.md
  getting-started.md
  installation.md
  typescript.md
  why.md
shared/
  connectors/
    coinbaseWallet.md
    injected.md
    metaMask.md
    mock.md
    safe.md
    walletConnect.md
  transports/
    custom.md
    fallback.md
    http.md
    unstable_connector.md
    webSocket.md
  utilities/
    cookieToInitialState.md
    deserialize.md
    normalizeChainId.md
    serialize.md
  create-chain.md
  createConfig.md
  createStorage.md
  errors.md
  faq.md
  getAccount-return-type.md
  installation.md
  mutation-imports.md
  mutation-options.md
  mutation-result.md
  query-imports.md
  query-options.md
  query-result.md
snippets/
  react/
    app.tsx
    config-chain-properties.ts
    config.ts
  abi-event.ts
  abi-infinite-read.ts
  abi-read.ts
  abi-write.ts
  typedData.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="core/api/actions/call.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'call'
const typeName = 'call'
</script>

# call

Action for executing a new message call immediately without submitting a transaction to the network.

## Import

```ts
import { call } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts twoslash
import { type CallParameters } from '@wagmi/core'
```

### account

`Account | Address | undefined`

The Account to call from.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`Address | undefined`

The contract address or recipient.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  accessList: [ // [!code focus:6] 
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined`

The gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  gas: 1_000_000n, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseGwei } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseGwei } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseGwei } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  nonce: 420, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value (in wei) sent with this transaction.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await call(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`number | undefined`

The block number to perform the call against.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  blockNumber: 15121123n, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to perform the call against.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'

await call(config, {
  blockTag: 'safe', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The block tag to perform the call against.

::: code-group
```ts [index.ts]
import { call } from '@wagmi/core'
import { config } from './config'
import { mainnet } from '@wagmi/core/chains'

await call(config, {
  chainId: mainnet.id, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts twoslash
import { type CallReturnType } from '@wagmi/core'
```

`{ data: 0x${string} }`

The call data.

## Error

```ts twoslash
import { type CallErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`call`](https://viem.sh/docs/actions/public/call.html)
</file>

<file path="core/api/actions/connect.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'connect'
const typeName = 'Connect'
</script>

# connect

Action for connecting accounts with [connectors](/core/api/connectors).

## Import

```ts
import { connect } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { connect } from '@wagmi/core'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await connect(config, { connector: injected() })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ConnectParameters } from '@wagmi/core'
```

### chainId

`number | undefined`

Chain ID to connect to.

Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider is connected to.

::: code-group
```ts [index.ts]
import { connect } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await connect(config, {
  chainId: mainnet.id, // [!code focus]
  connector: injected(),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`CreateConnectorFn | Connector`

[Connector](/core/api/connectors) to connect with.

::: code-group
```ts [index.ts]
import { connect } from '@wagmi/core'
import { injected } from '@wagmi/connectors' // [!code focus]
import { config } from './config'

const result = await connect(config, {
  connector: injected(), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ConnectReturnType } from '@wagmi/core'
```

### accounts

`readonly [Address, ...Address[]]`

Connected accounts from connector.

### chainId

`number`

Connected chain ID from connector.

## Error

```ts
import { type ConnectErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="core/api/actions/deployContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'deployContract'
const typeName = 'DeployContract'
</script>

# deployContract <Badge text="viem@>=2.8.18" />

Action for deploying a contract to the network, given bytecode, and constructor arguments.

## Import

```ts
import { deployContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Deploying with Constructor Args

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::


## Parameters

```ts
import { type DeployContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI.

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi, // [!code focus]
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when deploying a contract. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when deploying the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420], // [!code focus]
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### bytecode

`Hex`

The contract's bytecode.

::: code-group
```ts [index.ts]
import { deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...', // [!code focus]
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to use when deploying a contract.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getAccount, deployContract } from '@wagmi/core'
import { wagmiAbi } from './abi'
import { config } from './config'

const { connector } = getAccount(config)
const result = await deployContract(config, {
  abi: wagmiAbi,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  connector, // [!code focus]
})
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type DeployContractReturnType } from '@wagmi/core'
```

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

Transaction hash.

## Error

```ts
import { type DeployContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`deployContract`](https://viem.sh/docs/contract/deployContract)
</file>

<file path="core/api/actions/disconnect.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'disconnect'
const typeName = 'Disconnect'
</script>

# disconnect

Action for disconnecting connections.

## Import

```ts
import { disconnect } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { disconnect } from '@wagmi/core'
import { config } from './config'

await disconnect(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type DisconnectParameters } from '@wagmi/core'
```

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to disconnect with.

::: code-group
```ts [index.ts]
import { disconnect, getAccount } from '@wagmi/core'
import { config } from './config'

const { connector } = getAccount(config)
const result = await disconnect(config, {
  connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Error

```ts
import { type DisconnectErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="core/api/actions/estimateFeesPerGas.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'estimateFeesPerGas'
const typeName = 'EstimateFeesPerGas'
</script>

# estimateFeesPerGas

Returns an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { estimateFeesPerGas } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { config } from './config'

const result = await estimateFeesPerGas(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type EstimateFeesPerGasParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await estimateFeesPerGas(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { config } from './config'

const feesPerGas = estimateFeesPerGas(config, {
  formatUnits: 'ether', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559'`

- Fee value type.
- Defaults to `'eip1559'`

::: code-group
```ts [index.ts]
import { estimateFeesPerGas } from '@wagmi/core'
import { config } from './config'

const result = estimateFeesPerGas(config, {
  type: 'legacy', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type EstimateFeesPerGasReturnType } from '@wagmi/core'
```

[`FeeValues`](https://viem.sh/docs/glossary/types.html#feevalues)

An estimate (in wei) for the fees per gas.

### formatted
 
`{ gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }`

Object of formatted values using [`formatUnits`](#formatunits).

### gasPrice

`bigint | undefined`

- Gas price.
- When [`type`](#type) is `'eip1559'`, value is `undefined`.

### maxFeePerGas

`bigint | undefined`

- Max fee per gas.
- When [`type`](#type) is `'legacy'`, value is `undefined`.

### maxPriorityFeePerGas

`bigint | undefined`

- Max priority fee per gas.
- When [`type`](#type) is `'legacy'`, value is `undefined`.

## Error

```ts
import { type EstimateFeesPerGasErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`estimateFeesPerGas`](https://viem.sh/docs/actions/public/estimateFeesPerGas.html)
</file>

<file path="core/api/actions/estimateGas.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'estimateGas'
const typeName = 'EstimateGas'
</script>

# estimateGas

Action for estimating the gas necessary to complete a transaction without submitting it to the network.

## Import

```ts
import { estimateGas } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type EstimateGasParameters } from '@wagmi/core'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when estimating gas.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  chainId: mainnet.id, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

::: code-group
```ts [index.ts]
import { getConnections, estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const connections = getConnections(config)
const result = await estimateGas(config, {
  connector: connections[0]?.connector, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  gas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  nonce: 123, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`Address | undefined`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  type: 'eip1559', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await estimateGas(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type EstimateGasReturnType } from '@wagmi/core'
```

`bigint`

The gas estimate in wei.

## Error

```ts
import { type EstimateGasErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`estimateGas`](https://viem.sh/docs/actions/public/estimateGas.html)
</file>

<file path="core/api/actions/estimateMaxPriorityFeePerGas.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'estimateMaxPriorityFeePerGas'
const typeName = 'EstimateFeesPerGas'
</script>

# estimateMaxPriorityFeePerGas

Returns an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
import { config } from './config'

const result = await estimateMaxPriorityFeePerGas(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type EstimateFeesPerGasParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await estimateMaxPriorityFeePerGas(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type EstimateFeesPerGasReturnType } from '@wagmi/core'
```

`bigint`

An estimate (in wei) for the max priority fee per gas.

## Error

```ts
import { type EstimateFeesPerGasErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`estimateMaxPriorityFeePerGas`](https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html)
</file>

<file path="core/api/actions/getAccount.md">
# getAccount

Action for getting current account.

## Import

```ts
import { getAccount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getAccount } from '@wagmi/core'
import { config } from './config'

const account = getAccount(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetAccountReturnType } from '@wagmi/core'
```

<!--@include: @shared/getAccount-return-type.md-->
</file>

<file path="core/api/actions/getBalance.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBalance'
const typeName = 'GetBalance'
</script>

# getBalance

Action for fetching native currency or token balance.

## Import

```ts
import { getBalance } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBalanceParameters } from '@wagmi/core'
```

### address

`Address`

Address to get balance for.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get balance at.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockTag: 'latest', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const balance = await getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### token

`Address | undefined`

ERC-20 token address to get balance for.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### unit

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { getBalance } from '@wagmi/core'
import { config } from './config'

const balance = getBalance(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  unit: 'ether', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBalanceReturnType } from '@wagmi/core'
```

### decimals

`number`

Number of decimals for balance [`value`](#value).

### formatted

`string`

Formatted value of balance using [`unit`](#unit).

### symbol

`string`

Symbol of native currency or token.

### value

`bigint`

Raw value of balance.

## Error

```ts
import { type GetBalanceErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBalance`](https://viem.sh/docs/actions/public/getBalance.html) for native currency balances
- [`multicall`](https://viem.sh/docs/actions/public/multicall.html) for token balances
</file>

<file path="core/api/actions/getBlock.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBlock'
const typeName = 'GetBlock'
</script>

# getBlock

Action for fetching information about a block at a block number, hash or tag.

## Import

```ts
import { getBlock } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBlockParameters } from '@wagmi/core'
```

### blockHash

`` `0x${string}` ``

Information at a given block hash.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`` bigint ``

Information at a given block number.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  blockNumber: 42069n // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`` 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' ``

Information at a given block tag. Defaults to `'latest'`.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  blockTag: 'pending' // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const blockNumber = await getBlock(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### includeTransactions

`boolean`

Whether or not to include transactions as objects.

::: code-group
```ts [index.ts]
import { getBlock } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlock(config, {
  includeTransactions: true // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBlockReturnType } from '@wagmi/core'
```

[`Block`](https://viem.sh/docs/glossary/types.html#block)

Information about the block.

## Error

```ts
import { type GetBlockErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBlock`](https://viem.sh/docs/actions/public/getBlock.html)
</file>

<file path="core/api/actions/getBlockNumber.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBlockNumber'
const typeName = 'GetBlockNumber'
</script>

# getBlockNumber

Action for fetching the number of the most recent block seen.

## Import

```ts
import { getBlockNumber } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBlockNumber } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlockNumber(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBlockNumberParameters } from '@wagmi/core'
```

### cacheTime

`number | undefined`

Time in milliseconds that cached block number will remain in memory.

::: code-group
```ts [index.ts]
import { getBlockNumber } from '@wagmi/core'
import { config } from './config'

const blockNumber = await getBlockNumber(config, {
  cacheTime: 4_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBlockNumber } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const blockNumber = await getBlockNumber(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBlockNumberReturnType } from '@wagmi/core'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type GetBlockNumberErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBlockNumber`](https://viem.sh/docs/actions/public/getBlockNumber.html)
- [`watchBlockNumber`](https://viem.sh/docs/actions/public/watchBlockNumber.html)
</file>

<file path="core/api/actions/getBlockTransactionCount.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBlockTransactionCount'
const typeName = 'GetBlockTransactionCount'
</script>

# getBlockTransactionCount

Action for fetching the number of Transactions at a block number, hash or tag.

## Import

```ts
import { getBlockTransactionCount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBlockTransactionCount } from '@wagmi/core'
import { config } from './config'

const blockTransactionCount = await getBlockTransactionCount(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBlockTransactionCountParameters } from '@wagmi/core'
```

### cacheTime

`number | undefined`

Time in milliseconds that cached block transaction count will remain in memory.

::: code-group
```ts [index.ts]
import { getBlockTransactionCount } from '@wagmi/core'
import { config } from './config'

const blockTransactionCount = await getBlockTransactionCount(config, {
  cacheTime: 4_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getBlockTransactionCount } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const blockTransactionCount = await getBlockTransactionCount(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBlockTransactionCountReturnType } from '@wagmi/core'
```

`number`

The number of Transactions at a block number

## Error

```ts
import { type GetBlockTransactionCountErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getBlockTransactionCount`](https://viem.sh/docs/actions/public/getBlockTransactionCount.html)
</file>

<file path="core/api/actions/getBytecode.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getBytecode'
const typeName = 'getBytecode'
</script>

# getBytecode

Action for retrieving the bytecode at an address.

## Import

```ts
import { getBytecode } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetBytecodeParameters } from '@wagmi/core'
```

### address

`Address`

The contract address.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the bytecode at.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockNumber: 16280770n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { config } from './config'

await getBytecode(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockTag: 'safe', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

::: code-group
```ts [index.ts]
import { getBytecode } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await getBytecode(config, {
  chainId: mainnet.id, // [!code focus]
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetBytecodeReturnType } from '@wagmi/core'
```

`Hex`

The contract's bytecode.

## Error

```ts
import { type GetBytecodeErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getCode`](https://viem.sh/docs/contract/getCode)
</file>

<file path="core/api/actions/getCallsStatus.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'getCallsStatus'
const typeName = 'GetCallsStatus'
</script>

# getCallsStatus

Action to fetch the status and receipts of a call batch that was sent via [`sendCalls`](/core/api/actions/sendCalls).

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_getcallsstatus)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { getCallsStatus } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { getCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await getCallsStatus(config, {
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetCallsStatusParameters } from '@wagmi/core/experimental'
```

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```ts [index.ts]
import { getConnections, getCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const status = await getCallsStatus(config, {
  connector: connections[0]?.connector, // [!code focus]
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { getCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await getCallsStatus(config, {
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetCallsStatusReturnType } from '@wagmi/core/experimental'
```

`{ status: 'PENDING' | 'CONFIRMED', receipts: TransactionReceipt[] }`

The status and receipts of the call batch.

## Error

```ts
import { type GetCallsStatusErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getCallsStatus`](https://viem.sh/experimental/eip5792/getCallsStatus)
</file>

<file path="core/api/actions/getCapabilities.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'getCapabilities'
const typeName = 'GetCapabilities'
</script>

# getCapabilities

Action to extract capabilities (grouped by chain ID) that a connected wallet supports (e.g. paymasters, session keys, etc).

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_getcapabilities)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { getCapabilities } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { getCapabilities } from '@wagmi/core/experimental'
import { config } from './config'

const capabilities = await getCapabilities(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetCapabilitiesParameters } from '@wagmi/core/experimental'
```

### account

`Account | Address | undefined`

Fetch capabilities for the provided account.

::: code-group
```ts [index.ts]
import { getCapabilities } from '@wagmi/core/experimental'
import { config } from './config'

const capabilities = await getCapabilities(config, {
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get capabilities from.

::: code-group
```ts [index.ts]
import { getConnections, getCapabilities } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const capabilities = await getCapabilities(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetCapabilitiesReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type GetCapabilitiesErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getCapabilities`](https://viem.sh/experimental/eip5792/getCapabilities)
</file>

<file path="core/api/actions/getChainId.md">
# getChainId

Action for getting current chain ID.


## Import

```ts
import { getChainId } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getChainId } from '@wagmi/core'
import { config } from './config'

const chainId = getChainId(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainIdReturnType } from '@wagmi/core'
```

`number`

Current chain ID from [`config.state.chainId`](/core/api/createConfig#chainid).

::: info
Only returns chain IDs for chains configured via `createConfig`'s [`chains`](/core/api/createConfig#chains) parameter.

If the active [connection](/core/api/createConfig#connection) [`chainId`](/core/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `getChainId` will return the last configured chain ID.
:::
</file>

<file path="core/api/actions/getChains.md">
# getChains

Action for getting configured chains.

## Import

```ts
import { getChains } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getChains } from '@wagmi/core'
import { config } from './config'

const chains = getChains(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainsReturnType } from '@wagmi/core'
```

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](/core/api/createConfig#chains).
</file>

<file path="core/api/actions/getClient.md">
# getClient

Action for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Import

```ts
import { getClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getClient } from '@wagmi/core'
import { config } from './config'

const client = getClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetClientParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

::: code-group
```ts [index.ts]
import { getClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = await getClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetClientReturnType } from '@wagmi/core'
```

`Client`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.
</file>

<file path="core/api/actions/getConnections.md">
# getConnections

Action for getting active connections.

## Import

```ts
import { getConnections } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnections } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetConnectionsReturnType } from '@wagmi/core'
```

[`Connection[]`](/core/api/createConfig#connection)

Active connections.
</file>

<file path="core/api/actions/getConnectorClient.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getConnectorClient'
const typeName = 'GetConnectorClient'
</script>

# getConnectorClient

Action for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Import

```ts
import { getConnectorClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnectorClient } from '@wagmi/core'
import { config } from './config'

const client = await getConnectorClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetConnectorClientParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { getConnectorClient } from '@wagmi/core'
import { config } from './config'

const client = await getConnectorClient(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

::: code-group
```ts [index.ts]
import { getConnectorClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = await getConnectorClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getConnections, getConnectorClient } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const client = await getConnectorClient(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainIdReturnType } from '@wagmi/core'
```

`Client`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Error

```ts
import { type GetConnectorClientErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->
</file>

<file path="core/api/actions/getConnectors.md">
# getConnectors

Action for getting configured connectors.

## Import

```ts
import { getConnectors } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnectors } from '@wagmi/core'
import { config } from './config'

const connectors = getConnectors(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetConnectorsReturnType } from '@wagmi/core'
```

`readonly Connector[]`

Connectors from [`config.connectors`](/core/api/createConfig#connectors-1).
</file>

<file path="core/api/actions/getEnsAddress.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsAddress'
const typeName = 'GetEnsAddress'
</script>

# getEnsAddress

Action for fetching ENS address for name.

## Import

```ts
import { getEnsAddress } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = getEnsAddress(config, {
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsAddressParameters } from '@wagmi/core'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS address at.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = getEnsAddress(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = getEnsAddress(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### coinType

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  coinType: 60, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the address for.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  name: normalize('wevm.eth'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsAddress } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAddress = await getEnsAddress(config, {
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsAddressReturnType } from '@wagmi/core'
```

`string`

ENS address.

## Error

```ts
import { type GetEnsAddressErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsAddress`](https://viem.sh/docs/ens/actions/getEnsAddress.html)
</file>

<file path="core/api/actions/getEnsAvatar.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsAvatar'
const typeName = 'GetEnsAvatar'
</script>

# getEnsAvatar

Action for fetching ENS address for avatar.

## Import

```ts
import { getEnsAvatar } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsAvatarParameters } from '@wagmi/core'
```

---

### assetGatewayUrls <Badge text="viem@>=2.3.1" />

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  assetGatewayUrls: { // [!code focus]
    ipfs: 'https://cloudflare-ipfs.com', // [!code focus]
  }, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::


### blockNumber

`bigint | undefined`

Block number to get avatar at.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get avatar at.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gatewayUrls

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  gatewayUrls: ['https://cloudflare-ipfs.com'] { // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the avatar for.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  name: normalize('wevm.eth'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensAvatar = await getEnsAvatar(config, {
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsAvatarReturnType } from '@wagmi/core'
```

`string | null`

The avatar URI for ENS name.

## Error

```ts
import { type getEnsAvatarError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsAvatar`](https://viem.sh/docs/ens/actions/getEnsAvatar.html)
</file>

<file path="core/api/actions/getEnsName.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsName'
const typeName = 'GetEnsName'
</script>

# getEnsName

Action for fetching primary ENS name for address.

## Import

```ts
import { getEnsName } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetEnsNameParameters } from '@wagmi/core'
```

### address

`Address`

Address to get the name for.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = await getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get name at.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get name at.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockTag: 'latest', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const ensName = await getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsName } from '@wagmi/core'
import { config } from './config'

const ensName = await getEnsName(config, {
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  universalResolverName: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsNameReturnType } from '@wagmi/core'
```

`string | null`

The primary ENS name for the address. Returns `null` if address does not have primary name assigned.

## Error

```ts
import { type GetEnsNameErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsName`](https://viem.sh/docs/ens/actions/getEnsName.html)
</file>

<file path="core/api/actions/getEnsResolver.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsResolver'
const typeName = 'GetEnsResolver'
</script>

# getEnsResolver

Action for fetching ENS resolver for name.

## Import

```ts
import { getEnsResolver } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = getEnsResolver(config, {
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsResolver`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsResolverParameters } from '@wagmi/core'
```

---

### blockNumber

`bigint | undefined`

Block number to get resolver at.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = getEnsResolver(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get resolver at.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = getEnsResolver(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = await getEnsResolver(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the resolver for.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = await getEnsResolver(config, {
  name: normalize('wevm.eth'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsResolver } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensResolver = await getEnsResolver(config, {
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsResolverReturnType } from '@wagmi/core'
```

`Address`

The address of the resolver.

## Error

```ts
import { type getEnsResolverError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsResolver`](https://viem.sh/docs/ens/actions/getEnsResolver.html)
</file>

<file path="core/api/actions/getEnsText.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getEnsText'
const typeName = 'GetEnsText'
</script>

# getEnsText

Action for fetching a text record for a specified ENS name and key.

## Import

```ts
import { getEnsText } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = getEnsText(config, {
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsText`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type GetEnsTextParameters } from '@wagmi/core'
```

---

### blockNumber

`bigint | undefined`

Block number to get the text at.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = getEnsText(config, {
  blockNumber: 17829139n, // [!code focus]
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the text at.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = getEnsText(config, {
  blockTag: 'latest', // [!code focus]
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  chainId: mainnet.id, // [!code focus]
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### key

`string`

ENS key to get Text for.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  name: normalize('wevm.eth'),
  key: 'com.twitter', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### name

`string`

Name to get the text for.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  name: normalize('wevm.eth'), // [!code focus]
  key: 'com.twitter',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { getEnsText } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

const ensText = await getEnsText(config, {
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetEnsTextReturnType } from '@wagmi/core'
```

`string | null`

The text record for ENS name.

Returns `null` if name does not have text assigned.

## Error

```ts
import { type getEnsTextError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html)
</file>

<file path="core/api/actions/getFeeHistory.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getFeeHistory'
const typeName = 'GetFeeHistory'
</script>

# getFeeHistory

Action for fetching a collection of historical gas information.

## Import

```ts
import { getFeeHistory } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  rewardPercentiles: [25, 75]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetFeeHistoryParameters } from '@wagmi/core'
```

### blockCount

`number`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4, // [!code focus]
  rewardPercentiles: [25, 75]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### rewardPercentiles

`number[]`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  rewardPercentiles: [25, 75] // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Highest number block of the requested range.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  blockNumber: 1551231n, // [!code focus]
  rewardPercentiles: [25, 75],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag of the highest number block of the requested range.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  blockTag: 'safe', // [!code focus]
  rewardPercentiles: [25, 75],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getFeeHistory } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const feeHistory = await getFeeHistory(config, {
  blockCount: 4,
  chainId: mainnet.id, // [!code focus]
  rewardPercentiles: [25, 75],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetFeeHistoryReturnType } from '@wagmi/core'
```

[`FeeHistory`](https://viem.sh/docs/glossary/types.html#feehistory)

The fee history.

## Error

```ts
import { type GetFeeHistoryErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getFeeHistory`](https://viem.sh/docs/actions/public/getFeeHistory.html)
</file>

<file path="core/api/actions/getGasPrice.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getGasPrice'
const typeName = 'GetGasPrice'
</script>

# getGasPrice

Action for fetching the current price of gas (in wei).

## Import

```ts
import { getGasPrice } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getGasPrice } from '@wagmi/core'
import { config } from './config'

const gasPrice = await getGasPrice(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetGasPriceParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getGasPrice } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const gasPrice = await getGasPrice(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetGasPriceReturnType } from '@wagmi/core'
```

`bigint`

Current price of gas (in wei).

## Error

```ts
import { type GetGasPriceErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getGasPrice`](https://viem.sh/docs/actions/public/getGasPrice.html)
</file>

<file path="core/api/actions/getProof.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getProof'
const typeName = 'getProof'
</script>

# getProof

Action for return the account and storage values of the specified account including the Merkle-proof.

## Import

```ts
import { getProof } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetProofParameters } from '@wagmi/core'
```

### address

`Address`

The account address to get the proof for.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016', // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### storageKeys

`` `0x${string}`[] ``

Array of storage-keys that should be proofed and included.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [ // [!code focus:3]
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Proof at a given block number.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  blockNumber: 42069n, // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Proof at a given block tag.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'

await getProof(config, {
  address: '0x4200000000000000000000000000000000000016',
  blockTag: 'latest', // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to get the proof for.

::: code-group
```ts [index.ts]
import { getProof } from '@wagmi/core'
import { config } from './config'
import { optimism } from '@wagmi/core/chains'

await getProof(config, {
  chainId: optimism.id, // [!code focus]
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetProofReturnType } from '@wagmi/core'
```

`Proof`

Proof data.

## Error

```ts
import { type GetProofErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getProof`](https://viem.sh/docs/actions/public/getProof.html)
</file>

<file path="core/api/actions/getPublicClient.md">
# getPublicClient

Action for getting Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

## Import

```ts
import { getPublicClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getPublicClient } from '@wagmi/core'
import { config } from './config'

const client = getPublicClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`getClient`](/core/api/actions/getClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Public Client has all public actions attached directly to it.
:::

## Parameters

```ts
import { type GetClientParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Public Client.

::: code-group
```ts [index.ts]
import { getPublicClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = getPublicClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetPublicClientReturnType } from '@wagmi/core'
```

`PublicClient | undefined`

Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.
</file>

<file path="core/api/actions/getStorageAt.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getStorageAt'
const typeName = 'getStorageAt'
</script>

# getStorageAt

Action for returning the value from a storage slot at a given address.

## Import

```ts
import { getStorageAt } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetStorageAtParameters } from '@wagmi/core'
```

### address

`Address`

The contract address.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### slot

`Hex`

The storage position (as a hex encoded value).

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: '0x0', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the storage at.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockNumber: 16280770n, // [!code focus]
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the storage at.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { config } from './config'

await getStorageAt(config, {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockTag: 'safe', // [!code focus]
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the storage at.

::: code-group
```ts [index.ts]
import { getStorageAt } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await getStorageAt(config, {
  chainId: mainnet.id, // [!code focus]
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: '0x0',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetStorageAtReturnType } from '@wagmi/core'
```

`Hex`

The value of the storage slot.

## Error

```ts
import { type GetStorageAtErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getStorageAt`](https://viem.sh/docs/contract/getStorageAt)
</file>

<file path="core/api/actions/getToken.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getToken'
const typeName = 'GetToken'
</script>

# getToken

Action for fetching token info.

## Import

```ts
import { getToken } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { config } from './config'

const token = getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTokenParameters } from '@wagmi/core'
```

### address

`Address`

Address to get token for.

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { config } from './config'

const token = getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const token = await getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { getToken } from '@wagmi/core'
import { config } from './config'

const token = getToken(config, {
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  formatUnits: 'ether', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTokenReturnType } from '@wagmi/core'
```

### address 

`Address`

Address of token.

### decimals 

`number`

Number of decimals for token.

### name 

`string | undefined`

Name of token.

### symbol 

`string | undefined`

Symbol of token.

### totalSupply 

`{ formatted: string; value: bigint; }`

Total supply of token. `formatted` is formatted using [`formatUnits`](#formatunits).

## Error

```ts
import { type GetTokenErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`multicall`](https://viem.sh/docs/contract/multicall)
</file>

<file path="core/api/actions/getTransaction.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransaction'
const typeName = 'GetTransaction'
</script>

# getTransaction

Action for fetching transactions given hashes or block identifiers.

## Import

```ts
import { getTransaction } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionParameters } from '@wagmi/core'
```

---

### blockHash

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  index: 0,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockNumber: 17829139n, // [!code focus]
  index: 0,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockTag: 'safe', // [!code focus]
  index: 0,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const transaction = await getTransaction(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### hash

`` `0x${string}` | undefined ``

Hash to get transaction.

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### index

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)).

::: code-group
```ts [index.ts]
import { getTransaction } from '@wagmi/core'
import { config } from './config'

const transaction = getTransaction(config, {
  blockTag: 'safe',
  index: 0  // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTransactionReturnType } from '@wagmi/core'
```

[`Transaction`](https://viem.sh/docs/glossary/types.html#transaction)

## Error

```ts
import { type GetTransactionErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransaction`](https://viem.sh/docs/actions/public/getTransaction.html)
</file>

<file path="core/api/actions/getTransactionConfirmations.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransactionConfirmations'
const typeName = 'GetTransactionConfirmations'
</script>

# getTransactionConfirmations

Action for fetching the number of blocks passed (confirmations) since the transaction was processed on a block. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

## Import

```ts
import { getTransactionConfirmations } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { config } from './config'

const transaction = getTransactionConfirmations(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionConfirmationsParameters } from '@wagmi/core'
```

---

### hash

`` `0x${string}` | undefined ``

The hash of the transaction.

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { config } from './config'

const transaction = getTransactionConfirmations(config, {
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### transactionReceipt

`TransactionReceipt | undefined`

The transaction receipt.

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { config } from './config'

const transaction = getTransactionConfirmations(config, {
  transactionReceipt: { ... }, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getTransactionConfirmations } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const transaction = await getTransactionConfirmations(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTransactionConfirmationsReturnType } from '@wagmi/core'
```

`bigint`

The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

## Error

```ts
import { type GetTransactionConfirmationsErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransactionConfirmations`](https://viem.sh/docs/actions/public/getTransactionConfirmations.html)
</file>

<file path="core/api/actions/getTransactionCount.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransactionCount'
const typeName = 'GetTransactionCount'
</script>

# getTransactionCount

Action for fetching the number of transactions an Account has sent.

## Import

```ts
import { getTransactionCount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionCountParameters } from '@wagmi/core'
```

---

### address

`Address`

The address of the account.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Get the count at a block number.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Get the count at a block tag.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  blockTag: 'latest', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { getTransactionCount } from '@wagmi/core'
import { config } from './config'

const transactionCount = getTransactionCount(config, {
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::


## Return Type

```ts
import { type GetTransactionCountReturnType } from '@wagmi/core'
```

`number`

The number of transactions an account has sent.

## Error

```ts
import { type GetTransactionCountErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransactionCount`](https://viem.sh/docs/actions/public/getTransactionCount.html)
</file>

<file path="core/api/actions/getTransactionReceipt.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getTransactionReceipt'
const typeName = 'getTransactionReceipt'
</script>

# getTransactionReceipt

Action for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

## Import

```ts
import { getTransactionReceipt } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getTransactionReceipt } from '@wagmi/core'
import { config } from './config'

await getTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type GetTransactionReceiptParameters } from '@wagmi/core'
```

### hash

`` `0x${string}` ``

A transaction hash.

::: code-group
```ts [index.ts]
import { getTransactionReceipt } from '@wagmi/core'
import { config } from './config'

await getTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

::: code-group
```ts [index.ts]
import { getTransactionReceipt } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await getTransactionReceipt(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetTransactionReceiptReturnType } from '@wagmi/core'
```

[`TransactionReceipt`](https://viem.sh/docs/glossary/types.html#transactionreceipt)

The transaction receipt.

## Error

```ts
import { type GetTransactionReceiptErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`getTransactionReceipt`](https://viem.sh/docs/actions/public/getTransactionReceipt.html)
</file>

<file path="core/api/actions/getWalletClient.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'getWalletClient'
const typeName = 'GetWalletClient'
</script>

# getWalletClient

Action for getting a Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

## Import

```ts
import { getWalletClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getWalletClient } from '@wagmi/core'
import { config } from './config'

const client = getWalletClient(config)
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`getConnectorClient`](/core/api/actions/getConnectorClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Wallet Client has all wallet actions attached directly to it.
:::

## Parameters

```ts
import { type GetWalletClientParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { getWalletClient } from '@wagmi/core'
import { config } from './config'

const client = getWalletClient(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

::: code-group
```ts [index.ts]
import { getWalletClient } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const client = getWalletClient(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getConnections, getWalletClient } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const client = getWalletClient(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type GetChainIdReturnType } from '@wagmi/core'
```

`WalletClient`

Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

## Error

```ts
import { type GetWalletClientErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->
</file>

<file path="core/api/actions/multicall.md">
# multicall

Action for batching up multiple functions on a contract in a single RPC call via the [Multicall3 contract](https://github.com/mds1/multicall).

## Import

```ts
import { multicall } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { multicall } from '@wagmi/core'
import { config } from './config'

const wagmigotchiContract = {
  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: wagmigotchiABI,
} as const
const mlootContract = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: mlootABI,
} as const

const result = await multicall(config, {
  contracts: [
    {
      ...wagmigotchiContract,
      functionName: 'getAlive',
    },
    {
      ...wagmigotchiContract,
      functionName: 'getBoredom',
    },
    {
      ...mlootContract,
      functionName: 'getChest',
      args: [69],
    },
    {
      ...mlootContract,
      functionName: 'getWaist',
      args: [69],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type MulticallParameters } from '@wagmi/core'
```

### contracts

`readonly Contract[]`

Set of contracts to call.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI, // [!code hl]
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df', // [!code hl]
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69], // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
      chainId: 1, // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::


#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest', // [!code hl]
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### allowFailure

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `multicall` will fail silently and its error will be logged in the results array. Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  allowFailure: false, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### batchSize

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  batchSize: 1_024, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number`

The block number to perform the read against.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  blockNumber: 69420n, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  blockTag: 'safe', // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### multicallAddress

`Address`

Address of multicall contract.

::: code-group
```tsx [index.tsx]
import { multicall } from '@wagmi/core'
import { config } from './config'

const result = await multicall(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
  multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11', // [!code hl]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::


## Return Type

```ts
import { type MulticallReturnType } from '@wagmi/core'
```

## Type Inference

With [`contracts[number]['abi']`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type MulticallErrorType } from '@wagmi/core'
```

## Viem

- [`multicall`](https://viem.sh/docs/actions/public/multicall.html)
</file>

<file path="core/api/actions/prepareTransactionRequest.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'prepareTransactionRequest'
const typeName = 'prepareTransactionRequest'
</script>

# prepareTransactionRequest

Action for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

## Import

```ts
import { prepareTransactionRequest } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type PrepareTransactionRequestParameters } from '@wagmi/core'
```

### account

`Account | Address | undefined`

The Account to send the transaction from. 

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`` `0x${string}` | undefined ``

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',  // [!code focus]
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to prepare the transaction request for.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  chainId: mainnet.id, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
  nonce: 5, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### parameters

`("fees" | "gas" | "nonce" | "type")[] | undefined`

Parameters to prepare.

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  parameters: ['gas', 'nonce'], // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { prepareTransactionRequest } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

await prepareTransactionRequest(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type PrepareTransactionRequestReturnType } from '@wagmi/core'
```

[`TransactionRequest`](https://viem.sh/docs/glossary/types.html#transactionrequest)

The transaction request.

## Error

```ts
import { type PrepareTransactionRequestErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`prepareTransactionRequest`](https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html)
</file>

<file path="core/api/actions/readContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'readContract'
const typeName = 'ReadContract'
</script>

# readContract

Action for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

## Import

```ts
import { readContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ReadContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const result = await readContract(config, {
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address`

The contract's address.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'totalSupply',
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  blockTag: 'safe', // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'totalSupply',
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### functionName

`string`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { readContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await readContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf', // [!code focus]
  args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
})
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ReadContractReturnType } from '@wagmi/core'
```

`unknown`

- Result of contract read-only function.
- Inferred from [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args).

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type ReadContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`readContract`](https://viem.sh/docs/contract/readContract.html)
</file>

<file path="core/api/actions/readContracts.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'readContracts'
const typeName = 'ReadContracts'
</script>

# readContracts

Action for calling multiple read methods on a contract.

## Import

```ts
import { readContracts } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const wagmigotchiContract = {
  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: wagmigotchiABI,
} as const
const mlootContract = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: mlootABI,
} as const

const result = await readContracts(config, {
  contracts: [
    {
      ...wagmigotchiContract,
      functionName: 'getAlive',
    },
    {
      ...wagmigotchiContract,
      functionName: 'getBoredom',
    },
    {
      ...mlootContract,
      functionName: 'getChest',
      args: [69],
    },
    {
      ...mlootContract,
      functionName: 'getWaist',
      args: [69],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ReadContractsParameters } from '@wagmi/core'
```

### contracts

`readonly Contract[]`

Set of contracts to call.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI, // [!code hl]
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df', // [!code hl]
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69], // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
      chainId: 1, // [!code hl]
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::


#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest', // [!code hl]
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### allowFailure

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `readContracts` will fail silently and its error will be logged in the results array. Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  allowFailure: false, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### batchSize

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  batchSize: 1_024, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number`

The block number to perform the read against.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  blockNumber: 69420n, // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  blockTag: 'safe', // [!code hl]
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### multicallAddress

`Address`

Address of multicall contract.

::: code-group
```tsx [index.tsx]
import { readContracts } from '@wagmi/core'
import { config } from './config'

const result = await readContracts(config, {
  contracts: [
    {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
      functionName: 'getChest',
      args: [69],
    },
    // ...
  ],
  multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11', // [!code hl]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type ReadContractsReturnType } from '@wagmi/core'
```

## Type Inference

With [`contracts[number]['abi']`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type ReadContractsErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`multicall`](https://viem.sh/docs/actions/public/multicall.html) when supported by current chain.
- [`readContract`](https://viem.sh/docs/contract/readContract.html) when multicall is not supported.
</file>

<file path="core/api/actions/reconnect.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'reconnect'
const typeName = 'Reconnect'
</script>

# reconnect

Action for reconnecting [connectors](/core/api/connectors).

## Import

```ts
import { reconnect } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { reconnect } from '@wagmi/core'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await reconnect(config, { connectors: [injected()] })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ReconnectParameters } from '@wagmi/core'
```

### connectors

`(CreateConnectorFn | Connector)[] | undefined`

- [Connectors](/core/api/connectors) to reconnect to.
- Defaults to [`Config['connectors']`](/core/api/createConfig#connectors).

::: code-group
```ts [index.ts]
import { reconnect } from '@wagmi/core'
import { injected } from '@wagmi/connectors'
import { config } from './config'

const result = await reconnect(config, {
    connectors: [injected()], // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ReconnectReturnType } from '@wagmi/core'
```

`Connection[]`

[Connections](/core/api/createConfig#connection) that were successfully reconnected.

## Error

```ts
import { type ReconnectErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="core/api/actions/sendCalls.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'sendCalls'
const typeName = 'SendCalls'
</script>

# sendCalls

Action that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { sendCalls } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SendCallsParameters } from '@wagmi/core/experimental'
```

### account

`Account | Address | null | undefined`

Account to execute the calls. 

If set to `null`, it is assumed that the wallet will handle filling the sender of the calls.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### calls

`{ to: Hex, data?: Hex, value?: bigint }[]`

Calls to execute.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [ // [!code focus]
    { // [!code focus]
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
      value: parseEther('1') // [!code focus]
    }, // [!code focus]
    { // [!code focus]
      data: '0xdeadbeef', // [!code focus]
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
    }, // [!code focus]
  ], // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### capabilities

`WalletCapabilities | undefined`

Capability metadata for the calls (e.g. specifying a paymaster).

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
  capabilities: { // [!code focus]
    paymasterService: { // [!code focus]
      url: 'https://...' // [!code focus]
    } // [!code focus]
  } // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`number | undefined`

The target chain ID to broadcast the calls.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
  chainId: 10, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get send the calls with.

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { getConnections } from '@wagmi/core'
import { sendCalls } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const id = await sendCalls(config, {
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      data: '0xdeadbeef',
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    },
  ],
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SendCallsReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type SendCallsErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`sendCalls`](https://viem.sh/experimental/eip5792/sendCalls)
</file>

<file path="core/api/actions/sendTransaction.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'sendTransaction'
const typeName = 'SendTransaction'
</script>

# sendTransaction

Action for creating, signing, and sending transactions to networks.

## Import

```ts
import { sendTransaction } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SendTransactionParameters } from '@wagmi/core'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when sending transaction. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  chainId: mainnet.id, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to send transaction with.
- Defaults to current connector.

::: code-group
```ts [index.ts]
import { getConnections, sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const connections = getConnections(config)
const result = await sendTransaction(config, {
  connector: connections[0]?.connector, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined | null`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  gas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  nonce: 123, // [!code focus]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### to

`Address`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  type: 'eip1559', // [!code focus]
  value: parseEther('0.01'),
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { sendTransaction } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

const result = await sendTransaction(config, {
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SendTransactionReturnType } from '@wagmi/core'
```

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

Transaction hash.

## Error

```ts
import { type SendTransactionErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html)
</file>

<file path="core/api/actions/showCallsStatus.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'showCallsStatus'
const typeName = 'ShowCallsStatus'
</script>

# showCallsStatus

Action to request for the wallet to show information about a call batch that was sent via `showCalls`.

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_showcallsstatus)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { showCallsStatus } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { showCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

await showCallsStatus(config, {
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type ShowCallsStatusParameters } from '@wagmi/core/experimental'
```

### connector

`Connector | undefined`

Connector to show call statuses with.

::: code-group
```ts [index.ts]
import { getConnections, showCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
await showCallsStatus(config, {
  connector: connections[0]?.connector, // [!code focus]
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { showCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

await showCallsStatus(config, {
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type ShowCallsStatusReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type ShowCallsStatusErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`showCallsStatus`](https://viem.sh/experimental/eip5792/showCallsStatus)
</file>

<file path="core/api/actions/signMessage.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'signMessage'
const typeName = 'SignMessage'
</script>

# signMessage

Action for signing messages.

## Import

```ts
import { signMessage } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { signMessage } from '@wagmi/core'
import { config } from './config'

await signMessage(config, { message: 'hello world' })
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SignMessageParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use when signing message. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { signMessage } from '@wagmi/core'
import { config } from './config'

const result = await signMessage(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  message: 'hello world',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign message with.

::: code-group
```ts [index.ts]
import { getAccount, signMessage } from '@wagmi/core'
import { config } from './config'

const { connector } = getAccount(config)
const result = await signMessage(config, {
  connector, // [!code focus]
  message: 'hello world',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### message

`string | { raw: Hex | ByteArray }`

Message to sign.

::: code-group
```ts [index.ts]
import { signMessage } from '@wagmi/core'
import { config } from './config'

const result = await signMessage(config, {
  message: 'hello world', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

```ts
import { signMessage } from '@wagmi/core'
import { config } from './config'

const result = await signMessage(config, {
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus]
})
```
:::

## Return Type

```ts
import { type SignMessageReturnType } from '@wagmi/core'
```

[`Hex`](https://viem.sh/docs/glossary/types.html#hex)

The signed message.

## Error

```ts
import { type SignMessageErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`signMessage`](https://viem.sh/docs/actions/wallet/signMessage.html)
</file>

<file path="core/api/actions/signTypedData.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'signTypedData'
const typeName = 'SignTypedData'
</script>

# signTypedData

Action for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

## Import

```ts
import { signTypedData } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'

const result = await signTypedData(config, {
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SignTypedDataParameters } from '@wagmi/core'
```

### account

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign data with.

::: code-group
```ts [index.ts]
import { getAccount, signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const { connector } = getAccount(config)
const result = await signTypedData(config, {
  connector, // [!code focus]
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### domain

`TypedDataDomain | undefined`

- The typed data domain.
- If `EIP712Domain` key exists in [`types`](#types), `domain` schema is inferred from it.

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  domain: { // [!code focus]
    name: 'Ether Mail', // [!code focus]
    chainId: 1, // [!code focus]
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC', // [!code focus]
    version: '1', // [!code focus]
  }, // [!code focus]
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### message

`Record<string, unknown>`

- Data to sign.
- Type inferred from [`types`](#types) and [`primaryType`](#primarytype).

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  types,
  primaryType: 'Mail',
  message: { // [!code focus]
    from: { // [!code focus]
      name: 'Cow', // [!code focus]
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826', // [!code focus]
    }, // [!code focus]
    to: { // [!code focus]
      name: 'Bob', // [!code focus]
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB', // [!code focus]
    }, // [!code focus]
    contents: 'Hello, Bob!', // [!code focus]
  }, // [!code focus]
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### primaryType

`string`

- The primary type to extract from [`types`](#types) and use in [`message`](#message).
- Type inferred from [`types`](#types).

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'
import { types } from './typedData'

const result = await signTypedData(config, {
  types,
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/typedData.ts[typedData.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### types

`TypedData`

- The type definitions for the typed data.
- By defining inline or adding a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) to `types`, TypeScript will infer the correct types for [`message`](#message) and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/core/typescript) for more information.

::: code-group
```ts [index.ts]
import { signTypedData } from '@wagmi/core'
import { config } from './config'

const result = await signTypedData(config, {
  types: { // [!code focus]
    Person: [ // [!code focus]
      { name: 'name', type: 'string' }, // [!code focus]
      { name: 'wallet', type: 'address' }, // [!code focus]
    ], // [!code focus]
    Mail: [ // [!code focus]
      { name: 'from', type: 'Person' }, // [!code focus]
      { name: 'to', type: 'Person' }, // [!code focus]
      { name: 'contents', type: 'string' }, // [!code focus]
    ], // [!code focus]
  }, // [!code focus]
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SignTypedDataReturnType } from '@wagmi/core'
```

[`Hex`](https://viem.sh/docs/glossary/types.html#hex)

The signed data.

## Type Inference

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/core/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { createConfig, http, signTypedData } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const result = await signTypedData(config, {
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
```ts twoslash [Const-Asserted]
import { createConfig, http, signTypedData } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const

const result = await signTypedData(config, {
  types,
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
:::

## Error

```ts
import { type SignTypedDataErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`signTypedData`](https://viem.sh/docs/actions/wallet/signTypedData.html)
</file>

<file path="core/api/actions/simulateContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'simulateContract'
const typeName = 'SimulateContract'
</script>

# simulateContract

Action for simulating/validating a contract interaction.

## Import

```ts
import { simulateContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SimulateContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const result = await simulateContract(config, {
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address`

The contract's address.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::


### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [ // [!code focus]
    '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    123n, // [!code focus]
  ], // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to simulate against.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  blockNumber: 17829139n, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to simulate against.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  blockTag: 'safe', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to simulate transaction with.

::: code-group
```ts [index.ts]
import { getAccount, simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const { connector } = getAccount(config)
const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  connector, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  dataSuffix: '0xdeadbeef', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### functionName

`string`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'approve', // [!code focus]
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 123n]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gasPrice: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  nonce: 123, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  type: 'eip1559', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { simulateContract } from '@wagmi/core'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SimulateContractReturnType } from '@wagmi/core'
```

The simulation result and write request.

### request

Write request that includes [parameters](#parameters).

### response

`unknown`

- Result of contract simulation.
- Inferred from [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args).

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type SimulateContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`simulateContract`](https://viem.sh/docs/contract/simulateContract.html)
</file>

<file path="core/api/actions/switchAccount.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'switchAccount'
const typeName = 'SwitchAccount'
</script>

# switchAccount

Action for switching the current account.

## Import

```ts
import { switchAccount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { getConnections, switchAccount } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const result = await switchAccount(config, {
  connector: connections[0]?.connector,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type SwitchAccountParameters } from '@wagmi/core'
```

### connector

`Connector`

[Connector](/core/api/connectors) to switch to.

::: code-group
```ts [index.ts]
import { getConnections, switchAccount } from '@wagmi/core'
import { config } from './config'

const connections = getConnections(config)
const result = await switchAccount(config, {
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SwitchAccountReturnType } from '@wagmi/core'
```

### accounts

`readonly [Address, ...Address[]]`
  
Connected accounts from connector.

### chainId

`number`

Connected chain ID from connector.

## Error

```ts
import { type SwitchAccountErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->
</file>

<file path="core/api/actions/switchChain.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'switchChain'
const typeName = 'SwitchChain'
</script>

# switchChain

Action for switching the target chain for a connector or the Wagmi [`Config`](/core/api/createConfig#config).

## Import

```ts
import { switchChain } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { switchChain } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await switchChain(config, { chainId: mainnet.id })
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](/core/api/createConfig#config).
:::

## Parameters

```ts
import { type SwitchChainParameters } from '@wagmi/core'
```

### addEthereumChainParameter

`{ chainName: string; nativeCurrency?: { name: string; symbol: string; decimals: number } | undefined; rpcUrls: readonly string[]; blockExplorerUrls?: string[] | undefined; iconUrls?: string[] | undefined } | undefined`

[EIP-3085 parameters](https://eips.ethereum.org/EIPS/eip-3085) to use when adding chain to connector (when supported).

::: code-group
```ts [index.ts]
import { switchChain } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await switchChain(config, {
  addEthereumChainParameter: { // [!code focus]
    iconUrls: ['https://example.com/icon.png'], // [!code focus]
  }, // [!code focus]
  chainId: mainnet.id,
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to switch to.

::: code-group
```ts [index.ts]
import { switchChain } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const result = await switchChain(config, {
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector`

[Connector](/core/api/connectors) to switch chain with.

::: code-group
```ts [index.ts]
import { getConnections, switchAccount } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const connections = getConnections(config)
const result = await switchChain(config, {
  chainId: mainnet.id,
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type SwitchChainReturnType } from '@wagmi/core'
```

`Chain`

Chain that was switched to.

## Error

```ts
import { type SwitchChainErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`switchChain`](https://viem.sh/docs/actions/wallet/switchChain.html) when connected.
</file>

<file path="core/api/actions/verifyMessage.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'verifyMessage'
const typeName = 'VerifyMessage'
</script>

# verifyMessage

Action for verify that a message was signed by the provided address. It supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { verifyMessage } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type VerifyMessageParameters } from '@wagmi/core'
```

### address

`Address`

The Ethereum address that signed the original message.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### message

`string | { raw: Hex | ByteArray }`

The message to be verified.

By default, wagmi verifies the UTF-8 representation of the message.

::: code-group
```ts [index.ts]
import { getAccount, verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

::: tip
By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

```ts
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: { raw: '0x68656c6c6f20776f726c64' } // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
:::

### signature

`Hex | ByteArray `

The signature that was generated by signing the message with the address's signer.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

await verifyMessage(config, {
  chainId: mainnet.id, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  blockNumber: 12345678n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyMessage } from '@wagmi/core'
import { config } from './config'

await verifyMessage(config, {
  blockTag: 'latest', // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type VerifyMessageReturnType } from '@wagmi/core'
```

`boolean`

Whether the signed message is valid for the given address.

## Error

```ts
import { type VerifyMessageErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`verifyMessage`](https://viem.sh/docs/actions/public/verifyMessage.html)
</file>

<file path="core/api/actions/verifyTypedData.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'verifyTypedData'
const typeName = 'verifyTypedData'
</script>

# verifyTypedData

Action for verify that a typed data was signed by the provided address. It supports verifying typed data that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { verifyTypedData } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type VerifyTypedDataParameters } from '@wagmi/core'
```

### address

`Address`

The Ethereum address that signed the original typed data.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### domain

`TypedDataDomain`

The typed data domain.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### types

The type definitions for the typed data.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### primaryType

`string`

The primary `type` to extract from types and use in `value`.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail', // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### message

Type inferred from `types` & `primaryType`.

The message to be verified.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### signature

`Hex | ByteArray`

The signature that was generated by signing the typed data with the address's signer.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },  
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  chainId: mainnet.id, // [!code focus]
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  blockNumber: 12345678n, // [!code focus]
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```ts [index.ts]
import { verifyTypedData } from '@wagmi/core'
import { domain, types } from './data'
import { config } from './config'

const valid = await verifyTypedData(config, {
  blockTag: 'latest', // [!code focus]
  domain,
  types,
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  primaryType: 'Mail',
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
// true
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type VerifyTypedDataReturnType } from '@wagmi/core'
```

`boolean`

Whether the signed message is valid for the given address.

## Type Inference

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type VerifyTypedDataErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`verifyTypedData`](https://viem.sh/docs/actions/public/verifyTypedData.html)
</file>

<file path="core/api/actions/waitForCallsStatus.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'waitForCallsStatus'
const typeName = 'WaitForCallsStatus'
</script>

# waitForCallsStatus

Waits for a call bundle to be confirmed & included on a block before returning the status & receipts.

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { waitForCallsStatus } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { parseEther } from 'viem'
import { sendCalls, waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const id = await sendCalls(config, {
  calls: [{
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1')
  }]
})

const { status, receipts } = await waitForCallsStatus(config, { // [!code focus]
  id, // [!code focus]
}) // [!code focus]
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WaitForCallsStatusParameters } from '@wagmi/core/experimental'
```

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```ts [index.ts]
import { getConnections, waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const connections = getConnections(config)
const status = await waitForCallsStatus(config, {
  connector: connections[0]?.connector, // [!code focus]
  id: '0x1234567890abcdef',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await waitForCallsStatus(config, {
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number`

Polling interval in milliseconds.

::: code-group
```ts [index.ts]
import { waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await waitForCallsStatus(config, {
  id: '0x1234567890abcdef',
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### timeout

`number`

Timeout in milliseconds before `waitForCallsStatus` stops polling.

::: code-group
```ts [index.ts]
import { waitForCallsStatus } from '@wagmi/core/experimental'
import { config } from './config'

const status = await waitForCallsStatus(config, {
  id: '0x1234567890abcdef',
  timeout: 10_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WaitForCallsStatusReturnType } from '@wagmi/core/experimental'
```

`{ status: 'PENDING' | 'CONFIRMED', receipts: TransactionReceipt[] }`

The status and receipts of the call batch.

## Error

```ts
import { type WaitForCallsStatusErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`waitForCallsStatus`](https://viem.sh/experimental/eip5792/waitForCallsStatus)
</file>

<file path="core/api/actions/waitForTransactionReceipt.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'waitForTransactionReceipt'
const typeName = 'WaitForTransactionReceipt'
</script>

# waitForTransactionReceipt

Action that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

## Import

```ts
import { waitForTransactionReceipt } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WaitForTransactionReceiptParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  chainId: mainnet.id, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### confirmations

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  confirmations: 2, // [!code focus]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onReplaced

`
(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined
`

Optional callback to emit if the transaction has been replaced.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  onReplaced: replacement => console.log(replacement), // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### hash

`` `0x${string}` ``

The transaction hash to wait for.

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { waitForTransactionReceipt } from '@wagmi/core'
import { config } from './config'

const transactionReceipt = await waitForTransactionReceipt(config, {
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WaitForTransactionReceiptReturnType } from '@wagmi/core'
```

[`TransactionReceipt`](https://viem.sh/docs/glossary/types.html#transactionreceipt)

The transaction receipt.

## Error

```ts
import { type WaitForTransactionReceiptErrorType } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`waitForTransactionReceipt`](https://viem.sh/docs/actions/public/waitForTransactionReceipt.html)
</file>

<file path="core/api/actions/watchAccount.md">
# watchAccount

Subscribe to account changes.

## Import

```ts
import { watchAccount } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchAccount } from '@wagmi/core'
import { config } from './config'

const unwatch = watchAccount(config, {
  onChange(data) {
    console.log('Account changed!', data)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchAccountParameters } from '@wagmi/core'
```

### onChange

`onChange(account: GetAccountReturnType, prevAccount: GetAccountReturnType): void`

Callback function called when account changes.

::: code-group
```ts [index.ts]
import { watchAccount } from '@wagmi/core'
import { config } from './config'

const unwatch = watchAccount(config, {
  onChange(account) { // [!code focus:3]
    console.log('Account changed!', account)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchAccountReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="core/api/actions/watchAsset.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'watchAsset'
const typeName = 'WatchAsset'
</script>

# watchAsset

Action for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

## Import

```ts
import { watchAsset } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchAsset } from '@wagmi/core'
import { config } from './config'

await watchAsset(config, {
  type: 'ERC20',
  options: {
    address: '0x0000000000000000000000000000000000000000',
    symbol: 'WAGMI',
    decimals: 18,
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchAssetParameters } from '@wagmi/core'
```

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign message with.

::: code-group
```ts [index.ts]
import { getAccount, watchAsset } from '@wagmi/core'
import { config } from './config'

const { connector } = getAccount(config)
const result = await watchAsset(config, {
  connector, // [!code focus]
  options: {
    address: '0x0000000000000000000000000000000000000000',
    symbol: 'WAGMI',
    decimals: 18,
  },
  type: 'ERC20',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### options

`{ address: string; symbol: string; decimals: number; image?: string | undefined; }`

Asset options.

::: code-group
```ts [index.ts]
import { watchAsset } from '@wagmi/core'
import { config } from './config'

const result = await watchAsset(config, {
  options: { // [!code focus]
    address: '0x0000000000000000000000000000000000000000', // [!code focus]
    symbol: 'WAGMI', // [!code focus]
    decimals: 18, // [!code focus]
  }, // [!code focus]
  type: 'ERC20',
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'ERC20'`

Type of asset.

::: code-group
```ts [index.ts]
import { watchAsset } from '@wagmi/core'
import { config } from './config'

const result = await watchAsset(config, {
  options: {
    address: '0x0000000000000000000000000000000000000000',
    symbol: 'WAGMI',
    decimals: 18,
  },
  type: 'ERC20', // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchAssetReturnType } from '@wagmi/core'
```

`boolean`

Returns a boolean indicating if the token was successfully added.

## Error

```ts
import { type WatchAssetErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`watchAsset`](https://viem.sh/docs/actions/wallet/watchAsset.html)
</file>

<file path="core/api/actions/watchBlockNumber.md">
# watchBlockNumber

Action that watches for block number changes.

## Import

```ts
import { watchBlockNumber } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchBlockNumberParameters } from '@wagmi/core'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  chainId: mainnet.id, // [!code focus]
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean | undefined`

Whether or not to emit the latest block number to the callback when the subscription opens.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  emitOnBegin: true, // [!code focus]
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean | undefined`

Whether or not to emit the missed block numbers to the callback.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  emitMissed: true, // [!code focus]
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::


### onBlockNumber

`(blockNumber: bigint, prevBlockNumber: bigint | undefined) => void`

Callback for when block number changes.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { // [!code focus]
    console.log('Block number changed!', blockNumber) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { 
    console.log('Block number changed!', blockNumber) 
  }, 
  onError(error) { // [!code focus]
    console.error('Block number error', error) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { 
    console.log('Block number changed!', blockNumber) 
  }, 
  poll: true, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) { 
    console.log('Block number changed!', blockNumber) 
  }, 
  pollingInterval: 1_000, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchBlockNumber } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlockNumber(config, {
  onBlockNumber(blockNumber) {
    console.log('Block number changed!', blockNumber)
  },
  syncConnectedChain: false, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchBlockNumberReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.

## Viem

- [`watchBlockNumber`](https://viem.sh/docs/actions/public/watchBlockNumber.html)
</file>

<file path="core/api/actions/watchBlocks.md">
# watchBlocks

Action that watches for block changes.

## Import

```ts
import { watchBlocks } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchBlocksParameters } from '@wagmi/core'
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Watch for new blocks on a given tag. Defaults to `'latest'`.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  blockTag: 'pending', // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const unwatch = watchBlocks(config, {
  chainId: mainnet.id, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  emitMissed: true, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  emitOnBegin: true, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onBlock

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) { // [!code focus]
    console.log('Block changed!', block) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) { 
    console.log('Block changed!', block) 
  }, 
  onError(error) { // [!code focus]
    console.error('Block error', error) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  poll: true, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  pollingInterval: 1_000, // [!code focus]
  onBlock(block) {
    console.log('Block changed!', block)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchBlocks } from '@wagmi/core'
import { config } from './config'

const unwatch = watchBlocks(config, {
  onBlock(block) {
    console.log('Block changed!', block)
  },
  syncConnectedChain: false, // [!code focus]
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchBlocksReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.

## Viem

- [`watchBlocks`](https://viem.sh/docs/actions/public/watchBlocks.html)
</file>

<file path="core/api/actions/watchChainId.md">
# watchChainId

Subscribe to chain ID changes.

## Import

```ts
import { watchChainId } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchChainId } from '@wagmi/core'
import { config } from './config'

const unwatch = watchChainId(config, {
  onChange(chainId) {
    console.log('Chain ID changed!', chainId)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchChainIdParameters } from '@wagmi/core'
```

### onChange

`onChange(chainId: GetChainIdReturnType, prevChainId: GetChainIdReturnType): void`

Callback function called when chain ID changes.

::: code-group
```ts [index.ts]
import { watchChainId } from '@wagmi/core'
import { config } from './config'

const unwatch = watchChainId(config, {
  onChange(chainId) { // [!code focus:3]
    console.log('Chain ID changed!', chainId)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchChainIdReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="core/api/actions/watchClient.md">
# watchClient

Subscribe to Client changes.

## Import

```ts
import { watchClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchClient(config, {
  onChange(client) {
    console.log('Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchClientParameters } from '@wagmi/core'
```

### onChange

`onChange(client: GetClientReturnType, prevClient: GetClientReturnType): void`

Callback function called when Client changes.

::: code-group
```ts [index.ts]
import { watchClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchClient(config, {
  onChange(client) { // [!code focus:3]
    console.log('Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchClientReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="core/api/actions/watchConnections.md">
# watchConnections

Subscribe to connections changes.

## Import

```ts
import { watchConnections } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchConnections } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnections(config, {
  onChange(data) {
    console.log('Connections changed!', data)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchConnectionsParameters } from '@wagmi/core'
```

### onChange

`onChange(connections: GetConnectionsReturnType, prevConnections: GetConnectionsReturnType): void`

Callback function called when connections changes.

::: code-group
```ts [index.ts]
import { watchConnections } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnections(config, {
  onChange(data) { // [!code focus:3]
    console.log('Connections changed!', data)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchConnectionsReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="core/api/actions/watchConnectors.md">
# watchConnectors

Subscribe to connectors changes.

## Import

```ts
import { watchConnectors } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchConnectors } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnectors(config, {
  onChange(connectors) {
    console.log('Connectors changed!', connectors)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchConnectorsParameters } from '@wagmi/core'
```

### onChange

`onChange(connectors: GetConnectorsReturnType, prevConnectors: GetConnectorsReturnType): void`

Callback function called when connectors changes.

::: code-group
```ts [index.ts]
import { watchConnectors } from '@wagmi/core'
import { config } from './config'

const unwatch = watchConnectors(config, {
  onChange(connectors) { // [!code focus:3]
    console.log('Connectors changed!', connectors)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchConnectorsReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="core/api/actions/watchContractEvent.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'watchContractEvent'
const typeName = 'WatchContractEvent'
</script>

# watchContractEvent

Action that watches and returns emitted contract event logs.

## Import

```ts
import { watchContractEvent } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  abi,
  eventName: 'Transfer',
  onLogs(logs) {
    console.log('New logs!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchContractEventParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### args

`object | readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`eventName`](#eventname).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  args: { // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  }, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### batch

`boolean | undefined`

- Whether or not the events should be batched on each invocation.
- Defaults to `true`.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  batch: false, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  chainId: mainnet.id, // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### eventName

`string`

- Event to listen for the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  eventName: 'Approval', // [!code focus]
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) { 
    console.log('Logs changed!', logs) 
  }, 
  onError(error) { // [!code focus]
    console.error('Logs error', error) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### onLogs

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) { // [!code focus]
    console.log('Logs changed!', logs) // [!code focus]
  }, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  poll: true, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  pollingInterval: 1_000, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### strict

`boolean | undefined`

- Defaults to `false`.

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  strict: true, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchContractEvent } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const unwatch = watchContractEvent(config, {
  abi,
  onLogs(logs) {
    console.log('Logs changed!', logs)
  },
  syncConnectedChain: false, // [!code focus]
})
unwatch()
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchContractEventReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`eventName`](#eventname), [`args`](#args), and [`onLogs`](#onlogs) parameters. See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type WatchContractEventError } from '@wagmi/core'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`watchContractEvent`](https://viem.sh/docs/contract/watchContractEvent.html)
</file>

<file path="core/api/actions/watchPendingTransactions.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'watchPendingTransactions'
const typeName = 'WatchPendingTransactions'
</script>

# watchPendingTransactions

Action that watches and returns pending transaction hashes.

## Import

```ts
import { watchPendingTransactions } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchPendingTransactionsParameters } from '@wagmi/core'
```

### batch

`boolean | undefined`

- Whether or not the transactions should be batched on each invocation.
- Defaults to `true`.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'

const unwatch = watchPendingTransactions(config, {
  batch: false, // [!code focus]
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { mainnet } from '@wagmi/core/chains'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  chainId: mainnet.id, // [!code focus]
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from watching pending transactions.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onError(error) { // [!code focus]
    console.log('Error', error) // [!code focus]
  }, // [!code focus]
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onTransactions

`(transactions: Hash[], prevTransactions: Hash[] | undefined) => void`

Callback when new incoming pending transactions are detected.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) { // [!code focus]
    console.log('New transactions!', transactions) // [!code focus]
  }, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
  poll: false, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { watchPendingTransactions } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPendingTransactions(config, {
  onTransactions(transactions) {
    console.log('New transactions!', transactions)
  },
  syncConnectedChain: false, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchPendingTransactionsReturnType } from '@wagmi/core'
```

Function to unsubscribe from pending transaction listener.

## Error

```ts
import { type WatchPendingTransactionsError } from '@wagmi/core'
```

## Viem

- [`watchPendingTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html)
</file>

<file path="core/api/actions/watchPublicClient.md">
# watchPublicClient

Subscribe to Public Client changes.

## Import

```ts
import { watchPublicClient } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { watchPublicClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPublicClient(config, {
  onChange(client) {
    console.log('Public Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WatchPublicClientParameters } from '@wagmi/core'
```

### onChange

`onChange(client: GetPublicClientReturnType, prevClient: GetPublicClientReturnType): void`

Callback function called when Public Client changes.

::: code-group
```ts [index.ts]
import { watchPublicClient } from '@wagmi/core'
import { config } from './config'

const unwatch = watchPublicClient(config, {
  onChange(client) { // [!code focus:3]
    console.log('Public Client changed!', client)
  },
})
unwatch()
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WatchPublicClientReturnType } from '@wagmi/core'
```

Function for cleaning up watcher.
</file>

<file path="core/api/actions/writeContract.md">
<script setup>
const packageName = '@wagmi/core'
const actionName = 'writeContract'
const typeName = 'WriteContract'
</script>

# writeContract

Action for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

## Import

```ts
import { writeContract } from '@wagmi/core'
```

## Usage

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

::::tip Pairing with `simulateContract`

Pairing [`simulateContract`](/core/api/actions/simulateContract) with `writeContract` allows you to validate if the transaction will succeed ahead of time. If the simulate succeeds, `writeContract` can execute the transaction.

::: code-group
```ts [index.ts]
import { simulateContract, writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const { request } = await simulateContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
const hash = await writeContract(config, request)
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::
::::


## Parameters

```ts
import { type WriteContractParameters } from '@wagmi/core'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi' // [!code focus]
import { config } from './config'

const result = await writeContract(config, {
  abi, // [!code focus]
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  accessList: [{ // [!code focus]
    address: '0x1', // [!code focus]
    storageKeys: ['0x1'], // [!code focus]
  }], // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### address

`Address`

The contract's address.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::


### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [ // [!code focus]
    '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    123n, // [!code focus]
  ] // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  chainId: mainnet.id, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/core/api/connectors) to sign data with.

::: code-group
```ts [index.ts]
import { getAccount, writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const { connector } = getAccount(config)
const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  connector, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  dataSuffix: '0xdeadbeef', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### functionName

`string`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'approve', // [!code focus]
  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 123n]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::


### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  gasPrice: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  nonce: 123, // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  type: 'eip1559', // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { writeContract } from '@wagmi/core'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

const result = await writeContract(config, {
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'transferFrom',
  args: [
    '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    123n,
  ],
  value: parseEther('0.01'), // [!code focus]
})
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WriteContractReturnType } from '@wagmi/core'
```

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

The transaction hash.

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/core/typescript) for more information.

## Error

```ts
import { type WriteContractErrorType } from '@wagmi/core'
```

<!--@include: @shared/mutation-imports.md-->

## Viem

- [`writeContract`](https://viem.sh/docs/contract/writeContract.html)
</file>

<file path="core/api/actions/writeContracts.md">
<script setup>
const packageName = '@wagmi/core/experimental'
const actionName = 'writeContracts'
const typeName = 'WriteContracts'
</script>

# writeContracts

Action that requests for the wallet to sign and broadcast a batch of write contract calls (transactions) to the network.

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { writeContracts } from '@wagmi/core/experimental'
```

## Usage

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Parameters

```ts
import { type WriteContractsParameters } from '@wagmi/core/experimental'
```

### account

`Account | Address | undefined`

Account to execute the calls.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### contracts

`{ to: Hex, data?: Hex, value?: bigint }[]`

Calls to execute.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [ // [!code focus]
    { // [!code focus]
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
      abi, // [!code focus]
      functionName: 'approve', // [!code focus]
      args: [ // [!code focus]
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
        100n // [!code focus]
      ], // [!code focus]
    }, // [!code focus]
    { // [!code focus]
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
      abi, // [!code focus]
      functionName: 'transferFrom', // [!code focus]
      args: [ // [!code focus]
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
        '0x0000000000000000000000000000000000000000', // [!code focus]
        100n // [!code focus]
      ], // [!code focus]
    }, // [!code focus]
  ], // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### capabilities

`WalletCapabilities | undefined`

Capability metadata for the calls (e.g. specifying a paymaster).

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
  capabilities: { // [!code focus]
    paymasterService: { // [!code focus]
      url: 'https://...' // [!code focus]
    } // [!code focus]
  } // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`number | undefined`

The target chain ID to broadcast the calls.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
  chainId: 10, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get send the calls with.

::: code-group
```ts [index.ts]
import { parseAbi } from 'viem'
import { getConnections } from '@wagmi/core'
import { writeContracts } from '@wagmi/core/experimental'
import { config } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

const connections = getConnections(config)
const id = await writeContracts(config, {
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'approve',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        100n
      ],
    },
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'transferFrom',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        '0x0000000000000000000000000000000000000000',
        100n
      ],
    },
  ],
  connector: connections[0]?.connector, // [!code focus]
})
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type WriteContractsReturnType } from '@wagmi/core/experimental'
```

`bigint`

Most recent block number seen.

## Error

```ts
import { type WriteContractsErrorType } from '@wagmi/core/experimental'
```

<!--@include: @shared/query-imports.md-->

## Viem

- [`writeContracts`](https://viem.sh/experimental/eip5792/writeContracts)
</file>

<file path="core/api/connectors/coinbaseWallet.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/coinbaseWallet.md -->
</file>

<file path="core/api/connectors/injected.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/injected.md -->
</file>

<file path="core/api/connectors/metaMask.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/metaMask.md -->
</file>

<file path="core/api/connectors/mock.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/mock.md -->
</file>

<file path="core/api/connectors/safe.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/safe.md -->
</file>

<file path="core/api/connectors/walletConnect.md">
<script setup>
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!-- @include: @shared/connectors/walletConnect.md -->
</file>

<file path="core/api/transports/custom.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/custom.md -->
</file>

<file path="core/api/transports/fallback.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/fallback.md -->
</file>

<file path="core/api/transports/http.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/http.md -->
</file>

<file path="core/api/transports/unstable_connector.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/unstable_connector.md -->
</file>

<file path="core/api/transports/webSocket.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!-- @include: @shared/transports/webSocket.md -->
</file>

<file path="core/api/utilities/cookieToInitialState.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/cookieToInitialState.md-->
</file>

<file path="core/api/utilities/deserialize.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/deserialize.md-->
</file>

<file path="core/api/utilities/normalizeChainId.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/normalizeChainId.md-->
</file>

<file path="core/api/utilities/serialize.md">
<script setup>
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/utilities/serialize.md-->
</file>

<file path="core/api/actions.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const actions = getSidebar()['/core']
  .find(x => x.text.includes('Actions')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Actions

Actions for accounts, wallets, contracts, transactions, signing, ENS, and more.

## Import

```ts
import { getAccount } from '@wagmi/core'
```

## Available Actions

<ul>
  <li v-for="action of actions">
    <a :href="action.link">{{ action.text }}</a>
  </li>
</ul>
</file>

<file path="core/api/chains.md">
<script setup>
import packageJson from '../../../package.json'
import SearchChains from '../../components/SearchChains.vue'

const viemVersion = packageJson.devDependencies.viem
</script>

# Chains

## Import

Import via the `'@wagmi/core/chains'` entrypoint (proxies all chains from `'viem/chains'`).

```ts
import { mainnet } from '@wagmi/core/chains'
```

## Available Chains

Chain definitions as of `viem@{{viemVersion}}`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

<SearchChains />

<!--@include: @shared/create-chain.md-->
</file>

<file path="core/api/connectors.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const connectors = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Connectors')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Connectors

Connectors for popular wallet providers and protocols.

## Import

```ts
import { injected } from 'wagmi/connectors'
```

## Built-In Connectors

Available via the `'wagmi/connectors'` entrypoint.

<ul>
  <li v-for="connector of connectors">
    <a :href="connector.link">{{ connector.text }}</a>
  </li>
</ul>
</file>

<file path="core/api/createConfig.md">
<script setup>
const docsPath = 'core'
const packageName = '@wagmi/core'
const connectorsPackageName = '@wagmi/connectors'
</script>

<!--@include: @shared/createConfig.md-->
</file>

<file path="core/api/createConnector.md">
# createConnector

Creates new [`CreateConnectorFn`](#parameters).

## Import

```ts
import { createConnector } from '@wagmi/core'
```

## Usage

```ts
import { createConnector } from '@wagmi/core'

export type InjectedParameters = {}

export function injected(parameters: InjectedParameters = {}) {
  return createConnector((config) => ({
    // ...
  }))
}
```

## Parameters

```ts
import { type CreateConnectorFn } from '@wagmi/core'
```

Read [Creating Connectors](/dev/creating-connectors) for more info on the `CreateConnectorFn` type.
</file>

<file path="core/api/createStorage.md">
<script setup>
const docsPath = "core"
const packageName = '@wagmi/core'
</script>

<!--@include: @shared/createStorage.md-->
</file>

<file path="core/api/errors.md">
<script setup>
const docsPath = "core"
const packageName = '@wagmi/core'
</script>

# Errors

Error classes used by Wagmi.

<!--@include: @shared/errors.md-->
</file>

<file path="core/api/transports.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const transports = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Transports')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Transports

[`createConfig`](/core/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

## Import

```ts
import { http } from '@wagmi/core'
```

## Built-In Transports

Available via the `'@wagmi/core'` entrypoint.

<ul>
  <li v-for="transport of transports">
    <a :href="transport.link">{{ transport.text }}</a>
  </li>
</ul>
</file>

<file path="react/api/connectors/coinbaseWallet.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/coinbaseWallet.md -->
</file>

<file path="react/api/connectors/injected.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/injected.md -->
</file>

<file path="react/api/connectors/metaMask.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/metaMask.md -->
</file>

<file path="react/api/connectors/mock.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/mock.md -->
</file>

<file path="react/api/connectors/safe.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/safe.md -->
</file>

<file path="react/api/connectors/walletConnect.md">
<script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!-- @include: @shared/connectors/walletConnect.md -->
</file>

<file path="react/api/hooks/useAccount.md">
---
title: useAccount
description: Hook for getting current account.
---

# useAccount

Hook for getting current account.

## Import

```ts
import { useAccount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useAccount } from 'wagmi'

function App() {
  const account = useAccount()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseAccountParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useAccount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const account = useAccount({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseAccountReturnType } from 'wagmi'
```

<!--@include: @shared/getAccount-return-type.md-->

## Action

- [`getAccount`](/core/api/actions/getAccount)
</file>

<file path="react/api/hooks/useAccountEffect.md">
---
title: useAccountEffect
description: Hook for listening to account lifecycle events.
---

# useAccountEffect

Hook for listening to account lifecycle events.

## Import

```ts
import { useAccountEffect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'

function App() {
  useAccountEffect({
    onConnect(data) {
      console.log('Connected!', data)
    },
    onDisconnect() {
      console.log('Disconnected!')
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseAccountEffectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  useAccountEffect({
    config, // [!code focus]
    onConnect(data) {
      console.log('Connected!', data)
    },
    onDisconnect() {
      console.log('Disconnected!')
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onConnect

`` ((data: { address: `0x${string}`; addresses: readonly [`0x${string}`, ...`0x${string}`[]]; chain: Chain | undefined chainId: number; connector: Connector; isReconnected: boolean }) => void) | undefined ``

Callback that is called when accounts are connected.

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'

function App() {
  useAccountEffect({
    onConnect(data) { // [!code focus]
      console.log('Connected!', data) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onDisconnect

`(() => void) | undefined`

Callback that is called when no more accounts are connected.

::: code-group
```tsx [index.tsx]
import { useAccountEffect } from 'wagmi'

function App() {
  useAccountEffect({
    onDisconnect() { // [!code focus]
      console.log('Disconnected!') // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Action

- [`getAccount`](/core/api/actions/getAccount)
- [`watchAccount`](/core/api/actions/watchAccount)
</file>

<file path="react/api/hooks/useBalance.md">
---
title: useBalance
description: Hook for fetching native currency or token balance.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBalance'
const typeName = 'GetBalance'
const TData = '{ decimals: number; formatted: string; symbol: string; value: bigint; }'
const TError = 'GetBalanceErrorType'
</script>

# useBalance

Hook for fetching native currency or token balance.

## Import

```ts
import { useBalance } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBalanceParameters } from 'wagmi'
```

### address

`Address | undefined`

Address to get balance for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get balance at.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### token <Badge type="warning">[deprecated](/react/guides/migrate-from-v1-to-v2#deprecated-usebalance-token-parameter)</Badge>

`Address | undefined`

ERC-20 token address to get balance for.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### unit <Badge type="warning">[deprecated](/react/guides/migrate-from-v1-to-v2#deprecated-usebalance-unit-parameter-and-formatted-return-value)</Badge>

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { useBalance } from 'wagmi'

function App() {
  const result = useBalance({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    unit: 'ether', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBalanceReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBalance`](/core/api/actions/getBalance)
</file>

<file path="react/api/hooks/useBlock.md">
---
title: useBlock
description: Hook for fetching information about a block at a block number, hash or tag.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBlock'
const typeName = 'GetBlock'
const TData = 'GetBlockData'
const TError = 'GetBlockErrorType'
</script>

# useBlock

Hook for fetching information about a block at a block number, hash or tag.

## Import

```ts
import { useBlock } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockParameters } from 'wagmi'
```

### blockHash

`` `0x${string}` ``

Information at a given block hash.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`` bigint ``

Information at a given block number.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockNumber: 42069n // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`` 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' ``

Information at a given block tag. Defaults to `'latest'`.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockTag: 'pending' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBlock({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlock({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### includeTransactions

`boolean`

Whether or not to include transactions as objects.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config'

function App() {
  const result = useBlock({
    includeTransactions: true // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config'

function App() {
  const result = useBlock({
    scopeKey: 'foo' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### watch

`boolean | UseWatchBlockParameters | undefined`

- Enables/disables listening for block changes.
- Can pass a subset of [`UseWatchBlocksParameters`](/react/api/hooks/useWatchBlocks#parameters) directly to [`useWatchBlocks`](/react/api/hooks/useWatchBlocks).

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    watch: true, // [!code focus]
  })
}
```

```tsx [index-2.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    watch: { // [!code focus]
      pollingInterval: 4_000, // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlock`](/core/api/actions/getBlock)
- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="react/api/hooks/useBlockNumber.md">
---
title: useBlockNumber
description: Hook for fetching the number of the most recent block seen.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBlockNumber'
const typeName = 'GetBlockNumber'
const TData = 'bigint'
const TError = 'GetBlockNumberErrorType'
</script>

# useBlockNumber

Hook for fetching the number of the most recent block seen.

## Import

```ts
import { useBlockNumber } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockNumberParameters } from 'wagmi'
```

### cacheTime

`number | undefined`

Time in milliseconds that cached block number will remain in memory.

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber({
    cacheTime: 4_000, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBlockNumber({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockNumber({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockNumber({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### watch

`boolean | UseWatchBlockNumberParameters | undefined`

- Enables/disables listening for block number changes.
- Can pass a subset of [`UseWatchBlockNumberParameters`](/react/api/hooks/useWatchBlockNumber#parameters)directly to [`useWatchBlockNumber`](/react/api/hooks/useWatchBlockNumber).

::: code-group
```tsx [index.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber({
    watch: true, // [!code focus]
  })
}
```

```tsx [index-2.tsx]
import { useBlockNumber } from 'wagmi'

function App() {
  const result = useBlockNumber({
    watch: { // [!code focus]
      pollingInterval: 4_000, // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockNumberReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlockNumber`](/core/api/actions/getBlockNumber)
- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="react/api/hooks/useBlockTransactionCount.md">
---
title: useBlockTransactionCount
description: Hook for fetching the number of Transactions at a block number, hash or tag.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBlockTransactionCount'
const typeName = 'GetBlockTransactionCount'
const TData = 'bigint'
const TError = 'GetBlockTransactionCountErrorType'
</script>

# useBlockTransactionCount

Hook for fetching the number of Transactions at a block number, hash or tag.

## Import

```ts
import { useBlockTransactionCount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBlockTransactionCount } from 'wagmi'

function App() {
  const result = useBlockTransactionCount()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBlockTransactionCountParameters } from 'wagmi'
```

### blockHash

`` `0x${string}` ``

Transaction count at a given block hash.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`` bigint ``

Transaction count at a given block number.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockNumber: 42069n // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`` 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' ``

Transaction count at a given block tag. Defaults to `'latest'`.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'

function App() {
  const result = useBlock({
    blockTag: 'pending' // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useBlock({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBlockTransactionCount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockTransactionCount({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlockTransactionCount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBlockTransactionCount({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBlockTransactionCountReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBlockTransactionCount`](/core/api/actions/getBlockTransactionCount)
</file>

<file path="react/api/hooks/useBytecode.md">
---
title: useBytecode
description: Hook for retrieving the bytecode at an address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getBytecode'
const typeName = 'GetBytecode'
const TData = 'GetBytecodeData'
const TError = 'GetBytecodeErrorType'
</script>

# useBytecode

Hook for retrieving the bytecode at an address.

## Import

```ts
import { useBytecode } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseBytecodeParameters } from 'wagmi'
```

### address

`Address | undefined`

The contract address.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

The block number to check the bytecode at.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockNumber: 16280770n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'

function App() {
  const result = useBytecode({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockTag: 'safe', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useBytecode({
    chainId: mainnet.id, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useBytecode({
    config, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBytecode } from 'wagmi'
import { config } from './config'

function App() {
  const result = useBytecode({
    scopeKey: 'foo' // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseBytecodeReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getBytecode`](/core/api/actions/getBytecode)
</file>

<file path="react/api/hooks/useCall.md">
---
title: useCall
description: Hook for executing a new message call immediately without submitting a transaction to the network.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'call'
const typeName = 'Call'
const TData = 'CallData'
const TError = 'CallErrorType'
</script>

# useCall

Hook for executing a new message call immediately without submitting a transaction to the network.

## Import

```ts
import { useCall } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseCallParameters } from 'wagmi'
```

### account

`Account | Address | undefined`

The Account to call from.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### data

`0x${string} | undefined`

A contract hashed method call with encoded args.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### to

`Address | undefined`

The contract address or recipient.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    accessList: [ // [!code focus:6] 
      {
        address: '0x1',
        storageKeys: ['0x1'],
      },
    ],
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gas

`bigint | undefined`

The gas provided for transaction execution.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    gas: 1_000_000n, // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    gasPrice: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    maxFeePerGas: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    nonce: 420, // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value (in wei) sent with this transaction.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number | undefined`

The block number to perform the call against.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    blockNumber: 15121123n, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to perform the call against.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'

function App() {
  const result = useCall({
    blockTag: 'safe', // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The block tag to perform the call against.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'

function App() {
  const result = useCall({
    chainId: mainnet.id, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useCall({
    config, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useCall } from 'wagmi'
import { config } from './config'

function App() {
  const result = useCall({
    scopeKey: 'foo' // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseCallReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`call`](/core/api/actions/call)
</file>

<file path="react/api/hooks/useCallsStatus.md">
---
title: useCallsStatus
description: Hook for fetching the number of the most recent block seen.
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'getCallsStatus'
const typeName = 'GetCallsStatus'
const TData = 'GetCallsStatusReturnType'
const TError = 'GetCallsStatusErrorType'
</script>

# useCallsStatus

Hook to fetch the status and receipts of a call batch that was sent via [`useSendCalls`](/react/api/hooks/useSendCalls).

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useCallsStatus } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useCallsStatus } from 'wagmi/experimental'

function App() {
  const result = useCallsStatus({
    id: '0x...', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseCallsStatusParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCallsStatus({
    config, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```tsx [index.tsx]
import { useCallsStatus, useConnections } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections()
  const result = useCallsStatus({
    connector: connections[0]?.connector, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { useCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useCallsStatus({
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCallsStatus({
    id: '0x...',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseCallsStatusReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getCallsStatus`](https://viem.sh/experimental/eip5792/getCallsStatus)
</file>

<file path="react/api/hooks/useCapabilities.md">
---
title: useCapabilities
description: Hook for fetching the number of the most recent block seen.
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'getCapabilities'
const typeName = 'GetCapabilities'
const TData = 'GetCapabilitiesReturnType'
const TError = 'GetCapabilitiesErrorType'
</script>

# useCapabilities

Hook to extract capabilities (grouped by chain ID) that a connected wallet supports (e.g. paymasters, session keys, etc).

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_getcapabilities)

::: warning
This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useCapabilities } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useCapabilities } from 'wagmi/experimental'

function App() {
  const result = useCapabilities()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseCapabilitiesParameters } from 'wagmi/experimental'
```

### account

`Account | Address | undefined`

Fetch capabilities for the provided account.

::: code-group
```ts [index.ts]
import { useCapabilities } from '@wagmi/core'
import { config } from './config'

const status = await useCapabilities({
  account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useCapabilities } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCapabilities({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```tsx [index.tsx]
import { useCapabilities, useConnections } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections()
  const result = useCapabilities({
    connector: connections[0]?.connector, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useCapabilities } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useCapabilities({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseCapabilitiesReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getCapabilities`](https://viem.sh/experimental/eip5792/getCapabilities)
</file>

<file path="react/api/hooks/useChainId.md">
---
title: useChainId
description: Hook for getting current chain ID.
---

# useChainId

Hook for getting current chain ID.

## Import

```ts
import { useChainId } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useChainId } from 'wagmi'

function App() {
  const chainId = useChainId()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseChainIdParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useChainId } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const chainId = useChainId({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseChainIdReturnType } from 'wagmi'
```

`number`

Current chain ID from [`config.state.chainId`](/react/api/createConfig#chainid).

::: info
Only returns chain IDs for chains configured via `createConfig`'s [`chains`](/react/api/createConfig#chains) parameter.

If the active [connection](/react/api/createConfig#connection) [`chainId`](/react/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `useChainId` will return the last configured chain ID.
:::

## Action

- [`getChainId`](/core/api/actions/getChainId)
- [`watchChainId`](/core/api/actions/watchChainId)
</file>

<file path="react/api/hooks/useChains.md">
---
title: useChains
description: Hook for getting configured chains
---

# useChains

Hook for getting configured chains

## Import

```ts
import { useChains } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useChains } from 'wagmi'

function App() {
  const chains = useChains()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseChainsParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useChains } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const chains = useChains({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseChainsReturnType } from 'wagmi'
```

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](/react/api/createConfig#chains).

## Action

- [`getChains`](/core/api/actions/getChains)
</file>

<file path="react/api/hooks/useClient.md">
---
title: useClient
description: Hook for getting Viem `Client` instance.
---

# useClient

Hook for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Import

```ts
import { useClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useClient } from 'wagmi'

function App() {
  const client = useClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseClientParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

::: code-group
```ts [index.ts]
import { useClient } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { config } from './config'

function App() {
  const client = useClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const client = useClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseClientReturnType } from 'wagmi'
```

`Client | undefined`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

## Action

- [`getClient`](/core/api/actions/getClient)
- [`watchClient`](/core/api/actions/watchClient)
</file>

<file path="react/api/hooks/useConfig.md">
---
title: useConfig
description: Hook for getting `Config` from nearest `WagmiProvider`.
---

# useConfig

Hook for getting [`Config`](/react/api/createConfig#config) from nearest [`WagmiProvider`](/react/api/WagmiProvider).

## Import

```ts
import { useConfig } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConfig } from 'wagmi'

function App() {
  const config = useConfig()
}
```

:::

## Return Type

```ts
import { type UseConfigReturnType } from 'wagmi'
```

If you use TypeScript and [register your `Config`](/react/typescript#register-config), the return type will be inferred.

::: code-group
```ts twoslash [index.tsx]
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' {
  interface Register {
    config: Config<readonly [typeof mainnet, typeof sepolia]>
  }
}
// ---cut---
import { useConfig } from 'wagmi'

function App() {
  const config = useConfig()
  //    ^?
}
```

```ts [config.ts]
import { createConfig, http } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

:::
</file>

<file path="react/api/hooks/useConnect.md">
---
title: useConnect
description: Hook for connecting accounts with connectors.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'connect'
const typeName = 'Connect'
const mutate = 'connect'
const TData = '{ accounts: readonly [Address, ...Address[]]; chainId: number; }'
const TError = 'ConnectErrorType'
const TVariables = '{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }'
</script>

# useConnect

Hook for connecting accounts with [connectors](/react/api/connectors).

## Import

```ts
import { useConnect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnect } from 'wagmi'
import { injected } from 'wagmi/connectors'

function App() {
  const { connect } = useConnect()

  return (
    <button onClick={() => connect({ connector: injected() })}>
      Connect
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useConnect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useConnect({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseConnectReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured connectors via [`createConfig`](/react/api/createConfig#connectors). Useful for rendering a list of available connectors.

::: code-group
```tsx [index.tsx]
import { useConnect } from 'wagmi'

function App() {
  const { connect, connectors } = useConnect()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => connect({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

::: tip
Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider (e.g. wallet) is connected to.
:::

<!--@include: @shared/mutation-imports.md-->

## Action

- [`connect`](/core/api/actions/connect)
</file>

<file path="react/api/hooks/useConnections.md">
---
title: useConnections
description: Hook for getting active connections.
---

# useConnections

Hook for getting active connections.

## Import

```ts
import { useConnections } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnections } from 'wagmi'

function App() {
  const connections = useConnections()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectionsParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useConnections } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseConnectionsReturnType } from 'wagmi'
```

## Action

- [`getConnections`](/core/api/actions/getConnections)
- [`watchConnections`](/core/api/actions/watchConnections)
</file>

<file path="react/api/hooks/useConnectorClient.md">
---
title: useConnectorClient
description: Hook for getting a Viem `Client` object for the current or provided connector.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getConnectorClient'
const typeName = 'GetConnectorClient'
const TData = 'Client'
const TError = 'GetConnectorClientErrorType'
const hideQueryOptions = ['gcTime', 'staleTime']
</script>

# useConnectorClient

Hook for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

## Import

```ts
import { useConnectorClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnectorClient } from 'wagmi'

function App() {
  const result = useConnectorClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseConnectorClientParameters } from 'wagmi'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

```ts
import { useConnectorClient } from 'wagmi'

function App() {
  const result = useConnectorClient({
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

```ts
import { useConnectorClient } from 'wagmi'

function App() {
  const result = useConnectorClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useConnectorClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useConnectorClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

```ts
import { useConnections, useConnectorClient } from 'wagmi'

function App() {
  const connections = useConnections(config)
  const result = useConnectorClient({
    connector: connections[0]?.connector, // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseConnectorClientReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getConnectorClient`](/core/api/actions/getConnectorClient)
</file>

<file path="react/api/hooks/useConnectors.md">
---
title: useConnectors
description: Hook for getting configured connectors.
---

# useConnectors

Hook for getting configured connectors.

## Import

```ts
import { useConnectors } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useConnectors } from 'wagmi'

function App() {
  const connectors = useConnectors()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseConnectorsReturnType } from 'wagmi'
```

`readonly Connector[]`

Connectors from [`config.connectors`](/react/api/createConfig#connectors-1).

## Action

- [`getConnectors`](/core/api/actions/getConnectors)
</file>

<file path="react/api/hooks/useDeployContract.md">
---
title: useDeployContract
description: Hook for deploying a contract to the network, given bytecode & constructor arguments.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'deployContract'
const typeName = 'DeployContract'
const mutate = 'deployContract'
const TData = 'DeployContractData'
const TError = 'DeployContractErrorType'
const TVariables = 'DeployContractVariables'
</script>

# useDeployContract <Badge text="viem@>=2.8.18" />

Hook for deploying a contract to the network, given bytecode, and constructor arguments.

## Import

```ts
import { useDeployContract } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useDeployContract } from 'wagmi'
import { parseEther } from 'viem'
import { wagmiAbi } from './abi'

function App() {
  const { deployContract } = useDeployContract()

  return (
    <button
      onClick={() =>
        deployContract({
          abi: wagmiAbi,
          bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
        })
      }
    >
      Deploy Contract
    </button>
  )
}
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Deploying with Constructor Args

::: code-group
```tsx [index.tsx]
import { useDeployContract } from 'wagmi'
import { parseEther } from 'viem'
import { wagmiAbi } from './abi'

function App() {
  const { deployContract } = useDeployContract()

  return (
    <button
      onClick={() =>
        deployContract({
          abi: wagmiAbi,
          args: [69420],
          bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
        })
      }
    >
      Deploy Contract
    </button>
  )
}
```
```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type useDeployContractParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useDeployContract } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useDeployContract({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type useDeployContractReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`deployContract`](/core/api/actions/deployContract)
</file>

<file path="react/api/hooks/useDisconnect.md">
---
title: useDisconnect
description: Hook for disconnecting connections.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'disconnect'
const typeName = 'Disconnect'
const mutate = 'disconnect'
const TData = 'void'
const TError = 'DisconnectErrorType'
const TVariables = '{ connector?: Connector | undefined; }'
</script>

# useDisconnect

Hook for disconnecting connections.

## Import

```ts
import { useDisconnect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useDisconnect } from 'wagmi'

function App() {
  const { disconnect } = useDisconnect()

  return (
    <button onClick={() => disconnect()}>
      Disconnect
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseDisconnectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useDisconnect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useDisconnect({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseDisconnectReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Connectors that are currently connected. Useful for rendering a list of connectors to disconnect.

::: code-group
```tsx [index.tsx]
import { useDisconnect } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const { connectors, disconnect } = useDisconnect()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => disconnect({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`disconnect`](/core/api/actions/disconnect)
</file>

<file path="react/api/hooks/useEnsAddress.md">
---
title: useEnsAddress
description: Hook for fetching ENS address for name.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsAddress'
const typeName = 'GetEnsAddress'
const TData = 'string'
const TError = 'GetEnsAddressErrorType'
</script>

# useEnsAddress

Hook for fetching ENS address for name.

## Import

```ts
import { useEnsAddress } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsAddressParameters } from 'wagmi'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS address at.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsAddress } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    chainId: mainnet.id, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### coinType

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    coinType: 60, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsAddress({
    config, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the address for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAddress({
    name: normalize('wevm.eth'),
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsAddressReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsAddress`](/core/api/actions/getEnsAddress)
</file>

<file path="react/api/hooks/useEnsAvatar.md">
---
title: useEnsAvatar
description: Hook for fetching ENS avatar for name.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsAvatar'
const typeName = 'GetEnsAvatar'
const TData = 'string | null'
const TError = 'GetEnsAvatarErrorType'
</script>

# useEnsAvatar

Hook for fetching ENS avatar for name.

## Import

```ts
import { useEnsAvatar } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsAvatarParameters } from 'wagmi'
```

---

### assetGatewayUrls <Badge text="viem@>=2.3.1" />

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

::: code-group
```ts [index.ts]
import { getEnsAvatar } from '@wagmi/core'
import { normalize } from 'viem/ens'
import { config } from './config'

function App() {
  const result = useEnsAvatar({
    assetGatewayUrls: { // [!code focus]
      ipfs: 'https://cloudflare-ipfs.com', // [!code focus]
    }, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Block number to get ENS avatar at.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS avatar at.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsAvatar } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    chainId: mainnet.id, // [!code focus],
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsAvatar({
    config, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gatewayUrls

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    gatewayUrls: ['https://cloudflare-ipfs.com'] { // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the avatar for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsAvatar } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsAvatar({
    name: normalize('wevm.eth'),
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsAvatarReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsAvatar`](/core/api/actions/getEnsAvatar)
</file>

<file path="react/api/hooks/useEnsName.md">
---
title: useEnsName
description: Hook for fetching primary ENS name for address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsName'
const typeName = 'GetEnsName'
const TData = 'string | null'
const TError = 'GetEnsNameErrorType'
</script>

# useEnsName

Hook for fetching primary ENS name for address.

## Import

```ts
import { useEnsName } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEnsNameParameters } from 'wagmi'
```

### address

`Address | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get ENS name at.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS name at.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsName } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsName } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Address of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsName } from 'wagmi'

function App() {
  const result = useEnsName({
    address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsNameReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsName`](/core/api/actions/getEnsName)
</file>

<file path="react/api/hooks/useEnsResolver.md">
---
title: useEnsResolver
description: Hook for fetching ENS resolver for name.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsResolver'
const typeName = 'GetEnsResolver'
const TData = 'string | null'
const TError = 'GetEnsResolverErrorType'
</script>

# useEnsResolver

Hook for fetching ENS resolver for name.

## Import

```ts
import { useEnsResolver } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsResolver`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsResolverParameters } from 'wagmi'
```

---

### blockNumber

`bigint | undefined`

Block number to get ENS resolver at.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS resolver at.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsResolver } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    chainId: mainnet.id, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsResolver({
    config, // [!code focus]
    name: normalize('wevm.eth'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### name

`string | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Resolver of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsResolver } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsResolver({
    name: normalize('wevm.eth'),
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsResolverReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsResolver`](/core/api/actions/getEnsResolver)
</file>

<file path="react/api/hooks/useEnsText.md">
---
title: useEnsText
description: Hook for fetching a text record for a specified ENS name and key.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getEnsText'
const typeName = 'GetEnsText'
const TData = 'string | null'
const TError = 'GetEnsTextErrorType'
</script>

# useEnsText

Hook for fetching a text record for a specified ENS name and key.

## Import

```ts
import { useEnsText } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsText`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
:::

## Parameters

```ts
import { type UseEnsTextParameters } from 'wagmi'
```

---

### blockNumber

`bigint | undefined`

Block number to get the text at.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    blockNumber: 17829139n, // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the text at.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    blockTag: 'latest', // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEnsText } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    chainId: mainnet.id, // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### key

`string | undefined`

ENS key to get Text for.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'),
    key: 'com.twitter', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### name

`string | undefined`

Name to get the text for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'), // [!code focus]
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'
import { config } from './config' // [!code focus]

function App() {
  const result = useEnsText({
    config, // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    scopeKey: 'foo', // [!code focus]
    name: normalize('wevm.eth'),
    key: 'com.twitter',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### universalResolverAddress

`Address | undefined`

- Resolver of ENS Universal Resolver Contract.
- Defaults to current chain's Universal Resolver Contract address.

::: code-group
```ts [index.ts]
import { useEnsText } from 'wagmi'
import { normalize } from 'viem/ens'

function App() {
  const result = useEnsText({
    name: normalize('wevm.eth'),
    key: 'com.twitter',
    universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEnsTextReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getEnsText`](/core/api/actions/getEnsText)
</file>

<file path="react/api/hooks/useEstimateFeesPerGas.md">
---
title: useEstimateFeesPerGas
description: Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'estimateFeesPerGas'
const typeName = 'EstimateFeesPerGas'
const TData = '{ formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }'
const TError = 'EstimateFeesPerGasErrorType'
</script>

# useEstimateFeesPerGas

Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { useEstimateFeesPerGas } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateFeesPerGas } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEstimateFeesPerGas } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useEstimateFeesPerGas({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEstimateFeesPerGas } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useEstimateFeesPerGas({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas({
    formatUnits: 'ether', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559'`

- Defaults to `'eip1559'`

::: code-group
```ts [index.ts]
import { useEstimateFeesPerGas } from 'wagmi'

function App() {
  const result = useEstimateFeesPerGas({
    type: 'legacy', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateFeesPerGasReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateFeesPerGas`](/core/api/actions/estimateFeesPerGas)
</file>

<file path="react/api/hooks/useEstimateGas.md">
---
title: useEstimateGas
description: Hook for estimating the gas necessary to complete a transaction without submitting it to the network.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'estimateGas'
const typeName = 'EstimateGas'
const TData = 'bigint'
const TError = 'EstimateGasErrorType'
</script>

# useEstimateGas

Hook for estimating the gas necessary to complete a transaction without submitting it to the network.

## Import

```ts
import { useEstimateGas } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEstimateGas } from 'wagmi'

function App() {
  const result = useEstimateGas()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateGasParameters } from 'wagmi'
```

### accessList

`AccessList | undefined`

The access list.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    accessList: [{ // [!code focus]
      address: '0x1', // [!code focus]
      storageKeys: ['0x1'], // [!code focus]
    }], // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### account

`Address | Account | undefined`

Account to use when estimating gas.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    chainId: mainnet.id, // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

::: code-group
```ts [index.ts]
import { getConnections, estimateGas } from '@wagmi/core'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const connections = getConnections(config)
  const result = useEstimateGas({
    connector: connections[0]?.connector, // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded function data.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    gas: parseGwei('20'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    gasPrice: parseGwei('20'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    maxFeePerGas: parseGwei('20'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther, parseGwei } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    nonce: 123, // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    scopeKey: 'foo', // [!code focus]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### to

`Address | undefined`

The transaction recipient or contract address.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    type: 'eip1559', // [!code focus]
    value: parseEther('0.01'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```ts [index.ts]
import { useEstimateGas } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = useEstimateGas({
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    value: parseEther('0.01'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateGasReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateGas`](/core/api/actions/estimateGas)
</file>

<file path="react/api/hooks/useEstimateMaxPriorityFeePerGas.md">
---
title: useEstimateMaxPriorityFeePerGas
description: Hook for fetching an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'estimateMaxPriorityFeePerGas'
const typeName = 'EstimateMaxPriorityFeePerGas'
const TData = 'bigint'
const TError = 'EstimateMaxPriorityFeePerGasErrorType'
</script>

# useEstimateMaxPriorityFeePerGas

Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

## Import

```ts
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'

function App() {
  const result = useEstimateMaxPriorityFeePerGas()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseEstimateMaxPriorityFeePerGas } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useEstimateMaxPriorityFeePerGas({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useEstimateMaxPriorityFeePerGas({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useEstimateMaxPriorityFeePerGas } from 'wagmi'

function App() {
  const result = useEstimateMaxPriorityFeePerGas({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseEstimateMaxPriorityFeePerGasReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`estimateMaxPriorityFeePerGas`](/core/api/actions/estimateMaxPriorityFeePerGas)
</file>

<file path="react/api/hooks/useFeeHistory.md">
---
title: useFeeHistory
description: Hook for fetching a collection of historical gas information.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getFeeHistory'
const typeName = 'GetFeeHistory'
const TData = 'bigint'
const TError = 'GetFeeHistoryErrorType'
</script>

# useFeeHistory

Hook for fetching a collection of historical gas information.

## Import

```ts
import { useFeeHistory } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75]
})
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseFeeHistoryParameters } from 'wagmi'
```

### blockCount

`number | undefined`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4, // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### rewardPercentiles

`number[] | undefined`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75] // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Highest number block of the requested range.


::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    blockNumber: 1551231n, // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag of the highest number block of the requested range.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    blockTag: 'safe', // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.


::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    chainId: mainnet.id, // [!code focus]
    rewardPercentiles: [25, 75]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75]
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useFeeHistory } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useFeeHistory({
    blockCount: 4,
    rewardPercentiles: [25, 75]
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseFeeHistoryReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getFeeHistory`](/core/api/actions/getFeeHistory)
</file>

<file path="react/api/hooks/useGasPrice.md">
---
title: useGasPrice
description: Hook for fetching the current price of gas (in wei).
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getGasPrice'
const typeName = 'GetGasPrice'
const TData = 'bigint'
const TError = 'GetGasPriceErrorType'
</script>

# useGasPrice

Hook for fetching the current price of gas (in wei).

## Import

```ts
import { useGasPrice } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'

function App() {
  const result = useGasPrice()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseGasPriceParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useGasPrice({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useGasPrice({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useGasPrice } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useGasPrice({
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseGasPriceReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getGasPrice`](/core/api/actions/getGasPrice)
</file>

<file path="react/api/hooks/useInfiniteReadContracts.md">
---
title: useInfiniteReadContracts
description: Hook for calling multiple read methods on a contract with "infinite scroll"/"fetch more" support.
---

<script setup>
const packageName = 'wagmi'
const includeInfiniteQueryOptions = true
const TPageParam = 'number'
const TData = 'InfiniteReadContractsData'
const TError = 'ReadContractsErrorType'
</script>

# useInfiniteReadContracts

Hook for calling multiple contract read-only methods with "infinite scrolling"/"fetch more" support. 

## Import

```ts
import { useInfiniteReadContracts } from 'wagmi'
```

## Usage

The example below shows how to demonstrate how to fetch a set of [mloot](https://etherscan.io/address/0x1dfe7ca09e99d10835bf73044a23b73fc20623df) attributes (chestwear, footwear, and handwear) with "fetch more" support.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

const mlootContractConfig = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi,
} as const

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        { ...mlootContractConfig, functionName: 'getChest', args },
        { ...mlootContractConfig, functionName: 'getFoot', args },
        { ...mlootContractConfig, functionName: 'getHand', args },
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

In the above example, we are setting a few things:

- [`cacheKey`](#cachekey): A unique key to store the data in the cache.
- [`query.initialPageParam`](#initialpageparam): An initial page parameter to use when fetching the first set of contracts.
- [`query.getNextPageParam`](#getnextpageparam): A function that returns the next page parameter to use when fetching the next set of contracts.
- [`contracts`](#contracts): A function that provides `pageParam` (derived from the above) as an argument and expects to return an array of contracts.

### Paginated Parameters

We can also leverage properties like `getNextPageParam` with a custom `limit` variable to achieve "pagination" of parameters. For example, we can fetch the first 10 contract functions, then fetch the next 10 contract functions, and so on.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function Example({ limit = 10 }: { limit?: number } = {}) {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      return [...new Array(limit)].map(
        (_, i) =>
          ({
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi,
            functionName: 'getHand',
            args: [BigInt(pageParam + i)],
          }) as const,
      )
    },
    query: {
      initialPageParam: 1,
      getNextPageParam(_lastPage, _allPages, lastPageParam) {
        return lastPageParam + limit
      },
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::


## Parameters

```ts
import { type UseInfiniteReadContractsParameters } from 'wagmi'
```

### cacheKey

`string`

A unique key to store the data in the cache.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes', // [!code hl]
    contracts(pageParam) {
      // ...
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### contracts

`(pageParam: {{TPageParam}}) => Contract[]`

A function that provides `pageParam` (derived from the above) as an argument and expects to return an array of contracts.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi, // [!code hl]
          functionName: 'getChest', 
          args 
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df', // [!code hl]
          abi,
          functionName: 'getChest', 
          args 
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi,
          functionName: 'getChest', // [!code hl]
          args 
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi,
          functionName: 'getChest', 
          args: [pageParam] // [!code hl]
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useInfiniteReadContracts } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useInfiniteReadContracts({
    cacheKey: 'mlootAttributes',
    contracts(pageParam) {
      const args = [pageParam] as const
      return [
        // ...
        {  
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi,
          functionName: 'getChest', 
          args,
          chainId: 1 // [!code hl]
        },
        // ...
      ]
    }
    query: {
      initialPageParam: 0,
      getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
        return lastPageParam + 1
      }
    }
  })
}
```
<<< @/snippets/abi-infinite-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseInfiniteReadContractsReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->
</file>

<file path="react/api/hooks/usePrepareTransactionRequest.md">
---
title: usePrepareTransactionRequest
description: Hook for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'prepareTransactionRequest'
const typeName = 'PrepareTransactionRequest'
const TData = 'PrepareTransactionRequestData'
const TError = 'PrepareTransactionRequestErrorType'
</script>

# usePrepareTransactionRequest

Hook for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

## Import

```ts
import { usePrepareTransactionRequest } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UsePrepareTransactionRequestParameters } from 'wagmi'
```

### account

`Account | Address | undefined`

The Account to send the transaction from. 

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### to

`` `0x${string}` | undefined ``

The transaction recipient or contract address.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',  // [!code focus]
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    accessList: [ // [!code focus:6]
      {
        address: '0x1',
        storageKeys: ['0x1'],
      },
    ],
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Chain ID to prepare the transaction request for.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    chainId: mainnet.id, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### data

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### gasPrice

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther, parseGwei } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    gasPrice: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther, parseGwei } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    maxFeePerGas: parseGwei('20'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther, parseGwei } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### nonce

`number | undefined`

Unique number identifying this transaction.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
    nonce: 5, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### parameters

`("fees" | "gas" | "nonce" | "type")[] | undefined`

Parameters to prepare.

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    parameters: ['gas', 'nonce'], // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const result = usePrepareTransactionRequest({
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'), // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config' // [!code focus]

function App() {
  const result = usePrepareTransactionRequest({
    config, // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { usePrepareTransactionRequest } from 'wagmi'
import { parseEther } from 'viem'
import { config } from './config'

function App() {
  const result = usePrepareTransactionRequest({
    scopeKey: 'foo' // [!code focus]
    account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UsePrepareTransactionRequestReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`prepareTransactionRequest`](/core/api/actions/prepareTransactionRequest)
</file>

<file path="react/api/hooks/useProof.md">
---
title: useProof
description: Hook for return the account and storage values of the specified account including the Merkle-proof.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getProof'
const typeName = 'GetProof'
const TData = 'GetProofData'
const TError = 'GetProofErrorType'
</script>

# useProof

Hook for return the account and storage values of the specified account including the Merkle-proof.

## Import

```ts
import { useProof } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseProofParameters } from 'wagmi'
```

### address

`Address | undefined`

The account address to get the proof for.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016', // [!code focus]
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### storageKeys

`` `0x${string}`[] | undefined ``

Array of storage-keys that should be proofed and included.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [ // [!code focus:3]
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Proof at a given block number.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    blockNumber: 42069n, // [!code focus]
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Proof at a given block tag.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'

function App() {
  const result = useProof({
    address: '0x4200000000000000000000000000000000000016',
    blockTag: 'latest', // [!code focus]
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to get the proof for.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'
import { optimism } from 'wagmi/chains'

function App() {
  const result = useProof({
    chainId: optimism.id, // [!code focus]
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useProof({
    config, // [!code focus]
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useProof } from 'wagmi'
import { config } from './config'

function App() {
  const result = useProof({
    scopeKey: 'foo' // [!code focus]
    address: '0x4200000000000000000000000000000000000016',
    storageKeys: [
      '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseProofReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getProof`](/core/api/actions/getProof)
</file>

<file path="react/api/hooks/usePublicClient.md">
---
title: usePublicClient
description: Hook for getting Viem `PublicClient` instance.
---

# usePublicClient

Hook for getting Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

## Import

```ts
import { usePublicClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { usePublicClient } from 'wagmi'

function App() {
  const client = usePublicClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`useClient`](/react/api/hooks/useClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Public Client has all public actions attached directly to it.
:::

## Parameters

```ts
import { type UsePublicClientParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Public Client.

::: code-group
```ts [index.ts]
import { usePublicClient } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { config } from './config'

function App() {
  const client = usePublicClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { usePublicClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const client = usePublicClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UsePublicClientReturnType } from 'wagmi'
```

`PublicClient | undefined`

Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

## Action

- [`getPublicClient`](/core/api/actions/getPublicClient)
- [`watchPublicClient`](/core/api/actions/watchPublicClient)
</file>

<file path="react/api/hooks/useReadContract.md">
---
title: useReadContract
description: Hook for calling a read-only function on a contract, and returning the response.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'readContract'
const typeName = 'ReadContract'
const TData = 'ReadContractReturnType'
const TError = 'ReadContractErrorType'
</script>

# useReadContract

Hook for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

## Import

```ts
import { useReadContract } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseReadContractParameters } from 'wagmi'
```

### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi' // [!code focus]

function App() {
  const result = useReadContract({
    abi, // [!code focus]
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf',
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
    functionName: 'totalSupply',
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf',
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'], // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    blockTag: 'safe', // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config' // [!code focus]

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'totalSupply',
    config, // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf', // [!code focus]
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useReadContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useReadContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'balanceOf',
    args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/abi-read.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseReadContractReturnType } from 'wagmi'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/query-result.md-->

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](/react/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { createConfig, http, useReadContract } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const result = useReadContract({
  abi: [
    {
      type: 'function',
      name: 'balanceOf',
      stateMutability: 'view',
      inputs: [{ name: 'account', type: 'address' }],
      outputs: [{ type: 'uint256' }],
    },
    {
      type: 'function',
      name: 'totalSupply',
      stateMutability: 'view',
      inputs: [],
      outputs: [{ name: 'supply', type: 'uint256' }],
    },
  ],
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  // ^?


  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  // ^?
})

result.data
//     ^?
```
```ts twoslash [Const-Asserted]
import { createConfig, http, useReadContract } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
// ---cut---
const abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: 'supply', type: 'uint256' }],
  },
] as const

const result = useReadContract({
  abi,
  address: '0x6b175474e89094c44da98b954eedeac495271d0f',
  functionName: 'balanceOf',
  // ^?


  args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
  // ^?
})

result.data
//     ^?
```
:::

<!--@include: @shared/query-imports.md-->

## Action

- [`readContract`](/core/api/actions/readContract)
</file>

<file path="react/api/hooks/useReadContracts.md">
---
title: useReadContracts
description: Hook for calling multiple read methods on a contract.
---

# useReadContracts

Hook for calling multiple read methods on a contract.

## Import

```ts
import { useReadContracts } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

const wagmigotchiContract = {
  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: wagmigotchiABI,
} as const
const mlootContract = {
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: mlootABI,
} as const

function App() {
  const result = useReadContracts({
    contracts: [
      {
        ...wagmigotchiContract,
        functionName: 'getAlive',
      },
      {
        ...wagmigotchiContract,
        functionName: 'getBoredom',
      },
      {
        ...mlootContract,
        functionName: 'getChest',
        args: [69],
      },
      {
        ...mlootContract,
        functionName: 'getWaist',
        args: [69],
      },
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseReadContractsParameters } from 'wagmi'
```

### contracts

`readonly Contract[]`

Set of contracts to call.

#### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI, // [!code hl]
        functionName: 'getChest',
        args: [69],
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',  // [!code hl]
        abi: mlootABI,
        functionName: 'getChest',
        args: [69],
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest', // [!code hl]
        args: [69],
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69], // [!code hl]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

#### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69],
        chainId: 1  // [!code hl]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### allowFailure

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `useReadContracts` will fail silently and its error will be logged in the results array. Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    allowFailure: false, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::


### batchSize

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    batchSize: 1024, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`number`

The block number to perform the read against.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    blockNumber: 69420n, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    blockTag: 'safe', // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'
import { config } from './config'

function App() {
  const result = useReadContracts({
    config, // [!code hl]
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### multicallAddress

`Address`

Address of multicall contract.

::: code-group
```tsx [index.tsx]
import { useReadContracts } from 'wagmi'

function App() {
  const result = useReadContracts({
    contracts: [
      {
        address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
        abi: mlootABI,
        functionName: 'getChest',
        args: [69]
      },
      // ...
    ],
    multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11', // [!code hl]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseReadContractsReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

## Action

- [`readContracts`](/core/api/actions/readContracts)
</file>

<file path="react/api/hooks/useReconnect.md">
---
title: useReconnect
description: Hook for reconnecting connectors.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'reconnect'
const typeName = 'Reconnect'
const mutate = 'reconnect'
const TData = '{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }'
const TError = 'ReconnectErrorType'
const TVariables = '{ connectors?: (CreateConnectorFn | Connector)[] | undefined; }'
</script>

# useReconnect

Hook for reconnecting [connectors](/core/api/connectors).

## Import

```ts
import { useReconnect } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useReconnect } from 'wagmi'
import { useEffect } from 'react'

function App() {
  const { reconnect } = useReconnect()

  useEffect(() => {
    reconnect()
  }, [])
}
```

:::

::: tip
When [`WagmiProvider['reconnectOnMount']`](/react/api/WagmiProvider#reconnectonmount) is `true`, `reconnect` is called automatically on mount.
:::

## Parameters

```ts
import { type UseReconnectParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useReconnect } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useReconnect({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseReconnectReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured connectors via [`createConfig`](/react/api/createConfig#connectors).

::: code-group
```tsx [index.tsx]
import { useReconnect } from 'wagmi'
import { mainnet } from 'wagmi/chains'
import { useEffect } from 'react'

function App() {
  const { reconnect, connectors } = useReconnect()

  useEffect(() => {
    reconnect({ connectors })
  }, [])
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`reconnect`](/core/api/actions/reconnect)
</file>

<file path="react/api/hooks/useSendCalls.md">
---
title: useSendCalls
description: Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'sendCalls'
const typeName = 'SendCalls'
const mutate = 'sendCalls'
const TData = 'SendCallsData'
const TError = 'SendCallsErrorType'
const TVariables = 'SendCallsVariables'
</script>

# useSendCalls

Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useSendCalls } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSendCalls } from 'wagmi/experimental'
import { parseEther } from 'viem'

function App() {
  const { sendCalls } = useSendCalls()

  return (
    <button
      onClick={() =>
        sendCalls({
          calls: [
            {
              to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
              value: parseEther('1')
            },
            {
              data: '0xdeadbeef',
              to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
            },
          ]
        })
      }
    >
      Send calls
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSendCallsParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSendCalls } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useSendCalls({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSendCallsReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`sendCalls`](/core/api/actions/sendCalls)
</file>

<file path="react/api/hooks/useSendTransaction.md">
---
title: useSendTransaction
description: Hook for creating, signing, and sending transactions to networks.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'sendTransaction'
const typeName = 'SendTransaction'
const mutate = 'sendTransaction'
const TData = 'SendTransactionData'
const TError = 'SendTransactionErrorType'
const TVariables = 'SendTransactionVariables'
</script>

# useSendTransaction

Hook for creating, signing, and sending transactions to networks.

## Import

```ts
import { useSendTransaction } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSendTransaction } from 'wagmi'
import { parseEther } from 'viem'

function App() {
  const { sendTransaction } = useSendTransaction()

  return (
    <button
      onClick={() =>
        sendTransaction({
          to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          value: parseEther('0.01'),
        })
      }
    >
      Send transaction
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSendTransactionParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSendTransaction } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSendTransaction({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSendTransactionReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`sendTransaction`](/core/api/actions/sendTransaction)
</file>

<file path="react/api/hooks/useShowCallsStatus.md">
---
title: useShowCallsStatus
description: Action to request for the wallet to show information about a call batch
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'showCallsStatus'
const typeName = 'ShowCallsStatus'
const mutate = 'showCallsStatus'
const TData = 'ShowCallsStatusData'
const TError = 'ShowCallsStatusErrorType'
const TVariables = 'ShowCallsStatusVariables'
</script>

# useShowCallsStatus

Action to request for the wallet to show information about a call batch that was sent via `useShowCalls`.

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_showcallsstatus)

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useShowCallsStatus } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useShowCallsStatus } from 'wagmi/experimental'
import { parseEther } from 'viem'

function App() {
  const { showCallsStatus } = useShowCallsStatus()

  return (
    <button
      onClick={() =>
        showCallsStatus({
          id: '0x1234567890abcdef',
        })
      }
    >
      Show calls status
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseShowCallsStatusParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useShowCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useShowCallsStatus({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseShowCallsStatusReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`showCallsStatus`](/core/api/actions/showCallsStatus)
</file>

<file path="react/api/hooks/useSignMessage.md">
---
title: useSignMessage
description: Hook for signing messages.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'signMessage'
const typeName = 'SignMessage'
const mutate = 'signMessage'
const TData = 'SignMessageData'
const TError = 'SignMessageErrorType'
const TVariables = 'SignMessageVariables'
</script>

# useSignMessage

Hook for signing messages.

## Import

```ts
import { useSignMessage } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSignMessage } from 'wagmi'

function App() {
  const { signMessage } = useSignMessage()

  return (
    <button onClick={() => signMessage({ message: 'hello world' })}>
      Sign message
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSignMessageParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSignMessage } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSignMessage({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSignMessageReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`signMessage`](/core/api/actions/signMessage)
</file>

<file path="react/api/hooks/useSignTypedData.md">
---
title: useSignTypedData
description: Hook for signing typed data and calculating an Ethereum-specific EIP-712 signature.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'signTypedData'
const typeName = 'SignTypedData'
const mutate = 'signTypedData'
const TData = 'SignTypedDataData'
const TError = 'SignTypedDataErrorType'
const TVariables = 'SignTypedDataVariables'
</script>

# useSignTypedData

Hook for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

## Import

```ts
import { useSignTypedData } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSignTypedData } from 'wagmi'


function App() {
  const { signTypedData } = useSignTypedData()

  return (
    <button
      onClick={() =>
        signTypedData({
          types: {
            Person: [
              { name: 'name', type: 'string' },
              { name: 'wallet', type: 'address' },
            ],
            Mail: [
              { name: 'from', type: 'Person' },
              { name: 'to', type: 'Person' },
              { name: 'contents', type: 'string' },
            ],
          },
          primaryType: 'Mail',
          message: {
            from: {
              name: 'Cow',
              wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
            },
            to: {
              name: 'Bob',
              wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
            },
            contents: 'Hello, Bob!',
          },
        })
      }
    >
      Sign message
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSignTypedDataParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSignTypedData } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSignTypedData({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSignTypedDataReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

## Type Inference

With [`types`](/core/api/actions/signTypedData#types) setup correctly, TypeScript will infer the correct types for [`domain`](/core/api/actions/signTypedData#domain), [`message`](/core/api/actions/signTypedData#message), and [`primaryType`](/core/api/actions/signTypedData#primarytype). See the Wagmi [TypeScript docs](/react/typescript) for more information.

::: code-group
```ts twoslash [Inline]
import { useSignTypedData } from 'wagmi'
// ---cut---
const { signTypedData } = useSignTypedData()

signTypedData({
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
```ts twoslash [Const-Asserted]
import { useSignTypedData } from 'wagmi'
// ---cut---
const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const

const { signTypedData } = useSignTypedData()

signTypedData({
  types,
  primaryType: 'Mail',
  // ^?


  message: {
  // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
:::

<!--@include: @shared/mutation-imports.md-->

## Action

- [`signTypedData`](/core/api/actions/signTypedData)
</file>

<file path="react/api/hooks/useSimulateContract.md">
---
title: useSimulateContract
description: Hook for simulating/validating a contract interaction.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'simulateContract'
const typeName = 'SimulateContract'
const TData = 'SimulateContractReturnType'
const TError = 'SimulateContractErrorType'
</script>

# useSimulateContract

Hook for simulating/validating a contract interaction.

## Import

```ts
import { useSimulateContract } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!-- TODO: Usage for combining with useWriteContract -->

## Parameters

```ts
import { type UseSimulateContractParameters } from 'wagmi'
```

### abi

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi' // [!code focus]

function App() {
  const result = useSimulateContract({
    abi, // [!code focus]
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### accessList

`AccessList | undefined`

The access list.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    accessList: [{ // [!code focus]
      address: '0x1', // [!code focus]
      storageKeys: ['0x1'], // [!code focus]
    }], // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### account

`Account | undefined`

Account to use when calling the contract (`msg.sender`). Throws if account is not found on [`connector`](#connector).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### args

`readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`functionName`](#functionname).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [ // [!code focus]
      '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
      123n, // [!code focus]
    ], // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to call contract at.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    blockTag: 'safe', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    config, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

[Connector](/react/api/connectors) to simulate transaction with.

::: code-group
```tsx [index.ts]
import { useConnectorClient, useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const { data: connector } = useConnectorClient()
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    connector, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### dataSuffix

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    dataSuffix: '0xdeadbeef', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### functionName

`string | undefined`

- Function to call on the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
    functionName: 'transferFrom', // [!code focus]
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### gas

`bigint | undefined`

Gas provided for transaction execution.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    gas: parseGwei('20'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### gasPrice

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    gasPrice: parseGwei('20'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### maxFeePerGas

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    maxFeePerGas: parseGwei('20'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### maxPriorityFeePerGas

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseGwei } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    maxFeePerGas: parseGwei('20'),
    maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

---

### nonce

`number`

Unique number identifying this transaction.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    nonce: 123, // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### type

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    type: 'eip1559', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### value

`bigint | undefined`

Value in wei sent with this transaction.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { parseEther } from 'viem'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    value: parseEther('0.01'), // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.ts]
import { useSimulateContract } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  const result = useSimulateContract({
    abi,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    functionName: 'transferFrom',
    args: [
      '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
      123n,
    ],
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseSimulateContractReturnType } from 'wagmi'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/query-result.md-->

## Type Inference

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](/react/typescript) for more information.

<!--@include: @shared/query-imports.md-->

## Action

- [`simulateContract`](/core/api/actions/simulateContract)
</file>

<file path="react/api/hooks/useStorageAt.md">
---
title: useStorageAt
description: Hook for returning the value from a storage slot at a given address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getStorageAt'
const typeName = 'GetStorageAt'
const TData = 'GetStorageAtData'
const TError = 'GetStorageAtErrorType'
</script>

# useStorageAt

Hook for for returning the value from a storage slot at a given address.

## Import

```ts
import { useStorageAt } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseStorageAtParameters } from 'wagmi'
```

### address

`Address | undefined`

The contract address.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### slot

`Hex | undefined`

The storage position (as a hex encoded value).

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## blockNumber

`bigint | undefined`

The block number to check the storage at.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockNumber: 16280770n, // [!code focus]
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the storage at.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'

function App() {
  const result = useStorageAt({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    blockTag: 'safe', // [!code focus]
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The chain ID to check the storage at.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'
import { mainnet } from '@wagmi/core/chains'

function App() {
  const result = useStorageAt({
    chainId: mainnet.id, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useStorageAt({
    config, // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useStorageAt } from 'wagmi'
import { config } from './config'

function App() {
  const result = useStorageAt({
    scopeKey: 'foo' // [!code focus]
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    slot: '0x0',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseStorageAtReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getStorageAt`](/core/api/actions/getStorageAt)
</file>

<file path="react/api/hooks/useSwitchAccount.md">
---
title: useSwitchAccount
description: Hook for switching the current account.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'switchAccount'
const typeName = 'SwitchAccount'
const mutate = 'switchAccount'
const TData = 'SwitchAccountData'
const TError = 'SwitchAccountErrorType'
const TVariables = 'SwitchAccountVariables'
</script>

# useSwitchAccount

Hook for switching the current account.

## Import

```ts
import { useSwitchAccount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSwitchAccount } from 'wagmi'

function App() {
  const { connectors, switchAccount } = useSwitchAccount()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => switchAccount({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseSwitchAccountParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSwitchAccount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSwitchAccount({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSwitchAccountReturnType } from 'wagmi'
```

### connectors

`readonly Connector[]`

Globally configured and actively connected connectors. Useful for rendering a list of available connectors to switch to.

::: code-group
```tsx [index.tsx]
import { useSwitchAccount } from 'wagmi'

function App() {
  const { connectors, switchAccount } = useSwitchAccount()

  return (
    <div>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => switchAccount({ connector })}>
          {connector.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`switchAccount`](/core/api/actions/switchAccount)
</file>

<file path="react/api/hooks/useSwitchChain.md">
---
title: useSwitchChain
description: Hook for switching the target chain for a connector or the Wagmi `Config`.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'switchChain'
const typeName = 'SwitchChain'
const mutate = 'switchChain'
const TData = 'SwitchChainData'
const TError = 'SwitchChainErrorType'
const TVariables = 'SwitchChainVariables'
</script>

# useSwitchChain

Hook for switching the target chain for a connector or the Wagmi [`Config`](/react/api/createConfig#config).

## Import

```ts
import { useSwitchChain } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useSwitchChain } from 'wagmi'

function App() {
  const { chains, switchChain } = useSwitchChain()

  return (
    <div>
      {chains.map((chain) => (
        <button key={chain.id} onClick={() => switchChain({ chainId: chain.id })}>
          {chain.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: tip
When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](/react/api/createConfig#config).
:::

## Parameters

```ts
import { type UseSwitchChainParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useSwitchChain } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useSwitchChain({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseSwitchChainReturnType } from 'wagmi'
```

### chains

`readonly [Chain, ...Chain[]]`

Globally configured chains. Useful for rendering a list of available chains to switch to.

::: code-group
```tsx [index.tsx]
import { useSwitchChain } from 'wagmi'

function App() {
  const { chains, switchChain } = useSwitchChain()

  return (
    <div>
      {chains.map((chain) => (
        <button key={chain.id} onClick={() => switchChain({ chainId: chain.id })}>
          {chain.name}
        </button>
      ))}
    </div>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`switchChain`](/core/api/actions/switchChain)
</file>

<file path="react/api/hooks/useToken.md">
---
title: useToken
description: Hook for fetching token info.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getToken'
const typeName = 'GetToken'
const TData = '{ address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }'
const TError = 'GetTokenErrorType'
</script>

# useToken <Badge type="warning">[deprecated](/react/guides/migrate-from-v1-to-v2#deprecated-usetoken)</Badge>

Hook for fetching token info. 

## Import

```ts
import { useToken } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTokenParameters } from 'wagmi'
```

### address

`Address | undefined`

Address to get token for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useToken } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### formatUnits

`'ether' | 'gwei' | 'wei' | number | undefined`

- Units to use when formatting result.
- Defaults to `'ether'`.

::: code-group
```ts [index.ts]
import { useToken } from 'wagmi'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    formatUnits: 'ether', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```ts [index.ts]
import { useToken } from 'wagmi'

function App() {
  const result = useToken({
    address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTokenReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getToken`](/core/api/actions/getToken)
</file>

<file path="react/api/hooks/useTransaction.md">
---
title: useTransaction
description: Hook for fetching transactions given hashes or block identifiers.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransaction'
const typeName = 'GetTransaction'
const TData = 'GetTransactionData'
const TError = 'GetTransactionErrorType'
</script>

# useTransaction

Hook for fetching transactions given hashes or block identifiers.

## Import

```ts
import { useTransaction } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionParameters } from 'wagmi'
```

---

### blockHash

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
    index: 0,
  })
}
```

### blockNumber

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockNumber: 17829139n, // [!code focus]
    index: 0,
  })
}
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockTag: 'safe', // [!code focus]
    index: 0,
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```ts
import { useTransaction } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useTransaction({
    chainId: mainnet.id, // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransaction } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransaction({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### hash

`` `0x${string}` | undefined ``

Hash to get transaction. [`enabled`](#enabled) set to `false` if `hash` and [`index`](#index) are `undefined`.

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
  })
}
```

### index

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)). [`enabled`](#enabled) set to `false` if `index` and [`hash`](#hash) are `undefined`.

```ts
import { useTransaction } from 'wagmi'

function App() {
  const result = useTransaction({
    blockTag: 'safe',
    index: 0  // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransaction`](/core/api/actions/getTransaction)
</file>

<file path="react/api/hooks/useTransactionConfirmations.md">
---
title: useTransactionConfirmations
description: Hook for fetching the number of blocks passed (confirmations) since the transaction was processed on a block.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransactionConfirmations'
const typeName = 'GetTransactionConfirmations'
const TData = 'GetTransactionConfirmationsData'
const TError = 'GetTransactionConfirmationsErrorType'
</script>

# useTransactionConfirmations

Hook for fetching the number of blocks passed (confirmations) since the transaction was processed on a block. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

## Import

```ts
import { useTransactionConfirmations } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransactionConfirmations } from 'wagmi'

function App() {
  const result = useTransactionConfirmations({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionConfirmationsParameters } from 'wagmi'
```

---

### hash

`` `0x${string}` | undefined ``

The hash of the transaction.

```ts
import { useTransactionConfirmations } from 'wagmi'

function App() {
  const result = useTransactionConfirmations({
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', // [!code focus]
  })
}
```

### transactionReceipt

`TransactionReceipt | undefined`

The transaction receipt.

```ts
import { useTransactionConfirmations } from 'wagmi'

function App() {
  const result = useTransactionConfirmations({
    transactionReceipt: { ... }, // [!code focus]
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```ts
import { useTransactionConfirmations } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useTransactionConfirmations({
    chainId: mainnet.id, // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransactionConfirmations } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransactionConfirmations({
    config, // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useBlock } from 'wagmi'
import { config } from './config'

function App() {
  const result = useTransactionConfirmations({
    scopeKey: 'foo' // [!code focus]
    hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionConfirmationsReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionConfirmations`](/core/api/actions/getTransactionConfirmations)
</file>

<file path="react/api/hooks/useTransactionCount.md">
---
title: useTransactionCount
description: Hook for fetching the number of transactions an Account has broadcast / sent.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransactionCount'
const typeName = 'GetTransactionCount'
const TData = 'number'
const TError = 'GetTransactionCountErrorType'
</script>

# useTransactionCount

Hook for fetching the number of transactions an Account has sent.

## Import

```ts
import { useTransactionCount } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionCountParameters } from 'wagmi'
```

### address

`Address | undefined`

Address to get the transaction count for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### blockNumber

`bigint | undefined`

Block number to get the transaction count at.

::: code-group
```ts [index.ts]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockNumber: 17829139n, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the transaction count at.

::: code-group
```ts [index.ts]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    blockTag: 'latest', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

---

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'
import { mainnet } from 'wagmi/chains' // [!code focus]

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    chainId: mainnet.id, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useTransactionCount } from 'wagmi'

function App() {
  const result = useTransactionCount({
    address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionCountReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionCount`](/core/api/actions/getTransactionCount)
</file>

<file path="react/api/hooks/useTransactionReceipt.md">
---
title: useTransactionReceipt
description: Hook for return the Transaction Receipt given a Transaction hash.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getTransactionReceipt'
const typeName = 'GetTransactionReceipt'
const TData = 'GetTransactionReceiptData'
const TError = 'GetTransactionReceiptErrorType'
</script>

# useTransactionReceipt

Hook for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

## Import

```ts
import { useTransactionReceipt } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'

function App() {
  const result = useTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseTransactionReceiptParameters } from 'wagmi'
```

### hash

`` `0x${string}` | undefined ``

A transaction hash.

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'

function App() {
  const result = useTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'
import { mainnet } from 'wagmi/chains'


function App() {
  const result = useTransactionReceipt({
    chainId: mainnet.id, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useTransactionReceipt({
    config, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useTransactionReceipt } from 'wagmi'
import { config } from './config'

function App() {
  const result = useTransactionReceipt({
    scopeKey: 'foo' // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseTransactionReceiptReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getTransactionReceipt`](/core/api/actions/getTransactionReceipt)
</file>

<file path="react/api/hooks/useVerifyMessage.md">
---
title: useVerifyMessage
description: Hook for verify that a message was signed by the provided address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'verifyMessage'
const typeName = 'VerifyMessage'
const TData = 'VerifyMessageData'
const TError = 'VerifyMessageErrorType'
</script>

# useVerifyMessage

Hook for verify that a message was signed by the provided address. It supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { useVerifyMessage } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseVerifyMessageParameters } from 'wagmi'
```

### address

`Address | undefined`

The Ethereum address that signed the original message.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### message

`string | { raw: Hex | ByteArray } | undefined`

The message to be verified.

By default, wagmi verifies the UTF-8 representation of the message.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world', // [!code focus]
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: tip
By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

```ts
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: { raw: '0x68656c6c6f20776f726c64' } // [!code focus]
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
:::

### signature

`Hex | ByteArray | undefined`

The signature that was generated by signing the message with the address's signer.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'

function App() {
  const result = useVerifyMessage({
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyMessage({
    chainId: mainnet.id, // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyMessage({
    blockNumber: 12345678n, // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyMessage({
    blockTag: 'pending', // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useVerifyMessage({
    config, // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useVerifyMessage } from 'wagmi'
import { config } from './config'

function App() {
  const result = useVerifyMessage({
    scopeKey: 'foo' // [!code focus]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    message: 'hello world',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseVerifyMessageReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`verifyMessage`](/core/api/actions/verifyMessage)
</file>

<file path="react/api/hooks/useVerifyTypedData.md">
---
title: useVerifyTypedData
description: Hook for verify that a typed data was signed by the provided address.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'verifyTypedData'
const typeName = 'VerifyTypedData'
const TData = 'VerifyTypedDataData'
const TError = 'VerifyTypedDataErrorType'
</script>

# useVerifyTypedData

Hook for verify that a typed data was signed by the provided address. It supports verifying typed data that were signed by either a Smart Contract Account or Externally Owned Account.

## Import

```ts
import { useVerifyTypedData } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseVerifyTypedDataParameters } from 'wagmi'
```

### address

`Address | undefined`

The Ethereum address that signed the original typed data.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### domain

`TypedDataDomain | undefined`

The typed data domain.

::: code-group
```tsx [index.tsx]
import { types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain: { // [!code focus:6]
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    },
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### types

The type definitions for the typed data.

::: code-group
```tsx [index.tsx]
import { domain } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types: { // [!code focus:11]
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    },
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### primaryType

`string | undefined`

The primary `type` to extract from types and use in `value`.

::: code-group
```tsx [index.tsx]
import { domain } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types: {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [ // [!code focus:5]
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    },
    primaryType: 'Mail', // [!code focus]
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### message

Type inferred from `types` & `primaryType`.

The message to be verified.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: { // [!code focus:11]
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### signature

`Hex | ByteArray | undefined`

The signature that was generated by signing the typed data with the address's signer.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus]
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useVerifyTypedData({
    chainId: mainnet.id, // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockNumber

`bigint | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    blockNumber: 12345678n, // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    blockTag: 'latest', // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useVerifyTypedData({
    config, // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { domain, types } from './data'
import { useVerifyTypedData } from 'wagmi'

function App() {
  const result = useVerifyTypedData({
    scopeKey: 'foo' // [!code focus]
    domain,
    types,
    message: {
      from: {
        name: 'Cow',
        wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
      },
      to: {
        name: 'Bob',
        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
      },
      contents: 'Hello, Bob!',
    },
    primaryType: 'Mail',
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
  })
}
```
```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseVerifyTypedDataReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

## Type Inference

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](/react/typescript) for more information.

<!--@include: @shared/query-imports.md-->

## Action

- [`verifyTypedData`](/core/api/actions/verifyTypedData)
</file>

<file path="react/api/hooks/useWaitForCallsStatus.md">
---
title: useWaitForCallsStatus
description: Waits for a call bundle to be confirmed & included on a block.
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'waitForCallsStatus'
const typeName = 'WaitForCallsStatus'
const TData = 'WaitForCallsStatusReturnType'
const TError = 'WaitForCallsStatusErrorType'
</script>

# useWaitForCallsStatus

Waits for a call bundle to be confirmed & included on a block before returning the status & receipts.

::: warning
This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useWaitForCallsStatus } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus } from 'wagmi/experimental'

function App() {
  const result = useWaitForCallsStatus({
    id: '0x...', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWaitForCallsStatusParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useWaitForCallsStatus({
    config, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

Connector to get call statuses with.

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus, useConnections } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const connections = useConnections()
  const result = useWaitForCallsStatus({
    connector: connections[0]?.connector, // [!code focus]
    id: '0x...',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### id

`string`

Identifier of the call batch.

::: code-group
```ts [index.ts]
import { useWaitForCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useWaitForCallsStatus({
  id: '0x1234567890abcdef', // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

Polling interval in milliseconds.

::: code-group
```ts [index.ts]
import { useWaitForCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useWaitForCallsStatus({
  id: '0x1234567890abcdef',
  pollingInterval: 1_000, // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

### scopeKey

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

::: code-group
```tsx [index.tsx]
import { useWaitForCallsStatus } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useWaitForCallsStatus({
    id: '0x...',
    scopeKey: 'foo', // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### timeout

`number | undefined`

Timeout in milliseconds.

::: code-group
```ts [index.ts]
import { useWaitForCallsStatus } from '@wagmi/core'
import { config } from './config'

const status = await useWaitForCallsStatus({
  id: '0x1234567890abcdef',
  timeout: 10_000, // [!code focus]
})
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWaitForCallsStatusReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`waitForCallsStatus`](https://viem.sh/experimental/eip5792/waitForCallsStatus)
</file>

<file path="react/api/hooks/useWaitForTransactionReceipt.md">
---
title: useWaitForTransactionReceipt
description: Hook that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'waitForTransactionReceipt'
const typeName = 'WaitForTransactionReceipt'
const TData = 'WaitForTransactionReceiptData'
const TError = 'WaitForTransactionReceiptErrorType'
</script>

# useWaitForTransactionReceipt

Hook that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

## Import

```ts
import { useWaitForTransactionReceipt } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWaitForTransactionReceiptParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'
import { mainnet } from 'wagmi/chains'

function App() {
  const result = useWaitForTransactionReceipt({
    chainId: mainnet.id, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### confirmations

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    confirmations: 2, // [!code focus]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
  })
}
```

### onReplaced

`
(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined
`

Optional callback to emit if the transaction has been replaced.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    onReplaced: replacement => console.log(replacement), // [!code focus]
  })
}
```

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/react/api/createConfig#pollinginterval).

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    pollingInterval: 1_000, // [!code focus]
  })
}
```

### hash

`` `0x${string}` | undefined ``

The transaction hash to wait for. [`enabled`](#enabled) set to `false` if `hash` is `undefined`.

```ts [index.ts]
import { useWaitForTransactionReceipt } from 'wagmi'

function App() {
  const result = useWaitForTransactionReceipt({
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWaitForTransactionReceiptReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`waitForTransactionReceipt`](/core/api/actions/waitForTransactionReceipt)
</file>

<file path="react/api/hooks/useWalletClient.md">
---
title: useWalletClient
description: Hook for getting a Viem `WalletClient` object for the current or provided connector.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'getWalletClient'
const typeName = 'GetWalletClient'
const TData = 'WalletClient'
const TError = 'GetWalletClientErrorType'
const hideQueryOptions = ['gcTime', 'staleTime']
</script>

# useWalletClient

Hook for getting a Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

## Import

```ts
import { useWalletClient } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWalletClient } from 'wagmi'

function App() {
  const result = useWalletClient()
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

::: warning
If you want to optimize bundle size, you should use [`useConnectorClient`](/react/api/hooks/useConnectorClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Wallet Client has all wallet actions attached directly to it.
:::

## Parameters

```ts
import { type UseWalletClientParameters } from 'wagmi'
```

### account

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

```ts
import { useWalletClient } from 'wagmi'

function App() {
  const result = useWalletClient({
    account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
  })
}
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

```ts
import { useWalletClient } from 'wagmi'

function App() {
  const result = useWalletClient({
    chainId: mainnet.id, // [!code focus]
  })
}
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWalletClient } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWalletClient({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### connector

`Connector | undefined`

- Connector to get client for.
- Defaults to current connector.

```ts
import { useConnections, useWalletClient } from 'wagmi'

function App() {
  const connections = useConnections(config)
  const result = useWalletClient({
    connector: connections[0]?.connector, // [!code focus]
  })
}
```

<!--@include: @shared/query-options.md-->

## Return Type

```ts
import { type UseWalletClientReturnType } from 'wagmi'
```

<!--@include: @shared/query-result.md-->

<!--@include: @shared/query-imports.md-->

## Action

- [`getWalletClient`](/core/api/actions/getWalletClient)
</file>

<file path="react/api/hooks/useWatchAsset.md">
---
title: useWatchAsset
description: Hook for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'watchAsset'
const typeName = 'WatchAsset'
const mutate = 'watchAsset'
const TData = 'WatchAssetData'
const TError = 'WatchAssetErrorType'
const TVariables = 'WatchAssetVariables'
</script>

# useWatchAsset

Hook for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

## Import

```ts
import { useWatchAsset } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchAsset } from 'wagmi'

function App() {
  const { watchAsset } = useWatchAsset()

  return (
    <button
      onClick={() => watchAsset({
        type: 'ERC20',
        options: {
          address: '0x0000000000000000000000000000000000000000',
          symbol: 'WAGMI',
          decimals: 18,
        },
      })}
    >
      Watch asset
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchAssetParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWatchAsset } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWatchAsset({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWatchAssetReturnType } from 'wagmi'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`watchAsset`](/core/api/actions/watchAsset)
</file>

<file path="react/api/hooks/useWatchBlockNumber.md">
---
title: useWatchBlockNumber
description: Hook that watches for block number changes.
---

# useWatchBlockNumber

Hook that watches for block number changes.

## Import

```ts
import { useWatchBlockNumber } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) {
      console.log('Block number changed!', blockNumber)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchBlockNumberParameters } from 'wagmi'
```

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    chainId: 1, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'
import { config } from './config'

function App() {
  useWatchBlockNumber({
    config, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    emitMissed: true, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    emitOnBegin: true, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### enabled

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    enabled: false, // [!code focus]
    onBlockNumber(blockNumber) {
      console.log('New block number', blockNumber)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onBlockNumber

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { // [!code focus]
      console.log('New block number', blockNumber) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }, 
    onError(error) { // [!code focus]
      console.error('Block error', error) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }
    poll: true, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }
    pollingInterval: 1_000, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { useWatchBlockNumber } from 'wagmi'

function App() {
  useWatchBlockNumber({
    onBlockNumber(blockNumber) { 
      console.log('New block number', blockNumber) 
    }
    syncConnectedChain: false, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchBlockNumberReturnType } from 'wagmi'
```

Function for cleaning up watcher.

## Action

- [`watchBlockNumber`](/core/api/actions/watchBlockNumber)
</file>

<file path="react/api/hooks/useWatchBlocks.md">
---
title: useWatchBlocks
description: Hook that watches for block changes.
---

# useWatchBlocks

Hook that watches for block changes.

## Import

```ts
import { useWatchBlocks } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchBlocksParameters } from 'wagmi'
```

### blockTag

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to watch blocks at.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    blockTag: 'latest', // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    chainId: 1, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'
import { config } from './config'

function App() {
  useWatchBlocks({
    config, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitMissed

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    emitMissed: true, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### emitOnBegin

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    emitOnBegin: true, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### enabled

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    enabled: false, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### includeTransactions

`boolean`

Whether or not to unwrap transactions as objects (instead of hashes) in blocks. Defaults to `false`.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    includeTransactions: true, // [!code focus]
    onBlock(block) {
      console.log('New block', block.number)
    },
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onBlock

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { // [!code focus]
      console.log('New block', block.number) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }, 
    onError(error) { // [!code focus]
      console.error('Block error', error) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }
    poll: true, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }
    pollingInterval: 1_000, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```ts [index.ts]
import { useWatchBlocks } from 'wagmi'

function App() {
  useWatchBlocks({
    onBlock(block) { 
      console.log('New block', block.number) 
    }
    syncConnectedChain: false, // [!code focus]
  })
}
```
<<< @/snippets/core/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchBlocksReturnType } from 'wagmi'
```

## Action

- [`watchBlocks`](/core/api/actions/watchBlocks)
</file>

<file path="react/api/hooks/useWatchContractEvent.md">
---
title: useWatchContractEvent
description: Hook that watches and returns emitted contract event logs.
---

# useWatchContractEvent

Hook that watches and returns emitted contract event logs.

## Import

```ts
import { useWatchContractEvent } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchContractEventParameters } from 'wagmi'
```

### abi

`Abi`

The contract's ABI. Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### address

`Address | undefined`

The contract's address.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f', // [!code focus]
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### args

`object | readonly unknown[] | undefined`

- Arguments to pass when calling the contract.
- Inferred from [`abi`](#abi) and [`eventName`](#eventname).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    args: { // [!code focus]
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B' // [!code focus]
    } // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### batch

`boolean | undefined`

- Whether or not the events should be batched on each invocation.
- Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    batch: false, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    chainId: 1, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    config, // [!code focus]
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### eventName

`string`

- Event to listen for the contract.
- Inferred from [`abi`](#abi).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'
import { config } from './config'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer', // [!code focus]
    onLogs(logs) {
      console.log('New logs!', logs)
    },
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    onError(error) { // [!code focus]
      console.log('Error', error) // [!code focus]
    } // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### onLogs

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) { // [!code focus]
      console.log('New logs!', logs) // [!code focus]
    } // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    poll: true // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    pollingInterval: 1_000 // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### strict

`boolean | undefined`

- Defaults to `false`.

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    strict: true // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```tsx [index.tsx]
import { useWatchContractEvent } from 'wagmi'
import { abi } from './abi'

function App() {
  useWatchContractEvent({
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    abi,
    eventName: 'Transfer',
    onLogs(logs) {
      console.log('New logs!', logs)
    },
    syncConnectedChain: true // [!code focus]
  })
}
```
<<< @/snippets/abi-event.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchContractEventReturnType } from 'wagmi'
```

Hook returns `void`

## Action

- [`watchContractEvent`](/core/api/actions/watchContractEvent)
</file>

<file path="react/api/hooks/useWatchPendingTransactions.md">
---
title: useWatchPendingTransactions
description: Hook that watches and returns pending transaction hashes.
---

# useWatchPendingTransactions

Hook that watches and returns pending transaction hashes.

## Import

```ts
import { useWatchPendingTransactions } from 'wagmi'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWatchPendingTransactionsParameters } from 'wagmi'
```

### batch

`boolean | undefined`

- Whether or not the transactions should be batched on each invocation.
- Defaults to `true`.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    batch: true // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### chainId

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    chainId: 1 // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'
import { config } from './config'

function App() {
  useWatchPendingTransactions({
    config // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onError

`((error: Error) => void) | undefined`

Error thrown from watching pending transactions.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onError(error) { // [!code focus]
      console.log('Error', error) // [!code focus]
    }, // [!code focus]
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### onTransactions

`(transactions: Hash[], prevTransactions: Hash[] | undefined) => void`

Callback when new incoming pending transactions are detected.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) { // [!code focus]
      console.log('New transactions!', transactions) // [!code focus]
    }, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### poll

`boolean | undefined`

- Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.
- Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
    poll: true, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### pollingInterval

`number | undefined`

- Polling frequency (in milliseconds).
- Defaults to the [Config's `pollingInterval` config](/core/api/createConfig#pollinginterval).

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
    pollingInterval: 1_000, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### syncConnectedChain

`boolean | undefined`

- Set up subscriber for connected chain changes.
- Defaults to [`Config['syncConnectedChain']`](/core/api/createConfig#syncconnectedchain).

::: code-group
```tsx [index.tsx]
import { useWatchPendingTransactions } from 'wagmi'

function App() {
  useWatchPendingTransactions({
    onTransactions(transactions) {
      console.log('New transactions!', transactions)
    },
    syncConnectedChain: false, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Return Type

```ts
import { type UseWatchPendingTransactionsReturnType } from 'wagmi'
```

## Action

- [`watchPendingTransactions`](/core/api/actions/watchPendingTransactions)
</file>

<file path="react/api/hooks/useWriteContract.md">
---
title: useWriteContract
description: Action for executing a write function on a contract.
---

<script setup>
const packageName = 'wagmi'
const actionName = 'writeContract'
const typeName = 'WriteContract'
const mutate = 'writeContract'
const TData = 'WriteContractReturnType'
const TError = 'WriteContractErrorType'
const TVariables = 'WriteContractVariables'
</script>

# useWriteContract

Action for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

## Import

```ts
import { useWriteContract } from 'wagmi'
```

## Usage

::: code-group

```tsx [index.tsx]
import { useWriteContract } from 'wagmi'
import { abi } from './abi'

function App() {
  const { writeContract } = useWriteContract()

  return (
    <button 
      onClick={() => 
        writeContract({ 
          abi,
          address: '0x6b175474e89094c44da98b954eedeac495271d0f',
          functionName: 'transferFrom',
          args: [
            '0xd2135CfB216b74109775236E36d4b433F1DF507B',
            '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
            123n,
          ],
       })
      }
    >
      Transfer
    </button>
  )
}
```

<<< @/snippets/abi-write.ts[abi.ts]
<<< @/snippets/react/config.ts[config.ts]
:::

<!-- TODO: Usage for simulating before -->

<!-- TODO: Usage for estimating gas before -->

## Parameters

```ts
import { type UseWriteContractParameters } from 'wagmi'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group

```tsx [index.tsx]
import { useWriteContract } from 'wagmi'
import { config } from './config' // [!code focus]

function App() {
  const result = useWriteContract({
    config, // [!code focus]
  })
}
```

<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWriteContractReturnType } from 'wagmi'
```

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](/react/typescript#const-assert-abis-typed-data) for more info.

<!--@include: @shared/mutation-result.md-->

## Type Inference

With [`abi`](/core/api/actions/writeContract#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](/core/api/actions/writeContract#functionname), [`args`](/core/api/actions/writeContract#args), and the [`value`](/core/api/actions/writeContract##value). See the Wagmi [TypeScript docs](/react/typescript) for more information.

<!--@include: @shared/mutation-imports.md-->

## Action

- [`writeContract`](/core/api/actions/writeContract)
</file>

<file path="react/api/hooks/useWriteContracts.md">
---
title: useWriteContracts
description: Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network. 
---

<script setup>
const packageName = 'wagmi/experimental'
const actionName = 'writeContracts'
const typeName = 'WriteContracts'
const mutate = 'writeContracts'
const TData = 'WriteContractsData'
const TError = 'WriteContractsErrorType'
const TVariables = 'WriteContractsVariables'
</script>

# useWriteContracts

Hook that requests for the wallet to sign and broadcast a batch of write contract calls (transactions) to the network.

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

::: warning
This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.
:::

## Import

```ts
import { useWriteContracts } from 'wagmi/experimental'
```

## Usage

::: code-group
```tsx [index.tsx]
import { useWriteContracts } from 'wagmi/experimental'
import { parseAbi } from 'viem'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])

function App() {
  const { writeContracts } = useWriteContracts()

  return (
    <button
      onClick={() =>
        writeContracts({
          contracts: [
            {
              address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
              abi,
              functionName: 'approve',
              args: [
                '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
                100n
              ],
            },
            {
              address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
              abi,
              functionName: 'transferFrom',
              args: [
                '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
                '0x0000000000000000000000000000000000000000',
                100n
              ],
            },
          ],
        })
      }
    >
      Send calls
    </button>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type UseWriteContractsParameters } from 'wagmi/experimental'
```

### config

`Config | undefined`

[`Config`](/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](/react/api/WagmiProvider).

::: code-group
```tsx [index.tsx]
import { useWriteContracts } from 'wagmi/experimental'
import { config } from './config' // [!code focus]

function App() {
  const result = useWriteContracts({
    config, // [!code focus]
  })
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

<!--@include: @shared/mutation-options.md-->

## Return Type

```ts
import { type UseWriteContractsReturnType } from 'wagmi/experimental'
```

<!--@include: @shared/mutation-result.md-->

<!--@include: @shared/mutation-imports.md-->

## Action

- [`writeContracts`](/core/api/actions/writeContracts)
</file>

<file path="react/api/transports/custom.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/custom.md -->
</file>

<file path="react/api/transports/fallback.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/fallback.md -->
</file>

<file path="react/api/transports/http.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/http.md -->
</file>

<file path="react/api/transports/unstable_connector.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/unstable_connector.md -->
</file>

<file path="react/api/transports/webSocket.md">
<script setup>
const packageName = 'wagmi'
</script>

<!-- @include: @shared/transports/webSocket.md -->
</file>

<file path="react/api/utilities/cookieToInitialState.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/cookieToInitialState.md-->
</file>

<file path="react/api/utilities/deserialize.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/deserialize.md-->
</file>

<file path="react/api/utilities/normalizeChainId.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/normalizeChainId.md-->
</file>

<file path="react/api/utilities/serialize.md">
<script setup>
const packageName = 'wagmi'
</script>

<!--@include: @shared/utilities/serialize.md-->
</file>

<file path="react/api/actions.md">
# Actions

Sometimes the declarative nature of React Hooks doesn't work for parts of your app. For those cases, you can use Wagmi Core Actions directly!

All the Wagmi Core Actions are importable using the `wagmi/actions` entrypoint. For example, you can use the `watchBlockNumber` action to watch for block number changes.

::: code-group
```ts [index.tsx]
import { useConfig } from 'wagmi'
import { watchBlockNumber } from 'wagmi/actions'
import { useEffect } from 'react'

function App() {
  const config = useConfig()

  useEffect(() => {
    return watchBlockNumber(config, {
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
  }, [])
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

See the [Wagmi Core docs](/core/api/actions) for more info on what actions are available.
</file>

<file path="react/api/chains.md">
<script setup>
import packageJson from '../../../package.json'
import SearchChains from '../../components/SearchChains.vue'

const viemVersion = packageJson.devDependencies.viem
</script>

# Chains

Viem `Chain` objects. More info at the [Viem docs](https://viem.sh/docs/chains/introduction).

## Import

Import via the `'wagmi/chains'` entrypoint (proxies all chains from `'viem/chains'`).

```ts
import { mainnet } from 'wagmi/chains'
```

## Available Chains

Chain definitions as of `viem@{{viemVersion}}`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

<SearchChains />

<!--@include: @shared/create-chain.md-->
</file>

<file path="react/api/connectors.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const connectors = getSidebar()['/react']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Connectors')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Connectors

Connectors for popular wallet providers and protocols.

## Import

Import via the `'wagmi/connectors'` entrypoint.

```ts
import { injected } from 'wagmi/connectors'
```

## Available Connectors

<ul>
  <li v-for="connector of connectors">
    <a :href="connector.link">{{ connector.text }}</a>
  </li>
</ul>
</file>

<file path="react/api/createConfig.md">
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>

<!--@include: @shared/createConfig.md-->
</file>

<file path="react/api/createStorage.md">
<script setup>
const docsPath = "react"
const packageName = 'wagmi'
</script>

<!--@include: @shared/createStorage.md-->
</file>

<file path="react/api/errors.md">
<script setup>
const docsPath = "react"
const packageName = 'wagmi'
</script>

# Errors

Error classes used by Wagmi.

<!--@include: @shared/errors.md-->

## React

### WagmiProviderNotFoundError

When a Wagmi hook is used outside of a [`WagmiProvider`](/react/api/WagmiProvider).

```ts
import { WagmiProviderNotFoundError } from 'wagmi'
```
</file>

<file path="react/api/hooks.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const hooks = getSidebar()['/react']
  .find(x => x.text === 'Hooks').items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Hooks

React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more.

## Import

```ts
import { useAccount } from 'wagmi'
```

## Available Hooks

<ul>
  <li v-for="hook of hooks">
    <a :href="hook.link">{{ hook.text }}</a>
  </li>
</ul>
</file>

<file path="react/api/transports.md">
<script setup>
import { getSidebar } from '../../.vitepress/sidebar'

const transports = getSidebar()['/core']
  .find(x => x.text.includes('Configuration')).items
  .find(x => x.text.includes('Transports')).items
  .sort((a, b) => a.text.localeCompare(b.text))
</script>

# Transports

[`createConfig`](/react/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

## Import

```ts
import { http } from 'wagmi'
```

## Built-In Transports

Available via the `'wagmi'` entrypoint.

<ul>
  <li v-for="transport of transports">
    <a :href="transport.link">{{ transport.text }}</a>
  </li>
</ul>
</file>

<file path="react/api/WagmiProvider.md">
# WagmiProvider

React Context Provider for Wagmi.

## Import

```ts
import { WagmiProvider } from 'wagmi'
```

## Usage

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider config={config}> 
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Parameters

```ts
import { type WagmiProviderProps } from 'wagmi'
```

### config

[`Config`](/react/api/createConfig#config) object to inject with context.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider
      config={config} // [!code focus]
    >
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### initialState

`State | undefined`

- Initial state to hydrate into the [Wagmi Config](/react/api/createConfig). Useful for SSR.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider
      config={config}
      initialState={/* ... /*} // [!code focus]
    >
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### reconnectOnMount

`boolean | undefined`

- Whether or not to reconnect previously connected [connectors](/react/api/createConfig#connectors) on mount.
- Defaults to `true`.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi'
import { config } from './config' 

function App() {
  return (
    <WagmiProvider
      config={config}
      reconnectOnMount={false} // [!code focus]
    >
      {/** ... */}
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Context

```ts
import { type WagmiContext } from 'wagmi'
```
</file>

<file path="react/guides/chain-properties.md">
# Chain Properties

Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains all support additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

<br/>

::: tip
Make sure you follow the TypeScript guide's [Config Types](/react/typescript#config-types) section before moving on. The easiest way to do this is to use [Declaration Merging](/react/typescript#declaration-merging) to "register" your `config` globally with TypeScript.

<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

## Narrowing Parameters

Once your Config is registered with TypeScript, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

::: code-group
```ts [index.tsx]
import { parseEther } from 'viem'
import { useSimulateContract } from 'wagmi'

const result = useSimulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  feeCurrency: '0x', // [!code focus]
})
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

::: code-group
```ts [index.tsx]
import { parseEther } from 'viem'
import { useSimulateContract } from 'wagmi'
import { celo } from 'wagmi/chains'

const result = useSimulateContract({
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
  chainId: celo.id, // [!code focus]
  feeCurrency: '0x', // [!code focus]
  // ^? (property) feeCurrency?: `0x${string}` | undefined // [!code focus]
})
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

## Narrowing Return Types

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

::: code-group
```ts [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'
import { zkSync } from 'wagmi/chains'

const { data } = useWaitForTransactionReceipt({
  chainId: zkSync.id,
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

data?.logs
//    ^? (property) logs: ZkSyncLog[] | undefined
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

### `chainId` Data Property

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

::: code-group
```ts [index.tsx]
import { useWaitForTransactionReceipt } from 'wagmi'
import { zkSync } from 'wagmi/chains'

const { data } = useWaitForTransactionReceipt({
  hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
})

if (data?.chainId === zkSync.id) {
  data?.logs
  //    ^? (property) logs: ZkSyncLog[] | undefined
}
```
<<< @/snippets/react/config-chain-properties.ts[config.ts]
:::

## Troubleshooting

If chain properties aren't working, make sure [TypeScript](/react/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).
</file>

<file path="react/guides/connect-wallet.md">
# Connect Wallet

The ability for a user to connect their wallet is a core function for any Dapp. It allows users to perform tasks such as: writing to contracts, signing messages, or sending transactions.

Wagmi contains everything you need to get started with building a Connect Wallet module. To get started, you can either use a [third-party library](#third-party-libraries) or [build your own](#build-your-own).

## Third-party Libraries

You can use a pre-built Connect Wallet module from a third-party library such as:

- [ConnectKit](https://docs.family.co/connectkit) - [Guide](https://docs.family.co/connectkit/getting-started)
- [AppKit](https://walletconnect.com/appkit) - [Guide](https://docs.walletconnect.com/appkit/next/core/installation)
- [RainbowKit](https://www.rainbowkit.com/) - [Guide](https://www.rainbowkit.com/docs/installation)
- [Dynamic](https://www.dynamic.xyz/) - [Guide](https://docs.dynamic.xyz/quickstart)
- [Privy](https://privy.io) - [Guide](https://docs.privy.io/guide/react/wallets/usage/wagmi)

The above libraries are all built on top of Wagmi, handle all the edge cases around wallet connection, and provide a seamless Connect Wallet UX that you can use in your Dapp.

## Build Your Own

Wagmi provides you with the Hooks to get started building your own Connect Wallet module. 

It takes less than five minutes to get up and running with Browser Wallets, WalletConnect, and Coinbase Wallet.

### 1. Configure Wagmi

Before we get started with building the functionality of the Connect Wallet module, we will need to set up the Wagmi configuration.

Let's create a `config.ts` file and export a `config` object.

::: code-group

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

In the above configuration, we want to set up connectors for Injected (browser), WalletConnect (browser + mobile), MetaMask, and Safe wallets. This configuration uses the **Mainnet** and **Base** chains, but you can use whatever you want.

::: warning

Make sure to replace the `projectId` with your own WalletConnect Project ID, if you wish to use WalletConnect! 

[Get your Project ID](https://cloud.walletconnect.com/)

:::

### 2. Wrap App in Context Provider

Next, we will need to wrap our React App with Context so that our application is aware of Wagmi & React Query's reactive state and in-memory caching.

::: code-group

```tsx [app.tsx]
 // 1. Import modules
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

// 2. Set up a React Query client.
const queryClient = new QueryClient()

function App() {
  // 3. Wrap app with Wagmi and React Query context.
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        {/** ... */} 
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 3. Display Wallet Options

After that, we will create a `WalletOptions` component that will display our connectors. This will allow users to select a wallet and connect.

Below, we are rendering a list of `connectors` retrieved from `useConnect`. When the user clicks on a connector, the `connect` function will connect the users' wallet.

::: code-group

```tsx [wallet-options.tsx]
import * as React from 'react'
import { Connector, useConnect } from 'wagmi'

export function WalletOptions() {
  const { connectors, connect } = useConnect()

  return connectors.map((connector) => (
    <button key={connector.uid} onClick={() => connect({ connector })}>
      {connector.name}
    </button>
  ))
}
```

```tsx [app.tsx]
 // 1. Import modules
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

// 2. Set up a React Query client.
const queryClient = new QueryClient()

function App() {
  // 3. Wrap app with Wagmi and React Query context.
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        {/* ... */}
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 4. Display Connected Account

Lastly, if an account is connected, we want to show some basic information, like the connected address and ENS name and avatar.

Below, we are using hooks like `useAccount`, `useEnsAvatar` and `useEnsName` to extract this information.

We are also utilizing `useDisconnect` to show a "Disconnect" button so a user can disconnect their wallet.

::: code-group

```tsx [account.tsx]
import { useAccount, useDisconnect, useEnsAvatar, useEnsName } from 'wagmi'

export function Account() {
  const { address } = useAccount()
  const { disconnect } = useDisconnect()
  const { data: ensName } = useEnsName({ address })
  const { data: ensAvatar } = useEnsAvatar({ name: ensName! })

  return (
    <div>
      {ensAvatar && <img alt="ENS Avatar" src={ensAvatar} />}
      {address && <div>{ensName ? `${ensName} (${address})` : address}</div>}
      <button onClick={() => disconnect()}>Disconnect</button>
    </div>
  )
}
```

```tsx [wallet-options.tsx]
import * as React from 'react'
import { Connector, useConnect } from 'wagmi'

export function WalletOptions() {
  const { connectors, connect } = useConnect()

  return connectors.map((connector) => (
    <WalletOption
      key={connector.uid}
      connector={connector}
      onClick={() => connect({ connector })}
    />
  ))
}

function WalletOption({
  connector,
  onClick,
}: {
  connector: Connector
  onClick: () => void
}) {
  const [ready, setReady] = React.useState(false)

  React.useEffect(() => {
    ;(async () => {
      const provider = await connector.getProvider()
      setReady(!!provider)
    })()
  }, [connector])

  return (
    <button disabled={!ready} onClick={onClick}>
      {connector.name}
    </button>
  )
}
```

```tsx [app.tsx]
 // 1. Import modules
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

// 2. Set up a React Query client.
const queryClient = new QueryClient()

function App() {
  // 3. Wrap app with Wagmi and React Query context.
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        {/* ... */}
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### 5. Wire it up!

Finally, we can wire up our Wallet Options and Account components to our application's entrypoint.

::: code-group

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from './config'
import { Account } from './account' // [!code ++]
import { WalletOptions } from './wallet-options' // [!code ++]

const queryClient = new QueryClient()

function ConnectWallet() { // [!code ++]
  const { isConnected } = useAccount() // [!code ++]
  if (isConnected) return <Account /> // [!code ++]
  return <WalletOptions /> // [!code ++]
} // [!code ++]

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        <ConnectWallet /> // [!code ++]
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [account.tsx]
import { useAccount, useDisconnect, useEnsAvatar, useEnsName } from 'wagmi'

export function Account() {
  const { address } = useAccount()
  const { disconnect } = useDisconnect()
  const { data: ensName } = useEnsName({ address })
  const { data: ensAvatar } = useEnsAvatar({ name: ensName! })

  return (
    <div>
      {ensAvatar && <img alt="ENS Avatar" src={ensAvatar} />}
      {address && <div>{ensName ? `${ensName} (${address})` : address}</div>}
      <button onClick={() => disconnect()}>Disconnect</button>
    </div>
  )
}
```

```tsx [wallet-options.tsx]
import * as React from 'react'
import { Connector, useConnect } from 'wagmi'

export function WalletOptions() {
  const { connectors, connect } = useConnect()

  return connectors.map((connector) => (
    <WalletOption
      key={connector.uid}
      connector={connector}
      onClick={() => connect({ connector })}
    />
  ))
}

function WalletOption({
  connector,
  onClick,
}: {
  connector: Connector
  onClick: () => void
}) {
  const [ready, setReady] = React.useState(false)

  React.useEffect(() => {
    ;(async () => {
      const provider = await connector.getProvider()
      setReady(!!provider)
    })()
  }, [connector])

  return (
    <button disabled={!ready} onClick={onClick}>
      {connector.name}
    </button>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

### Playground

Want to see the above steps all wired up together in an end-to-end example? Check out the below StackBlitz playground.

<br/>

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-ujbsuv?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>
</file>

<file path="react/guides/error-handling.md">
# Error Handling

The `error` property in Wagmi Hooks is strongly typed with it's corresponding error type. This enables you to have granular precision with handling errors in your application.

You can discriminate the error type by using the `name` property on the error object.

::: code-group
```tsx twoslash [index.tsx]
// @noErrors
import { useBlockNumber } from 'wagmi'

function App() {
  const { data, error } = useBlockNumber()
  //            ^?

  error?.name
  //     ^?






  if (error?.name === 'HttpRequestError') {
    const { status } = error
    //      ^?      


    return <div>A HTTP error occurred. Status: {status}</div>
  }
  if (error?.name === 'LimitExceededRpcError') {
    const { code } = error
    //      ^?

    
    return <div>Rate limit exceeded. Code: {code}</div>
  }
  // ...
}
```
<<< @/snippets/react/config.ts[config.ts]
:::
</file>

<file path="react/guides/ethers.md">
# Ethers.js Adapters

It is recommended for projects to migrate to [Viem](https://viem.sh) when using Wagmi, but there are some cases where you might still need to use [Ethers.js](https://ethers.org) in your project:

- You may want to **incrementally migrate** Ethers.js usage to Viem
- Some **third-party libraries & SDKs** may only support Ethers.js
- Personal preference

We have provided reference implementations for Viem  Ethers.js adapters that you can copy + paste in your project.

## Client  Provider

### Reference Implementation

Copy the following reference implementation into a file of your choice:

::: code-group

```ts [Ethers v5]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback')
    return new providers.FallbackProvider(
      (transport.transports as ReturnType<Transport>[]).map(
        ({ value }) => new providers.JsonRpcProvider(value?.url, network),
      ),
    )
  return new providers.JsonRpcProvider(transport.url, network)
}

/** Hook to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({
  chainId,
}: { chainId?: number | undefined } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

```ts [Ethers v6]
import { FallbackProvider, JsonRpcProvider } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { type Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback') {
    const providers = (transport.transports as ReturnType<Transport>[]).map(
      ({ value }) => new JsonRpcProvider(value?.url, network),
    )
    if (providers.length === 1) return providers[0]
    return new FallbackProvider(providers)
  }
  return new JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({ chainId }: { chainId?: number } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

:::

### Usage

Now you can use the `useEthersProvider` function in your components:

::: code-group

```ts [example.ts]
import { useEthersProvider } from './ethers'

function Example() {
  const provider = useEthersProvider()
  ...
}
```

```ts [ethers.ts (Ethers v5)]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback')
    return new providers.FallbackProvider(
      (transport.transports as ReturnType<Transport>[]).map(
        ({ value }) => new providers.JsonRpcProvider(value?.url, network),
      ),
    )
  return new providers.JsonRpcProvider(transport.url, network)
}

/** Hook to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({
  chainId,
}: { chainId?: number | undefined } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

```ts [ethers.ts (Ethers v6)]
import { FallbackProvider, JsonRpcProvider } from 'ethers'
import { useMemo } from 'react'
import type { Chain, Client, Transport } from 'viem'
import { type Config, useClient } from 'wagmi'

export function clientToProvider(client: Client<Transport, Chain>) {
  const { chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  if (transport.type === 'fallback') {
    const providers = (transport.transports as ReturnType<Transport>[]).map(
      ({ value }) => new JsonRpcProvider(value?.url, network),
    )
    if (providers.length === 1) return providers[0]
    return new FallbackProvider(providers)
  }
  return new JsonRpcProvider(transport.url, network)
}

/** Action to convert a viem Client to an ethers.js Provider. */
export function useEthersProvider({ chainId }: { chainId?: number } = {}) {
  const client = useClient<Config>({ chainId })
  return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
}
```

:::

## Connector Client  Signer

### Reference Implementation

Copy the following reference implementation into a file of your choice:

::: code-group

```ts [Ethers v5]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new providers.Web3Provider(transport, network)
  const signer = provider.getSigner(account.address)
  return signer
}

/** Hook to convert a Viem Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

```ts [Ethers v6]
import { BrowserProvider, JsonRpcSigner } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { type Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new BrowserProvider(transport, network)
  const signer = new JsonRpcSigner(provider, account.address)
  return signer
}

/** Hook to convert a viem Wallet Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

:::

### Usage

Now you can use the `useEthersSigner` function in your components:

::: code-group

```ts [example.ts]
import { useEthersSigner } from './ethers'

function example() {
  const signer = useEthersSigner()
  ...
}
```

```ts [ethers.ts (Ethers v5)]
import { providers } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new providers.Web3Provider(transport, network)
  const signer = provider.getSigner(account.address)
  return signer
}

/** Action to convert a Viem Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

```ts [ethers.ts (Ethers v6)]
import { BrowserProvider, JsonRpcSigner } from 'ethers'
import { useMemo } from 'react'
import type { Account, Chain, Client, Transport } from 'viem'
import { type Config, useConnectorClient } from 'wagmi'

export function clientToSigner(client: Client<Transport, Chain, Account>) {
  const { account, chain, transport } = client
  const network = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: chain.contracts?.ensRegistry?.address,
  }
  const provider = new BrowserProvider(transport, network)
  const signer = new JsonRpcSigner(provider, account.address)
  return signer
}

/** Hook to convert a viem Wallet Client to an ethers.js Signer. */
export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
  const { data: client } = useConnectorClient<Config>({ chainId })
  return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
}
```

:::
</file>

<file path="react/guides/faq.md">
<script setup>
const docsPath = 'react'
</script>

# FAQ / Troubleshooting

Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

<!--@include: @shared/faq.md-->

## How does Wagmi work?

Until there's a more in-depth write-up about Wagmi internals, here is the gist:

- Wagmi is essentially a wrapper around [Viem](https://viem.sh) and TanStack Query that adds connector and multichain support.
- [Connectors](/react/api/connectors) allow Wagmi and Ethereum accounts to communicate with each other.
- The Wagmi [`Config`](/react/api/createConfig#config) manages connections established between Wagmi and Connectors, as well as some global state. [Connections](/react/api/createConfig#connection) come with one or more addresses and a chain ID.
  - If there are connections, the Wagmi `Config` listens for connection changes and updates the [`chainId`](/react/api/createConfig#chainid) based on the ["current" connection](/react/api/createConfig#current). (The Wagmi `Config` can have [many connections established](/react/api/createConfig#connections) at once, but only one connection can be the "current" connection. Usually this is the connection from the last connector that is connected, but can change based on event emitted from other connectors or through the [`useSwitchAccount`](/react/api/hooks/useSwitchAccount) hook and [`switchAccount`](/core/api/actions/switchAccount) action.)
  - If there are no connections, the Wagmi `Config` defaults the global state `chainId` to the first chain it was created with or last established connection.
  - The global `chainId` can be changed directly using the [`useSwitchChain`](/react/api/hooks/useSwitchChain) hook and [`switchChain`](/core/api/actions/switchChain) action. This works when there are no connections as well as for most connectors (not all connectors support chain switching).
- Wagmi uses the global `chainId` (from the "current" connection or global state) to internally create Viem Client's, which are used by hooks and actions.
- Hooks are constructed by TanStack Query options helpers, exported by the `'@wagmi/core/query'` entrypoint, and some additional code to wire up type parameters, hook into React Context, etc.
- There are three types of hooks: query hooks, mutation hooks, and config hooks. Query hooks, like [`useCall`](/react/api/hooks/useCall), generally read blockchain state and mutation hooks, like [`useSendTransaction`](/react/api/hooks/useSendTransaction), usually change state through sending transactions via the "current" connection. Config hooks are for getting data from and managing the Wagmi `Config` instance, e.g. [`useChainId`](/react/api/hooks/useChainId) and `useSwitchAccount`. Query and mutation hooks usually have corresponding [Viem actions.](https://viem.sh)
</file>

<file path="react/guides/migrate-from-v1-to-v2.md">
---
title: Migrate from v1 to v2
description: Guide for migrating from Wagmi v1 to v2.
---

<script setup>
import packageJson from '../../../packages/react/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Migrate from v1 to v2

## Overview

Wagmi v2 redesigns the core APIs to mesh better with [Viem](https://viem.sh) and [TanStack Query](https://tanstack.com/query/v5/docs/react). This major version transforms Wagmi into a light wrapper around these libraries, sprinkling in multichain support and account management. As such, there are some breaking changes and deprecations to be aware of outlined in this guide.

To get started, install the latest version of Wagmi and it's required peer dependencies.

::: code-group
```bash-vue [pnpm]
pnpm add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [npm]
npm install wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [yarn]
yarn add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [bun]
bun add wagmi viem@{{viemVersion}} @tanstack/react-query
```
:::

::: info Wagmi v2 should be the last major version that will have this many actionable breaking changes. 
Moving forward after Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.
:::

::: info Not ready to migrate yet?
The Wagmi v1 docs are still available at [1.x.wagmi.sh/react](https://1.x.wagmi.sh/react).
:::

## Dependencies

### Moved TanStack Query to peer dependencies

Wagmi uses [TanStack Query](https://tanstack.com/query/v5/docs/react) to manage async state, handling requests, caching, and more. With Wagmi v1, TanStack Query was an internal implementation detail. With Wagmi v2, TanStack Query is a peer dependency. A lot of Wagmi users also use TanStack Query in their apps so making it a peer dependency gives them more control and removes some custom Wagmi code internally.

If you don't normally use TanStack Query, all you need to do is set it up and mostly forget about it (we'll provide guidance around version updates).

::: code-group
```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query' // [!code ++]
import { WagmiProvider } from 'wagmi'
import { config } from './config'

const queryClient = new QueryClient() // [!code ++]

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> // [!code ++]
        {/** ... */}
      </QueryClientProvider> // [!code ++]
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

For more information on setting up TanStack Query for Wagmi, follow the [Getting Started docs](/react/getting-started#setup-tanstack-query). If you want to set up persistence for your query cache (default behavior before Wagmi v2), check out the [TanStack Query docs](https://tanstack.com/query/v5/docs/react/plugins/persistQueryClient#usage-with-react).

### Dropped CommonJS support

Wagmi v2 no longer publishes a separate `cjs` tag since very few people use this tag and ESM is the future. See [Sindre Sorhus' guide](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c) for more info about switching to ESM.

## Hooks

### Removed mutation setup arguments

Mutation hooks are hooks that change network or application state, sign data, or perform write operations through mutation functions. With Wagmi v1, you could pass arguments directly to these hooks instead of using them with their mutation functions. For example:

```ts{3}
// Wagmi v1
const { signMessage } = useSignMessage({
  message: 'foo bar baz',
})
```

With Wagmi v2, you must pass arguments to the mutation function instead. This follows the same behavior as [TanStack Query](https://tanstack.com/query/v5/docs/react/guides/mutations) mutations and improves type-safety.

```tsx
import { useSignMessage } from 'wagmi'

const { signMessage } = useSignMessage({ message: 'foo bar baz' }) // [!code --]
const { signMessage } = useSignMessage() // [!code ++]

<button
  onClick={() => signMessage()} // [!code --]
  onClick={() => signMessage({ message: 'foo bar baz' })} // [!code ++]
>
  Sign message
</button>
```

### Moved TanStack Query parameters to `query` property

Previously, you could pass TanStack Query parameters, like `enabled` and `staleTime`, directly to hooks. In Wagmi v2, TanStack Query parameters are now moved to the `query` property. This allows Wagmi to better support TanStack Query type inference, control for future breaking changes since [TanStack Query is now a peer dependency](#moved-tanstack-query-to-peer-dependencies), and expose Wagmi-related hook property at the top-level of editor features, like autocomplete.

```tsx
useReadContract({
  enabled: false, // [!code --]
  staleTime: 1_000, // [!code --]
  query: { // [!code ++]
    enabled: false, // [!code ++]
    staleTime: 1_000, // [!code ++]
  }, // [!code ++]
})
```

### Removed watch property

The `watch` property was removed from all hooks besides [`useBlock`](/react/api/hooks/useBlock) and [`useBlockNumber`](/react/api/hooks/useBlockNumber). This property allowed hooks to internally listen for block changes and automatically refresh their data. In Wagmi v2, you can compose `useBlock` or `useBlockNumber` along with [`React.useEffect`](https://react.dev/reference/react/useEffect) to achieve the same behavior. Two different approaches are outlined for `useBalance` below.

::: code-group
```ts [invalidateQueries]
import { useQueryClient } from '@tanstack/react-query' // [!code ++]
import { useEffect } from 'react' // [!code ++]
import { useBlockNumber, useBalance } from 'wagmi' // [!code ++]

const queryClient = useQueryClient() // [!code ++]
const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code ++]
const { data: balance, queryKey } = useBalance({ // [!code ++]
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  watch: true, // [!code --]
})

useEffect(() => { // [!code ++]
  queryClient.invalidateQueries({ queryKey }) // [!code ++]
}, [blockNumber, queryClient]) // [!code ++]
```
```ts [refetch]
import { useEffect } from 'react' // [!code ++]
import { useBlockNumber, useBalance } from 'wagmi' // [!code ++]

const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code ++]
const { data: balance, refetch } = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  watch: true, // [!code --]
})

useEffect(() => { // [!code ++]
  refetch() // [!code ++]
}, [blockNumber]) // [!code ++]
```
:::

This is a bit more code, but removes a lot of internal code from hooks that can slow down your app when not used and gives you more control. For example, you can easily refresh data every five blocks instead of every block.

```ts
const { data: blockNumber } = useBlockNumber({ watch: true })
const { data: balance, queryKey } = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
})

useEffect(() => {
  if (blockNumber % 5 === 0) // [!code focus]
    queryClient.invalidateQueries({ queryKey }) // [!code focus]
}, [blockNumber, queryClient])
```

### Removed suspense property

Wagmi used to support an experimental `suspense` property via TanStack Query. Since TanStack Query [removed `suspense`](https://tanstack.com/query/v5/docs/react/guides/migrating-to-v5#new-hooks-for-suspense) from its `useQuery` hook, it is no longer supported by Wagmi Hooks.

Instead, you can use `useSuspenseQuery` along with TanStack Query-related exports from the `'wagmi/query'` entrypoint.

```ts
import { useSuspenseQuery } from '@tanstack/react-query' // [!code ++]
import { useConfig } from 'wagmi' // [!code ++]
import { getBalanceQueryOptions } from 'wagmi/query' // [!code ++]
import { useBalance } from 'wagmi' // [!code --]

const config = useConfig() // [!code ++]
const options = getBalanceQueryOptions(config, { address: '0x' }) // [!code ++]
const result = useSuspenseQuery(options) // [!code ++]
const result = useBalance({ // [!code --]
  address: '0x', // [!code --]
  suspense: true, // [!code --]
}) // [!code --]
```

### Removed prepare hooks

`usePrepareContractWrite` and `usePrepareSendTransaction` were removed and replaced with idiomatic Viem alternatives. For `usePrepareContractWrite`, use [`useSimulateContract`](/react/api/hooks/useSimulateContract). Similar to `usePrepareContractWrite`, `useSimulateContract` composes well with `useWriteContract`

```tsx
import { usePrepareContractWrite, useWriteContract } from 'wagmi' // [!code --]
import { useSimulateContract, useWriteContract } from 'wagmi' // [!code ++]

const { config } = usePrepareContractWrite({ // [!code --]
const { data } = useSimulateContract({ // [!code ++]
  address: '0x',
  abi: [{
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'sender', type: 'address' },
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  }],
  functionName: 'transferFrom',
  args: ['0x', '0x', 123n],
})
const { write } = useWriteContract(config) // [!code --]
const { writeContract } = useWriteContract() // [!code ++]

<button
  disabled={!Boolean(write)} // [!code --]
  onClick={() => write()} // [!code --]
  disabled={!Boolean(data?.request)} // [!code ++]
  onClick={() => writeContract(data!.request)} // [!code ++]
>
  Write contract
</button>
```

Instead of `usePrepareSendTransaction`, use [`useEstimateGas`](/react/api/hooks/useEstimateGas). You can pass `useEstimateGas` `data` to `useSendTransaction` to compose the two hooks.

```tsx
import { usePrepareSendTransaction, useSendTransaction } from 'wagmi' // [!code --]
import { useEstimateGas, useSendTransaction } from 'wagmi' // [!code ++]
import { parseEther } from 'viem'

const { config } = usePrepareSendTransaction({ // [!code --]
const { data } = useEstimateGas({ // [!code ++]
  to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  value: parseEther('0.01'),
})
const { sendTransaction } = useSendTransaction(config) // [!code --]
const { sendTransaction } = useSendTransaction() // [!code ++]

<button
  disabled={!Boolean(sendTransaction)} // [!code --]
  onClick={() => sendTransaction()} // [!code --]
  disabled={!Boolean(data)} // [!code ++]
  onClick={() => sendTransaction({ // [!code ++]
    gas: data, // [!code ++]
    to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code ++]
    value: parseEther('0.01'), // [!code ++]
  })} // [!code ++]
>
  Send transaction
</button>
```

This might seem like more work, but it gives you more control and is more accurate representation of what is happening under the hood.

### Removed `useNetwork` hook

The `useNetwork` hook was removed since the connected chain is typically based on the connected account. Use [`useAccount`](/react/api/hooks/useAccount) to get the connected `chain`.

```ts
import { useNetwork } from 'wagmi' // [!code --]
import { useAccount } from 'wagmi' // [!code ++]

const { chain } = useNetwork() // [!code --]
const { chain } = useAccount() // [!code ++]
```

Use `useConfig` for the list of `chains` set up with the Wagmi [`Config`](/react/api/createConfig#chains).

```ts
import { useNetwork } from 'wagmi' // [!code --]
import { useConfig } from 'wagmi' // [!code ++]

const { chains } = useNetwork() // [!code --]
const { chains } = useConfig() // [!code ++]
```

### Removed `onConnect` and `onDisconnect` callbacks from `useAccount`

The `onConnect` and `onDisconnect` callbacks were removed from the `useAccount` hook since it is frequently used without these callbacks so it made sense to extract these into a new API, [`useAccountEffect`](/react/api/hooks/useAccountEffect), rather than clutter the `useAccount` hook.

```ts
import { useAccount } from 'wagmi' // [!code --]
import { useAccountEffect } from 'wagmi' // [!code ++]

useAccount({ // [!code --]
useAccountEffect({ // [!code ++]
  onConnect(data) {
    console.log('connected', data)
  },
  onDisconnect() {
    console.log('disconnected')
  },
}) 
```

### Removed `useWebSocketPublicClient`

The Wagmi [`Config`](/react/api/createConfig) does not separate transport types anymore. Simply use Viem's [`webSocket`](https://viem.sh/docs/clients/transports/websocket.html) transport instead when setting up your Wagmi `Config`. You can get Viem `Client` instance with this transport attached by using [`useClient`](/react/api/hooks/useClient) or [`usePublicClient`](/react/api/hooks/usePublicClient).

### Removed `useInfiniteReadContracts` `paginatedIndexesConfig`

In the spirit of removing unnecessary abstractions, `paginatedIndexesConfig` was removed. Use `useInfiniteReadContracts`'s `initialPageParam` and `getNextPageParam` parameters along with `fetchNextPage`/`fetchPreviousPage` from the result instead or copy `paginatedIndexesConfig`'s implementation to your codebase.

See the [TanStack Query docs](https://tanstack.com/query/v5/docs/react/guides/infinite-queries) for more information on infinite queries.

### Updated `useSendTransaction` and `useWriteContract` return type

Updated [`useSendTransaction`](/react/api/hooks/useSendTransaction) and [`useWriteContract`](/react/api/hooks/useWriteContract) return type from `` { hash: `0x${string}` } `` to `` `0x${string}` ``.

```ts
const result = useSendTransaction()
result.data?.hash // [!code --]
result.data // [!code ++]
```

### Updated `useConnect` return type

Updated [`useConnect`](/react/api/hooks/useConnect) return type from `` { account: Address; chain: { id: number; unsupported?: boolean }; connector: Connector } `` to `` { accounts: readonly Address[]; chainId: number } ``. This better reflects the ability to have multiple accounts per connector.

### Renamed parameters and return types

All hook parameters and return types follow the naming pattern of `[PascalCaseHookName]Parameters` and `[PascalCaseHookName]ReturnType`. For example, `UseAccountParameters` and `UseAccountReturnType`.

```ts
import { UseAccountConfig, UseAccountResult } from 'wagmi' // [!code --]
import { UseAccountParameters, UseAccountReturnType } from 'wagmi' // [!code ++]
```

## Connectors

### Updated connector API

In order to maximize type-safety and ease of creating connectors, the connector API changed. Follow the [Creating Connectors guide](/dev/creating-connectors) for more info on creating new connectors and converting Wagmi v1 connectors.

### Removed individual entrypoints

Previously, each connector had it's own entrypoint to optimize tree-shaking. Since all connectors now have [`package.json#sideEffects`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) enabled, this is no longer necessary and the entrypoint is unified. Use the `'wagmi/connectors'` entrypoint instead.

```ts
import { InjectedConnector } from 'wagmi/connectors/injected' // [!code --]
import { CoinbaseWalletConnector } from 'wagmi/connectors/coinbaseWallet' // [!code --]
import { coinbaseWallet, injected } from 'wagmi/connectors' // [!code ++]
```

### Removed `MetaMaskConnector`

The `MetaMaskConnector` was removed since it was nearly the same thing as the `InjectedConnector`. Use the [`injected`](/react/api/connectors/injected) connector instead, along with the [`target`](/react/api/connectors/injected#target) parameter set to `'metaMask'`, for the same behavior.

```ts
import { MetaMaskConnector } from 'wagmi/connectors/metaMask' // [!code --]
import { injected } from 'wagmi/connectors' // [!code ++]

const connector = new MetaMaskConnector() // [!code --]
const connector = injected({ target: 'metaMask' }) // [!code ++]
```
### Renamed connectors

In Wagmi v1, connectors were classes you needed to instantiate. In Wagmi v2, connectors are functions. As a result, the API has changed. Connectors have the following new names:

- `CoinbaseWalletConnector` is now [`coinbaseWallet`](/react/api/connectors/coinbaseWallet).
- `InjectedConnector` is now [`injected`](/react/api/connectors/injected).
- `SafeConnector` is now [`safe`](/react/api/connectors/safe).
- `WalletConnectConnector` is now [`walletConnect`](/react/api/connectors/walletConnect).

To create a connector, you now call the connector function with parameters.

```ts
import { WalletConnectConnector } from 'wagmi/connectors/walletConnect' // [!code --]
import { walletConnect } from 'wagmi/connectors' // [!code ++]

const connector = new WalletConnectConnector({ // [!code --]
const connector = walletConnect({ // [!code ++]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### Removed `WalletConnectLegacyConnector`

WalletConnect v1 was sunset June 28, 2023. Use the [`walletConnect`](/react/api/connectors/walletConnect) connector instead.

```ts
import { WalletConnectLegacyConnector } from 'wagmi/connectors/walletConnectLegacy' // [!code --]
import { walletConnect } from 'wagmi/connectors' // [!code ++]

const connector = new WalletConnectLegacyConnector({ // [!code --]
const connector = walletConnect({ // [!code ++]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

## Chains

### Updated `'wagmi/chains'` entrypoint

Chains now live in the [Viem repository](https://github.com/wevm/viem). As a result, the `'wagmi/chains'` entrypoint now proxies all chains from `'viem/chains'` directly.

### Removed `mainnet` and `sepolia` from main entrypoint

Since the `'wagmi/chains'` entrypoint now proxies `'viem/chains'`, `mainnet` and `sepolia` were removed from the main entrypoint. Use the `'wagmi/chains'` entrypoint instead.

```ts
import { mainnet, sepolia } from 'wagmi' // [!code --]
import { mainnet, sepolia } from 'wagmi/chains' // [!code ++]
```

## Errors

A number of errors were renamed to better reflect their functionality or replaced by Viem errors.

## Miscellaneous

### Removed internal ENS name normalization

Before v2, Wagmi handled ENS name normalization internally for `useEnsAddress`, `useEnsAvatar`, and `useEnsResolver`, using Viem's [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function. This added extra bundle size as full normalization is quite heavy. For v2, you must normalize ENS names yourself before passing them to these hooks. You can use Viem's `normalize` function or any other function that performs [UTS-46 normalization](https://unicode.org/reports/tr46).

```ts
import { useEnsAddress } from 'wagmi'
import { normalize } from 'viem/ens' // [!code ++]

const result = useEnsAddress({
  name: 'wevm.eth', // [!code --]
  name: normalize('wevm.eth'), // [!code ++]
})
```

By inverting control, Wagmi let's you choose how much normalization to do. For example, maybe your project only allows ENS names that are numeric so no normalization is not needed. Check out the [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) for more information on normalizing names.

### Removed `configureChains`

The Wagmi v2 `Config` now has native multichain support using the [`chains`](/react/api/createConfig) parameter so the `configureChains` function is no longer required.

```ts
import { configureChains, createConfig } from 'wagmi' // [!code --]
import { http, createConfig } from 'wagmi' // [!code ++]
import { mainnet, sepolia } from 'wagmi/chains'

const { chains, publicClient } = configureChains( // [!code --]
  [mainnet, sepolia], // [!code --]
  [publicProvider(), publicProvider()], // [!code --]
) // [!code --]

export const config = createConfig({
  publicClient, // [!code --]
  chains: [mainnet, sepolia], // [!code ++]
  transports: { // [!code ++]
    [mainnet.id]: http(), // [!code ++]
    [sepolia.id]: http(), // [!code ++]
  }, // [!code ++]
})
```

### Removed ABI exports

Import from Viem instead.

```ts
import { erc20ABI } from 'wagmi' // [!code --]
import { erc20Abi } from 'viem' // [!code ++]
```

### Removed `'wagmi/providers/*` entrypoints

It never made sense that we would have provider URLs hardcoded in the Wagmi codebase. Use [Viem transports](https://viem.sh/docs/clients/intro.html#transports) along with RPC provider URLs instead.

```ts
import { alchemyProvider } from 'wagmi/providers/alchemy' // [!code --]
import { http } from 'viem' // [!code ++]

const transport = http('https://mainnet.example.com')
```

### Updated `createConfig` parameters

- Removed `autoConnect`. The reconnecting behavior is now managed by React and not related to the Wagmi `Config`. Use `WagmiProvider` [`reconnectOnMount`](/react/api/WagmiProvider#reconnectonmount) or [`useReconnect`](/react/api/hooks/useReconnect) hook instead.
- Removed `publicClient` and `webSocketPublicClient`. Use [`transports`](/react/api/createConfig#transports) or [`client`](/react/api/createConfig#client) instead.
- Removed `logger`. Wagmi no longer logs debug information to console.

### Updated `Config` object

- Removed `config.connector`. Use `config.state.connections.get(config.state.current)?.connector` instead.
- Removed `config.data`. Use `config.state.connections.get(config.state.current)` instead.
- Removed `config.error`. Was unused and not needed.
- Removed `config.lastUsedChainId`. Use `config.state.connections.get(config.state.current)?.chainId` instead.
- Removed `config.publicClient`. Use [`config.getClient()`](/react/api/createConfig#getclient) or [`getPublicClient`](/core/api/actions/getPublicClient) instead.
- Removed `config.status`. Use [`config.state.status`](/react/api/createConfig#status) instead.
- Removed `config.webSocketClient`. Use [`config.getClient()`](/react/api/createConfig#getclient) or [`getPublicClient`](/core/api/actions/getPublicClient) instead.
- Removed `config.clearState`. Was unused and not needed.
- Removed `config.autoConnect()`. Use [`reconnect`](/core/api/actions/reconnect) action instead.
- Renamed `config.setConnectors`. Use `config._internal.setConnectors` instead.
- Removed `config.setLastUsedConnector`. Use `config.storage?.setItem('recentConnectorId', connectorId)` instead.
- Removed `getConfig`. `config` should be passed explicitly to actions instead of using global `config`.

## Deprecations

### Renamed `WagmiConfig`

`WagmiConfig` was renamed to [`WagmiProvider`](/react/api/WagmiProvider) to reduce confusion with the Wagmi [`Config`](/react/api/createConfig) type. React Context Providers usually follow the naming schema `*Provider` so this is a more idiomatic name. Now that Wagmi no longer uses Ethers.js (since Wagmi v1), the term "Provider" is less overloaded.

::: code-group
```tsx [app.tsx]
import { WagmiConfig } from 'wagmi' // [!code --]
import { WagmiProvider } from 'wagmi' // [!code ++]
import { config } from './config'

function App() {
  return (
    <WagmiConfig config={config}> // [!code --]
    <WagmiProvider config={config}> // [!code ++]
      {/** ... */}
    </WagmiProvider> // [!code ++]
    </WagmiConfig> // [!code --]
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

### Deprecated `useBalance` `token` parameter

Moving forward, `useBalance` will only work for native currencies, thus the `token` parameter is no longer supported. Use [`useReadContracts`](/react/api/hooks/useReadContracts) instead.

```ts
import { useBalance } from 'wagmi' // [!code --]
import { useReadContracts } from 'wagmi' // [!code ++]
import { erc20Abi } from 'viem' // [!code ++]

const result = useBalance({ // [!code --]
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48', // [!code --]
  token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code --]
}) // [!code --]
const result = useReadContracts({ // [!code ++]
  allowFailure: false, // [!code ++]
  contracts: [ // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'balanceOf', // [!code ++]
      args: ['0x4557B18E779944BFE9d78A672452331C186a9f48'], // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'decimals', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'symbol', // [!code ++]
    }, // [!code ++]
  ] // [!code ++]
}) // [!code ++]
```

### Deprecated `useBalance` `unit` parameter and `formatted` return value

Moving forward, `useBalance` will not accept the `unit` parameter or return a `formatted` value. Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

```ts
import { formatUnits } from 'viem' // [!code ++]
import { useBalance } from 'wagmi'

const result = useBalance({
  address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
  unit: 'ether', // [!code --]
})
result.data!.formatted // [!code --]
formatUnits(result.data!.value, result.data!.decimals) // [!code ++]
```

### Deprecated `useToken`

Moving forward, `useToken` is no longer supported. Use [`useReadContracts`](/react/api/hooks/useReadContracts) instead.

```ts
import { useToken } from 'wagmi' // [!code --]
import { useReadContracts } from 'wagmi' // [!code ++]
import { erc20Abi } from 'viem' // [!code ++]

const result = useToken({ // [!code --]
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code --]
}) // [!code --]
const result = useReadContracts({ // [!code ++]
  allowFailure: false, // [!code ++]
  contracts: [ // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'decimals', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'name', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'symbol', // [!code ++]
    }, // [!code ++]
    { // [!code ++]
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // [!code ++]
      abi: erc20Abi, // [!code ++]
      functionName: 'totalSupply', // [!code ++]
    }, // [!code ++]
  ] // [!code ++]
}) // [!code ++]
```

### Deprecated `formatUnits` parameters and return values

The `formatUnits` parameter and related return values (e.g. `result.formatted`) are deprecated for the following hooks:

- [`useEstimateFeesPerGas`](/react/api/hooks/useEstimateFeesPerGas)
- [`useToken`](/react/api/hooks/useToken)

Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

```ts
import { formatUnits } from 'viem' // [!code ++]

const result = useToken({
  address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  formatUnits: 'ether',
})
result.data!.totalSupply.formatted  // [!code --]
formatUnits(result.data!.totalSupply.value, 18)  // [!code ++]
```

This allows us to invert control to users so they can handle number formatting however they want, taking into account precision, localization, and more.

### Renamed hooks

The following hooks were renamed to better reflect their functionality and underlying [Viem](https://viem.sh) actions:

- `useContractRead` is now [`useReadContract`](/react/api/hooks/useReadContract)
- `useContractReads` is now [`useReadContracts`](/react/api/hooks/useReadContracts)
- `useContractWrite` is now [`useWriteContract`](/react/api/hooks/useWriteContract)
- `useContractEvent` is now [`useWatchContractEvent`](/react/api/hooks/useWatchContractEvent)
- `useContractInfiniteReads` is now [`useInfiniteReadContracts`](/react/api/hooks/useInfiniteReadContracts)
- `useFeeData` is now [`useEstimateFeesPerGas`](/react/api/hooks/useEstimateFeesPerGas)
- `useSwitchNetwork` is now [`useSwitchChain`](/react/api/hooks/useSwitchChain)
- `useWaitForTransaction` is now [`useWaitForTransactionReceipt`](/react/api/hooks/useWaitForTransactionReceipt)

### Miscellaneous

- `WagmiConfigProps` renamed to [`WagmiProviderProps`](/react/api/WagmiProvider#parameters).
- `Context` renamed to [`WagmiContext`](/react/api/WagmiProvider#context).
</file>

<file path="react/guides/read-from-contract.md">
# Read from Contract

The [`useReadContract` Hook](/react/api/hooks/useReadContract) allows you to read data on a smart contract, from a `view` or `pure` (read-only) function. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

The component below shows how to retrieve the token balance of an address from the [Wagmi Example](https://etherscan.io/token/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2) contract

:::code-group
```tsx [read-contract.tsx]
import { useReadContract } from 'wagmi'
import { wagmiContractConfig } from './contracts'

function ReadContract() {
  const { data: balance } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
```ts [contracts.ts]
export const wagmiContractConfig = {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: [
    {
      type: 'function',
      name: 'balanceOf',
      stateMutability: 'view',
      inputs: [{ name: 'account', type: 'address' }],
      outputs: [{ type: 'uint256' }],
    },
    {
      type: 'function',
      name: 'totalSupply',
      stateMutability: 'view',
      inputs: [],
      outputs: [{ name: 'supply', type: 'uint256' }],
    },
  ],
} as const
```
:::

If `useReadContract` depends on another value (`address` in the example below), you can use the [`query.enabled`](/react/api/hooks/useReadContract#enabled) option to prevent the query from running until the dependency is ready.

```tsx
const { data: balance } = useReadContract({
  ...wagmiContractConfig,
  functionName: 'balanceOf',
  args: [address],
  query: { // [!code focus]
    enabled: !!address, // [!code focus]
  }, // [!code focus]
})
```

## Loading & Error States

The [`useReadContract` Hook](/react/api/hooks/useReadContract) also returns loading & error states, which can be used to display a loading indicator while the data is being fetched, or an error message if contract execution reverts.

:::code-group

```tsx [read-contract.tsx]
import { type BaseError, useReadContract } from 'wagmi'

function ReadContract() {
  const { 
    data: balance,
    error, // [!code ++]
    isPending // [!code ++]
  } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })

  if (isPending) return <div>Loading...</div> // [!code ++]

  if (error) // [!code ++]
    return ( // [!code ++]
      <div> // [!code ++]
        Error: {(error as BaseError).shortMessage || error.message} // [!code ++]
      </div> // [!code ++]
    )  // [!code ++]

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```

## Refetching On Blocks

The [`useBlockNumber` Hook](/react/api/hooks/useBlockNumber) can be utilized to refetch or [invalidate](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation) the contract data on a specific block interval.

:::code-group
```tsx [read-contract.tsx (refetch)]
import { useEffect } from 'react'
import { useBlockNumber, useReadContract } from 'wagmi'

function ReadContract() {
  const { data: balance, refetch } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })
  const { data: blockNumber } = useBlockNumber({ watch: true })

  useEffect(() => {
    // want to refetch every `n` block instead? use the modulo operator!
    // if (blockNumber % 5 === 0) refetch() // refetch every 5 blocks
    refetch()
  }, [blockNumber])

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
```tsx [read-contract.tsx (invalidate)]
import { useQueryClient } from '@tanstack/react-query'
import { useEffect } from 'react'
import { useBlockNumber, useReadContract } from 'wagmi'

function ReadContract() {
  const queryClient = useQueryClient()
  const { data: balance, refetch } = useReadContract({
    ...wagmiContractConfig,
    functionName: 'balanceOf',
    args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
  })
  const { data: blockNumber } = useBlockNumber({ watch: true })

  useEffect(() => {
    // if `useReadContract` is in a different hook/component,
    // you can import `readContractQueryKey` from `'wagmi/query'` and
    // construct a one-off query key to use for invalidation
    queryClient.invalidateQueries({ queryKey })
  }, [blockNumber, queryClient])

  return (
    <div>Balance: {balance?.toString()}</div>
  )
}
```
:::

## Calling Multiple Functions

We can use the [`useReadContract` Hook](/react/api/hooks/useReadContract) multiple times in a single component to call multiple functions on the same contract, but this ends up being hard to manage as the number of functions increases, especially when we also want to deal with loading & error states. 

Luckily, to make this easier, we can use the [`useReadContracts` Hook](/react/api/hooks/useReadContracts) to call multiple functions in a single call.

:::code-group

```tsx [read-contract.tsx]
import { type BaseError, useReadContracts } from 'wagmi'

function ReadContract() {
  const { 
    data,
    error,
    isPending
  } = useReadContracts({ 
    contracts: [{ 
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
    }, { 
      ...wagmiContractConfig, 
      functionName: 'ownerOf', 
      args: [69n], 
    }, { 
      ...wagmiContractConfig, 
      functionName: 'totalSupply', 
    }] 
  }) 
  const [balance, ownerOf, totalSupply] = data || [] 

  if (isPending) return <div>Loading...</div>

  if (error)
    return (
      <div>
        Error: {(error as BaseError).shortMessage || error.message}
      </div>
    ) 

  return (
    <>
      <div>Balance: {balance?.toString()}</div>
      <div>Owner of Token 69: {ownerOf?.toString()}</div> 
      <div>Total Supply: {totalSupply?.toString()}</div> 
    </>
  )
}
```

:::
</file>

<file path="react/guides/send-transaction.md">
# Send Transaction

The following guide teaches you how to send transactions in Wagmi. The example below builds on the [Connect Wallet guide](/react/guides/connect-wallet) and uses the [useSendTransaction](/react/api/hooks/useSendTransaction) & [useWaitForTransaction](/react/api/hooks/useWaitForTransactionReceipt) hooks. 

## Example

Feel free to check out the example before moving on:

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-zkzqj7?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>

## Steps

### 1. Connect Wallet

Follow the [Connect Wallet guide](/react/guides/connect-wallet) guide to get this set up.

### 2. Create a new component

Create your `SendTransaction` component that will contain the send transaction logic.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
 
export function SendTransaction() {
  return (
    <form>
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button type="submit">Send</button>
    </form>
  )
}
```

:::

### 3. Add a form handler

Next, we will need to add a handler to the form that will send the transaction when the user hits "Send". This will be a basic handler in this step.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
 
export function SendTransaction() {
  async function submit(e: React.FormEvent<HTMLFormElement>) { // [!code ++]
    e.preventDefault() // [!code ++]
    const formData = new FormData(e.target as HTMLFormElement) // [!code ++]
    const to = formData.get('address') as `0x${string}` // [!code ++]
    const value = formData.get('value') as string // [!code ++]
  } // [!code ++]

  return (
    <form> // [!code --]
    <form onSubmit={submit}> // [!code ++]
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button type="submit">Send</button>
    </form>
  )
}
```

:::

### 4. Hook up the `useSendTransaction` Hook

Now that we have the form handler, we can hook up the [`useSendTransaction` Hook](/react/api/hooks/useSendTransaction) to send the transaction.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { useSendTransaction } from 'wagmi' // [!code ++]
import { parseEther } from 'viem' // [!code ++]
 
export function SendTransaction() {
  const { data: hash, sendTransaction } = useSendTransaction() // [!code ++]

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) // [!code ++]
  } 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button type="submit">Send</button>
      {hash && <div>Transaction Hash: {hash}</div>} // [!code ++]
    </form>
  )
}
```

:::

### 5. Add loading state (optional)

We can optionally add a loading state to the "Send" button while we are waiting confirmation from the user's wallet.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { useSendTransaction } from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash, 
    isPending, // [!code ++]
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} // [!code ++]
        type="submit"
      >
        Send // [!code --]
        {isPending ? 'Confirming...' : 'Send'} // [!code ++]
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
    </form>
  )
}
```

:::

### 6. Wait for transaction receipt (optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Hook](/react/api/hooks/useWaitForTransactionReceipt). 

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { 
  useSendTransaction, 
  useWaitForTransactionReceipt // [!code ++]
} from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash, 
    isPending, 
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = // [!code ++]
    useWaitForTransactionReceipt({ // [!code ++]
      hash, // [!code ++]
    }) // [!code ++]

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Send'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
      {isConfirming && <div>Waiting for confirmation...</div>} // [!code ++]
      {isConfirmed && <div>Transaction confirmed.</div>} // [!code ++]
    </form>
  )
}
```

:::

### 7. Handle errors (optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

::: code-group

```tsx [send-transaction.tsx]
import * as React from 'react'
import { 
  type BaseError, // [!code ++]
  useSendTransaction, 
  useWaitForTransactionReceipt 
} from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash,
    error, // [!code ++] 
    isPending, 
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Send'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( // [!code ++]
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> // [!code ++]
      )} // [!code ++]
    </form>
  )
}
```

:::

### 8. Wire it up!

Finally, we can wire up our Send Transaction component to our application's entrypoint.

::: code-group

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from './config'
import { SendTransaction } from './send-transaction' // [!code ++]

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        <SendTransaction /> // [!code ++]
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [send-transaction.tsx]
import * as React from 'react'
import { 
  type BaseError, 
  useSendTransaction, 
  useWaitForTransactionReceipt 
} from 'wagmi' 
import { parseEther } from 'viem' 
 
export function SendTransaction() {
  const { 
    data: hash,
    error, 
    isPending, 
    sendTransaction 
  } = useSendTransaction() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const to = formData.get('address') as `0x${string}` 
    const value = formData.get('value') as string 
    sendTransaction({ to, value: parseEther(value) }) 
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="address" placeholder="0xA0Cf251e" required />
      <input name="value" placeholder="0.05" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Send'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>} 
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( 
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> 
      )} 
    </form>
  )
}
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

[See the Example.](#example)
</file>

<file path="react/guides/ssr.md">
---
outline: deep
---

# SSR

Wagmi uses client-only external stores (such as `localStorage` and `mipd`) to show the user the most relevant data as quickly as possible on first render.

However, the caveat of using these external client stores is that frameworks which incorporate SSR (such as Next.js) will throw hydration warnings on the client when it identifies mismatches between the server-rendered HTML and the client-rendered HTML.

To stop this from happening, you can toggle on the [`ssr`](/react/api/createConfig#ssr) property in the Wagmi Config.

```tsx
import { createConfig, http } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

const config = createConfig({ // [!code focus:99]
  chains: [mainnet, sepolia],
  ssr: true, // [!code ++]
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

Turning on the `ssr` property means that content from the external stores will be hydrated on the client after the initial mount.

## Persistence using Cookies

As a result of turning on the `ssr` property, external persistent stores like `localStorage` will be hydrated on the client **after the initial mount**.

This means that you will still see a flash of "empty" data on the client (e.g. a `"disconnected"` account instead of a `"reconnecting"` account, or an empty address instead of the last connected address) until after the first mount, when the store hydrates.

In order to persist data between the server and the client, you can use cookies.

### 1. Set up cookie storage

First, we will set up cookie storage in the Wagmi Config.

```tsx
import { 
  createConfig, 
  http, 
  cookieStorage, // [!code ++]
  createStorage // [!code ++]
} from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

export function getConfig() {
  return createConfig({
    chains: [mainnet, sepolia],
    ssr: true,
    storage: createStorage({  // [!code ++]
      storage: cookieStorage, // [!code ++]
    }),  // [!code ++]
    transports: {
      [mainnet.id]: http(),
      [sepolia.id]: http(),
    },
  })
}
```

### 2. Hydrate the cookie

Next, we will need to add some mechanisms to hydrate the stored cookie in Wagmi.

#### Next.js App Directory

In our `app/layout.tsx` file (a [Server Component](https://nextjs.org/docs/app/building-your-application/rendering/server-components)), we will need to extract the cookie from the `headers` function and pass it to [`cookieToInitialState`](/react/api/utilities/cookieToInitialState). 

We will need to pass this result to the [`initialState` property](/react/api/WagmiProvider#initialstate) of the `WagmiProvider`. The `WagmiProvider` **must** be in a Client Component tagged with `"use client"` (see `app/providers.tsx` tab).

::: code-group
```tsx [app/layout.tsx]
import { type ReactNode } from 'react'
import { headers } from 'next/headers' // [!code ++]
import { cookieToInitialState } from 'wagmi' // [!code ++]

import { getConfig } from './config'
import { Providers } from './providers'

export default async function Layout({ children }: { children: ReactNode }) {
  const initialState = cookieToInitialState( // [!code ++]
    getConfig(), // [!code ++]
    (await headers()).get('cookie') // [!code ++]
  ) // [!code ++]
  return (
    <html lang="en">
      <body>
        <Providers> // [!code --]
        <Providers initialState={initialState}> // [!code ++]
          {children}
        </Providers>
      </body>
    </html>
  )
}

```

```tsx [app/providers.tsx]
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { type ReactNode, useState } from 'react'
import { type State, WagmiProvider } from 'wagmi'

import { getConfig } from './config'

type Props = {
  children: ReactNode,
  initialState: State | undefined, // [!code ++]
}

export function Providers({ children }: Props) {  // [!code --]
export function Providers({ children, initialState }: Props) {  // [!code ++]
  const [config] = useState(() => getConfig())
  const [queryClient] = useState(() => new QueryClient())

  return (
    <WagmiProvider config={config}> // [!code --]
    <WagmiProvider config={config} initialState={initialState}> // [!code ++]
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </WagmiProvider>
  )
}

```

```tsx [app/config.ts]
import { 
  createConfig, 
  http, 
  cookieStorage,
  createStorage 
} from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

export function getConfig() {
  return createConfig({
    chains: [mainnet, sepolia],
    ssr: true,
    storage: createStorage({  // [!code ++]
      storage: cookieStorage, // [!code ++]
    }),  // [!code ++]
    transports: {
      [mainnet.id]: http(),
      [sepolia.id]: http(),
    },
  })
}
```
:::

#### Next.js Pages Directory

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!
<!-- TODO -->

#### Vanilla SSR

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!
<!-- TODO -->
</file>

<file path="react/guides/tanstack-query.md">
# TanStack Query

Wagmi Hooks are not only a wrapper around the core [Wagmi Actions](/core/api/actions), but they also utilize [TanStack Query](https://tanstack.com/query/v5) to enable trivial and intuitive fetching, caching, synchronizing, and updating of asynchronous data in your React applications.

Without an asynchronous data fetching abstraction, you would need to handle all the negative side-effects that comes as a result, such as: representing finite states (loading, error, success), handling race conditions, caching against a deterministic identifier, etc.

## Queries & Mutations

Wagmi Hooks represent either a **Query** or a **Mutation**. 

**Queries** are used for fetching data (e.g. fetching a block number, reading from a contract, etc), and are typically invoked on mount by default. All queries are coupled to a unique [Query Key](#query-keys), and can be used for further operations such as refetching, prefetching, or modifying the cached data.

**Mutations** are used for mutating data (e.g. connecting/disconnecting accounts, writing to a contract, switching chains, etc), and are typically invoked in response to a user interaction. Unlike **Queries**, they are not coupled with a query key.

## Terms

- **Query**: An asynchronous data fetching (e.g. read data) operation that is tied against a unique Query Key.
- **Mutation**: An asynchronous mutating (e.g. create/update/delete data or side-effect) operation.
- **Query Key**: A unique identifier that is used to deterministically identify a query. It is typically a tuple of the query name and the query arguments.
- **Stale Data**: Data that is unused or inactive after a certain period of time.
- **Query Fetching**: The process of invoking an async query function.
- **Query Refetching**: The process of refetching **rendered** queries.
- **[Query Invalidation](https://tanstack.com/query/v5/docs/react/guides/query-invalidation)**: The process of marking query data as stale (e.g. inactive/unused), and refetching **rendered** queries.
- **[Query Prefetching](https://tanstack.com/query/v5/docs/react/guides/prefetching)**: The process of prefetching queries and seeding the cache.

## Persistence via External Stores

By default, TanStack Query persists all query data in-memory. This means that if you refresh the page, all in-memory query data will be lost. 

If you want to persist query data to an external storage, you can utilize TanStack Query's [`createSyncStoragePersister`](https://tanstack.com/query/v5/docs/react/plugins/createSyncStoragePersister) or [`createAsyncStoragePersister`](https://tanstack.com/query/v5/docs/react/plugins/createAsyncStoragePersister) to plug external storage like `localStorage`, `sessionStorage`, [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or [`AsyncStorage`](https://reactnative.dev/docs/asyncstorage) (React Native).

### Sync Storage

Below is an example of how to set up Wagmi + TanStack Query with sync external storage like `localStorage` or `sessionStorage`.

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

```bash [npm]
npm i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

```bash [yarn]
yarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

```bash [bun]
bun i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```
:::

#### Usage

```tsx
// 1. Import modules. // [!code hl]
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister' // [!code hl]
import { QueryClient } from '@tanstack/react-query' // [!code hl]
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client' // [!code hl]
import { WagmiProvider, deserialize, serialize } from 'wagmi' // [!code hl]

// 2. Create a new Query Client with a default `gcTime`. // [!code hl]
const queryClient = new QueryClient({ // [!code hl]
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      gcTime: 1_000 * 60 * 60 * 24, // 24 hours // [!code hl]
    }, // [!code hl] 
  }, // [!code hl]
}) // [!code hl]

// 3. Set up the persister. // [!code hl]
const persister = createSyncStoragePersister({ // [!code hl]
  serialize, // [!code hl]
  storage: window.localStorage, // [!code hl]
  deserialize, // [!code hl]
}) // [!code hl]

function App() {
  return (
    <WagmiProvider config={config}>
      {/* 4. Wrap app in PersistQueryClientProvider */} // [!code hl]
      <PersistQueryClientProvider // [!code hl]
        client={queryClient} // [!code hl]
        persistOptions={{ persister }} // [!code hl]
      > // [!code hl]
        {/* ... */}
      </PersistQueryClientProvider> // [!code hl]
    </WagmiProvider>
  )
}
```

Read more about [Sync Storage Persistence](https://tanstack.com/query/v5/docs/react/plugins/createSyncStoragePersister).

### Async Storage

Below is an example of how to set up Wagmi + TanStack Query with async external storage like [`IndexedDB`](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or [`AsyncStorage`](https://reactnative.dev/docs/asyncstorage).

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

```bash [npm]
npm i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

```bash [yarn]
yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

```bash [bun]
bun i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```
:::

#### Usage

```tsx
// 1. Import modules. // [!code hl]
import AsyncStorage from '@react-native-async-storage/async-storage' // [!code hl]
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister' // [!code hl]
import { QueryClient } from '@tanstack/react-query' // [!code hl]
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client' // [!code hl]
import { WagmiProvider, deserialize, serialize } from 'wagmi' // [!code hl]

// 2. Create a new Query Client with a default `gcTime`. // [!code hl]
const queryClient = new QueryClient({ // [!code hl]
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      gcTime: 1_000 * 60 * 60 * 24, // 24 hours // [!code hl]
    }, // [!code hl] 
  }, // [!code hl]
}) // [!code hl]

// 3. Set up the persister. // [!code hl]
const persister = createAsyncStoragePersister({ // [!code hl]
  serialize, // [!code hl]
  storage: AsyncStorage, // [!code hl]
  deserialize, // [!code hl]
}) // [!code hl]

function App() {
  return (
    <WagmiProvider config={config}>
      {/* 4. Wrap app in PersistQueryClientProvider */} // [!code hl]
      <PersistQueryClientProvider // [!code hl]
        client={queryClient} // [!code hl]
        persistOptions={{ persister }} // [!code hl]
      > // [!code hl]
        {/* ... */}
      </PersistQueryClientProvider> // [!code hl]
    </WagmiProvider>
  )
}
```

Read more about [Async Storage Persistence](https://tanstack.com/query/v5/docs/react/plugins/createAsyncStoragePersister).

## Query Keys

Query Keys are typically used to perform advanced operations on the query such as: invalidation, refetching, prefetching, etc. 

Wagmi exports Query Keys for every Hook, and they can be retrieved via the [Hook (React)](#hook-react) or via an [Import (Vanilla JS)](#import-vanilla-js).

Read more about **Query Keys** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/query-keys)

### Hook (React)

Each Hook returns a `queryKey` value. You would use this approach when you want to utilize the query key in a React component as it handles reactivity for you, unlike the [Import](#import-vanilla-js) method below.

```ts 
import { useBlock } from 'wagmi' // [!code hl]

function App() {
  const { queryKey } = useBlock() // [!code hl]
}
```

### Import (Vanilla JS)

Each Hook has a corresponding `get<X>QueryOptions` function that returns a query key. You would use this method when you want to utilize the query key outside of a React component in a Vanilla JS context, like in a utility function. 

```ts 
import { getBlockQueryOptions } from 'wagmi/query' // [!code hl]
import { config } from './config'

function perform() {
  const { queryKey } = getBlockQueryOptions(config, { // [!code hl]
    chainId: config.state.chainId // [!code hl]
  }) // [!code hl]
}
```

::: warning

The caveat of this method is that it does not handle reactivity for you (e.g. active account/chain changes, argument changes, etc). You would need to handle this yourself by explicitly passing through the arguments to `get<X>QueryOptions`.

:::

## Invalidating Queries

Invalidating a query is the process of marking the query data as stale (e.g. inactive/unused), and refetching the queries that are already rendered.

Read more about **Invalidating Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/query-invalidation)

#### Example: Watching a Users' Balance

You may want to "watch" a users' balance, and invalidate the balance after each incoming block. We can invoke `invalidateQueries` inside a `useEffect` with the block number as it's only dependency  this will refetch all rendered balance queries when the `blockNumber` changes.

```tsx
import { useQueryClient } from '@tanstack/react-query' 
import { useEffect } from 'react' 
import { useBlockNumber, useBalance } from 'wagmi' 

function App() {
  const queryClient = useQueryClient()
  const { data: blockNumber } = useBlockNumber({ watch: true }) // [!code hl]
  const { data: balance, queryKey } = useBalance() // [!code hl]
  
  useEffect(() => { // [!code hl]
    queryClient.invalidateQueries({ queryKey }) // [!code hl]
  }, [blockNumber]) // [!code hl]

  return <div>{balance}</div>
}
```

#### Example: After User Interaction

Maybe you want to invalidate a users' balance after some interaction. This would mark the balance as stale, and consequently refetch all rendered balance queries.

```tsx
import { useBalance } from 'wagmi'

function App() {
  // 1. Extract `queryKey` from the useBalance Hook. // [!code hl]
  const { queryKey } = useBalance() // [!code hl]

  return (
    <button
      onClick={async () => {
        // 2. Invalidate the query when the user clicks "Invalidate". // [!code hl]
        await queryClient.invalidateQueries({ queryKey }) // [!code hl]
      }}
    >
      Invalidate
    </button>
  )
}

function Example() {
  // 3. Other `useBalance` Hooks in your rendered React tree will be refetched! // [!code hl]
  const { data: balance } = useBalance() // [!code hl]

  return <div>{balance}</div>
}
```

## Fetching Queries

Fetching a query is the process of invoking the query function to retrieve data. If the query exists and the data is not invalidated or older than a given `staleTime`, then the data from the cache will be returned. Otherwise, the query will fetch for the latest data.

::: code-group
```tsx [example.tsx]
import { getBlockQueryOptions } from 'wagmi'
import { queryClient } from './app'
import { config } from './config'

export async function fetchBlockData() {
  return queryClient.fetchQuery( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
    } // [!code hl]
  )) // [!code hl]
}
```
<<< @/snippets/react/app.tsx[app.tsx]
<<< @/snippets/react/config.ts[config.ts]
:::

## Retrieving & Updating Query Data

You can retrieve and update query data imperatively with `getQueryData` and `setQueryData`. This is useful for scenarios where you want to retrieve or update a query outside of a React component.

Note that these functions do not invalidate or refetch queries.

::: code-group
```tsx [example.tsx]
import { getBlockQueryOptions } from 'wagmi'
import type { Block } from 'viem'
import { queryClient } from './app'
import { config } from './config'

export function getPendingBlockData() {
  return queryClient.getQueryData( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
      tag: 'pending' // [!code hl]
    } // [!code hl]
  )) // [!code hl]
}

export function setPendingBlockData(data: Block) {
  return queryClient.setQueryData( // [!code hl]
    getBlockQueryOptions(config, { // [!code hl]
      chainId: config.state.chainId, // [!code hl]
      tag: 'pending' // [!code hl]
    }, // [!code hl]
    data // [!code hl]
  )) // [!code hl]
}
```
<<< @/snippets/react/app.tsx[app.tsx]
<<< @/snippets/react/config.ts[config.ts]
:::

## Prefetching Queries

Prefetching a query is the process of fetching the data ahead of time and seeding the cache with the returned data. This is useful for scenarios where you want to fetch data before the user navigates to a page, or fetching data on the server to be reused on client hydration.

Read more about **Prefetching Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/prefetching)

#### Example: Prefetching in Event Handler

```tsx
import { Link } from 'next/link'
import { getBlockQueryOptions } from 'wagmi'

function App() {
  const config = useConfig()
  const chainId = useChainId()

  // 1. Set up a function to prefetch the block data. // [!code hl]
  const prefetch = () => // [!code hl]
    queryClient.prefetchQuery(getBlockQueryOptions(config, { chainId })) // [!code hl]
  

  return (
    <Link
      // 2. Add event handlers to prefetch the block data // [!code hl] 
      // when user hovers over or focuses on the button. // [!code hl]
      onMouseEnter={prefetch} // [!code hl]
      onFocus={prefetch} // [!code hl]
      to="/block-details"
    >
      Block details
    </Link>
  )
}
```

## SSR

It is possible to utilize TanStack Query's SSR strategies with Wagmi Hooks & Query Keys. Check out the [Server Rendering & Hydration](https://tanstack.com/query/v5/docs/react/guides/ssr) & [Advanced Server Rendering](https://tanstack.com/query/v5/docs/react/guides/advanced-ssr) guides.

## Devtools

TanStack Query includes dedicated [Devtools](https://tanstack.com/query/latest/docs/framework/react/devtools) that assist in visualizing and debugging your queries, their cache states, and much more. You will have to pass a custom `queryKeyFn` to your `QueryClient` for Devtools to correctly serialize BigInt values for display. Alternatively, You can use the `hashFn` from `@wagmi/core/query`, which already handles this serialization.

#### Install

::: code-group
```bash [pnpm]
pnpm i @tanstack/react-query-devtools
```

```bash [npm]
npm i @tanstack/react-query-devtools
```

```bash [yarn]
yarn add @tanstack/react-query-devtools
```

```bash [bun]
bun i @tanstack/react-query-devtools
```
:::

#### Usage

```tsx
import {
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools"; // [!code hl]
import { hashFn } from "@wagmi/core/query"; // [!code hl]

const queryClient = new QueryClient({
  defaultOptions: { // [!code hl]
    queries: { // [!code hl]
      queryKeyHashFn: hashFn, // [!code hl]
    }, // [!code hl]
  }, // [!code hl]
});
```
</file>

<file path="react/guides/testing.md">
# Testing
</file>

<file path="react/guides/viem.md">
# Viem

[Viem](https://viem.sh) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](/react/api/createConfig) and automatic account management via [Connectors](/react/api/connectors).

## Leveraging Viem Actions

All of the core [Wagmi Hooks](/react/api/actions) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](/react/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe a Hook doesn't exist in Wagmi yet). In these cases, you can create your own custom Wagmi Hook by importing Viem Actions directly via `viem/actions` and plugging in a Viem Client returned by the [`useClient` Hook](/react/api/hooks/useClient).

The example below demonstrates two different ways to utilize Viem Actions:

1. **Tree-shakable Actions (recommended):** Uses `useClient` (for public actions) and `useConnectorClient` (for wallet actions).
2. **Client Actions:** Uses `usePublicClient` (for public actions) and  `useWalletClient` (for wallet actions).

::: tip

It is highly recommended to use the **tree-shakable** method to ensure that you are only pulling modules you use, and keep your bundle size low.

:::

::: code-group

```tsx [Tree-shakable Actions]
// 1. Import modules. 
import { useMutation, useQuery } from '@tanstack/react-query'
import { http, createConfig, useClient, useConnectorClient } from 'wagmi' 
import { base, mainnet, optimism, zora } from 'wagmi/chains' 
import { getLogs, watchAsset } from 'viem/actions'

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

function Example() {
  // 3. Extract a Viem Client for the current active chain. // [!code hl]
  const publicClient = useClient({ config }) // [!code hl]

  // 4. Create a "custom" Query Hook that utilizes the Client. // [!code hl]
  const { data: logs } = useQuery({ // [!code hl]
    queryKey: ['logs', publicClient.uid], // [!code hl]
    queryFn: () => getLogs(publicClient, /* ... */) // [!code hl]
  }) // [!code hl]
  
  // 5. Extract a Viem Client for the current active chain & account. // [!code hl]
  const { data: walletClient } = useConnectorClient({ config }) // [!code hl]

  // 6. Create a "custom" Mutation Hook that utilizes the Client. // [!code hl]
  const { mutate } = useMutation({ // [!code hl]
    mutationFn: (asset) => watchAsset(walletClient, asset) // [!code hl]
  }) // [!code hl]

  return (
    <div>
      {/* ... */}
    </div>
  )
}
```

```tsx [Client Actions]
// 1. Import modules. 
import { useMutation, useQuery } from '@tanstack/react-query'
import { http, createConfig, useClient, useConnectorClient } from 'wagmi' 
import { base, mainnet, optimism, zora } from 'wagmi/chains' 

// 2. Set up a Wagmi Config 
export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

function Example() {
  // 3. Extract a Viem Client for the current active chain. // [!code hl]
  const publicClient = useClient({ config }) // [!code hl]

  // 4. Create a "custom" Query Hook that utilizes the Client. // [!code hl]
  const { data: logs } = useQuery({ // [!code hl]
    queryKey: ['logs', publicClient.uid], // [!code hl]
    queryFn: () => publicClient.getLogs(/* ... */) // [!code hl]
  }) // [!code hl]
  
  // 5. Extract a Viem Client for the current active chain & account. // [!code hl]
  const { data: walletClient } = useConnectorClient({ config }) // [!code hl]

  // 6. Create a "custom" Mutation Hook that utilizes the Client. // [!code hl]
  const { mutate } = useMutation({ // [!code hl]
    mutationFn: (asset) => walletClient.watchAsset(asset) // [!code hl]
  }) // [!code hl]

  return (
    <div>
      {/* ... */}
    </div>
  )
}
```

:::

## Private Key & Mnemonic Accounts

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

```tsx
import { http, createConfig, useSendTransaction } from 'wagmi' 
import { base, mainnet, optimism, zora } from 'wagmi/chains' 
import { parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const config = createConfig({ 
  chains: [base, mainnet, optimism, zora], 
  transports: { 
    [base.id]: http(), 
    [mainnet.id]: http(), 
    [optimism.id]: http(), 
    [zora.id]: http(), 
  }, 
}) 

const account = privateKeyToAccount('0x...') // [!code hl]

function Example() {
  const { data: hash } = useSendTransaction({
    account, // [!code hl]
    to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
    value: parseEther('0.001')
  })
}
```

::: info

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config  meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open an discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).

:::
</file>

<file path="react/guides/write-to-contract.md">
# Write to Contract

The [`useWriteContract` Hook](/react/api/hooks/useWriteContract) allows you to mutate data on a smart contract, from a `payable` or `nonpayable` (write) function. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

In the guide below, we will teach you how to implement a "Mint NFT" form that takes in a dynamic argument (token ID) using Wagmi. The example below builds on the [Connect Wallet guide](/react/guides/connect-wallet) and uses the [useWriteContract](/react/api/hooks/useWriteContract) & [useWaitForTransaction](/react/api/hooks/useWaitForTransactionReceipt) hooks. 

If you have already completed the [Sending Transactions guide](/react/guides/send-transaction), this guide will look very similar! That's because writing to a contract internally broadcasts & sends a transaction.

## Example

Feel free to check out the example before moving on:

<iframe frameborder="0" width="100%" height="500px" src="https://stackblitz.com/edit/vitejs-vite-f5uwlm?embed=1&file=src%2FApp.tsx&hideExplorer=1&view=preview"></iframe>

## Steps

### 1. Connect Wallet

Follow the [Connect Wallet guide](/react/guides/connect-wallet) guide to get this set up.

### 2. Create a new component

Create your `MintNFT` component that will contain the Mint NFT logic.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
 
export function MintNFT() {
  return (
    <form>
      <input name="tokenId" placeholder="69420" required />
      <button type="submit">Mint</button>
    </form>
  )
}
```

:::

### 3. Add a form handler

Next, we will need to add a handler to the form that will send the transaction when the user hits "Mint". This will be a basic handler in this step.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
 
export function MintNFT() {
  async function submit(e: React.FormEvent<HTMLFormElement>) { // [!code ++]
    e.preventDefault() // [!code ++]
    const formData = new FormData(e.target as HTMLFormElement) // [!code ++]
    const tokenId = formData.get('tokenId') as string // [!code ++]
  } // [!code ++]

  return (
    <form> // [!code --]
    <form onSubmit={submit}> // [!code ++]
      <input name="tokenId" placeholder="69420" required />
      <button type="submit">Mint</button>
    </form>
  )
}
```

:::

### 4. Hook up the `useWriteContract` Hook

Now that we have the form handler, we can hook up the [`useWriteContract` Hook](/react/api/hooks/useWriteContract) to send the transaction.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { useWriteContract } from 'wagmi' // [!code ++]
import { abi } from './abi' // [!code ++]
 
export function MintNFT() {
  const { data: hash, writeContract } = useWriteContract() // [!code ++]

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({ // [!code ++]
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code ++]
      abi, // [!code ++]
      functionName: 'mint', // [!code ++]
      args: [BigInt(tokenId)], // [!code ++]
    }) // [!code ++]
  } 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button type="submit">Mint</button>
      {hash && <div>Transaction Hash: {hash}</div>} // [!code ++]
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 5. Add loading state (optional)

We can optionally add a loading state to the "Mint" button while we are waiting confirmation from the user's wallet.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { useWriteContract } from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash, 
    isPending, // [!code ++]
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} // [!code ++]
        type="submit"
      >
        Mint // [!code --]
        {isPending ? 'Confirming...' : 'Mint'} // [!code ++]
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 6. Wait for transaction receipt (optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Hook](/react/api/hooks/useWaitForTransactionReceipt). 

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { 
  useWaitForTransactionReceipt, // [!code ++]
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash, 
    isPending, 
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = // [!code ++]
    useWaitForTransactionReceipt({ // [!code ++]
      hash, // [!code ++]
    }) // [!code ++]

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Mint'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && <div>Waiting for confirmation...</div>} // [!code ++]
      {isConfirmed && <div>Transaction confirmed.</div>} // [!code ++]
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 7. Handle errors (optional)

If the user rejects the transaction, or the contract reverts, we can display an error message to the user.

::: code-group

```tsx [mint-nft.tsx]
import * as React from 'react'
import { 
  type BaseError, // [!code ++]
  useWaitForTransactionReceipt, 
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash,
    error, // [!code ++]  
    isPending, 
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Mint'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( // [!code ++]
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> // [!code ++]
      )} // [!code ++]
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

:::

### 8. Wire it up!

Finally, we can wire up our Mint NFT component to our application's entrypoint.

::: code-group

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from './config'
import { MintNft } from './mint-nft' // [!code ++]

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> 
        <MintNft /> // [!code ++]
      </QueryClientProvider> 
    </WagmiProvider>
  )
}
```

```tsx [mint-nft.tsx]
import * as React from 'react'
import { 
  type BaseError, 
  useWaitForTransactionReceipt, 
  useWriteContract 
} from 'wagmi'
import { abi } from './abi'
 
export function MintNFT() {
  const { 
    data: hash,
    error,   
    isPending, 
    writeContract 
  } = useWriteContract() 

  async function submit(e: React.FormEvent<HTMLFormElement>) { 
    e.preventDefault() 
    const formData = new FormData(e.target as HTMLFormElement) 
    const tokenId = formData.get('tokenId') as string 
    writeContract({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
      args: [BigInt(tokenId)],
    })
  } 

  const { isLoading: isConfirming, isSuccess: isConfirmed } = 
    useWaitForTransactionReceipt({ 
      hash, 
    }) 

  return (
    <form onSubmit={submit}>
      <input name="tokenId" placeholder="69420" required />
      <button 
        disabled={isPending} 
        type="submit"
      >
        {isPending ? 'Confirming...' : 'Mint'} 
      </button>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && <div>Waiting for confirmation...</div>} 
      {isConfirmed && <div>Transaction confirmed.</div>} 
      {error && ( 
        <div>Error: {(error as BaseError).shortMessage || error.message}</div> 
      )} 
    </form>
  )
}
```

```ts [abi.ts]
export const abi = [
  {
    name: 'mint',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
    outputs: [],
  },
] as const
```

```tsx [config.ts]
import { http, createConfig } from 'wagmi'
import { base, mainnet, optimism } from 'wagmi/chains'
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [mainnet, base],
  connectors: [
    injected(),
    walletConnect({ projectId }),
    metaMask(),
    safe(),
  ],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
})
```

:::

[See the Example.](#example)
</file>

<file path="react/comparisons.md">
# Comparison

There are multiple options when it comes to React libraries for Ethereum that help manage wallet connections, provide utility methods/hooks, etc.

::: tip
Comparisons strive to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes.
:::

## Overview

|                      | [wagmi](https://github.com/wagmi-dev/wagmi)                                                     | [web3-react](https://github.com/NoahZinsmeister/web3-react)                                             | [useDApp](https://github.com/EthWorks/useDApp)                                                     |
| -------------------- | :---------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------- |
| GitHub Stars         | ![wagmi star count](https://img.shields.io/github/stars/wagmi-dev/wagmi?colorB=27292E&label=)   | ![web3-react star count](https://img.shields.io/github/stars/Uniswap/web3-react?colorB=27292E&label=)   | ![useDApp star count](https://img.shields.io/github/stars/EthWorks/useDApp?colorB=27292E&label=)   |
| Open Issues          | ![wagmi issue count](https://img.shields.io/github/issues/wagmi-dev/wagmi?colorB=27292E&label=) | ![web3-react issue count](https://img.shields.io/github/issues/Uniswap/web3-react?colorB=27292E&label=) | ![useDApp issue count](https://img.shields.io/github/issues/EthWorks/useDApp?colorB=27292E&label=) |
| Downloads            | ![wagmi downloads](https://img.shields.io/npm/dw/wagmi?colorB=27292E&label=)                    | ![web3-react downloads](https://img.shields.io/npm/dw/@web3-react/core?colorB=27292E&label=)            | ![useDApp downloads](https://img.shields.io/npm/dw/@usedapp/core?colorB=27292E&label=)             |
| License              | ![wagmi license](https://img.shields.io/github/license/wagmi-dev/wagmi?colorB=27292E&label=)    | ![web3-react license](https://img.shields.io/github/license/Uniswap/web3-react?colorB=27292E&label=)    | ![useDApp license](https://img.shields.io/github/license/EthWorks/useDApp?colorB=27292E&label=)    |
| Their Comparison     |                                                                                                | none                                                                                                    | none                                                                                               |
| Supported Frameworks | React, Vanilla JS                                                                               | React                                                                                                   | React                                                                                              |
| Documentation        |                                                                                               |                                                                                                       |                                                                                                  |
| TypeScript           |                                                                                               |                                                                                                       |                                                                                                  |
| EIP-6963 Support     |                                                                                               |                                                                                                       |                                                                                                  |
| Test Suite           |                                                                                               |                                                                                                       |                                                                                                  |
| Examples             |                                                                                               |                                                                                                       |                                                                                                  |

::: details Comparison Key

1. Documentation
  - Comprehensive documentation for all library features 
  - No documentation 
2. Typescript
  - Infer types from ABIs, EIP-712 Typed Data, etc. 
  - Can add types with explicit generics, type annotations, etc. 
3. Test Suite
  - Runs against forked Ethereum network(s) 
  - Mocking functionality (i.e. RPC calls) is 
4. EIP-6963 Support
  - Fully compatible with EIP-6963 
  - Not compatible with EIP-6963 
5. Examples
  - Has multiple examples 
  - Has single example 
:::

## [Wagmi](https://github.com/wagmi-dev/wagmi)

### Pros

- 20+ hooks for working with wallets, ENS, contracts, transactions, signing, etc.
- Built-in wallet connectors for injected providers (EIP-6963 support), WalletConnect, MetaMask, Coinbase Wallet
- Caching, request deduplication, and persistence powered by TanStack Query
- Auto-refresh data on wallet, block, and network changes
- Multicall support
- Test suite running against forked Ethereum networks
- TypeScript ready (infer types from ABIs and EIP-712 Typed Data)
- Extensive documentation and examples
- Used by Coinbase, Stripe, Shopify, Uniswap, Optimism, ENS, Sushi, and [many more](https://github.com/wagmi-dev/wagmi/discussions/201)
- MIT License

### Cons

- Not as many built-in connectors as `web3-react`

## [web3-react](https://github.com/Uniswap/web3-react)

### Pros

- Supports many different connectors (conceptually similar to Wagmi's connectors)
- Basic hooks for managing account

### Cons

- Need to set up connectors and method for connecting wallet on your own
- Need to install connectors separately
- Almost no tests or documentation; infrequent updates
- GPL-3.0 License

## [useDApp](https://github.com/EthWorks/useDApp)

### Pros

- Auto-refresh on new blocks and wallet changes
- Multicall support
- Transaction notifications
- Chrome extension and Firefox add-on
- MIT License

### Cons

- Non-standard hook API
</file>

<file path="react/getting-started.md">
<script setup>
import packageJson from '../../packages/react/package.json'

const viemVersion = packageJson.peerDependencies.viem
</script>

# Getting Started

## Overview

Wagmi is a React Hooks library for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](/react/why) section.

## Automatic Installation

For new projects, it is recommended to set up your Wagmi app using the [`create-wagmi`](/cli/create-wagmi) command line interface (CLI). This will create a new Wagmi project using TypeScript and install the required dependencies.

::: code-group
```bash [pnpm]
pnpm create wagmi
```

```bash [npm]
npm create wagmi@latest
```

```bash [yarn]
yarn create wagmi
```

```bash [bun]
bun create wagmi
```
:::

Once the command runs, you'll see some prompts to complete.

```ansi
Project name: wagmi-project
Select a framework: React / Vanilla
...
```

After the prompts, `create-wagmi` will create a directory with your project name and install the required dependencies. Check out the `README.md` for further instructions (if required).

## Manual Installation

To manually add Wagmi to your project, install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [npm]
npm install wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [yarn]
yarn add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [bun]
bun add wagmi viem@{{viemVersion}} @tanstack/react-query
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
- [TypeScript](/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/react/typescript).

### Create Config

Create and export a new Wagmi config using `createConfig`.

::: code-group
<<< @/snippets/react/config.ts[config.ts]
:::

In this example, Wagmi is configured to use the Mainnet and Sepolia chains, and `injected` connector. Check out the [`createConfig` docs](/react/api/createConfig) for more configuration options.


::: details TypeScript Tip
If you are using TypeScript, you can "register" the Wagmi config or use the hook `config` property to get strong type-safety across React Context in places that wouldn't normally have type info.

::: code-group
```ts twoslash [register config]
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare const config: Config<readonly [typeof mainnet, typeof sepolia]>
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123 })

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
```

```ts twoslash [hook config property]
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare const config: Config<readonly [typeof mainnet, typeof sepolia]>
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123, config })
```

By registering or using the hook `config` property, `useBlockNumber`'s `chainId` is strongly typed to only allow Mainnet and Sepolia IDs. Learn more by reading the [TypeScript docs](/react/typescript#config-types).
:::

### Wrap App in Context Provider

Wrap your app in the `WagmiProvider` React Context Provider and pass the `config` you created earlier to the `value` property.

::: code-group
```tsx [app.tsx]
import { WagmiProvider } from 'wagmi' // [!code focus]
import { config } from './config' // [!code focus]

function App() {
  return (
    <WagmiProvider config={config}> // [!code focus]
      {/** ... */} // [!code focus]
    </WagmiProvider> // [!code focus]
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

Check out the [`WagmiProvider` docs](/react/api/WagmiProvider) to learn more about React Context in Wagmi.

### Setup TanStack Query

Inside the `WagmiProvider`, wrap your app in a TanStack Query React Context Provider, e.g. `QueryClientProvider`, and pass a new `QueryClient` instance to the `client` property.

::: code-group
```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query' // [!code focus]
import { WagmiProvider } from 'wagmi'
import { config } from './config'

const queryClient = new QueryClient() // [!code focus]

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}> // [!code focus]
        {/** ... */} // [!code focus]
      </QueryClientProvider> // [!code focus]
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

Check out the [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/react) to learn about the library, APIs, and more.

### Use Wagmi

Now that everything is set up, every component inside the Wagmi and TanStack Query Providers can use Wagmi React Hooks.

::: code-group
```tsx [profile.tsx]
import { useAccount, useEnsName } from 'wagmi'

export function Profile() {
  const { address } = useAccount()
  const { data, error, status } = useEnsName({ address })
  if (status === 'pending') return <div>Loading ENS name</div>
  if (status === 'error')
    return <div>Error fetching ENS name: {error.message}</div>
  return <div>ENS name: {data}</div>
}
```

```tsx [app.tsx]
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './config'
import { Profile } from './profile'

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <Profile />
      </QueryClientProvider>
    </WagmiProvider>
  )
}
```
<<< @/snippets/react/config.ts[config.ts]
:::

## Next Steps

For more information on what to do next, check out the following topics.

- [**TypeScript**](/react/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
- [**Connect Wallet**](/react/guides/connect-wallet) Learn how to enable wallets to connect to and disconnect from your apps and display information about connected accounts.
- [**React Hooks**](/react/api/hooks) Browse the collection of React Hooks and learn how to use them.
- [**Viem**](/react/guides/viem) Learn about Viem and how it works with Wagmi.
</file>

<file path="react/installation.md">
<script setup>
import packageJson from '../../packages/react/package.json'
import Browsers from '../components/Browsers.vue'

const docsPath = 'react'
const packageDir = 'react'
const packageName = 'wagmi'
const viemVersion = packageJson.peerDependencies.viem
</script>

# Installation

Install Wagmi via your package manager, a `<script>` tag, or build from source.

## Package Manager

Install the required packages.

::: code-group
```bash-vue [pnpm]
pnpm add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [npm]
npm install wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [yarn]
yarn add wagmi viem@{{viemVersion}} @tanstack/react-query
```

```bash-vue [bun]
bun add wagmi viem@{{viemVersion}} @tanstack/react-query
```
:::

- [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.
- [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
- [TypeScript](/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](/react/typescript).

## CDN

If you're not using a package manager, you can also use Wagmi via an ESM-compatible CDN such as [esm.sh](https://esm.sh). Simply add a `<script type="module">` tag to the bottom of your HTML file with the following content.

```html-vue
<script type="module">
  import React from 'https://esm.sh/react@18.2.0'
  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
  import { createClient } from 'https://esm.sh/viem@{{viemVersion}}'
  import { createConfig } from 'https://esm.sh/wagmi'
</script>
```

Check out the React docs for info on how to use [React without JSX](https://react.dev/reference/react/createElement#creating-an-element-without-jsx).

<!--@include: @shared/installation.md-->
</file>

<file path="react/typescript.md">
<script setup>
import packageJson from '../../packages/react/package.json'

const typescriptVersion = packageJson.peerDependencies.typescript
</script>

# TypeScript

## Requirements

Wagmi is designed to be as type-safe as possible! Things to keep in mind:

- Types currently require using TypeScript {{typescriptVersion}}.
- [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
- Changes to types in this repository are considered non-breaking and are usually released as patch changes (otherwise every type enhancement would be a major version!).
- It is highly recommended that you lock your `wagmi` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
- The non-type-related public API of Wagmi still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

::: code-group
```json [tsconfig.json]
{
  "compilerOptions": {
    "strict": true
  }
}
```
:::

## Config Types

By default React Context does not work well with type inference. To support strong type-safety across the React Context boundary, there are two options available:

- Declaration merging to "register" your `config` globally with TypeScript.
- `config` property to pass your `config` directly to hooks.

### Declaration Merging

[Declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) allows you to "register" your `config` globally with TypeScript. The `Register` type enables Wagmi to infer types in places that wouldn't normally have access to type info via React Context alone. 

To set this up, add the following declaration to your project. Below, we co-locate the declaration merging and the `config` set up.

```ts
import { createConfig, http } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' { // [!code focus]
  interface Register { // [!code focus]
    config: typeof config // [!code focus]
  } // [!code focus]
} // [!code focus]

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

Since the `Register` type is global, you only need to add it once in your project. Once set up, you will get strong type-safety across your entire project. For example, query hooks will type `chainId` based on your `config`'s `chains`. 

```ts twoslash
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

declare module 'wagmi' {
  interface Register {
    config: Config<readonly [typeof mainnet, typeof sepolia]>
  }
}
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123 })
```

You just saved yourself a runtime error and you didn't even need to pass your `config`. 

### Hook `config` Property

For cases where you have more than one Wagmi `config` or don't want to use the declaration merging approach, you can pass a specific `config` directly to hooks via the `config` property.

```ts
import { createConfig, http } from 'wagmi'
import { mainnet, optimism } from 'wagmi/chains'

export const configA = createConfig({ // [!code focus]
  chains: [mainnet], // [!code focus]
  transports: { // [!code focus]
    [mainnet.id]: http(), // [!code focus]
  }, // [!code focus]
}) // [!code focus]

export const configB = createConfig({ // [!code focus]
  chains: [optimism], // [!code focus]
  transports: { // [!code focus]
    [optimism.id]: http(), // [!code focus]
  }, // [!code focus]
}) // [!code focus]
```

As you expect, `chainId` is inferred correctly for each `config`.

```ts twoslash
// @errors: 2322
import { type Config } from 'wagmi'
import { mainnet, optimism } from 'wagmi/chains'

declare const configA: Config<readonly [typeof mainnet]>
declare const configB: Config<readonly [typeof optimism]>
// ---cut---
import { useBlockNumber } from 'wagmi'

useBlockNumber({ chainId: 123, config: configA })
useBlockNumber({ chainId: 123, config: configB })
```

This approach is more explicit, but works well for advanced use-cases, if you don't want to use React Context or declaration merging, etc.

## Const-Assert ABIs & Typed Data

Wagmi can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

```ts
const { data } = useReadContract({
  abi: [], // <--- defined inline // [!code focus]
})
```

```ts
const abi = [] as const // <--- const assertion // [!code focus]
const { data } = useReadContract({ abi })
```

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

::: tip
Unfortunately [TypeScript doesn't support importing JSON `as const` yet](https://github.com/microsoft/TypeScript/issues/32063). Check out the [Wagmi CLI](/cli/getting-started) to help with this! It can automatically fetch ABIs from Etherscan and other block explorers, resolve ABIs from your Foundry/Hardhat projects, generate React Hooks, and more.
:::

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`useReadContract`](/react/api/hooks/useReadContract) looks like with and without a const-asserted `abi` property.

::: code-group
```ts twoslash [Const-Asserted]
const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { useReadContract } from 'wagmi'

const { data } = useReadContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

data
// ^?
```
```ts twoslash [Not Const-Asserted]
declare const erc721Abi: {
  name: string;
  type: string;
  stateMutability: string;
  inputs: {
    type: string;
    name: string;
  }[];
  outputs: {
    type: string;
  }[];
}[]
// ---cut---
import { useReadContract } from 'wagmi'

const { data } = useReadContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: erc721Abi,
  functionName: 'balanceOf',
  // ^?



  args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
  // ^?
})

data
// ^?
```
:::

<br/>
<br/>

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. 

```ts twoslash
// @errors: 2820
const erc721Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'owner' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isApprovedForAll',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'operator' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'getApproved',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'ownerOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'address' }],
  },
  {
    name: 'tokenURI',
    type: 'function',
    stateMutability: 'pure',
    inputs: [{ type: 'uint256', name: 'tokenId' }],
    outputs: [{ type: 'string' }],
  },
] as const
// ---cut---
import { useReadContract } from 'wagmi'

useReadContract({
  abi: erc721Abi,
  functionName: 'balanecOf',
})
```

## Configure Internal Types

For advanced use-cases, you may want to configure Wagmi's internal types. Most of Wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev) for more info on how to configure types.
</file>

<file path="react/why.md">
# Why Wagmi

## The Problems

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi solves all these problems and more  allowing app developers to focus on building high-quality and performant experiences for Ethereum  by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

## Developer Experience

Wagmi delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi's APIs might seem more verbose at first, it makes Wagmi's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi is a great way to learn how to interact with Ethereum in general.

Wagmi also provides [strongly typed APIs](/react/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](/react/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20(TDD),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

## Performance

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi uses and is built by the same team behind [Viem](https://viem.sh), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times. 

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi supports caching, deduplication, persistence, and much more through [TanStack Query](/react/guides/tanstack-query).

## Feature Coverage

Wagmi supports the most popular and commonly-used Ethereum features out of the box with 40+ React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi also supports just about any wallet out there through official [connectors](/react/api/connectors), [EIP-6963 support](/react/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Wagmi Core](/core/getting-started) or [Viem](https://viem.sh), which Wagmi uses internally to perform blockchain operations. Wagmi also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi has a [CLI](/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz), [Privy](https://privy.io), and many more, so you can get started quickly without needing to build everything from scratch.

## Stability

Stability is a fundamental principle for Wagmi. Many organizations, large and small, rely heavily on Wagmi and expect it to be entirely stable for their users and applications.

Wagmi's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi follows semver so developers can upgrade between versions with confidence. Starting with Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi and [related projects](https://github.com/wevm), and is constantly improving Wagmi and keeping it up-to-date with industry trends and changes.
</file>

<file path="shared/connectors/coinbaseWallet.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# coinbaseWallet

Connector for the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk).

## Import

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { coinbaseWallet } from '{{connectorsPackageName}}' // [!code hl]

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [coinbaseWallet()], // [!code hl]
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

:::warning
Before going to production, it is highly recommended to set an [`appName`](#appname) and [`appLogoUrl`](#applogourl) for your application that can be displayed upon connection to the wallet.
:::

## Parameters

```ts-vue
import { type CoinbaseWalletParameters } from '{{connectorsPackageName}}'
```

Check out the [Coinbase Wallet SDK docs](https://github.com/coinbase/coinbase-wallet-sdk) for more info.

### appName

`string`

Application name.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App', // [!code focus]
})
```

### appLogoUrl

`string | null | undefined`

Application logo image URL; favicon is used if unspecified.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  appLogoUrl: 'https://example.com/myLogoUrl.png', // [!code focus]
})
```

### headlessMode <Badge type="warning" text="deprecated" />

`boolean | undefined`

- Whether or not onboarding overlay popup should be displayed.
- `headlessMode` will be removed in the next major version. Upgrade to [`version: '4'`](#version).

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  headlessMode: false, // [!code focus]
})
```

### preference <Badge text=">=2.9.0" />

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

- `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
- `'smartWalletOnly'`: Displays Smart Wallet popup.
- `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  preference: 'smartWalletOnly', // [!code focus]
})
```

::: warning
Passing `preference` as a string is deprecated and will be removed in the next major version. Instead you should use [`preference#options`](#options).
:::

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  preference: { // [!code focus]
    options: 'smartWalletOnly' // [!code focus]
  }, // [!code focus]
})
```

#### attribution <Badge text=">=2.12.33" />

`` { auto?: boolean | undefined; dataSuffix?: `0x${string}` | undefined } ``

This option only applies to Coinbase Smart Wallet. When a valid data suffix is supplied, it is appended to the `initCode` and `executeBatch` calldata. Coinbase Smart Wallet expects a 16 byte hex string. If the data suffix is not a 16 byte hex string, the Smart Wallet will ignore the property. If auto is true, the Smart Wallet will generate a 16 byte hex string from the apps origin.

#### keysUrl <Badge text=">=2.12.33" />

`string`

- The URL for the keys popup.
- By default, `https://keys.coinbase.com/connect` is used for production. Use `https://keys-dev.coinbase.com/connect` for development environments.

#### options <Badge text=">=2.12.33" />

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

- `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
- `'smartWalletOnly'`: Displays Smart Wallet popup.
- `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

### version <Badge text=">=2.13.0" />

- Coinbase Wallet SDK version
- Defaults to `'4'`. If [`headlessMode: true`](#headlessmode), defaults to `'3'`.

```ts-vue
import { coinbaseWallet } from '{{connectorsPackageName}}'

const connector = coinbaseWallet({
  appName: 'My Wagmi App',
  version: '4', // [!code focus]
})
```
</file>

<file path="shared/connectors/injected.md">
<!-- <script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# injected

Connector for [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Providers.

## Import

```ts-vue
import { injected } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,7}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { injected } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type InjectedParameters } from '{{connectorsPackageName}}'
```

### shimDisconnect

`boolean | undefined`

- MetaMask and other injected providers do not support programmatic disconnect.
- This flag simulates the disconnect behavior by keeping track of connection status in storage. See [GitHub issue](https://github.com/MetaMask/metamask-extension/issues/10353) for more info.
- Defaults to `true`.

```ts-vue
import { injected } from '{{connectorsPackageName}}'

const connector = injected({
  shimDisconnect: false, // [!code focus]
})
```

### target

`TargetId | (TargetMap[TargetId] & { id: string }) | (() => (TargetMap[TargetId] & { id: string }) | undefined) | undefined`

- [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target.
- [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) supported via `createConfig`'s <a :href="`/${docsPath}/api/createConfig#multiinjectedproviderdiscovery`">`multiInjectedProviderDiscovery`</a> property.

```ts-vue
import { injected } from '{{connectorsPackageName}}'

const connector = injected({
  target() { // [!code focus]
    return { // [!code focus]
      id: 'windowProvider', // [!code focus]
      name: 'Window Provider', // [!code focus]
      provider: window.ethereum, // [!code focus]
    } // [!code focus]
  }, // [!code focus]
})
```

### unstable_shimAsyncInject

`boolean | number | undefined`

Watches for async provider injection via the `ethereum#initialized` event. When `true`, defaults to `1_000` milliseconds. Otherwise, uses a provided value of milliseconds.

```ts-vue
import { injected } from '{{connectorsPackageName}}'

const connector = injected({
  unstable_shimAsyncInject: 2_000, // [!code focus]
})
```
</file>

<file path="shared/connectors/metaMask.md">
<!-- <script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# metaMask

Connector for [MetaMask SDK](https://github.com/MetaMask/metamask-sdk).

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/metamask-sdk/javascript) for more information.

## Import

```ts-vue
import { metaMask } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,7}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { metaMask } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [metaMask()],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type MetaMaskParameters } from '{{connectorsPackageName}}'
```

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/3rd-party-libraries/wagmi/) for more info. A few options are omitted that Wagmi manages internally.

### dappMetadata

`DappMetadata | undefined`

Metadata is used to fill details for the UX on confirmation screens in MetaMask, including the following fields:

- `name`: `string` - The name of the dapp.
- `url`: `string` - URL of the dapp (defaults to `window.location.origin`).
- `iconUrl`: `string` - URL to the dapp's favicon or icon.

```ts-vue
import { metaMask } from '{{connectorsPackageName}}'

const connector = metaMask({
  dappMetadata: { // [!code focus]
    name: 'My Wagmi App', // [!code focus]
    url: 'https://example.com', // [!code focus]
    iconUrl: 'https://example.com/favicon.ico', // [!code focus]
  }
})
```

### logging

`SDKLoggingOptions | undefined`

Enables SDK-side logging to provide visibility into:

- RPC methods being called.
- Events received for syncing the chain or active account.
- Raw RPC responses.

In this context, this is especially useful to observe what calls are made through Wagmi hooks.

Relevant options:

```ts
{
  developerMode: boolean, // Enables developer mode logs
  sdk: boolean           // Enables SDK-specific logs
}
```

```ts
import { metaMask } from '{{connectorsPackageName}}'

const connector = metaMask({
  logging: { developerMode: true, sdk: true } // [!code focus]
})
```

### headless

`boolean | undefined`

- Enables headless mode, disabling MetaMask's built-in modal.
- Allows developers to create their own modal, such as for displaying a QR code.

This is particularly relevant for web-only setups using Wagmi, where developers want complete control over the UI.

To get the deeplink to display in the QR code, listen to the `display_uri` event.

The default is `false`.

```ts-vue
import { metaMask } from '{{connectorsPackageName}}'

const connector = metaMask({
  headless: true // [!code focus]
})
```

## Advanced

By default, if the EIP-6963 MetaMask injected provider is detected, this connector will replace it.

EIP-6963 defines a standard way for dapps to interact with multiple wallets simultaneously by injecting providers into the browser. Wallets that implement this standard can make their presence known to dapps in a consistent and predictable manner.

When MetaMask SDK detects an EIP-6963-compliant provider (such as MetaMask itself), the connector will automatically replace the default injected provider (like `window.ethereum`) with the one provided by MetaMask SDK.

See the [`rdns` property](https://wagmi.sh/dev/creating-connectors#properties) for more information.
</file>

<file path="shared/connectors/mock.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# mock

Connector for mocking Wagmi functionality.

## Import

```ts-vue
import { mock } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,8-14}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { mock } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [
    mock({
      accounts: [
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
      ],
    }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type MockParameters } from '{{connectorsPackageName}}'
```

### accounts

`readonly [Address, ...Address[]]`

Accounts to use with the connector.

```ts-vue
import { mock } from '{{connectorsPackageName}}'

const connector = mock({
  accounts: [ // [!code focus]
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', // [!code focus]
    '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
    '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', // [!code focus]
    '0x90F79bf6EB2c4f870365E785982E1f101E93b906', // [!code focus]
    '0x15d34aaf54267db7d7c367839aaf71a00a2c6a65', // [!code focus]
    '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', // [!code focus]
    '0x976EA74026E726554dB657fA54763abd0C3a0aa9', // [!code focus]
    '0x14dC79964da2C08b23698B3D3cc7Ca32193d9955', // [!code focus]
    '0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f', // [!code focus]
    '0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', // [!code focus]
  ], // [!code focus]
})
```

### features

`{ connectError?: boolean | Error | undefined; reconnect?: boolean | undefined; signMessageError?: boolean | Error | undefined; signTypedDataError?: boolean | Error | undefined; switchChainError?: boolean | Error | undefined; } | undefined`

Feature flags that change behavior of Wagmi internals.

```ts-vue
import { mock } from '{{connectorsPackageName}}'
import { UserRejectedRequestError } from 'viem'

const connector = mock({
  accounts: [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
  ],
  features: { // [!code focus]
    connectError: new UserRejectedRequestError(new Error('Failed to connect.')), // [!code focus]
    reconnect: false, // [!code focus]
  }, // [!code focus]
})
```
#### defaultConnected

`boolean | undefined`

Whether the connector is connected by default.

#### connectError

`boolean | Error | undefined`

Whether to throw an error when `connector.connect` is called.

#### reconnect

`boolean | undefined`

Enables reconnecting to connector.

#### signMessageError

`boolean | Error | undefined`

Whether to throw an error when `'personal_sign'` is called.

#### signTypedDataError

`boolean | Error | undefined`

Whether to throw an error when `'eth_signTypedData_v4'` is called.

#### switchChainError

`boolean | Error | undefined`

Whether to throw an error when `connector.switchChain` is called.
</file>

<file path="shared/connectors/safe.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# safe

Connector for [Safe Apps SDK](https://github.com/safe-global/safe-apps-sdk).

## Import

```ts-vue
import { safe } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,7}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { safe } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [safe()],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type SafeParameters } from '{{connectorsPackageName}}'
```

Check out the [Safe docs](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-sdk) for more info.
### allowedDomains

`RegExp[] | undefined`

```ts-vue
import { safe } from '{{connectorsPackageName}}'

const connector = safe({
  allowedDomains: [/app.safe.global$/], // [!code focus]
})
```

### debug

`boolean | undefined`

```ts-vue
import { safe } from '{{connectorsPackageName}}'

const connector = safe({
  debug: true, // [!code focus]
})
```

### shimDisconnect

`boolean | undefined`

- This flag simulates disconnect behavior by keeping track of connection status in storage.
- Defaults to `false`.

```ts-vue
import { safe } from '{{connectorsPackageName}}'

const connector = safe({
  shimDisconnect: true, // [!code focus]
})
```
</file>

<file path="shared/connectors/walletConnect.md">
<!-- <script setup>
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script> -->

# walletConnect

Connector for [WalletConnect](https://walletconnect.com).

## Import

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'
```

## Usage

```ts-vue{3,8-10}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { walletConnect } from '{{connectorsPackageName}}'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [
    walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

## Parameters

```ts-vue
import { type WalletConnectParameters } from '{{connectorsPackageName}}'
```

Check out the [WalletConnect docs](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/providers/ethereum-provider) for more info. A few options are omitted that Wagmi manages internally.

### customStoragePrefix <Badge :text="`${packageName === '@wagmi/core' ? '@wagmi/connectors@>=5.1.8' : `${packageName}@>=${packageName === 'wagmi' ? '2.12.8' : packageName === '@wagmi/vue' ? '0.0.40' : ''}`}`" />

`string | undefined`

Custom storage prefix for persisting provider state.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  customStoragePrefix: 'wagmi', // [!code focus]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### disableProviderPing

`boolean | undefined`

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  disableProviderPing: false, // [!code focus]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

### isNewChainsStale

`boolean | undefined`

- If a new chain is added to a previously existing configured connector `chains`, this flag
will determine if that chain should be considered as stale. A stale chain is a chain that
WalletConnect has yet to establish a relationship with (e.g. the user has not approved or
rejected the chain).
- Defaults to `true`.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  isNewChainsStale: true, // [!code focus]
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
})
```

::: details More info
Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires
the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when
a user tries to switch to a chain that they have not approved.

This flag mainly affects the behavior when a wallet does not support dynamic chain authorization
with WalletConnect v2.

If `true` (default), the new chain will be treated as a stale chain. If the user
has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect
session, the connector will disconnect upon the dapp auto-connecting, and the user will have to
reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.
This is the default behavior to avoid an unexpected error upon switching chains which may
be a confusing user experience (e.g. the user will not know they have to reconnect
unless the dapp handles these types of errors).

If `false`, the new chain will be treated as a validated chain. This means that if the user
has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully
auto-connect the user. This comes with the trade-off that the connector will throw an error
when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly
modifies their configured chains, and they do not want to disconnect the user upon
auto-connecting. If the user decides to switch to the unapproved chain, it is important that the
dapp handles this error and prompts the user to reconnect to the dapp in order to approve
the newly added chain.
:::

### metadata

`CoreTypes.Metadata | undefined`

Metadata related to the app requesting the connection.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  metadata: { // [!code focus]
    name: 'Example', // [!code focus]
    description: 'Example website', // [!code focus]
    url: 'https://example.com', // [!code focus]
  }, // [!code focus]
})
```

### projectId

`string`

WalletConnect Cloud project identifier. You can find your `projectId` on your [WalletConnect dashboard](https://cloud.reown.com/sign-in).

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68', // [!code focus]
})
```

### qrModalOptions

`QrModalOptions | undefined`

Options for rendering QR modal.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  qrModalOptions: { // [!code focus]
    themeMode: 'dark', // [!code focus]
  }, // [!code focus]
})
```

### relayUrl

`string | undefined`

- WalletConnect relay URL to use.
- Defaults to `'wss://relay.walletconnect.com'`.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  relayUrl: 'wss://relay.walletconnect.org', // [!code focus]
})
```

### storageOptions

`KeyValueStorageOptions | undefined`

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  storageOptions: {}, // [!code focus]
})
```

### showQrModal

`boolean | undefined`

- Whether to show the QR code modal upon calling `connector.connect()`.
- Defaults to `true`.

```ts-vue
import { walletConnect } from '{{connectorsPackageName}}'

const connector = walletConnect({
  projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
  showQrModal: true, // [!code focus]
})
```

::: tip
This can be disabled and you can listen for a `'message'` event with payload `{ type: 'display_uri'; data: string }` if you want to render your own QR code.
:::
</file>

<file path="shared/transports/custom.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# custom

The `custom` Transport connects to a JSON-RPC API via custom. Wraps Viem's [`custom` Transport](https://viem.sh/docs/clients/transports/custom.html).

## Import

```ts-vue
import { custom } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  custom // [!code hl]
} from '{{packageName}}'
import { mainnet } from '{{packageName}}/chains'
import { customRpc } from './rpc'

export const config = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  transports: {
    [mainnet.id]: custom({ // [!code hl]
      async request({ method, params }) { // [!code hl]
        const response = await customRpc.request(method, params) // [!code hl]
        return response // [!code hl]
      } // [!code hl]
    }) // [!code hl]
  },
})
```

## Parameters

### provider

`{ request({ method: string, params: unknown[] }): Promise<unknown> }`

An [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request) function.

```ts
import { customRpc } from './rpc'

const transport = custom({
  async request({ method, params }) { // [!code focus:3]
    const response = await customRpc.request(method, params)
    return response
  }
})
```

### key (optional)

`string`

A key for the Transport. Defaults to `"custom"`.

```ts
const transport = custom(
  provider,
  { 
    key: 'windowProvider', // [!code focus]
  }
)
```

### name (optional)

`string`

A name for the Transport. Defaults to `"Ethereum Provider"`.

```ts
const transport = custom(
  provider,
  { 
    name: 'Window Ethereum Provider', // [!code focus]
  }
)
```

### retryCount (optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
const transport = custom(provider, {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
const transport = custom(provider, {
  retryDelay: 100, // [!code focus]
})
```
</file>

<file path="shared/transports/fallback.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# fallback

The `fallback` Transport consumes **multiple** Transports. If a Transport request fails, it will fall back to the next one in the list. Wraps Viem's [`fallback` Transport](https://viem.sh/docs/clients/transports/fallback.html).

## Import

```ts-vue
import { fallback } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  fallback, // [!code hl]
  http,
} from '{{packageName}}'
import { mainnet } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  transports: {
    [mainnet.id]: fallback([ // [!code hl]
      http('https://foo-bar-baz.quiknode.pro/...'), // [!code hl]
      http('https://mainnet.infura.io/v3/...'), // [!code hl]
    ]) // [!code hl]
  },
})
```
</file>

<file path="shared/transports/http.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# http

The `http` Transport connects to a JSON-RPC API via HTTP. Wraps Viem's [`http` Transport](https://viem.sh/docs/clients/transports/http.html).

## Import

```ts-vue
import { http } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  http // [!code hl]
} from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()],
  transports: {
    [mainnet.id]: http('https://foo-bar-baz.quiknode.pro/...'), // [!code hl]
    [sepolia.id]: http('https://foo-bar-sep.quiknode.pro/...'), // [!code hl]
  },
})
```

::: warning
If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.
:::

### Batch JSON-RPC

The `http` Transport supports Batch JSON-RPC. This means that multiple JSON-RPC requests can be sent in a single HTTP request.

The Transport will batch up Actions over a given period and execute them in a single Batch JSON-RPC HTTP request. By default, this period is a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays) meaning that the batch request will be executed at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue). Consumers can specify a custom time period `wait` (in ms).

You can enable Batch JSON-RPC by setting the `batch` flag to `true`:

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: true // [!code hl]
})
```

## Parameters

### url

`string`

URL of the JSON-RPC API. Defaults to `chain.rpcUrls.default.http[0]`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...')
```

### batch

`boolean | BatchOptions`

Toggle to enable Batch JSON-RPC. Defaults to `false`

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: true // [!code focus]
})
```

### batch.batchSize

`number`

The maximum number of JSON-RPC requests to send in a batch. Defaults to `1_000`.

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: {
    batchSize: 2_000 // [!code focus]
  }
})
```

### batch.wait

`number`

The maximum number of milliseconds to wait before sending a batch. Defaults to `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays)).

```ts 
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  batch: {
    wait: 16 // [!code focus]
  }
})
```

### fetchOptions

[`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)

[Fetch options](https://developer.mozilla.org/en-US/docs/Web/API/fetch) to pass to the internal `fetch` function. Useful for passing auth headers or cache options.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  fetchOptions: { // [!code focus:5]
    headers: {
      'Authorization': 'Bearer ...'
    }
  }
})
```

### key

`string`

A key for the Transport. Defaults to `"http"`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  key: 'alchemy', // [!code focus]
})
```

### name

`string`

A name for the Transport. Defaults to `"HTTP JSON-RPC"`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  name: 'Alchemy HTTP Provider', // [!code focus]
})
```

### retryCount

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  retryDelay: 100, // [!code focus]
})
```

### timeout

`number`

The timeout for requests. Defaults to `10_000`.

```ts
const transport = http('https://foo-bar-baz.quiknode.pro/...', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="shared/transports/unstable_connector.md">
<!-- <script setup>
const docsPath = 'core'
const packageName = 'wagmi'
</script> -->

# unstable_connector

The `unstable_connector` Transport connects to a JSON-RPC API via the provided <a :href="`/${docsPath}/api/connectors`">Connector</a>. 

For example, if the provided Connector is <a :href="`/${docsPath}/api/connectors/injected`">`injected`</a> and the end-user uses MetaMask, then outgoing JSON-RPC requests will be sent via the MetaMask EIP-1193 Provider (`window.ethereum`).

## Import

```ts-vue
import { unstable_connector } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  fallback,
  unstable_connector, // [!code hl]
} from '{{packageName}}'
import { mainnet } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  transports: {
    [mainnet.id]: fallback([
      unstable_connector(injected), // [!code hl]
      http('https://foo-bar-baz.quiknode.pro/...')
    ])
  },
})
```

::: warning
It is **highly recommended** to use the `unstable_connector` Transport inside of a <a :href="`/${docsPath}/api/transports/fallback`">`fallback` Transport</a>. This ensures that if the Connector request fails, the Transport will fall back to a different Transport in the fallback set. 

Some common cases for a Connector request to fail are: 

- Chain ID mismatches,
- Connector RPC not supporting the requested method and/or only supporting a subset of methods for connected accounts,
- Rate-limiting of Connector RPC.
:::

## Parameters

### connector

`Connector`

The Connector to use for the Transport.

```ts
import { unstable_connector } from 'wagmi'
import { safe } from 'wagmi/connectors'

const transport = unstable_connector(safe) // [!code focus]
```

### key (optional)

`string`

A key for the Transport. Defaults to `"connector"`.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, { 
  key: 'injected',  // [!code focus]
})
```

### name (optional)

`string`

A name for the Transport. Defaults to `"Connector"`.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, { 
  name: 'Injected',  // [!code focus]
})
```

### retryCount (optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
import { unstable_connector } from 'wagmi'
import { injected } from 'wagmi/connectors'

const transport = unstable_connector(injected, {
  retryDelay: 100, // [!code focus]
})
```
</file>

<file path="shared/transports/webSocket.md">
<!-- <script setup>
const packageName = 'wagmi'
</script> -->

# webSocket

The `webSocket` Transport connects to a JSON-RPC API via a WebSocket. Wraps Viem's [`webSocket` Transport](https://viem.sh/docs/clients/transports/webSocket.html).

## Import

```ts-vue
import { webSocket } from '{{packageName}}'
```

## Usage

```ts-vue
import { 
  createConfig, 
  webSocket // [!code hl]
} from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()],
  transports: {
    [mainnet.id]: webSocket('wss://foo-bar-baz.quiknode.pro/...'), // [!code hl]
    [sepolia.id]: webSocket('wss://foo-bar-sep.quicknode.pro/...'), // [!code hl]
  },
})
```

::: warning
If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.
:::

## Parameters

### url

`string`

URL of the JSON-RPC API.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...')
```

### key (optional)

`string`

A key for the Transport. Defaults to `"webSocket"`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
  key: 'alchemy',  // [!code focus]
})
```

### name (optional)

`string`

A name for the Transport. Defaults to `"WebSocket JSON-RPC"`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
  name: 'Alchemy WebSocket Provider',  // [!code focus]
})
```

### retryCount (optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
  retryDelay: 100, // [!code focus]
})
```

### timeout (optional)

`number`

The timeout for async WebSocket requests. Defaults to `10_000`.

```ts
const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="shared/utilities/cookieToInitialState.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# cookieToInitialState

Helper to convert a cookie string into [initial state](/react/api/WagmiProvider#initialstate).

## Import

```ts-vue
import { cookieToInitialState } from '{{packageName}}'
```

## Usage

::: code-group

```ts-vue [server.ts]
import { cookieToInitialState } from '{{packageName}}'
import config from './config'

function handler(req: Request) {
  const initialState = cookieToInitialState(config, req.headers.cookie)
  // ...
}
```

```ts-vue [config.ts]
import { 
  createConfig, 
  http, 
  cookieStorage,
  createStorage
} from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  ssr: true,
  storage: createStorage({ 
    storage: cookieStorage,
  }), 
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

:::

## Parameters

### config

`Config`

Wagmi Config


### cookie

`string | null | undefined`

The cookie string.

## Return Type

`State`

Initial state.
</file>

<file path="shared/utilities/deserialize.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# deserialize

Deserialize function that supports `bigint` and `Map`.

## Import

```ts-vue
import { deserialize } from '{{packageName}}'
```

## Usage

```ts-vue
import { deserialize } from '{{packageName}}'

const result = deserialize('{"foo":"wagmi","bar":{"__type":"bigint","value":"123"}}')
```

## Parameters

### value

`string`

The string to deserialize.


### reviver

`(key: string, value: any) => any`

A custom reviver function for handling standard values.

## Return Type

`unknown`

Parsed value.
</file>

<file path="shared/utilities/normalizeChainId.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# normalizeChainId

Normalizes a chain ID to a number.

## Import

```ts-vue
import { normalizeChainId } from '{{packageName}}'
```

## Usage

:::warning Deprecated
Use `Number` instead.

```ts-vue
import { normalizeChainId } from '{{packageName}}' // [!code --]
const chainId = normalizeChainId(123n) // [!code --]
const chainId = Number(123n) // [!code ++]
```
:::

```ts-vue
import { normalizeChainId } from '{{packageName}}'

const result = normalizeChainId('0x1')
```

## Parameters


### chainId

`bigint | number | string`

The chain ID to normalize.

```ts-vue
import { normalizeChainId } from '{{packageName}}'

normalizeChainId(1n)
normalizeChainId(1)
normalizeChainId('0x1')
```

## Return Type

`number`

The normalized chain ID.
</file>

<file path="shared/utilities/serialize.md">
<!--
<script setup>
const packageName = 'wagmi'
</script>
-->

# serialize

Serialize function that supports `bigint` and `Map`.

## Import

```ts-vue
import { serialize } from '{{packageName}}'
```

## Usage

```ts-vue
import { serialize } from '{{packageName}}'

const result = serialize({ foo: 'wagmi', bar: 123n })
```

## Parameters

### value

`any`

The value to stringify.

### replacer

`(key: string, value: any) => any`

A custom replacer function for handling standard values.

### indent

`number | null | undefined`

The number of spaces to indent the output by.

### circularReplacer

A custom replacer function for handling circular values.

## Return Type

`string`

Stringified value.
</file>

<file path="shared/create-chain.md">
## Create Chain

Import the `Chain` type from Viem and create a new object that is asserted `as const` and `satisfies` the type. You can also use the `defineChain` function from Viem.

::: code-group
```ts twoslash [as const satisfies Chain]
// @errors: 1360
import { type Chain } from 'viem'

export const mainnet = {} as const satisfies Chain
```
```ts twoslash [defineChain]
// @errors: 2345
import { defineChain } from 'viem'

export const mainnet = defineChain({})
```
:::

Now, add the missing required properties to the object until the error goes away.

::: code-group
```ts twoslash [as const satisfies Chain]
import { type Chain } from 'viem'

export const mainnet = {
  id: 1,
  name: 'Ethereum',
  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
  rpcUrls: {
    default: { http: ['https://eth.merkle.io'] },
  },
  blockExplorers: {
    default: { name: 'Etherscan', url: 'https://etherscan.io' },
  },
  contracts: {
    ensRegistry: {
      address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    },
    ensUniversalResolver: {
      address: '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
      blockCreated: 16773775,
    },
    multicall3: {
      address: '0xca11bde05977b3631167028862be2a173976ca11',
      blockCreated: 14353601,
    },
  },
} as const satisfies Chain
```
```ts twoslash [defineChain]
import { defineChain } from 'viem'

export const mainnet = defineChain({
  id: 1,
  name: 'Ethereum',
  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
  rpcUrls: {
    default: { http: ['https://eth.merkle.io'] },
  },
  blockExplorers: {
    default: { name: 'Etherscan', url: 'https://etherscan.io' },
  },
  contracts: {
    ensRegistry: {
      address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    },
    ensUniversalResolver: {
      address: '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
      blockCreated: 16773775,
    },
    multicall3: {
      address: '0xca11bde05977b3631167028862be2a173976ca11',
      blockCreated: 14353601,
    },
  },
})
```
:::

The more properties you add, the better the chain will be to use with Wagmi. Most of these attributes exist within the [`ethereum-lists/chains` repository](https://github.com/ethereum-lists/chains/tree/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains).

- `id`: The chain ID for the network. This can be found by typing the network name into [ChainList](https://chainlist.org). Example: "Ethereum Mainnet" has a Chain ID of `1`.
- `name`: Human-readable name for the chain. Example: "Ethereum Mainnet"
- `nativeCurrency`: The native currency of the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L20-L24).
- `rpcUrls`: At least one public, credible RPC URL. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L4-L18).
- `blockExplorers`: A set of block explorers for the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L30-L36).
- `contracts`: A set of deployed contracts for the chain. If you are deploying one of the following contracts yourself, make sure it is verified.
  - `multicall3` is optional, but it's address is most likely `0xca11bde05977b3631167028862be2a173976ca11`  you can find the deployed block number on the block explorer. Check out [`mds1/multicall`](https://github.com/mds1/multicall#multicall3-contract-addresses) for more info.
  - `ensRegistry` is optional  not all Chains have a ENS Registry. See [ENS Deployments](https://docs.ens.domains/ens-deployments) for more info.
  - `ensUniversalResolver` is optional  not all Chains have a ENS Universal Resolver.
- `sourceId`: Source Chain ID (e.g. the L1 chain).
- `testnet`: Whether or not the chain is a testnet.
</file>

<file path="shared/createConfig.md">
<!--
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
const connectorsPackageName = 'wagmi/connectors'
</script>
-->

# createConfig

Creates new [`Config`](#config) object.

## Import

```ts-vue
import { createConfig } from '{{packageName}}'
```

## Usage

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

::: tip Integrating a Viem Client

Instead of using [`transports`](#transports), it's possible to provide a function that returns a Viem [`Client`](https://viem.sh/docs/clients/custom.html) via the [`client`](#client) property for more fine-grained control over Wagmi's internal `Client` creation.

```ts-vue {3,7-9}
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { createClient } from 'viem'

const config = createConfig({
  chains: [mainnet, sepolia],
  client({ chain }) {
    return createClient({ chain, transport: http() })
  },
})
```
:::

## Parameters

```ts-vue
import { type CreateConfigParameters } from '{{packageName}}'
```

### chains

`readonly [Chain, ...Chain[]]`

- Chains used by the `Config`.
- See <a :href="`/${docsPath}/api/chains`">Chains</a> for more details about built-in chains and the `Chain` type.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia], // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### connectors

`CreateConnectorFn[] | undefined`

<a :href="`/${docsPath}/api/connectors`">Connectors</a> used by the `Config`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'
import { injected } from '{{connectorsPackageName}}' // [!code focus]

const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [injected()], // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### multiInjectedProviderDiscovery

`boolean | undefined`

- Enables discovery of injected providers via [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) using the [`mipd`](https://github.com/wevm/mipd) library and converting to <a :href="`/${docsPath}/api/connectors/injected`">injected</a> connectors.
- Defaults to `true`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  multiInjectedProviderDiscovery: false, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### ssr

`boolean | undefined`

Flag to indicate if the config is being used in a server-side rendering environment. Defaults to `false`.

```ts-vue
import { createConfig, http } from '{{packageName}}' // [!code focus]
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  ssr: true, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### storage

`Storage | null | undefined`

- <a :href="`/${docsPath}/api/createStorage#storage`">`Storage`</a> used by the config. Persists `Config`'s [`State`](#state-1) between sessions.
- Defaults to `createStorage({ storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage })`.

```ts-vue
import { createConfig, createStorage, http } from '{{packageName}}' // [!code focus]
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  storage: createStorage({ storage: window.localStorage }), // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### syncConnectedChain

`boolean | undefined`

- Keep the [`State['chainId']`](#chainid) in sync with the current connection.
- Defaults to `true`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  syncConnectedChain: false, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

---

### batch

`{ multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | { [_ in chains[number]["id"]]?: { multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | undefined } | undefined`

- Batch settings. See [Viem docs](https://viem.sh/docs/clients/custom.html#batch-optional) for more info.
- Defaults to `{ multicall: true }`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  batch: { multicall: true }, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### cacheTime

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

- Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/public.html#cachetime-optional) for more info.
- Defaults to [`pollingInterval`](#pollinginterval) or `4_000`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  cacheTime: 4_000, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### pollingInterval

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

- Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/custom.html#pollinginterval-optional) for more info.
- Defaults to `4_000`.

```ts-vue
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  pollingInterval: 4_000, // [!code focus]
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

### transports

`Record<chains[number]['id'], Transport>`

Mapping of [chain IDs](#chains) to <a :href="`/${docsPath}/api/transports`">`Transport`</a>s. This mapping is used internally when creating chain-aware Viem [`Client`](https://viem.sh/docs/clients/custom.html) objects. See the <a :href="`/${docsPath}/api/transports`">Transport docs</a> for more info.

```ts-vue
import { createConfig, fallback, http } from '{{packageName}}' // [!code focus]
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  transports: { // [!code focus]
    [mainnet.id]: fallback([ // [!code focus]
      http('https://...'), // [!code focus]
      http('https://...'), // [!code focus]
    ]), // [!code focus]
    [sepolia.id]: http('https://...'), // [!code focus]
  }, // [!code focus]
})
```

---

### client

`(parameters: { chain: chains[number] }) => Client<Transport, chains[number]>`

Function for creating new Viem [`Client`](https://viem.sh/docs/clients/custom.html) to be used internally. Exposes more control over the internal `Client` creation logic versus using the [`transports`](#transports) property.

```ts-vue
import { createClient, http } from 'viem' // [!code focus]
import { createConfig } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

const config = createConfig({
  chains: [mainnet, sepolia],
  client({ chain }) { // [!code focus]
    return createClient({ chain, transport: http('https://...') }) // [!code focus]
  }, // [!code focus]
})
```

::: warning
When using this option, you likely want to pass `parameters.chain` straight through to [`createClient`](https://viem.sh/docs/clients/custom.html#createclient) to ensure the Viem `Client` is in sync with any active connections.
:::

## Return Type

```ts-vue
import { type Config } from '{{packageName}}'
```

## Config

Object responsible for managing Wagmi state and internals.

```ts-vue
import { type Config } from '{{packageName}}'
```

### chains

`readonly [Chain, ...Chain[]]`

[`chains`](#chains) passed to `createConfig`.

### connectors

`readonly Connector[]`

Connectors set up from passing [`connectors`](#connectors) and [`multiInjectedProviderDiscovery`](#multiinjectedproviderdiscovery) to `createConfig`.

### state

`State<chains>`

The `Config` object's internal state. See [`State`](#state-1) for more info.

### storage

`Storage | null`

[`storage`](#storage) passed to `createConfig`.

### getClient

`(parameters?: { chainId?: chainId | chains[number]['id'] | undefined }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>`

Creates new Viem [`Client`](https://viem.sh/docs/clients/custom.html) object.

::: code-group
```ts-vue [index.ts]
import { config } from './config'

const client = config.getClient({ chainId: 1 })
```

```ts-vue [config.ts]
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

:::

### setState

`(value: State<chains> | ((state: State<chains>) => State<chains>)) => void`

Updates the `Config` object's internal state. See [`State`](#state-1) for more info.

::: code-group
```ts-vue [index.ts]
import { mainnet } from '{{packageName}}/chains'
import { config } from './config'

config.setState((x) => ({
  ...x,
  chainId: x.current ? x.chainId : mainnet.id,
}))
```

```ts-vue [config.ts]
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

:::

::: warning
Exercise caution when using this method. It is intended for internal and advanced use-cases only. Manually setting state can cause unexpected behavior.
:::

### subscribe

`(selector: (state: State<chains>) => state, listener: (selectedState: state, previousSelectedState: state) => void, options?: { emitImmediately?: boolean | undefined; equalityFn?: ((a: state, b: state) => boolean) | undefined } | undefined) => (() => void)`

Listens for state changes matching the `selector` function. Returns a function that can be called to unsubscribe the listener.

::: code-group
```ts-vue [index.ts]
import { config } from './config'

const unsubscribe = config.subscribe(
  (state) => state.chainId,
  (chainId) => console.log(`Chain ID changed to ${chainId}`),
)
unsubscribe()
```

```ts-vue [config.ts]
import { createConfig, http } from '{{packageName}}'
import { mainnet, sepolia } from '{{packageName}}/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http('https://mainnet.example.com'),
    [sepolia.id]: http('https://sepolia.example.com'),
  },
})
```

:::

## State

```ts-vue
import { type State } from '{{packageName}}'
```

### chainId

`chains[number]['id']`

Current chain ID. When `syncConnectedChain` is `true`, `chainId` is kept in sync with the current connection. Defaults to first chain in [`chains`](#chains).

### connections

`Map<string, Connection>`

Mapping of unique connector identifier to [`Connection`](#connection) object.

### current

`string | undefined`

Unique identifier of the current connection.

### status

`'connected' | 'connecting' | 'disconnected' | 'reconnecting'`

Current connection status.

- `'connecting'` attempting to establish connection.
- `'reconnecting'` attempting to re-establish connection to one or more connectors.
- `'connected'` at least one connector is connected.
- `'disconnected'` no connection to any connector.

## Connection

```ts-vue
import { type Connection } from '{{packageName}}'
```

### accounts

`readonly [Address, ...Address[]]`

Array of addresses associated with the connection.

### chainId

`number`

Chain ID associated with the connection.

### connector

`Connector`

Connector associated with the connection.
</file>

<file path="shared/createStorage.md">
<!--
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
</script>
-->

# createStorage

Creates new [`Storage`](#storage) object.

## Import

```ts-vue
import { createStorage } from '{{packageName}}'
```

## Usage

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
```

## Parameters

```ts-vue
import { type CreateStorageParameters } from '{{packageName}}'
```

### deserialize

`(<T>(value: string) => T) | undefined`

- Function to deserialize data from storage.
- Defaults to <a :href="`/${docsPath}/api/utilities/deserialize`">`deserialize`</a>.

```ts-vue
import { createStorage, deserialize } from '{{packageName}}' // [!code focus]

const storage = createStorage({
  deserialize, // [!code focus]
  storage: localStorage,
})
```

::: warning
If you use a custom `deserialize` function, make sure it can handle `bigint` and `Map` values.
:::

### key

`string | undefined`

- Key prefix to use when persisting data.
- Defaults to `'wagmi'`.

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({
  key: 'my-app', // [!code focus]
  storage: localStorage,
})
```

### serialize

`(<T>(value: T) => string) | undefined`

- Function to serialize data for storage.
- Defaults to <a :href="`/${docsPath}/api/utilities/serialize`">`serialize`</a>.

```ts-vue
import { createStorage, serialize } from '{{packageName}}' // [!code focus]

const storage = createStorage({
  serialize, // [!code focus]
  storage: localStorage,
})
```

::: warning
If you use a custom `serialize` function, make sure it can handle `bigint` and `Map` values.
:::

### storage

`{ getItem(key: string): string | null | undefined | Promise<string | null | undefined>; setItem(key: string, value: string): void | Promise<void>; removeItem(key: string): void | Promise<void>; }`

- Storage interface to use for persisting data.
- Defaults to `localStorage`.
- Supports synchronous and asynchronous storage methods.

```ts-vue
import { createStorage } from '{{packageName}}'
// Using IndexedDB via https://github.com/jakearchibald/idb-keyval // [!code focus]
import { del, get, set } from 'idb-keyval' // [!code focus]

const storage = createStorage({
  storage: { // [!code focus]
    async getItem(name) { // [!code focus]
      return get(name)// [!code focus]
    }, // [!code focus]
    async setItem(name, value) { // [!code focus]
      await set(name, value) // [!code focus]
    }, // [!code focus]
    async removeItem(name) { // [!code focus]
      await del(name) // [!code focus]
    }, // [!code focus]
  }, // [!code focus]
})
```

## Return Type

```ts-vue
import { type Storage } from '{{packageName}}'
```

## Storage

Object responsible for persisting Wagmi <a :href="`/${docsPath}/api/createConfig#state-1`">`State`</a> and other data.

```ts-vue
import { type Storage } from '{{packageName}}'
```

### getItem

`getItem(key: string, defaultValue?: value | null | undefined): value | null | Promise<value | null>`

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
const recentConnectorId = storage.getItem('recentConnectorId') // [!code focus]
```

### setItem

`setItem(key: string, value: any): void | Promise<void>`

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
storage.setItem('recentConnectorId', 'foo') // [!code focus]
```

### removeItem

`removeItem(key: string): void | Promise<void>`

```ts-vue
import { createStorage } from '{{packageName}}'

const storage = createStorage({ storage: localStorage })
storage.removeItem('recentConnectorId') // [!code focus]
```
</file>

<file path="shared/errors.md">
<!--
<script setup>
const docsPath = 'react'
const packageName = 'wagmi'
</script>
-->

## BaseError

Error class extended by all errors.

```ts-vue
import { BaseError } from '{{packageName}}'
```

## Config

### ConnectorAccountNotFoundError

When an account does not exist on the connector or is unable to be used.

```ts-vue
import { ConnectorAccountNotFoundError } from '{{packageName}}'
```

### ConnectorAlreadyConnectedError

When a connector is already connected.

```ts-vue
import { ConnectorAlreadyConnectedError } from '{{packageName}}'
```

### ConnectorChainMismatchError

When the Wagmi Config is out-of-sync with the connector's active chain ID. This is rare and likely an upstream wallet issue.

```ts-vue
import { ConnectorChainMismatchError } from '{{packageName}}'
```

### ChainNotConfiguredError

When a chain is not configured. You likely need to add the chain to <a :href="`/${docsPath}/api/createConfig#chains`">`Config['chains']`</a>.

```ts-vue
import { ChainNotConfiguredError } from '{{packageName}}'
```

### ConnectorNotConnectedError

When a connector is not connected.

```ts-vue
import { ConnectorNotConnectedError } from '{{packageName}}'
```

### ConnectorNotFoundError

When a connector is not found or able to be used.

```ts-vue
import { ConnectorNotFoundError } from '{{packageName}}'
```

### ConnectorUnavailableReconnectingError

During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.

```ts-vue
import { ConnectorUnavailableReconnectingError } from '{{packageName}}'
```

## Connector

### ProviderNotFoundError

When a connector's provider is not found or able to be used.

```ts-vue
import { ProviderNotFoundError } from '{{packageName}}'
```

### SwitchChainNotSupportedError

When switching chains is not supported by connectors.

```ts-vue
import { SwitchChainNotSupportedError } from '{{packageName}}'
```
</file>

<file path="shared/faq.md">
<!--
<script setup>
const docsPath = 'react'
</script>
-->

## Type inference doesn't work

- Check that you set up TypeScript correctly with `"strict": true` in your `tsconfig.json` (<a :href="`/${docsPath}/typescript#requirements`">TypeScript docs</a>)
- Check that you <a :href="`/${docsPath}/typescript#const-assert-abis-typed-data`">const-asserted any ABIs or Typed Data</a> you are using.
- Restart your language server or IDE, and check for type errors in your code.

## My wallet doesn't work

If you run into issues with a specific wallet, try another before opening up an issue. There are many different wallets and it's likely that the issue is with the wallet itself, not Wagmi. For example, if you are using Wallet X and sending a transaction doesn't work, try Wallet Y and see if it works.

## `BigInt` Serialization

Using native `BigInt` with `JSON.stringify` will raise a `TypeError` as
[`BigInt` values are not serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json). There are two techniques to mitigate this:

#### Lossless serialization

Lossless serialization means that `BigInt` will be converted to a format that can be deserialized later (e.g. `69420n`  `"#bigint.69420"`). The trade-off is that these values are not human-readable and are not intended to be displayed to the user.

Lossless serialization can be achieved with wagmi's <a :href="`/${docsPath}/api/utilities/serialize`">`serialize`</a> and <a :href="`/${docsPath}/api/utilities/deserialize`">`deserialize`</a> utilities.

```tsx
import { serialize, deserialize } from 'wagmi'

const serialized = serialize({ value: 69420n })
// '{"value":"#bigint.69420"}'

const deserialized = deserialize(serialized)
// { value: 69420n }
```

#### Lossy serialization

Lossy serialization means that the `BigInt` will be converted to a normal display string (e.g. `69420n`  `'69420'`).
The trade-off is that you will not be able to deserialize the `BigInt` with `JSON.parse` as it can not distinguish between a normal string and a `BigInt`.

This method can be achieved by modifying `JSON.stringify` to include a BigInt `replacer`:

```tsx
const replacer = (key, value) =>
  typeof value === 'bigint' ? value.toString() : value

JSON.stringify({ value: 69420n }, replacer)
// '{"value":"69420"}'
```

## How do I support the project?

Wagmi is an open source software project and free to use. If you enjoy using Wagmi or would like to support Wagmi development, you can:

- [Become a sponsor on GitHub](https://github.com/sponsors/wevm)
- Send us crypto
  - Mainnet: 0x4557B18E779944BFE9d78A672452331C186a9f48
  - Multichain: 0xd2135CfB216b74109775236E36d4b433F1DF507B
- [Become a supporter on Drips](https://www.drips.network/app/projects/github/wevm/wagmi)

If you use Wagmi at work, consider asking your company to sponsor Wagmi. This may not be easy, but **business sponsorships typically make a much larger impact on the sustainability of OSS projects** than individual donations, so you will help us much more if you succeed.

## Is Wagmi production ready?

Yes. Wagmi is very stable and is used in production by thousands of organizations, like [Stripe](https://stripe.com), [Shopify](https://shopify.com), [Coinbase](https://coinbase.com), [Uniswap](https://uniswap.org), [ENS](https://ens.domains), [Optimism](https://optimism.com).

## Is Wagmi strict with semver?

Yes, Wagmi is very strict with [semantic versioning](https://semver.org) and we will never introduce breaking changes to the runtime API in a minor version bump.

For exported types, we try our best to not introduce breaking changes in non-major versions, however, [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases that can cause Wagmi type issues. See the <a :href="`/${docsPath}/typescript#requirements`">TypeScript docs</a> for more information.

## How can I contribute to Wagmi?

The Wagmi team accepts all sorts of contributions. Check out the [Contributing](/dev/contributing) guide to get started. If you are interested in adding a new connector to Wagmi, check out the [Creating Connectors](/dev/creating-connectors) guide.

## Anything else you want to know?

Please create a new [GitHub Discussion thread](https://github.com/wevm/wagmi). You're also free to suggest changes to this or any other page on the site using the "Suggest changes to this page" button at the bottom of the page.
</file>

<file path="shared/getAccount-return-type.md">
<!--
<script setup>
const TVariables = 'TVariables'
</script>
-->

### address

`Address | undefined`

- Connected address from connector.
- Defaults to first address in [`addresses`](#addresses).

### addresses

`readonly Address[] | undefined`

Connected addresses from connector.

### chain

`Chain | undefined`

Connected chain from connector. If chain is not configured by config, it will be `undefined`.

### chainId

`number | undefined`

Connected chain id from connector.

### connector

`Connector | undefined`

Connected connector.

### isConnecting / isReconnecting / isConnected / isDisconnected

`boolean`

Boolean variables derived from [`status`](#status).

### status

`'connecting' | 'reconnecting' | 'connected' | 'disconnected'`

- `'connecting'` attempting to establish connection.
- `'reconnecting'` attempting to re-establish connection to one or more connectors.
- `'connected'` at least one connector is connected.
- `'disconnected'` no connection to any connector.

::: info You can use `status` to narrow the return type. 
For example, when `status` is `'connected'` properties like `address` are guaranteed to be defined.

```ts twoslash
import { type GetAccountReturnType } from '@wagmi/core'
const account = {} as GetAccountReturnType
// ---cut---
if (account.status === 'connected') {
  account
  // ^?















}
```

Or when status is `'disconnected'` properties like `address` are guaranteed to be `undefined`:

```ts twoslash
import { type GetAccountReturnType } from '@wagmi/core'
const account = {} as GetAccountReturnType
// ---cut---
if (account.status === 'disconnected') {
  account
  // ^?















}
```
:::
</file>

<file path="shared/installation.md">
<!--
<script setup>
import Browsers from '../components/Browsers.vue'
const docsPath = 'react'
const packageDir = 'react'
const packageName = 'wagmi'
</script>
-->

## Requirements

Wagmi is optimized for modern browsers. It is compatible with the latest versions of the following browsers.

<Browsers />

::: tip
Depending on your environment, you might need to add polyfills. See [Viem Platform Compatibility](https://viem.sh/docs/compatibility.html) for more info.
:::

## Using Unreleased Commits

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

::: code-group
```bash-vue [pnpm]
pnpm add {{packageName}}@canary
```

```bash-vue [npm]
npm install {{packageName}}@canary
```

```bash-vue [yarn]
yarn add {{packageName}}@canary
```

```bash-vue [bun]
bun add {{packageName}}@canary
```
:::

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

```bash-vue
gh repo clone wevm/wagmi
cd wagmi
pnpm install
pnpm build
cd packages/{{packageDir}}
pnpm link --global
```

Then go to the project where you are using Wagmi and run `pnpm link --global {{packageName}}` (or the package manager that you used to link Wagmi globally). Make sure you installed any [required peer dependencies](#package-manager) and their versions are correct.

## Security

Ethereum-related projects are often targeted in attacks to steal users' assets. Make sure you follow security best-practices for your project. Some quick things to get started.

- Pin package versions, upgrade mindfully, and inspect lockfile changes to minimize the risk of [supply-chain attacks](https://nodejs.org/en/guides/security/#supply-chain-attacks).
- Install the [Socket Security](https://socket.dev) [GitHub App](https://github.com/apps/socket-security) to help detect and block supply-chain attacks.
- Add a [Content Security Policy](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) to defend against external scripts running in your app.
- Pin [GitHub Action](https://x.com/paulmillr/status/1900948425325031448) versions to commits instead of tags.
</file>

<file path="shared/mutation-imports.md">
<!--
<script setup>
const packageName = 'wagmi'
const actionName = 'connect'
const typeName = 'Connect'
</script>
-->

## TanStack Query

```ts-vue
import {
  type {{typeName}}Data,
  type {{typeName}}Variables,
  type {{typeName}}Mutate,
  type {{typeName}}MutateAsync,
  {{actionName}}MutationOptions,
} from '{{packageName}}/query'
```
</file>

<file path="shared/mutation-options.md">
<!--
<script setup>
const mutate = 'mutationFn'
const TData = 'TData'
const TError = 'TError'
const TVariables = 'TVariables'
</script>
-->

<br />

---

### mutation

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

::: info Wagmi does not support passing all TanStack Query parameters
TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.
:::

#### gcTime

`number | Infinity | undefined`

- The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
- If set to `Infinity`, will disable garbage collection

#### meta

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`{{mutate}}`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode

`'online' | 'always' | 'offlineFirst' | undefined`

- defaults to `'online'`
- see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError

`((error: {{TError}}, variables: {{TVariables}}, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate

`((variables: {{TVariables}}) => Promise<context | void> | context | void) | undefined`

- This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
- Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
- The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess

`((data: {{TData}}, variables: {{TVariables}}, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled

`((data: {{TData}}, error: {{TError}}, variables: {{TVariables}}, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry

`boolean | number | ((failureCount: number, error: {{TError}}) => boolean) | undefined`

- Defaults to `0`.
- If `false`, failed mutations will not retry.
- If `true`, failed mutations will retry infinitely.
- If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay

`number | ((retryAttempt: number, error: {{TError}}) => number) | undefined`

- This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
- A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
- A function like `attempt => attempt * 1000` applies linear backoff.
</file>

<file path="shared/mutation-result.md">
<!--
<script setup>
const mutate = 'mutationFn'
const TData = 'TData'
const TError = 'TError'
const TVariables = 'TVariables'
</script>
-->

<br />

---

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### {{mutate}}

`(variables: {{TVariables}}, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

- #### variables

  `{{TVariables}}`

  The variables object to pass to the <a :href="`/core/api/actions/${mutate}#parameters`">`{{mutate}}`</a> action.

- #### onSuccess

  `(data: {{TData}}, variables: {{TVariables}}, context: TContext) => void`

  This function will fire when the mutation is successful and will be passed the mutation's result.

- #### onError

  `(error: {{TError}}, variables: {{TVariables}}, context: TContext | undefined) => void`

  This function will fire if the mutation encounters an error and will be passed the error.

- #### onSettled

  `(data: {{TData}} | undefined, error: {{TError}} | null, variables: {{TVariables}}, context: TContext | undefined) => void`

  - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
  - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### {{mutate}}Async

`(variables: {{TVariables}}, { onSuccess, onSettled, onError }) => Promise<{{TData}}>`

Similar to [`{{mutate}}`](#mutate) but returns a promise which can be awaited.

### data

`{{TData}} | undefined`

- <a :href="`/core/api/actions/${mutate}#return-type`">`{{mutate}}` return type</a>
- Defaults to `undefined`
- The last successfully resolved data for the mutation.

### error

`{{TError}} | null`

The error object for the mutation, if an error was encountered.

### failureCount

`number`

- The failure count for the mutation.
- Incremented every time the mutation fails.
- Reset to `0` when the mutation succeeds.

### failureReason

`{{TError}} | null`

- The failure reason for the mutation retry.
- Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused

`boolean`

- will be `true` if the mutation has been `paused`.
- see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status

`'idle' | 'pending' | 'error' | 'success'`

- `'idle'` initial status prior to the mutation function executing.
- `'pending'` if the mutation is currently executing.
- `'error'` if the last mutation attempt resulted in an error.
- `'success'` if the last mutation attempt was successful.

### submittedAt

`number`

- The timestamp for when the mutation was submitted.
- Defaults to `0`.

### variables

`{{TVariables}} | undefined`

- The variables object passed to [`{{mutate}}`](#mutate).
- Defaults to `undefined`.
</file>

<file path="shared/query-imports.md">
<!--
<script setup>
const packageName = 'wagmi'
const actionName = 'getBalance'
const typeName = 'GetBalance'
</script>
-->

## TanStack Query

```ts-vue
import {
  type {{typeName}}Data,
  type {{typeName}}Options,
  type {{typeName}}QueryFnData,
  type {{typeName}}QueryKey,
  {{actionName}}QueryKey,
  {{actionName}}QueryOptions,
} from '{{packageName}}/query'
```
</file>

<file path="shared/query-options.md">
<!--
<script setup>
const TData = 'TData'
const TError = 'TError'
const TPageParam = number
const hideQueryOptions = []
const includeInfiniteQueryOptions = false
</script>
-->

<br />

---

### query

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

::: info Wagmi does not support passing all TanStack Query parameters
TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.
:::

#### enabled

`boolean | undefined`

- Set this to `false` to disable this query from automatically running.
- Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

<div v-if="!hideQueryOptions?.includes('gcTime')">

#### gcTime

`number | Infinity | undefined`

- Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
- The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
- If set to `Infinity`, will disable garbage collection

</div>

#### initialData

`{{TData}} | (() => {{TData}}) | undefined`

- If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
- If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
- Initial data is considered stale by default unless a `staleTime` has been set.
- `initialData` **is persisted** to the cache

#### initialDataUpdatedAt

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

<div v-if="includeInfiniteQueryOptions">

#### initialPageParam

`{{TPageParam}}`

The initial page parameter to be passed to the query function.

#### getPreviousPageParam

This function can be set to automatically get the previous cursor for infinite queries.
The result will also be used to determine the value of `hasPreviousPage`.

`(firstPage: {{TData}}, allPages: {{TData}}[], firstPageParam: {{TPageParam}}, allPageParams: {{TPageParam}}[]) => {{TPageParam}} | undefined | null`

#### getNextPageParam

This function can be set to automatically get the previous cursor for infinite queries.
The result will also be used to determine the value of `hasPreviousPage`.

`(lastPage: {{TData}}, allPages: {{TData}}[], lastPageParam: {{TPageParam}}, allPageParams: {{TPageParam}}[]) => {{TPageParam}} | undefined | null`

</div>

#### meta

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode

`online' | 'always' | 'offlineFirst' | undefined`

- Defaults to `'online'`
- see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps

`string[] | 'all' | (() => string[] | 'all') | undefined`

- If set, the component will only re-render if any of the listed properties change.
- If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
- If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
- If set to a function, the function will be executed to compute the list of properties.
- By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData

`{{TData}} | ((previousValue: {{TData}} | undefined; previousQuery: Query | undefined) => {{TData}}) | undefined`

- If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
- `placeholderData` is **not persisted** to the cache
- If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval

`number | false | ((data: {{TData}} | undefined, query: Query) => number | false | undefined) | undefined`

- If set to a number, all queries will continuously refetch at this frequency in milliseconds
- If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

- Defaults to `true`
- If set to `true`, the query will refetch on mount if the data is stale.
- If set to `false`, the query will not refetch on mount.
- If set to `'always'`, the query will always refetch on mount.
- If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

- Defaults to `true`
- If set to `true`, the query will refetch on reconnect if the data is stale.
- If set to `false`, the query will not refetch on reconnect.
- If set to `'always'`, the query will always refetch on reconnect.
- If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

- Defaults to `true`
- If set to `true`, the query will refetch on window focus if the data is stale.
- If set to `false`, the query will not refetch on window focus.
- If set to `'always'`, the query will always refetch on window focus.
- If set to a function, the function will be executed with the query to compute the value

#### retry

`boolean | number | ((failureCount: number, error: {{TError}}) => boolean) | undefined`

- If `false`, failed queries will not retry by default.
- If `true`, failed queries will retry infinitely.
- If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
- Defaults to `3` on the client and `0` on the server

#### retryDelay

`number | ((retryAttempt: number, error: {{TError}}) => number) | undefined`

- This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
- A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
- A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select

`((data: {{TData}}) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

<div v-if="!hideQueryOptions?.includes('staleTime')">

#### staleTime

`number | Infinity | undefined`

- Defaults to `0`
- The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
- If set to `Infinity`, the data will never be considered stale

</div>

#### structuralSharing

`boolean | (((oldData: {{TData}} | undefined, newData: {{TData}}) => {{TData}})) | undefined`

- Defaults to `true`
- If set to `false`, structural sharing between query results will be disabled.
- If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.
</file>

<file path="shared/query-result.md">
<!--
<script setup>
const TData = 'TData'
const TError = 'TError'
const includeInfiniteQueryResult = false
</script>
-->

<br />

---

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data

`{{TData}}`

- The last successfully resolved data for the query.
- Defaults to `undefined`.

### dataUpdatedAt

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error

`null | {{TError}}`

- The error object for the query, if an error was thrown.
- Defaults to `null`

### errorUpdatedAt

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount

`number`

The sum of all errors.

### failureCount

`number`

- The failure count for the query.
- Incremented every time the query fails.
- Reset to `0` when the query succeeds.

### failureReason

`null | {{TError}}`

- The failure reason for the query retry.
- Reset to `null` when the query succeeds.

<div v-if="includeInfiniteQueryOptions">

### fetchNextPage

`(options?: FetchNextPageOptions) => Promise<InfiniteQueryObserverResult<{{TData}}, {{TError}}>>`

This function allows you to fetch the next "page" of results.

### fetchPreviousPage

`(options?: FetchPreviousPageOptions) => Promise<InfiniteQueryObserverResult<TData, TError>>`

This function allows you to fetch the previous "page" of results.

### hasNextPage

`boolean`

This will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).

### hasPreviousPage

`boolean`

This will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).

### isFetchingNextPage

`boolean`

Will be `true` while fetching the next page with `fetchNextPage`.

### isFetchingPreviousPage

`boolean`

Will be `true` while fetching the previous page with `fetchPreviousPage`.

</div>

### fetchStatus

`'fetching' | 'idle' | 'paused'`

- `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
- `paused` The query wanted to fetch, but has been `paused`.
- `idle` The query is not fetching.
- See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount

`boolean`

- Will be `true` if the query has been fetched after the component mounted.
- This property can be used to not show any previously cached data.

### isFetching / isPaused

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading

`boolean`

- Is `true` whenever the first fetch for a query is in-flight
- Is the same as `isFetching && isPending`

### isLoadingError

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching

`boolean`

- Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
- Is the same as `isFetching && !isPending`

### isStale

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<{{TData}}, {{TError}}>>`

- A function to manually refetch the query.
- `throwOnError`
  - When set to `true`, an error will be thrown if the query fails.
  - When set to `false`, an error will be logged if the query fails.
- `cancelRefetch`
  - When set to `true`, a currently running request will be cancelled before a new request is made.
  - When set to `false`, no refetch will be made if there is already a request running.
  - Defaults to `true`

### status

`'error' | 'pending' | 'success'`

- `pending` if there's no cached data and no query attempt was finished yet.
- `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
- `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.
</file>

<file path="snippets/react/app.tsx">
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import * as React from 'react'
import { WagmiProvider } from 'wagmi'
import { config } from './config'

export const queryClient = new QueryClient()

export function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        {/** ... */}
      </QueryClientProvider>
    </WagmiProvider>
  )
}
</file>

<file path="snippets/react/config-chain-properties.ts">
import { http, createConfig } from 'wagmi'
import { base, celo, mainnet } from 'wagmi/chains'

export const config = createConfig({
  chains: [base, celo, mainnet],
  transports: {
    [base.id]: http(),
    [celo.id]: http(),
    [mainnet.id]: http(),
  },
})

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
</file>

<file path="snippets/react/config.ts">
import { http, createConfig } from 'wagmi'
import { mainnet, sepolia } from 'wagmi/chains'

export const config = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
</file>

<file path="snippets/abi-event.ts">
export const abi = [
  {
    type: 'event',
    name: 'Approval',
    inputs: [
      { indexed: true, name: 'owner', type: 'address' },
      { indexed: true, name: 'spender', type: 'address' },
      { indexed: false, name: 'value', type: 'uint256' },
    ],
  },
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      { indexed: true, name: 'from', type: 'address' },
      { indexed: true, name: 'to', type: 'address' },
      { indexed: false, name: 'value', type: 'uint256' },
    ],
  },
] as const
</file>

<file path="snippets/abi-infinite-read.ts">
export const abi = [
  {
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    name: 'getChest',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    name: 'getFoot',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    name: 'getHand',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const
</file>

<file path="snippets/abi-read.ts">
export const abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: 'supply', type: 'uint256' }],
  },
] as const
</file>

<file path="snippets/abi-write.ts">
export const abi = [
  {
    type: 'function',
    name: 'approve',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
  {
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'sender', type: 'address' },
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
] as const
</file>

<file path="snippets/typedData.ts">
import type { TypedData } from 'viem'

export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const satisfies TypedData
</file>

</files>
