This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/core, packages/sign-client, packages/types, packages/utils
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  core/
    src/
      constants/
        core.ts
        crypto.ts
        echo.ts
        events.ts
        expirer.ts
        history.ts
        index.ts
        keychain.ts
        messages.ts
        pairing.ts
        publisher.ts
        relayer.ts
        store.ts
        subscriber.ts
        verify.ts
      controllers/
        crypto.ts
        echo.ts
        events.ts
        expirer.ts
        history.ts
        index.ts
        keychain.ts
        messages.ts
        pairing.ts
        publisher.ts
        relayer.ts
        store.ts
        subscriber.ts
        topicmap.ts
        verify.ts
      core.ts
      index.ts
    test/
      shared/
        helpers.ts
        index.ts
        values.ts
        ws.ts
      core.spec.ts
      crypto.spec.ts
      events.spec.ts
      expirer.spec.ts
      history.spec.ts
      keychain.spec.ts
      messages.spec.ts
      pairing.spec.ts
      persistence.spec.ts
      publisher.spec.ts
      relayer.spec.ts
      store.spec.ts
      subscriber.spec.ts
      verify.spec.ts
    .npmignore
    CHANGELOG.md
    LICENSE
    package.json
    README.md
    rollup.config.js
    tsconfig.json
  sign-client/
    src/
      constants/
        auth.ts
        client.ts
        engine.ts
        history.ts
        index.ts
        pendingRequest.ts
        proposal.ts
        session.ts
        verify.ts
      controllers/
        authKey.ts
        authPairingTopic.ts
        authRequest.ts
        authStore.ts
        engine.ts
        index.ts
        pendingRequest.ts
        proposal.ts
        session.ts
      client.ts
      index.ts
    test/
      canary/
        canary.spec.ts
      concurrency/
        concurrency.spec.ts
      lifecycle/
        lifecycle.spec.ts
      sdk/
        integration/
          events.spec.ts
          integration.spec.ts
          push.spec.ts
        auth.spec.ts
        client.spec.ts
        link-mode.spec.ts
        persistence.spec.ts
        transport.spec.ts
        validation.spec.ts
      shared/
        connect.ts
        helpers.ts
        index.ts
        init.ts
        metrics.ts
        status.ts
        values.ts
        ws.ts
      xregion/
        xregion.spec.ts
    .npmignore
    CHANGELOG.md
    Dockerfile
    LICENSE
    package.json
    README.md
    rollup.config.js
    tsconfig.json
  types/
    src/
      core/
        core.ts
        crypto.ts
        echo.ts
        events.ts
        expirer.ts
        history.ts
        index.ts
        keychain.ts
        messages.ts
        pairing.ts
        publisher.ts
        relayer.ts
        store.ts
        subscriber.ts
        verify.ts
      sign-client/
        auth.ts
        client.ts
        engine.ts
        index.ts
        jsonrpc.ts
        pendingRequest.ts
        proposal.ts
        session.ts
      index.ts
    .npmignore
    CHANGELOG.md
    LICENSE
    package.json
    README.md
    rollup.config.js
    tsconfig.json
  utils/
    src/
      cacao.ts
      caip.ts
      crypto.ts
      errors.ts
      index.ts
      memoryStore.ts
      misc.ts
      namespaces.ts
      network.ts
      relay.ts
      signatures.ts
      uri.ts
      validators.ts
    test/
      shared/
        index.ts
        values.ts
      cacao.spec.ts
      crypto.spec.ts
      metadata.spec.ts
      misc.spec.ts
      signatures.spec.ts
      uri.spec.ts
      validators.spec.ts
    .npmignore
    CHANGELOG.md
    LICENSE
    package.json
    README.md
    rollup.config.js
    tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/core/src/constants/core.ts">
export const CORE_PROTOCOL = "wc";
export const CORE_VERSION = 2;
export const CORE_CONTEXT = "core";

export const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;

export const CORE_DEFAULT = {
  name: CORE_CONTEXT,
  logger: "error",
};

export const CORE_STORAGE_OPTIONS = {
  database: ":memory:",
};
</file>

<file path="packages/core/src/constants/crypto.ts">
import { ONE_DAY } from "@walletconnect/time";

export const CRYPTO_CONTEXT = "crypto";

export const CRYPTO_CLIENT_SEED = "client_ed25519_seed";

export const CRYPTO_JWT_TTL = ONE_DAY;
</file>

<file path="packages/core/src/constants/echo.ts">
export const ECHO_CONTEXT = "echo";

export const ECHO_URL = "https://echo.walletconnect.com";
</file>

<file path="packages/core/src/constants/events.ts">
export const EVENT_CLIENT_CONTEXT = "event-client";

export const EVENT_CLIENT_PAIRING_TRACES = {
  pairing_started: "pairing_started",
  pairing_uri_validation_success: "pairing_uri_validation_success",
  pairing_uri_not_expired: "pairing_uri_not_expired",
  store_new_pairing: "store_new_pairing",
  subscribing_pairing_topic: "subscribing_pairing_topic",
  subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
  existing_pairing: "existing_pairing",
  pairing_not_expired: "pairing_not_expired",
  emit_inactive_pairing: "emit_inactive_pairing",
  emit_session_proposal: "emit_session_proposal",
  subscribing_to_pairing_topic: "subscribing_to_pairing_topic",
};

export const EVENT_CLIENT_PAIRING_ERRORS = {
  no_wss_connection: "no_wss_connection",
  no_internet_connection: "no_internet_connection",
  malformed_pairing_uri: "malformed_pairing_uri",
  active_pairing_already_exists: "active_pairing_already_exists",
  subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
  pairing_expired: "pairing_expired",
  proposal_expired: "proposal_expired",
  proposal_listener_not_found: "proposal_listener_not_found",
};

export const EVENT_CLIENT_SESSION_TRACES = {
  session_approve_started: "session_approve_started",
  proposal_not_expired: "proposal_not_expired",
  session_namespaces_validation_success: "session_namespaces_validation_success",
  create_session_topic: "create_session_topic",
  subscribing_session_topic: "subscribing_session_topic",
  subscribe_session_topic_success: "subscribe_session_topic_success",
  publishing_session_approve: "publishing_session_approve",
  session_approve_publish_success: "session_approve_publish_success",
  store_session: "store_session",
  publishing_session_settle: "publishing_session_settle",
  session_settle_publish_success: "session_settle_publish_success",
};

export const EVENT_CLIENT_SESSION_ERRORS = {
  no_internet_connection: "no_internet_connection",
  no_wss_connection: "no_wss_connection",
  proposal_expired: "proposal_expired",
  subscribe_session_topic_failure: "subscribe_session_topic_failure",
  session_approve_publish_failure: "session_approve_publish_failure",
  session_settle_publish_failure: "session_settle_publish_failure",
  session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
  proposal_not_found: "proposal_not_found",
};

export const EVENT_CLIENT_AUTHENTICATE_TRACES = {
  authenticated_session_approve_started: "authenticated_session_approve_started",
  authenticated_session_not_expired: "authenticated_session_not_expired",
  chains_caip2_compliant: "chains_caip2_compliant",
  chains_evm_compliant: "chains_evm_compliant",
  create_authenticated_session_topic: "create_authenticated_session_topic",
  cacaos_verified: "cacaos_verified",
  store_authenticated_session: "store_authenticated_session",
  subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
  subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
  publishing_authenticated_session_approve: "publishing_authenticated_session_approve",
  authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success",
};

export const EVENT_CLIENT_AUTHENTICATE_ERRORS = {
  no_internet_connection: "no_internet_connection",
  no_wss_connection: "no_wss_connection",
  missing_session_authenticate_request: "missing_session_authenticate_request",
  session_authenticate_request_expired: "session_authenticate_request_expired",
  chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
  chains_evm_compliant_failure: "chains_evm_compliant_failure",
  invalid_cacao: "invalid_cacao",
  subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
  authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
  authenticated_session_pending_request_not_found:
    "authenticated_session_pending_request_not_found",
};

export const EVENTS_STORAGE_VERSION = 0.1;

export const EVENTS_STORAGE_CONTEXT = "event-client";

export const EVENTS_STORAGE_CLEANUP_INTERVAL = 86400;

export const EVENTS_CLIENT_API_URL = "https://pulse.walletconnect.org/batch";
</file>

<file path="packages/core/src/constants/expirer.ts">
import { ONE_DAY } from "@walletconnect/time";

export const EXPIRER_CONTEXT = "expirer";

export const EXPIRER_EVENTS = {
  created: "expirer_created",
  deleted: "expirer_deleted",
  expired: "expirer_expired",
  sync: "expirer_sync",
};

export const EXPIRER_STORAGE_VERSION = "0.3";

export const EXPIRER_DEFAULT_TTL = ONE_DAY;
</file>

<file path="packages/core/src/constants/history.ts">
export const HISTORY_EVENTS = {
  created: "history_created",
  updated: "history_updated",
  deleted: "history_deleted",
  sync: "history_sync",
};

export const HISTORY_CONTEXT = "history";

export const HISTORY_STORAGE_VERSION = "0.3";
</file>

<file path="packages/core/src/constants/index.ts">
export * from "./core";
export * from "./crypto";
export * from "./keychain";
export * from "./messages";
export * from "./publisher";
export * from "./relayer";
export * from "./store";
export * from "./subscriber";
export * from "./pairing";
export * from "./history";
export * from "./expirer";
export * from "./verify";
export * from "./echo";
export * from "./events";
</file>

<file path="packages/core/src/constants/keychain.ts">
export const KEYCHAIN_CONTEXT = "keychain";

export const KEYCHAIN_STORAGE_VERSION = "0.3";
</file>

<file path="packages/core/src/constants/messages.ts">
export const MESSAGES_CONTEXT = "messages";

export const MESSAGES_STORAGE_VERSION = "0.3";
</file>

<file path="packages/core/src/constants/pairing.ts">
import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from "@walletconnect/time";
import { RelayerTypes, PairingJsonRpcTypes } from "@walletconnect/types";

export const PAIRING_CONTEXT = "pairing";

export const PAIRING_STORAGE_VERSION = "0.3";

export const PAIRING_DEFAULT_TTL = THIRTY_DAYS;

export const PAIRING_RPC_OPTS: Record<
  PairingJsonRpcTypes.WcMethod | "unregistered_method",
  {
    req: RelayerTypes.PublishOptions;
    res: RelayerTypes.PublishOptions;
  }
> = {
  wc_pairingDelete: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1000,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1001,
    },
  },
  wc_pairingPing: {
    req: {
      ttl: THIRTY_SECONDS,
      prompt: false,
      tag: 1002,
    },
    res: {
      ttl: THIRTY_SECONDS,
      prompt: false,
      tag: 1003,
    },
  },
  unregistered_method: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 0,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 0,
    },
  },
};

export const PAIRING_EVENTS = {
  create: "pairing_create",
  expire: "pairing_expire",
  delete: "pairing_delete",
  ping: "pairing_ping",
};
</file>

<file path="packages/core/src/constants/publisher.ts">
import { SIX_HOURS } from "@walletconnect/time";

export const PUBLISHER_DEFAULT_TTL = SIX_HOURS;

export const PUBLISHER_CONTEXT = "publisher";
</file>

<file path="packages/core/src/constants/relayer.ts">
export const RELAYER_DEFAULT_PROTOCOL = "irn";

export const RELAYER_DEFAULT_LOGGER = "error";

export const RELAYER_DEFAULT_RELAY_URL = "wss://relay.walletconnect.org";

export const RELAYER_CONTEXT = "relayer";

export const RELAYER_EVENTS = {
  message: "relayer_message",
  message_ack: "relayer_message_ack",
  connect: "relayer_connect",
  disconnect: "relayer_disconnect",
  error: "relayer_error",
  connection_stalled: "relayer_connection_stalled",
  transport_closed: "relayer_transport_closed",
  publish: "relayer_publish",
};

export const RELAYER_SUBSCRIBER_SUFFIX = "_subscription";

export const RELAYER_PROVIDER_EVENTS = {
  payload: "payload",
  connect: "connect",
  disconnect: "disconnect",
  error: "error",
};

export const RELAYER_RECONNECT_TIMEOUT = 0.1;

export const RELAYER_STORAGE_OPTIONS = {
  database: ":memory:",
};

// Updated automatically via `new-version` npm script.

export const RELAYER_SDK_VERSION = "2.19.2";

// delay to wait before closing the transport connection after init if not active
export const RELAYER_TRANSPORT_CUTOFF = 10_000;

export const TRANSPORT_TYPES = {
  link_mode: "link_mode",
  relay: "relay",
} as const;

export const MESSAGE_DIRECTION = {
  inbound: "inbound",
  outbound: "outbound",
} as const;
</file>

<file path="packages/core/src/constants/store.ts">
export const STORE_STORAGE_VERSION = "0.3";

export const WALLETCONNECT_CLIENT_ID = "WALLETCONNECT_CLIENT_ID";
export const WALLETCONNECT_LINK_MODE_APPS = "WALLETCONNECT_LINK_MODE_APPS";
</file>

<file path="packages/core/src/constants/subscriber.ts">
import { THIRTY_DAYS, FIVE_SECONDS } from "@walletconnect/time";

export const SUBSCRIBER_EVENTS = {
  created: "subscription_created",
  deleted: "subscription_deleted",
  expired: "subscription_expired",
  disabled: "subscription_disabled",
  sync: "subscription_sync",
  resubscribed: "subscription_resubscribed",
};

export const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;

export const SUBSCRIBER_CONTEXT = "subscription";

export const SUBSCRIBER_STORAGE_VERSION = "0.3";

export const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;
</file>

<file path="packages/core/src/constants/verify.ts">
export const VERIFY_CONTEXT = "verify-api";

const VERIFY_SERVER_COM = "https://verify.walletconnect.com";
const VERIFY_SERVER_ORG = "https://verify.walletconnect.org";
export const VERIFY_SERVER = VERIFY_SERVER_ORG;
export const VERIFY_SERVER_V3 = `${VERIFY_SERVER}/v3`;

export const TRUSTED_VERIFY_URLS = [VERIFY_SERVER_COM, VERIFY_SERVER_ORG];
</file>

<file path="packages/core/src/controllers/crypto.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { safeJsonParse, safeJsonStringify } from "@walletconnect/safe-json";
import { ICore, ICrypto, IKeyChain } from "@walletconnect/types";
import * as relayAuth from "@walletconnect/relay-auth";
import { fromString } from "uint8arrays/from-string";
import {
  decrypt,
  deriveSymKey,
  encrypt,
  generateKeyPair as generateKeyPairUtil,
  hashKey,
  getInternalError,
  generateRandomBytes32,
  validateEncoding,
  validateDecoding,
  isTypeOneEnvelope,
  isTypeTwoEnvelope,
  encodeTypeTwoEnvelope,
  decodeTypeTwoEnvelope,
  deserialize,
  decodeTypeByte,
  BASE16,
  BASE64,
} from "@walletconnect/utils";
import { toString } from "uint8arrays";

import { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from "../constants";
import { KeyChain } from "./keychain";

export class Crypto implements ICrypto {
  public name = CRYPTO_CONTEXT;
  public keychain: ICrypto["keychain"];
  public readonly randomSessionIdentifier = generateRandomBytes32();

  private initialized = false;

  constructor(
    public core: ICore,
    public logger: Logger,
    keychain?: IKeyChain,
  ) {
    this.core = core;
    this.logger = generateChildLogger(logger, this.name);
    this.keychain = keychain || new KeyChain(this.core, this.logger);
  }

  public init: ICrypto["init"] = async () => {
    if (!this.initialized) {
      await this.keychain.init();
      this.initialized = true;
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  public hasKeys: ICrypto["hasKeys"] = (tag) => {
    this.isInitialized();
    return this.keychain.has(tag);
  };

  public getClientId: ICrypto["getClientId"] = async () => {
    this.isInitialized();
    const seed = await this.getClientSeed();
    const keyPair = relayAuth.generateKeyPair(seed);
    const clientId = relayAuth.encodeIss(keyPair.publicKey);
    return clientId;
  };

  public generateKeyPair: ICrypto["generateKeyPair"] = () => {
    this.isInitialized();
    const keyPair = generateKeyPairUtil();
    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);
  };

  public signJWT: ICrypto["signJWT"] = async (aud) => {
    this.isInitialized();
    const seed = await this.getClientSeed();
    const keyPair = relayAuth.generateKeyPair(seed);
    const sub = this.randomSessionIdentifier;
    const ttl = CRYPTO_JWT_TTL;
    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);
    return jwt;
  };

  public generateSharedKey: ICrypto["generateSharedKey"] = (
    selfPublicKey,
    peerPublicKey,
    overrideTopic,
  ) => {
    this.isInitialized();
    const selfPrivateKey = this.getPrivateKey(selfPublicKey);
    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);
    return this.setSymKey(symKey, overrideTopic);
  };

  public setSymKey: ICrypto["setSymKey"] = async (symKey, overrideTopic) => {
    this.isInitialized();
    const topic = overrideTopic || hashKey(symKey);
    await this.keychain.set(topic, symKey);
    return topic;
  };

  public deleteKeyPair: ICrypto["deleteKeyPair"] = async (publicKey: string) => {
    this.isInitialized();
    await this.keychain.del(publicKey);
  };

  public deleteSymKey: ICrypto["deleteSymKey"] = async (topic: string) => {
    this.isInitialized();
    await this.keychain.del(topic);
  };

  public encode: ICrypto["encode"] = async (topic, payload, opts) => {
    this.isInitialized();
    const params = validateEncoding(opts);
    const message = safeJsonStringify(payload);

    if (isTypeTwoEnvelope(params)) {
      return encodeTypeTwoEnvelope(message, opts?.encoding);
    }

    if (isTypeOneEnvelope(params)) {
      const selfPublicKey = params.senderPublicKey;
      const peerPublicKey = params.receiverPublicKey;
      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);
    }
    const symKey = this.getSymKey(topic);
    const { type, senderPublicKey } = params;
    const result = encrypt({ type, symKey, message, senderPublicKey, encoding: opts?.encoding });
    return result;
  };

  public decode: ICrypto["decode"] = async (topic, encoded, opts) => {
    this.isInitialized();
    const params = validateDecoding(encoded, opts);
    if (isTypeTwoEnvelope(params)) {
      const message = decodeTypeTwoEnvelope(encoded, opts?.encoding);
      return safeJsonParse(message);
    }
    if (isTypeOneEnvelope(params)) {
      const selfPublicKey = params.receiverPublicKey;
      const peerPublicKey = params.senderPublicKey;
      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);
    }
    try {
      const symKey = this.getSymKey(topic);
      const message = decrypt({ symKey, encoded, encoding: opts?.encoding });
      const payload = safeJsonParse(message);
      return payload;
    } catch (error) {
      this.logger.error(
        `Failed to decode message from topic: '${topic}', clientId: '${await this.getClientId()}'`,
      );
      this.logger.error(error);
    }
  };

  public getPayloadType: ICrypto["getPayloadType"] = (encoded, encoding = BASE64) => {
    const deserialized = deserialize({ encoded, encoding });
    return decodeTypeByte(deserialized.type);
  };

  public getPayloadSenderPublicKey: ICrypto["getPayloadSenderPublicKey"] = (
    encoded,
    encoding = BASE64,
  ) => {
    const deserialized = deserialize({ encoded, encoding });
    return deserialized.senderPublicKey
      ? toString(deserialized.senderPublicKey, BASE16)
      : undefined;
  };

  // ---------- Private ----------------------------------------------- //

  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {
    await this.keychain.set(publicKey, privateKey);
    return publicKey;
  }

  private getPrivateKey(publicKey: string) {
    const privateKey = this.keychain.get(publicKey);
    return privateKey;
  }

  private async getClientSeed(): Promise<Uint8Array> {
    let seed = "";
    try {
      seed = this.keychain.get(CRYPTO_CLIENT_SEED);
    } catch {
      seed = generateRandomBytes32();
      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);
    }
    return fromString(seed, "base16");
  }

  private getSymKey(topic: string) {
    const symKey = this.keychain.get(topic);
    return symKey;
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/echo.ts">
import { generateChildLogger, Logger } from "@walletconnect/logger";
import { IEchoClient } from "@walletconnect/types";
import { ECHO_CONTEXT, ECHO_URL } from "../constants";

export class EchoClient extends IEchoClient {
  public readonly context = ECHO_CONTEXT;
  constructor(
    public projectId: string,
    public logger: Logger,
  ) {
    super(projectId, logger);
    this.logger = generateChildLogger(logger, this.context);
  }

  public registerDeviceToken: IEchoClient["registerDeviceToken"] = async (params) => {
    const { clientId, token, notificationType, enableEncrypted = false } = params;

    const echoUrl = `${ECHO_URL}/${this.projectId}/clients`;

    await fetch(echoUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        client_id: clientId,
        type: notificationType,
        token,
        always_raw: enableEncrypted,
      }),
    });
  };
}
</file>

<file path="packages/core/src/controllers/events.ts">
import { generateChildLogger, Logger } from "@walletconnect/logger";
import { ICore, IEventClient, EventClientTypes } from "@walletconnect/types";
import { formatUA, isTestRun, uuidv4, getAppMetadata } from "@walletconnect/utils";
import {
  CORE_STORAGE_PREFIX,
  EVENTS_CLIENT_API_URL,
  EVENTS_STORAGE_CLEANUP_INTERVAL,
  EVENTS_STORAGE_CONTEXT,
  EVENTS_STORAGE_VERSION,
  RELAYER_SDK_VERSION,
} from "../constants";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { fromMiliseconds } from "@walletconnect/time";

export class EventClient extends IEventClient {
  public readonly context = EVENTS_STORAGE_CONTEXT;
  private readonly storagePrefix = CORE_STORAGE_PREFIX;
  private readonly storageVersion = EVENTS_STORAGE_VERSION;
  private events = new Map<string, EventClientTypes.Event>();
  private shouldPersist = false;
  constructor(
    public core: ICore,
    public logger: Logger,
    telemetryEnabled = true,
  ) {
    super(core, logger, telemetryEnabled);
    this.logger = generateChildLogger(logger, this.context);
    this.telemetryEnabled = telemetryEnabled;
    if (telemetryEnabled) {
      this.restore().then(async () => {
        await this.submit();
        this.setEventListeners();
      });
    } else {
      // overwrite any persisted events with an empty array
      this.persist();
    }
  }

  get storageKey() {
    return (
      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
    );
  }

  public init: IEventClient["init"] = async () => {
    if (isTestRun()) return;
    try {
      const initEvent = {
        eventId: uuidv4(),
        timestamp: Date.now(),
        domain: this.getAppDomain(),
        props: {
          event: "INIT",
          type: "",
          properties: {
            client_id: await this.core.crypto.getClientId(),
            user_agent: formatUA(
              this.core.relayer.protocol,
              this.core.relayer.version,
              RELAYER_SDK_VERSION,
            ),
          },
        },
      };
      await this.sendEvent([initEvent] as unknown as EventClientTypes.Event[]);
    } catch (error) {
      this.logger.warn(error);
    }
  };

  public createEvent: IEventClient["createEvent"] = (params) => {
    const {
      event = "ERROR",
      type = "",
      properties: { topic, trace },
    } = params;
    const eventId = uuidv4();
    const bundleId = this.core.projectId || "";
    const timestamp = Date.now();
    const props = {
      event,
      type,
      properties: {
        topic,
        trace,
      },
    };
    const eventObj = {
      eventId,
      timestamp,
      props,
      bundleId,
      domain: this.getAppDomain(),
      ...this.setMethods(eventId),
    };
    if (this.telemetryEnabled) {
      this.events.set(eventId, eventObj);
      this.shouldPersist = true;
    }

    return eventObj;
  };

  public getEvent: IEventClient["getEvent"] = (params) => {
    const { eventId, topic } = params;
    if (eventId) {
      return this.events.get(eventId);
    }
    const event = Array.from(this.events.values()).find(
      (event) => event.props.properties.topic === topic,
    );

    if (!event) return;

    return {
      ...event,
      ...this.setMethods(event.eventId),
    };
  };

  public deleteEvent: IEventClient["deleteEvent"] = (params) => {
    const { eventId } = params;
    this.events.delete(eventId);
    this.shouldPersist = true;
  };

  private setEventListeners = () => {
    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {
      if (this.shouldPersist) await this.persist();
      // cleanup events older than EVENTS_STORAGE_CLEANUP_INTERVAL
      this.events.forEach((event) => {
        if (
          fromMiliseconds(Date.now()) - fromMiliseconds(event.timestamp) >
          EVENTS_STORAGE_CLEANUP_INTERVAL
        ) {
          this.events.delete(event.eventId);
          this.shouldPersist = true;
        }
      });
    });
  };

  private setMethods = (eventId: string) => {
    return {
      addTrace: (trace: string) => this.addTrace(eventId, trace),
      setError: (errorType: string) => this.setError(eventId, errorType),
    };
  };

  private addTrace = (eventId: string, trace: string) => {
    const event = this.events.get(eventId);
    if (!event) return;
    event.props.properties.trace.push(trace);
    this.events.set(eventId, event);
    this.shouldPersist = true;
  };

  private setError = (eventId: string, errorType: string) => {
    const event = this.events.get(eventId);
    if (!event) return;
    event.props.type = errorType;
    event.timestamp = Date.now();
    this.events.set(eventId, event);
    this.shouldPersist = true;
  };

  private persist = async () => {
    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values()));
    this.shouldPersist = false;
  };

  private restore = async () => {
    try {
      const events =
        (await this.core.storage.getItem<EventClientTypes.Event[]>(this.storageKey)) || [];
      if (!events.length) return;
      events.forEach((event) => {
        this.events.set(event.eventId, {
          ...event,
          ...this.setMethods(event.eventId),
        });
      });
    } catch (error) {
      this.logger.warn(error);
    }
  };

  private submit = async () => {
    if (!this.telemetryEnabled) return;

    if (this.events.size === 0) return;

    const eventsToSend: EventClientTypes.Event[] = [];
    // exclude events without type as they can be considered `in progress`
    for (const [_, event] of this.events) {
      if (event.props.type) {
        eventsToSend.push(event);
      }
    }

    if (eventsToSend.length === 0) return;

    try {
      const response = await this.sendEvent(eventsToSend);
      if (response.ok) {
        for (const event of eventsToSend) {
          this.events.delete(event.eventId);
          this.shouldPersist = true;
        }
      }
    } catch (error) {
      this.logger.warn(error);
    }
  };

  private sendEvent = async (events: EventClientTypes.Event[]) => {
    // if domain isn't available, set `sp` as `desktop` so data would be extracted on api side
    const platform = this.getAppDomain() ? "" : "&sp=desktop";
    const response = await fetch(
      `${EVENTS_CLIENT_API_URL}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${RELAYER_SDK_VERSION}${platform}`,
      {
        method: "POST",
        body: JSON.stringify(events),
      },
    );
    return response;
  };

  private getAppDomain = () => {
    return getAppMetadata().url;
  };
}
</file>

<file path="packages/core/src/controllers/expirer.ts">
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { toMiliseconds } from "@walletconnect/time";
import { ExpirerTypes, ICore, IExpirer } from "@walletconnect/types";
import { getInternalError, formatIdTarget, formatTopicTarget } from "@walletconnect/utils";
import { EventEmitter } from "events";
import {
  CORE_STORAGE_PREFIX,
  EXPIRER_CONTEXT,
  EXPIRER_EVENTS,
  EXPIRER_STORAGE_VERSION,
} from "../constants";

export class Expirer extends IExpirer {
  public expirations = new Map<string, ExpirerTypes.Expiration>();
  public events = new EventEmitter();
  public name = EXPIRER_CONTEXT;
  public version = EXPIRER_STORAGE_VERSION;

  private cached: ExpirerTypes.Expiration[] = [];
  private initialized = false;

  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger);
    this.logger = generateChildLogger(logger, this.name);
  }

  public init: IExpirer["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      await this.restore();
      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));
      this.cached = [];
      this.registerEventListeners();
      this.initialized = true;
    }
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get length(): number {
    return this.expirations.size;
  }

  get keys(): string[] {
    return Array.from(this.expirations.keys());
  }

  get values(): ExpirerTypes.Expiration[] {
    return Array.from(this.expirations.values());
  }

  public has: IExpirer["has"] = (key) => {
    try {
      const target = this.formatTarget(key);
      const expiration = this.getExpiration(target);
      return typeof expiration !== "undefined";
    } catch (e) {
      // ignore
      return false;
    }
  };

  public set: IExpirer["set"] = (key, expiry) => {
    this.isInitialized();
    const target = this.formatTarget(key);
    const expiration = { target, expiry };
    this.expirations.set(target, expiration);
    this.checkExpiry(target, expiration);
    this.events.emit(EXPIRER_EVENTS.created, {
      target,
      expiration,
    } as ExpirerTypes.Created);
  };

  public get: IExpirer["get"] = (key) => {
    this.isInitialized();
    const target = this.formatTarget(key);
    return this.getExpiration(target);
  };

  public del: IExpirer["del"] = (key) => {
    this.isInitialized();
    const exists = this.has(key);
    if (exists) {
      const target = this.formatTarget(key);
      const expiration = this.getExpiration(target);
      this.expirations.delete(target);
      this.events.emit(EXPIRER_EVENTS.deleted, {
        target,
        expiration,
      } as ExpirerTypes.Deleted);
    }
  };

  public on: IExpirer["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: IExpirer["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: IExpirer["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: IExpirer["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  // ---------- Private ----------------------------------------------- //

  private formatTarget(key: string | number) {
    if (typeof key === "string") {
      return formatTopicTarget(key);
    } else if (typeof key === "number") {
      return formatIdTarget(key);
    }
    const { message } = getInternalError("UNKNOWN_TYPE", `Target type: ${typeof key}`);
    throw new Error(message);
  }

  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {
    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);
  }

  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {
    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);
    return expirations;
  }

  private async persist() {
    await this.setExpirations(this.values);
    this.events.emit(EXPIRER_EVENTS.sync);
  }

  private async restore() {
    try {
      const persisted = await this.getExpirations();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.expirations.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored expirations for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private getExpiration(target: string): ExpirerTypes.Expiration {
    const expiration = this.expirations.get(target);
    if (!expiration) {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${target}`);
      this.logger.warn(message);
      throw new Error(message);
    }
    return expiration;
  }

  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {
    const { expiry } = expiration;
    const msToTimeout = toMiliseconds(expiry) - Date.now();
    if (msToTimeout <= 0) this.expire(target, expiration);
  }

  private expire(target: string, expiration: ExpirerTypes.Expiration): void {
    this.expirations.delete(target);
    this.events.emit(EXPIRER_EVENTS.expired, {
      target,
      expiration,
    } as ExpirerTypes.Expired);
  }

  private checkExpirations(): void {
    // avoid auto expiring if the relayer is not connected
    if (!this.core.relayer.connected) return;
    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));
  }

  private registerEventListeners(): void {
    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());
    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {
      const eventName = EXPIRER_EVENTS.created;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: createdEvent });
      this.persist();
    });
    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {
      const eventName = EXPIRER_EVENTS.expired;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
      this.persist();
    });
    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {
      const eventName = EXPIRER_EVENTS.deleted;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
      this.persist();
    });
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/history.ts">
import { formatJsonRpcRequest, isJsonRpcError } from "@walletconnect/jsonrpc-utils";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from "@walletconnect/types";
import { calcExpiry, getInternalError } from "@walletconnect/utils";
import { EventEmitter } from "events";
import { THIRTY_DAYS, toMiliseconds } from "@walletconnect/time";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import {
  CORE_STORAGE_PREFIX,
  HISTORY_CONTEXT,
  HISTORY_EVENTS,
  HISTORY_STORAGE_VERSION,
} from "../constants";

export class JsonRpcHistory extends IJsonRpcHistory {
  public records = new Map<number, JsonRpcRecord>();
  public events = new EventEmitter();
  public name = HISTORY_CONTEXT;
  public version = HISTORY_STORAGE_VERSION;

  private cached: JsonRpcRecord[] = [];
  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger);
    this.logger = generateChildLogger(logger, this.name);
  }

  public init: IJsonRpcHistory["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      await this.restore();
      this.cached.forEach((record) => this.records.set(record.id, record));
      this.cached = [];
      this.registerEventListeners();
      this.initialized = true;
    }
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get size(): number {
    return this.records.size;
  }

  get keys(): number[] {
    return Array.from(this.records.keys());
  }

  get values() {
    return Array.from(this.records.values());
  }

  get pending(): RequestEvent[] {
    const requests: RequestEvent[] = [];
    this.values.forEach((record) => {
      if (typeof record.response !== "undefined") return;
      const requestEvent: RequestEvent = {
        topic: record.topic,
        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),
        chainId: record.chainId,
      };
      return requests.push(requestEvent);
    });
    return requests;
  }

  public set: IJsonRpcHistory["set"] = (topic, request, chainId) => {
    this.isInitialized();
    this.logger.debug(`Setting JSON-RPC request history record`);
    this.logger.trace({ type: "method", method: "set", topic, request, chainId });
    if (this.records.has(request.id)) return;
    const record: JsonRpcRecord = {
      id: request.id,
      topic,
      request: { method: request.method, params: request.params || null },
      chainId,
      expiry: calcExpiry(THIRTY_DAYS),
    };
    this.records.set(record.id, record);
    this.persist();
    this.events.emit(HISTORY_EVENTS.created, record);
  };

  public resolve: IJsonRpcHistory["resolve"] = async (response) => {
    this.isInitialized();
    this.logger.debug(`Updating JSON-RPC response history record`);
    this.logger.trace({ type: "method", method: "update", response });
    if (!this.records.has(response.id)) return;
    const record = await this.getRecord(response.id);
    if (typeof record.response !== "undefined") return;
    record.response = isJsonRpcError(response)
      ? { error: response.error }
      : { result: response.result };
    this.records.set(record.id, record);
    this.persist();
    this.events.emit(HISTORY_EVENTS.updated, record);
  };

  public get: IJsonRpcHistory["get"] = async (topic, id) => {
    this.isInitialized();
    this.logger.debug(`Getting record`);
    this.logger.trace({ type: "method", method: "get", topic, id });
    const record = await this.getRecord(id);
    return record;
  };

  public delete: IJsonRpcHistory["delete"] = (topic, id) => {
    this.isInitialized();
    this.logger.debug(`Deleting record`);
    this.logger.trace({ type: "method", method: "delete", id });
    this.values.forEach((record: JsonRpcRecord) => {
      if (record.topic === topic) {
        if (typeof id !== "undefined" && record.id !== id) return;
        this.records.delete(record.id);
        this.events.emit(HISTORY_EVENTS.deleted, record);
      }
    });
    this.persist();
  };

  public exists: IJsonRpcHistory["exists"] = async (topic, id) => {
    this.isInitialized();
    if (!this.records.has(id)) return false;
    const record = await this.getRecord(id);
    return record.topic === topic;
  };

  public on: IJsonRpcHistory["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: IJsonRpcHistory["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: IJsonRpcHistory["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: IJsonRpcHistory["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  // ---------- Private ----------------------------------------------- //

  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {
    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);
  }

  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {
    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);
    return records;
  }

  private getRecord(id: number) {
    this.isInitialized();
    const record = this.records.get(id);
    if (!record) {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${id}`);
      throw new Error(message);
    }
    return record;
  }

  private async persist() {
    await this.setJsonRpcRecords(this.values);
    this.events.emit(HISTORY_EVENTS.sync);
  }

  private async restore() {
    try {
      const persisted = await this.getJsonRpcRecords();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.records.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored records for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private registerEventListeners(): void {
    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {
      const eventName = HISTORY_EVENTS.created;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, record });
    });
    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {
      const eventName = HISTORY_EVENTS.updated;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, record });
    });

    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {
      const eventName = HISTORY_EVENTS.deleted;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, record });
    });

    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }

  private cleanup() {
    try {
      this.isInitialized();
      let deleted = false;
      this.records.forEach((record: JsonRpcRecord) => {
        const msToExpiry = toMiliseconds(record.expiry || 0) - Date.now();
        if (msToExpiry <= 0) {
          this.logger.info(`Deleting expired history log: ${record.id}`);
          this.records.delete(record.id);
          this.events.emit(HISTORY_EVENTS.deleted, record, false);
          deleted = true;
        }
      });
      if (deleted) {
        this.persist();
      }
    } catch (e) {
      this.logger.warn(e);
    }
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/index.ts">
export * from "./crypto";
export * from "./messages";
export * from "./relayer";
export * from "./store";
export * from "./subscriber";
export * from "./keychain";
export * from "./pairing";
export * from "./history";
export * from "./expirer";
export * from "./verify";
export * from "./echo";
export * from "./events";
</file>

<file path="packages/core/src/controllers/keychain.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IKeyChain } from "@walletconnect/types";
import { getInternalError, mapToObj, objToMap } from "@walletconnect/utils";

import { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from "../constants";

export class KeyChain implements IKeyChain {
  public keychain = new Map<string, string>();
  public name = KEYCHAIN_CONTEXT;
  public version = KEYCHAIN_STORAGE_VERSION;

  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    this.core = core;
    this.logger = generateChildLogger(logger, this.name);
  }

  public init: IKeyChain["init"] = async () => {
    if (!this.initialized) {
      const keychain = await this.getKeyChain();
      if (typeof keychain !== "undefined") {
        this.keychain = keychain;
      }
      this.initialized = true;
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  public has: IKeyChain["has"] = (tag) => {
    this.isInitialized();
    return this.keychain.has(tag);
  };

  public set: IKeyChain["set"] = async (tag, key) => {
    this.isInitialized();
    this.keychain.set(tag, key);
    await this.persist();
  };

  public get: IKeyChain["get"] = (tag) => {
    this.isInitialized();
    const key = this.keychain.get(tag);
    if (typeof key === "undefined") {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${tag}`);
      throw new Error(message);
    }
    return key;
  };

  public del: IKeyChain["del"] = async (tag) => {
    this.isInitialized();
    this.keychain.delete(tag);
    await this.persist();
  };

  // ---------- Private ----------------------------------------------- //

  private async setKeyChain(keychain: Map<string, string>) {
    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));
  }

  private async getKeyChain() {
    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);
    return typeof keychain !== "undefined" ? objToMap(keychain) : undefined;
  }

  private async persist() {
    await this.setKeyChain(this.keychain);
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/messages.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IMessageTracker, MessageRecord } from "@walletconnect/types";
import { hashMessage, mapToObj, objToMap, getInternalError } from "@walletconnect/utils";
import {
  CORE_STORAGE_PREFIX,
  MESSAGE_DIRECTION,
  MESSAGES_CONTEXT,
  MESSAGES_STORAGE_VERSION,
} from "../constants";

export class MessageTracker extends IMessageTracker {
  public messages = new Map<string, MessageRecord>();
  /**
   * stores messages that have not been acknowledged by the implementing client
   * this is used to prevent losing messages in race conditions such as
   * when a message is received by the relayer before the implementing client is ready to receive it
   */
  public messagesWithoutClientAck = new Map<string, MessageRecord>();
  public name = MESSAGES_CONTEXT;
  public version = MESSAGES_STORAGE_VERSION;

  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;

  constructor(
    public logger: Logger,
    public core: ICore,
  ) {
    super(logger, core);
    this.logger = generateChildLogger(logger, this.name);
    this.core = core;
  }

  public init: IMessageTracker["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      try {
        const messages = await this.getRelayerMessages();
        if (typeof messages !== "undefined") {
          this.messages = messages;
        }
        const messagesWithoutClientAck = await this.getRelayerMessagesWithoutClientAck();
        if (typeof messagesWithoutClientAck !== "undefined") {
          this.messagesWithoutClientAck = messagesWithoutClientAck;
        }
        this.logger.debug(`Successfully Restored records for ${this.name}`);
        this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
      } catch (e) {
        this.logger.debug(`Failed to Restore records for ${this.name}`);
        this.logger.error(e as any);
      } finally {
        this.initialized = true;
      }
    }
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get storageKeyWithoutClientAck() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name +
      "_withoutClientAck"
    );
  }

  public set: IMessageTracker["set"] = async (topic, message, direction) => {
    this.isInitialized();
    const hash = hashMessage(message);
    let messages = this.messages.get(topic);
    if (typeof messages === "undefined") {
      messages = {};
    }
    if (typeof messages[hash] !== "undefined") {
      return hash;
    }
    messages[hash] = message;
    this.messages.set(topic, messages);
    // Only store messages without client ack for inbound messages
    if (direction === MESSAGE_DIRECTION.inbound) {
      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};
      this.messagesWithoutClientAck.set(topic, {
        ...messagesWithoutClientAck,
        [hash]: message,
      });
    }

    await this.persist();
    return hash;
  };

  public get: IMessageTracker["get"] = (topic) => {
    this.isInitialized();
    let messages = this.messages.get(topic);
    if (typeof messages === "undefined") {
      messages = {};
    }
    return messages;
  };

  public getWithoutAck: IMessageTracker["getWithoutAck"] = (topics) => {
    this.isInitialized();
    const messages: Record<string, string[]> = {};
    for (const topic of topics) {
      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};
      messages[topic] = Object.values(messagesWithoutClientAck);
    }
    return messages;
  };

  public has: IMessageTracker["has"] = (topic, message) => {
    this.isInitialized();
    const messages = this.get(topic);
    const hash = hashMessage(message);
    return typeof messages[hash] !== "undefined";
  };

  public ack: IMessageTracker["ack"] = async (topic, message) => {
    this.isInitialized();
    const messages = this.messagesWithoutClientAck.get(topic);
    if (typeof messages === "undefined") {
      return;
    }

    const hash = hashMessage(message);

    delete messages[hash];
    if (Object.keys(messages).length === 0) {
      this.messagesWithoutClientAck.delete(topic);
    } else {
      this.messagesWithoutClientAck.set(topic, messages);
    }
    await this.persist();
  };

  public del: IMessageTracker["del"] = async (topic) => {
    this.isInitialized();
    this.messages.delete(topic);
    this.messagesWithoutClientAck.delete(topic);
    await this.persist();
  };

  // ---------- Private ----------------------------------------------- //

  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {
    await this.core.storage.setItem<Record<string, MessageRecord>>(
      this.storageKey,
      mapToObj(messages),
    );
  }

  private async setRelayerMessagesWithoutClientAck(
    messages: Map<string, MessageRecord>,
  ): Promise<void> {
    await this.core.storage.setItem<Record<string, MessageRecord>>(
      this.storageKeyWithoutClientAck,
      mapToObj(messages),
    );
  }

  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {
    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(
      this.storageKey,
    );
    return typeof messages !== "undefined" ? objToMap(messages) : undefined;
  }

  private async getRelayerMessagesWithoutClientAck(): Promise<
    Map<string, MessageRecord> | undefined
  > {
    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(
      this.storageKeyWithoutClientAck,
    );
    return typeof messages !== "undefined" ? objToMap(messages) : undefined;
  }

  private async persist() {
    await this.setRelayerMessages(this.messages);
    await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/pairing.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import {
  ICore,
  PairingTypes,
  IPairing,
  IPairingPrivate,
  IStore,
  RelayerTypes,
  PairingJsonRpcTypes,
  ExpirerTypes,
  EventClientTypes,
} from "@walletconnect/types";
import {
  getInternalError,
  parseUri,
  calcExpiry,
  generateRandomBytes32,
  formatUri,
  getSdkError,
  engineEvent,
  createDelayedPromise,
  isValidParams,
  isValidUrl,
  isValidString,
  isExpired,
  parseExpirerTarget,
  TYPE_1,
} from "@walletconnect/utils";
import {
  formatJsonRpcRequest,
  formatJsonRpcResult,
  formatJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isJsonRpcError,
} from "@walletconnect/jsonrpc-utils";
import { FIVE_MINUTES, toMiliseconds } from "@walletconnect/time";
import EventEmitter from "events";
import {
  PAIRING_CONTEXT,
  PAIRING_STORAGE_VERSION,
  CORE_STORAGE_PREFIX,
  RELAYER_DEFAULT_PROTOCOL,
  PAIRING_RPC_OPTS,
  RELAYER_EVENTS,
  EXPIRER_EVENTS,
  PAIRING_EVENTS,
  EVENT_CLIENT_PAIRING_TRACES,
  EVENT_CLIENT_PAIRING_ERRORS,
  TRANSPORT_TYPES,
} from "../constants";
import { Store } from "../controllers/store";

export class Pairing implements IPairing {
  public name = PAIRING_CONTEXT;
  public version = PAIRING_STORAGE_VERSION;

  public events = new EventEmitter();
  public pairings: IStore<string, PairingTypes.Struct>;

  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;
  private ignoredPayloadTypes = [TYPE_1];
  private registeredMethods: string[] = [];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    this.core = core;
    this.logger = generateChildLogger(logger, this.name);
    this.pairings = new Store(this.core, this.logger, this.name, this.storagePrefix);
  }

  public init: IPairing["init"] = async () => {
    if (!this.initialized) {
      await this.pairings.init();
      await this.cleanup();
      this.registerRelayerEvents();
      this.registerExpirerEvents();
      this.initialized = true;
      this.logger.trace(`Initialized`);
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  public register: IPairing["register"] = ({ methods }) => {
    this.isInitialized();
    this.registeredMethods = [...new Set([...this.registeredMethods, ...methods])];
  };

  public create: IPairing["create"] = async (params) => {
    this.isInitialized();
    const symKey = generateRandomBytes32();
    const topic = await this.core.crypto.setSymKey(symKey);
    const expiry = calcExpiry(FIVE_MINUTES);
    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };
    const pairing = { topic, expiry, relay, active: false, methods: params?.methods };
    const uri = formatUri({
      protocol: this.core.protocol,
      version: this.core.version,
      topic,
      symKey,
      relay,
      expiryTimestamp: expiry,
      methods: params?.methods,
    });
    this.events.emit(PAIRING_EVENTS.create, pairing);
    this.core.expirer.set(topic, expiry);
    await this.pairings.set(topic, pairing);
    await this.core.relayer.subscribe(topic, { transportType: params?.transportType });

    return { topic, uri };
  };

  public pair: IPairing["pair"] = async (params) => {
    this.isInitialized();

    const event = this.core.eventClient.createEvent({
      properties: {
        topic: params?.uri,
        trace: [EVENT_CLIENT_PAIRING_TRACES.pairing_started],
      },
    });

    this.isValidPair(params, event);

    const { topic, symKey, relay, expiryTimestamp, methods } = parseUri(params.uri);

    event.props.properties.topic = topic;
    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_validation_success);
    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_not_expired);

    let existingPairing;
    if (this.pairings.keys.includes(topic)) {
      existingPairing = this.pairings.get(topic);
      event.addTrace(EVENT_CLIENT_PAIRING_TRACES.existing_pairing);
      if (existingPairing.active) {
        event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
        throw new Error(
          `Pairing already exists: ${topic}. Please try again with a new connection URI.`,
        );
      } else {
        event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_not_expired);
      }
    }

    const expiry = expiryTimestamp || calcExpiry(FIVE_MINUTES);
    const pairing = { topic, relay, expiry, active: false, methods };
    this.core.expirer.set(topic, expiry);
    await this.pairings.set(topic, pairing);

    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.store_new_pairing);

    if (params.activatePairing) {
      await this.activate({ topic });
    }

    this.events.emit(PAIRING_EVENTS.create, pairing);

    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_inactive_pairing);

    // avoid overwriting keychain pairing already exists
    if (!this.core.crypto.keychain.has(topic)) {
      await this.core.crypto.setSymKey(symKey, topic);
    }
    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribing_pairing_topic);

    try {
      await this.core.relayer.confirmOnlineStateOrThrow();
    } catch (error) {
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.no_internet_connection);
    }

    try {
      await this.core.relayer.subscribe(topic, { relay });
    } catch (error) {
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.subscribe_pairing_topic_failure);
      throw error;
    }

    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribe_pairing_topic_success);

    return pairing;
  };

  public activate: IPairing["activate"] = async ({ topic }) => {
    this.isInitialized();
    const expiry = calcExpiry(FIVE_MINUTES);
    this.core.expirer.set(topic, expiry);
    await this.pairings.update(topic, { active: true, expiry });
  };

  /**
   * @deprecated Ping will be removed in the next major release.
   */
  public ping: IPairing["ping"] = async (params) => {
    this.isInitialized();
    await this.isValidPing(params);
    this.logger.warn("ping() is deprecated and will be removed in the next major release.");
    const { topic } = params;
    if (this.pairings.keys.includes(topic)) {
      const id = await this.sendRequest(topic, "wc_pairingPing", {});
      const { done, resolve, reject } = createDelayedPromise<void>();
      this.events.once(engineEvent("pairing_ping", id), ({ error }) => {
        if (error) reject(error);
        else resolve();
      });
      await done();
    }
  };

  public updateExpiry: IPairing["updateExpiry"] = async ({ topic, expiry }) => {
    this.isInitialized();
    await this.pairings.update(topic, { expiry });
  };

  public updateMetadata: IPairing["updateMetadata"] = async ({ topic, metadata }) => {
    this.isInitialized();
    await this.pairings.update(topic, { peerMetadata: metadata });
  };

  public getPairings: IPairing["getPairings"] = () => {
    this.isInitialized();
    return this.pairings.values;
  };

  public disconnect: IPairing["disconnect"] = async (params) => {
    this.isInitialized();
    await this.isValidDisconnect(params);
    const { topic } = params;
    if (this.pairings.keys.includes(topic)) {
      await this.sendRequest(topic, "wc_pairingDelete", getSdkError("USER_DISCONNECTED"));
      await this.deletePairing(topic);
    }
  };

  public formatUriFromPairing: IPairing["formatUriFromPairing"] = (pairing) => {
    this.isInitialized();
    const { topic, relay, expiry, methods } = pairing;
    const symKey = this.core.crypto.keychain.get(topic);
    return formatUri({
      protocol: this.core.protocol,
      version: this.core.version,
      topic,
      symKey,
      relay,
      expiryTimestamp: expiry,
      methods,
    });
  };

  // ---------- Private Helpers ----------------------------------------------- //

  private sendRequest: IPairingPrivate["sendRequest"] = async (topic, method, params) => {
    const payload = formatJsonRpcRequest(method, params);
    const message = await this.core.crypto.encode(topic, payload);
    const opts = PAIRING_RPC_OPTS[method].req;
    this.core.history.set(topic, payload);
    this.core.relayer.publish(topic, message, opts);
    return payload.id;
  };

  private sendResult: IPairingPrivate["sendResult"] = async (id, topic, result) => {
    const payload = formatJsonRpcResult(id, result);
    const message = await this.core.crypto.encode(topic, payload);
    const record = await this.core.history.get(topic, id);
    const method = record.request.method as PairingJsonRpcTypes.WcMethod;
    const opts = PAIRING_RPC_OPTS[method].res;
    await this.core.relayer.publish(topic, message, opts);
    await this.core.history.resolve(payload);
  };

  private sendError: IPairingPrivate["sendError"] = async (id, topic, error) => {
    const payload = formatJsonRpcError(id, error);
    const message = await this.core.crypto.encode(topic, payload);
    const record = await this.core.history.get(topic, id);
    const method = record.request.method as PairingJsonRpcTypes.WcMethod;

    const opts = PAIRING_RPC_OPTS[method]
      ? PAIRING_RPC_OPTS[method].res
      : PAIRING_RPC_OPTS.unregistered_method.res;

    await this.core.relayer.publish(topic, message, opts);
    await this.core.history.resolve(payload);
  };

  private deletePairing: IPairingPrivate["deletePairing"] = async (topic, expirerHasDeleted) => {
    // Await the unsubscribe first to avoid deleting the symKey too early below.
    await this.core.relayer.unsubscribe(topic);
    await Promise.all([
      this.pairings.delete(topic, getSdkError("USER_DISCONNECTED")),
      this.core.crypto.deleteSymKey(topic),
      expirerHasDeleted ? Promise.resolve() : this.core.expirer.del(topic),
    ]);
  };

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private cleanup = async () => {
    const expiredPairings = this.pairings.getAll().filter((pairing) => isExpired(pairing.expiry));
    await Promise.all(expiredPairings.map((pairing) => this.deletePairing(pairing.topic)));
  };

  // ---------- Relay Events Router ----------------------------------- //

  private registerRelayerEvents() {
    this.core.relayer.on(RELAYER_EVENTS.message, async (event: RelayerTypes.MessageEvent) => {
      const { topic, message, transportType } = event;

      // Do not handle if the topic is not related to known pairing topics.
      if (!this.pairings.keys.includes(topic)) return;

      // Do not handle link-mode messages
      if (transportType === TRANSPORT_TYPES.link_mode) return;

      // messages of certain types should be ignored as they are handled by their respective SDKs
      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(message))) return;

      try {
        const payload = await this.core.crypto.decode(topic, message);

        if (isJsonRpcRequest(payload)) {
          this.core.history.set(topic, payload);
          await this.onRelayEventRequest({ topic, payload });
        } else if (isJsonRpcResponse(payload)) {
          await this.core.history.resolve(payload);
          await this.onRelayEventResponse({ topic, payload });
          this.core.history.delete(topic, payload.id);
        }
        await this.core.relayer.messages.ack(topic, message);
      } catch (error) {
        this.logger.error(error);
      }
    });
  }

  private onRelayEventRequest: IPairingPrivate["onRelayEventRequest"] = async (event) => {
    const { topic, payload } = event;
    const reqMethod = payload.method as PairingJsonRpcTypes.WcMethod;

    switch (reqMethod) {
      case "wc_pairingPing":
        return await this.onPairingPingRequest(topic, payload);
      case "wc_pairingDelete":
        return await this.onPairingDeleteRequest(topic, payload);
      default:
        return await this.onUnknownRpcMethodRequest(topic, payload);
    }
  };

  private onRelayEventResponse: IPairingPrivate["onRelayEventResponse"] = async (event) => {
    const { topic, payload } = event;
    const record = await this.core.history.get(topic, payload.id);
    const resMethod = record.request.method as PairingJsonRpcTypes.WcMethod;

    switch (resMethod) {
      case "wc_pairingPing":
        return this.onPairingPingResponse(topic, payload);
      default:
        return this.onUnknownRpcMethodResponse(resMethod);
    }
  };

  private onPairingPingRequest: IPairingPrivate["onPairingPingRequest"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    try {
      this.isValidPing({ topic });
      await this.sendResult<"wc_pairingPing">(id, topic, true);
      this.events.emit(PAIRING_EVENTS.ping, { id, topic });
    } catch (err: any) {
      await this.sendError(id, topic, err);
      this.logger.error(err);
    }
  };

  private onPairingPingResponse: IPairingPrivate["onPairingPingResponse"] = (_topic, payload) => {
    const { id } = payload;
    // put at the end of the stack to avoid a race condition
    // where pairing_ping listener is not yet initialized
    setTimeout(() => {
      if (isJsonRpcResult(payload)) {
        this.events.emit(engineEvent("pairing_ping", id), {});
      } else if (isJsonRpcError(payload)) {
        this.events.emit(engineEvent("pairing_ping", id), { error: payload.error });
      }
    }, 500);
  };

  private onPairingDeleteRequest: IPairingPrivate["onPairingDeleteRequest"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    try {
      this.isValidDisconnect({ topic });
      await this.deletePairing(topic);
      this.events.emit(PAIRING_EVENTS.delete, { id, topic });
    } catch (err: any) {
      await this.sendError(id, topic, err);
      this.logger.error(err);
    }
  };

  private onUnknownRpcMethodRequest: IPairingPrivate["onUnknownRpcMethodRequest"] = async (
    topic,
    payload,
  ) => {
    const { id, method } = payload;

    try {
      // Ignore if the implementing client has registered this method as known.
      if (this.registeredMethods.includes(method)) return;
      const error = getSdkError("WC_METHOD_UNSUPPORTED", method);
      await this.sendError(id, topic, error);
      this.logger.error(error);
    } catch (err: any) {
      await this.sendError(id, topic, err);
      this.logger.error(err);
    }
  };

  private onUnknownRpcMethodResponse: IPairingPrivate["onUnknownRpcMethodResponse"] = (method) => {
    // Ignore if the implementing client has registered this method as known.
    if (this.registeredMethods.includes(method)) return;
    this.logger.error(getSdkError("WC_METHOD_UNSUPPORTED", method));
  };

  // ---------- Expirer Events ---------------------------------------- //

  private registerExpirerEvents() {
    this.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {
      const { topic } = parseExpirerTarget(event.target);
      if (!topic) return;
      if (!this.pairings.keys.includes(topic)) return;
      await this.deletePairing(topic, true);
      this.events.emit(PAIRING_EVENTS.expire, { topic });
    });
  }

  // ---------- Validation Helpers ----------------------------------- //

  private isValidPair = (params: { uri: string }, event: EventClientTypes.Event) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() params: ${params}`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    if (!isValidUrl(params.uri)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri: ${params.uri}`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    const uri = parseUri(params?.uri);
    if (!uri?.relay?.protocol) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri#relay-protocol`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    if (!uri?.symKey) {
      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri#symKey`);
      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
      throw new Error(message);
    }
    if (uri?.expiryTimestamp) {
      const expiration = toMiliseconds(uri?.expiryTimestamp);
      if (expiration < Date.now()) {
        event.setError(EVENT_CLIENT_PAIRING_ERRORS.pairing_expired);
        const { message } = getInternalError(
          "EXPIRED",
          `pair() URI has expired. Please try again with a new connection URI.`,
        );
        throw new Error(message);
      }
    }
  };

  private isValidPing = async (params: { topic: string }) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `ping() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;
    await this.isValidPairingTopic(topic);
  };

  private isValidDisconnect = async (params: { topic: string }) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `disconnect() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;
    await this.isValidPairingTopic(topic);
  };

  private isValidPairingTopic = async (topic: any) => {
    if (!isValidString(topic, false)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `pairing topic should be a string: ${topic}`,
      );
      throw new Error(message);
    }
    if (!this.pairings.keys.includes(topic)) {
      const { message } = getInternalError(
        "NO_MATCHING_KEY",
        `pairing topic doesn't exist: ${topic}`,
      );
      throw new Error(message);
    }
    if (isExpired(this.pairings.get(topic).expiry)) {
      await this.deletePairing(topic);
      const { message } = getInternalError("EXPIRED", `pairing topic: ${topic}`);
      throw new Error(message);
    }
  };
}
</file>

<file path="packages/core/src/controllers/publisher.ts">
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { JsonRpcPayload, RequestArguments } from "@walletconnect/jsonrpc-types";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { RelayJsonRpc } from "@walletconnect/relay-api";
import { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from "@walletconnect/types";
import {
  getRelayProtocolApi,
  getRelayProtocolName,
  isUndefined,
  createExpiringPromise,
} from "@walletconnect/utils";
import { EventEmitter } from "events";

import { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from "../constants";
import { getBigIntRpcId } from "@walletconnect/jsonrpc-utils";
import { ONE_MINUTE, ONE_SECOND, toMiliseconds } from "@walletconnect/time";

type IPublishType = PublisherTypes.Params & {
  attestation?: string;
  attempt: number;
};
export class Publisher extends IPublisher {
  public events = new EventEmitter();
  public name = PUBLISHER_CONTEXT;
  public queue = new Map<string, IPublishType>();

  private publishTimeout = toMiliseconds(ONE_MINUTE);
  private initialPublishTimeout = toMiliseconds(ONE_SECOND * 15);
  private needsTransportRestart = false;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super(relayer, logger);
    this.relayer = relayer;
    this.logger = generateChildLogger(logger, this.name);
    this.registerEventListeners();
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  public publish: IPublisher["publish"] = async (topic, message, opts) => {
    this.logger.debug(`Publishing Payload`);
    this.logger.trace({ type: "method", method: "publish", params: { topic, message, opts } });

    const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;
    const relay = getRelayProtocolName(opts);
    const prompt = opts?.prompt || false;
    const tag = opts?.tag || 0;
    const id = opts?.id || (getBigIntRpcId().toString() as any);
    const params = {
      topic,
      message,
      opts: {
        ttl,
        relay,
        prompt,
        tag,
        id,
        attestation: opts?.attestation,
        tvf: opts?.tvf,
      },
    };
    const failedPublishMessage = `Failed to publish payload, please try again. id:${id} tag:${tag}`;

    try {
      /**
       * attempt to publish the payload for <initialPublishTimeout> seconds,
       * if the publish fails, add the payload to the queue and it will be retried on every pulse
       * until it is successfully published or <publishTimeout> seconds have passed
       */
      const publishPromise = new Promise(async (resolve) => {
        const onPublish = ({ id }: { id: string }) => {
          if (params.opts.id === id) {
            this.removeRequestFromQueue(id);
            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);
            resolve(params);
          }
        };
        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);
        const initialPublish = createExpiringPromise(
          new Promise((resolve, reject) => {
            this.rpcPublish({
              topic,
              message,
              ttl,
              prompt,
              tag,
              id,
              attestation: opts?.attestation,
              tvf: opts?.tvf,
            })
              .then(resolve)
              .catch((e) => {
                this.logger.warn(e, e?.message);
                reject(e);
              });
          }),
          this.initialPublishTimeout,
          `Failed initial publish, retrying.... id:${id} tag:${tag}`,
        );
        try {
          await initialPublish;
          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);
        } catch (e) {
          this.queue.set(id, { ...params, attempt: 1 });
          this.logger.warn(e, (e as Error)?.message);
        }
      });
      this.logger.trace({
        type: "method",
        method: "publish",
        params: { id, topic, message, opts },
      });

      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);
    } catch (e) {
      this.logger.debug(`Failed to Publish Payload`);
      this.logger.error(e as any);
      if (opts?.internal?.throwOnFailedPublish) {
        throw e;
      }
    } finally {
      this.queue.delete(id);
    }
  };

  public on: IPublisher["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: IPublisher["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: IPublisher["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: IPublisher["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  // ---------- Private ----------------------------------------------- //

  private async rpcPublish(params: {
    topic: string;
    message: string;
    ttl?: number;
    prompt?: boolean;
    tag?: number;
    id?: number;
    attestation?: string;
    tvf?: RelayerTypes.ITVF;
  }) {
    const {
      topic,
      message,
      ttl = PUBLISHER_DEFAULT_TTL,
      prompt,
      tag,
      id,
      attestation,
      tvf,
    } = params;
    const api = getRelayProtocolApi(getRelayProtocolName().protocol);
    const request: RequestArguments<RelayJsonRpc.PublishParams> = {
      method: api.publish,
      params: {
        topic,
        message,
        ttl,
        prompt,
        tag,
        attestation,
        ...tvf,
      },
      id,
    };
    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;
    if (isUndefined(request.params?.tag)) delete request.params?.tag;
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "message", direction: "outgoing", request });
    const result = await this.relayer.request(request);
    this.relayer.events.emit(RELAYER_EVENTS.publish, params);
    this.logger.debug(`Successfully Published Payload`);
    return result;
  }

  private removeRequestFromQueue(id: string) {
    this.queue.delete(id);
  }

  private checkQueue() {
    this.queue.forEach(async (params, id) => {
      const attempt = params.attempt + 1;
      this.queue.set(id, { ...params, attempt });
      const { topic, message, opts, attestation } = params;
      this.logger.warn(
        {},
        `Publisher: queue->publishing: ${params.opts.id}, tag: ${params.opts.tag}, attempt: ${attempt}`,
      );
      await this.rpcPublish({
        ...params,
        topic,
        message,
        ttl: opts.ttl,
        prompt: opts.prompt,
        tag: opts.tag,
        id: opts.id,
        attestation,
        tvf: opts.tvf,
      });
      this.logger.warn({}, `Publisher: queue->published: ${params.opts.id}`);
    });
  }

  private registerEventListeners() {
    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
      // restart the transport if needed
      // queue will be processed on the next pulse
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false;
        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
        return;
      }
      this.checkQueue();
    });
    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {
      this.removeRequestFromQueue(event.id.toString());
    });
  }
}
</file>

<file path="packages/core/src/controllers/relayer.ts">
import { EventEmitter } from "events";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
import {
  formatJsonRpcResult,
  getBigIntRpcId,
  IJsonRpcProvider,
  isJsonRpcRequest,
  isJsonRpcResponse,
  JsonRpcPayload,
  JsonRpcRequest,
  RequestArguments,
} from "@walletconnect/jsonrpc-utils";
import WsConnection from "@walletconnect/jsonrpc-ws-connection";
import {
  generateChildLogger,
  getDefaultLoggerOptions,
  getLoggerContext,
  pino,
  Logger,
} from "@walletconnect/logger";
import { RelayJsonRpc } from "@walletconnect/relay-api";
import {
  FIVE_MINUTES,
  ONE_SECOND,
  FIVE_SECONDS,
  THIRTY_SECONDS,
  toMiliseconds,
} from "@walletconnect/time";
import {
  ICore,
  IMessageTracker,
  IPublisher,
  IRelayer,
  ISubscriber,
  RelayerOptions,
  RelayerTypes,
  SubscriberTypes,
} from "@walletconnect/types";
import {
  createExpiringPromise,
  formatRelayRpcUrl,
  isOnline,
  subscribeToNetworkChange,
  getAppId,
  isAndroid,
  isIos,
  getInternalError,
  isNode,
  calcExpiry,
} from "@walletconnect/utils";

import {
  RELAYER_SDK_VERSION,
  RELAYER_CONTEXT,
  RELAYER_DEFAULT_LOGGER,
  RELAYER_EVENTS,
  RELAYER_PROVIDER_EVENTS,
  RELAYER_SUBSCRIBER_SUFFIX,
  RELAYER_DEFAULT_RELAY_URL,
  SUBSCRIBER_EVENTS,
  RELAYER_RECONNECT_TIMEOUT,
  TRANSPORT_TYPES,
  MESSAGE_DIRECTION,
} from "../constants";
import { MessageTracker } from "./messages";
import { Publisher } from "./publisher";
import { Subscriber } from "./subscriber";

export class Relayer extends IRelayer {
  public protocol = "wc";
  public version = 2;

  public core: ICore;
  public logger: Logger;
  public events = new EventEmitter();
  public provider: IJsonRpcProvider;
  public messages: IMessageTracker;
  public subscriber: ISubscriber;
  public publisher: IPublisher;
  public name = RELAYER_CONTEXT;
  public transportExplicitlyClosed = false;

  private initialized = false;
  private connectionAttemptInProgress = false;

  private relayUrl: string;
  private projectId: string | undefined;
  private packageName: string | undefined;
  private bundleId: string | undefined;
  private hasExperiencedNetworkDisruption = false;
  private pingTimeout: NodeJS.Timeout | undefined;
  /**
   * the relay pings the client 30 seconds after the last message was received
   * meaning if we don't receive a message in 30 seconds, the connection can be considered dead
   */
  private heartBeatTimeout = toMiliseconds(THIRTY_SECONDS + FIVE_SECONDS);
  private reconnectTimeout: NodeJS.Timeout | undefined;
  private connectPromise: Promise<void> | undefined;
  private reconnectInProgress = false;
  private requestsInFlight: string[] = [];
  private connectTimeout = toMiliseconds(ONE_SECOND * 15);
  constructor(opts: RelayerOptions) {
    super(opts);
    this.core = opts.core;
    this.logger =
      typeof opts.logger !== "undefined" && typeof opts.logger !== "string"
        ? generateChildLogger(opts.logger, this.name)
        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));
    this.messages = new MessageTracker(this.logger, opts.core);
    this.subscriber = new Subscriber(this, this.logger);
    this.publisher = new Publisher(this, this.logger);

    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;
    this.projectId = opts.projectId;

    if (isAndroid()) {
      this.packageName = getAppId();
    } else if (isIos()) {
      this.bundleId = getAppId();
    }

    // re-assigned during init()
    this.provider = {} as IJsonRpcProvider;
  }

  public async init() {
    this.logger.trace(`Initialized`);
    this.registerEventListeners();
    await Promise.all([this.messages.init(), this.subscriber.init()]);
    this.initialized = true;
    if (this.subscriber.hasAnyTopics) {
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e, (e as Error)?.message);
      }
    }
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  get connected() {
    // @ts-expect-error
    return this.provider?.connection?.socket?.readyState === 1 || false;
  }

  get connecting() {
    return (
      // @ts-expect-error
      this.provider?.connection?.socket?.readyState === 0 ||
      this.connectPromise !== undefined ||
      false
    );
  }

  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {
    this.isInitialized();
    await this.publisher.publish(topic, message, opts);
    await this.recordMessageEvent(
      {
        topic,
        message,
        // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.
        publishedAt: Date.now(),
        transportType: TRANSPORT_TYPES.relay,
      },
      MESSAGE_DIRECTION.outbound,
    );
  }

  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {
    this.isInitialized();
    if (!opts?.transportType || opts?.transportType === "relay") {
      await this.toEstablishConnection();
    }
    // throw unless explicitly set to false
    const shouldThrowOnFailure =
      typeof opts?.internal?.throwOnFailedPublish === "undefined"
        ? true
        : opts?.internal?.throwOnFailedPublish;

    let id = this.subscriber.topicMap.get(topic)?.[0] || "";
    let resolvePromise: () => void;
    const onSubCreated = (subscription: SubscriberTypes.Active) => {
      if (subscription.topic === topic) {
        this.subscriber.off(SUBSCRIBER_EVENTS.created, onSubCreated);
        resolvePromise();
      }
    };

    await Promise.all([
      new Promise<void>((resolve) => {
        resolvePromise = resolve;
        this.subscriber.on(SUBSCRIBER_EVENTS.created, onSubCreated);
      }),
      new Promise<void>(async (resolve, reject) => {
        const result = await this.subscriber
          .subscribe(topic, {
            internal: {
              throwOnFailedPublish: shouldThrowOnFailure,
            },
            ...opts,
          })
          .catch((error) => {
            if (shouldThrowOnFailure) {
              reject(error);
            }
          });
        id = result || id;
        resolve();
      }),
    ]);
    return id;
  }

  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {
    this.logger.debug(`Publishing Request Payload`);
    const id = request.id || (getBigIntRpcId().toString() as any);
    await this.toEstablishConnection();
    try {
      this.logger.trace(
        {
          id,
          method: request.method,
          topic: request.params?.topic,
        },
        "relayer.request - publishing...",
      );
      const tag = `${id}:${(request.params as any)?.tag || ""}`;
      this.requestsInFlight.push(tag);
      const result = await this.provider.request(request);
      this.requestsInFlight = this.requestsInFlight.filter((i) => i !== tag);
      return result;
    } catch (e) {
      this.logger.debug(`Failed to Publish Request: ${id}`);
      throw e;
    }
  };

  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {
    this.isInitialized();
    await this.subscriber.unsubscribe(topic, opts);
  }

  public on(event: string, listener: any) {
    this.events.on(event, listener);
  }

  public once(event: string, listener: any) {
    this.events.once(event, listener);
  }

  public off(event: string, listener: any) {
    this.events.off(event, listener);
  }

  public removeListener(event: string, listener: any) {
    this.events.removeListener(event, listener);
  }

  public async transportDisconnect() {
    if (this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)) {
      await createExpiringPromise(this.provider.disconnect(), 2000, "provider.disconnect()").catch(
        () => this.onProviderDisconnect(),
      );
    } else {
      this.onProviderDisconnect();
    }
  }

  public async transportClose() {
    this.transportExplicitlyClosed = true;
    await this.transportDisconnect();
  }

  async transportOpen(relayUrl?: string) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn(
        "Starting WS connection skipped because the client has no topics to work with.",
      );
      return;
    }

    if (this.connectPromise) {
      this.logger.debug({}, `Waiting for existing connection attempt to resolve...`);
      await this.connectPromise;
      this.logger.debug({}, `Existing connection attempt resolved`);
    } else {
      this.connectPromise = new Promise(async (resolve, reject) => {
        await this.connect(relayUrl)
          .then(resolve)
          .catch(reject)
          .finally(() => {
            this.connectPromise = undefined;
          });
      });
      await this.connectPromise;
    }
    if (!this.connected) {
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
    }
  }

  public async restartTransport(relayUrl?: string) {
    this.logger.debug({}, "Restarting transport...");
    if (this.connectionAttemptInProgress) return;
    this.relayUrl = relayUrl || this.relayUrl;
    await this.confirmOnlineStateOrThrow();
    await this.transportClose();
    await this.transportOpen();
  }

  public async confirmOnlineStateOrThrow() {
    if (await isOnline()) return;
    throw new Error("No internet connection detected. Please restart your network and try again.");
  }

  public async handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]) {
    if (messages?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const sortedMessages = messages.sort((a, b) => a.publishedAt - b.publishedAt);
    this.logger.debug(`Batch of ${sortedMessages.length} message events sorted`);
    for (const message of sortedMessages) {
      try {
        await this.onMessageEvent(message);
      } catch (e) {
        this.logger.warn(e, "Error while processing batch message event: " + (e as Error)?.message);
      }
    }
    this.logger.trace(`Batch of ${sortedMessages.length} message events processed`);
  }

  public async onLinkMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
    opts: { sessionExists: boolean },
  ) {
    const { topic } = messageEvent;

    if (!opts.sessionExists) {
      const expiry = calcExpiry(FIVE_MINUTES);
      const pairing = { topic, expiry, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(topic, pairing);
    }

    this.events.emit(RELAYER_EVENTS.message, messageEvent);
    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);
  }

  // ---------- Private ----------------------------------------------- //

  private async connect(relayUrl?: string) {
    await this.confirmOnlineStateOrThrow();
    if (relayUrl && relayUrl !== this.relayUrl) {
      this.relayUrl = relayUrl;
      await this.transportDisconnect();
    }

    this.connectionAttemptInProgress = true;
    this.transportExplicitlyClosed = false;
    let attempt = 1;
    while (attempt < 6) {
      try {
        if (this.transportExplicitlyClosed) {
          break;
        }
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${attempt}...`);
        // Always create new socket instance when trying to connect because if the socket was dropped due to `socket hang up` exception
        // It wont be able to reconnect
        await this.createProvider();

        await new Promise<void>(async (resolve, reject) => {
          const onDisconnect = () => {
            reject(new Error(`Connection interrupted while trying to subscribe`));
          };
          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);

          await createExpiringPromise(
            new Promise((resolve, reject) => {
              this.provider.connect().then(resolve).catch(reject);
            }),
            this.connectTimeout,
            `Socket stalled when trying to connect to ${this.relayUrl}`,
          )
            .catch((e) => {
              reject(e);
            })
            .finally(() => {
              this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
              clearTimeout(this.reconnectTimeout);
            });
          await new Promise(async (resolve, reject) => {
            const onDisconnect = () => {
              reject(new Error(`Connection interrupted while trying to subscribe`));
            };
            this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
            await this.subscriber
              .start()
              .then(resolve)
              .catch(reject)
              .finally(() => {
                this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
              });
          });
          this.hasExperiencedNetworkDisruption = false;
          resolve();
        });
      } catch (e) {
        await this.subscriber.stop();
        const error = e as Error;
        this.logger.warn({}, error.message);
        this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }

      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${attempt}`);
        break;
      }

      await new Promise((resolve) => setTimeout(resolve, toMiliseconds(attempt * 1)));
      attempt++;
    }
  }

  /*
   * In Node, we must detect when the connection is stalled and terminate it.
   * The logic is, if we don't receive ping from the relay within a certain time, we terminate the connection.
   * The timer is refreshed on every message received from the relay.
   *
   * In the browser, ping/pong events are not exposed, so the above behaviour is handled by `subscribeToNetworkChange` and `isOnline` functions.
   */
  private startPingTimeout() {
    if (!isNode()) return;
    try {
      //@ts-expect-error - Types are divergent between the node and browser WS API
      if (this.provider?.connection?.socket) {
        //@ts-expect-error
        this.provider?.connection?.socket?.on("ping", () => {
          this.resetPingTimeout();
        });
      }
      this.resetPingTimeout();
    } catch (e) {
      this.logger.warn(e, (e as Error)?.message);
    }
  }

  private resetPingTimeout = () => {
    if (!isNode()) return;
    clearTimeout(this.pingTimeout);
    this.pingTimeout = setTimeout(() => {
      try {
        this.logger.debug({}, "pingTimeout: Connection stalled, terminating...");
        //@ts-expect-error
        this.provider?.connection?.socket?.terminate?.();
      } catch (e) {
        this.logger.warn(e, (e as Error)?.message);
      }
    }, this.heartBeatTimeout);
  };

  private async createProvider() {
    if (this.provider.connection) {
      this.unregisterProviderListeners();
    }
    const auth = await this.core.crypto.signJWT(this.relayUrl);

    this.provider = new JsonRpcProvider(
      new WsConnection(
        formatRelayRpcUrl({
          sdkVersion: RELAYER_SDK_VERSION,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth,
          useOnCloseEvent: true,
          bundleId: this.bundleId,
          packageName: this.packageName,
        }),
      ),
    );
    this.registerProviderListeners();
  }

  private async recordMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
    direction?: RelayerTypes.MessageDirection,
  ) {
    const { topic, message } = messageEvent;
    await this.messages.set(topic, message, direction);
  }

  private async shouldIgnoreMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
  ): Promise<boolean> {
    const { topic, message } = messageEvent;

    // Ignore if incoming `message` is clearly invalid.
    if (!message || message.length === 0) {
      this.logger.warn(`Ignoring invalid/empty message: ${message}`);
      return true;
    }

    // Ignore if `topic` is not known to the subscriber.
    if (!(await this.subscriber.isKnownTopic(topic))) {
      this.logger.warn(`Ignoring message for unknown topic ${topic}`);
      return true;
    }

    // Ignore if `message` is a duplicate.
    const exists = this.messages.has(topic, message);
    if (exists) {
      this.logger.warn(`Ignoring duplicate message: ${message}`);
    }
    return exists;
  }

  private async onProviderPayload(payload: JsonRpcPayload) {
    this.logger.debug(`Incoming Relay Payload`);
    this.logger.trace({ type: "payload", direction: "incoming", payload });
    if (isJsonRpcRequest(payload)) {
      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;
      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;
      const { topic, message, publishedAt, attestation } = event.data;
      const messageEvent: RelayerTypes.MessageEvent = {
        topic,
        message,
        publishedAt,
        transportType: TRANSPORT_TYPES.relay,
        attestation,
      };
      this.logger.debug(`Emitting Relayer Payload`);
      this.logger.trace({ type: "event", event: event.id, ...messageEvent });
      this.events.emit(event.id, messageEvent);
      await this.acknowledgePayload(payload);
      await this.onMessageEvent(messageEvent);
    } else if (isJsonRpcResponse(payload)) {
      this.events.emit(RELAYER_EVENTS.message_ack, payload);
    }
  }

  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {
    if (await this.shouldIgnoreMessageEvent(messageEvent)) {
      return;
    }
    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);
    this.events.emit(RELAYER_EVENTS.message, messageEvent);
  }

  private async acknowledgePayload(payload: JsonRpcPayload) {
    const response = formatJsonRpcResult(payload.id, true);
    await this.provider.connection.send(response);
  }

  // ---------- Events Handlers ----------------------------------------------- //
  private onPayloadHandler = (payload: JsonRpcPayload) => {
    this.onProviderPayload(payload);
    this.resetPingTimeout();
  };

  private onConnectHandler = () => {
    this.logger.warn({}, "Relayer connected 🛜");
    this.startPingTimeout();
    this.events.emit(RELAYER_EVENTS.connect);
  };

  private onDisconnectHandler = () => {
    this.logger.warn({}, `Relayer disconnected 🛑`);
    this.requestsInFlight = [];
    this.onProviderDisconnect();
  };

  private onProviderErrorHandler = (error: Error) => {
    this.logger.fatal(`Fatal socket error: ${error.message}`);
    this.events.emit(RELAYER_EVENTS.error, error);
    // close the transport when a fatal error is received as there's no way to recover from it
    // usual cases are missing/invalid projectId, expired jwt token, invalid origin etc
    this.logger.fatal("Fatal socket error received, closing transport");
    this.transportClose();
  };

  private registerProviderListeners = () => {
    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);
    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);
    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);
    this.provider.on(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);
  };

  private unregisterProviderListeners() {
    this.provider.off(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);
    this.provider.off(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);
    this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);
    this.provider.off(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);
    clearTimeout(this.pingTimeout);
  }

  private async registerEventListeners() {
    let lastConnectedState = await isOnline();
    subscribeToNetworkChange(async (connected: boolean) => {
      // sometimes the network change event is triggered multiple times so avoid reacting to the samFe value
      if (lastConnectedState === connected) return;

      lastConnectedState = connected;
      if (!connected) {
        // when the device network is restarted, the socket might stay in false `connected` state
        this.hasExperiencedNetworkDisruption = true;
        await this.transportDisconnect();
        this.transportExplicitlyClosed = false;
      } else {
        await this.transportOpen().catch((error) =>
          this.logger.error(error, (error as Error)?.message),
        );
      }
    });
  }

  private async onProviderDisconnect() {
    clearTimeout(this.pingTimeout);
    this.events.emit(RELAYER_EVENTS.disconnect);
    this.connectionAttemptInProgress = false;
    if (this.reconnectInProgress) return;

    this.reconnectInProgress = true;
    await this.subscriber.stop();

    if (!this.subscriber.hasAnyTopics) return;
    if (this.transportExplicitlyClosed) return;

    this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((error) =>
        this.logger.error(error, (error as Error)?.message),
      );
      this.reconnectTimeout = undefined;
      this.reconnectInProgress = false;
    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow();
    if (this.connected) return;
    await this.connect();
  }
}
</file>

<file path="packages/core/src/controllers/store.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IStore } from "@walletconnect/types";
import {
  getInternalError,
  isProposalStruct,
  isSessionStruct,
  isUndefined,
} from "@walletconnect/utils";
import { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from "../constants";
import { isEqual } from "es-toolkit/compat";

export class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {
  public map = new Map<Key, Data>();
  public version = STORE_STORAGE_VERSION;

  private cached: Data[] = [];
  private initialized = false;

  /**
   * Regenerates the value key to retrieve it from cache
   */
  private getKey: ((data: Data) => Key) | undefined;

  private storagePrefix = CORE_STORAGE_PREFIX;

  // stores recently deleted key to return different rejection message when key is not found
  private recentlyDeleted: Key[] = [];
  private recentlyDeletedLimit = 200;

  /**
   * @param {ICore} core Core
   * @param {Logger} logger Logger
   * @param {string} name Store's name
   * @param {Store<Key, Data>["getKey"]} getKey Regenerates the value key to retrieve it from cache
   * @param {string} storagePrefix Prefixes value keys
   */
  constructor(
    public core: ICore,
    public logger: Logger,
    public name: string,
    storagePrefix: string = CORE_STORAGE_PREFIX,
    getKey: Store<Key, Data>["getKey"] = undefined,
  ) {
    super(core, logger, name, storagePrefix);
    this.logger = generateChildLogger(logger, this.name);
    this.storagePrefix = storagePrefix;
    this.getKey = getKey;
  }

  public init: IStore<Key, Data>["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);

      await this.restore();

      this.cached.forEach((value) => {
        if (this.getKey && value !== null && !isUndefined(value)) {
          this.map.set(this.getKey(value), value);
        } else if (isProposalStruct(value)) {
          // TODO(pedro) revert type casting as any
          this.map.set(value.id as any, value);
        } else if (isSessionStruct(value)) {
          // TODO(pedro) revert type casting as any
          this.map.set(value.topic as any, value);
        }
      });

      this.cached = [];
      this.initialized = true;
    }
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }

  get length() {
    return this.map.size;
  }

  get keys() {
    return Array.from(this.map.keys());
  }

  get values() {
    return Array.from(this.map.values());
  }

  public set: IStore<Key, Data>["set"] = async (key, value) => {
    this.isInitialized();
    if (this.map.has(key)) {
      await this.update(key, value);
    } else {
      this.logger.debug(`Setting value`);
      this.logger.trace({ type: "method", method: "set", key, value });
      this.map.set(key, value);
      await this.persist();
    }
  };

  public get: IStore<Key, Data>["get"] = (key) => {
    this.isInitialized();
    this.logger.debug(`Getting value`);
    this.logger.trace({ type: "method", method: "get", key });
    const value = this.getData(key);
    return value;
  };

  public getAll: IStore<Key, Data>["getAll"] = (filter) => {
    this.isInitialized();
    if (!filter) return this.values;

    return this.values.filter((value) =>
      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),
    );
  };

  public update: IStore<Key, Data>["update"] = async (key, update) => {
    this.isInitialized();
    this.logger.debug(`Updating value`);
    this.logger.trace({ type: "method", method: "update", key, update });
    const value = { ...this.getData(key), ...update };
    this.map.set(key, value);
    await this.persist();
  };

  public delete: IStore<Key, Data>["delete"] = async (key, reason) => {
    this.isInitialized();
    if (!this.map.has(key)) return;
    this.logger.debug(`Deleting value`);
    this.logger.trace({ type: "method", method: "delete", key, reason });
    this.map.delete(key);
    this.addToRecentlyDeleted(key);
    await this.persist();
  };

  // ---------- Private ----------------------------------------------- //

  private addToRecentlyDeleted(key: Key) {
    this.recentlyDeleted.push(key);
    // limit the size of the recentlyDeleted array, truncate the 100 oldest entries.
    if (this.recentlyDeleted.length >= this.recentlyDeletedLimit) {
      this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
    }
  }

  private async setDataStore(value: Data[]) {
    await this.core.storage.setItem<Data[]>(this.storageKey, value);
  }

  private async getDataStore() {
    const value = await this.core.storage.getItem<Data[]>(this.storageKey);
    return value;
  }

  private getData(key: Key) {
    const value = this.map.get(key);
    if (!value) {
      if (this.recentlyDeleted.includes(key)) {
        const { message } = getInternalError(
          "MISSING_OR_INVALID",
          `Record was recently deleted - ${this.name}: ${key}`,
        );
        this.logger.error(message);
        throw new Error(message);
      }

      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${key}`);
      this.logger.error(message);
      throw new Error(message);
    }
    return value;
  }

  private async persist() {
    await this.setDataStore(this.values);
  }

  private async restore() {
    try {
      const persisted = await this.getDataStore();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.map.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored value for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }
}
</file>

<file path="packages/core/src/controllers/subscriber.ts">
import { EventEmitter } from "events";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
import { ErrorResponse, RequestArguments } from "@walletconnect/jsonrpc-types";
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { RelayJsonRpc } from "@walletconnect/relay-api";
import { ONE_SECOND, ONE_MINUTE, toMiliseconds } from "@walletconnect/time";
import {
  IRelayer,
  ISubscriber,
  RelayerTypes,
  SubscriberEvents,
  SubscriberTypes,
} from "@walletconnect/types";
import {
  getSdkError,
  getInternalError,
  getRelayProtocolApi,
  getRelayProtocolName,
  createExpiringPromise,
  hashMessage,
  sleep,
} from "@walletconnect/utils";
import {
  CORE_STORAGE_PREFIX,
  SUBSCRIBER_CONTEXT,
  SUBSCRIBER_EVENTS,
  SUBSCRIBER_STORAGE_VERSION,
  RELAYER_EVENTS,
  TRANSPORT_TYPES,
} from "../constants";
import { SubscriberTopicMap } from "./topicmap";

export class Subscriber extends ISubscriber {
  public subscriptions = new Map<string, SubscriberTypes.Active>();
  public topicMap = new SubscriberTopicMap();
  public events = new EventEmitter();
  public name = SUBSCRIBER_CONTEXT;
  public version = SUBSCRIBER_STORAGE_VERSION;
  public pending = new Map<string, SubscriberTypes.Params>();

  private cached: SubscriberTypes.Active[] = [];
  private initialized = false;
  private storagePrefix = CORE_STORAGE_PREFIX;
  private subscribeTimeout = toMiliseconds(ONE_MINUTE);
  private initialSubscribeTimeout = toMiliseconds(ONE_SECOND * 15);
  private clientId: string;
  private batchSubscribeTopicsLimit = 500;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super(relayer, logger);
    this.relayer = relayer;
    this.logger = generateChildLogger(logger, this.name);
    this.clientId = ""; // assigned when calling this.getClientId()
  }

  public init: ISubscriber["init"] = async () => {
    if (!this.initialized) {
      this.logger.trace(`Initialized`);
      this.registerEventListeners();
      await this.restore();
    }
    this.initialized = true;
  };

  get context() {
    return getLoggerContext(this.logger);
  }

  get storageKey() {
    return (
      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    );
  }

  get length() {
    return this.subscriptions.size;
  }

  get ids() {
    return Array.from(this.subscriptions.keys());
  }

  get values() {
    return Array.from(this.subscriptions.values());
  }

  get topics() {
    return this.topicMap.topics;
  }

  get hasAnyTopics() {
    return (
      this.topicMap.topics.length > 0 ||
      this.pending.size > 0 ||
      this.cached.length > 0 ||
      this.subscriptions.size > 0
    );
  }

  public subscribe: ISubscriber["subscribe"] = async (topic, opts) => {
    this.isInitialized();
    this.logger.debug(`Subscribing Topic`);
    this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
    try {
      const relay = getRelayProtocolName(opts);
      const params = { topic, relay, transportType: opts?.transportType };
      this.pending.set(topic, params);
      const id = await this.rpcSubscribe(topic, relay, opts);
      if (typeof id === "string") {
        this.onSubscribe(id, params);
        this.logger.debug(`Successfully Subscribed Topic`);
        this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
      }
      return id;
    } catch (e) {
      this.logger.debug(`Failed to Subscribe Topic`);
      this.logger.error(e as any);
      throw e;
    }
  };

  public unsubscribe: ISubscriber["unsubscribe"] = async (topic, opts) => {
    this.isInitialized();
    if (typeof opts?.id !== "undefined") {
      await this.unsubscribeById(topic, opts.id, opts);
    } else {
      await this.unsubscribeByTopic(topic, opts);
    }
  };

  /**
   * returns `true` only if the topic is actively subscribed to i.e. not pending or cached
   */
  public isSubscribed: ISubscriber["isSubscribed"] = (topic: string) => {
    return new Promise((resolve) => {
      resolve(this.topicMap.topics.includes(topic));
    });
  };

  /**
   * returns `true` if the topic is known to the subscriber i.e. it is actively subscribed, pending, cached or in the topic map
   */
  public isKnownTopic: ISubscriber["isKnownTopic"] = (topic: string) => {
    return new Promise((resolve) => {
      resolve(
        this.topicMap.topics.includes(topic) ||
          this.pending.has(topic) ||
          this.cached.some((s) => s.topic === topic),
      );
    });
  };

  public on: ISubscriber["on"] = (event, listener) => {
    this.events.on(event, listener);
  };

  public once: ISubscriber["once"] = (event, listener) => {
    this.events.once(event, listener);
  };

  public off: ISubscriber["off"] = (event, listener) => {
    this.events.off(event, listener);
  };

  public removeListener: ISubscriber["removeListener"] = (event, listener) => {
    this.events.removeListener(event, listener);
  };

  public start: ISubscriber["start"] = async () => {
    await this.onConnect();
  };

  public stop: ISubscriber["stop"] = async () => {
    await this.onDisconnect();
  };

  // ---------- Private ----------------------------------------------- //

  private hasSubscription(id: string, topic: string) {
    let result = false;
    try {
      const subscription = this.getSubscription(id);
      result = subscription.topic === topic;
    } catch (e) {
      // ignore error
    }
    return result;
  }

  private reset() {
    this.cached = [];
    this.initialized = true;
  }

  private onDisable() {
    this.cached = this.values;
    this.subscriptions.clear();
    this.topicMap.clear();
  }

  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {
    const ids = this.topicMap.get(topic);
    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));
  }

  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {
    this.logger.debug(`Unsubscribing Topic`);
    this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });

    try {
      const relay = getRelayProtocolName(opts);
      await this.restartToComplete({ topic, id, relay });
      await this.rpcUnsubscribe(topic, id, relay);
      const reason = getSdkError("USER_DISCONNECTED", `${this.name}, ${topic}`);
      await this.onUnsubscribe(topic, id, reason);
      this.logger.debug(`Successfully Unsubscribed Topic`);
      this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
    } catch (e) {
      this.logger.debug(`Failed to Unsubscribe Topic`);
      this.logger.error(e as any);
      throw e;
    }
  }

  private async rpcSubscribe(
    topic: string,
    relay: RelayerTypes.ProtocolOptions,
    opts?: RelayerTypes.SubscribeOptions,
  ) {
    if (!opts || opts?.transportType === TRANSPORT_TYPES.relay) {
      await this.restartToComplete({ topic, id: topic, relay });
    }
    const api = getRelayProtocolApi(relay.protocol);
    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {
      method: api.subscribe,
      params: {
        topic,
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    const shouldThrow = opts?.internal?.throwOnFailedPublish;
    try {
      const subId = await this.getSubscriptionId(topic);
      // in link mode, allow the app to update its network state (i.e. active airplane mode) with small delay before attempting to subscribe
      if (opts?.transportType === TRANSPORT_TYPES.link_mode) {
        setTimeout(() => {
          if (this.relayer.connected || this.relayer.connecting) {
            this.relayer.request(request).catch((e) => this.logger.warn(e));
          }
        }, toMiliseconds(ONE_SECOND));
        return subId;
      }
      const subscribePromise = new Promise(async (resolve) => {
        const onSubscribe = (subscription: SubscriberEvents.Created) => {
          if (subscription.topic === topic) {
            this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);
            resolve(subscription.id);
          }
        };
        this.events.on(SUBSCRIBER_EVENTS.created, onSubscribe);
        try {
          const result = await createExpiringPromise(
            new Promise((resolve, reject) => {
              this.relayer
                .request(request)
                .catch((e) => {
                  this.logger.warn(e, e?.message);
                  reject(e);
                })
                .then(resolve);
            }),
            this.initialSubscribeTimeout,
            `Subscribing to ${topic} failed, please try again`,
          );
          this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);
          resolve(result);
        } catch (err) {}
      });

      const subscribe = createExpiringPromise(
        subscribePromise,
        this.subscribeTimeout,
        `Subscribing to ${topic} failed, please try again`,
      );

      const result = await subscribe;
      if (!result && shouldThrow) {
        throw new Error(`Subscribing to ${topic} failed, please try again`);
      }
      // return null to indicate that the subscription failed
      return result ? subId : null;
    } catch (err) {
      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);
      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
      if (shouldThrow) {
        throw err;
      }
    }
    return null;
  }

  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;
    const relay = subscriptions[0].relay;
    const api = getRelayProtocolApi(relay!.protocol);
    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {
      method: api.batchSubscribe,
      params: {
        topics: subscriptions.map((s) => s.topic),
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    try {
      const subscribe = await createExpiringPromise(
        new Promise((resolve) => {
          this.relayer
            .request(request)
            .catch((e) => this.logger.warn(e))
            .then(resolve);
        }),
        this.subscribeTimeout,
        "rpcBatchSubscribe failed, please try again",
      );
      await subscribe;
    } catch (err) {
      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
    }
  }

  private async rpcBatchFetchMessages(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;
    const relay = subscriptions[0].relay;
    const api = getRelayProtocolApi(relay!.protocol);
    const request: RequestArguments<RelayJsonRpc.BatchFetchMessagesParams> = {
      method: api.batchFetchMessages,
      params: {
        topics: subscriptions.map((s) => s.topic),
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    let result;
    try {
      const fetchMessagesPromise = await createExpiringPromise(
        new Promise((resolve, reject) => {
          this.relayer
            .request(request)
            .catch((e) => {
              this.logger.warn(e);
              reject(e);
            })
            .then(resolve);
        }),
        this.subscribeTimeout,
        "rpcBatchFetchMessages failed, please try again",
      );
      result = (await fetchMessagesPromise) as {
        messages: RelayerTypes.MessageEvent[];
      };
    } catch (err) {
      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
    }
    return result;
  }

  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {
    const api = getRelayProtocolApi(relay.protocol);
    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {
      method: api.unsubscribe,
      params: {
        topic,
        id,
      },
    };
    this.logger.debug(`Outgoing Relay Payload`);
    this.logger.trace({ type: "payload", direction: "outgoing", request });
    return this.relayer.request(request);
  }

  private onSubscribe(id: string, params: SubscriberTypes.Params) {
    this.setSubscription(id, { ...params, id });
    this.pending.delete(params.topic);
  }

  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {
    if (!subscriptions.length) return;
    subscriptions.forEach((subscription) => {
      this.setSubscription(subscription.id, { ...subscription });
      this.pending.delete(subscription.topic);
    });
  }

  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {
    this.events.removeAllListeners(id);
    if (this.hasSubscription(id, topic)) {
      this.deleteSubscription(id, reason);
    }
    await this.relayer.messages.del(topic);
  }

  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {
    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(
      this.storageKey,
      subscriptions,
    );
  }

  private async getRelayerSubscriptions() {
    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(
      this.storageKey,
    );
    return subscriptions;
  }

  private setSubscription(id: string, subscription: SubscriberTypes.Active) {
    this.logger.debug(`Setting subscription`);
    this.logger.trace({ type: "method", method: "setSubscription", id, subscription });
    this.addSubscription(id, subscription);
  }

  private addSubscription(id: string, subscription: SubscriberTypes.Active) {
    this.subscriptions.set(id, { ...subscription });
    this.topicMap.set(subscription.topic, id);
    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);
  }

  private getSubscription(id: string) {
    this.logger.debug(`Getting subscription`);
    this.logger.trace({ type: "method", method: "getSubscription", id });
    const subscription = this.subscriptions.get(id);
    if (!subscription) {
      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${id}`);
      throw new Error(message);
    }
    return subscription;
  }

  private deleteSubscription(id: string, reason: ErrorResponse) {
    this.logger.debug(`Deleting subscription`);
    this.logger.trace({ type: "method", method: "deleteSubscription", id, reason });
    const subscription = this.getSubscription(id);
    this.subscriptions.delete(id);
    this.topicMap.delete(subscription.topic, id);
    this.events.emit(SUBSCRIBER_EVENTS.deleted, {
      ...subscription,
      reason,
    } as SubscriberEvents.Deleted);
  }

  private restart = async () => {
    await this.restore();
    await this.onRestart();
  };

  private async persist() {
    await this.setRelayerSubscriptions(this.values);
    this.events.emit(SUBSCRIBER_EVENTS.sync);
  }

  private async onRestart() {
    if (this.cached.length) {
      const subs = [...this.cached];
      const numOfBatches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i = 0; i < numOfBatches; i++) {
        const batch = subs.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(batch);
      }
    }
    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);
  }

  private async restore() {
    try {
      const persisted = await this.getRelayerSubscriptions();
      if (typeof persisted === "undefined") return;
      if (!persisted.length) return;
      if (this.subscriptions.size) {
        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
        this.logger.error(message);
        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);
        throw new Error(message);
      }
      this.cached = persisted;
      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);
      this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);
      this.logger.error(e as any);
    }
  }

  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;

    await this.rpcBatchSubscribe(subscriptions);
    this.onBatchSubscribe(
      await Promise.all(
        subscriptions.map(async (s) => {
          return { ...s, id: await this.getSubscriptionId(s.topic) };
        }),
      ),
    );
  }

  // @ts-ignore
  private async batchFetchMessages(subscriptions: SubscriberTypes.Params[]) {
    if (!subscriptions.length) return;
    this.logger.trace(`Fetching batch messages for ${subscriptions.length} subscriptions`);
    const response = await this.rpcBatchFetchMessages(subscriptions);
    if (response && response.messages) {
      await sleep(toMiliseconds(ONE_SECOND));
      await this.relayer.handleBatchMessageEvents(response.messages);
    }
  }

  private async onConnect() {
    await this.restart();
    this.reset();
  }

  private onDisconnect() {
    this.onDisable();
  }

  private checkPending = async () => {
    if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) {
      return;
    }
    const pendingSubscriptions: SubscriberTypes.Params[] = [];
    this.pending.forEach((params) => {
      pendingSubscriptions.push(params);
    });

    await this.batchSubscribe(pendingSubscriptions);
  };

  private registerEventListeners = () => {
    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    });
    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {
      const eventName = SUBSCRIBER_EVENTS.created;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: createdEvent });
      await this.persist();
    });
    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {
      const eventName = SUBSCRIBER_EVENTS.deleted;
      this.logger.info(`Emitting ${eventName}`);
      this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
      await this.persist();
    });
  };

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private async restartToComplete(subscription: SubscriberTypes.Active) {
    if (!this.relayer.connected && !this.relayer.connecting) {
      this.cached.push(subscription);
      await this.relayer.transportOpen();
    }
  }

  private async getClientId() {
    if (!this.clientId) {
      this.clientId = await this.relayer.core.crypto.getClientId();
    }
    return this.clientId;
  }

  private async getSubscriptionId(topic: string) {
    return hashMessage(topic + (await this.getClientId()));
  }
}
</file>

<file path="packages/core/src/controllers/topicmap.ts">
import { ISubscriberTopicMap } from "@walletconnect/types";

export class SubscriberTopicMap implements ISubscriberTopicMap {
  public map = new Map<string, string[]>();

  get topics(): string[] {
    return Array.from(this.map.keys());
  }

  public set: ISubscriberTopicMap["set"] = (topic, id) => {
    const ids = this.get(topic);
    if (this.exists(topic, id)) return;
    this.map.set(topic, [...ids, id]);
  };

  public get: ISubscriberTopicMap["get"] = (topic) => {
    const ids = this.map.get(topic);
    return ids || [];
  };

  public exists: ISubscriberTopicMap["exists"] = (topic, id) => {
    const ids = this.get(topic);
    return ids.includes(id);
  };

  public delete: ISubscriberTopicMap["delete"] = (topic, id) => {
    if (typeof id === "undefined") {
      this.map.delete(topic);
      return;
    }
    if (!this.map.has(topic)) return;
    const ids = this.get(topic);
    if (!this.exists(topic, id)) return;
    const remaining = ids.filter((x) => x !== id);
    if (!remaining.length) {
      this.map.delete(topic);
      return;
    }
    this.map.set(topic, remaining);
  };

  public clear: ISubscriberTopicMap["clear"] = () => {
    this.map.clear();
  };
}
</file>

<file path="packages/core/src/controllers/verify.ts">
import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
import { ICore, IVerify } from "@walletconnect/types";
import { isBrowser, isTestRun, P256KeyDataType, verifyP256Jwt } from "@walletconnect/utils";
import { FIVE_SECONDS, ONE_SECOND, toMiliseconds } from "@walletconnect/time";
import { getDocument } from "@walletconnect/window-getters";
import { decodeJWT } from "@walletconnect/relay-auth";

import {
  CORE_STORAGE_PREFIX,
  CORE_VERSION,
  TRUSTED_VERIFY_URLS,
  VERIFY_CONTEXT,
  VERIFY_SERVER,
  VERIFY_SERVER_V3,
} from "../constants";
import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";

type Jwk = {
  publicKey: P256KeyDataType;
  expiresAt: number;
};
type JwkPayload = {
  exp: number;
  id: string;
  origin: string;
  isScam: boolean;
  isVerified: boolean;
};
export class Verify extends IVerify {
  public name = VERIFY_CONTEXT;
  private abortController: AbortController;
  private isDevEnv;
  private verifyUrlV3 = VERIFY_SERVER_V3;
  private storagePrefix = CORE_STORAGE_PREFIX;
  private version = CORE_VERSION;
  private publicKey?: Jwk;
  private fetchPromise?: Promise<Jwk>;

  constructor(
    public core: ICore,
    public logger: Logger,
    public store: IKeyValueStorage,
  ) {
    super(core, logger, store);
    this.logger = generateChildLogger(logger, this.name);
    this.abortController = new AbortController();
    this.isDevEnv = isTestRun();
    this.init();
  }

  get storeKey(): string {
    return (
      this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + `verify:public:key`
    );
  }

  public init = async () => {
    if (this.isDevEnv) return;
    this.publicKey = await this.store.getItem(this.storeKey);
    if (this.publicKey && toMiliseconds(this.publicKey?.expiresAt) < Date.now()) {
      this.logger.debug("verify v2 public key expired");
      await this.removePublicKey();
    }
  };

  public register: IVerify["register"] = async (params) => {
    if (!isBrowser() || this.isDevEnv) return;
    const origin = window.location.origin;
    const { id, decryptedId } = params;
    const src = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${origin}&id=${id}&decryptedId=${decryptedId}`;
    try {
      const document = getDocument() as Document;
      const abortTimeout = this.startAbortTimer(ONE_SECOND * 5);
      const attestationJwt = await new Promise((resolve, reject) => {
        const abortListener = () => {
          window.removeEventListener("message", listener);
          document.body.removeChild(iframe);
          reject("attestation aborted");
        };
        this.abortController.signal.addEventListener("abort", abortListener);
        const iframe = document.createElement("iframe");
        iframe.src = src;
        iframe.style.display = "none";
        iframe.addEventListener("error", abortListener, { signal: this.abortController.signal });
        const listener = (event: MessageEvent) => {
          if (!event.data) return;
          if (typeof event.data !== "string") return;
          try {
            const data = JSON.parse(event.data);
            if (data.type === "verify_attestation") {
              const decoded = decodeJWT(data.attestation) as unknown as { payload: JwkPayload };
              if (decoded.payload.id !== id) return;

              clearInterval(abortTimeout);
              document.body.removeChild(iframe);
              this.abortController.signal.removeEventListener("abort", abortListener);
              window.removeEventListener("message", listener);
              resolve(data.attestation === null ? "" : data.attestation);
            }
          } catch (e) {
            this.logger.warn(e);
          }
        };
        document.body.appendChild(iframe);
        window.addEventListener("message", listener, { signal: this.abortController.signal });
      });
      this.logger.debug("jwt attestation", attestationJwt);
      return attestationJwt as string;
    } catch (e) {
      this.logger.warn(e);
    }
    return "";
  };

  public resolve: IVerify["resolve"] = async (params) => {
    if (this.isDevEnv) return "";
    const { attestationId, hash, encryptedId } = params;
    if (attestationId === "") {
      this.logger.debug("resolve: attestationId is empty, skipping");
      return;
    }

    if (attestationId) {
      const decoded = decodeJWT(attestationId) as unknown as { payload: JwkPayload };
      if (decoded.payload.id !== encryptedId) return;
      const validation = await this.isValidJwtAttestation(attestationId);
      if (validation) {
        if (!validation.isVerified) {
          this.logger.warn("resolve: jwt attestation: origin url not verified");
          return;
        }
        return validation;
      }
    }
    if (!hash) return;
    const verifyUrl = this.getVerifyUrl(params?.verifyUrl);
    return this.fetchAttestation(hash, verifyUrl);
  };

  get context(): string {
    return getLoggerContext(this.logger);
  }

  private fetchAttestation = async (attestationId: string, url: string) => {
    this.logger.debug(`resolving attestation: ${attestationId} from url: ${url}`);
    // set artificial timeout to prevent hanging
    const timeout = this.startAbortTimer(ONE_SECOND * 5);
    const result = await fetch(`${url}/attestation/${attestationId}?v2Supported=true`, {
      signal: this.abortController.signal,
    });
    clearTimeout(timeout);
    return result.status === 200 ? await result.json() : undefined;
  };

  private startAbortTimer(timer: number) {
    this.abortController = new AbortController();
    return setTimeout(() => this.abortController.abort(), toMiliseconds(timer));
  }

  private getVerifyUrl = (verifyUrl?: string) => {
    let url = verifyUrl || VERIFY_SERVER;
    if (!TRUSTED_VERIFY_URLS.includes(url)) {
      this.logger.info(
        `verify url: ${url}, not included in trusted list, assigning default: ${VERIFY_SERVER}`,
      );
      url = VERIFY_SERVER;
    }
    return url;
  };

  private fetchPublicKey = async () => {
    try {
      this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
      const timeout = this.startAbortTimer(FIVE_SECONDS);
      const result = await fetch(`${this.verifyUrlV3}/public-key`, {
        signal: this.abortController.signal,
      });
      clearTimeout(timeout);
      return (await result.json()) as Jwk;
    } catch (e) {
      this.logger.warn(e);
    }
    return undefined;
  };

  private persistPublicKey = async (publicKey: Jwk) => {
    this.logger.debug(`persisting public key to local storage`, publicKey);
    await this.store.setItem(this.storeKey, publicKey);
    this.publicKey = publicKey;
  };

  private removePublicKey = async () => {
    this.logger.debug(`removing verify v2 public key from storage`);
    await this.store.removeItem(this.storeKey);
    this.publicKey = undefined;
  };

  private isValidJwtAttestation = async (attestation: string) => {
    const key = await this.getPublicKey();
    try {
      if (key) {
        const validation = this.validateAttestation(attestation, key);
        return validation;
      }
    } catch (e) {
      this.logger.error(e);
      this.logger.warn("error validating attestation");
    }
    const newKey = await this.fetchAndPersistPublicKey();
    try {
      if (newKey) {
        const validation = this.validateAttestation(attestation, newKey);
        return validation;
      }
    } catch (e) {
      this.logger.error(e);
      this.logger.warn("error validating attestation");
    }
    return undefined;
  };

  private getPublicKey = async () => {
    if (this.publicKey) return this.publicKey;
    return await this.fetchAndPersistPublicKey();
  };

  private fetchAndPersistPublicKey = async () => {
    if (this.fetchPromise) {
      await this.fetchPromise;
      return this.publicKey;
    }
    this.fetchPromise = new Promise(async (resolve) => {
      const key = await this.fetchPublicKey();
      if (!key) return;
      await this.persistPublicKey(key);
      resolve(key);
    });
    const key = await this.fetchPromise;
    this.fetchPromise = undefined;
    return key;
  };

  private validateAttestation = (attestation: string, key: Jwk) => {
    const result = verifyP256Jwt<JwkPayload>(attestation, key.publicKey);
    const validation = {
      hasExpired: toMiliseconds(result.exp) < Date.now(),
      payload: result,
    };

    if (validation.hasExpired) {
      this.logger.warn("resolve: jwt attestation expired");
      throw new Error("JWT attestation expired");
    }

    return {
      origin: validation.payload.origin,
      isScam: validation.payload.isScam,
      isVerified: validation.payload.isVerified,
    };
  };
}
</file>

<file path="packages/core/src/core.ts">
import { EventEmitter } from "events";

import { HeartBeat } from "@walletconnect/heartbeat";
import KeyValueStorage from "@walletconnect/keyvaluestorage";
import {
  ChunkLoggerController,
  generateChildLogger,
  generatePlatformLogger,
  getDefaultLoggerOptions,
  getLoggerContext,
} from "@walletconnect/logger";
import { CoreTypes, ICore } from "@walletconnect/types";

import {
  CORE_CONTEXT,
  CORE_DEFAULT,
  CORE_PROTOCOL,
  CORE_STORAGE_OPTIONS,
  CORE_VERSION,
  RELAYER_DEFAULT_RELAY_URL,
  TRANSPORT_TYPES,
  WALLETCONNECT_CLIENT_ID,
  WALLETCONNECT_LINK_MODE_APPS,
} from "./constants";
import {
  Crypto,
  EchoClient,
  EventClient,
  Expirer,
  JsonRpcHistory,
  Pairing,
  Relayer,
  Verify,
} from "./controllers";

export class Core extends ICore {
  public readonly protocol = CORE_PROTOCOL;
  public readonly version = CORE_VERSION;

  public readonly name: ICore["name"] = CORE_CONTEXT;
  public readonly relayUrl: ICore["relayUrl"];
  public readonly projectId: ICore["projectId"];
  public readonly customStoragePrefix: ICore["customStoragePrefix"];
  public events: ICore["events"] = new EventEmitter();
  public logger: ICore["logger"];
  public heartbeat: ICore["heartbeat"];
  public relayer: ICore["relayer"];
  public crypto: ICore["crypto"];
  public storage: ICore["storage"];
  public history: ICore["history"];
  public expirer: ICore["expirer"];
  public pairing: ICore["pairing"];
  public verify: ICore["verify"];
  public echoClient: ICore["echoClient"];
  public linkModeSupportedApps: ICore["linkModeSupportedApps"];
  public eventClient: ICore["eventClient"];

  private initialized = false;
  private logChunkController: ChunkLoggerController | null;

  static async init(opts?: CoreTypes.Options) {
    const core = new Core(opts);
    await core.initialize();
    const clientId = await core.crypto.getClientId();
    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);

    return core;
  }

  constructor(opts?: CoreTypes.Options) {
    super(opts);

    const globalCore = this.getGlobalCore(opts?.customStoragePrefix);
    if (globalCore) {
      try {
        this.customStoragePrefix = globalCore.customStoragePrefix;
        this.logger = globalCore.logger;
        this.heartbeat = globalCore.heartbeat;
        this.crypto = globalCore.crypto;
        this.history = globalCore.history;
        this.expirer = globalCore.expirer;
        this.storage = globalCore.storage;
        this.relayer = globalCore.relayer;
        this.pairing = globalCore.pairing;
        this.verify = globalCore.verify;
        this.echoClient = globalCore.echoClient;
        this.linkModeSupportedApps = globalCore.linkModeSupportedApps;
        this.eventClient = globalCore.eventClient;
        this.initialized = globalCore.initialized;
        this.logChunkController = globalCore.logChunkController;
        return globalCore;
      } catch (error) {
        console.warn("Failed to copy global core", error);
      }
    }

    this.projectId = opts?.projectId;
    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;
    this.customStoragePrefix = opts?.customStoragePrefix ? `:${opts.customStoragePrefix}` : "";

    const loggerOptions = getDefaultLoggerOptions({
      level: typeof opts?.logger === "string" && opts.logger ? opts.logger : CORE_DEFAULT.logger,
      name: CORE_CONTEXT,
    });

    const { logger, chunkLoggerController } = generatePlatformLogger({
      opts: loggerOptions,
      maxSizeInBytes: opts?.maxLogBlobSizeInBytes,
      loggerOverride: opts?.logger,
    });

    this.logChunkController = chunkLoggerController;

    if (this.logChunkController?.downloadLogsBlobInBrowser) {
      // @ts-ignore
      window.downloadLogsBlobInBrowser = async () => {
        // Have to null check twice becquse there is no guarantee
        // this.logChunkController.downloadLogsBlobInBrowser is always truthy
        if (this.logChunkController?.downloadLogsBlobInBrowser) {
          this.logChunkController?.downloadLogsBlobInBrowser({
            clientId: await this.crypto.getClientId(),
          });
        }
      };
    }

    this.logger = generateChildLogger(logger, this.name);
    this.heartbeat = new HeartBeat();
    this.crypto = new Crypto(this, this.logger, opts?.keychain);
    this.history = new JsonRpcHistory(this, this.logger);
    this.expirer = new Expirer(this, this.logger);
    this.storage = opts?.storage
      ? opts.storage
      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });
    this.relayer = new Relayer({
      core: this,
      logger: this.logger,
      relayUrl: this.relayUrl,
      projectId: this.projectId,
    });
    this.pairing = new Pairing(this, this.logger);
    this.verify = new Verify(this, this.logger, this.storage);
    this.echoClient = new EchoClient(this.projectId || "", this.logger);
    this.linkModeSupportedApps = [];
    this.eventClient = new EventClient(this, this.logger, opts?.telemetryEnabled);
    this.setGlobalCore(this);
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  // ---------- Public ----------------------------------------------- //

  public async start() {
    if (this.initialized) return;
    await this.initialize();
  }

  public async getLogsBlob() {
    return this.logChunkController?.logsToBlob({
      clientId: await this.crypto.getClientId(),
    });
  }

  public async addLinkModeSupportedApp(universalLink: string) {
    if (this.linkModeSupportedApps.includes(universalLink)) return;
    this.linkModeSupportedApps.push(universalLink);
    await this.storage.setItem(WALLETCONNECT_LINK_MODE_APPS, this.linkModeSupportedApps);
  }

  // ---------- Events ----------------------------------------------- //

  public on = (name: any, listener: any) => {
    return this.events.on(name, listener);
  };

  public once = (name: any, listener: any) => {
    return this.events.once(name, listener);
  };

  public off = (name: any, listener: any) => {
    return this.events.off(name, listener);
  };

  public removeListener = (name: any, listener: any) => {
    return this.events.removeListener(name, listener);
  };

  // ---------- Link-mode ----------------------------------------------- //

  public dispatchEnvelope = ({
    topic,
    message,
    sessionExists,
  }: {
    topic: string;
    message: string;
    sessionExists: boolean;
  }) => {
    if (!topic || !message) return;

    const payload = {
      topic,
      message,
      publishedAt: Date.now(),
      transportType: TRANSPORT_TYPES.link_mode,
    };

    this.relayer.onLinkMessageEvent(payload, { sessionExists });
  };

  // ---------- Private ----------------------------------------------- //

  private async initialize() {
    this.logger.trace(`Initialized`);
    try {
      await this.crypto.init();
      await this.history.init();
      await this.expirer.init();
      await this.relayer.init();
      await this.heartbeat.init();
      await this.pairing.init();
      this.linkModeSupportedApps = (await this.storage.getItem(WALLETCONNECT_LINK_MODE_APPS)) || [];

      this.initialized = true;
      this.logger.info(`Core Initialization Success`);
    } catch (error) {
      this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, error);
      this.logger.error((error as any).message);
      throw error;
    }
  }

  private getGlobalCore(customStoragePrefix = ""): Core | undefined {
    try {
      if (this.isGlobalCoreDisabled()) {
        return undefined;
      }
      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;

      const counterKey = `${globalCorePrefix}_count`;
      globalThis[counterKey] = (globalThis[counterKey] || 0) + 1;
      if (globalThis[counterKey] > 1) {
        console.warn(
          `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[counterKey]} times.`,
        );
      }

      return globalThis[globalCorePrefix];
    } catch (error) {
      console.warn("Failed to get global WalletConnect core", error);
      return undefined;
    }
  }

  private setGlobalCore(core: Core) {
    try {
      if (this.isGlobalCoreDisabled()) {
        return;
      }
      const customStoragePrefix = core.opts?.customStoragePrefix || "";
      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;
      globalThis[globalCorePrefix] = core;
    } catch (error) {
      console.warn("Failed to set global WalletConnect core", error);
    }
  }

  private isGlobalCoreDisabled() {
    try {
      return typeof process !== "undefined" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch (error) {
      return true;
    }
  }
}
</file>

<file path="packages/core/src/index.ts">
import { Core as WalletConnectCore } from "./core";

export * from "./constants";
export * from "./controllers";

export const Core = WalletConnectCore;
export default WalletConnectCore;
</file>

<file path="packages/core/test/shared/helpers.ts">
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { CoreTypes, ICore } from "@walletconnect/types";
import { DEFAULT_DB_NAME, MOCK_STORE_NAME, TEST_CORE_OPTIONS, storeTestValues } from "./values";
import { Core, Store } from "../../src";

export type MockStoreValue = { id: string; value: string };

export async function throttle(timeout: number) {
  return await new Promise<void>((resolve) =>
    setTimeout(() => {
      resolve();
    }, timeout),
  );
}

/**
 * Initializes a core instance with default options
 * Default uses custom db to isolate persistence tests
 * @param customOpts = custom core init opts
 * @returns Initialized core instance
 */
export const initCore = async (
  customOpts: CoreTypes.Options = { storageOptions: { database: DEFAULT_DB_NAME } },
) => {
  const coreOptions = {
    ...TEST_CORE_OPTIONS,
    ...customOpts,
  };
  const core = new Core(coreOptions);
  await core.start();
  return core;
};

/**
 * Initializes a store instance with default options
 * @param core = core to use for store
 * @returns Initialized store instance
 */
export const initStore = async (core: ICore) => {
  const logger = pino(getDefaultLoggerOptions({ level: "fatal" }));

  const store = new Store<string, MockStoreValue>(
    core,
    logger,
    MOCK_STORE_NAME,
    undefined,
    (val) => val.value,
  );
  await store.init();
  storeTestValues.forEach((val) => store.set(val.id, val));
  return store;
};

/**
 * Prevents gross code duplication in tests that require restarting core
 * @param beforeRestart function to run before each restart
 * @param afterRestart function to run after each restart
 * @param n_restarts number of times to restart core
 * @param customOpts custom core options
 */
export const restartCore = async (
  beforeRestart?: () => Promise<void>,
  afterRestart?: () => Promise<void>,
  n_restarts = 1,
  customOpts = { storageOptions: { database: DEFAULT_DB_NAME } },
) => {
  for (let i = 0; i < n_restarts; i++) {
    if (beforeRestart) await beforeRestart();
    await initCore(customOpts);
    if (afterRestart) await afterRestart();
  }
};

/**
 * Search for a topic in a list of records
 * @param records
 * @param topic
 * @returns true if topic is found, false otherwise
 */
export const searchRecords = (records: any, topic: string) => {
  for (const [_, record] of records.entries()) {
    if (record.topic === topic) return true;
  }
  return false;
};

export const waitForEvent = async (checkForEvent: (...args: any[]) => boolean) => {
  await new Promise((resolve) => {
    const intervalId = setInterval(() => {
      if (checkForEvent()) {
        clearInterval(intervalId);
        resolve({});
      }
    }, 100);
  });
};
</file>

<file path="packages/core/test/shared/index.ts">
export * from "./values";
export * from "./ws";
export * from "./helpers";
</file>

<file path="packages/core/test/shared/values.ts">
import { CoreTypes } from "@walletconnect/types";

export const TEST_RELAY_URL = process.env.TEST_RELAY_URL
  ? process.env.TEST_RELAY_URL
  : "ws://0.0.0.0:5555";

export const TEST_PROJECT_ID = process.env.TEST_PROJECT_ID
  ? process.env.TEST_PROJECT_ID
  : undefined;

export const TEST_PROJECT_ID_MOBILE = process.env.TEST_PROJECT_ID_MOBILE
  ? process.env.TEST_PROJECT_ID_MOBILE
  : undefined;

export const TEST_CORE_OPTIONS: CoreTypes.Options = {
  logger: "fatal",
  relayUrl: TEST_RELAY_URL,
  projectId: TEST_PROJECT_ID,
  storageOptions: {
    database: ":memory:",
  },
};

export const TEST_MOBILE_APP_ID = process.env.TEST_MOBILE_APP_ID
  ? process.env.TEST_MOBILE_APP_ID
  : undefined;

// default db name for persistent storage tests
export const DEFAULT_DB_NAME = "./test/tmp/persistent-test.db";

// default store name for persistent storage tests
export const MOCK_STORE_NAME = "persistent-store";

// default test values for persistent storage tests
export const storeTestValues = [
  { id: "1", value: "foo" },
  { id: "2", value: "bar" },
  { id: "3", value: "baz" },
];
</file>

<file path="packages/core/test/shared/ws.ts">
import { IRelayer } from "@walletconnect/types";

export async function disconnectSocket(relayer: IRelayer) {
  if (relayer && relayer.connected) {
    await relayer.transportClose();
  }
}
</file>

<file path="packages/core/test/core.spec.ts">
import { expect, describe, it } from "vitest";
import sinon from "sinon";
import Core from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Core", () => {
  it("does not duplicate initialization if `Core.start()` is called repeatedly", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    const cryptoInitSpy = sinon.spy();
    const relayerInitSpy = sinon.spy();
    const heartbeatInitSpy = sinon.spy();
    // Spy on subcontroller `init` as a proxy to the private `Core.initialize`.
    core.crypto.init = cryptoInitSpy;
    core.relayer.init = relayerInitSpy;
    core.heartbeat.init = heartbeatInitSpy;
    await core.start();
    await core.start();
    expect(cryptoInitSpy.callCount).to.equal(1);
    expect(relayerInitSpy.callCount).to.equal(1);
    expect(heartbeatInitSpy.callCount).to.equal(1);
  });
  it("saves core instance in global scope", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core = await Core.init(TEST_CORE_OPTIONS);
    expect(globalThis._walletConnectCore_).to.deep.equal(core);
    globalThis._walletConnectCore_ = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
  it("saves core instance in global scope with custom storage prefix", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
    expect(globalThis._walletConnectCore_test).to.deep.equal(core);
    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
    globalThis._walletConnectCore_test = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
  it("does not save core instance in global scope if disabled", async () => {
    process.env.DISABLE_GLOBAL_CORE = "true";
    await Core.init(TEST_CORE_OPTIONS);
    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
  });
  it("does not save core instance in global scope if disabled with custom storage prefix", async () => {
    process.env.DISABLE_GLOBAL_CORE = "true";
    await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
    expect(globalThis._walletConnectCore_test).to.deep.equal(undefined);
    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
  });
  it("saves multiple core instances in global scope", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core1 = await Core.init(TEST_CORE_OPTIONS);
    const core2 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
    expect(globalThis._walletConnectCore_).to.deep.equal(core1);
    expect(globalThis._walletConnectCore_test).to.deep.equal(core2);
    globalThis._walletConnectCore_ = undefined;
    globalThis._walletConnectCore_test = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
  it("saves multiple core instances in global scope with custom storage prefix", async () => {
    process.env.DISABLE_GLOBAL_CORE = "false";
    const core1 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test1" });
    const core2 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test2" });
    expect(globalThis._walletConnectCore_test1).to.deep.equal(core1);
    expect(globalThis._walletConnectCore_test2).to.deep.equal(core2);
    globalThis._walletConnectCore_test1 = undefined;
    globalThis._walletConnectCore_test2 = undefined;
    process.env.DISABLE_GLOBAL_CORE = "true";
  });
});
</file>

<file path="packages/core/test/crypto.spec.ts">
import { expect, describe, it, beforeEach } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import * as utils from "@walletconnect/utils";
import Sinon from "sinon";
import { Core, CORE_DEFAULT, Crypto } from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Crypto", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
  const core = new Core(TEST_CORE_OPTIONS);

  let crypto: Crypto;

  beforeEach(async () => {
    crypto = new Crypto(core, logger);
    await crypto.init();
  });

  it("initializes the keychain subcontroller a single time", async () => {
    const spy = Sinon.spy();
    const _crypto = new Crypto(core, logger);
    _crypto.keychain.init = spy;
    await _crypto.init();
    await _crypto.init();
    expect(spy.callCount).to.equal(1);
  });

  describe("generateKeyPair", () => {
    it("throws if not initialized", () => {
      const invalidCrypto = new Crypto(core, logger);
      expect(() => invalidCrypto.generateKeyPair()).to.throw("Not initialized. crypto");
    });
    it("generates a keyPair, sets it in the keychain and returns publicKey", async () => {
      const privateKey = utils.generateRandomBytes32();
      const publicKey = utils.generateRandomBytes32();
      // Stub `utils.generateKeyPair` to return predictable values.
      Sinon.stub(utils, "generateKeyPair").returns({ publicKey, privateKey });
      const keychainSpy = Sinon.spy();
      crypto.keychain.set = keychainSpy;
      const returnedPublicKey = await crypto.generateKeyPair();
      const [calledPublicKey, calledPrivateKey] = keychainSpy.getCall(0).args;
      expect(calledPublicKey).to.equal(publicKey);
      expect(calledPrivateKey).to.equal(privateKey);
      expect(returnedPublicKey).to.equal(publicKey);
    });
  });

  describe("generateSharedKey", () => {
    it("throws if not initialized", () => {
      const invalidCrypto = new Crypto(core, logger);
      expect(() => invalidCrypto.generateSharedKey("a", "b")).to.throw("Not initialized. crypto");
    });
    it("generates a shared symKey, sets it in the keychain and returns the topic", async () => {
      const overrideTopic = utils.generateRandomBytes32();
      const peerPublicKey = utils.generateRandomBytes32();
      const selfPublicKey = await crypto.generateKeyPair();
      const selfPrivateKey = crypto.keychain.get(selfPublicKey);
      const expectedSymKey = utils.deriveSymKey(selfPrivateKey, peerPublicKey);
      const spy = Sinon.spy();
      crypto.setSymKey = spy;
      await crypto.generateSharedKey(selfPublicKey, peerPublicKey, overrideTopic);
      const [calledSymKey, calledOverrideTopic] = spy.getCall(0).args;
      expect(calledSymKey).to.equal(expectedSymKey);
      expect(calledOverrideTopic).to.equal(overrideTopic);
    });
  });

  describe("setSymKey", () => {
    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.setSymKey("key")).rejects.toThrow("Not initialized. crypto");
    });
    it("sets expected topic-symKey pair in keychain, returns topic", async () => {
      const spy = Sinon.spy();
      crypto.keychain.set = spy;
      const fakeSymKey = utils.generateRandomBytes32();
      const topic = utils.hashKey(fakeSymKey);
      const returnedTopic = await crypto.setSymKey(fakeSymKey);
      const [calledTopic, calledSymKey] = spy.getCall(0).args;
      expect(calledTopic).to.equal(topic);
      expect(calledSymKey).to.equal(fakeSymKey);
      expect(returnedTopic).to.equal(topic);
    });
    it("sets expected topic-symKey pair in keychain if overrideTopic is passed", async () => {
      const spy = Sinon.spy();
      crypto.keychain.set = spy;
      const fakeSymKey = utils.generateRandomBytes32();
      const topic = utils.generateRandomBytes32();
      const returnedTopic = await crypto.setSymKey(fakeSymKey, topic);
      const [calledTopic, calledSymKey] = spy.getCall(0).args;
      expect(calledTopic).to.equal(topic);
      expect(calledSymKey).to.equal(fakeSymKey);
      expect(returnedTopic).to.equal(topic);
    });
  });

  describe("deleteKeyPair", () => {
    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.deleteKeyPair("key")).rejects.toThrow("Not initialized. crypto");
    });
    it("deletes the expected topic-symKey pair from keychain", async () => {
      const publicKey = utils.generateRandomBytes32();
      const spy = Sinon.spy();
      crypto.keychain.del = spy;
      await crypto.deleteKeyPair(publicKey);
      const [calledTopic] = spy.getCall(0).args;
      expect(calledTopic).to.equal(publicKey);
    });
  });

  describe("deleteSymKey", () => {
    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.deleteSymKey("key")).rejects.toThrow("Not initialized. crypto");
    });
    it("deletes the expected topic-symKey pair from keychain", async () => {
      const topic = utils.generateRandomBytes32();
      const spy = Sinon.spy();
      crypto.keychain.del = spy;
      await crypto.deleteSymKey(topic);
      const [calledTopic] = spy.getCall(0).args;
      expect(calledTopic).to.equal(topic);
    });
  });

  describe("encode", () => {
    const symKey = "5720435e682cd03ee45b484f9a213f0e3246a0ccc2cca183b72ab1cbfbefb702";
    const payload = { id: 1, jsonrpc: "2.0", result: "result" };
    // const encoded =
    //   "AG7iJl9mMl9K04REnuWaKLQU6kwMcQWUd69OxGOJ5/A+VRRKkxnKhBeIAl4JRaIft3qZKEfnBvc7/Fife1DWcERqAfJwzPI=";

    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.encode("topic", payload)).rejects.toThrow(
        "Not initialized. crypto",
      );
    });
    it.skip("encrypts `payload` if the passed topic is known", async () => {
      const topic = await crypto.setSymKey(symKey);
      // FIXME: needs to be tested dynamically because of random IV generation
      await crypto.encode(topic, payload);
    });
  });

  describe("decode", () => {
    const symKey = "5720435e682cd03ee45b484f9a213f0e3246a0ccc2cca183b72ab1cbfbefb702";
    const payload = { id: 1, jsonrpc: "2.0", result: "result" };
    const encoded =
      "AG7iJl9mMl9K04REnuWaKLQU6kwMcQWUd69OxGOJ5/A+VRRKkxnKhBeIAl4JRaIft3qZKEfnBvc7/Fife1DWcERqAfJwzPI=";

    it("throws if not initialized", async () => {
      const invalidCrypto = new Crypto(core, logger);
      await expect(invalidCrypto.decode("topic", "encoded")).rejects.toThrow(
        "Not initialized. crypto",
      );
    });
    it("decrypts `payload` if the passed topic is known", async () => {
      const topic = await crypto.setSymKey(symKey);
      const decoded = await crypto.decode(topic, encoded);
      expect(decoded).to.eql(payload);
    });
    it("should not throw on failed decrypt", async () => {
      const decoded = await crypto.decode("non-existent-topic", "dummymessage");
      expect(decoded).to.eql(undefined);
    });
  });
});
</file>

<file path="packages/core/test/events.spec.ts">
import { expect, describe, it } from "vitest";
import Core, {
  EVENTS_STORAGE_CLEANUP_INTERVAL,
  EVENT_CLIENT_CONTEXT,
  EVENT_CLIENT_PAIRING_ERRORS,
} from "../src";
import { TEST_CORE_OPTIONS } from "./shared";
import { toMiliseconds } from "@walletconnect/time";

describe("Events Client", () => {
  it("Init events client", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    expect(core.eventClient).toBeDefined();
    expect(core.eventClient.context).toBe(EVENT_CLIENT_CONTEXT);
    expect(core.eventClient.core).toBe(core);
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(0);
  });
  it("should create event", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe(type);
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(1);
  });

  it("should create multiple events", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const eventsToCreate = 10;
    for (let i = 0; i < eventsToCreate; i++) {
      const topic = "test topic";
      const trace = ["test trace", "test trace 2"];
      const eventType = "ERROR";
      const event = core.eventClient.createEvent({
        event: eventType,
        type,
        properties: {
          topic,
          trace,
        },
      });
      expect(event).toBeDefined();
      expect(event.props.event).toBe(eventType);
      expect(event.props.type).toBe(type);
      expect(event.props.properties.topic).toBe(topic);
      expect(event.props.properties.trace).toBe(trace);
    }
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(eventsToCreate);
  });
  it("should create & delete event", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe(type);
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(1);

    core.eventClient.deleteEvent({ eventId: event.eventId });

    // @ts-expect-error - accessing private properties for testing
    expect(core.eventClient.events.size).toBe(0);
  });
  it("should add trace", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe(type);
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    expect(event.addTrace).to.exist;
    expect(event.setError).to.exist;

    const additionalTrace = ["test trace 3", "test trace 4"];
    const additionlTraceLenght = additionalTrace.length;
    const defaultTraceLength = trace.length;
    event.addTrace(additionalTrace[0]);
    event.addTrace(additionalTrace[1]);
    expect(event.props.properties.trace.length).toEqual(defaultTraceLength + additionlTraceLenght);
    expect(event.props.properties.trace).toContain(additionalTrace[0]);
    expect(event.props.properties.trace).toContain(additionalTrace[1]);
  });
  it("should set error type", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      properties: {
        topic,
        trace,
      },
    });
    expect(event).toBeDefined();
    expect(event.props.event).toBe(eventType);
    expect(event.props.type).toBe("");
    expect(event.props.properties.topic).toBe(topic);
    expect(event.props.properties.trace).toBe(trace);
    expect(event.addTrace).to.exist;
    expect(event.setError).to.exist;

    event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);

    expect(event.props.type).toBe(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
  });
  it("should clean up old events", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    const event = core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });

    event.timestamp = Date.now() - toMiliseconds(EVENTS_STORAGE_CLEANUP_INTERVAL);
    // @ts-expect-error - accessing private properties
    expect(core.eventClient.events.size).toBe(1);
    await new Promise((resolve) => setTimeout(resolve, 5000));
    // @ts-expect-error - accessing private properties
    expect(core.eventClient.events.size).toBe(0);
  });
  it("should not store events when telemetry is disabled", async () => {
    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
    await core.start();
    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
    const topic = "test topic";
    const trace = ["test trace", "test trace 2"];
    const eventType = "ERROR";
    core.eventClient.createEvent({
      event: eventType,
      type,
      properties: {
        topic,
        trace,
      },
    });
    // @ts-expect-error - accessing private properties
    expect(core.eventClient.events.size).toBe(0);
  });

  it("should not send automatic init event", async () => {
    process.env.IS_VITEST = false as any;
    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
    let initCalled = false;
    // @ts-expect-error - accessing private properties
    core.eventClient.sendEvent = async (payload: any) => {
      initCalled = true;
      expect(payload).toBeDefined();
      expect(payload.length).to.eql(1);
      expect(payload[0].props.event).to.eql("INIT");
      expect(payload[0].props.properties.client_id).to.eql(await core.crypto.getClientId());
    };
    await core.start();
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(initCalled).to.eql(false);
    process.env.IS_VITEST = true as any;
  });

  it("should send init event", async () => {
    process.env.IS_VITEST = false as any;
    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
    let initCalled = false;
    // @ts-expect-error - accessing private properties
    core.eventClient.sendEvent = async (payload: any) => {
      initCalled = true;
      expect(payload).toBeDefined();
      expect(payload.length).to.eql(1);
      expect(payload[0].props.event).to.eql("INIT");
      expect(payload[0].props.properties.client_id).to.eql(await core.crypto.getClientId());
    };
    await core.start();
    await new Promise((resolve) => setTimeout(resolve, 500));

    expect(initCalled).to.eql(false);
    await core.eventClient.init();
    expect(initCalled).to.eql(true);
    if (!initCalled) {
      throw new Error("init not called");
    }
    process.env.IS_VITEST = true as any;
  });
});
</file>

<file path="packages/core/test/expirer.spec.ts">
import { pino, getDefaultLoggerOptions } from "@walletconnect/logger";
import { expect, describe, it } from "vitest";
import { calcExpiry, formatExpirerTarget } from "@walletconnect/utils";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";

import {
  Core,
  Expirer,
  EXPIRER_EVENTS,
  CORE_STORAGE_PREFIX,
  EXPIRER_STORAGE_VERSION,
  EXPIRER_CONTEXT,
  CORE_DEFAULT,
} from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";
import { generateRandomBytes32 } from "../../utils/src";

describe("Expirer", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const core = new Core(TEST_CORE_OPTIONS);
      const expirer = new Expirer(core, logger);
      expect(expirer.storageKey).to.equal(
        CORE_STORAGE_PREFIX + EXPIRER_STORAGE_VERSION + "//" + EXPIRER_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const expirer = new Expirer(core, logger);
      expect(expirer.storageKey).to.equal(
        CORE_STORAGE_PREFIX + EXPIRER_STORAGE_VERSION + ":test" + "//" + EXPIRER_CONTEXT,
      );
    });
  });

  it("should expire payload", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    await core.relayer.subscribe(generateRandomBytes32());
    // confirm the expirer is empty
    expect(core.expirer.length).to.eq(0);
    // set a payload
    const topic = "test";
    core.expirer.set(topic, calcExpiry(1));
    // confirm the expirer is not empty
    expect(core.expirer.length).to.eq(1);
    setTimeout(() => {
      // emit heartbeat pulse event to trigger expirer
      core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
    }, 1_000);
    await new Promise<void>((resolve) => {
      core.expirer.on(EXPIRER_EVENTS.expired, (payload: any) => {
        expect(payload.target).to.eq(formatExpirerTarget("topic", topic));
        // confirm the expirer is empty again
        expect(core.expirer.length).to.eq(0);
        resolve();
      });
    });
    await disconnectSocket(core.relayer);
  });
});
</file>

<file path="packages/core/test/history.spec.ts">
import { pino, getDefaultLoggerOptions } from "@walletconnect/logger";
import { vi, expect, describe, it, beforeEach, afterEach } from "vitest";
import { calcExpiry } from "@walletconnect/utils";
import { THIRTY_DAYS, toMiliseconds } from "@walletconnect/time";
import { ICore, JsonRpcRecord } from "@walletconnect/types";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  HISTORY_STORAGE_VERSION,
  HISTORY_CONTEXT,
  HISTORY_EVENTS,
  JsonRpcHistory,
} from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";

describe("history", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
  let core: ICore;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    await core.start();
  });
  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const core = new Core(TEST_CORE_OPTIONS);
      const history = new JsonRpcHistory(core, logger);
      expect(history.storageKey).to.equal(
        CORE_STORAGE_PREFIX + HISTORY_STORAGE_VERSION + "//" + HISTORY_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const history = new JsonRpcHistory(core, logger);
      expect(history.storageKey).to.equal(
        CORE_STORAGE_PREFIX + HISTORY_STORAGE_VERSION + ":test" + "//" + HISTORY_CONTEXT,
      );
    });
  });

  it("should set a record expiry", async () => {
    expect(core.history.records.size).to.eq(0);
    const request = {
      id: 1687958477400360,
      topic: "24fd0e137c4ccc655ca9e1b9d0e2481bb3d028dc307edc62d2a5190bb081c1b9",
      jsonrpc: "2.0",
      method: "test",
      params: {
        request: {
          method: "personal_sign",
          params: [
            "0x4d7920656d61696c206973206a6f686e40646f652e636f6d202d2031363837393538343737333838",
            "0x7770471b86c6dd889a6D81DA53Fb7eeE1F9a2ba7",
          ],
        },
        chainId: "eip155:5",
      },
    };
    core.history.set(request.topic, request);
    expect(core.history.records.size).to.eq(1);
    const record = core.history.records.get(request.id);
    expect(record).to.not.be.undefined;
    expect(record?.expiry).to.not.be.undefined;
    expect(record?.expiry).to.be.greaterThan(0);
    expect(toMiliseconds(record?.expiry || 0)).to.be.approximately(
      toMiliseconds(calcExpiry(THIRTY_DAYS)),
      10,
    ); // delta ~10ms execution variance

    vi.useFakeTimers();
    vi.advanceTimersByTime(toMiliseconds(calcExpiry(THIRTY_DAYS)));
    // move time forward to force expiry and wait for heartbeat to delete the record
    await new Promise<void>((resolve) => {
      core.history.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {
        expect(record).to.not.be.undefined;
        expect(record.id).to.eq(request.id);
        resolve();
      });
    });
    vi.useRealTimers();
    expect(core.history.records.size).to.eq(0);
  });
});
</file>

<file path="packages/core/test/keychain.spec.ts">
import { expect, describe, it } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  KeyChain,
  KEYCHAIN_CONTEXT,
  KEYCHAIN_STORAGE_VERSION,
} from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Keychain", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const core = new Core(TEST_CORE_OPTIONS);
      const keychain = new KeyChain(core, logger);
      expect(keychain.storageKey).to.equal(
        CORE_STORAGE_PREFIX + KEYCHAIN_STORAGE_VERSION + "//" + KEYCHAIN_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const keychain = new KeyChain(core, logger);
      expect(keychain.storageKey).to.equal(
        CORE_STORAGE_PREFIX + KEYCHAIN_STORAGE_VERSION + ":test" + "//" + KEYCHAIN_CONTEXT,
      );
    });
  });
});
</file>

<file path="packages/core/test/messages.spec.ts">
import { expect, describe, it, beforeEach } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { generateRandomBytes32, hashMessage } from "@walletconnect/utils";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  MESSAGE_DIRECTION,
  MESSAGES_CONTEXT,
  MESSAGES_STORAGE_VERSION,
  MessageTracker,
} from "../src";
import { TEST_CORE_OPTIONS } from "./shared";

describe("Messages", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  let messageTracker: MessageTracker;
  let topic: string;

  beforeEach(async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    messageTracker = new MessageTracker(logger, core);
    topic = generateRandomBytes32();
    await messageTracker.init();
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      expect(messageTracker.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + "//" + MESSAGES_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const messageTracker = new MessageTracker(logger, core);
      expect(messageTracker.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + ":test" + "//" + MESSAGES_CONTEXT,
      );
    });
  });

  describe("set", () => {
    it("throws if not initialized", async () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      await expect(invalidMessageTracker.set(topic, "some message")).rejects.toThrow(
        "Not initialized. messages",
      );
    });
    it("sets an entry on the messages map for a new topic-message pair", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      const key = hashMessage(mockMessage);
      const message = messageTracker.messages.get(topic) ?? {};
      expect(message[key]).to.equal(mockMessage);
      const messagesWithoutClientAck = messageTracker.messagesWithoutClientAck.get(topic) ?? {};
      expect(messagesWithoutClientAck[key]).to.equal(mockMessage);
    });
  });

  describe("get", () => {
    it("throws if not initialized", () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      expect(() => invalidMessageTracker.get(topic)).to.throw("Not initialized. messages");
    });
    it("returns an empty object for an unknown topic", () => {
      const message = messageTracker.get("fakeTopic");
      expect(message).to.deep.equal({});
    });
    it("returns the expected message based on the topic", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.get(topic)).to.deep.equal({ [hashMessage(mockMessage)]: mockMessage });
      const messagesWithoutClientAck = messageTracker.messagesWithoutClientAck.get(topic) ?? {};
      expect(messagesWithoutClientAck[hashMessage(mockMessage)]).to.equal(mockMessage);
    });
  });

  describe("has", () => {
    it("throws if not initialized", () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      expect(() => invalidMessageTracker.has(topic, "message")).to.throw(
        "Not initialized. messages",
      );
    });
    it("returns `false` by default", () => {
      expect(messageTracker.has("fakeTopic", "message")).to.be.false;
    });
    it("returns `true` if provided topic-message pair exists", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage);
      expect(messageTracker.has(topic, mockMessage)).to.be.true;
    });
  });

  describe("del", () => {
    it("throws if not initialized", async () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      await expect(invalidMessageTracker.del(topic)).rejects.toThrow("Not initialized. messages");
    });
    it("removes the matching topic-message pair for the provided topic", async () => {
      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.inbound);
      expect(messageTracker.messages.size).to.equal(1);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(1);
      await messageTracker.del(topic);
      expect(messageTracker.messages.size).to.equal(0);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
    });
  });

  describe("ack", () => {
    it("throws if not initialized", async () => {
      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
      await expect(invalidMessageTracker.ack(topic, "message")).rejects.toThrow(
        "Not initialized. messages",
      );
    });
    it("removes the the topic-message pair from `messagesWithoutClientAck` when acknowledged", async () => {
      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.inbound);
      await messageTracker.ack(topic, "message");
      expect(messageTracker.messages.size).to.equal(1);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
    });

    it("doesn't store outbound messages in `messagesWithoutClientAck`", async () => {
      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.outbound);
      expect(messageTracker.messages.size).to.equal(1);
      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
    });

    it("doesn't throw if the topic-message pair doesn't exist", async () => {
      expect(await messageTracker.ack(topic, "message")).to.be.undefined;
    });
  });

  describe("getWithoutAck", () => {
    it("returns an empty map if no topics are provided", () => {
      expect(messageTracker.getWithoutAck([])).to.deep.equal({});
    });

    it("returns empty map if no messages are available for the provided topic", () => {
      expect(messageTracker.getWithoutAck([topic])).to.deep.equal({ [topic]: [] });
    });
    it("returns correct messages for the provided topic", async () => {
      const mockMessage = "test message";
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic])).to.deep.equal({
        [topic]: [mockMessage],
      });
    });
    it("returns correct messages for multiple provided topics", async () => {
      const mockMessage = "test message";
      const topic2 = generateRandomBytes32();
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic2, mockMessage, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic, topic2])).to.deep.equal({
        [topic]: [mockMessage],
        [topic2]: [mockMessage],
      });
    });
    it("returns correct messages for multiple provided topics. Test 2", async () => {
      const mockMessage = "test message";
      const mockMessage2 = "test message 2";
      const mockMessage3 = "test message 3";
      const topic2 = generateRandomBytes32();
      const topic3 = generateRandomBytes32();
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic2, mockMessage2, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic3, mockMessage3, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic2, topic3])).to.deep.equal({
        [topic2]: [mockMessage2],
        [topic3]: [mockMessage3],
      });
    });
    it("returns correct messages for multiple provided topics. Test 3", async () => {
      const mockMessage = "test message";
      const mockMessage2 = "test message 2";
      const mockMessage3 = "test message 3";
      const topic2 = generateRandomBytes32();
      const topic3 = generateRandomBytes32();
      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic, mockMessage2, MESSAGE_DIRECTION.inbound);
      await messageTracker.set(topic2, mockMessage3, MESSAGE_DIRECTION.inbound);
      expect(messageTracker.getWithoutAck([topic, topic2, topic3])).to.deep.equal({
        [topic]: [mockMessage, mockMessage2],
        [topic2]: [mockMessage3],
        [topic3]: [],
      });
    });
  });
});
</file>

<file path="packages/core/test/pairing.spec.ts">
import { expect, describe, it, beforeEach, afterEach } from "vitest";
import { ICore } from "@walletconnect/types";
import { Core, CORE_PROTOCOL, CORE_VERSION, PAIRING_EVENTS, SUBSCRIBER_EVENTS } from "../src";
import { TEST_CORE_OPTIONS, disconnectSocket, waitForEvent } from "./shared";
import { calcExpiry, generateRandomBytes32, parseUri, toBase64 } from "@walletconnect/utils";
import { FIVE_MINUTES } from "@walletconnect/time";

const createCoreClients: () => Promise<{ coreA: ICore; coreB: ICore }> = async () => {
  const coreA = new Core(TEST_CORE_OPTIONS);
  const coreB = new Core(TEST_CORE_OPTIONS);
  await coreA.start();
  await coreB.start();
  return { coreA, coreB };
};

describe("Pairing", () => {
  let coreA: ICore;
  let coreB: ICore;

  beforeEach(async () => {
    const coreClients = await createCoreClients();
    coreA = coreClients.coreA;
    coreB = coreClients.coreB;
  });

  afterEach(async () => {
    await disconnectSocket(coreA.relayer);
    await disconnectSocket(coreB.relayer);
  });

  describe("init", () => {
    it("initializes", () => {
      expect(coreA.pairing.pairings).toBeDefined();
      expect(coreB.pairing.pairings).toBeDefined();
    });
  });

  describe("create", () => {
    it("returns the pairing topic and URI in expected format", async () => {
      const { topic, uri } = await coreA.pairing.create();
      expect(topic.length).toBe(64);
      expect(uri.startsWith(`${CORE_PROTOCOL}:${topic}@${CORE_VERSION}`)).toBe(true);
    });
  });

  describe("pair", () => {
    it("can pair via provided URI", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });
    it("can pair via base64 provided URI", async () => {
      const { uri } = await coreA.pairing.create();
      const encodedUri = toBase64(uri, true);
      await coreB.pairing.pair({ uri: encodedUri });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });

    it("can pair via provided android deeplink URI", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri: `wc://${uri}` });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });

    it("can pair via provided iOS deeplink URI", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri: `wc:${uri}` });

      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(false);
    });

    it("can auto-activate the pairing on pair step", async () => {
      const { uri } = await coreA.pairing.create();
      await coreB.pairing.pair({ uri, activatePairing: true });

      expect(coreA.pairing.getPairings()[0].active).toBe(false);
      expect(coreB.pairing.getPairings()[0].active).toBe(true);
    });

    it("throws when pairing is attempted on topic that already exists", async () => {
      const { topic, uri } = await coreA.pairing.create();
      coreA.pairing.pairings.get(topic).active = true;
      await expect(coreA.pairing.pair({ uri })).rejects.toThrowError(
        `Pairing already exists: ${topic}`,
      );
    });

    it("should not override existing keychain values", async () => {
      const keychainTopic = generateRandomBytes32();
      const keychainValue = generateRandomBytes32();
      let { topic, uri } = await coreA.pairing.create();
      coreA.crypto.keychain.set(keychainTopic, keychainValue);
      uri = uri.replace(topic, keychainTopic);
      await coreA.pairing.pair({ uri });
      expect(coreA.crypto.keychain.get(keychainTopic)).toBe(keychainValue);
    });
  });

  describe("activate", () => {
    it("can activate a pairing", async () => {
      const { topic } = await coreA.pairing.create();

      const inactivePairing = coreA.pairing.pairings.get(topic);
      expect(inactivePairing.active).toBe(false);
      await coreA.pairing.activate({ topic });
      const activePairing = coreA.pairing.pairings.get(topic);
      expect(activePairing.active).toBe(true);
      // inactive pairing should have an expiry of 5 minutes
      expect(inactivePairing.expiry).to.be.approximately(calcExpiry(FIVE_MINUTES), 5);
      // active pairing should still have an expiry of 5 minutes
      expect(activePairing.expiry).to.be.approximately(calcExpiry(FIVE_MINUTES), 5);
    });
  });

  describe("updateExpiry", () => {
    it("can update a pairing's expiry", async () => {
      const mockExpiry = 11111111;
      const { topic } = await coreA.pairing.create();

      await coreA.pairing.updateExpiry({ topic, expiry: mockExpiry });
      expect(coreA.pairing.pairings.get(topic).expiry).toBe(mockExpiry);
    });
  });

  describe("updateMetadata", () => {
    it("can update a pairing's `peerMetadata`", async () => {
      const mockMetadata = {
        name: "Mock",
        description: "Mock Metadata",
        url: "https://mockurl.com",
        icons: [],
      };
      const { topic } = await coreA.pairing.create();

      expect(coreA.pairing.pairings.get(topic).peerMetadata).toBeUndefined();
      await coreA.pairing.updateMetadata({ topic, metadata: mockMetadata });
      expect(coreA.pairing.pairings.get(topic).peerMetadata).toEqual(mockMetadata);
    });
  });

  describe("formatUriFromPairing", () => {
    it("should generate pairing uri from pairing", async () => {
      let generatedUri = "";
      coreA.pairing.events.once("pairing_create", (payload) => {
        generatedUri = coreA.pairing.formatUriFromPairing(payload);
      });
      const { uri } = await coreA.pairing.create({
        methods: ["eth_sendTransaction", "personal_sign"],
      });
      expect(generatedUri).to.be.eq(uri);
      const parsedUri = parseUri(uri);
      const parsedGeneratedUri = parseUri(generatedUri);
      expect(parsedGeneratedUri).to.deep.equal(parsedUri);
    });
  });

  describe("ping", () => {
    it("clients can ping each other", async () => {
      const { uri, topic } = await coreA.pairing.create();
      let gotPing = false;

      coreB.pairing.events.on("pairing_ping", () => {
        gotPing = true;
      });

      await coreB.pairing.pair({ uri });
      await coreA.pairing.ping({ topic });
      await waitForEvent(() => gotPing);

      expect(gotPing).toBe(true);
    });
  });

  describe("disconnect", () => {
    it("can disconnect a known pairing", async () => {
      const { uri, topic } = await coreA.pairing.create();
      let hasDeleted = false;

      coreA.pairing.events.on("pairing_delete", () => {
        hasDeleted = true;
      });

      await coreB.pairing.pair({ uri });
      await coreB.pairing.disconnect({ topic });
      await waitForEvent(() => hasDeleted);

      expect(coreA.pairing.pairings.keys.length).toBe(0);
      expect(coreB.pairing.pairings.keys.length).toBe(0);
      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
    });
  });

  describe("validations", () => {
    describe("pair", () => {
      it("throws when no params are passed", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.pair()).rejects.toThrowError(
          "Missing or invalid. pair() params: undefined",
        );
      });

      it("throws when empty uri is provided", async () => {
        await expect(coreA.pairing.pair({ uri: "" })).rejects.toThrowError(
          "Missing or invalid. pair() uri: ",
        );
      });

      it("throws when invalid uri is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.pair({ uri: 123 })).rejects.toThrowError(
          "Missing or invalid. pair() uri: 123",
        );
      });

      it("throws when no uri is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.pair({ uri: undefined })).rejects.toThrowError(
          "Missing or invalid. pair() uri: undefined",
        );
      });
      it("throws when uri missing relay protocol is provided", async () => {
        // Using v1 pairing URI as it is unsupported
        const v1PairingUri =
          "wc:e9d6ef98-6b65-490b-8726-a21e1afb181d@1?bridge=https%3A%2F%2Fwalletconnect.com&key=73f096cb97aaee97b3d9871ced35fdce1668e652db3d39423ea6cd22e14528bf";
        await expect(
          coreA.pairing.pair({
            uri: v1PairingUri,
          }),
        ).rejects.toThrowError("Missing or invalid. pair() uri#relay-protocol");
      });
      it("throws when uri missing relay protocol is provided", async () => {
        await expect(
          coreA.pairing.pair({
            uri: "wc:e9d6ef98-6b65-490b-8726-a21e1afb181d@1?bridge=https%3A%2F%2Fwalletconnect.com&relay-protocol=irn",
          }),
        ).rejects.toThrowError("Missing or invalid. pair() uri#symKey");
      });
    });

    describe("ping", () => {
      it("throws when no params are passed", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.ping()).rejects.toThrowError(
          "Missing or invalid. ping() params: undefined",
        );
      });

      it("throws when invalid topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.ping({ topic: 123 })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: 123",
        );
      });

      it("throws when empty topic is provided", async () => {
        await expect(coreA.pairing.ping({ topic: "" })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: ",
        );
      });

      it("throws when no topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.ping({ topic: undefined })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: undefined",
        );
      });

      it("throws when non existent topic is provided", async () => {
        await expect(coreA.pairing.ping({ topic: "none" })).rejects.toThrowError(
          "No matching key. pairing topic doesn't exist: none",
        );
      });
    });

    describe("disconnect", () => {
      it("throws when no params are passed", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.disconnect()).rejects.toThrowError(
          "Missing or invalid. disconnect() params: undefined",
        );
      });

      it("throws when invalid topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.disconnect({ topic: 123 })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: 123",
        );
      });

      it("throws when empty topic is provided", async () => {
        await expect(coreA.pairing.disconnect({ topic: "" })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: ",
        );
      });

      it("throws when no topic is provided", async () => {
        // @ts-expect-error - ignore TS error to test runtime validation
        await expect(coreA.pairing.disconnect({ topic: undefined })).rejects.toThrowError(
          "Missing or invalid. pairing topic should be a string: undefined",
        );
      });

      it("throws when non existent topic is provided", async () => {
        await expect(coreA.pairing.disconnect({ topic: "none" })).rejects.toThrowError(
          "No matching key. pairing topic doesn't exist: none",
        );
      });
    });
  });
  describe("events", () => {
    it("should emit 'pairing_create' event", async () => {
      let pairingCreatedEvent = false;
      coreB.pairing.events.on(PAIRING_EVENTS.create, () => (pairingCreatedEvent = true));
      const { uri } = await coreA.pairing.create();
      coreB.pairing.pair({ uri });
      await waitForEvent(() => pairingCreatedEvent);
    });
    it("should store pairing before subscribing to its topic", async () => {
      let pairingCreatedEvent = false;
      let pairingCreatedEventTime = 0;
      let subscriptionCreatedEvent = false;
      let subscriptionCreatedEventTime = 0;
      const { uri } = await coreA.pairing.create();
      const { topic } = parseUri(uri);
      coreB.pairing.events.on(PAIRING_EVENTS.create, () => {
        pairingCreatedEventTime = performance.now();
        pairingCreatedEvent = true;
      });

      coreB.relayer.subscriber.events.on(SUBSCRIBER_EVENTS.created, () => {
        subscriptionCreatedEventTime = performance.now();
        subscriptionCreatedEvent = true;
      });

      coreB.pairing.pair({ uri });
      await waitForEvent(() => pairingCreatedEvent);
      await waitForEvent(() => subscriptionCreatedEvent);
      expect(coreB.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.values[0].topic).toEqual(topic);
      expect(subscriptionCreatedEventTime).toBeGreaterThan(pairingCreatedEventTime);
    });
  });
});
</file>

<file path="packages/core/test/persistence.spec.ts">
import { expect, describe, it, beforeEach, afterEach } from "vitest";
import { ICore, IStore } from "@walletconnect/types";
import {
  MockStoreValue,
  TEST_CORE_OPTIONS,
  disconnectSocket,
  initCore,
  initStore,
  restartCore,
  searchRecords,
  storeTestValues,
  waitForEvent,
} from "./shared";
import { Core } from "../src";
import { generateRandomBytes32 } from "@walletconnect/utils";

describe("Persistence", () => {
  let core: ICore;
  let store: IStore<string, MockStoreValue>;

  beforeEach(async () => {
    core = await initCore();
  });

  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  it("should persist store values across restarts", async () => {
    store = await initStore(core);
    await restartCore();
    expect(store.getAll()).to.toMatchObject(storeTestValues);
  });

  it("should persist store values of PAIRINGS across restarts", async () => {
    // --- setup ---
    const coreA = core; // alias for clarity
    const coreB = new Core(TEST_CORE_OPTIONS);
    await coreB.start();

    // --- after restart routine ---
    const afterRestart = async () => {
      const { uri, topic } = await coreA.pairing.create();
      let hasDeleted = false;
      coreA.pairing.events.on("pairing_delete", () => {
        hasDeleted = true;
      });

      await coreB.pairing.pair({ uri });

      // pairing was created
      expect(coreA.pairing.pairings.keys.length).toBe(1);
      expect(coreB.pairing.pairings.keys.length).toBe(1);

      // topic does not exist in history
      expect(searchRecords(coreA.history.records, topic)).toBe(false);
      expect(searchRecords(coreB.history.records, topic)).toBe(false);

      // ensure that keychain is updated
      expect(coreA.crypto.keychain.keychain.has(topic)).toBe(true);
      expect(coreB.crypto.keychain.keychain.has(topic)).toBe(true);

      // ensure that expiry is updated
      expect(coreA.expirer.values.length).toBe(1);
      expect(coreB.expirer.values.length).toBe(1);

      await coreB.pairing.disconnect({ topic });

      await waitForEvent(() => hasDeleted);

      // pairing was deleted
      expect(coreA.pairing.pairings.keys.length).toBe(0);
      expect(coreB.pairing.pairings.keys.length).toBe(0);

      // topic was added to history
      expect(searchRecords(coreA.history.records, topic)).toBe(true);
      expect(searchRecords(coreB.history.records, topic)).toBe(true);

      // keychain was updated
      expect(coreA.crypto.keychain.keychain.has(topic)).toBe(false);
      expect(coreB.crypto.keychain.keychain.has(topic)).toBe(false);

      // ensure that expiry is updated
      expect(coreA.expirer.values.length).toBe(0);
      expect(coreB.expirer.values.length).toBe(0);
    };

    // start routine
    await restartCore(undefined, afterRestart);

    // final check of pairings
    expect(coreA.pairing.getPairings()).to.deep.equal(coreB.pairing.getPairings());
  });

  it("should persist store values of SESSIONS across restarts", async () => {
    // --- setup ---
    const subscriber = core.relayer.subscriber;
    const datashare = { topic: generateRandomBytes32() };

    // --- before core restarts routine ---
    const beforeRestart = async () => {
      const topic = generateRandomBytes32();
      await subscriber.subscribe(topic);
      datashare.topic = topic;
    };

    // --- after core restarts routine ---
    const afterRestart = async () => {
      // check that the session, topic were restored
      expect(subscriber.subscriptions.size).to.equal(1);
      expect(subscriber.topics).to.contain(datashare.topic);

      await subscriber.unsubscribe(datashare.topic);

      // check that the session, topic were cleared correctly
      expect(subscriber.subscriptions.size).to.equal(0);
      expect(subscriber.topics.length).to.equal(0);
    };

    // start routine
    await restartCore(beforeRestart, afterRestart);
  });
});
</file>

<file path="packages/core/test/publisher.spec.ts">
import { expect, describe, it, beforeEach, afterEach } from "vitest";
import Sinon from "sinon";
import { ICore } from "@walletconnect/types";
import { generateRandomBytes32, hashMessage } from "@walletconnect/utils";
import { Publisher } from "../src/controllers/publisher";
import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";

import { Core, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS, throttle } from "./shared";
import { getBigIntRpcId } from "@walletconnect/jsonrpc-utils";

const getId = () => {
  return getBigIntRpcId().toString() as any;
};

describe("Publisher", () => {
  let core: ICore;
  let publisher: Publisher;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    publisher = core.relayer.publisher as Publisher;
  });

  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  describe("init", () => {
    it("should process queue", async () => {
      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 0 };
      const items = [
        {
          topic: generateRandomBytes32(),
          message: "itemA",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemB",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemC",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemD",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemE",
          opts: { ...opts, id: getId() },
        },
      ];

      const requestSpy = Sinon.spy();
      publisher.relayer.request = requestSpy;

      // Manually set some items in the queue.
      items.forEach((item) => publisher.queue.set(item.opts.id.toString(), item));
      expect(publisher.queue.size).to.equal(items.length);
      // Emit heartbeat pulse event
      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);

      // Emit ACKs
      items.forEach((item) =>
        core.relayer.events.emit(RELAYER_EVENTS.message_ack, { id: item.opts.id }),
      );

      // -> Queue should clear after the ACKs.
      expect(publisher.queue.size).to.equal(0);
      // Emit heartbeat pulse event
      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
      await throttle(100);
      // Emit heartbeat pulse event
      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);

      // -> Queue should still be clear after the pulses.
      expect(publisher.queue.size).to.equal(0);
      // -> `request` should not have been called more times than the n items regardless of the n of pulses.
      expect(requestSpy.callCount).to.equal(items.length);
    });
    it("should process queue with delayed ACK", () => {
      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 0 };
      const items = [
        {
          topic: generateRandomBytes32(),
          message: "itemA",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemB",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemC",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemD",
          opts: { ...opts, id: getId() },
        },
        {
          topic: generateRandomBytes32(),
          message: "itemE",
          opts: { ...opts, id: getId() },
        },
      ];

      const requestSpy = Sinon.spy();
      publisher.relayer.request = requestSpy;

      // Manually set some items in the queue.
      items.forEach((item) => publisher.queue.set(item.opts.id.toString(), item));
      expect(publisher.queue.size).to.equal(items.length);

      const pulsesBeforeAck = 5;
      // emit multiple pulses to ensure queue is works correctly if ACK is delayed
      Array.from(Array(pulsesBeforeAck).keys()).forEach(async () => {
        publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
        await throttle(100);
      });

      // Emit ACKs
      items.forEach((item) =>
        core.relayer.events.emit(RELAYER_EVENTS.message_ack, { id: item.opts.id }),
      );

      // -> Queue should clear after the ACKs.
      expect(publisher.queue.size).to.equal(0);
      // -> all requests should have been sent once per pulse
      const expectedCallCount = items.length * pulsesBeforeAck;
      expect(requestSpy.callCount).to.equal(expectedCallCount);

      const pulsesAfterAck = 5;
      // emit additional pulses
      Array.from(Array(pulsesAfterAck).keys()).forEach(async () => {
        publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
        await throttle(100);
      });

      // request count should stay the same even after additional pulses
      expect(requestSpy.callCount).to.equal(expectedCallCount);
    });
  });

  describe("publish", () => {
    let topic: string;
    let requestSpy: Sinon.SinonSpy;

    beforeEach(() => {
      requestSpy = Sinon.spy();
      topic = generateRandomBytes32();
      publisher.relayer.request = requestSpy;
    });

    it("calls `provider.request` with the expected request shape", async () => {
      const message = "test message";
      const id = getId();
      await publisher.publish(topic, message, { id });
      expect(requestSpy.callCount).to.equal(1);
      expect(requestSpy.getCall(0).args[0]).to.deep.equal({
        method: "irn_publish",
        params: {
          topic,
          message,
          prompt: false,
          ttl: PUBLISHER_DEFAULT_TTL,
          tag: 0,
          attestation: undefined,
        },
        id,
      });
    });
    it("allows overriding of defaults via `opts` param", async () => {
      const message = "test message";
      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 1, id: getId(1) };
      await publisher.publish(topic, message, opts);
      expect(requestSpy.callCount).to.equal(1);
      expect(requestSpy.getCall(0).args[0]).to.deep.equal({
        method: "irn_publish",
        params: {
          topic,
          message,
          prompt: opts.prompt,
          ttl: opts.ttl,
          tag: opts.tag,
          attestation: undefined,
        },
        id: opts.id,
      });
    });
  });
});
</file>

<file path="packages/core/test/relayer.spec.ts">
import { expect, describe, it, beforeEach, afterEach, vi } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";

import {
  Core,
  CORE_DEFAULT,
  Relayer,
  RELAYER_DEFAULT_RELAY_URL,
  RELAYER_EVENTS,
  RELAYER_PROVIDER_EVENTS,
  RELAYER_SUBSCRIBER_SUFFIX,
  SUBSCRIBER_EVENTS,
  TRANSPORT_TYPES,
} from "../src";
import {
  disconnectSocket,
  TEST_MOBILE_APP_ID,
  TEST_CORE_OPTIONS,
  TEST_PROJECT_ID_MOBILE,
  throttle,
} from "./shared";
import { ICore, IRelayer, ISubscriber } from "@walletconnect/types";
import Sinon from "sinon";
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";
import { createExpiringPromise, generateRandomBytes32, hashMessage } from "@walletconnect/utils";
import * as utils from "@walletconnect/utils";

describe("Relayer", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  let core: ICore;
  let relayer: IRelayer;
  const randomTopic = generateRandomBytes32();

  describe("init", () => {
    let initSpy: Sinon.SinonSpy;
    beforeEach(async () => {
      initSpy = Sinon.spy();
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
      relayer.subscriber.topicMap.set(randomTopic, randomTopic);
    });
    afterEach(async () => {
      await disconnectSocket(relayer);
    });

    it("should not throw unhandled on network disconnect when there is no provider instance", async () => {
      relayer.messages.init = initSpy;
      relayer.subscriber.topicMap.clear();
      await relayer.init();
      expect(relayer.provider).to.be.empty;
      expect(relayer.connected).to.be.false;
      // @ts-expect-error - private property
      relayer.hasExperiencedNetworkDisruption = true;
      // @ts-expect-error - private method
      await relayer.transportDisconnect();
    });
    it("initializes a MessageTracker", async () => {
      relayer.messages.init = initSpy;
      await relayer.init();
      expect(initSpy.calledOnce).to.be.true;
    });
    it("initializes a Subscriber", async () => {
      relayer.subscriber.init = initSpy;
      await relayer.init();
      expect(initSpy.calledOnce).to.be.true;
    });
    it("initializes a Publisher", async () => {
      relayer.subscriber.init = initSpy;
      await relayer.init();
      expect(initSpy.calledOnce).to.be.true;
    });
    it("initializes a JsonRpcProvider", async () => {
      expect(relayer.provider).to.be.empty;
      await relayer.init();
      await relayer.transportOpen();
      expect(relayer.provider).not.to.be.empty;
      expect(relayer.provider instanceof JsonRpcProvider).to.be.true;
    });
    it("registers provider event listeners", async () => {
      const emitSpy = Sinon.spy();
      await relayer.init();
      await relayer.transportOpen();
      relayer.events.emit = emitSpy;
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.connect);
      expect(emitSpy.calledOnceWith(RELAYER_EVENTS.connect)).to.be.true;
    });
  });

  describe("publish", () => {
    beforeEach(async () => {
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
    });

    const topic = "abc123";
    const message = "publish me";
    it("calls `publisher.publish` with provided args", async () => {
      const spy = Sinon.spy();
      relayer.publisher.publish = spy;
      await relayer.publish(topic, message);
      expect(spy.calledOnceWith(topic, message)).to.be.true;
    });
    it("records a message with provided args", async () => {
      const spy = Sinon.spy();
      relayer.publisher.publish = () => Promise.resolve();
      relayer.messages.set = spy;
      await relayer.publish(topic, message);
      expect(spy.calledOnceWith(topic, message)).to.be.true;
    });
  });

  describe("subscribe", () => {
    beforeEach(async () => {
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
    });
    it("returns the id provided by calling `subscriber.subscribe` with the passed topic", async () => {
      const spy = Sinon.spy(
        (topic) =>
          new Promise((resolve) => {
            relayer.subscriber.events.emit(SUBSCRIBER_EVENTS.created, { topic });
            resolve(topic);
          }),
      );
      relayer.subscriber.subscribe = spy;

      const testTopic = "abc123";
      let id;
      await new Promise<void>(async (resolve) => {
        id = await relayer.subscribe(testTopic);
        resolve();
      });
      // @ts-expect-error
      expect(spy.calledOnceWith(testTopic)).to.be.true;
      expect(id).to.eq(testTopic);
    });

    it("should subscribe multiple topics", async () => {
      const spy = Sinon.spy(
        (topic) =>
          new Promise((resolve) => {
            relayer.subscriber.events.emit(SUBSCRIBER_EVENTS.created, { topic });
            resolve(topic);
          }),
      );
      relayer.subscriber.subscribe = spy;
      const subscriber = relayer.subscriber as ISubscriber;
      // record the number of listeners before subscribing
      const startNumListeners = subscriber.events.listenerCount(SUBSCRIBER_EVENTS.created);
      const topicsToSubscribe = Array.from(Array(5).keys()).map(() => generateRandomBytes32());
      const subscribePromises = topicsToSubscribe.map((topic) => relayer.subscribe(topic));
      await Promise.all([...subscribePromises]);
      // expect the number of listeners to be the same as before subscribing to confirm proper cleanup
      expect(subscriber.events.listenerCount(SUBSCRIBER_EVENTS.created)).to.eq(startNumListeners);
    });

    it("should throw when subscribe reaches a publish timeout", async () => {
      relayer.subscriber.subscribeTimeout = 5_000;
      relayer.request = () => {
        return new Promise<void>((_, reject) => {
          setTimeout(() => {
            reject(new Error("Subscription timeout"));
          }, 100_000);
        });
      };
      const topic = generateRandomBytes32();
      await expect(relayer.subscribe(topic)).rejects.toThrow(
        `Subscribing to ${topic} failed, please try again`,
      );
    });

    it("should throw when subscribe publish fails", async () => {
      await relayer.transportOpen();
      await relayer.toEstablishConnection();
      relayer.subscriber.subscribeTimeout = 5_000;
      relayer.request = () => {
        return new Promise<void>((resolve) => {
          resolve();
        });
      };
      const topic = generateRandomBytes32();
      await expect(relayer.subscribe(topic)).rejects.toThrow(
        `Subscribing to ${topic} failed, please try again`,
      );
    });

    it("should be able to resubscribe on topic that already exists", async () => {
      const topic = generateRandomBytes32();
      const id = await relayer.subscribe(topic);
      const expectedId = hashMessage(topic + (await core.crypto.getClientId()));
      const a = await relayer.subscribe(topic);
      const b = await relayer.subscribe(topic);
      const c = await relayer.subscribe(topic);
      expect(a).to.equal(id);
      expect(a).to.equal(b);
      expect(b).to.equal(c);
      expect(a).to.equal(expectedId);
      expect(b).to.equal(expectedId);
      expect(c).to.equal(expectedId);
      expect(id).to.equal(expectedId);
    });
  });

  describe("unsubscribe", () => {
    beforeEach(async () => {
      core = new Core(TEST_CORE_OPTIONS);
      relayer = core.relayer;
      await core.start();
      relayer.subscriber.topicMap.set(randomTopic, randomTopic);
      await relayer.transportOpen();
    });
    it("calls `subscriber.unsubscribe` with the passed topic", async () => {
      const spy = Sinon.spy();
      relayer.subscriber.unsubscribe = spy;
      await relayer.unsubscribe("abc123");
      expect(spy.calledOnceWith("abc123")).to.be.true;
    });

    describe("onProviderPayload", () => {
      const validPayload: JsonRpcRequest = {
        id: 123,
        jsonrpc: "2.0",
        method: "mock" + RELAYER_SUBSCRIBER_SUFFIX,
        params: {
          id: "abc123",
          data: {
            topic: "ababab",
            message: "deadbeef",
            publishedAt: 1677151760537,
            transportType: TRANSPORT_TYPES.relay,
            attestation: undefined,
          },
        },
      };

      it("does nothing if payload is not a valid JsonRpcRequest.", () => {
        const spy = Sinon.spy();
        relayer.events.emit = spy;
        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, {});
        expect(spy.notCalled).to.be.true;
      });
      it(`does nothing if payload.method does not have the ${RELAYER_SUBSCRIBER_SUFFIX} suffix`, () => {
        const spy = Sinon.spy();
        relayer.events.emit = spy;
        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, {
          ...validPayload,
          method: "mock",
        });
        expect(spy.notCalled).to.be.true;
      });
      it("emits an event based on `payload.params.id`", () => {
        const spy = Sinon.spy();
        relayer.events.emit = spy;
        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, validPayload);
        expect(
          spy.calledOnceWith(validPayload.params.id, {
            topic: validPayload.params.data.topic,
            message: validPayload.params.data.message,
            publishedAt: validPayload.params.data.publishedAt,
            transportType: validPayload.params.data.transportType,
            attestation: validPayload.params.data.attestation,
          }),
        ).to.be.true;
      });
    });
    describe("transport", () => {
      beforeEach(async () => {
        core = new Core(TEST_CORE_OPTIONS);
        relayer = core.relayer;
        await core.start();
        relayer.subscriber.subscriptions.set(randomTopic, {
          topic: randomTopic,
          id: randomTopic,
          relay: { protocol: "irn" },
        });
      });
      it("should restart transport after connection drop", async () => {
        const randomSessionIdentifier = relayer.core.crypto.randomSessionIdentifier;
        await relayer.transportOpen();
        const timeout = setTimeout(() => {
          throw new Error("Connection did not restart after disconnect");
        }, 5_001);
        await Promise.all([
          new Promise<void>((resolve) => {
            relayer.once(RELAYER_EVENTS.connect, () => {
              expect(relayer.connected).to.be.true;
              resolve();
            });
          }),
          new Promise<void>((resolve) => {
            relayer.once(RELAYER_EVENTS.disconnect, () => {
              expect(relayer.connected).to.be.false;
              resolve();
            });
          }),
          relayer.provider.connection.close(),
        ]);
        clearTimeout(timeout);
        // the identifier should be the same
        expect(relayer.core.crypto.randomSessionIdentifier).to.eq(randomSessionIdentifier);
      });
      it("should connect once regardless of the number of disconnect events", async () => {
        const disconnectsToEmit = 10;
        let disconnectsReceived = 0;
        let connectReceived = 0;
        relayer.on(RELAYER_EVENTS.connect, () => {
          connectReceived++;
        });
        relayer.on(RELAYER_EVENTS.disconnect, () => {
          disconnectsReceived++;
        });
        await Promise.all(
          Array.from(Array(disconnectsToEmit).keys()).map(() => relayer.onDisconnectHandler()),
        );
        await throttle(5_000);
        expect(connectReceived).to.eq(1);
        expect(disconnectsReceived).to.eq(disconnectsToEmit);
      });

      it("should not start wss connection on init without subscriber topics", async () => {
        relayer = new Relayer({
          core,
          relayUrl: TEST_CORE_OPTIONS.relayUrl,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        await throttle(1_000); // +1 sec buffer
        expect(relayer.connected).to.be.false;
      });

      it("should start transport on subscribe attempt", async () => {
        relayer = new Relayer({
          core,
          relayUrl: TEST_CORE_OPTIONS.relayUrl,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        expect(relayer.connected).to.be.false;
        const topic = generateRandomBytes32();
        await relayer.subscribe(topic);
        await throttle(1_000); // +1 sec buffer
        expect(relayer.connected).to.be.true;
      });
      it(`should connect to ${RELAYER_DEFAULT_RELAY_URL} relay url`, async () => {
        relayer = new Relayer({
          core,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        relayer.subscriber.subscriptions.set(randomTopic, {
          topic: randomTopic,
          id: randomTopic,
          relay: { protocol: "irn" },
        });
        await relayer.transportOpen();
        const wsConnection = relayer.provider.connection as unknown as WebSocket;
        expect(relayer.connected).to.be.true;
        expect(wsConnection.url.startsWith(RELAYER_DEFAULT_RELAY_URL)).to.be.true;
      });
      it("should not throw an error if terminate() is not available", async () => {
        const relayer = new Relayer({
          core,
          relayUrl: TEST_CORE_OPTIONS.relayUrl,
          projectId: TEST_CORE_OPTIONS.projectId,
        });
        await relayer.init();
        relayer.subscriber.subscriptions.set(randomTopic, {
          topic: randomTopic,
          id: randomTopic,
          relay: { protocol: "irn" },
        });
        await relayer.transportOpen();
        expect(relayer.connected).to.be.true;
        //@ts-expect-error - private property
        relayer.provider.connection.socket.terminate = undefined;
        //@ts-expect-error - private property
        relayer.heartBeatTimeout = 1000;
        //@ts-expect-error - private method
        relayer.resetPingTimeout();
        await throttle(2000);
        await relayer.transportClose();
        expect(relayer.connected).to.be.false;
      });
    });
  });
  describe("packageName and bundleId validations", () => {
    beforeEach(async () => {
      core = new Core({ ...TEST_CORE_OPTIONS, projectId: TEST_PROJECT_ID_MOBILE });
      relayer = core.relayer;
      await core.start();
    });

    it("[Android] packageName included in Cloud Settings - should connect", async () => {
      // Mock Android environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      await relayer.subscribe(randomTopic);

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).to.include(`packageName=${TEST_MOBILE_APP_ID}`);
      expect(relayer.connected).to.be.true;
    });

    it("[Android] packageName undefined - should connect", async () => {
      // Mock Android environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue(undefined);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      await relayer.subscribe(randomTopic);

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).not.to.include("packageName=");
      expect(relayer.connected).to.be.true;
    });

    it("[Android] packageName not included in Cloud Settings - should fail", async () => {
      // Mock Android environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue("com.example.wrong");

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();

      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });

      let errorReceived = false;
      relayer.on(RELAYER_EVENTS.error, (payload) => {
        expect(payload.message).to.include("Unauthorized: origin not allowed");
        errorReceived = true;
      });
      await relayer.transportOpen().catch((e) => {});
      await throttle(1000);
      expect(errorReceived).to.be.true;
    });

    it("[iOS] bundleId included in Cloud Settings - should connect", async () => {
      // Mock iOS environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(true);
      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      await relayer.subscribe(randomTopic);

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).to.include(`bundleId=${TEST_MOBILE_APP_ID}`);
    });

    it("[iOS] bundleId undefined - should connect", async () => {
      // Mock iOS environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(true);
      vi.spyOn(utils, "getAppId").mockReturnValue(undefined);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });
      await relayer.transportOpen();

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).not.to.include("bundleId=");
      expect(relayer.connected).to.be.true;
    });

    it("[iOS] bundleId not included in Cloud Settings - should fail", async () => {
      // Mock iOS environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(true);
      vi.spyOn(utils, "getAppId").mockReturnValue("com.example.wrong");

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });

      let errorReceived = false;
      relayer.on(RELAYER_EVENTS.error, (payload) => {
        expect(payload.message).to.include("Unauthorized: origin not allowed");
        errorReceived = true;
      });

      await relayer.transportOpen().catch((e) => {});

      await throttle(1000);
      expect(errorReceived).to.be.true;
    });

    it("[Web] packageName and bundleId not set - should connect", async () => {
      // Mock non-mobile environment
      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
      vi.spyOn(utils, "isIos").mockReturnValue(false);
      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);

      relayer = new Relayer({
        core,
        relayUrl: TEST_CORE_OPTIONS.relayUrl,
        projectId: TEST_PROJECT_ID_MOBILE,
      });

      await relayer.init();
      relayer.subscriber.subscriptions.set(randomTopic, {
        topic: randomTopic,
        id: randomTopic,
        relay: { protocol: "irn" },
      });
      await relayer.transportOpen();

      // @ts-expect-error - accessing private property for testing
      const wsUrl = relayer.provider.connection.url;
      expect(wsUrl).not.to.include("packageName=");
      expect(wsUrl).not.to.include("bundleId=");
    });

    afterEach(() => {
      vi.restoreAllMocks();
    });
  });
});
</file>

<file path="packages/core/test/store.spec.ts">
import { expect, describe, it, beforeEach } from "vitest";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { Core, CORE_STORAGE_PREFIX, Store, STORE_STORAGE_VERSION } from "../src";
import { TEST_CORE_OPTIONS } from "./shared";
import { ICore, IStore, SessionTypes } from "@walletconnect/types";

const MOCK_STORE_NAME = "mock-entity";

describe("Store", () => {
  const logger = pino(getDefaultLoggerOptions({ level: "fatal" }));

  let core: ICore;
  type MockValue = { id: string; value: string };
  let store: IStore<any, any>;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    store = new Store(core, logger, MOCK_STORE_NAME);
    await store.init();
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const store = new Store(core, logger, MOCK_STORE_NAME);
      expect(store.storageKey).to.equal(
        CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + "//" + MOCK_STORE_NAME,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const store = new Store(core, logger, MOCK_STORE_NAME);
      expect(store.storageKey).to.equal(
        CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + ":test" + "//" + MOCK_STORE_NAME,
      );
    });
  });

  describe("init", () => {
    const ids = ["1", "2", "3", "foo"];
    const STORAGE_KEY = CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + "//" + MOCK_STORE_NAME;

    beforeEach(() => {
      const cachedValues = ids.map((id) => ({ id, value: "foo" }));
      core.storage.setItem(STORAGE_KEY, cachedValues);
    });

    it("retrieves from cache using getKey", async () => {
      const store = new Store<string, MockValue>(
        core,
        logger,
        MOCK_STORE_NAME,
        undefined,
        (val) => val.id,
      );
      await store.init();
      for (const id of ids) {
        expect(store.keys).includes(id);
      }
    });

    it("safely overwrites values when retrieving from cache using getKey", async () => {
      const store = new Store<string, MockValue>(
        core,
        logger,
        MOCK_STORE_NAME,
        undefined,
        (val) => val.value,
      );
      await store.init();
      expect(store.keys).to.eql(["foo"]);
    });

    it("handles null and undefined cases", async () => {
      core.storage.setItem(STORAGE_KEY, [undefined, null, { id: 1, value: "foo" }]);
      const store = new Store<string, MockValue>(
        core,
        logger,
        MOCK_STORE_NAME,
        undefined,
        (val) => val.value,
      );
      await store.init();
      expect(store.keys).to.eql(["foo"]);
    });
  });

  describe("set", () => {
    it("creates a new entry for a new key", async () => {
      const key = "newKey";
      const value = {
        topic: "abc123",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      expect(store.length).to.equal(1);
      expect(store.keys.includes(key)).to.be.true;
      expect(store.values.includes(value)).to.be.true;
    });
    it("updates an existing entry for a known key", async () => {
      const key = "key";
      const value = {
        topic: "111",
        expiry: 1000,
      } as SessionTypes.Struct;
      const updatedValue = {
        topic: "222",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      await store.set(key, updatedValue);
      expect(store.length).to.equal(1);
      expect(store.map.has(key)).to.be.true;
      expect(store.values.some((val: any) => val.topic === updatedValue.topic)).to.be.true;
    });
  });

  describe("get", () => {
    it("returns the value for a known key", async () => {
      const key = "key";
      const value = {
        topic: "abc123",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      expect(await store.get(key)).to.equal(value);
    });
    it("throws with expected error if passed an unknown key", () => {
      const unknownKey = "unknown";
      expect(() => store.get(unknownKey)).to.throw(
        `No matching key. ${MOCK_STORE_NAME}: ${unknownKey}`,
      );
    });
  });

  describe("delete", () => {
    it("removes a known key from the map", async () => {
      const key = "key";
      const value = {
        topic: "abc123",
        expiry: 1000,
      } as SessionTypes.Struct;
      await store.set(key, value);
      expect(store.length).to.equal(1);
      await store.delete(key, { code: 0, message: "reason" });
      expect(store.length).to.equal(0);
    });
    it("does nothing if key is unknown", async () => {
      await store.delete("key", { code: 0, message: "reason" });
      expect(store.length).to.equal(0);
    });
    it("should add deleted key to the recentlyDeleted list", async () => {
      const key = "key";
      const value = "value";
      await store.set(key, value);
      await store.delete(key, { code: 0, message: "reason" });
      try {
        await store.get(key);
      } catch (e) {
        expect(e.message).to.equal(
          `Missing or invalid. Record was recently deleted - mock-entity: ${key}`,
        );
      }
    });
    it("should cleanup recentlyDeleted when size limit is reached", async () => {
      //@ts-expect-error
      const itemsToDelete = store.recentlyDeletedLimit - 1;
      // populate recentlyDeleted just below the limit
      for (let i = 0; i < itemsToDelete; i++) {
        const key = `key${i}`;
        const value = `value${i}`;
        await store.set(key, value);
        await store.delete(key, { code: 0, message: "reason" });
      }
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.be.greaterThan(1);
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.equal(itemsToDelete);
      // add one more to reach the limit
      await store.set("test", "test");
      await store.delete("test", { code: 0, message: "reason" });

      // check that the recentlyDeleted list has been halved
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.be.greaterThan(1);
      //@ts-expect-error
      expect(store.recentlyDeleted?.length).to.equal(store.recentlyDeletedLimit / 2);
    });
  });

  describe("getAll", () => {
    const key1 = "key1";
    const key2 = "key2";
    const value1 = { topic: "abc123", expiry: 1000, active: false };
    const value2 = { topic: "abc456", expiry: 1000, active: true };

    it("returns all values if no filter was provided", async () => {
      await store.set(key1, value1);
      await store.set(key2, value2);
      const all = store.getAll();
      expect(all.length).to.equal(2);
    });
    it("only returns values that satisfy filter", async () => {
      await store.set(key1, value1);
      await store.set(key2, value2);
      const filtered = store.getAll({ active: true });
      expect(filtered.length).to.equal(1);
      expect(filtered[0].active).to.equal(true);
    });
  });
});
</file>

<file path="packages/core/test/subscriber.spec.ts">
import { expect, describe, it, beforeEach, afterAll, afterEach } from "vitest";
import Sinon from "sinon";
import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
import { ICore, IRelayer, ISubscriber } from "@walletconnect/types";
import { generateRandomBytes32, getRelayProtocolName, hashMessage } from "@walletconnect/utils";

import {
  Core,
  CORE_DEFAULT,
  CORE_STORAGE_PREFIX,
  MESSAGES_STORAGE_VERSION,
  RELAYER_PROVIDER_EVENTS,
  Subscriber,
  SUBSCRIBER_CONTEXT,
} from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";

describe("Subscriber", () => {
  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));

  let relayer: IRelayer;
  let subscriber: ISubscriber;
  let core: ICore;

  beforeEach(async () => {
    core = new Core(TEST_CORE_OPTIONS);
    await core.start();
    relayer = core.relayer;
    subscriber = relayer.subscriber;
    subscriber.relayer.provider.request = () => Promise.resolve({} as any);
  });

  afterEach(async () => {
    await disconnectSocket(core.relayer);
  });

  describe("init", () => {
    it.skip("should call batch fetch messages on init when it has cached topics", async () => {
      const requestSpy: Sinon.SinonSpy = Sinon.spy(() => {
        return Promise.resolve({} as any);
      });
      subscriber.relayer.provider.request = requestSpy;

      const topic = generateRandomBytes32();
      // manually switch off the subscriber
      // @ts-expect-error
      subscriber.onDisconnect();
      // add a topic to the subscriber as if it was loaded from persistence
      // @ts-expect-error
      subscriber.cached = [{ topic, relay: { protocol: "irn" } }];

      // restart the subscriber
      // @ts-expect-error
      subscriber.onConnect();

      await new Promise((resolve) => setTimeout(resolve, 2000));

      // first req should be the batch fetch messages call followed by the batch subscribe call
      expect(requestSpy.getCalls().length).toBe(2);
      expect(requestSpy.getCalls()[0].args[0].method).toBe("irn_batchFetchMessages");
      expect(requestSpy.getCalls()[1].args[0].method).toBe("irn_batchSubscribe");
      expect(
        requestSpy.calledWith(
          Sinon.match({
            method: "irn_batchFetchMessages",
            params: {
              topics: [topic],
            },
          }),
        ),
      ).to.be.true;

      expect(
        requestSpy.calledWith(
          Sinon.match({
            method: "irn_batchSubscribe",
            params: {
              topics: [topic],
            },
          }),
        ),
      ).to.be.true;
    });
  });

  describe("storageKey", () => {
    it("provides the expected default `storageKey` format", () => {
      const subscriber = new Subscriber(relayer, logger);
      expect(subscriber.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + "//" + SUBSCRIBER_CONTEXT,
      );
    });
    it("provides the expected custom `storageKey` format", () => {
      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
      const subscriber = new Subscriber(core.relayer, logger);
      expect(subscriber.storageKey).to.equal(
        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + ":test" + "//" + SUBSCRIBER_CONTEXT,
      );
    });
  });

  describe("init", () => {
    it("registers event listeners", async () => {
      expect(subscriber.clientId).to.equal("");

      const topic = generateRandomBytes32();
      const emitSpy = Sinon.spy();
      subscriber.events.emit = emitSpy;
      // subscribe to a topic
      await subscriber.subscribe(topic);
      expect(subscriber.subscriptions.size).to.equal(1);
      expect(subscriber.topics.length).to.equal(1);
      // relayer.provider emits a `disconnect` event -> should clear both subscriptions and topics.
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.disconnect);
      expect(subscriber.subscriptions.size).to.equal(0);
      expect(subscriber.topics.length).to.equal(0);

      expect(subscriber.clientId).to.not.equal("");
    });

    it("should set hasAnyTopics", async () => {
      const topic = generateRandomBytes32();
      expect(subscriber.hasAnyTopics).toBe(false);
      subscriber.topicMap.set(topic, topic);
      expect(subscriber.hasAnyTopics).toBe(true);
      subscriber.topicMap.clear();
      expect(subscriber.hasAnyTopics).toBe(false);
      // @ts-expect-error - private property
      subscriber.cached = [{ topic }];
      expect(subscriber.hasAnyTopics).toBe(true);
      // @ts-expect-error - private property
      subscriber.cached = [];
      expect(subscriber.hasAnyTopics).toBe(false);
      subscriber.pending.set(topic, { topic });
      expect(subscriber.hasAnyTopics).toBe(true);
      subscriber.pending.clear();
      expect(subscriber.hasAnyTopics).toBe(false);
    });
  });

  describe("subscribe", () => {
    let topic: string;
    let requestSpy: Sinon.SinonSpy;

    beforeEach(async () => {
      await relayer.connect();
      requestSpy = Sinon.spy(() => Promise.resolve(["test-id"]));
      topic = generateRandomBytes32();
      subscriber.relayer.provider.request = requestSpy;
    });

    it("throws if Subscriber was not initialized", async () => {
      const subscriber = new Subscriber(relayer, logger);
      await expect(subscriber.subscribe(topic)).rejects.toThrow("Not initialized. subscription");
    });
    it("calls `provider.request` with the expected request shape", async () => {
      await subscriber.subscribe(topic);
      expect(
        requestSpy.calledOnceWith(
          Sinon.match({
            method: "irn_subscribe",
            params: {
              topic,
            },
          }),
        ),
      ).to.be.true;
    });
    it("returns the subscription id", async () => {
      const id = await subscriber.subscribe(topic);
      const expectedId = hashMessage(topic + (await core.crypto.getClientId()));
      expect(id).to.equal(expectedId);
    });
    it("should subscribe a topic immediately after connect", async () => {
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.disconnect);
      expect(subscriber.subscriptions.size).to.equal(0);
      expect(subscriber.topics.length).to.equal(0);
      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.connect);
      await relayer.subscriber.subscribe(generateRandomBytes32());
      expect(subscriber.subscriptions.size).to.equal(1);
      expect(subscriber.topics.length).to.equal(1);
    });
  });

  describe("unsubscribe", () => {
    let topic: string;
    let requestSpy: Sinon.SinonSpy;
    let messageDeleteSpy: Sinon.SinonSpy;

    beforeEach(async () => {
      await relayer.connect();
      requestSpy = Sinon.spy(() => Promise.resolve(["test-id"]));
      messageDeleteSpy = Sinon.spy();
      topic = generateRandomBytes32();
      subscriber.relayer.provider.request = requestSpy;
      subscriber.relayer.messages.del = messageDeleteSpy;
    });
    it("throws if Subscriber was not initialized", async () => {
      const subscriber = new Subscriber(relayer, logger);
      await expect(subscriber.unsubscribe(topic)).rejects.toThrow("Not initialized. subscription");
    });
    it("unsubscribes by individual id if `opts.id` is provided", async () => {
      const id = "test-id";
      await subscriber.unsubscribe(topic, { id, relay: getRelayProtocolName() });
      expect(messageDeleteSpy.calledOnceWith(topic)).to.be.true;
      expect(
        requestSpy.calledOnceWith(
          Sinon.match({
            method: "irn_unsubscribe",
            params: {
              topic,
            },
          }),
        ),
      ).to.be.true;
    });
    it("unsubscribes by topic by default", async () => {
      await subscriber.subscribe(topic);
      expect(subscriber.topics.length).to.equal(1);
      await subscriber.unsubscribe(topic);
      expect(subscriber.topics.length).to.equal(0);
      expect(
        requestSpy.getCall(1).calledWith(
          Sinon.match({
            method: "irn_unsubscribe",
            params: {
              topic,
            },
          }),
        ),
      ).to.be.true;
    });
  });
});
</file>

<file path="packages/core/test/verify.spec.ts">
import { expect, describe, it } from "vitest";
import { hashMessage } from "@walletconnect/utils";

import { Core, VERIFY_SERVER } from "../src";
import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";

// TODO: re-enable this suite when we have a way to provide/mock CSRF token now required by the server.
describe.skip("verify", () => {
  it("should register attestation", async () => {
    const core = new Core(TEST_CORE_OPTIONS);
    await core.start();

    expect(core.expirer.length).to.eq(0);

    const POST_URL = `${VERIFY_SERVER}/attestation`;
    const attestationId = hashMessage("some");
    const origin = "localhost";

    const postResponse = await fetch(POST_URL, {
      method: "POST",
      body: JSON.stringify({ attestationId, origin }),
      headers: { "Content-Type": "application/json" },
    });

    expect(postResponse.status).toBe(200);

    const getResponse = await fetch(`${VERIFY_SERVER}/attestation/${attestationId}`);
    const result: any = await getResponse.json();

    expect(getResponse.status).toBe(200);
    expect(result.origin).toBe(origin);
    expect(result.attestationId).toBe(attestationId);

    await disconnectSocket(core.relayer);
  });
});
</file>

<file path="packages/core/.npmignore">
*.log
npm-debug.log*

# Coverage directory used by tools like istanbul
coverage
.nyc_output

# Dependency directories
node_modules

# npm package lock
package-lock.json
yarn.lock

# project files
src
test
CHANGELOG.md
.travis.yml
.editorconfig
.eslintignore
.eslintrc
.babelrc
.gitignore
.watchmanconfig
</file>

<file path="packages/core/CHANGELOG.md">
# @walletconnect/core

## 2.20.0

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.20.0
  - @walletconnect/types@2.20.0

## 2.19.4

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.19.4
  - @walletconnect/types@2.19.4

## 2.19.3

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.19.3
  - @walletconnect/types@2.19.3
</file>

<file path="packages/core/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="packages/core/package.json">
{
  "name": "@walletconnect/core",
  "description": "Core for WalletConnect Protocol",
  "version": "2.20.0",
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
  "license": "Apache-2.0",
  "main": "dist/index.cjs.js",
  "module": "dist/index.es.js",
  "unpkg": "dist/index.umd.js",
  "types": "dist/types/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "keywords": [
    "wallet",
    "walletconnect"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build:pre": "npm run clean",
    "build:types": "tsc",
    "build:source": "rollup --config rollup.config.js",
    "build": "npm run build:pre; npm run build:source; npm run build:types",
    "test:pre": "rm -rf ./test/tmp",
    "test:run": "vitest run --dir test",
    "test": "npm run test:pre; npm run test:run",
    "test:ignoreUnhandled": "npm run test:pre; npm run test:run -- --dangerouslyIgnoreUnhandledErrors",
    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
    "prettier": "prettier --check '{src,test}/**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@walletconnect/heartbeat": "1.2.2",
    "@walletconnect/jsonrpc-provider": "1.0.14",
    "@walletconnect/jsonrpc-types": "1.0.4",
    "@walletconnect/jsonrpc-utils": "1.0.8",
    "@walletconnect/jsonrpc-ws-connection": "1.0.16",
    "@walletconnect/keyvaluestorage": "1.1.1",
    "@walletconnect/logger": "2.1.2",
    "@walletconnect/relay-api": "1.0.11",
    "@walletconnect/relay-auth": "1.1.0",
    "@walletconnect/safe-json": "1.0.2",
    "@walletconnect/time": "1.0.2",
    "@walletconnect/types": "2.20.0",
    "@walletconnect/utils": "2.20.0",
    "@walletconnect/window-getters": "1.0.1",
    "es-toolkit": "1.33.0",
    "events": "3.3.0",
    "uint8arrays": "3.1.0"
  },
  "engines": {
    "node": ">=18"
  }
}
</file>

<file path="packages/core/README.md">
# @walletconnect/core

Core for WalletConnect Protocol

## License

Apache 2.0
</file>

<file path="packages/core/rollup.config.js">
import { name, dependencies } from "./package.json";
import createConfig from "../../rollup.config";

export default createConfig(name, Object.keys(dependencies));
</file>

<file path="packages/core/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["./src/**/*"],
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "./dist/types",
    "emitDeclarationOnly": true
  }
}
</file>

<file path="packages/sign-client/src/constants/auth.ts">
export const AUTH_PROTOCOL = "wc";
export const AUTH_VERSION = 1.5;
export const AUTH_CONTEXT = "auth";
export const AUTH_KEYS_CONTEXT = "authKeys";
export const AUTH_PAIRING_TOPIC_CONTEXT = "pairingTopics";
export const AUTH_REQUEST_CONTEXT = "requests";

export const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;
export const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;
</file>

<file path="packages/sign-client/src/constants/client.ts">
import { SignClientTypes } from "@walletconnect/types";

export const SIGN_CLIENT_PROTOCOL = "wc";
export const SIGN_CLIENT_VERSION = 2;
export const SIGN_CLIENT_CONTEXT = "client";

export const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;

export const SIGN_CLIENT_DEFAULT = {
  name: SIGN_CLIENT_CONTEXT,
  logger: "error",
  controller: false,
  relayUrl: "wss://relay.walletconnect.org",
};

export const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {
  session_proposal: "session_proposal",
  session_update: "session_update",
  session_extend: "session_extend",
  session_ping: "session_ping",
  session_delete: "session_delete",
  session_expire: "session_expire",
  session_request: "session_request",
  session_request_sent: "session_request_sent",
  session_event: "session_event",
  proposal_expire: "proposal_expire",
  session_authenticate: "session_authenticate",
  session_request_expire: "session_request_expire",
  session_connect: "session_connect",
};

export const SIGN_CLIENT_STORAGE_OPTIONS = {
  database: ":memory:",
};

export const WALLETCONNECT_DEEPLINK_CHOICE = "WALLETCONNECT_DEEPLINK_CHOICE";
</file>

<file path="packages/sign-client/src/constants/engine.ts">
import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from "@walletconnect/time";
import { EngineTypes } from "@walletconnect/types";

export const ENGINE_CONTEXT = "engine";

export const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {
  wc_sessionPropose: {
    req: {
      ttl: FIVE_MINUTES,
      prompt: true,
      tag: 1100,
    },
    res: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1101,
    },
    reject: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1120,
    },
    autoReject: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1121,
    },
  },
  wc_sessionSettle: {
    req: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1102,
    },
    res: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1103,
    },
  },
  wc_sessionUpdate: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1104,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1105,
    },
  },
  wc_sessionExtend: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1106,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1107,
    },
  },
  wc_sessionRequest: {
    req: {
      ttl: FIVE_MINUTES,
      prompt: true,
      tag: 1108,
    },
    res: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1109,
    },
  },
  wc_sessionEvent: {
    req: {
      ttl: FIVE_MINUTES,
      prompt: true,
      tag: 1110,
    },
    res: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1111,
    },
  },

  wc_sessionDelete: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1112,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1113,
    },
  },
  wc_sessionPing: {
    req: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1114,
    },
    res: {
      ttl: ONE_DAY,
      prompt: false,
      tag: 1115,
    },
  },
  wc_sessionAuthenticate: {
    req: {
      ttl: ONE_HOUR,
      prompt: true,
      tag: 1116,
    },
    res: {
      ttl: ONE_HOUR,
      prompt: false,
      tag: 1117,
    },
    reject: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1118,
    },
    autoReject: {
      ttl: FIVE_MINUTES,
      prompt: false,
      tag: 1119,
    },
  },
};

export const SESSION_REQUEST_EXPIRY_BOUNDARIES = {
  min: FIVE_MINUTES,
  max: SEVEN_DAYS,
};

export const ENGINE_QUEUE_STATES: { idle: "IDLE"; active: "ACTIVE" } = {
  idle: "IDLE",
  active: "ACTIVE",
};

export const TVF_METHODS = {
  eth_sendTransaction: {
    key: "",
  },
  eth_sendRawTransaction: {
    key: "",
  },
  wallet_sendCalls: {
    key: "",
  },

  solana_signTransaction: {
    key: "signature",
  },
  solana_signAllTransactions: {
    key: "transactions",
  },
  solana_signAndSendTransaction: {
    key: "signature",
  },
};
</file>

<file path="packages/sign-client/src/constants/history.ts">
export const HISTORY_EVENTS = {
  created: "history_created",
  updated: "history_updated",
  deleted: "history_deleted",
  sync: "history_sync",
};

export const HISTORY_CONTEXT = "history";

export const HISTORY_STORAGE_VERSION = "0.3";
</file>

<file path="packages/sign-client/src/constants/index.ts">
export * from "./client";
export * from "./history";
export * from "./proposal";
export * from "./session";
export * from "./engine";
export * from "./pendingRequest";
export * from "./verify";
export * from "./auth";
</file>

<file path="packages/sign-client/src/constants/pendingRequest.ts">
export const REQUEST_CONTEXT = "request";
</file>

<file path="packages/sign-client/src/constants/proposal.ts">
import { THIRTY_DAYS } from "@walletconnect/time";

export const PROPOSAL_CONTEXT = "proposal";

export const PROPOSAL_EXPIRY = THIRTY_DAYS;

export const PROPOSAL_EXPIRY_MESSAGE = "Proposal expired";
</file>

<file path="packages/sign-client/src/constants/session.ts">
import { SEVEN_DAYS } from "@walletconnect/time";

export const SESSION_CONTEXT = "session";

export const SESSION_EXPIRY = SEVEN_DAYS;
</file>

<file path="packages/sign-client/src/constants/verify.ts">
export const METHODS_TO_VERIFY = [
  "wc_sessionPropose",
  "wc_sessionRequest",
  "wc_authRequest",
  "wc_sessionAuthenticate",
];
</file>

<file path="packages/sign-client/src/controllers/authKey.ts">
import { Store } from "@walletconnect/core";
import { Logger } from "@walletconnect/logger";
import { ICore } from "@walletconnect/types";

import { AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, AUTH_PUBLIC_KEY_NAME } from "../constants";

export class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {
  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);
  }
}
</file>

<file path="packages/sign-client/src/controllers/authPairingTopic.ts">
import { Store } from "@walletconnect/core";
import { Logger } from "@walletconnect/logger";
import { ICore } from "@walletconnect/types";

import { AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX } from "../constants";

export class AuthPairingTopic extends Store<string, { topic: string; pairingTopic: string }> {
  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger, AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX);
  }
}
</file>

<file path="packages/sign-client/src/controllers/authRequest.ts">
import { Store } from "@walletconnect/core";
import { Logger } from "@walletconnect/logger";
import { AuthTypes, ICore } from "@walletconnect/types";

import { AUTH_STORAGE_PREFIX, AUTH_REQUEST_CONTEXT } from "../constants";

export class AuthRequest extends Store<number, AuthTypes.PendingRequest> {
  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(
      core,
      logger,
      AUTH_REQUEST_CONTEXT,
      AUTH_STORAGE_PREFIX,
      (val: AuthTypes.PendingRequest) => val.id,
    );
  }
}
</file>

<file path="packages/sign-client/src/controllers/authStore.ts">
import { Logger } from "@walletconnect/logger";
import { IAuth, ICore } from "@walletconnect/types";
import { AuthPairingTopic } from "./authPairingTopic";
import { AuthRequest } from "./authRequest";
import { AuthKey } from "./authKey";

export class AuthStore {
  public authKeys: IAuth["authKeys"];
  public pairingTopics: IAuth["pairingTopics"];
  public requests: IAuth["requests"];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    this.authKeys = new AuthKey(this.core, this.logger);
    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);
    this.requests = new AuthRequest(this.core, this.logger);
  }

  public async init() {
    await this.authKeys.init();
    await this.pairingTopics.init();
    await this.requests.init();
  }
}
</file>

<file path="packages/sign-client/src/controllers/engine.ts">
/* eslint-disable no-console */
import {
  EVENT_CLIENT_AUTHENTICATE_ERRORS,
  EVENT_CLIENT_AUTHENTICATE_TRACES,
  EVENT_CLIENT_PAIRING_ERRORS,
  EVENT_CLIENT_PAIRING_TRACES,
  EVENT_CLIENT_SESSION_ERRORS,
  EVENT_CLIENT_SESSION_TRACES,
  EXPIRER_EVENTS,
  PAIRING_EVENTS,
  RELAYER_DEFAULT_PROTOCOL,
  RELAYER_EVENTS,
  TRANSPORT_TYPES,
  VERIFY_SERVER,
} from "@walletconnect/core";

import {
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  payloadId,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  JsonRpcRequest,
  ErrorResponse,
  getBigIntRpcId,
} from "@walletconnect/jsonrpc-utils";
import { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from "@walletconnect/time";
import {
  EnginePrivate,
  EngineTypes,
  ExpirerTypes,
  IEngine,
  IEngineEvents,
  JsonRpcTypes,
  PendingRequestTypes,
  Verify,
  CoreTypes,
  ProposalTypes,
  RelayerTypes,
  SessionTypes,
  PairingTypes,
  AuthTypes,
  EventClientTypes,
} from "@walletconnect/types";
import {
  calcExpiry,
  createDelayedPromise,
  engineEvent,
  getInternalError,
  getSdkError,
  isConformingNamespaces,
  isExpired,
  isSessionCompatible,
  isUndefined,
  isValidController,
  isValidErrorReason,
  isValidEvent,
  isValidId,
  isValidNamespaces,
  isValidNamespacesChainId,
  isValidNamespacesEvent,
  isValidNamespacesRequest,
  isValidObject,
  isValidParams,
  isValidRelay,
  isValidRelays,
  isValidRequest,
  isValidRequestExpiry,
  hashMessage,
  isValidRequiredNamespaces,
  isValidResponse,
  isValidString,
  parseExpirerTarget,
  TYPE_1,
  TYPE_2,
  handleDeeplinkRedirect,
  MemoryStore,
  getDeepLink,
  hashKey,
  getDidAddress,
  formatMessage,
  getMethodsFromRecap,
  buildNamespacesFromAuth,
  createEncodedRecap,
  getChainsFromRecap,
  mergeEncodedRecaps,
  getRecapFromResources,
  validateSignedCacao,
  getNamespacedDidChainId,
  parseChainId,
  getLinkModeURL,
  BASE64,
  BASE64URL,
  getSearchParamFromURL,
  isReactNative,
  isTestRun,
  isValidArray,
  extractSolanaTransactionId,
} from "@walletconnect/utils";
import EventEmmiter from "events";
import {
  ENGINE_CONTEXT,
  ENGINE_RPC_OPTS,
  PROPOSAL_EXPIRY_MESSAGE,
  SESSION_EXPIRY,
  SESSION_REQUEST_EXPIRY_BOUNDARIES,
  METHODS_TO_VERIFY,
  WALLETCONNECT_DEEPLINK_CHOICE,
  ENGINE_QUEUE_STATES,
  AUTH_PUBLIC_KEY_NAME,
  TVF_METHODS,
} from "../constants";

export class Engine extends IEngine {
  public name = ENGINE_CONTEXT;

  private events: IEngineEvents = new EventEmmiter();
  private initialized = false;

  /**
   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc
   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time
   */
  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {
    state: ENGINE_QUEUE_STATES.idle,
    queue: [],
  };

  /**
   * Queue responsible for processing incoming session_request
   * The queue emits the next request only after the previous one has been responded to
   */
  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {
    state: ENGINE_QUEUE_STATES.idle,
    queue: [],
  };

  private requestQueueDelay = ONE_SECOND;
  private expectedPairingMethodMap: Map<string, string[]> = new Map();
  // Ephemeral (in-memory) map to store recently deleted items
  private recentlyDeletedMap = new Map<
    string | number,
    "pairing" | "session" | "proposal" | "request"
  >();

  private recentlyDeletedLimit = 200;
  private relayMessageCache: RelayerTypes.MessageEvent[] = [];
  private pendingSessions: Map<
    number,
    {
      sessionTopic: string;
      pairingTopic: string;
      proposalId: number;
      publicKey: string;
    }
  > = new Map();

  constructor(client: IEngine["client"]) {
    super(client);
  }

  public init: IEngine["init"] = async () => {
    if (!this.initialized) {
      await this.cleanup();
      this.registerRelayerEvents();
      this.registerExpirerEvents();
      this.registerPairingEvents();
      await this.registerLinkModeListeners();
      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });
      this.initialized = true;
      setTimeout(async () => {
        await this.processPendingMessageEvents();

        this.sessionRequestQueue.queue = this.getPendingSessionRequests();
        this.processSessionRequestQueue();
      }, toMiliseconds(this.requestQueueDelay));
    }
  };

  private async processPendingMessageEvents() {
    try {
      const topics = this.client.session.keys;
      const pendingMessages = this.client.core.relayer.messages.getWithoutAck(topics);
      for (const [topic, messages] of Object.entries(pendingMessages)) {
        for (const message of messages) {
          try {
            await this.onProviderMessageEvent({
              topic,
              message,
              publishedAt: Date.now(),
            });
          } catch (error) {
            this.client.logger.warn(
              `Error processing pending message event for topic: ${topic}, message: ${message}`,
            );
          }
        }
      }
    } catch (error) {
      this.client.logger.warn("processPendingMessageEvents failed", error);
    }
  }

  // ---------- Public ------------------------------------------------ //

  public connect: IEngine["connect"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    const connectParams = {
      ...params,
      requiredNamespaces: params.requiredNamespaces || {},
      optionalNamespaces: params.optionalNamespaces || {},
    };
    await this.isValidConnect(connectParams);
    const {
      pairingTopic,
      requiredNamespaces,
      optionalNamespaces,
      sessionProperties,
      scopedProperties,
      relays,
    } = connectParams;
    let topic = pairingTopic;
    let uri: string | undefined;
    let active = false;
    try {
      if (topic) {
        const pairing = this.client.core.pairing.pairings.get(topic);
        this.client.logger.warn(
          "connect() with existing pairing topic is deprecated and will be removed in the next major release.",
        );
        active = pairing.active;
      }
    } catch (error) {
      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);
      throw error;
    }
    if (!topic || !active) {
      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();
      topic = newTopic;
      uri = newUri;
    }
    // safety check to ensure pairing topic is available
    if (!topic) {
      const { message } = getInternalError("NO_MATCHING_KEY", `connect() pairing topic: ${topic}`);
      throw new Error(message);
    }

    const publicKey = await this.client.core.crypto.generateKeyPair();

    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;
    const expiryTimestamp = calcExpiry(expiry);
    const proposal = {
      requiredNamespaces,
      optionalNamespaces,
      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],
      proposer: {
        publicKey,
        metadata: this.client.metadata,
      },
      expiryTimestamp,
      pairingTopic: topic,
      ...(sessionProperties && { sessionProperties }),
      ...(scopedProperties && { scopedProperties }),
      id: payloadId(),
    };
    const sessionConnectTarget = engineEvent("session_connect", proposal.id);

    const {
      reject,
      resolve,
      done: approval,
    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);

    const proposalExpireHandler = ({ id }: { id: number }) => {
      if (id === proposal.id) {
        this.client.events.off("proposal_expire", proposalExpireHandler);
        this.pendingSessions.delete(proposal.id);
        // emit the event to trigger reject, this approach automatically cleans up the .once listener below
        this.events.emit(sessionConnectTarget, {
          error: { message: PROPOSAL_EXPIRY_MESSAGE, code: 0 },
        });
      }
    };

    this.client.events.on("proposal_expire", proposalExpireHandler);
    this.events.once<"session_connect">(sessionConnectTarget, ({ error, session }) => {
      this.client.events.off("proposal_expire", proposalExpireHandler);
      if (error) reject(error);
      else if (session) {
        resolve(session);
      }
    });

    await this.sendRequest({
      topic,
      method: "wc_sessionPropose",
      params: proposal,
      throwOnFailedPublish: true,
      clientRpcId: proposal.id,
    });

    await this.setProposal(proposal.id, proposal);
    return { uri, approval };
  };

  public pair: IEngine["pair"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    try {
      return await this.client.core.pairing.pair(params);
    } catch (error) {
      this.client.logger.error("pair() failed");
      throw error;
    }
  };

  public approve: IEngine["approve"] = async (params) => {
    const configEvent = this.client.core.eventClient.createEvent({
      properties: {
        topic: params?.id?.toString(),
        trace: [EVENT_CLIENT_SESSION_TRACES.session_approve_started],
      },
    });
    try {
      this.isInitialized();
      await this.confirmOnlineStateOrThrow();
    } catch (error) {
      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.no_internet_connection);
      throw error;
    }
    try {
      await this.isValidProposalId(params?.id);
    } catch (error) {
      this.client.logger.error(`approve() -> proposal.get(${params?.id}) failed`);
      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);
      throw error;
    }

    try {
      await this.isValidApprove(params);
    } catch (error) {
      this.client.logger.error("approve() -> isValidApprove() failed");
      configEvent.setError(
        EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure,
      );
      throw error;
    }

    const { id, relayProtocol, namespaces, sessionProperties, scopedProperties, sessionConfig } =
      params;

    const proposal = this.client.proposal.get(id);

    this.client.core.eventClient.deleteEvent({ eventId: configEvent.eventId });

    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;

    let event = this.client.core.eventClient?.getEvent({
      topic: pairingTopic,
    }) as EventClientTypes.Event;
    if (!event) {
      event = this.client.core.eventClient?.createEvent({
        type: EVENT_CLIENT_SESSION_TRACES.session_approve_started,
        properties: {
          topic: pairingTopic,
          trace: [
            EVENT_CLIENT_SESSION_TRACES.session_approve_started,
            EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success,
          ],
        },
      });
    }

    const selfPublicKey = await this.client.core.crypto.generateKeyPair();
    const peerPublicKey = proposer.publicKey;
    const sessionTopic = await this.client.core.crypto.generateSharedKey(
      selfPublicKey,
      peerPublicKey,
    );
    const sessionSettle = {
      relay: { protocol: relayProtocol ?? "irn" },
      namespaces,
      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },
      expiry: calcExpiry(SESSION_EXPIRY),
      ...(sessionProperties && { sessionProperties }),
      ...(scopedProperties && { scopedProperties }),
      ...(sessionConfig && { sessionConfig }),
    };
    const transportType = TRANSPORT_TYPES.relay;
    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);
    try {
      await this.client.core.relayer.subscribe(sessionTopic, { transportType });
    } catch (error) {
      event.setError(EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure);
      throw error;
    }

    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);

    const session = {
      ...sessionSettle,
      topic: sessionTopic,
      requiredNamespaces,
      optionalNamespaces,
      pairingTopic,
      acknowledged: false,
      self: sessionSettle.controller,
      peer: {
        publicKey: proposer.publicKey,
        metadata: proposer.metadata,
      },
      controller: selfPublicKey,
      transportType: TRANSPORT_TYPES.relay,
    };
    await this.client.session.set(sessionTopic, session);

    event.addTrace(EVENT_CLIENT_SESSION_TRACES.store_session);

    try {
      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_settle);
      await this.sendRequest({
        topic: sessionTopic,
        method: "wc_sessionSettle",
        params: sessionSettle,
        throwOnFailedPublish: true,
      }).catch((error) => {
        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure);
        throw error;
      });

      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success);

      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_approve);
      await this.sendResult<"wc_sessionPropose">({
        id,
        topic: pairingTopic,
        result: {
          relay: {
            protocol: relayProtocol ?? "irn",
          },
          responderPublicKey: selfPublicKey,
        },
        throwOnFailedPublish: true,
      }).catch((error) => {
        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure);
        throw error;
      });

      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success);
    } catch (error) {
      this.client.logger.error(error);
      // if the publish fails, delete the session and throw an error
      this.client.session.delete(sessionTopic, getSdkError("USER_DISCONNECTED"));
      await this.client.core.relayer.unsubscribe(sessionTopic);
      throw error;
    }

    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });

    await this.client.core.pairing.updateMetadata({
      topic: pairingTopic,
      metadata: proposer.metadata,
    });
    await this.client.proposal.delete(id, getSdkError("USER_DISCONNECTED"));
    await this.client.core.pairing.activate({ topic: pairingTopic });
    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));
    return {
      topic: sessionTopic,
      acknowledged: () => Promise.resolve(this.client.session.get(sessionTopic)),
    };
  };

  public reject: IEngine["reject"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    try {
      await this.isValidReject(params);
    } catch (error) {
      this.client.logger.error("reject() -> isValidReject() failed");
      throw error;
    }
    const { id, reason } = params;
    let pairingTopic;
    try {
      const proposal = this.client.proposal.get(id);
      pairingTopic = proposal.pairingTopic;
    } catch (error) {
      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);
      throw error;
    }

    if (pairingTopic) {
      await this.sendError({
        id,
        topic: pairingTopic,
        error: reason,
        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,
      });
      await this.client.proposal.delete(id, getSdkError("USER_DISCONNECTED"));
    }
  };

  public update: IEngine["update"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    try {
      await this.isValidUpdate(params);
    } catch (error) {
      this.client.logger.error("update() -> isValidUpdate() failed");
      throw error;
    }
    const { topic, namespaces } = params;

    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();
    const clientRpcId = payloadId();
    const relayRpcId = getBigIntRpcId().toString() as any;

    const oldNamespaces = this.client.session.get(topic).namespaces;
    this.events.once(engineEvent("session_update", clientRpcId), ({ error }: any) => {
      if (error) reject(error);
      else {
        resolve();
      }
    });
    // Update the session with the new namespaces, if the publish fails, revert to the old.
    // This allows the client to use the updated session like emitting events
    // without waiting for the peer to acknowledge
    await this.client.session.update(topic, { namespaces });
    await this.sendRequest({
      topic,
      method: "wc_sessionUpdate",
      params: { namespaces },
      throwOnFailedPublish: true,
      clientRpcId,
      relayRpcId,
    }).catch((error) => {
      this.client.logger.error(error);
      this.client.session.update(topic, { namespaces: oldNamespaces });
      reject(error);
    });
    return { acknowledged };
  };

  public extend: IEngine["extend"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    try {
      await this.isValidExtend(params);
    } catch (error) {
      this.client.logger.error("extend() -> isValidExtend() failed");
      throw error;
    }

    const { topic } = params;
    const clientRpcId = payloadId();
    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();
    this.events.once(engineEvent("session_extend", clientRpcId), ({ error }: any) => {
      if (error) reject(error);
      else resolve();
    });

    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));
    this.sendRequest({
      topic,
      method: "wc_sessionExtend",
      params: {},
      clientRpcId,
      throwOnFailedPublish: true,
    }).catch((e) => {
      reject(e);
    });

    return { acknowledged };
  };

  public request: IEngine["request"] = async <T>(params: EngineTypes.RequestParams) => {
    this.isInitialized();
    try {
      await this.isValidRequest(params);
    } catch (error) {
      this.client.logger.error("request() -> isValidRequest() failed");
      throw error;
    }
    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;
    const session = this.client.session.get(topic);

    if (session?.transportType === TRANSPORT_TYPES.relay) {
      await this.confirmOnlineStateOrThrow();
    }
    const clientRpcId = payloadId();
    const relayRpcId = getBigIntRpcId().toString() as any;
    const { done, resolve, reject } = createDelayedPromise<T>(
      expiry,
      "Request expired. Please try again.",
    );
    this.events.once<"session_request">(
      engineEvent("session_request", clientRpcId),
      ({ error, result }) => {
        if (error) reject(error);
        else resolve(result);
      },
    );
    const protocolMethod = "wc_sessionRequest";
    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);
    if (appLink) {
      await this.sendRequest({
        clientRpcId,
        relayRpcId,
        topic,
        method: protocolMethod,
        params: {
          request: {
            ...request,
            expiryTimestamp: calcExpiry(expiry),
          },
          chainId,
        },
        expiry,
        throwOnFailedPublish: true,
        appLink,
      }).catch((error) => reject(error));

      this.client.events.emit("session_request_sent", {
        topic,
        request,
        chainId,
        id: clientRpcId,
      });
      const result = await done();
      return result;
    }

    const protocolRequestParams: JsonRpcTypes.RequestParams["wc_sessionRequest"] = {
      request: {
        ...request,
        expiryTimestamp: calcExpiry(expiry),
      },
      chainId,
    };
    const shouldSetTVF = this.shouldSetTVF(protocolMethod, protocolRequestParams);

    return await Promise.all([
      new Promise<void>(async (resolve) => {
        await this.sendRequest({
          clientRpcId,
          relayRpcId,
          topic,
          method: protocolMethod,
          params: protocolRequestParams,
          expiry,
          throwOnFailedPublish: true,
          ...(shouldSetTVF && {
            tvf: this.getTVFParams(clientRpcId, protocolRequestParams),
          }),
        }).catch((error) => reject(error));
        this.client.events.emit("session_request_sent", {
          topic,
          request,
          chainId,
          id: clientRpcId,
        });
        resolve();
      }),
      new Promise<void>(async (resolve) => {
        // only attempt to handle deeplinks if they are not explicitly disabled in the session config
        if (!session.sessionConfig?.disableDeepLink) {
          const wcDeepLink = (await getDeepLink(
            this.client.core.storage,
            WALLETCONNECT_DEEPLINK_CHOICE,
          )) as string;
          await handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });
        }
        resolve();
      }),
      done(),
    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise
  };

  public respond: IEngine["respond"] = async (params) => {
    this.isInitialized();
    await this.isValidRespond(params);
    const { topic, response } = params;
    const { id } = response;
    const session = this.client.session.get(topic);

    if (session.transportType === TRANSPORT_TYPES.relay) {
      await this.confirmOnlineStateOrThrow();
    }

    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);
    if (isJsonRpcResult(response)) {
      await this.sendResult({
        id,
        topic,
        result: response.result,
        throwOnFailedPublish: true,
        appLink,
      });
    } else if (isJsonRpcError(response)) {
      await this.sendError({ id, topic, error: response.error, appLink });
    }
    this.cleanupAfterResponse(params);
  };

  public ping: IEngine["ping"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    try {
      await this.isValidPing(params);
    } catch (error) {
      this.client.logger.error("ping() -> isValidPing() failed");
      throw error;
    }
    const { topic } = params;
    if (this.client.session.keys.includes(topic)) {
      const clientRpcId = payloadId();
      const relayRpcId = getBigIntRpcId().toString() as any;
      const { done, resolve, reject } = createDelayedPromise<void>();
      this.events.once(engineEvent("session_ping", clientRpcId), ({ error }: any) => {
        if (error) reject(error);
        else resolve();
      });
      await Promise.all([
        this.sendRequest({
          topic,
          method: "wc_sessionPing",
          params: {},
          throwOnFailedPublish: true,
          clientRpcId,
          relayRpcId,
        }),
        done(),
      ]);
    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {
      this.client.logger.warn(
        "ping() on pairing topic is deprecated and will be removed in the next major release.",
      );
      await this.client.core.pairing.ping({ topic });
    }
  };

  public emit: IEngine["emit"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    await this.isValidEmit(params);
    const { topic, event, chainId } = params;
    const relayRpcId = getBigIntRpcId().toString() as any;
    const clientRpcId = payloadId();
    await this.sendRequest({
      topic,
      method: "wc_sessionEvent",
      params: { event, chainId },
      throwOnFailedPublish: true,
      relayRpcId,
      clientRpcId,
    });
  };

  public disconnect: IEngine["disconnect"] = async (params) => {
    this.isInitialized();
    await this.confirmOnlineStateOrThrow();
    await this.isValidDisconnect(params);
    const { topic } = params;
    if (this.client.session.keys.includes(topic)) {
      // await an ack to ensure the relay has received the disconnect request
      await this.sendRequest({
        topic,
        method: "wc_sessionDelete",
        params: getSdkError("USER_DISCONNECTED"),
        throwOnFailedPublish: true,
      });
      await this.deleteSession({ topic, emitEvent: false });
    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {
      await this.client.core.pairing.disconnect({ topic });
    } else {
      const { message } = getInternalError(
        "MISMATCHED_TOPIC",
        `Session or pairing topic not found: ${topic}`,
      );
      throw new Error(message);
    }
  };

  public find: IEngine["find"] = (params) => {
    this.isInitialized();
    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));
  };

  public getPendingSessionRequests: IEngine["getPendingSessionRequests"] = () => {
    return this.client.pendingRequest.getAll();
  };

  // ---------- Auth ------------------------------------------------ //

  public authenticate: IEngine["authenticate"] = async (params, walletUniversalLink) => {
    this.isInitialized();
    this.isValidAuthenticate(params);

    const isLinkMode =
      walletUniversalLink &&
      this.client.core.linkModeSupportedApps.includes(walletUniversalLink) &&
      this.client.metadata.redirect?.linkMode;

    const transportType: RelayerTypes.TransportType = isLinkMode
      ? TRANSPORT_TYPES.link_mode
      : TRANSPORT_TYPES.relay;

    if (transportType === TRANSPORT_TYPES.relay) {
      await this.confirmOnlineStateOrThrow();
    }

    const {
      chains,
      statement = "",
      uri,
      domain,
      nonce,
      type,
      exp,
      nbf,
      methods = [],
      expiry,
    } = params;
    // reassign resources to remove reference as the array is modified and might cause side effects
    const resources = [...(params.resources || [])];

    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({
      methods: ["wc_sessionAuthenticate"],
      transportType,
    });

    this.client.logger.info({
      message: "Generated new pairing",
      pairing: { topic: pairingTopic, uri: connectionUri },
    });

    const publicKey = await this.client.core.crypto.generateKeyPair();
    const responseTopic = hashKey(publicKey);

    await Promise.all([
      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),
      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),
    ]);

    // Subscribe to response topic
    await this.client.core.relayer.subscribe(responseTopic, { transportType });

    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);

    if (methods.length > 0) {
      const { namespace } = parseChainId(chains[0]);
      let recap = createEncodedRecap(namespace, "request", methods);
      const existingRecap = getRecapFromResources(resources);
      if (existingRecap) {
        // per Recaps spec, recap must occupy the last position in the resources array
        // using .pop to remove the element given we already checked it's a recap and will replace it
        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);
        recap = mergedRecap;
      }
      resources.push(recap);
    }

    // Ensure the expiry is greater than the minimum required for the request - currently 1h
    const authRequestExpiry =
      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl
        ? expiry
        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;

    const request: AuthTypes.SessionAuthenticateRequestParams = {
      authPayload: {
        type: type ?? "caip122",
        chains,
        statement,
        aud: uri,
        domain,
        version: "1",
        nonce,
        iat: new Date().toISOString(),
        exp,
        nbf,
        resources,
      },
      requester: { publicKey, metadata: this.client.metadata },
      expiryTimestamp: calcExpiry(authRequestExpiry),
    };

    // ----- build namespaces for fallback session proposal ----- //
    const namespaces = {
      eip155: {
        chains,
        // request `personal_sign` method by default to allow for fallback siwe
        methods: [...new Set(["personal_sign", ...methods])],
        events: ["chainChanged", "accountsChanged"],
      },
    };

    const proposal = {
      requiredNamespaces: {},
      optionalNamespaces: namespaces,
      relays: [{ protocol: "irn" }],
      pairingTopic,
      proposer: {
        publicKey,
        metadata: this.client.metadata,
      },
      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),
      id: payloadId(),
    };

    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, "Request expired");

    const authenticateId = payloadId();
    const sessionConnectEventTarget = engineEvent("session_connect", proposal.id);
    const authenticateEventTarget = engineEvent("session_request", authenticateId);

    // handle fallback session proposal response
    const onSessionConnect = async ({ error, session }: any) => {
      // cleanup listener for authenticate response
      this.events.off(authenticateEventTarget, onAuthenticate);
      if (error) reject(error);
      else if (session) {
        resolve({
          session,
        });
      }
    };
    // handle session authenticate response
    const onAuthenticate = async (payload: any) => {
      // delete this auth request on response
      // we're using payload from the wallet to establish the session so we don't need to keep this around
      await this.deletePendingAuthRequest(authenticateId, { message: "fulfilled", code: 0 });
      if (payload.error) {
        // wallets that do not support wc_sessionAuthenticate will return an error
        // we should not reject the promise in this case as the fallback session proposal will be used
        const error = getSdkError("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
        if (payload.error.code === error.code) return;

        // cleanup listener for fallback response
        this.events.off(sessionConnectEventTarget, onSessionConnect);
        return reject(payload.error.message);
      }
      // delete fallback proposal on successful authenticate as the proposal will not be responded to
      await this.deleteProposal(proposal.id);
      // cleanup listener for fallback response
      this.events.off(sessionConnectEventTarget, onSessionConnect);

      const {
        cacaos,
        responder,
      }: {
        cacaos: AuthTypes.SessionAuthenticateResponseParams["cacaos"];
        responder: AuthTypes.SessionAuthenticateResponseParams["responder"];
      } = payload.result;

      const approvedMethods: string[] = [];
      const approvedAccounts: string[] = [];
      for (const cacao of cacaos) {
        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });
        if (!isValid) {
          this.client.logger.error(cacao, "Signature verification failed");
          reject(getSdkError("SESSION_SETTLEMENT_FAILED", "Signature verification failed"));
        }

        const { p: payload } = cacao;
        const recap = getRecapFromResources(payload.resources);

        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];
        const parsedAddress = getDidAddress(payload.iss) as string;

        if (recap) {
          const methodsfromRecap = getMethodsFromRecap(recap);
          const chainsFromRecap = getChainsFromRecap(recap);
          approvedMethods.push(...methodsfromRecap);
          approvedChains.push(...chainsFromRecap);
        }

        for (const chain of approvedChains) {
          approvedAccounts.push(`${chain}:${parsedAddress}`);
        }
      }
      const sessionTopic = await this.client.core.crypto.generateSharedKey(
        publicKey,
        responder.publicKey,
      );

      //create session object
      let session: SessionTypes.Struct | undefined;

      if (approvedMethods.length > 0) {
        session = {
          topic: sessionTopic,
          acknowledged: true,
          self: {
            publicKey,
            metadata: this.client.metadata,
          },
          peer: responder,
          controller: responder.publicKey,
          expiry: calcExpiry(SESSION_EXPIRY),
          requiredNamespaces: {},
          optionalNamespaces: {},
          relay: { protocol: "irn" },
          pairingTopic,
          namespaces: buildNamespacesFromAuth(
            [...new Set(approvedMethods)],
            [...new Set(approvedAccounts)],
          ),
          transportType,
        };

        await this.client.core.relayer.subscribe(sessionTopic, { transportType });
        await this.client.session.set(sessionTopic, session);
        if (pairingTopic) {
          await this.client.core.pairing.updateMetadata({
            topic: pairingTopic,
            metadata: responder.metadata,
          });
        }

        session = this.client.session.get(sessionTopic);
      }

      if (
        this.client.metadata.redirect?.linkMode &&
        responder.metadata.redirect?.linkMode &&
        responder.metadata.redirect?.universal &&
        walletUniversalLink
      ) {
        // save wallet link in array of apps that support linkMode
        this.client.core.addLinkModeSupportedApp(responder.metadata.redirect.universal);

        this.client.session.update(sessionTopic, {
          transportType: TRANSPORT_TYPES.link_mode,
        });
      }

      resolve({
        auths: cacaos,
        session,
      });
    };

    // subscribe to response events
    this.events.once<"session_connect">(sessionConnectEventTarget, onSessionConnect);
    this.events.once(authenticateEventTarget, onAuthenticate);

    let linkModeURL;
    try {
      if (isLinkMode) {
        const payload = formatJsonRpcRequest("wc_sessionAuthenticate", request, authenticateId);
        this.client.core.history.set(pairingTopic, payload);
        const message = await this.client.core.crypto.encode("", payload, {
          type: TYPE_2,
          encoding: BASE64URL,
        });
        linkModeURL = getLinkModeURL(walletUniversalLink, pairingTopic, message);
      } else {
        // send both (main & fallback) requests
        await Promise.all([
          this.sendRequest({
            topic: pairingTopic,
            method: "wc_sessionAuthenticate",
            params: request,
            expiry: params.expiry,
            throwOnFailedPublish: true,
            clientRpcId: authenticateId,
          }),
          this.sendRequest({
            topic: pairingTopic,
            method: "wc_sessionPropose",
            params: proposal,
            expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,
            throwOnFailedPublish: true,
            clientRpcId: proposal.id,
          }),
        ]);
      }
    } catch (error) {
      // cleanup listeners on failed publish
      this.events.off(sessionConnectEventTarget, onSessionConnect);
      this.events.off(authenticateEventTarget, onAuthenticate);
      throw error;
    }

    await this.setProposal(proposal.id, proposal);
    await this.setAuthRequest(authenticateId, {
      request: {
        ...request,
        verifyContext: {} as any,
      },
      pairingTopic,
      transportType,
    });

    return {
      uri: linkModeURL ?? connectionUri,
      response: done,
    } as EngineTypes.SessionAuthenticateResponsePromise;
  };

  public approveSessionAuthenticate: IEngine["approveSessionAuthenticate"] = async (
    sessionAuthenticateResponseParams,
  ) => {
    const { id, auths } = sessionAuthenticateResponseParams;

    const event = this.client.core.eventClient.createEvent({
      properties: {
        topic: id.toString(),
        trace: [EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started],
      },
    });

    try {
      this.isInitialized();
    } catch (error) {
      event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection);
      throw error;
    }

    const pendingRequest = this.getPendingAuthRequest(id);

    if (!pendingRequest) {
      event.setError(
        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found,
      );
      throw new Error(`Could not find pending auth request with id ${id}`);
    }

    const transportType = pendingRequest.transportType || TRANSPORT_TYPES.relay;
    if (transportType === TRANSPORT_TYPES.relay) {
      await this.confirmOnlineStateOrThrow();
    }

    const receiverPublicKey = pendingRequest.requester.publicKey;
    const senderPublicKey = await this.client.core.crypto.generateKeyPair();
    const responseTopic = hashKey(receiverPublicKey);

    const encodeOpts = {
      type: TYPE_1,
      receiverPublicKey,
      senderPublicKey,
    };

    const approvedMethods: string[] = [];
    const approvedAccounts: string[] = [];
    for (const cacao of auths) {
      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });
      if (!isValid) {
        event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);

        const invalidErr = getSdkError(
          "SESSION_SETTLEMENT_FAILED",
          "Signature verification failed",
        );

        await this.sendError({
          id,
          topic: responseTopic,
          error: invalidErr,
          encodeOpts,
        });

        throw new Error(invalidErr.message);
      }

      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);

      const { p: payload } = cacao;
      const recap = getRecapFromResources(payload.resources);

      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];

      const parsedAddress = getDidAddress(payload.iss) as string;

      if (recap) {
        const methodsfromRecap = getMethodsFromRecap(recap);
        const chainsFromRecap = getChainsFromRecap(recap);
        approvedMethods.push(...methodsfromRecap);
        approvedChains.push(...chainsFromRecap);
      }
      for (const chain of approvedChains) {
        approvedAccounts.push(`${chain}:${parsedAddress}`);
      }
    }

    const sessionTopic = await this.client.core.crypto.generateSharedKey(
      senderPublicKey,
      receiverPublicKey,
    );

    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);

    let session: SessionTypes.Struct | undefined;
    if (approvedMethods?.length > 0) {
      session = {
        topic: sessionTopic,
        acknowledged: true,
        self: {
          publicKey: senderPublicKey,
          metadata: this.client.metadata,
        },
        peer: {
          publicKey: receiverPublicKey,
          metadata: pendingRequest.requester.metadata,
        },
        controller: receiverPublicKey,
        expiry: calcExpiry(SESSION_EXPIRY),
        authentication: auths,
        requiredNamespaces: {},
        optionalNamespaces: {},
        relay: { protocol: "irn" },
        pairingTopic: pendingRequest.pairingTopic,
        namespaces: buildNamespacesFromAuth(
          [...new Set(approvedMethods)],
          [...new Set(approvedAccounts)],
        ),
        transportType,
      };

      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);

      try {
        await this.client.core.relayer.subscribe(sessionTopic, { transportType });
      } catch (error) {
        event.setError(
          EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure,
        );
        throw error;
      }

      event.addTrace(
        EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success,
      );

      await this.client.session.set(sessionTopic, session);

      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session);

      await this.client.core.pairing.updateMetadata({
        topic: pendingRequest.pairingTopic,
        metadata: pendingRequest.requester.metadata,
      });
    }

    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);

    try {
      await this.sendResult<"wc_sessionAuthenticate">({
        topic: responseTopic,
        id,
        result: {
          cacaos: auths,
          responder: {
            publicKey: senderPublicKey,
            metadata: this.client.metadata,
          },
        },
        encodeOpts,
        throwOnFailedPublish: true,
        appLink: this.getAppLinkIfEnabled(pendingRequest.requester.metadata, transportType),
      });
    } catch (error) {
      event.setError(
        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure,
      );
      throw error;
    }

    await this.client.auth.requests.delete(id, { message: "fulfilled", code: 0 });
    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });
    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });

    return { session };
  };

  public rejectSessionAuthenticate: IEngine["rejectSessionAuthenticate"] = async (params) => {
    this.isInitialized();

    const { id, reason } = params;

    const pendingRequest = this.getPendingAuthRequest(id);

    if (!pendingRequest) {
      throw new Error(`Could not find pending auth request with id ${id}`);
    }

    if (pendingRequest.transportType === TRANSPORT_TYPES.relay) {
      await this.confirmOnlineStateOrThrow();
    }

    const receiverPublicKey = pendingRequest.requester.publicKey;
    const senderPublicKey = await this.client.core.crypto.generateKeyPair();
    const responseTopic = hashKey(receiverPublicKey);

    const encodeOpts = {
      type: TYPE_1,
      receiverPublicKey,
      senderPublicKey,
    };

    await this.sendError({
      id,
      topic: responseTopic,
      error: reason,
      encodeOpts,
      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,
      appLink: this.getAppLinkIfEnabled(
        pendingRequest.requester.metadata,
        pendingRequest.transportType,
      ),
    });
    await this.client.auth.requests.delete(id, { message: "rejected", code: 0 });
    await this.client.proposal.delete(id, getSdkError("USER_DISCONNECTED"));
  };

  public formatAuthMessage: IEngine["formatAuthMessage"] = (params) => {
    this.isInitialized();
    const { request, iss } = params;
    return formatMessage(request, iss);
  };

  public processRelayMessageCache: IEngine["processRelayMessageCache"] = () => {
    // process the relay messages cache in the next tick to allow event listeners to be registered by the implementing app
    setTimeout(async () => {
      if (this.relayMessageCache.length === 0) return;
      while (this.relayMessageCache.length > 0) {
        try {
          const message = this.relayMessageCache.shift();
          if (message) {
            await this.onRelayMessage(message);
          }
        } catch (error) {
          this.client.logger.error(error);
        }
      }
    }, 50);
  };

  // ---------- Private Helpers --------------------------------------- //

  private cleanupDuplicatePairings: EnginePrivate["cleanupDuplicatePairings"] = async (
    session: SessionTypes.Struct,
  ) => {
    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it
    if (!session.pairingTopic) return;

    try {
      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);
      const allPairings = this.client.core.pairing.pairings.getAll();
      const duplicates = allPairings.filter(
        (p) =>
          p.peerMetadata?.url &&
          p.peerMetadata?.url === session.peer.metadata.url &&
          p.topic &&
          p.topic !== pairing.topic,
      );
      if (duplicates.length === 0) return;
      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);
      await Promise.all(
        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),
      );
      this.client.logger.info(`Duplicate pairings clean up finished`);
    } catch (error) {
      this.client.logger.error(error);
    }
  };

  private deleteSession: EnginePrivate["deleteSession"] = async (params) => {
    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;
    const { self } = this.client.session.get(topic);
    // Await the unsubscribe first to avoid deleting the symKey too early below.
    await this.client.core.relayer.unsubscribe(topic);
    await this.client.session.delete(topic, getSdkError("USER_DISCONNECTED"));
    this.addToRecentlyDeleted(topic, "session");
    if (this.client.core.crypto.keychain.has(self.publicKey)) {
      await this.client.core.crypto.deleteKeyPair(self.publicKey);
    }
    if (this.client.core.crypto.keychain.has(topic)) {
      await this.client.core.crypto.deleteSymKey(topic);
    }
    if (!expirerHasDeleted) this.client.core.expirer.del(topic);
    // remove any deeplinks from storage after the session is deleted
    // to avoid navigating to incorrect deeplink later on
    this.client.core.storage
      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)
      .catch((e) => this.client.logger.warn(e));
    this.getPendingSessionRequests().forEach((r) => {
      if (r.topic === topic) {
        this.deletePendingSessionRequest(r.id, getSdkError("USER_DISCONNECTED"));
      }
    });
    // reset the queue state back to idle if a request for the deleted session is still in the queue
    if (topic === this.sessionRequestQueue.queue[0]?.topic) {
      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;
    }
    if (emitEvent) this.client.events.emit("session_delete", { id, topic });
  };

  private deleteProposal: EnginePrivate["deleteProposal"] = async (id, expirerHasDeleted) => {
    if (expirerHasDeleted) {
      try {
        const proposal = this.client.proposal.get(id);
        const event = this.client.core.eventClient.getEvent({ topic: proposal.pairingTopic });
        event?.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_expired);
      } catch (error) {}
    }
    await Promise.all([
      this.client.proposal.delete(id, getSdkError("USER_DISCONNECTED")),
      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),
    ]);
    this.addToRecentlyDeleted(id, "proposal");
  };

  private deletePendingSessionRequest: EnginePrivate["deletePendingSessionRequest"] = async (
    id,
    reason,
    expirerHasDeleted = false,
  ) => {
    await Promise.all([
      this.client.pendingRequest.delete(id, reason),
      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),
    ]);
    this.addToRecentlyDeleted(id, "request");
    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);
    if (expirerHasDeleted) {
      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;
      this.client.events.emit("session_request_expire", { id });
    }
  };

  private deletePendingAuthRequest: EnginePrivate["deletePendingAuthRequest"] = async (
    id,
    reason,
    expirerHasDeleted = false,
  ) => {
    await Promise.all([
      this.client.auth.requests.delete(id, reason),
      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),
    ]);
  };

  private setExpiry: EnginePrivate["setExpiry"] = async (topic, expiry) => {
    if (!this.client.session.keys.includes(topic)) return;
    this.client.core.expirer.set(topic, expiry);
    await this.client.session.update(topic, { expiry });
  };

  private setProposal: EnginePrivate["setProposal"] = async (id, proposal) => {
    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));
    await this.client.proposal.set(id, proposal);
  };

  private setAuthRequest: EnginePrivate["setAuthRequest"] = async (id, params) => {
    const { request, pairingTopic, transportType = TRANSPORT_TYPES.relay } = params;
    this.client.core.expirer.set(id, request.expiryTimestamp);
    await this.client.auth.requests.set(id, {
      authPayload: request.authPayload,
      requester: request.requester,
      expiryTimestamp: request.expiryTimestamp,
      id,
      pairingTopic,
      verifyContext: request.verifyContext,
      transportType,
    });
  };

  private setPendingSessionRequest: EnginePrivate["setPendingSessionRequest"] = async (
    pendingRequest: PendingRequestTypes.Struct,
  ) => {
    const { id, topic, params, verifyContext } = pendingRequest;
    const expiry =
      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);
    this.client.core.expirer.set(id, expiry);
    await this.client.pendingRequest.set(id, {
      id,
      topic,
      params,
      verifyContext,
    });
  };

  private sendRequest: EnginePrivate["sendRequest"] = async (args) => {
    const {
      topic,
      method,
      params,
      expiry,
      relayRpcId,
      clientRpcId,
      throwOnFailedPublish,
      appLink,
      tvf,
    } = args;
    const payload = formatJsonRpcRequest(method, params, clientRpcId);

    let message: string;
    const isLinkMode = !!appLink;

    try {
      const encoding = isLinkMode ? BASE64URL : BASE64;
      message = await this.client.core.crypto.encode(topic, payload, { encoding });
    } catch (error) {
      await this.cleanup();
      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);
      throw error;
    }

    let attestation: string | undefined;
    if (METHODS_TO_VERIFY.includes(method)) {
      const decryptedId = hashMessage(JSON.stringify(payload));
      const id = hashMessage(message);
      attestation = await this.client.core.verify.register({ id, decryptedId });
    }
    const opts = ENGINE_RPC_OPTS[method].req;
    opts.attestation = attestation;
    if (expiry) opts.ttl = expiry;
    if (relayRpcId) opts.id = relayRpcId;
    this.client.core.history.set(topic, payload);

    if (isLinkMode) {
      const redirectURL = getLinkModeURL(appLink, topic, message);
      await (global as any).Linking.openURL(redirectURL, this.client.name);
    } else {
      const opts = ENGINE_RPC_OPTS[method].req;
      if (expiry) opts.ttl = expiry;
      if (relayRpcId) opts.id = relayRpcId;

      opts.tvf = {
        ...tvf,
        correlationId: payload.id,
      };

      if (throwOnFailedPublish) {
        opts.internal = {
          ...opts.internal,
          throwOnFailedPublish: true,
        };
        await this.client.core.relayer.publish(topic, message, opts);
      } else {
        this.client.core.relayer
          .publish(topic, message, opts)
          .catch((error) => this.client.logger.error(error));
      }
    }

    return payload.id;
  };

  private sendResult: EnginePrivate["sendResult"] = async (args) => {
    const { id, topic, result, throwOnFailedPublish, encodeOpts, appLink } = args;
    const payload = formatJsonRpcResult(id, result);
    let message;
    const isLinkMode = appLink && typeof (global as any)?.Linking !== "undefined";

    try {
      const encoding = isLinkMode ? BASE64URL : BASE64;
      message = await this.client.core.crypto.encode(topic, payload, {
        ...(encodeOpts || {}),
        encoding,
      });
    } catch (error) {
      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable
      await this.cleanup();
      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);
      throw error;
    }
    let record;
    let tvf;
    try {
      record = await this.client.core.history.get(topic, id);
      const request = record.request;
      try {
        if (this.shouldSetTVF(request.method as JsonRpcTypes.WcMethod, request.params)) {
          tvf = this.getTVFParams(id, request.params, result);
        }
      } catch (error) {
        this.client.logger.warn(`sendResult() -> getTVFParams() failed`, error);
      }
    } catch (error) {
      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);
      throw error;
    }

    if (isLinkMode) {
      const redirectURL = getLinkModeURL(appLink, topic, message);
      await (global as any).Linking.openURL(redirectURL, this.client.name);
    } else {
      const method = record.request.method as JsonRpcTypes.WcMethod;
      const opts = ENGINE_RPC_OPTS[method].res;

      opts.tvf = {
        ...tvf,
        correlationId: id,
      };

      if (throwOnFailedPublish) {
        opts.internal = {
          ...opts.internal,
          throwOnFailedPublish: true,
        };
        await this.client.core.relayer.publish(topic, message, opts);
      } else {
        this.client.core.relayer
          .publish(topic, message, opts)
          .catch((error) => this.client.logger.error(error));
      }
    }

    await this.client.core.history.resolve(payload);
  };

  private sendError: EnginePrivate["sendError"] = async (params) => {
    const { id, topic, error, encodeOpts, rpcOpts, appLink } = params;
    const payload = formatJsonRpcError(id, error);
    let message;
    const isLinkMode = appLink && typeof (global as any)?.Linking !== "undefined";
    try {
      const encoding = isLinkMode ? BASE64URL : BASE64;
      message = await this.client.core.crypto.encode(topic, payload, {
        ...(encodeOpts || {}),
        encoding,
      });
    } catch (error) {
      await this.cleanup();
      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);
      throw error;
    }
    let record;
    try {
      record = await this.client.core.history.get(topic, id);
    } catch (error) {
      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);
      throw error;
    }

    if (isLinkMode) {
      const redirectURL = getLinkModeURL(appLink, topic, message);
      await (global as any).Linking.openURL(redirectURL, this.client.name);
    } else {
      const method = record.request.method as JsonRpcTypes.WcMethod;
      const opts = rpcOpts || ENGINE_RPC_OPTS[method].res;
      // await is intentionally omitted to speed up performance
      this.client.core.relayer.publish(topic, message, opts);
    }

    await this.client.core.history.resolve(payload);
  };

  private cleanup: EnginePrivate["cleanup"] = async () => {
    const sessionTopics: string[] = [];
    const proposalIds: number[] = [];
    this.client.session.getAll().forEach((session) => {
      let toCleanup = false;
      if (isExpired(session.expiry)) toCleanup = true;
      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;
      if (toCleanup) sessionTopics.push(session.topic);
    });
    this.client.proposal.getAll().forEach((proposal) => {
      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);
    });
    await Promise.all([
      ...sessionTopics.map((topic) => this.deleteSession({ topic })),
      ...proposalIds.map((id) => this.deleteProposal(id)),
    ]);
  };

  private isInitialized() {
    if (!this.initialized) {
      const { message } = getInternalError("NOT_INITIALIZED", this.name);
      throw new Error(message);
    }
  }

  private async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }

  // ---------- Relay Events Router ----------------------------------- //

  private registerRelayerEvents() {
    this.client.core.relayer.on(RELAYER_EVENTS.message, (event: RelayerTypes.MessageEvent) => {
      this.onProviderMessageEvent(event);
    });
  }

  private onProviderMessageEvent = async (event: RelayerTypes.MessageEvent) => {
    // capture any messages that arrive before the client is initialized so we can process them after initialization is complete
    if (!this.initialized || this.relayMessageCache.length > 0) {
      this.relayMessageCache.push(event);
    } else {
      await this.onRelayMessage(event);
    }
  };

  private async onRelayMessage(event: RelayerTypes.MessageEvent) {
    const { topic, message, attestation, transportType } = event;

    // Retrieve the public key (if defined) to decrypt possible `auth_request` response
    const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)
      ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)
      : ({ responseTopic: undefined, publicKey: undefined } as any);

    try {
      const payload = await this.client.core.crypto.decode(topic, message, {
        receiverPublicKey: publicKey,
        encoding: transportType === TRANSPORT_TYPES.link_mode ? BASE64URL : BASE64,
      });

      if (isJsonRpcRequest(payload)) {
        this.client.core.history.set(topic, payload);
        await this.onRelayEventRequest({
          topic,
          payload,
          attestation,
          transportType,
          encryptedId: hashMessage(message),
        });
      } else if (isJsonRpcResponse(payload)) {
        await this.client.core.history.resolve(payload);
        await this.onRelayEventResponse({ topic, payload, transportType });
        this.client.core.history.delete(topic, payload.id);
      } else {
        await this.onRelayEventUnknownPayload({ topic, payload, transportType });
      }
      await this.client.core.relayer.messages.ack(topic, message);
    } catch (error) {
      this.client.logger.error(error);
    }
  }

  private onRelayEventRequest: EnginePrivate["onRelayEventRequest"] = async (event) => {
    this.requestQueue.queue.push(event);
    await this.processRequestsQueue();
  };

  private processRequestsQueue = async () => {
    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {
      this.client.logger.info(`Request queue already active, skipping...`);
      return;
    }

    this.client.logger.info(
      `Request queue starting with ${this.requestQueue.queue.length} requests`,
    );

    while (this.requestQueue.queue.length > 0) {
      this.requestQueue.state = ENGINE_QUEUE_STATES.active;
      const request = this.requestQueue.queue.shift();
      if (!request) continue;

      try {
        await this.processRequest(request);
      } catch (error) {
        this.client.logger.warn(error);
      }
    }
    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;
  };

  private processRequest: EnginePrivate["onRelayEventRequest"] = async (event) => {
    const { topic, payload, attestation, transportType, encryptedId } = event;

    const reqMethod = payload.method as JsonRpcTypes.WcMethod;

    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {
      return;
    }

    switch (reqMethod) {
      case "wc_sessionPropose":
        return await this.onSessionProposeRequest({ topic, payload, attestation, encryptedId });
      case "wc_sessionSettle":
        return await this.onSessionSettleRequest(topic, payload);
      case "wc_sessionUpdate":
        return await this.onSessionUpdateRequest(topic, payload);
      case "wc_sessionExtend":
        return await this.onSessionExtendRequest(topic, payload);
      case "wc_sessionPing":
        return await this.onSessionPingRequest(topic, payload);
      case "wc_sessionDelete":
        return await this.onSessionDeleteRequest(topic, payload);
      case "wc_sessionRequest":
        return await this.onSessionRequest({
          topic,
          payload,
          attestation,
          encryptedId,
          transportType,
        });
      case "wc_sessionEvent":
        return await this.onSessionEventRequest(topic, payload);
      case "wc_sessionAuthenticate":
        return await this.onSessionAuthenticateRequest({
          topic,
          payload,
          attestation,
          encryptedId,
          transportType,
        });
      default:
        return this.client.logger.info(`Unsupported request method ${reqMethod}`);
    }
  };

  private onRelayEventResponse: EnginePrivate["onRelayEventResponse"] = async (event) => {
    const { topic, payload, transportType } = event;
    const record = await this.client.core.history.get(topic, payload.id);
    const resMethod = record.request.method as JsonRpcTypes.WcMethod;

    switch (resMethod) {
      case "wc_sessionPropose":
        return this.onSessionProposeResponse(topic, payload, transportType);
      case "wc_sessionSettle":
        return this.onSessionSettleResponse(topic, payload);
      case "wc_sessionUpdate":
        return this.onSessionUpdateResponse(topic, payload);
      case "wc_sessionExtend":
        return this.onSessionExtendResponse(topic, payload);
      case "wc_sessionPing":
        return this.onSessionPingResponse(topic, payload);
      case "wc_sessionRequest":
        return this.onSessionRequestResponse(topic, payload);
      case "wc_sessionAuthenticate":
        return this.onSessionAuthenticateResponse(topic, payload);
      default:
        return this.client.logger.info(`Unsupported response method ${resMethod}`);
    }
  };

  private onRelayEventUnknownPayload: EnginePrivate["onRelayEventUnknownPayload"] = (event) => {
    const { topic } = event;
    const { message } = getInternalError(
      "MISSING_OR_INVALID",
      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,
    );
    throw new Error(message);
  };

  private shouldIgnorePairingRequest: EnginePrivate["shouldIgnorePairingRequest"] = (params) => {
    const { topic, requestMethod } = params;
    const expectedMethods = this.expectedPairingMethodMap.get(topic);
    // check if the request method matches the expected method
    if (!expectedMethods) return false;
    if (expectedMethods.includes(requestMethod)) return false;

    /**
     * we want to make sure fallback session proposal is ignored only if there are subscribers
     * for the `session_authenticate` event, otherwise this would result in no-op for the user
     */
    if (expectedMethods.includes("wc_sessionAuthenticate")) {
      if (this.client.events.listenerCount("session_authenticate") > 0) {
        return true;
      }
    }
    return false;
  };

  // ---------- Relay Events Handlers --------------------------------- //

  private onSessionProposeRequest: EnginePrivate["onSessionProposeRequest"] = async (args) => {
    const { topic, payload, attestation, encryptedId } = args;
    const { params, id } = payload;
    try {
      const event = this.client.core.eventClient.getEvent({ topic });

      if (this.client.events.listenerCount("session_proposal") === 0) {
        console.warn("No listener for session_proposal event");
        event?.setError(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);
      }

      this.isValidConnect({ ...payload.params });
      const expiryTimestamp =
        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);
      const proposal = { id, pairingTopic: topic, expiryTimestamp, ...params };
      await this.setProposal(id, proposal);

      const verifyContext = await this.getVerifyContext({
        attestationId: attestation,
        hash: hashMessage(JSON.stringify(payload)),
        encryptedId,
        metadata: proposal.proposer.metadata,
      });

      event?.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal);

      this.client.events.emit("session_proposal", { id, params: proposal, verifyContext });
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,
      });
      this.client.logger.error(err);
    }
  };

  private onSessionProposeResponse: EnginePrivate["onSessionProposeResponse"] = async (
    topic,
    payload,
    transportType,
  ) => {
    const { id } = payload;
    if (isJsonRpcResult(payload)) {
      const { result } = payload;
      this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result });
      const proposal = this.client.proposal.get(id);
      this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal });
      const selfPublicKey = proposal.proposer.publicKey;
      this.client.logger.trace({
        type: "method",
        method: "onSessionProposeResponse",
        selfPublicKey,
      });
      const peerPublicKey = result.responderPublicKey;
      this.client.logger.trace({
        type: "method",
        method: "onSessionProposeResponse",
        peerPublicKey,
      });
      const sessionTopic = await this.client.core.crypto.generateSharedKey(
        selfPublicKey,
        peerPublicKey,
      );
      this.pendingSessions.set(id, {
        sessionTopic,
        pairingTopic: topic,
        proposalId: id,
        publicKey: selfPublicKey,
      });

      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic, {
        transportType,
      });
      this.client.logger.trace({
        type: "method",
        method: "onSessionProposeResponse",
        subscriptionId,
      });
      await this.client.core.pairing.activate({ topic });
    } else if (isJsonRpcError(payload)) {
      await this.client.proposal.delete(id, getSdkError("USER_DISCONNECTED"));
      const target = engineEvent("session_connect", id);
      const listeners = this.events.listenerCount(target);
      if (listeners === 0) {
        throw new Error(`emitting ${target} without any listeners, 954`);
      }
      this.events.emit(target, { error: payload.error });
    }
  };

  private onSessionSettleRequest: EnginePrivate["onSessionSettleRequest"] = async (
    topic,
    payload,
  ) => {
    const { id, params } = payload;
    try {
      this.isValidSessionSettleRequest(params);
      const {
        relay,
        controller,
        expiry,
        namespaces,
        sessionProperties,
        scopedProperties,
        sessionConfig,
      } = payload.params;
      const pendingSession = [...this.pendingSessions.values()].find(
        (s) => s.sessionTopic === topic,
      );

      if (!pendingSession) {
        return this.client.logger.error(`Pending session not found for topic ${topic}`);
      }

      const proposal = this.client.proposal.get(pendingSession.proposalId);

      const session: SessionTypes.Struct = {
        topic,
        relay,
        expiry,
        namespaces,
        acknowledged: true,
        pairingTopic: pendingSession.pairingTopic,
        requiredNamespaces: proposal.requiredNamespaces,
        optionalNamespaces: proposal.optionalNamespaces,
        controller: controller.publicKey,
        self: {
          publicKey: pendingSession.publicKey,
          metadata: this.client.metadata,
        },
        peer: {
          publicKey: controller.publicKey,
          metadata: controller.metadata,
        },
        ...(sessionProperties && { sessionProperties }),
        ...(scopedProperties && { scopedProperties }),
        ...(sessionConfig && { sessionConfig }),
        transportType: TRANSPORT_TYPES.relay,
      };

      await this.client.session.set(session.topic, session);
      await this.setExpiry(session.topic, session.expiry);

      await this.client.core.pairing.updateMetadata({
        topic: pendingSession.pairingTopic,
        metadata: session.peer.metadata,
      });

      this.client.events.emit("session_connect", { session });
      this.events.emit(engineEvent("session_connect", pendingSession.proposalId), { session });

      this.pendingSessions.delete(pendingSession.proposalId);
      this.deleteProposal(pendingSession.proposalId, false);
      this.cleanupDuplicatePairings(session);

      await this.sendResult<"wc_sessionSettle">({
        id: payload.id,
        topic,
        result: true,
        throwOnFailedPublish: true,
      });
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
      });
      this.client.logger.error(err);
    }
  };

  private onSessionSettleResponse: EnginePrivate["onSessionSettleResponse"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    if (isJsonRpcResult(payload)) {
      await this.client.session.update(topic, { acknowledged: true });
      this.events.emit(engineEvent("session_approve", id), {});
    } else if (isJsonRpcError(payload)) {
      await this.client.session.delete(topic, getSdkError("USER_DISCONNECTED"));
      this.events.emit(engineEvent("session_approve", id), { error: payload.error });
    }
  };

  private onSessionUpdateRequest: EnginePrivate["onSessionUpdateRequest"] = async (
    topic,
    payload,
  ) => {
    const { params, id } = payload;
    try {
      const memoryKey = `${topic}_session_update`;
      // compare the current request id with the last processed session update
      // we want to update only if the request is newer than the last processed one
      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);

      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {
        this.client.logger.warn(`Discarding out of sync request - ${id}`);
        this.sendError({ id, topic, error: getSdkError("INVALID_UPDATE_REQUEST") });
        return;
      }
      this.isValidUpdate({ topic, ...params });
      try {
        MemoryStore.set(memoryKey, id);
        await this.client.session.update(topic, { namespaces: params.namespaces });
        await this.sendResult<"wc_sessionUpdate">({
          id,
          topic,
          result: true,
          throwOnFailedPublish: true,
        });
      } catch (e) {
        MemoryStore.delete(memoryKey);
        throw e;
      }

      this.client.events.emit("session_update", { id, topic, params });
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
      });
      this.client.logger.error(err);
    }
  };

  // compares the timestamp of the last processed request with the current request
  // client <-> client rpc ID is timestamp + 3 random digits
  private isRequestOutOfSync = (lastId: number, currentId: number) => {
    return currentId.toString().slice(0, -3) < lastId.toString().slice(0, -3);
  };

  private onSessionUpdateResponse: EnginePrivate["onSessionUpdateResponse"] = (_topic, payload) => {
    const { id } = payload;
    const target = engineEvent("session_update", id);
    const listeners = this.events.listenerCount(target);
    if (listeners === 0) {
      throw new Error(`emitting ${target} without any listeners`);
    }
    if (isJsonRpcResult(payload)) {
      this.events.emit(engineEvent("session_update", id), {});
    } else if (isJsonRpcError(payload)) {
      this.events.emit(engineEvent("session_update", id), { error: payload.error });
    }
  };

  private onSessionExtendRequest: EnginePrivate["onSessionExtendRequest"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    try {
      this.isValidExtend({ topic });
      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));
      await this.sendResult<"wc_sessionExtend">({
        id,
        topic,
        result: true,
        throwOnFailedPublish: true,
      });
      this.client.events.emit("session_extend", { id, topic });
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
      });
      this.client.logger.error(err);
    }
  };

  private onSessionExtendResponse: EnginePrivate["onSessionExtendResponse"] = (_topic, payload) => {
    const { id } = payload;
    const target = engineEvent("session_extend", id);
    const listeners = this.events.listenerCount(target);
    if (listeners === 0) {
      throw new Error(`emitting ${target} without any listeners`);
    }
    if (isJsonRpcResult(payload)) {
      this.events.emit(engineEvent("session_extend", id), {});
    } else if (isJsonRpcError(payload)) {
      this.events.emit(engineEvent("session_extend", id), { error: payload.error });
    }
  };

  private onSessionPingRequest: EnginePrivate["onSessionPingRequest"] = async (topic, payload) => {
    const { id } = payload;
    try {
      this.isValidPing({ topic });
      await this.sendResult<"wc_sessionPing">({
        id,
        topic,
        result: true,
        throwOnFailedPublish: true,
      });
      this.client.events.emit("session_ping", { id, topic });
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
      });
      this.client.logger.error(err);
    }
  };

  private onSessionPingResponse: EnginePrivate["onSessionPingResponse"] = (_topic, payload) => {
    const { id } = payload;
    const target = engineEvent("session_ping", id);

    // put at the end of the stack to avoid a race condition
    // where session_ping listener is not yet initialized
    setTimeout(() => {
      const listeners = this.events.listenerCount(target);
      if (listeners === 0) {
        throw new Error(`emitting ${target} without any listeners 2176`);
      }

      if (isJsonRpcResult(payload)) {
        this.events.emit(engineEvent("session_ping", id), {});
      } else if (isJsonRpcError(payload)) {
        this.events.emit(engineEvent("session_ping", id), { error: payload.error });
      }
    }, 500);
  };

  private onSessionDeleteRequest: EnginePrivate["onSessionDeleteRequest"] = async (
    topic,
    payload,
  ) => {
    const { id } = payload;
    try {
      this.isValidDisconnect({ topic, reason: payload.params });
      Promise.all([
        new Promise((resolve) => {
          // RPC request needs to happen before deletion as it utalises session encryption
          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {
            resolve(await this.deleteSession({ topic, id }));
          });
        }),
        this.sendResult<"wc_sessionDelete">({
          id,
          topic,
          result: true,
          throwOnFailedPublish: true,
        }),
        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError("USER_DISCONNECTED") }),
      ]).catch((err) => this.client.logger.error(err));
    } catch (err: any) {
      this.client.logger.error(err);
    }
  };

  private onSessionRequest: EnginePrivate["onSessionRequest"] = async (args) => {
    const { topic, payload, attestation, encryptedId, transportType } = args;
    const { id, params } = payload;
    try {
      await this.isValidRequest({ topic, ...params });
      const session = this.client.session.get(topic);
      const verifyContext = await this.getVerifyContext({
        attestationId: attestation,
        hash: hashMessage(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", params, id))),
        encryptedId,
        metadata: session.peer.metadata,
        transportType,
      });
      const request = {
        id,
        topic,
        params,
        verifyContext,
      };
      await this.setPendingSessionRequest(request);

      if (
        transportType === TRANSPORT_TYPES.link_mode &&
        session.peer.metadata.redirect?.universal
      ) {
        // save app as supported for link mode
        this.client.core.addLinkModeSupportedApp(session.peer.metadata.redirect?.universal);
      }

      if (this.client.signConfig?.disableRequestQueue) {
        this.emitSessionRequest(request);
      } else {
        this.addSessionRequestToSessionRequestQueue(request);
        this.processSessionRequestQueue();
      }
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
      });
      this.client.logger.error(err);
    }
  };

  private onSessionRequestResponse: EnginePrivate["onSessionRequestResponse"] = (
    _topic,
    payload,
  ) => {
    const { id } = payload;
    const target = engineEvent("session_request", id);
    const listeners = this.events.listenerCount(target);
    if (listeners === 0) {
      throw new Error(`emitting ${target} without any listeners`);
    }
    if (isJsonRpcResult(payload)) {
      this.events.emit(engineEvent("session_request", id), { result: payload.result });
    } else if (isJsonRpcError(payload)) {
      this.events.emit(engineEvent("session_request", id), { error: payload.error });
    }
  };

  private onSessionEventRequest: EnginePrivate["onSessionEventRequest"] = async (
    topic,
    payload,
  ) => {
    const { id, params } = payload;
    try {
      // similar to session update, we want to discard out of sync requests
      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged
      const memoryKey = `${topic}_session_event_${params.event.name}`;
      // compare the current request id with the last processed session update
      // we want to update only if the request is newer than the last processed one
      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);
      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {
        this.client.logger.info(`Discarding out of sync request - ${id}`);
        return;
      }

      this.isValidEmit({ topic, ...params });
      this.client.events.emit("session_event", { id, topic, params });
      MemoryStore.set(memoryKey, id);
    } catch (err: any) {
      await this.sendError({
        id,
        topic,
        error: err,
      });
      this.client.logger.error(err);
    }
  };

  private onSessionAuthenticateResponse: EnginePrivate["onSessionAuthenticateResponse"] = (
    topic,
    payload,
  ) => {
    const { id } = payload;
    this.client.logger.trace({
      type: "method",
      method: "onSessionAuthenticateResponse",
      topic,
      payload,
    });
    if (isJsonRpcResult(payload)) {
      this.events.emit(engineEvent("session_request", id), { result: payload.result });
    } else if (isJsonRpcError(payload)) {
      this.events.emit(engineEvent("session_request", id), { error: payload.error });
    }
  };

  private onSessionAuthenticateRequest: EnginePrivate["onSessionAuthenticateRequest"] = async (
    args,
  ) => {
    const { topic, payload, attestation, encryptedId, transportType } = args;
    try {
      const { requester, authPayload, expiryTimestamp } = payload.params;
      const verifyContext = await this.getVerifyContext({
        attestationId: attestation,
        hash: hashMessage(JSON.stringify(payload)),
        encryptedId,
        metadata: requester.metadata,
        transportType,
      });
      const pendingRequest = {
        requester,
        pairingTopic: topic,
        id: payload.id,
        authPayload,
        verifyContext,
        expiryTimestamp,
      };
      await this.setAuthRequest(payload.id, {
        request: pendingRequest,
        pairingTopic: topic,
        transportType,
      });

      if (transportType === TRANSPORT_TYPES.link_mode && requester.metadata.redirect?.universal) {
        // save app as supported for link mode
        this.client.core.addLinkModeSupportedApp(requester.metadata.redirect.universal);
      }

      this.client.events.emit("session_authenticate", {
        topic,
        params: payload.params,
        id: payload.id,
        verifyContext,
      });
    } catch (err: any) {
      this.client.logger.error(err);

      const receiverPublicKey = payload.params.requester.publicKey;
      const senderPublicKey = await this.client.core.crypto.generateKeyPair();
      const appLink = this.getAppLinkIfEnabled(payload.params.requester.metadata, transportType);

      const encodeOpts = {
        type: TYPE_1,
        receiverPublicKey,
        senderPublicKey,
      };
      await this.sendError({
        id: payload.id,
        topic,
        error: err,
        encodeOpts,
        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,
        appLink,
      });
    }
  };

  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {
    this.sessionRequestQueue.queue.push(request);
  };

  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {
    this.deletePendingSessionRequest(params.response.id, { message: "fulfilled", code: 0 });
    // intentionally delay the emitting of the next pending request a bit
    setTimeout(() => {
      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;
      this.processSessionRequestQueue();
    }, toMiliseconds(this.requestQueueDelay));
  };

  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding
  private cleanupPendingSentRequestsForTopic = ({
    topic,
    error,
  }: {
    topic: string;
    error: ErrorResponse;
  }) => {
    const pendingRequests = this.client.core.history.pending;
    if (pendingRequests.length > 0) {
      const forSession = pendingRequests.filter(
        (r) => r.topic === topic && r.request.method === "wc_sessionRequest",
      );
      forSession.forEach((r) => {
        const id = r.request.id;
        const target = engineEvent("session_request", id);
        const listeners = this.events.listenerCount(target);
        if (listeners === 0) {
          throw new Error(`emitting ${target} without any listeners`);
        }
        // notify .request() handler of the rejection
        this.events.emit(engineEvent("session_request", r.request.id), {
          error,
        });
      });
    }
  };

  private processSessionRequestQueue = () => {
    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {
      this.client.logger.info("session request queue is already active.");
      return;
    }
    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)
    const request = this.sessionRequestQueue.queue[0];
    if (!request) {
      this.client.logger.info("session request queue is empty.");
      return;
    }

    try {
      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;
      this.emitSessionRequest(request);
    } catch (error) {
      this.client.logger.error(error);
    }
  };

  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {
    this.client.events.emit("session_request", request);
  };

  // ---------- Expirer Events ---------------------------------------- //

  private registerExpirerEvents() {
    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {
      const { topic, id } = parseExpirerTarget(event.target);
      if (id && this.client.pendingRequest.keys.includes(id)) {
        return await this.deletePendingSessionRequest(id, getInternalError("EXPIRED"), true);
      }
      if (id && this.client.auth.requests.keys.includes(id)) {
        return await this.deletePendingAuthRequest(id, getInternalError("EXPIRED"), true);
      }

      if (topic) {
        if (this.client.session.keys.includes(topic)) {
          await this.deleteSession({ topic, expirerHasDeleted: true });
          this.client.events.emit("session_expire", { topic });
        }
      } else if (id) {
        await this.deleteProposal(id, true);
        this.client.events.emit("proposal_expire", { id });
      }
    });
  }

  // ---------- Pairing Events ---------------------------------------- //
  private registerPairingEvents() {
    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>
      this.onPairingCreated(pairing),
    );
    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {
      this.addToRecentlyDeleted(pairing.topic, "pairing");
    });
  }

  /**
   * when a pairing is created, we check if there is a pending proposal for it.
   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.
   * It allows QR/URI to be scanned multiple times without having to create new pairing.
   */
  private onPairingCreated = (pairing: PairingTypes.Struct) => {
    if (pairing.methods) {
      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);
    }
    if (pairing.active) return;
    const proposals = this.client.proposal.getAll();
    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);
    if (!proposal) return;
    this.onSessionProposeRequest({
      topic: pairing.topic,
      payload: formatJsonRpcRequest(
        "wc_sessionPropose",
        {
          ...proposal,
          requiredNamespaces: proposal.requiredNamespaces,
          optionalNamespaces: proposal.optionalNamespaces,
          relays: proposal.relays,
          proposer: proposal.proposer,
          sessionProperties: proposal.sessionProperties,
          scopedProperties: proposal.scopedProperties,
        },
        proposal.id,
      ),
    });
  };

  // ---------- Validation Helpers ------------------------------------ //
  private isValidPairingTopic(topic: any) {
    if (!isValidString(topic, false)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `pairing topic should be a string: ${topic}`,
      );
      throw new Error(message);
    }
    if (!this.client.core.pairing.pairings.keys.includes(topic)) {
      const { message } = getInternalError(
        "NO_MATCHING_KEY",
        `pairing topic doesn't exist: ${topic}`,
      );
      throw new Error(message);
    }
    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {
      const { message } = getInternalError("EXPIRED", `pairing topic: ${topic}`);
      throw new Error(message);
    }
  }

  private async isValidSessionTopic(topic: any) {
    if (!isValidString(topic, false)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `session topic should be a string: ${topic}`,
      );
      throw new Error(message);
    }
    // Store will throw custom message if topic was recently deleted
    this.checkRecentlyDeleted(topic);
    if (!this.client.session.keys.includes(topic)) {
      const { message } = getInternalError(
        "NO_MATCHING_KEY",
        `session topic doesn't exist: ${topic}`,
      );
      throw new Error(message);
    }
    if (isExpired(this.client.session.get(topic).expiry)) {
      await this.deleteSession({ topic });
      const { message } = getInternalError("EXPIRED", `session topic: ${topic}`);
      throw new Error(message);
    }

    if (!this.client.core.crypto.keychain.has(topic)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `session topic does not exist in keychain: ${topic}`,
      );
      await this.deleteSession({ topic });
      throw new Error(message);
    }
  }

  private async isValidSessionOrPairingTopic(topic: string) {
    this.checkRecentlyDeleted(topic);
    if (this.client.session.keys.includes(topic)) {
      await this.isValidSessionTopic(topic);
    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {
      this.isValidPairingTopic(topic);
    } else if (!isValidString(topic, false)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `session or pairing topic should be a string: ${topic}`,
      );
      throw new Error(message);
    } else {
      const { message } = getInternalError(
        "NO_MATCHING_KEY",
        `session or pairing topic doesn't exist: ${topic}`,
      );
      throw new Error(message);
    }
  }

  private async isValidProposalId(id: any) {
    if (!isValidId(id)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `proposal id should be a number: ${id}`,
      );
      throw new Error(message);
    }
    if (!this.client.proposal.keys.includes(id)) {
      const { message } = getInternalError("NO_MATCHING_KEY", `proposal id doesn't exist: ${id}`);
      throw new Error(message);
    }
    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {
      await this.deleteProposal(id);
      const { message } = getInternalError("EXPIRED", `proposal id: ${id}`);
      throw new Error(message);
    }
  }

  // ---------- Validation  ------------------------------------------- //

  private isValidConnect: EnginePrivate["isValidConnect"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `connect() params: ${JSON.stringify(params)}`,
      );
      throw new Error(message);
    }
    const {
      pairingTopic,
      requiredNamespaces,
      optionalNamespaces,
      sessionProperties,
      scopedProperties,
      relays,
    } = params;
    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);

    if (!isValidRelays(relays, true)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `connect() relays: ${relays}`);
      throw new Error(message);
    }

    // validate required namespaces only if they are defined
    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {
      this.validateNamespaces(requiredNamespaces, "requiredNamespaces");
    }

    // validate optional namespaces only if they are defined
    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {
      this.validateNamespaces(optionalNamespaces, "optionalNamespaces");
    }

    // validate session properties only if they are defined
    if (!isUndefined(sessionProperties)) {
      this.validateSessionProps(sessionProperties, "sessionProperties");
    }

    if (!isUndefined(scopedProperties)) {
      this.validateSessionProps(scopedProperties, "scopedProperties");

      const requestedNamespaces = Object.keys(requiredNamespaces || {}).concat(
        Object.keys(optionalNamespaces || {}),
      );

      const scopedNamespaces = Object.keys(scopedProperties);
      const valid = scopedNamespaces.every((ns) => requestedNamespaces.includes(ns));
      if (!valid) {
        throw new Error(
          `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
            scopedProperties,
          )}, required/optional namespaces: ${JSON.stringify(requestedNamespaces)}`,
        );
      }
    }
  };

  private validateNamespaces = (
    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,
    type: string,
  ) => {
    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, "connect()", type);
    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);
  };

  private isValidApprove: EnginePrivate["isValidApprove"] = async (params) => {
    if (!isValidParams(params))
      throw new Error(
        getInternalError("MISSING_OR_INVALID", `approve() params: ${params}`).message,
      );
    const { id, namespaces, relayProtocol, sessionProperties, scopedProperties } = params;

    this.checkRecentlyDeleted(id);
    await this.isValidProposalId(id);
    const proposal = this.client.proposal.get(id);
    const validNamespacesError = isValidNamespaces(namespaces, "approve()");
    if (validNamespacesError) throw new Error(validNamespacesError.message);
    const conformingNamespacesError = isConformingNamespaces(
      proposal.requiredNamespaces,
      namespaces,
      "approve()",
    );
    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);
    if (!isValidString(relayProtocol, true)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `approve() relayProtocol: ${relayProtocol}`,
      );
      throw new Error(message);
    }

    if (!isUndefined(sessionProperties)) {
      this.validateSessionProps(sessionProperties, "sessionProperties");
    }

    if (!isUndefined(scopedProperties)) {
      this.validateSessionProps(scopedProperties, "scopedProperties");

      const approvedNamespaces = new Set(Object.keys(namespaces));
      const scopedNamespaces = Object.keys(scopedProperties);

      // the approved scoped namespaces must be a subset of the approved namespaces
      const valid = scopedNamespaces.every((ns) => approvedNamespaces.has(ns));
      if (!valid) {
        throw new Error(
          `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
            scopedProperties,
          )}, approved namespaces: ${Array.from(approvedNamespaces).join(", ")}`,
        );
      }
    }
  };

  private isValidReject: EnginePrivate["isValidReject"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `reject() params: ${params}`);
      throw new Error(message);
    }
    const { id, reason } = params;
    this.checkRecentlyDeleted(id);
    await this.isValidProposalId(id);
    if (!isValidErrorReason(reason)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `reject() reason: ${JSON.stringify(reason)}`,
      );
      throw new Error(message);
    }
  };

  private isValidSessionSettleRequest: EnginePrivate["isValidSessionSettleRequest"] = (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `onSessionSettleRequest() params: ${params}`,
      );
      throw new Error(message);
    }
    const { relay, controller, namespaces, expiry } = params;
    if (!isValidRelay(relay)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `onSessionSettleRequest() relay protocol should be a string`,
      );
      throw new Error(message);
    }
    const validControllerError = isValidController(controller, "onSessionSettleRequest()");
    if (validControllerError) throw new Error(validControllerError.message);
    const validNamespacesError = isValidNamespaces(namespaces, "onSessionSettleRequest()");
    if (validNamespacesError) throw new Error(validNamespacesError.message);
    if (isExpired(expiry)) {
      const { message } = getInternalError("EXPIRED", `onSessionSettleRequest()`);
      throw new Error(message);
    }
  };

  private isValidUpdate: EnginePrivate["isValidUpdate"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `update() params: ${params}`);
      throw new Error(message);
    }
    const { topic, namespaces } = params;

    this.checkRecentlyDeleted(topic);
    await this.isValidSessionTopic(topic);
    const session = this.client.session.get(topic);
    const validNamespacesError = isValidNamespaces(namespaces, "update()");
    if (validNamespacesError) throw new Error(validNamespacesError.message);
    const conformingNamespacesError = isConformingNamespaces(
      session.requiredNamespaces,
      namespaces,
      "update()",
    );
    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);
    // TODO(ilja) - check if wallet
  };

  private isValidExtend: EnginePrivate["isValidExtend"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `extend() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;

    this.checkRecentlyDeleted(topic);
    await this.isValidSessionTopic(topic);
  };

  private isValidRequest: EnginePrivate["isValidRequest"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `request() params: ${params}`);
      throw new Error(message);
    }
    const { topic, request, chainId, expiry } = params;
    this.checkRecentlyDeleted(topic);
    await this.isValidSessionTopic(topic);
    const { namespaces } = this.client.session.get(topic);
    if (!isValidNamespacesChainId(namespaces, chainId)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `request() chainId: ${chainId}`);
      throw new Error(message);
    }
    if (!isValidRequest(request)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `request() ${JSON.stringify(request)}`,
      );
      throw new Error(message);
    }
    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `request() method: ${request.method}`,
      );
      throw new Error(message);
    }
    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,
      );
      throw new Error(message);
    }
  };

  private isValidRespond: EnginePrivate["isValidRespond"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `respond() params: ${params}`);
      throw new Error(message);
    }
    const { topic, response } = params;
    try {
      // if the session is already disconnected, we can't respond to the request so we need to delete it
      await this.isValidSessionTopic(topic);
    } catch (error) {
      if (params?.response?.id) this.cleanupAfterResponse(params);
      throw error;
    }
    if (!isValidResponse(response)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `respond() response: ${JSON.stringify(response)}`,
      );
      throw new Error(message);
    }
  };

  private isValidPing: EnginePrivate["isValidPing"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `ping() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;
    await this.isValidSessionOrPairingTopic(topic);
  };

  private isValidEmit: EnginePrivate["isValidEmit"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `emit() params: ${params}`);
      throw new Error(message);
    }
    const { topic, event, chainId } = params;
    await this.isValidSessionTopic(topic);
    const { namespaces } = this.client.session.get(topic);
    if (!isValidNamespacesChainId(namespaces, chainId)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `emit() chainId: ${chainId}`);
      throw new Error(message);
    }
    if (!isValidEvent(event)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `emit() event: ${JSON.stringify(event)}`,
      );
      throw new Error(message);
    }
    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `emit() event: ${JSON.stringify(event)}`,
      );
      throw new Error(message);
    }
  };

  private isValidDisconnect: EnginePrivate["isValidDisconnect"] = async (params) => {
    if (!isValidParams(params)) {
      const { message } = getInternalError("MISSING_OR_INVALID", `disconnect() params: ${params}`);
      throw new Error(message);
    }
    const { topic } = params;
    await this.isValidSessionOrPairingTopic(topic);
  };

  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {
    const { chains, uri, domain, nonce } = params;

    // ----- validate params ----- //
    if (!Array.isArray(chains) || chains.length === 0) {
      throw new Error("chains is required and must be a non-empty array");
    }
    if (!isValidString(uri, false)) {
      throw new Error("uri is required parameter");
    }
    if (!isValidString(domain, false)) {
      throw new Error("domain is required parameter");
    }
    if (!isValidString(nonce, false)) {
      throw new Error("nonce is required parameter");
    }

    // ----- reject multi namespaces ----- //
    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];
    if (uniqueNamespaces.length > 1) {
      throw new Error(
        "Multi-namespace requests are not supported. Please request single namespace only.",
      );
    }

    const { namespace } = parseChainId(chains[0]);
    if (namespace !== "eip155") {
      throw new Error(
        "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.",
      );
    }
  };

  private getVerifyContext = async (params: {
    attestationId?: string;
    hash?: string;
    encryptedId?: string;
    metadata: CoreTypes.Metadata;
    transportType?: RelayerTypes.TransportType;
  }) => {
    const { attestationId, hash, encryptedId, metadata, transportType } = params;
    const context: Verify.Context = {
      verified: {
        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,
        validation: "UNKNOWN",
        origin: metadata.url || "",
      },
    };

    try {
      if (transportType === TRANSPORT_TYPES.link_mode) {
        const applink = this.getAppLinkIfEnabled(metadata, transportType);
        context.verified.validation =
          applink && new URL(applink).origin === new URL(metadata.url).origin ? "VALID" : "INVALID";
        return context;
      }
      const result = await this.client.core.verify.resolve({
        attestationId,
        hash,
        encryptedId,
        verifyUrl: metadata.verifyUrl,
      });
      if (result) {
        context.verified.origin = result.origin;
        context.verified.isScam = result.isScam;
        context.verified.validation =
          result.origin === new URL(metadata.url).origin ? "VALID" : "INVALID";
      }
    } catch (e) {
      this.client.logger.warn(e);
    }

    this.client.logger.debug(`Verify context: ${JSON.stringify(context)}`);
    return context;
  };

  private validateSessionProps = (properties: SessionTypes.ScopedProperties, type: string) => {
    Object.values(properties).forEach((property, index) => {
      if (property === null || property === undefined) {
        const { message } = getInternalError(
          "MISSING_OR_INVALID",
          `${type} must contain an existing value for each key. Received: ${property} for key ${
            Object.keys(properties)[index]
          }`,
        );
        throw new Error(message);
      }
    });
  };

  private getPendingAuthRequest = (id: number) => {
    const request = this.client.auth.requests.get(id);
    return typeof request === "object" ? request : undefined;
  };

  private addToRecentlyDeleted = (
    id: string | number,
    type: "pairing" | "session" | "proposal" | "request",
  ) => {
    this.recentlyDeletedMap.set(id, type);
    // remove first half of the map if it exceeds the limit
    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
      let i = 0;
      const numItemsToDelete = this.recentlyDeletedLimit / 2;
      for (const k of this.recentlyDeletedMap.keys()) {
        if (i++ >= numItemsToDelete) {
          break;
        }
        this.recentlyDeletedMap.delete(k);
      }
    }
  };

  private checkRecentlyDeleted = (id: string | number) => {
    const deletedRecord = this.recentlyDeletedMap.get(id);
    if (deletedRecord) {
      const { message } = getInternalError(
        "MISSING_OR_INVALID",
        `Record was recently deleted - ${deletedRecord}: ${id}`,
      );
      throw new Error(message);
    }
  };

  private isLinkModeEnabled = (
    peerMetadata?: CoreTypes.Metadata,
    transportType?: RelayerTypes.TransportType,
  ): boolean => {
    if (!peerMetadata || transportType !== TRANSPORT_TYPES.link_mode) return false;

    return (
      this.client.metadata?.redirect?.linkMode === true &&
      this.client.metadata?.redirect?.universal !== undefined &&
      this.client.metadata?.redirect?.universal !== "" &&
      peerMetadata?.redirect?.universal !== undefined &&
      peerMetadata?.redirect?.universal !== "" &&
      peerMetadata?.redirect?.linkMode === true &&
      this.client.core.linkModeSupportedApps.includes(peerMetadata.redirect.universal) &&
      typeof (global as any)?.Linking !== "undefined"
    );
  };

  private getAppLinkIfEnabled = (
    peerMetadata?: CoreTypes.Metadata,
    transportType?: RelayerTypes.TransportType,
  ): string | undefined => {
    return this.isLinkModeEnabled(peerMetadata, transportType)
      ? peerMetadata?.redirect?.universal
      : undefined;
  };

  private handleLinkModeMessage = ({ url }: { url: string }) => {
    if (!url || !url.includes("wc_ev") || !url.includes("topic")) return;

    const topic = getSearchParamFromURL(url, "topic") || "";
    const message = decodeURIComponent(getSearchParamFromURL(url, "wc_ev") || "");

    const sessionExists = this.client.session.keys.includes(topic);

    if (sessionExists) {
      this.client.session.update(topic, { transportType: TRANSPORT_TYPES.link_mode });
    }

    this.client.core.dispatchEnvelope({ topic, message, sessionExists });
  };

  private registerLinkModeListeners = async () => {
    if (isTestRun() || (isReactNative() && this.client.metadata.redirect?.linkMode)) {
      const linking = (global as any)?.Linking;
      // global.Linking is set by react-native-compat
      if (typeof linking !== "undefined") {
        // set URL listener
        linking.addEventListener("url", this.handleLinkModeMessage, this.client.name);

        // check for initial URL -> cold boots
        const initialUrl = await linking.getInitialURL();
        if (initialUrl) {
          // wait to process the message to allow event listeners to be registered by the implementing app
          setTimeout(() => {
            this.handleLinkModeMessage({ url: initialUrl });
          }, 50);
        }
      }
    }
  };

  private shouldSetTVF = (
    protocolMethod: JsonRpcTypes.WcMethod,
    params: JsonRpcTypes.RequestParams["wc_sessionRequest"],
  ) => {
    if (!params) return false;
    if (protocolMethod !== "wc_sessionRequest") return false;
    const { request } = params;
    return Object.keys(TVF_METHODS).includes(request.method);
  };

  private getTVFParams = (
    id: number,
    params: JsonRpcTypes.RequestParams["wc_sessionRequest"],
    result?: any,
  ) => {
    try {
      const requestMethod = params.request.method;
      const txHashes = this.extractTxHashesFromResult(requestMethod, result);
      const tvf: RelayerTypes.ITVF = {
        correlationId: id,
        rpcMethods: [requestMethod],
        chainId: params.chainId,
        ...(this.isValidContractData(params.request.params) && {
          // initially only get contractAddresses from EVM txs
          contractAddresses: [params.request.params?.[0]?.to],
        }),
        txHashes,
      };
      return tvf;
    } catch (e) {
      this.client.logger.warn("Error getting TVF params", e);
    }
    return {};
  };

  private isValidContractData = (params: any) => {
    if (!params) return false;
    try {
      const data = params?.data || params?.[0]?.data;

      if (!data.startsWith("0x")) return false;

      const hexPart = data.slice(2);
      if (!/^[0-9a-fA-F]*$/.test(hexPart)) return false;

      return hexPart.length % 2 === 0;
    } catch (e) {}
    return false;
  };

  private extractTxHashesFromResult = (method: string, result: any): string[] => {
    try {
      const methodConfig = TVF_METHODS[method as keyof typeof TVF_METHODS];
      // result = 0x...
      if (typeof result === "string") {
        return [result];
      }

      // result = { key: [0x...] } or { key: 0x... }
      const hashes: string[] = result[methodConfig.key];

      // result = { key: [0x...] }
      if (isValidArray(hashes)) {
        if (method === "solana_signAllTransactions") {
          return hashes.map((hash) => extractSolanaTransactionId(hash));
        }

        return hashes;

        // result = { key: 0x... }
      } else if (typeof hashes === "string") {
        return [hashes];
      }
    } catch (e) {
      this.client.logger.warn("Error extracting tx hashes from result", e);
    }
    return [];
  };
}
</file>

<file path="packages/sign-client/src/controllers/index.ts">
export * from "./engine";
export * from "./proposal";
export * from "./session";
export * from "./pendingRequest";
export * from "./authKey";
export * from "./authPairingTopic";
export * from "./authRequest";
export * from "./authStore";
</file>

<file path="packages/sign-client/src/controllers/pendingRequest.ts">
import { Store } from "@walletconnect/core";
import { Logger } from "@walletconnect/logger";
import { ICore, PendingRequestTypes } from "@walletconnect/types";
import { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from "../constants";

export class PendingRequest extends Store<number, PendingRequestTypes.Struct> {
  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(
      core,
      logger,
      REQUEST_CONTEXT,
      SIGN_CLIENT_STORAGE_PREFIX,
      (val: PendingRequestTypes.Struct) => val.id,
    );
  }
}
</file>

<file path="packages/sign-client/src/controllers/proposal.ts">
import { Store } from "@walletconnect/core";
import { Logger } from "@walletconnect/logger";
import { ICore, ProposalTypes } from "@walletconnect/types";

import { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from "../constants";

export class Proposal extends Store<number, ProposalTypes.Struct> {
  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);
  }
}
</file>

<file path="packages/sign-client/src/controllers/session.ts">
import { Store } from "@walletconnect/core";
import { Logger } from "@walletconnect/logger";
import { ICore, SessionTypes } from "@walletconnect/types";

import { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from "../constants";

export class Session extends Store<string, SessionTypes.Struct> {
  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);
  }
}
</file>

<file path="packages/sign-client/src/client.ts">
import { Core } from "@walletconnect/core";
import {
  generateChildLogger,
  getDefaultLoggerOptions,
  getLoggerContext,
  pino,
} from "@walletconnect/logger";
import { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from "@walletconnect/types";
import { ONE_SECOND, toMiliseconds } from "@walletconnect/time";
import { populateAppMetadata } from "@walletconnect/utils";
import { EventEmitter } from "events";
import { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from "./constants";
import { AuthStore, Engine, PendingRequest, Proposal, Session } from "./controllers";

export class SignClient extends ISignClient {
  public readonly protocol = SIGN_CLIENT_PROTOCOL;
  public readonly version = SIGN_CLIENT_VERSION;
  public readonly name: ISignClient["name"] = SIGN_CLIENT_DEFAULT.name;
  public readonly metadata: ISignClient["metadata"];

  public core: ISignClient["core"];
  public logger: ISignClient["logger"];
  public events: ISignClient["events"] = new EventEmitter();
  public engine: ISignClient["engine"];
  public session: ISignClient["session"];
  public proposal: ISignClient["proposal"];
  public pendingRequest: ISignClient["pendingRequest"];
  public auth: ISignClient["auth"];
  public signConfig?: ISignClient["signConfig"];

  static async init(opts?: SignClientTypes.Options) {
    const client = new SignClient(opts);
    await client.initialize();

    return client;
  }

  constructor(opts?: SignClientTypes.Options) {
    super(opts);

    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;
    this.metadata = populateAppMetadata(opts?.metadata);
    this.signConfig = opts?.signConfig;

    const logger =
      typeof opts?.logger !== "undefined" && typeof opts?.logger !== "string"
        ? opts.logger
        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));

    this.core = opts?.core || new Core(opts);
    this.logger = generateChildLogger(logger, this.name);
    this.session = new Session(this.core, this.logger);
    this.proposal = new Proposal(this.core, this.logger);
    this.pendingRequest = new PendingRequest(this.core, this.logger);
    this.engine = new Engine(this);
    this.auth = new AuthStore(this.core, this.logger);
  }

  get context() {
    return getLoggerContext(this.logger);
  }

  get pairing() {
    return this.core.pairing.pairings;
  }

  // ---------- Events ----------------------------------------------- //

  public on: ISignClientEvents["on"] = (name, listener) => {
    return this.events.on(name, listener);
  };

  public once: ISignClientEvents["once"] = (name, listener) => {
    return this.events.once(name, listener);
  };

  public off: ISignClientEvents["off"] = (name, listener) => {
    return this.events.off(name, listener);
  };

  public removeListener: ISignClientEvents["removeListener"] = (name, listener) => {
    return this.events.removeListener(name, listener);
  };

  public removeAllListeners: ISignClientEvents["removeAllListeners"] = (name) => {
    return this.events.removeAllListeners(name);
  };

  // ---------- Engine ----------------------------------------------- //

  public connect: ISignClient["connect"] = async (params) => {
    try {
      return await this.engine.connect(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public pair: ISignClient["pair"] = async (params) => {
    try {
      return await this.engine.pair(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public approve: ISignClient["approve"] = async (params) => {
    try {
      return await this.engine.approve(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public reject: ISignClient["reject"] = async (params) => {
    try {
      return await this.engine.reject(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public update: ISignClient["update"] = async (params) => {
    try {
      return await this.engine.update(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public extend: ISignClient["extend"] = async (params) => {
    try {
      return await this.engine.extend(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public request: ISignClient["request"] = async <T>(params: EngineTypes.RequestParams) => {
    try {
      return await this.engine.request<T>(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public respond: ISignClient["respond"] = async (params) => {
    try {
      return await this.engine.respond(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public ping: ISignClient["ping"] = async (params) => {
    try {
      return await this.engine.ping(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public emit: ISignClient["emit"] = async (params) => {
    try {
      return await this.engine.emit(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public disconnect: ISignClient["disconnect"] = async (params) => {
    try {
      return await this.engine.disconnect(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public find: ISignClient["find"] = (params) => {
    try {
      return this.engine.find(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public getPendingSessionRequests: ISignClient["getPendingSessionRequests"] = () => {
    try {
      return this.engine.getPendingSessionRequests();
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public authenticate: ISignClient["authenticate"] = async (params, walletUniversalLink) => {
    try {
      return await this.engine.authenticate(params, walletUniversalLink);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public formatAuthMessage: ISignClient["formatAuthMessage"] = (params) => {
    try {
      return this.engine.formatAuthMessage(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public approveSessionAuthenticate: ISignClient["approveSessionAuthenticate"] = async (params) => {
    try {
      return await this.engine.approveSessionAuthenticate(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  public rejectSessionAuthenticate: ISignClient["rejectSessionAuthenticate"] = async (params) => {
    try {
      return await this.engine.rejectSessionAuthenticate(params);
    } catch (error: any) {
      this.logger.error(error.message);
      throw error;
    }
  };

  // ---------- Private ----------------------------------------------- //

  private async initialize() {
    this.logger.trace(`Initialized`);
    try {
      await this.core.start();
      await this.session.init();
      await this.proposal.init();
      await this.pendingRequest.init();
      await this.auth.init();
      await this.engine.init();
      this.logger.info(`SignClient Initialization Success`);
      setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, toMiliseconds(ONE_SECOND));
    } catch (error: any) {
      this.logger.info(`SignClient Initialization Failure`);
      this.logger.error(error.message);
      throw error;
    }
  }
}
</file>

<file path="packages/sign-client/src/index.ts">
import { SignClient as Client } from "./client";
import { Session } from "./controllers/session";
export * from "./constants";

export const SessionStore = Session;
export const SignClient = Client;
export default Client;
</file>

<file path="packages/sign-client/test/canary/canary.spec.ts">
import { getSdkError } from "@walletconnect/utils";
import {
  initTwoClients,
  testConnectMethod,
  deleteClients,
  uploadCanaryResultsToCloudWatch,
  publishToStatusPage,
} from "../shared";
import {
  TEST_RELAY_URL,
  TEST_SIGN_CLIENT_OPTIONS_A,
  TEST_SIGN_CLIENT_OPTIONS_B,
} from "./../shared/values";
import { describe, it, expect, afterEach } from "vitest";
import { SignClient } from "../../src";

const environment = process.env.ENVIRONMENT || "dev";
const region = process.env.REGION || "unknown";
const logger = process.env.LOGGER || "error";
const log = (log: string) => {
  // eslint-disable-next-line no-console
  console.log(log);
};

describe("Canary", () => {
  const metric_prefix = "HappyPath.connects";
  describe("HappyPath", () => {
    it("connects", async () => {
      const initStart = Date.now();
      const handshakeClient = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS_A,
        logger,
      });
      const initLatencyMs = Date.now() - initStart;
      log(
        `Client A (${await handshakeClient.core.crypto.getClientId()}) initialized in ${initLatencyMs}ms`,
      );
      const handshakeStart = Date.now();
      //@ts-expect-error
      await handshakeClient.core.relayer.connect();
      const handshakeLatencyMs = Date.now() - handshakeStart;
      log(
        `Client A (${await handshakeClient.core.crypto.getClientId()}) initialized in ${handshakeLatencyMs}ms`,
      );
      await handshakeClient.core.relayer.transportClose();

      const aInitStart = Date.now();
      const A = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS_A,
        logger,
      });
      log(
        `Client A (${await A.core.crypto.getClientId()}) initialized in ${
          Date.now() - aInitStart
        }ms`,
      );

      const bInitStart = Date.now();
      const B = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS_B,
        logger,
      });
      log(
        `Client B (${await B.core.crypto.getClientId()}) initialized in ${
          Date.now() - bInitStart
        }ms`,
      );

      const start = Date.now();

      const clients = { A, B };
      log(
        `Clients initialized (relay '${TEST_RELAY_URL}'), client ids: A:'${await clients.A.core.crypto.getClientId()}';B:'${await clients.B.core.crypto.getClientId()}'`,
      );
      const humanInputLatencyMs = 600;
      const { pairingA, sessionA, clientAConnectLatencyMs, settlePairingLatencyMs } =
        await testConnectMethod(clients, { qrCodeScanLatencyMs: humanInputLatencyMs });
      log(
        `Clients connected (relay '${TEST_RELAY_URL}', client ids: A:'${await clients.A.core.crypto.getClientId()}';B:'${await clients.B.core.crypto.getClientId()}' pairing topic '${
          pairingA.topic
        }', session topic '${sessionA.topic}')`,
      );

      const successful = true;
      const pairingLatencyMs = Date.now() - start - humanInputLatencyMs;

      // Send a ping
      const pingStart = Date.now();
      await new Promise<void>(async (resolve, reject) => {
        try {
          clients.B.once("session_ping", (event) => {
            expect(sessionA.topic).to.eql(event.topic);
            resolve();
          });

          await clients.A.ping({ topic: sessionA.topic });
        } catch (e) {
          reject(e);
        }
      });
      const pingLatencyMs = Date.now() - pingStart;
      const latencyMs = Date.now() - start - 2 * humanInputLatencyMs;

      console.log(`Clients paired after ${pairingLatencyMs}ms`);
      if (environment !== "dev") {
        await uploadCanaryResultsToCloudWatch(
          environment,
          region,
          TEST_RELAY_URL,
          metric_prefix,
          successful,
          latencyMs,
          [
            { initLatency: initLatencyMs },
            { handshakeLatency: handshakeLatencyMs },
            { proposePairingLatency: clientAConnectLatencyMs },
            { settlePairingLatency: settlePairingLatencyMs - clientAConnectLatencyMs },
            { pairingLatency: pairingLatencyMs },
            { pingLatency: pingLatencyMs },
          ],
        );
      }

      if (environment === "prod") {
        await publishToStatusPage(latencyMs);
      }

      const clientDisconnect = new Promise<void>((resolve, reject) => {
        try {
          clients.B.on("session_delete", (event: any) => {
            expect(sessionA.topic).to.eql(event.topic);
            resolve();
          });
        } catch (e) {
          reject();
        }
      });

      await clients.A.disconnect({
        topic: sessionA.topic,
        reason: getSdkError("USER_DISCONNECTED"),
      });
      await clientDisconnect;
      log("Clients disconnected");
      for (const client of [clients.A, clients.B]) {
        if (client.core.relayer.connected) await client.core.relayer.transportClose();
      }
      log("Clients deleted");
    }, 600_000);
  });
  afterEach(async (done) => {
    const { result } = done.meta;
    const nowTimestamp = Date.now();
    const latencyMs = nowTimestamp - (result?.startTime || nowTimestamp);
    const taskState = result?.state;
    log(`Canary finished in state ${taskState} took ${latencyMs}ms`);
    if (environment !== "dev" && taskState?.toString() !== "pass") {
      await uploadCanaryResultsToCloudWatch(
        environment,
        region,
        TEST_RELAY_URL,
        metric_prefix,
        false,
        latencyMs,
        [],
      );
    }
  });
});
</file>

<file path="packages/sign-client/test/concurrency/concurrency.spec.ts">
import { getSdkError } from "@walletconnect/utils";
import SignClient from "../../src";
import {
  initTwoClients,
  testConnectMethod,
  TEST_SIGN_CLIENT_OPTIONS,
  uploadLoadTestConnectionDataToCloudWatch,
  deleteClients,
  Clients,
  TEST_EMIT_PARAMS,
  throttle,
  batchArray,
} from "./../shared";
import { TEST_RELAY_URL } from "./../shared/values";
import { describe, it, expect } from "vitest";

const environment = process.env.ENVIRONMENT || "dev";

describe("Sign Client Concurrency", () => {
  it("should successfully handle concurrent clients", async () => {
    const clientPairs = process.env.CLIENTS ? parseInt(process.env.CLIENTS) : 300000;
    const messagesToBeExchanged = process.env.MESSAGES_PER_CLIENT
      ? parseInt(process.env.MESSAGES_PER_CLIENT)
      : 1000; // minimum messages to be exchanged between clients
    const relayUrl =
      process.env.RELAY_URL || process.env.TEST_RELAY_URL || TEST_SIGN_CLIENT_OPTIONS.relayUrl;
    const heartbeatIntervalMs = process.env.HEARTBEAT_INTERVAL
      ? parseInt(process.env.HEARTBEAT_INTERVAL)
      : 3000;

    const pairings: any[] = [];
    const messagesReceived: any = {};

    const log = (log: string) => {
      // eslint-disable-next-line no-console
      console.log(log);
    };

    const heartBeat = setInterval(() => {
      log(`initialized pairs - ${pairings.length}`);
      log(
        `total messages exchanged - ${Object.values(messagesReceived).reduce(
          (messagesSum: any, messages: any) => parseInt(messagesSum) + parseInt(messages.length),
          0,
        )}`,
      );
    }, heartbeatIntervalMs);

    const processMessages = async (data: any, clientIndex: number) => {
      const { clients, sessionA } = data;
      const eventPayload: any = {
        topic: sessionA.topic,
        ...TEST_EMIT_PARAMS,
      };
      messagesReceived[clientIndex] = [];

      await new Promise<void>(async (resolve, reject) => {
        try {
          const clientsArr = [clients.A, clients.B];

          for await (const client of [clients.A, clients.B]) {
            client.on("session_ping", (event: any) => {
              expect(sessionA.topic).to.eql(event.topic);
              messagesReceived[clientIndex].push(event);
              validate();
            });

            client.on("session_event", (event: any) => {
              expect(TEST_EMIT_PARAMS).to.eql(event.params);
              expect(eventPayload.topic).to.eql(event.topic);
              messagesReceived[clientIndex].push(event);
              validate();
            });

            client.on("session_update", (event: any) => {
              expect(client.session.get(sessionA.topic).namespaces).to.eql(namespacesAfter);
              messagesReceived[clientIndex].push(event);
              validate();
            });
          }

          const namespacesBefore = sessionA.namespaces;
          const namespacesAfter = {
            ...namespacesBefore,
            eip9001: {
              accounts: ["eip9001:1:0x000000000000000000000000000000000000dead"],
              methods: ["eth_sendTransaction"],
              events: ["accountsChanged"],
            },
          };

          const emit = async (client: any) => {
            await client.emit(eventPayload);
          };

          const validate = () => {
            if (messagesReceived[clientIndex].length >= messagesToBeExchanged) {
              resolve();
            }
          };

          for (const i of Array.from(Array(messagesToBeExchanged).keys())) {
            const client: any = Math.floor(Math.random() * clientsArr.length);
            await emit(clientsArr[client]);
            await throttle(10); // throttle the messages/s to avoid being blocked by the relay
          }
        } catch (e) {
          reject(e);
        }
      });
    };

    // init clients and pair
    // we connect 10 clients at a time
    for await (const batch of batchArray(Array.from(Array(clientPairs).keys()), 100)) {
      const connections: {
        handshakeLatencyMs: number;
        pairingLatencyMs: number;
      }[] = await Promise.all(
        batch
          .map((i) => {
            return new Promise<{
              handshakeLatencyMs: number;
              pairingLatencyMs: number;
              connected: boolean;
            }>(async (resolve) => {
              const timeout = setTimeout(() => {
                log(`Client ${i} hung up`);
                resolve({ handshakeLatencyMs: -1, pairingLatencyMs: -1, connected: false });
              }, 120_000);

              const now = new Date().getTime();
              const clients: Clients = await initTwoClients({}, {}, { relayUrl });
              const handshakeLatencyMs = new Date().getTime() - now;
              await throttle(10);
              expect(clients.A instanceof SignClient).to.eql(true);
              expect(clients.B instanceof SignClient).to.eql(true);
              const { sessionA } = await testConnectMethod(clients);
              pairings.push({ clients, sessionA });
              clearTimeout(timeout);
              const pairingLatencyMs = new Date().getTime() - now;
              resolve({
                handshakeLatencyMs,
                pairingLatencyMs,
                connected: true,
              });
            });
          })
          .filter(
            (connectionResult: {
              handshakeLatencyMs: number;
              pairingLatencyMs: number;
              connected: boolean;
            }) => connectionResult.connected,
          ),
      );
      const averagePairingLatency =
        connections.map((connection) => connection.pairingLatencyMs).reduce((a, b) => a + b, 0) /
        connections.length;
      const averageHandhsakeLatency =
        connections.map((connection) => connection.handshakeLatencyMs).reduce((a, b) => a + b, 0) /
        connections.length;
      const failures = batch.length - connections.length;
      log(
        `${connections.length} out of ${batch.length} connected (${averagePairingLatency}ms avg pairing latency, ${averageHandhsakeLatency}ms avg handshake latency)`,
      );

      const metric_prefix = `Pairing`;
      await uploadLoadTestConnectionDataToCloudWatch(
        environment,
        TEST_RELAY_URL,
        metric_prefix,
        connections.length,
        failures,
        averagePairingLatency,
        averageHandhsakeLatency,
      );
    }

    // process all messages between clients in parallel
    await Promise.all(
      pairings.map(({ clients, sessionA }, i) => {
        return new Promise<void>(async (resolve) => {
          await processMessages({ clients, sessionA }, i);
          resolve();
        });
      }),
    );

    for await (const data of pairings) {
      const { clients, sessionA } = data;

      await Promise.all([
        new Promise<void>(async (resolve, reject) => {
          const eventPayload: any = {
            topic: sessionA.topic,
            ...TEST_EMIT_PARAMS,
          };

          try {
            clients.B.on("session_delete", (event: any) => {
              expect(eventPayload.topic).to.eql(event.topic);
              resolve();
            });
          } catch (e) {
            reject();
          }
        }),
        new Promise<void>((resolve) => {
          clients.A.disconnect({
            topic: sessionA.topic,
            reason: getSdkError("USER_DISCONNECTED"),
          });
          resolve();
        }),
      ]);
    }

    for (const data of pairings) {
      deleteClients(data.clients);
    }
    clearInterval(heartBeat);
  }, 1_200_000);
});
</file>

<file path="packages/sign-client/test/lifecycle/lifecycle.spec.ts">
import { getSdkError } from "@walletconnect/utils";
import { deleteClients, throttle, initTwoPairedClients } from "../shared";
import { TEST_RELAY_URL } from "../shared/values";
import { describe, it, expect, afterEach } from "vitest";

const environment = process.env.ENVIRONMENT || "dev";

const timeout = environment === "prod" ? 610_000 : 30_000;

const log = (log: string) => {
  // eslint-disable-next-line no-console
  console.log(log);
};

describe("Lifecycle", () => {
  describe("Reconnect", () => {
    it("reconnects", async () => {
      const { clients, pairingA, sessionA } = await initTwoPairedClients();
      log(
        `Clients initialized (relay '${TEST_RELAY_URL}'), client ids: A:'${await clients.A.core.crypto.getClientId()}';B:'${await clients.B.core.crypto.getClientId()}'`,
      );
      const humanInputLatencyMs = 600;
      log(
        `Clients connected (relay '${TEST_RELAY_URL}', client ids: A:'${await clients.A.core.crypto.getClientId()}';B:'${await clients.B.core.crypto.getClientId()}' pairing topic '${
          pairingA.topic
        }', session topic '${sessionA.topic}')`,
      );

      // Send a ping
      await throttle(humanInputLatencyMs); // Introduce some realistic timeout and allow backend to replicate

      await new Promise<void>(async (resolve, reject) => {
        try {
          clients.B.once("session_ping", (event) => {
            expect(sessionA.topic).to.eql(event.topic);
            resolve();
          });

          await clients.A.ping({ topic: sessionA.topic });
        } catch (e) {
          reject(e);
        }
      });

      log(`Going to wait for ${timeout / 1000}s until pinging again`);

      // Send a ping
      await throttle(humanInputLatencyMs); // Introduce some realistic timeout and allow backend to replicate
      await new Promise<void>(async (resolve, reject) => {
        try {
          clients.B.once("session_ping", (event) => {
            expect(sessionA.topic).to.eql(event.topic);
            resolve();
          });

          await clients.A.ping({ topic: sessionA.topic });
        } catch (e) {
          reject(e);
        }
      });

      await throttle(timeout); // Wait to trigger the reconnection logic

      await new Promise<void>(async (resolve, reject) => {
        try {
          clients.B.once("session_ping", (event) => {
            expect(sessionA.topic).to.eql(event.topic);
            resolve();
          });

          await clients.A.ping({ topic: sessionA.topic });
        } catch (e) {
          reject(e);
        }
      });

      const clientDisconnect = new Promise<void>((resolve, reject) => {
        try {
          clients.B.on("session_delete", (event: any) => {
            expect(sessionA.topic).to.eql(event.topic);
            resolve();
          });
        } catch (e) {
          reject();
        }
      });

      await clients.A.disconnect({
        topic: sessionA.topic,
        reason: getSdkError("USER_DISCONNECTED"),
      });
      await clientDisconnect;
      log("Clients disconnected");
      await deleteClients(clients);
      log("Clients deleted");
    }, 70000_000);
  });
  afterEach(async (done) => {
    const { result } = done.meta;
    const nowTimestamp = Date.now();
    const latencyMs = nowTimestamp - (result?.startTime || nowTimestamp);
    log(`Lifecycle test finished in state ${result?.state} took ${latencyMs}ms`);
  });
});
</file>

<file path="packages/sign-client/test/sdk/integration/events.spec.ts">
import { createExpiringPromise, getSdkError } from "@walletconnect/utils";
import { expect, describe, it, beforeAll, afterAll } from "vitest";
import {
  initTwoClients,
  testConnectMethod,
  deleteClients,
  TEST_EMIT_PARAMS,
  Clients,
  TESTS_CONNECT_RETRIES,
  TESTS_CONNECT_TIMEOUT,
  initTwoPairedClients,
} from "../../shared";
import { EngineTypes, PairingTypes, SessionTypes } from "@walletconnect/types";

// skip tests as they are already tested in integration.spec.ts
describe.skip("Sign Client Events Validation", () => {
  let clients: Clients;
  let pairingA: PairingTypes.Struct;
  let sessionA: SessionTypes.Struct;

  beforeAll(async () => {
    ({ clients, pairingA, sessionA } = await initTwoPairedClients());
  });

  afterAll(async () => {
    await deleteClients(clients);
  });

  describe("session", () => {
    describe("session_update", () => {
      it("emits and handles a valid session_update", async () => {
        await new Promise<void>(async (resolve, reject) => {
          try {
            const namespacesBefore = sessionA.namespaces;
            const namespacesAfter = {
              ...namespacesBefore,
              eip9001: {
                accounts: ["eip9001:1:0x000000000000000000000000000000000000dead"],
                methods: ["eth_sendTransaction"],
                events: ["accountsChanged"],
              },
            };

            clients.B.once("session_update", () => {
              expect(clients.A.session.get(sessionA.topic).namespaces).to.eql(namespacesAfter);
              resolve();
            });

            const { acknowledged } = await clients.A.update({
              topic: sessionA.topic,
              namespaces: namespacesAfter,
            });
            await acknowledged();
          } catch (e) {
            reject(e);
          }
        });
      });
    });
    describe("session_ping", () => {
      it("emits and handles a valid session_ping", async () => {
        await new Promise<void>(async (resolve, reject) => {
          try {
            clients.B.once("session_ping", (event) => {
              expect(sessionA.topic).to.eql(event.topic);
              resolve();
            });
            await clients.A.ping({ topic: sessionA.topic });
          } catch (e) {
            reject(e);
          }
        });
      });
    });
    describe("session_event", () => {
      it("emits and handles a valid session_event", async () => {
        const eventPayload: EngineTypes.EmitParams = {
          topic: sessionA.topic,
          ...TEST_EMIT_PARAMS,
        };

        await new Promise<void>(async (resolve, reject) => {
          try {
            clients.B.on("session_event", (event) => {
              expect(TEST_EMIT_PARAMS).to.eql(event.params);
              expect(eventPayload.topic).to.eql(event.topic);
              resolve();
            });

            await clients.A.emit(eventPayload);
          } catch (e) {
            reject(e);
          }
        });
      });
    });
    describe("session_delete", () => {
      it("emits and handles a valid session_delete", async () => {
        const eventPayload: EngineTypes.EmitParams = {
          topic: sessionA.topic,
          ...TEST_EMIT_PARAMS,
        };

        const activeSessions = clients.B.session.getAll();
        expect(activeSessions.length).to.eql(1);

        await new Promise<void>(async (resolve, reject) => {
          try {
            clients.B.on("session_delete", (event) => {
              expect(eventPayload.topic).to.eql(event.topic);

              const sessionsLeft = clients.B.session.getAll();
              expect(sessionsLeft.length).to.eql(0);
              resolve();
            });
            await clients.A.disconnect({
              topic: sessionA.topic,
              reason: getSdkError("USER_DISCONNECTED"),
            });
          } catch (e) {
            reject(e);
          }
        });
      });
    });
  });
});
</file>

<file path="packages/sign-client/test/sdk/integration/integration.spec.ts">
/* eslint-disable no-console */
import { getSdkError } from "@walletconnect/utils";
import { expect, describe, it } from "vitest";
import { deleteClients, initTwoPairedClients } from "../../shared";

describe("Sign Client Integration", () => {
  it("should connect, ping, restart transport, ping & disconnect", async () => {
    const { clients, sessionA } = await initTwoPairedClients({}, {}, { logger: "error" });
    console.log("Step 1: Connect done ✅");
    await Promise.all([
      new Promise<void>((resolve) => {
        clients.B.once("session_ping", (event) => {
          expect(sessionA.topic).to.eql(event.topic);
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        clients.A.once("session_ping", (event) => {
          expect(sessionA.topic).to.eql(event.topic);
          resolve();
        });
      }),
      clients.A.ping({ topic: sessionA.topic }),
      clients.B.ping({ topic: sessionA.topic }),
    ]);
    console.log("Step 2: Ping done ✅");
    await clients.A.core.relayer.restartTransport();
    await clients.B.core.relayer.restartTransport();
    console.log("Step 3: Restart transport done ✅");
    await Promise.all([
      new Promise<void>((resolve) => {
        clients.B.once("session_ping", (event) => {
          expect(sessionA.topic).to.eql(event.topic);
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        clients.A.once("session_ping", (event) => {
          expect(sessionA.topic).to.eql(event.topic);
          resolve();
        });
      }),
      clients.A.ping({ topic: sessionA.topic }),
      clients.B.ping({ topic: sessionA.topic }),
    ]);
    console.log("Step 4: Ping done ✅");
    await Promise.all([
      new Promise<void>((resolve) => {
        clients.B.once("session_delete", (event) => {
          expect(sessionA.topic).to.eql(event.topic);
          resolve();
        });
      }),
      clients.A.disconnect({
        topic: sessionA.topic,
        reason: getSdkError("USER_DISCONNECTED"),
      }),
    ]);
    console.log("Step 5: Disconnect done ✅");
    await deleteClients(clients);
    console.log("Step 6: Delete clients done ✅");
  });
});
</file>

<file path="packages/sign-client/test/sdk/integration/push.spec.ts">
import axios from "axios";
import {
  deleteClients,
  TEST_EMIT_PARAMS,
  TEST_WEBHOOK_DELAY_MS,
  TEST_WEBHOOK_ENDPOINT,
  throttle,
  Clients,
  initTwoPairedClients,
} from "../../shared";
import { describe, it, expect, afterEach, beforeAll } from "vitest";
import { PairingTypes, SessionTypes } from "@walletconnect/types";

describe("Push", () => {
  let clients: Clients;
  let pairingA: PairingTypes.Struct;
  let sessionA: SessionTypes.Struct;

  beforeAll(async () => {
    ({ clients, pairingA, sessionA } = await initTwoPairedClients());
  });

  it("receives a prompt webhook", async () => {
    // Send a message which triggers the webhook to be invoked
    const eventPayload: any = {
      topic: sessionA.topic,
      ...TEST_EMIT_PARAMS,
    };
    await clients.A.emit(eventPayload);

    // Relay processes webhooks in background
    // Extend some time to relay to process it
    await throttle(TEST_WEBHOOK_DELAY_MS);

    const url = `${TEST_WEBHOOK_ENDPOINT}/${await clients.B.core.crypto.getClientId()}`.replace(
      "did:key:",
      "",
    );

    // Validate webhook was called
    const res = await axios.get(url);
    expect(res.data.payload.payload.topic).to.eql(sessionA.topic);
    expect(res.data.payload.payload.flags).to.eql(2);
    expect(res.status).to.eql(200);
  });
  afterEach(async () => {
    await deleteClients(clients);
  });
});
</file>

<file path="packages/sign-client/test/sdk/auth.spec.ts">
/* eslint-disable no-console */
import { expect, describe, it, beforeAll } from "vitest";
import { ENGINE_RPC_OPTS, SignClient } from "../../src";
import { TEST_APP_METADATA_B, TEST_SIGN_CLIENT_OPTIONS, deleteClients, throttle } from "../shared";
import {
  buildApprovedNamespaces,
  buildAuthObject,
  getSdkError,
  populateAuthPayload,
} from "@walletconnect/utils";
import { AuthTypes } from "@walletconnect/types";
import { Wallet as CryptoWallet } from "@ethersproject/wallet";
import { formatJsonRpcResult } from "@walletconnect/jsonrpc-utils";
import { RELAYER_EVENTS } from "@walletconnect/core";

describe("Authenticated Sessions", () => {
  let cryptoWallet: CryptoWallet;

  beforeAll(() => {
    cryptoWallet = CryptoWallet.createRandom();
  });
  // this test simulates the scenario where the wallet supports all the requested chains and methods
  // and replies with a single signature
  it("should establish authenticated session with single signature. Case 1", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      Promise.race<void>([
        new Promise((resolve) => {
          wallet.on("session_authenticate", async (payload) => {
            const verifyContext = payload.verifyContext;
            expect(verifyContext).to.exist;
            expect(verifyContext.verified.validation).to.eq("UNKNOWN");

            // validate that the dapp has both `session_authenticate` & `session_proposal` stored
            // and expirer configured
            const pendingProposals = dapp.proposal.getAll();
            expect(pendingProposals.length).to.eq(1);
            expect(dapp.core.expirer.keys).to.include(`id:${pendingProposals[0].id}`);
            expect(dapp.core.expirer.get(pendingProposals[0].id)).to.exist;
            expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.exist;
            expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.be.greaterThan(0);

            const pendingAuthRequests = dapp.auth.requests.getAll();
            expect(pendingAuthRequests.length).to.eq(1);
            expect(dapp.core.expirer.keys).to.include(`id:${pendingAuthRequests[0].id}`);
            expect(dapp.core.expirer.get(pendingAuthRequests[0].id)).to.exist;
            expect(dapp.core.expirer.get(pendingAuthRequests[0].id)?.expiry).to.exist;
            expect(dapp.core.expirer.get(pendingAuthRequests[0].id)?.expiry).to.be.greaterThan(0);
            expect(pendingAuthRequests[0].id).to.eq(payload.id);

            // validate that the wallet doesn't have any pending proposals
            const pendingProposalsWallet = wallet.proposal.getAll();
            expect(pendingProposalsWallet.length).to.eq(0);

            const authPayload = populateAuthPayload({
              authPayload: payload.params.authPayload,
              chains: requestedChains,
              methods: requestedMethods,
            });
            const iss = `${requestedChains[0]}:${cryptoWallet.address}`;
            const message = wallet.engine.formatAuthMessage({
              request: authPayload,
              iss,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              authPayload,
              {
                t: "eip191",
                s: sig,
              },
              iss,
            );
            await wallet.approveSessionAuthenticate({
              id: payload.id,
              auths: [auth],
            });
            resolve();
          });
        }),
        new Promise((_, reject) => {
          wallet.on("session_proposal", () => {
            reject(new Error("wallet should not emit session_proposal"));
          });
        }),
      ]),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((res) => res[2]);
    const session = result.session;
    const walletSession = wallet.session.get(session.topic);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: "eip155:1",
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    // confirm that all pending proposals and auth requests have been cleared
    expect(wallet.proposal.getAll().length).to.eq(0);
    expect(wallet.auth.requests.getAll().length).to.eq(0);
    expect(dapp.proposal.getAll().length).to.eq(0);
    expect(dapp.auth.requests.getAll().length).to.eq(0);

    await deleteClients({ A: dapp, B: wallet });
  });
  // this test simulates the scenario where the wallet supports subset of the requested chains and all methods
  // and replies with a single signature
  it("should establish authenticated session with single signature. Case 2", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const supportedChains = [requestedChains[1]];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          // validate that the dapp has both `session_authenticate` & `session_proposal` stored
          // and expirer configured
          const pendingProposals = dapp.proposal.getAll();
          expect(pendingProposals.length).to.eq(1);
          expect(dapp.core.expirer.keys).to.include(`id:${pendingProposals[0].id}`);
          expect(dapp.core.expirer.get(pendingProposals[0].id)).to.exist;
          expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.exist;
          expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.be.greaterThan(0);

          const pendingAuthRequests = dapp.auth.requests.getAll();
          expect(pendingAuthRequests.length).to.eq(1);
          expect(dapp.core.expirer.keys).to.include(`id:${pendingAuthRequests[0].id}`);
          expect(dapp.core.expirer.get(pendingAuthRequests[0].id)).to.exist;
          expect(dapp.core.expirer.get(pendingAuthRequests[0].id)?.expiry).to.exist;
          expect(dapp.core.expirer.get(pendingAuthRequests[0].id)?.expiry).to.be.greaterThan(0);
          expect(pendingAuthRequests[0].id).to.eq(payload.id);

          // validate that the wallet doesn't have any pending proposals
          const pendingProposalsWallet = wallet.proposal.getAll();
          expect(pendingProposalsWallet.length).to.eq(0);

          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: supportedChains,
            methods: requestedMethods,
          });
          const iss = `${supportedChains[0]}:${cryptoWallet.address}`;
          const message = wallet.engine.formatAuthMessage({
            request: authPayload,
            iss,
          });
          const sig = await cryptoWallet.signMessage(message);
          const auth = buildAuthObject(
            authPayload,
            {
              t: "eip191",
              s: sig,
            },
            iss,
          );
          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths: [auth],
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const session = result.session;
    const walletSession = wallet.session.get(session.topic);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: supportedChains[0],
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);
    // confirm that all pending proposals and auth requests have been cleared
    expect(wallet.proposal.getAll().length).to.eq(0);
    expect(wallet.auth.requests.getAll().length).to.eq(0);
    expect(dapp.proposal.getAll().length).to.eq(0);
    expect(dapp.auth.requests.getAll().length).to.eq(0);

    await deleteClients({ A: dapp, B: wallet });
  });
  // this test simulates the scenario where the wallet supports subset of the requested chains and methods
  // and replies with a single signature
  it("should establish authenticated session with single signature. Case 3", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const supportedChains = [requestedChains[1]];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const supportedMethods = [requestedMethods[0]];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const verifyContext = payload.verifyContext;
          expect(verifyContext).to.exist;
          expect(verifyContext.verified.validation).to.eq("UNKNOWN");

          // validate that the dapp has both `session_authenticate` & `session_proposal` stored
          // and expirer configured
          const pendingProposals = dapp.proposal.getAll();
          expect(pendingProposals.length).to.eq(1);
          expect(dapp.core.expirer.keys).to.include(`id:${pendingProposals[0].id}`);
          expect(dapp.core.expirer.get(pendingProposals[0].id)).to.exist;
          expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.exist;
          expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.be.greaterThan(0);

          const pendingAuthRequests = dapp.auth.requests.getAll();
          expect(pendingAuthRequests.length).to.eq(1);
          expect(dapp.core.expirer.keys).to.include(`id:${pendingAuthRequests[0].id}`);
          expect(dapp.core.expirer.get(pendingAuthRequests[0].id)).to.exist;
          expect(dapp.core.expirer.get(pendingAuthRequests[0].id)?.expiry).to.exist;
          expect(dapp.core.expirer.get(pendingAuthRequests[0].id)?.expiry).to.be.greaterThan(0);
          expect(pendingAuthRequests[0].id).to.eq(payload.id);

          // validate that the wallet doesn't have any pending proposals
          const pendingProposalsWallet = wallet.proposal.getAll();
          expect(pendingProposalsWallet.length).to.eq(0);

          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: supportedChains,
            methods: supportedMethods,
          });
          const iss = `${supportedChains[0]}:${cryptoWallet.address}`;
          const message = wallet.engine.formatAuthMessage({
            request: authPayload,
            iss,
          });
          const sig = await cryptoWallet.signMessage(message);
          const auth = buildAuthObject(
            authPayload,
            {
              t: "eip191",
              s: sig,
            },
            iss,
          );
          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths: [auth],
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const session = result.session;
    const walletSession = wallet.session.get(session.topic);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: supportedChains[0],
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });
  // this test simulates the scenario where the wallet supports all requested chains and subset of methods
  // and replies with a single signature
  it("should establish authenticated session with single signature. Case 4", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const supportedChains = requestedChains;
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const supportedMethods = [requestedMethods[0]];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: supportedChains,
            methods: supportedMethods,
          });
          const iss = `${supportedChains[1]}:${cryptoWallet.address}`;
          const message = wallet.engine.formatAuthMessage({
            request: authPayload,
            iss,
          });
          const sig = await cryptoWallet.signMessage(message);
          const auth = buildAuthObject(
            authPayload,
            {
              t: "eip191",
              s: sig,
            },
            iss,
          );
          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths: [auth],
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const session = result.session;
    const walletSession = wallet.session.get(session.topic);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        await dapp.request({
          chainId: supportedChains[1],
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });

  // this test simulates the scenario where the wallet supports all the requested chains and methods
  it("should establish authenticated session with multiple signatures. Case 1", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: requestedChains,
            methods: requestedMethods,
          });

          const auths: AuthTypes.Cacao[] = [];
          authPayload.chains.forEach(async (chain) => {
            const iss = `${chain}:${cryptoWallet.address}`;
            const message = wallet.engine.formatAuthMessage({
              request: authPayload,
              iss,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              authPayload,
              {
                t: "eip191",
                s: sig,
              },
              iss,
            );
            auths.push(auth);
          });

          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths,
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const { session, auths } = result;
    const walletSession = wallet.session.get(session.topic);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    expect(auths?.length).to.eq(requestedChains.length);
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: "eip155:1",
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });
  // this test simulates the scenario where the wallet supports subset of the requested chains and all methods
  it("should establish authenticated session with multiple signatures. Case 2", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const supportedChains = [requestedChains[1]];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: supportedChains,
            methods: requestedMethods,
          });

          const auths: AuthTypes.Cacao[] = [];
          authPayload.chains.forEach(async (chain) => {
            const iss = `${chain}:${cryptoWallet.address}`;
            const message = wallet.engine.formatAuthMessage({
              request: authPayload,
              iss,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              authPayload,
              {
                t: "eip191",
                s: sig,
              },
              iss,
            );
            auths.push(auth);
          });

          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths,
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const { session, auths } = result;
    const walletSession = wallet.session.get(session.topic);
    expect(auths?.length).to.eq(supportedChains.length);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: supportedChains[0],
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });
  // this test simulates the scenario where the wallet supports subset of the requested chains and methods
  it("should establish authenticated session with multiple signatures. Case 3", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const supportedChains = [requestedChains[1]];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const supportedMethods = [requestedMethods[0]];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: supportedChains,
            methods: supportedMethods,
          });
          const auths: AuthTypes.Cacao[] = [];
          authPayload.chains.forEach(async (chain) => {
            const iss = `${chain}:${cryptoWallet.address}`;
            const message = wallet.engine.formatAuthMessage({
              request: authPayload,
              iss,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              authPayload,
              {
                t: "eip191",
                s: sig,
              },
              iss,
            );
            auths.push(auth);
          });

          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths,
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const { session, auths } = result;
    const walletSession = wallet.session.get(session.topic);
    expect(auths?.length).to.eq(supportedChains.length);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: supportedChains[0],
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });
  // this test simulates the scenario where the wallet supports all requested chains and subset of methods
  it("should establish authenticated session with multiple signatures. Case 4", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const requestedChains = ["eip155:1", "eip155:2"];
    const supportedChains = requestedChains;
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const supportedMethods = [requestedMethods[0]];
    const { uri, response } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const authPayload = populateAuthPayload({
            authPayload: payload.params.authPayload,
            chains: supportedChains,
            methods: supportedMethods,
          });

          const auths: AuthTypes.Cacao[] = [];
          authPayload.chains.forEach(async (chain) => {
            const iss = `${chain}:${cryptoWallet.address}`;
            const message = wallet.engine.formatAuthMessage({
              request: authPayload,
              iss,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              authPayload,
              {
                t: "eip191",
                s: sig,
              },
              iss,
            );
            auths.push(auth);
          });

          await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths,
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const { session, auths } = result;
    const walletSession = wallet.session.get(session.topic);
    expect(auths?.length).to.eq(supportedChains.length);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        await dapp.request({
          chainId: supportedChains[1],
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });
  it("should establish authenticated session", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const { uri, response } = await dapp.authenticate({
      chains: ["eip155:1", "eip155:2"],
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: ["personal_sign"],
      resources: [],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const auths: any[] = [];
          payload.params.authPayload.chains.forEach(async (chain) => {
            const message = wallet.engine.formatAuthMessage({
              request: payload.params.authPayload,
              iss: `${chain}:${cryptoWallet.address}`,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              payload.params.authPayload,
              {
                t: "eip191",
                s: sig,
              },
              `${chain}:${cryptoWallet.address}`,
            );
            auths.push(auth);
          });
          const result = await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths,
          });
          expect(result.session).to.exist;
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const { session, auths } = result;
    const walletSession = wallet.session.get(session.topic);
    // approved namespaces on both sides must be equal
    expect(JSON.stringify(session.namespaces)).to.eq(JSON.stringify(walletSession.namespaces));
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        await dapp.request({
          chainId: "eip155:1",
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    // Ensure that pairing metadata has been set correctly on both peers.
    expect(wallet.pairing.get(walletSession.pairingTopic).peerMetadata).to.deep.eq(
      TEST_SIGN_CLIENT_OPTIONS.metadata,
    );
    expect(dapp.pairing.get(session.pairingTopic).peerMetadata).to.deep.eq(TEST_APP_METADATA_B);

    await deleteClients({ A: dapp, B: wallet });
  });

  it("should establish normal sign session when URI doesn't specify `wc_sessionAuthenticate` method", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const { uri, response } = await dapp.authenticate({
      chains: ["eip155:1", "eip155:2"],
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: ["personal_sign", "eth_signTypedData_v4"],
    });

    expect(uri).to.exist;
    expect(uri).to.include("wc_sessionAuthenticate");

    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_proposal", async (payload) => {
          const approved = buildApprovedNamespaces({
            supportedNamespaces: {
              eip155: {
                methods: ["personal_sign", "eth_signTransaction", "eth_signTypedData_v4"],
                chains: ["eip155:1", "eip155:2", "eip155:3"],
                accounts: [
                  "eip155:1:" + cryptoWallet.address,
                  "eip155:2:" + cryptoWallet.address,
                  "eip155:3:" + cryptoWallet.address,
                ],
                events: [],
              },
            },
            proposal: payload.params,
          });
          await wallet.approve({
            id: payload.id,
            namespaces: approved,
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri: uri.replace("methods", "") });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const session = result.session;
    await throttle(1000);

    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: "eip155:1",
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });

  it("should establish normal sign session when wallet hasn't subscribed to session_authenticate", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const { uri, response } = await dapp.authenticate({
      chains: ["eip155:1", "eip155:2"],
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: ["personal_sign", "eth_signTypedData_v4"],
    });

    expect(uri).to.exist;
    expect(uri).to.include("wc_sessionAuthenticate");

    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_proposal", async (payload) => {
          const approved = buildApprovedNamespaces({
            supportedNamespaces: {
              eip155: {
                methods: ["personal_sign", "eth_signTransaction", "eth_signTypedData_v4"],
                chains: ["eip155:1", "eip155:2", "eip155:3"],
                accounts: [
                  "eip155:1:" + cryptoWallet.address,
                  "eip155:2:" + cryptoWallet.address,
                  "eip155:3:" + cryptoWallet.address,
                ],
                events: [],
              },
            },
            proposal: payload.params,
          });
          await wallet.approve({
            id: payload.id,
            namespaces: approved,
          });
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const session = result.session;
    await throttle(1000);

    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: "eip155:1",
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);

    await deleteClients({ A: dapp, B: wallet });
  });

  it("should perform siwe", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const { uri, response } = await dapp.authenticate({
      chains: ["eip155:1"],
      domain: "localhost",
      nonce: "1",
      uri: "aud",
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });

    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_authenticate", async (payload) => {
          const auths: any[] = [];
          payload.params.authPayload.chains.forEach(async (chain) => {
            const message = wallet.engine.formatAuthMessage({
              request: payload.params.authPayload,
              iss: `${chain}:${cryptoWallet.address}`,
            });
            const sig = await cryptoWallet.signMessage(message);
            const auth = buildAuthObject(
              payload.params.authPayload,
              {
                t: "eip191",
                s: sig,
              },
              `${chain}:${cryptoWallet.address}`,
            );
            auths.push(auth);
          });
          const result = await wallet.approveSessionAuthenticate({
            id: payload.id,
            auths,
          });
          // we expect `session` to be undefined as this is a siwe request
          expect(result.session).to.not.exist;
          resolve();
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((res) => res[2]);
    expect(result).to.exist;
    // its siwe request so session should be undefined
    expect(result.session).to.be.undefined;
    expect(result.auths).to.exist;
    expect(result.auths).to.have.length(1);
    await throttle(1000);
    await deleteClients({ A: dapp, B: wallet });
  });
  it("should perform siwe on fallback session via personal_sign", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    expect(dapp).to.be.exist;
    expect(dapp.metadata.redirect).to.exist;
    expect(dapp.metadata.redirect?.universal).to.exist;
    expect(dapp.metadata.redirect?.native).to.not.exist;

    const { uri, response } = await dapp.authenticate({
      chains: ["eip155:1"],
      domain: "localhost",
      nonce: "1",
      uri: "aud",
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });

    // force wallet to not support `wc_sessionAuthenticate` by removing it from registered methods
    const supportedMethods = ENGINE_RPC_OPTS;
    const toRegisterMethods = Object.keys(supportedMethods).filter(
      (method) => method !== "wc_sessionAuthenticate",
    );
    //@ts-expect-error
    wallet.core.pairing.registeredMethods = [];
    wallet.core.pairing.register({ methods: toRegisterMethods });
    const result = await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_proposal", async (payload) => {
          // validate that the dapp has both `session_authenticate` & `session_proposal` stored
          // and expirer configured
          const pendingProposals = dapp.proposal.getAll();
          expect(pendingProposals.length).to.eq(1);
          expect(dapp.core.expirer.keys).to.include(`id:${pendingProposals[0].id}`);
          expect(dapp.core.expirer.get(pendingProposals[0].id)).to.exist;
          expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.exist;
          expect(dapp.core.expirer.get(pendingProposals[0].id)?.expiry).to.be.greaterThan(0);
          expect(pendingProposals[0].id).to.eq(payload.id);

          try {
            const approved = buildApprovedNamespaces({
              supportedNamespaces: {
                eip155: {
                  methods: ["personal_sign", "eth_signTransaction", "eth_signTypedData_v4"],
                  chains: ["eip155:1"],
                  accounts: ["eip155:1:" + cryptoWallet.address],
                  events: ["chainChanged", "accountsChanged"],
                },
              },
              proposal: payload.params,
            });
            await wallet.approve({
              id: payload.id,
              namespaces: approved,
            });
            resolve();
          } catch (e) {
            console.error("failed to approve session proposal");
            console.log(e);
          }
        });
      }),
      new Promise<void>((resolve) => {
        wallet.pair({ uri });
        resolve();
      }),
      response(),
    ]).then((result) => result[2]);
    const { session, auths } = result;
    expect(auths).to.be.undefined;
    expect(session).to.exist;
    expect(session.namespaces.eip155).to.exist;
    expect(session.namespaces.eip155.methods).to.exist;
    expect(session.namespaces.eip155.methods).to.have.length(1);
    expect(session.namespaces.eip155.methods[0]).to.eq("personal_sign");
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.on("session_request", async (payload) => {
          const { id, topic } = payload;
          await wallet.respond({
            topic,
            response: formatJsonRpcResult(
              id,
              await cryptoWallet.signMessage(payload.params.request.params[0]),
            ),
          });
          resolve();
        });
      }),
      new Promise<void>(async (resolve) => {
        const result = await dapp.request({
          chainId: "eip155:1",
          topic: session.topic,
          request: {
            method: "personal_sign",
            params: ["hey, sup"],
          },
        });
        resolve();
      }),
    ]);
    // confirm that all pending proposals and auth requests have been cleared
    expect(wallet.proposal.getAll().length).to.eq(0);
    expect(dapp.proposal.getAll().length).to.eq(0);
    expect(dapp.auth.requests.getAll().length).to.eq(0);
    await deleteClients({ A: dapp, B: wallet });
  });
  it.skip("should use rejected tag for session_authenticate", async () => {
    const dapp = await SignClient.init({ ...TEST_SIGN_CLIENT_OPTIONS, name: "dapp" });
    const requestedChains = ["eip155:1", "eip155:2"];
    const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
    const { uri } = await dapp.authenticate({
      chains: requestedChains,
      domain: "localhost",
      nonce: "1",
      uri: "aud",
      methods: requestedMethods,
      resources: [
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    });
    const wallet = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "wallet",
      metadata: TEST_APP_METADATA_B,
    });

    if (!uri) throw new Error("URI is undefined");
    expect(uri).to.exist;
    await Promise.all([
      new Promise<void>((resolve) => {
        wallet.core.relayer.on(RELAYER_EVENTS.publish, (payload) => {
          const { opts } = payload;
          const expectedOpts = ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject;
          expect(opts).to.exist;
          if (
            opts.tag === expectedOpts?.tag &&
            opts.ttl === expectedOpts?.ttl &&
            opts.prompt === expectedOpts?.prompt
          ) {
            resolve();
          }
        });
      }),
      new Promise<void>((resolve) => {
        wallet.once("session_authenticate", async (params) => {
          await wallet.rejectSessionAuthenticate({
            id: params.id,
            reason: getSdkError("USER_REJECTED"),
          });
          resolve();
        });
      }),
      wallet.pair({ uri }),
    ]);
    await deleteClients({ A: dapp, B: wallet });
  });
});
</file>

<file path="packages/sign-client/test/sdk/client.spec.ts">
import { TEST_APP_METADATA_A, TEST_EMPTY_METADATA, TEST_WALLET_METADATA } from "./../shared/values";
import {
  formatJsonRpcError,
  formatJsonRpcResult,
  JsonRpcError,
} from "@walletconnect/jsonrpc-utils";
import { calcExpiry, getSdkError, parseUri } from "@walletconnect/utils";
import { expect, describe, it, vi } from "vitest";
import SignClient, {
  ENGINE_QUEUE_STATES,
  ENGINE_RPC_OPTS,
  WALLETCONNECT_DEEPLINK_CHOICE,
} from "../../src";

import {
  initTwoClients,
  testConnectMethod,
  TEST_SIGN_CLIENT_OPTIONS,
  deleteClients,
  throttle,
  TEST_REQUEST_PARAMS,
  TEST_NAMESPACES,
  TEST_REQUEST_PARAMS_OPTIONAL_NAMESPACE,
  TEST_AVALANCHE_CHAIN,
  TEST_REQUIRED_NAMESPACES_V2,
  TEST_NAMESPACES_V2,
  initTwoPairedClients,
  TEST_CONNECT_PARAMS,
} from "../shared";
import {
  EVENT_CLIENT_PAIRING_ERRORS,
  EVENT_CLIENT_PAIRING_TRACES,
  EVENT_CLIENT_SESSION_ERRORS,
  RELAYER_EVENTS,
} from "@walletconnect/core";

describe("Sign Client Integration", () => {
  it("init", async () => {
    const client = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      name: "init",
      signConfig: { disableRequestQueue: true },
    });
    expect(client).to.be.exist;
    expect(client.metadata.redirect).to.exist;
    expect(client.metadata.redirect?.universal).to.exist;
    expect(client.metadata.redirect?.native).to.not.exist;
    expect(client.signConfig).to.exist;
    expect(client.signConfig?.disableRequestQueue).to.be.true;
    await deleteClients({ A: client, B: undefined });
  });

  it("should initialize without metadata object", async () => {
    const options = TEST_SIGN_CLIENT_OPTIONS;
    delete options.metadata;
    const client = await SignClient.init({
      ...options,
      name: "init",
      signConfig: { disableRequestQueue: true },
    });
    expect(client).to.be.exist;
    await deleteClients({ A: client, B: undefined });
  });

  it("should initialize with empty metadata", async () => {
    const client = await SignClient.init({
      ...TEST_SIGN_CLIENT_OPTIONS,
      metadata: TEST_EMPTY_METADATA,
      name: "init",
      signConfig: { disableRequestQueue: true },
    });
    expect(client).to.be.exist;
    await deleteClients({ A: client, B: undefined });
  });

  describe("connect", () => {
    it("connect (with new pairing)", async () => {
      const { clients, sessionA, pairingA } = await initTwoPairedClients(
        {},
        {},
        { logger: "error" },
      );
      expect(pairingA).to.be.exist;
      expect(sessionA).to.be.exist;
      expect(pairingA.topic).to.eq(sessionA.pairingTopic);
      const sessionB = clients.B.session.get(sessionA.topic);
      expect(sessionB).to.be.exist;
      expect(sessionB.pairingTopic).to.eq(sessionA.pairingTopic);
      expect(clients.A.metadata.redirect).to.exist;
      expect(clients.A.metadata.redirect?.native).to.exist;
      expect(clients.A.metadata.redirect?.universal).to.exist;
      expect(clients.B.metadata.redirect).to.exist;
      expect(clients.B.metadata.redirect?.native).to.exist;
      expect(clients.B.metadata.redirect?.universal).to.exist;
      await deleteClients(clients);
    });
    it("should set scopedProperties in session", async () => {
      const clients = await initTwoClients();
      const requestedScopedProperties = {
        [Object.keys(TEST_CONNECT_PARAMS.requiredNamespaces)[0]]: "test",
      };
      const approvedScopedProperties = {
        polkadot: "approved",
      };
      const { uri, approval } = await clients.A.connect({
        ...TEST_CONNECT_PARAMS,
        scopedProperties: requestedScopedProperties,
      });
      if (!uri) throw new Error("URI is undefined");

      await Promise.all([
        new Promise<void>((resolve) => {
          clients.B.once("session_proposal", async (params) => {
            const { scopedProperties } = params.params;
            expect(scopedProperties).to.exist;
            expect(scopedProperties).to.deep.equal(requestedScopedProperties);

            await clients.B.approve({
              id: params.id,
              namespaces: TEST_NAMESPACES,
              scopedProperties: approvedScopedProperties,
            });
            resolve();
          });
        }),
        clients.B.pair({ uri }),
        approval(),
      ]);
      const dappSession = clients.A.session.getAll()[0];
      const walletSession = clients.B.session.getAll()[0];
      expect(dappSession.scopedProperties).to.deep.equal(approvedScopedProperties);
      expect(walletSession.scopedProperties).to.deep.equal(approvedScopedProperties);
      expect(dappSession.topic).to.eq(walletSession.topic);

      await deleteClients(clients);
    });
    it("should connect with out of order URIs", async () => {
      const clients = await initTwoClients();
      // load three proposals
      const { uri: uriOne, approval: approvalOne } = await clients.A.connect(TEST_CONNECT_PARAMS);
      const { uri: uriTwo, approval: approvalTwo } = await clients.A.connect(TEST_CONNECT_PARAMS);
      const { uri: uriThree, approval: approvalThree } =
        await clients.A.connect(TEST_CONNECT_PARAMS);

      if (!uriOne || !uriTwo || !uriThree) throw new Error("URI is undefined");

      const wallet = clients.B;

      const onSessionPropose = async (params) => {
        await wallet.approve({ id: params.id, namespaces: TEST_NAMESPACES });
      };
      wallet.on("session_proposal", onSessionPropose);

      // approve the oldest
      const sessionOne = await Promise.all([approvalOne(), wallet.pair({ uri: uriOne })]).then(
        (result) => result[0],
      );
      // approve the newest
      const sessionThree = await Promise.all([
        approvalThree(),
        wallet.pair({ uri: uriThree }),
      ]).then((result) => result[0]);
      // approve the middle
      const sessionTwo = await Promise.all([approvalTwo(), wallet.pair({ uri: uriTwo })]).then(
        (result) => result[0],
      );

      wallet.off("session_proposal", onSessionPropose);

      expect(sessionOne).to.exist;
      expect(sessionTwo).to.exist;
      expect(sessionThree).to.exist;
      expect(sessionOne.topic).to.not.eq(sessionTwo.topic);
      expect(sessionOne.topic).to.not.eq(sessionThree.topic);
      expect(sessionTwo.topic).to.not.eq(sessionThree.topic);
      expect(wallet.session.getAll().length).to.eq([sessionOne, sessionTwo, sessionThree].length);
      expect(wallet.session.get(sessionOne.topic)).to.exist;
      expect(wallet.session.get(sessionTwo.topic)).to.exist;
      expect(wallet.session.get(sessionThree.topic)).to.exist;

      await deleteClients(clients);
    });
    it("connect (with old pairing)", async () => {
      const {
        clients,
        pairingA: { topic: pairingTopic },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      const { A, B } = clients;
      expect(A.pairing.keys).to.eql(B.pairing.keys);
      await throttle(200);
      await testConnectMethod(clients, {
        pairingTopic,
      });
      await deleteClients(clients);
    });
    it("should remove duplicate pairing", async () => {
      const { clients } = await initTwoPairedClients({}, {}, { logger: "error" });
      const { A, B } = clients;
      expect(A.pairing.keys).to.eql(B.pairing.keys);
      expect(A.pairing.keys.length).to.eql(1);
      await throttle(1000);
      await testConnectMethod(clients);
      await throttle(1000);
      expect(A.pairing.keys).to.eql(B.pairing.keys);
      expect(A.pairing.keys.length).to.eql(1);
      await deleteClients(clients);
    });
    it("should receive session acknowledge", async () => {
      const {
        clients,
        sessionA: { topic, acknowledged },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      await throttle(5_000);
      const session = clients.B.session.get(topic);
      expect(session.acknowledged).to.be.true;
      expect(acknowledged).to.be.true;
      await deleteClients(clients);
    });
    it("should cleanup duplicate pairings", async () => {
      const { clients, sessionA, pairingA } = await initTwoPairedClients(
        {},
        {},
        { logger: "error" },
      );
      expect(pairingA).to.be.exist;
      expect(sessionA).to.be.exist;
      expect(pairingA.topic).to.eq(sessionA.pairingTopic);
      const sessionB = clients.B.session.get(sessionA.topic);
      expect(sessionB).to.be.exist;
      expect(sessionB.pairingTopic).to.eq(sessionA.pairingTopic);
      await clients.A.disconnect({
        topic: sessionA.topic,
        reason: getSdkError("USER_DISCONNECTED"),
      });
      expect(clients.A.pairing.getAll().length).to.eq(1);
      const { pairingA: pairingAfter, sessionA: sessionAfter } = await testConnectMethod(clients);
      await throttle(1_000);
      expect(pairingA.topic).to.not.eq(pairingAfter.topic);
      expect(sessionA.topic).to.not.eq(sessionAfter.topic);
      expect(sessionA.pairingTopic).to.not.eq(sessionAfter.pairingTopic);
      expect(sessionAfter.pairingTopic).to.eq(pairingAfter.topic);
      expect(clients.A.pairing.getAll().length).to.eq(1);
      await deleteClients(clients);
    });
    it("should emit session_proposal on every pair attempt with same URI as long as the proposal has not yet been approved or rejected", async () => {
      const dapp = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "dapp",
        metadata: TEST_APP_METADATA_A,
      });
      const wallet = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "wallet",
        metadata: TEST_WALLET_METADATA,
      });
      const { uri, approval } = await dapp.connect(TEST_CONNECT_PARAMS);
      if (!uri) throw new Error("URI is undefined");
      expect(uri).to.exist;
      const parsedUri = parseUri(uri);
      // 1. attempt to pair
      // 2. receive the session_proposal event
      // 3. avoid approving or rejecting the proposal - simulates accidental closing of the app/modal etc
      await Promise.all([
        new Promise<void>((resolve) => {
          wallet.once("session_proposal", (params) => {
            expect(params).to.exist;
            expect(params.params.pairingTopic).to.eq(parsedUri.topic);
            resolve();
          });
        }),
        wallet.pair({ uri }),
      ]);
      // 4. attempt to pair again with the same URI
      // 5. receive the session_proposal event again
      // 6. approve the proposal
      await Promise.all([
        new Promise<void>((resolve) => {
          wallet.once("session_proposal", async (params) => {
            expect(params).to.exist;
            expect(params.params.pairingTopic).to.eq(parsedUri.topic);
            await wallet.approve({ id: params.id, namespaces: TEST_NAMESPACES });
            resolve();
          });
        }),
        new Promise<void>(async (resolve) => {
          const session = await approval();
          expect(session).to.exist;
          expect(session.topic).to.exist;
          expect(session.pairingTopic).to.eq(parsedUri.topic);
          resolve();
        }),
        wallet.pair({ uri }),
      ]);

      // 7. attempt to pair again with the same URI
      // 8. should receive an error the pairing already exists
      await expect(wallet.pair({ uri })).rejects.toThrowError();
      await deleteClients({ A: dapp, B: wallet });
    });
    it("should set `sessionConfig`", async () => {
      const dapp = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "dapp",
        metadata: TEST_APP_METADATA_A,
      });
      const wallet = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "wallet",
        metadata: TEST_WALLET_METADATA,
      });
      const { uri, approval } = await dapp.connect(TEST_CONNECT_PARAMS);
      if (!uri) throw new Error("URI is undefined");
      expect(uri).to.exist;
      const parsedUri = parseUri(uri);
      const sessionConfig = {
        disableDeepLink: true,
      };
      let sessionTopic = "";
      await Promise.all([
        new Promise<void>((resolve) => {
          wallet.once("session_proposal", async (params) => {
            expect(params).to.exist;
            expect(params.params.pairingTopic).to.eq(parsedUri.topic);
            const { acknowledged } = await wallet.approve({
              id: params.id,
              namespaces: TEST_NAMESPACES,
              sessionConfig,
            });
            sessionTopic = (await acknowledged()).topic;
            resolve();
          });
        }),
        new Promise<void>(async (resolve) => {
          const session = await approval();
          expect(session).to.exist;
          expect(session.topic).to.exist;
          expect(session.pairingTopic).to.eq(parsedUri.topic);
          resolve();
        }),
        wallet.pair({ uri }),
      ]);
      const sessionDapp = dapp.session.get(sessionTopic);
      const sessionWallet = wallet.session.get(sessionTopic);
      expect(sessionDapp).to.exist;
      expect(sessionWallet).to.exist;
      expect(sessionDapp.sessionConfig).to.eql(sessionConfig);
      expect(sessionWallet.sessionConfig).to.eql(sessionConfig);
      expect(sessionWallet.sessionConfig).to.eql(sessionDapp.sessionConfig);
      await deleteClients({ A: dapp, B: wallet });
    });
    it.skip("should use rejected tag for session_propose", async () => {
      const dapp = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "dapp",
        metadata: TEST_APP_METADATA_A,
      });
      const wallet = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "wallet",
        metadata: TEST_WALLET_METADATA,
      });
      const { uri } = await dapp.connect(TEST_CONNECT_PARAMS);
      if (!uri) throw new Error("URI is undefined");
      expect(uri).to.exist;
      await Promise.all([
        new Promise<void>((resolve) => {
          wallet.core.relayer.on(RELAYER_EVENTS.publish, (payload) => {
            const { opts } = payload;
            const expectedOpts = ENGINE_RPC_OPTS.wc_sessionPropose.reject;
            expect(opts).to.exist;
            if (
              opts.tag === expectedOpts?.tag &&
              opts.ttl === expectedOpts?.ttl &&
              opts.prompt === expectedOpts?.prompt
            ) {
              resolve();
            }
          });
        }),
        new Promise<void>((resolve) => {
          wallet.once("session_proposal", async (params) => {
            await wallet.reject({ id: params.id, reason: getSdkError("USER_REJECTED") });
            resolve();
          });
        }),
        wallet.pair({ uri }),
      ]);
      await deleteClients({ A: dapp, B: wallet });
    });
  });

  describe("disconnect", () => {
    describe("pairing", () => {
      it("deletes the pairing on disconnect", async () => {
        const {
          clients,
          pairingA: { topic },
        } = await initTwoPairedClients({}, {}, { logger: "error" });
        const reason = getSdkError("USER_DISCONNECTED");
        await clients.A.disconnect({ topic, reason });
        expect(() => clients.A.pairing.get(topic)).to.throw(
          `Missing or invalid. Record was recently deleted - pairing: ${topic}`,
        );
        const promise = clients.A.ping({ topic });
        await expect(promise).rejects.toThrowError(
          `No matching key. session or pairing topic doesn't exist: ${topic}`,
        );
        await deleteClients(clients);
      });
    });
    describe("session", () => {
      it("deletes the session on disconnect", async () => {
        const {
          clients,
          sessionA: { topic, self },
        } = await initTwoPairedClients({}, {}, { logger: "error" });
        const { self: selfB } = clients.B.session.get(topic);
        expect(clients.A.core.crypto.keychain.has(topic)).to.be.true;
        expect(clients.A.core.crypto.keychain.has(self.publicKey)).to.be.true;
        expect(clients.B.core.crypto.keychain.has(topic)).to.be.true;
        expect(clients.B.core.crypto.keychain.has(selfB.publicKey)).to.be.true;
        const reason = getSdkError("USER_DISCONNECTED");
        await clients.A.disconnect({ topic, reason });
        const promise = clients.A.ping({ topic });
        expect(() => clients.A.session.get(topic)).to.throw(
          `Missing or invalid. Record was recently deleted - session: ${topic}`,
        );
        await expect(promise).rejects.toThrowError(
          `Missing or invalid. Record was recently deleted - session: ${topic}`,
        );
        await throttle(2_000);
        expect(clients.A.core.crypto.keychain.has(topic)).to.be.false;
        expect(clients.A.core.crypto.keychain.has(self.publicKey)).to.be.false;
        expect(clients.B.core.crypto.keychain.has(topic)).to.be.false;
        expect(clients.B.core.crypto.keychain.has(selfB.publicKey)).to.be.false;
        await deleteClients(clients);
      });
    });
    describe("deeplinks", () => {
      it("should clear `WALLETCONNECT_DEEPLINK_CHOICE` from storage on disconnect", async () => {
        const {
          clients,
          sessionA: { topic },
        } = await initTwoPairedClients({}, {}, { logger: "error" });
        const deepLink = "dummy deep link";
        await clients.A.core.storage.setItem(WALLETCONNECT_DEEPLINK_CHOICE, deepLink);
        expect(await clients.A.core.storage.getItem(WALLETCONNECT_DEEPLINK_CHOICE)).to.eq(deepLink);
        await clients.A.disconnect({ topic, reason: getSdkError("USER_DISCONNECTED") });
        // small delay to finish disconnect
        await throttle(500);
        expect(await clients.A.core.storage.getItem(WALLETCONNECT_DEEPLINK_CHOICE)).to.be.undefined;
        await deleteClients(clients);
      });
    });
    describe("request queue", () => {
      it("should reset request queue state on disconnect", async () => {
        const {
          clients,
          sessionA: { topic },
        } = await initTwoPairedClients({}, {}, { logger: "error" });
        await Promise.all([
          new Promise<void>((resolve) => {
            clients.B.once("session_delete", () => {
              expect(clients.B.pendingRequest.getAll().length).to.eq(0);
              // @ts-expect-error - sessionRequestQueue is private property
              expect(clients.B.engine.sessionRequestQueue.state).to.eq(ENGINE_QUEUE_STATES.idle);
              resolve();
            });
          }),
          new Promise<void>((resolve) => {
            clients.B.once("session_request", async (params) => {
              expect(clients.B.pendingRequest.getAll().length).to.eq(1);

              await clients.A.disconnect({ topic, reason: getSdkError("USER_DISCONNECTED") });

              // @ts-expect-error - sessionRequestQueue is private property
              expect(clients.B.engine.sessionRequestQueue.state).to.eq(ENGINE_QUEUE_STATES.active);

              resolve();
            });
            clients.A.request({
              topic,
              ...TEST_REQUEST_PARAMS,
            }).catch((e) => {
              // eslint-disable-next-line no-console
              console.error(e);
            });
          }),
        ]);

        await deleteClients(clients);
      });
    });
  });

  describe("ping", () => {
    it("throws if the topic is not a known pairing or session topic", async () => {
      const clients = await initTwoClients();
      const fakeTopic = "nonsense";
      await expect(clients.A.ping({ topic: fakeTopic })).rejects.toThrowError(
        `No matching key. session or pairing topic doesn't exist: ${fakeTopic}`,
      );
      await deleteClients(clients);
    });
    describe("pairing", () => {
      describe("with existing pairing", () => {
        it("A pings B", async () => {
          const {
            clients,
            pairingA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          await clients.A.ping({ topic });
          await deleteClients(clients);
        });
        it("B pings A", async () => {
          const {
            clients,
            pairingA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          await clients.B.ping({ topic });
          await deleteClients(clients);
        });
      });
    });
    describe("session", () => {
      describe("with existing session", () => {
        it("A pings B", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          await clients.A.ping({ topic });
          await deleteClients(clients);
        });
        it("B pings A", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          await clients.B.ping({ topic });
          await deleteClients(clients);
        });
        it("can get pending session request", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });

          let rejection: JsonRpcError;

          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.on("session_request", async (args) => {
                const pendingRequests = clients.B.pendingRequest.getAll();
                const { id, topic, params } = pendingRequests[0];
                expect(params).toEqual(args.params);
                expect(topic).toEqual(args.topic);
                expect(id).toEqual(args.id);
                rejection = formatJsonRpcError(id, getSdkError("USER_REJECTED_METHODS").message);
                await clients.B.respond({
                  topic,
                  response: rejection,
                });
                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              try {
                await clients.A.request({
                  topic,
                  ...TEST_REQUEST_PARAMS,
                });
              } catch (err) {
                expect(err.message).toMatch(rejection.error.message);
                resolve();
              }
            }),
          ]);
          await throttle(1_000);
          await deleteClients(clients);
        });

        it("can set tvf params", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients(
            {},
            {},
            { logger: "error" },
            {
              requiredNamespaces: {
                solana: {
                  methods: [
                    "solana_signTransaction",
                    "solana_signAllTransactions",
                    "solana_signAndSendTransaction",
                  ],
                  events: [],
                  chains: ["solana:devnet"],
                },
                eip155: {
                  methods: ["eth_sendTransaction"],
                  events: [],
                  chains: ["eip155:1"],
                },
              },
              namespaces: {
                solana: {
                  chains: ["solana:devnet"],
                  methods: [
                    "solana_signTransaction",
                    "solana_signAllTransactions",
                    "solana_signAndSendTransaction",
                  ],
                  events: [],
                  accounts: ["solana:devnet:0x"],
                },
                eip155: {
                  methods: ["eth_sendTransaction"],
                  events: [],
                  accounts: ["eip155:1:0x"],
                },
              },
            },
          );

          // eip155 eth_sendTransaction example
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.once("session_request", async (args) => {
                const pendingRequests = clients.B.pendingRequest.getAll();
                const { id, topic, params } = pendingRequests[0];
                expect(params).toEqual(args.params);
                expect(topic).toEqual(args.topic);
                expect(id).toEqual(args.id);

                const result = formatJsonRpcResult(id, "0x");
                let checkedWalletPublish = false;

                clients.B.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                  checkedWalletPublish = true;
                  const tvf = publishPayload.tvf;
                  expect(tvf).to.exist;
                  expect(tvf?.chainId).to.eq(params.chainId);
                  expect(tvf?.rpcMethods).to.eql([params.request.method]);
                  expect(tvf?.txHashes).to.eql([result.result]);
                  expect(tvf?.contractAddresses).to.eql([params.request.params[0].to]);

                  if (!tvf) {
                    return console.error("tvf is undefined");
                  }
                  if (!tvf.chainId || !tvf.rpcMethods || !tvf.txHashes) {
                    return console.error("tvf is missing required fields");
                  }
                  if (tvf.txHashes[0] !== result.result) {
                    return console.error(
                      "txHashes do not match: signature - eth_sendTransaction",
                      tvf.txHashes[0],
                      result.result,
                      id,
                    );
                  }

                  checkedWalletPublish = true;
                });
                await clients.B.respond({
                  topic,
                  response: result,
                });
                expect(checkedWalletPublish).to.be.true;
                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              const requestParams = {
                method: "eth_sendTransaction",
                params: [
                  {
                    data: "0xa9059cbb00000000000000000000000013a2ff792037aa2cd77fe1f4b522921ac59a9c5200000000000000000000000000000000000000000000000000000000003d0900",
                    from: "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52",
                    to: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
                  },
                ],
              };
              let checkedDappPublish = false;

              clients.A.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                checkedDappPublish = true;
                const tvf = publishPayload.tvf;
                expect(tvf).to.exist;
                expect(tvf?.chainId).to.eq(TEST_REQUEST_PARAMS.chainId);
                expect(tvf?.rpcMethods).to.eql([requestParams.method]);
                expect(tvf?.txHashes).to.be.undefined;
                expect(tvf?.contractAddresses).to.eql([requestParams.params[0].to]);
              });

              await clients.A.request({
                topic,
                ...TEST_REQUEST_PARAMS,
                request: {
                  ...TEST_REQUEST_PARAMS.request,
                  ...requestParams,
                },
              });
              expect(checkedDappPublish).to.be.true;
              resolve();
            }),
          ]);
          // solana solana_signAndSendTransaction example
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.once("session_request", async (args) => {
                const pendingRequests = clients.B.pendingRequest.getAll();
                const { id, topic, params } = pendingRequests[0];
                expect(params).toEqual(args.params);
                expect(topic).toEqual(args.topic);
                expect(id).toEqual(args.id);

                const result = formatJsonRpcResult(id, { signature: "0xSignature" });
                let checkedWalletPublish = false;

                clients.B.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                  const tvf = publishPayload.tvf;
                  console.log("tvf", tvf);
                  if (!tvf) {
                    return console.error("tvf is undefined");
                  }
                  if (!tvf.chainId || !tvf.rpcMethods || !tvf.txHashes) {
                    return console.error("tvf is missing required fields");
                  }
                  if (tvf.txHashes[0] !== result.result.signature) {
                    return console.error(
                      "txHashes do not match: signature - solana_signAndSendTransaction",
                      tvf.txHashes[0],
                      result.result.signature,
                      id,
                    );
                  }
                  checkedWalletPublish = true;
                });
                await clients.B.respond({
                  topic,
                  response: result,
                });

                expect(checkedWalletPublish).to.be.true;
                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              const requestParams = {
                method: "solana_signAndSendTransaction",
                params: [
                  {
                    data: "0xa9059cbb00000000000000000000000013a2ff792037aa2cd77fe1f4b522921ac59a9c5200000000000000000000000000000000000000000000000000000000003d0900",
                    from: "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52",
                    to: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
                  },
                ],
              };
              let checkedDappPublish = false;

              clients.A.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                checkedDappPublish = true;
                const tvf = publishPayload.tvf;
                expect(tvf).to.exist;
                expect(tvf?.chainId).to.eq(TEST_REQUEST_PARAMS.chainId);
                expect(tvf?.rpcMethods).to.eql([requestParams.method]);
                expect(tvf?.txHashes).to.be.undefined;
                expect(tvf?.contractAddresses).to.eql([requestParams.params[0].to]);
              });

              await clients.A.request({
                topic,
                ...TEST_REQUEST_PARAMS,
                request: {
                  ...TEST_REQUEST_PARAMS.request,
                  ...requestParams,
                },
                chainId: "solana:devnet",
              });
              expect(checkedDappPublish).to.be.true;
              resolve();
            }),
          ]);

          // solana solana_signTransaction example
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.once("session_request", async (args) => {
                const pendingRequests = clients.B.pendingRequest.getAll();
                const { id, topic, params } = pendingRequests[0];
                expect(params).toEqual(args.params);
                expect(topic).toEqual(args.topic);
                expect(id).toEqual(args.id);

                const result = formatJsonRpcResult(id, { signature: "0xSignature" });
                let checkedWalletPublish = false;

                clients.B.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                  const tvf = publishPayload.tvf;
                  if (!tvf) {
                    return console.error("tvf is undefined");
                  }
                  if (!tvf.chainId || !tvf.rpcMethods || !tvf.txHashes) {
                    return console.error("tvf is missing required fields");
                  }
                  if (tvf.txHashes[0] !== result.result.signature) {
                    return console.error(
                      "txHashes do not match: signature",
                      tvf.txHashes[0],
                      result.result.signature,
                    );
                  }

                  checkedWalletPublish = true;
                });

                await clients.B.respond({
                  topic,
                  response: result,
                });

                expect(checkedWalletPublish).to.be.true;
                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              const requestParams = {
                method: "solana_signTransaction",
                params: [
                  {
                    data: "0xa9059cbb00000000000000000000000013a2ff792037aa2cd77fe1f4b522921ac59a9c5200000000000000000000000000000000000000000000000000000000003d0900",
                    from: "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52",
                    to: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
                  },
                ],
              };
              let checkedDappPublish = false;

              clients.A.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                checkedDappPublish = true;
                const tvf = publishPayload.tvf;
                expect(tvf).to.exist;
                expect(tvf?.chainId).to.eq(TEST_REQUEST_PARAMS.chainId);
                expect(tvf?.rpcMethods).to.eql([requestParams.method]);
                expect(tvf?.txHashes).to.be.undefined;
                expect(tvf?.contractAddresses).to.eql([requestParams.params[0].to]);
              });

              await clients.A.request({
                topic,
                ...TEST_REQUEST_PARAMS,
                request: {
                  ...TEST_REQUEST_PARAMS.request,
                  ...requestParams,
                },
                chainId: "solana:devnet",
              });
              expect(checkedDappPublish).to.be.true;
              resolve();
            }),
          ]);

          // solana solana_signAllTransactions example
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.once("session_request", async (args) => {
                const pendingRequests = clients.B.pendingRequest.getAll();
                const { id, topic, params } = pendingRequests[0];
                expect(params).toEqual(args.params);
                expect(topic).toEqual(args.topic);
                expect(id).toEqual(args.id);

                const result = formatJsonRpcResult(id, {
                  transactions: [
                    "AeJw688VKMWEeOHsYhe03By/2rqJHTQeq6W4L1ZLdbT2l/Nim8ctL3erMyH9IWPsQP73uaarRmiVfanEJHx7uQ4BAAIDb3ObYkq6BFd46JrMFy1h0Q+dGmyRGtpelqTKkIg82isAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAAtIy17v5fs39LuoitzpBhVrg8ZIQF/3ih1N9dQ+X3shEDAgAFAlgCAAABAgAADAIAAACghgEAAAAAAAIACQMjTgAAAAAAAA==",
                    "AeJw688VKMWEeOHsYhe03By/2rqJHTQeq6W4L1ZLdbT2l/Nim8ctL3erMyH9IWPsQP73uaarRmiVfanEJHx7uQ4BAAIDb3ObYkq6BFd46JrMFy1h0Q+dGmyRGtpelqTKkIg82isAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAAtIy17v5fs39LuoitzpBhVrg8ZIQF/3ih1N9dQ+X3shEDAgAFAlgCAAABAgAADAIAAACghgEAAAAAAAIACQMjTgAAAAAAAA==",
                    "AeJw688VKMWEeOHsYhe03By/2rqJHTQeq6W4L1ZLdbT2l/Nim8ctL3erMyH9IWPsQP73uaarRmiVfanEJHx7uQ4BAAIDb3ObYkq6BFd46JrMFy1h0Q+dGmyRGtpelqTKkIg82isAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAAtIy17v5fs39LuoitzpBhVrg8ZIQF/3ih1N9dQ+X3shEDAgAFAlgCAAABAgAADAIAAACghgEAAAAAAAIACQMjTgAAAAAAAA==",
                  ],
                });
                const expectedTxHashes = [
                  "5XanD5KnkqzH3RjyqHzPCSRrNXYW2ADH4bge4oMi9KnDBrkFvugagH3LytFZFmBhZEEcyxPsZqeyF4cgLpEXVFR7",
                  "5XanD5KnkqzH3RjyqHzPCSRrNXYW2ADH4bge4oMi9KnDBrkFvugagH3LytFZFmBhZEEcyxPsZqeyF4cgLpEXVFR7",
                  "5XanD5KnkqzH3RjyqHzPCSRrNXYW2ADH4bge4oMi9KnDBrkFvugagH3LytFZFmBhZEEcyxPsZqeyF4cgLpEXVFR7",
                ];
                let checkedWalletPublish = false;
                clients.B.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                  const tvf = publishPayload.tvf;
                  if (!tvf) {
                    return console.error("tvf is undefined");
                  }
                  if (!tvf.chainId || !tvf.rpcMethods || !tvf.txHashes) {
                    return console.error("tvf is missing required fields");
                  }
                  if (tvf.txHashes.join(",") !== expectedTxHashes.join(",")) {
                    return console.error(
                      "txHashes do not match: transactions",
                      tvf.txHashes,
                      result.result.transactions,
                    );
                  }

                  checkedWalletPublish = true;
                });

                await clients.B.respond({
                  topic,
                  response: result,
                });

                expect(checkedWalletPublish).to.be.true;
                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              const requestParams = {
                method: "solana_signAllTransactions",
                params: [
                  {
                    data: "0xa9059cbb00000000000000000000000013a2ff792037aa2cd77fe1f4b522921ac59a9c5200000000000000000000000000000000000000000000000000000000003d0900",
                    from: "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52",
                    to: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
                  },
                ],
              };
              let checkedDappPublish = false;

              clients.A.core.relayer.once(RELAYER_EVENTS.publish, (publishPayload: any) => {
                checkedDappPublish = true;
                const tvf = publishPayload.tvf;
                expect(tvf).to.exist;
                expect(tvf?.chainId).to.eq(TEST_REQUEST_PARAMS.chainId);
                expect(tvf?.rpcMethods).to.eql([requestParams.method]);
                expect(tvf?.txHashes).to.be.undefined;
                expect(tvf?.contractAddresses).to.eql([requestParams.params[0].to]);
              });

              await clients.A.request({
                topic,
                ...TEST_REQUEST_PARAMS,
                request: {
                  ...TEST_REQUEST_PARAMS.request,
                  ...requestParams,
                },
                chainId: "solana:devnet",
              });
              expect(checkedDappPublish).to.be.true;
              resolve();
            }),
          ]);

          await throttle(1_000);
          await deleteClients(clients);
        });

        it("should process requests queue", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          const expectedRequests = 5;
          let receivedRequests = 0;
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.on("session_request", async (args) => {
                receivedRequests++;
                const { id, topic } = args;
                await clients.B.respond({
                  topic,
                  response: formatJsonRpcResult(id, "ok"),
                });
                if (receivedRequests >= expectedRequests) resolve();
              });
            }),
            Array.from(Array(expectedRequests).keys()).map(
              async () =>
                await clients.A.request({
                  topic,
                  ...TEST_REQUEST_PARAMS,
                }).catch((e) => {
                  console.error(e);
                }),
            ),
          ]);
          await throttle(1000);
          await deleteClients(clients);
        });
        it("should disable requests queue via `signConfig`", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients(
            {},
            { signConfig: { disableRequestQueue: true } },
            { logger: "error" },
          );
          let firstRequestId;
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.once("session_request", (args) => {
                const { id, topic } = args;
                firstRequestId = id;
                // validate that theres only one request pending (the one we just received)
                const pendingRequests = clients.B.pendingRequest.getAll();
                expect(pendingRequests.length).to.eq(1);
                resolve();
              });
            }),
            new Promise<void>((resolve) => {
              clients.A.request({
                topic,
                ...TEST_REQUEST_PARAMS,
              }).catch((e) => {
                console.error(e);
              });
              resolve();
            }),
          ]);
          await throttle(1000);
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.once("session_request", async (args) => {
                const { id, topic } = args;
                const pendingRequests = clients.B.pendingRequest.getAll();
                // validate that there are two requests pending
                expect(pendingRequests.length).to.eq(2);
                // validate the IDs are different even though we didn't respond to the first request
                // if the queue was active, we would've received the first request again
                expect(id).to.not.eq(firstRequestId);
                // validate we can respond to the second request successfully
                await clients.B.respond({
                  topic,
                  response: formatJsonRpcResult(id, "ok"),
                });
                resolve();
              });
            }),
            clients.A.request({
              topic,
              ...TEST_REQUEST_PARAMS,
            }).catch((e) => {
              console.error(e);
            }),
          ]);
          // validate the first request is still pending
          expect(clients.B.pendingRequest.getAll().length).to.eq(1);
          expect(clients.B.pendingRequest.getAll()[0].id).to.eq(firstRequestId);

          await clients.B.respond({
            topic,
            response: formatJsonRpcResult(firstRequestId, "ok"),
          });

          await deleteClients(clients);
        });
        /**
         * this test simulates the case where a session is disconnected
         * while session request is being approved
         * the queue should continue operating normally after the `respond` rejection
         */
        it("continue processing requests queue after respond rejection due to disconnected session", async () => {
          // create the clients and pair them
          const {
            clients,
            sessionA: { topic: topicA },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          const dapp = clients.A as SignClient;
          const wallet = clients.B as SignClient;
          const { uri, approval } = await dapp.connect({
            requiredNamespaces: {},
          });

          let topicB = "";
          await Promise.all([
            new Promise<void>((resolve) => {
              wallet.once("session_proposal", async (args) => {
                const { id } = args.params;
                await wallet.approve({
                  id,
                  namespaces: TEST_NAMESPACES,
                });
                resolve();
              });
            }),
            wallet.pair({ uri: uri! }),
            new Promise<void>(async (resolve) => {
              const session = await approval();
              topicB = session.topic;
              resolve();
            }),
          ]);

          const expectedRequests = 5;
          let receivedRequests = 0;
          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.on("session_request", async (args) => {
                receivedRequests++;
                const { id, topic } = args;

                // capture the request on topicB, disconnect and try to approve the request
                if (topic === topicB) {
                  await new Promise<void>(async (_resolve) => {
                    await wallet.disconnect({
                      topic,
                      reason: getSdkError("USER_DISCONNECTED"),
                    });
                    _resolve();
                  });
                }
                await clients.B.respond({
                  topic,
                  response: formatJsonRpcResult(id, "ok"),
                }).catch((err) => {
                  // eslint-disable-next-line no-console
                  console.log("respond error", err);
                });
                if (receivedRequests > expectedRequests) resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              await Promise.all([
                ...Array.from(Array(expectedRequests).keys()).map(
                  async () =>
                    await clients.A.request({
                      topic: topicA,
                      ...TEST_REQUEST_PARAMS,
                    }).catch((e) => {
                      console.error(e);
                    }),
                ),
                clients.A.request({
                  topic: topicB,
                  ...TEST_REQUEST_PARAMS,
                  // eslint-disable-next-line no-console
                }).catch((e) => console.error(e)), // capture the error from the session disconnect
              ]);
              resolve();
            }),
          ]);
          await throttle(1000);
          await deleteClients(clients);
        });
        it("should handle invalid session state with missing keychain", async () => {
          const {
            clients,
            sessionA: { topic },
          } = await initTwoPairedClients({}, {}, { logger: "error" });
          const dapp = clients.A as SignClient;
          const sessions = dapp.session.getAll();
          expect(sessions.length).to.eq(1);
          await dapp.core.crypto.keychain.del(topic);
          await Promise.all([
            new Promise<void>((resolve) => {
              dapp.on("session_delete", async (args) => {
                const { topic: sessionTopic } = args;
                expect(sessionTopic).to.eq(topic);
                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              try {
                await dapp.ping({ topic });
              } catch (err) {
                expect(err.message).to.eq(
                  `Missing or invalid. session topic does not exist in keychain: ${topic}`,
                );
              }
              resolve();
            }),
          ]);

          const sessionsAfter = dapp.session.getAll();
          expect(sessionsAfter.length).to.eq(0);

          await deleteClients(clients);
        });
      });
    });
  });
  describe("update", () => {
    it("updates session namespaces state with provided namespaces", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      const namespacesBefore = clients.A.session.get(topic).namespaces;
      const namespacesAfter = {
        ...namespacesBefore,
        eip9001: {
          accounts: ["eip9001:1:0x000000000000000000000000000000000000dead"],
          methods: ["eth_sendTransaction"],
          events: ["accountsChanged"],
        },
      };
      const { acknowledged } = await clients.A.update({
        topic,
        namespaces: namespacesAfter,
      });
      await acknowledged();
      const result = clients.A.session.get(topic).namespaces;
      expect(result).to.eql(namespacesAfter);
      await deleteClients(clients);
    });
  });

  describe("extend", () => {
    it("updates session expiry state initiated by client A", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      const prevExpiry = clients.A.session.get(topic).expiry;
      vi.useFakeTimers({ shouldAdvanceTime: true });
      // Fast-forward system time by 60 seconds after expiry was first set.
      vi.setSystemTime(Date.now() + 60_000);
      const { acknowledged } = await clients.A.extend({
        topic,
      });
      await acknowledged();
      const updatedExpiry = clients.A.session.get(topic).expiry;
      expect(updatedExpiry).to.be.greaterThan(prevExpiry);
      vi.useRealTimers();
      await deleteClients(clients);
    });
    it("updates session expiry state initiated by client B", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      const prevExpiry = clients.A.session.get(topic).expiry;
      vi.useFakeTimers({ shouldAdvanceTime: true });
      // Fast-forward system time by 60 seconds after expiry was first set.
      vi.setSystemTime(Date.now() + 60_000);
      const { acknowledged } = await clients.A.extend({
        topic,
      });
      await acknowledged();
      const updatedExpiry = clients.A.session.get(topic).expiry;
      expect(updatedExpiry).to.be.greaterThan(prevExpiry);
      vi.useRealTimers();
      await deleteClients(clients);
    });
  });
  describe("namespaces", () => {
    it("should pair with empty namespaces", async () => {
      const clients = await initTwoClients();
      const requiredNamespaces = {};
      const { sessionA } = await testConnectMethod(clients, {
        requiredNamespaces,
        namespaces: TEST_NAMESPACES,
      });
      expect(requiredNamespaces).toMatchObject({});
      expect(sessionA.requiredNamespaces).toMatchObject(
        clients.B.session.get(sessionA.topic).requiredNamespaces,
      );
      await deleteClients(clients);
    });
  });

  describe("session requests", () => {
    it("should set custom request expiry", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      const expiry = 600; // 10 minutes in seconds

      await Promise.all([
        new Promise<void>((resolve) => {
          (clients.B as SignClient).once("session_request", async (payload) => {
            expect(payload.params.request.expiryTimestamp).to.be.approximately(
              calcExpiry(expiry),
              1000,
            );
            await clients.B.respond({
              topic,
              response: formatJsonRpcResult(payload.id, "test response"),
            });
            resolve();
          });
        }),
        new Promise<void>(async (resolve) => {
          await clients.A.request({ ...TEST_REQUEST_PARAMS, topic, expiry });
          resolve();
        }),
      ]);
      await deleteClients(clients);
    });
    it("should send request on optional namespace", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients({}, {}, { logger: "error" });
      await Promise.all([
        new Promise<void>((resolve) => {
          clients.B.once("session_request", async (payload) => {
            const { params } = payload;
            expect(params).toMatchObject(TEST_REQUEST_PARAMS_OPTIONAL_NAMESPACE);
            await clients.B.respond({
              topic,
              response: formatJsonRpcResult(payload.id, "test response"),
            });
            resolve();
          });
        }),
        new Promise<void>(async (resolve) => {
          await clients.A.request({ ...TEST_REQUEST_PARAMS_OPTIONAL_NAMESPACE, topic });
          resolve();
        }),
      ]);
      await deleteClients(clients);
    });
    it("should send request on inline indexed namespace", async () => {
      const clients = await initTwoClients();
      const {
        sessionA: { topic },
      } = await testConnectMethod(clients, {
        requiredNamespaces: TEST_REQUIRED_NAMESPACES_V2,
        namespaces: TEST_NAMESPACES_V2,
      });
      const testRequestProps = {
        ...TEST_REQUEST_PARAMS,
        chainId: TEST_AVALANCHE_CHAIN,
      };
      await Promise.all([
        new Promise<void>((resolve) => {
          clients.B.once("session_request", async (payload) => {
            const { params } = payload;
            const session = clients.B.session.get(payload.topic);
            expect(params).toMatchObject(testRequestProps);
            expect(
              session.namespaces.eip155.accounts.filter((acc) =>
                acc.includes(TEST_AVALANCHE_CHAIN),
              ),
            ).to.exist;
            expect(session.requiredNamespaces[TEST_AVALANCHE_CHAIN]).to.exist;
            await clients.B.respond({
              topic,
              response: formatJsonRpcResult(payload.id, "test response"),
            });
            resolve();
          });
        }),
        new Promise<void>(async (resolve) => {
          await clients.A.request({ ...testRequestProps, topic });
          resolve();
        }),
      ]);
      await deleteClients(clients);
    });
  });
  describe("Events Client", () => {
    it("should create event during pairing flow", async () => {
      const clients = await initTwoClients();
      const { uri } = await clients.A.connect({});
      if (!uri) throw new Error("URI is undefined");
      await clients.B.pair({ uri });
      const { topic } = parseUri(uri);
      expect(clients.B.core.eventClient.events.size).to.eq(1);
      const event = clients.B.core.eventClient.getEvent({ topic });
      if (!event) throw new Error("Event is undefined");
      expect(event).to.exist;
      expect(event.props.event).to.eq("ERROR");
      expect(event.props.type).to.eq(""); // there is no type yet as no error has happened
      expect(event.props.properties.topic).to.eq(topic);
      expect(event.props.properties.trace).to.exist;
      expect(event.props.properties.trace.length).to.toBeGreaterThan(0);

      await new Promise<void>((resolve) => {
        clients.B.once("session_proposal", (params) => {
          resolve();
        });
      });

      expect(event.props.properties.trace).to.include(
        EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal,
      );

      vi.useFakeTimers({ shouldAdvanceTime: true });
      vi.useFakeTimers({ shouldAdvanceTime: true, shouldClearNativeTimers: true });
      vi.setSystemTime(Date.now() + 60_000 * 6);
      await throttle(5_000);

      expect(event.props.type).to.eq(EVENT_CLIENT_PAIRING_ERRORS.proposal_expired);

      vi.useRealTimers();

      await deleteClients(clients);
    });
    it("should set missing event listener error type", async () => {
      const clients = await initTwoClients();
      const { uri } = await clients.A.connect({});
      if (!uri) throw new Error("URI is undefined");
      await clients.B.pair({ uri });
      const { topic } = parseUri(uri);
      expect(clients.B.core.eventClient.events.size).to.eq(1);
      const event = clients.B.core.eventClient.getEvent({ topic });
      if (!event) throw new Error("Event is undefined");
      expect(event).to.exist;
      expect(event.props.event).to.eq("ERROR");
      expect(event.props.type).to.eq(""); // there is no type yet as no error has happened
      expect(event.props.properties.topic).to.eq(topic);
      expect(event.props.properties.trace).to.exist;
      expect(event.props.properties.trace.length).to.toBeGreaterThan(0);

      // wait for the proposal to be received
      await throttle(5_000);

      expect(event.props.type).to.eq(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);

      await deleteClients(clients);
    });
    it("should create event during approve session flow when proposal is not found", async () => {
      const wallet = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "wallet",
        metadata: TEST_WALLET_METADATA,
      });

      await expect(wallet.approve({ id: 123, namespaces: TEST_NAMESPACES })).rejects.toThrowError();
      expect(wallet.core.eventClient.events.size).to.eq(1);
      const event = wallet.core.eventClient.getEvent({ topic: "123" });
      if (!event) throw new Error("Event is undefined");
      expect(event).to.exist;
      expect(event.props.event).to.eq("ERROR");
      expect(event.props.type).to.eq(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);
      expect(event.props.properties.topic).to.eq("123");
      expect(event.props.properties.trace).to.exist;
      expect(event.props.properties.trace.length).to.toBeGreaterThan(0);
      await deleteClients({ A: wallet, B: undefined });
    });
    it("should create event during approve session flow and delete it on successful approve", async () => {
      const clients = await initTwoClients();
      const { uri } = await clients.A.connect({});
      if (!uri) throw new Error("URI is undefined");
      await clients.B.pair({ uri });
      const { topic } = parseUri(uri);
      expect(clients.B.core.eventClient.events.size).to.eq(1);
      const event = clients.B.core.eventClient.getEvent({ topic });
      if (!event) throw new Error("Event is undefined");
      expect(event).to.exist;
      expect(event.props.event).to.eq("ERROR");
      expect(event.props.type).to.eq(""); // there is no type yet as no error has happened
      expect(event.props.properties.topic).to.eq(topic);
      expect(event.props.properties.trace).to.exist;
      expect(event.props.properties.trace.length).to.toBeGreaterThan(0);

      await new Promise<void>((resolve) => {
        clients.B.once("session_proposal", async (params) => {
          // confirm the emit_session_proposal trace
          expect(event.props.properties.trace).to.include(
            EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal,
          );
          await clients.B.approve({ id: params.id, namespaces: TEST_NAMESPACES });
          resolve();
        });
      });

      await throttle(2_000);

      // the event should be deleted
      expect(clients.B.core.eventClient.events.size).to.eq(0);

      await deleteClients(clients);
    });
  });
});
</file>

<file path="packages/sign-client/test/sdk/link-mode.spec.ts">
import { formatJsonRpcResult } from "@walletconnect/jsonrpc-utils";
import { buildAuthObject, populateAuthPayload } from "@walletconnect/utils";
import { beforeAll, describe, expect, it } from "vitest";
import { Wallet as CryptoWallet } from "@ethersproject/wallet";
import { SignClient } from "../../src";
import { throttle, TEST_SIGN_CLIENT_OPTIONS, TEST_APP_METADATA_B } from "../shared";

describe("Sign Client Link Mode", () => {
  let cryptoWallet: CryptoWallet;

  beforeAll(() => {
    cryptoWallet = CryptoWallet.createRandom();
    const handlers: any = {};
    (global as any).Linking = {
      openURL: (url: any, sender: string) => {
        if (sender === "dapp") {
          handlers.wallet({ url }, "wallet");
        } else {
          handlers.dapp({ url }, "dapp");
        }
      },
      addEventListener: (_, cb, name) => {
        handlers[name] = cb;
      },
      getInitialURL: () => undefined,
    };
  });

  describe("ping", () => {
    it("should establish authenticated session with single signature via link mode", async () => {
      const dapp = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "dapp",
        metadata: {
          name: "dapp",
          description: "dapp description",
          url: "https://localhost:dapp",
          icons: ["https://localhost:3000/favicon.ico"],
          redirect: {
            universal: "https://localhost:/dapp",
            linkMode: true,
          },
        },
      });
      dapp.core.addLinkModeSupportedApp("https://localhost:/wallet");
      const requestedChains = ["eip155:1", "eip155:2"];
      const requestedMethods = ["personal_sign", "eth_chainId", "eth_signTypedData_v4"];
      const { uri, response } = await dapp.authenticate(
        {
          chains: requestedChains,
          domain: "localhost",
          nonce: "1",
          uri: "aud",
          methods: requestedMethods,
          resources: [
            "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
          ],
        },
        "https://localhost:/wallet",
      );
      const wallet = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS,
        name: "wallet",
        metadata: {
          ...TEST_APP_METADATA_B,
          redirect: {
            universal: "https://localhost:/wallet",
            linkMode: true,
          },
        },
      });

      expect(dapp.core.relayer.connected).to.be.false;
      expect(wallet.core.relayer.connected).to.be.false;

      await Promise.all([
        Promise.race<void>([
          new Promise((resolve) => {
            wallet.on("session_authenticate", async (payload) => {
              const authPayload = populateAuthPayload({
                authPayload: payload.params.authPayload,
                chains: requestedChains,
                methods: requestedMethods,
              });
              const iss = `${requestedChains[0]}:${cryptoWallet.address}`;
              const message = wallet.engine.formatAuthMessage({
                request: authPayload,
                iss,
              });
              const sig = await cryptoWallet.signMessage(message);
              const auth = buildAuthObject(
                authPayload,
                {
                  t: "eip191",
                  s: sig,
                },
                iss,
              );
              await wallet.approveSessionAuthenticate({
                id: payload.id,
                auths: [auth],
              });
              resolve();
            });
          }),
          new Promise((_, reject) => {
            wallet.on("session_proposal", () => {
              reject(new Error("wallet should not emit session_proposal"));
            });
          }),
        ]),
        new Promise<void>((resolve) => {
          global.Linking.openURL(uri, "dapp");
          resolve();
        }),
      ]);
      const { session } = await response();

      expect(dapp.core.relayer.connected).to.be.false;
      expect(wallet.core.relayer.connected).to.be.false;

      await Promise.all([
        new Promise<void>((resolve) => {
          wallet.on("session_request", async (params) => {
            await wallet.respond({
              topic: session.topic,
              response: formatJsonRpcResult(params.id, "test"),
            });
            resolve();
          });
        }),
        new Promise<void>(async (resolve) => {
          const result = await dapp.request({
            topic: session.topic,
            request: {
              method: "personal_sign",
              params: ["0xdeadbeef", "0xAddress"],
            },
            chainId: "eip155:1",
          });
          resolve();
        }),
      ]);

      expect(dapp.core.relayer.connected).to.be.false;
      expect(wallet.core.relayer.connected).to.be.false;

      await throttle(2000);
    });
  });
});
</file>

<file path="packages/sign-client/test/sdk/persistence.spec.ts">
import { formatJsonRpcError, JsonRpcError } from "@walletconnect/jsonrpc-utils";
import { generateRandomBytes32, getSdkError } from "@walletconnect/utils";
import { describe, expect, it } from "vitest";
import { SignClient } from "../../src";
import {
  initTwoClients,
  testConnectMethod,
  deleteClients,
  throttle,
  TEST_REQUEST_PARAMS,
  TEST_SIGN_CLIENT_OPTIONS_B,
  TEST_SIGN_CLIENT_OPTIONS_A,
  TEST_NAMESPACES,
  TEST_APP_METADATA_A,
  TEST_SIGN_CLIENT_NAME_A,
} from "../shared";
import { Core, RELAYER_EVENTS } from "@walletconnect/core";
import { RelayerTypes } from "@walletconnect/types";

const generateClientDbName = (prefix: string) =>
  `./test/tmp/${prefix}_${generateRandomBytes32()}.db`;

describe("Sign Client Persistence", () => {
  describe("ping", () => {
    describe("pairing", () => {
      describe("after restart", () => {
        it("clients can ping each other", async () => {
          const db_a = generateClientDbName("client_a");
          const db_b = generateClientDbName("client_b");

          let clients = await initTwoClients(
            {
              storageOptions: { database: db_a },
            },
            {
              storageOptions: { database: db_b },
            },
          );

          expect(clients.A.core.relayer.connected).toBe(false);
          expect(clients.B.core.relayer.connected).toBe(false);

          const {
            pairingA: { topic },
          } = await testConnectMethod(clients);

          await Promise.all([
            new Promise((resolve) => {
              // ping
              clients.B.core.pairing.events.on("pairing_ping", (event: any) => {
                resolve(event);
              });
            }),
            new Promise((resolve) => {
              clients.A.core.pairing.events.on("pairing_ping", (event: any) => {
                resolve(event);
              });
            }),
            new Promise<void>(async (resolve, reject) => {
              try {
                await clients.A.ping({ topic });
                await clients.B.ping({ topic });
                resolve();
              } catch (error) {
                reject(error);
              }
            }),
          ]);

          await deleteClients(clients);
          // restart
          clients = await initTwoClients(
            {
              storageOptions: { database: db_a },
            },
            {
              storageOptions: { database: db_b },
            },
          );

          expect(clients.A.core.relayer.connected).toBe(true);
          expect(clients.B.core.relayer.connected).toBe(true);

          // ping
          await clients.A.ping({ topic });
          await clients.B.ping({ topic });

          await deleteClients(clients);
        });
      });
    });
    describe("session", () => {
      describe("after restart", () => {
        it("clients can ping each other", async () => {
          const db_a = generateClientDbName("client_a");
          const db_b = generateClientDbName("client_b");
          let clients = await initTwoClients(
            {
              storageOptions: { database: db_a },
            },
            {
              storageOptions: { database: db_b },
            },
          );
          const {
            sessionA: { topic },
          } = await testConnectMethod(clients);

          await Promise.all([
            new Promise((resolve) => {
              // ping
              clients.B.on("session_ping", (event: any) => {
                resolve(event);
              });
            }),
            new Promise((resolve) => {
              clients.A.on("session_ping", (event: any) => {
                resolve(event);
              });
            }),
            new Promise<void>(async (resolve, reject) => {
              try {
                await clients.A.ping({ topic });
                await clients.B.ping({ topic });
                resolve();
              } catch (error) {
                reject(error);
              }
            }),
          ]);

          // delete
          await deleteClients(clients);

          await throttle(2_000);
          // restart
          clients = await initTwoClients(
            {
              storageOptions: { database: db_a },
            },
            {
              storageOptions: { database: db_b },
            },
          );

          // ping
          await clients.A.ping({ topic });
          await clients.B.ping({ topic });
          // delete
          await deleteClients(clients);
        });

        it("should respond to pending request after restart", async () => {
          const db_a = generateClientDbName("client_a");
          const db_b = generateClientDbName("client_b");
          const clients = await initTwoClients(
            {
              storageOptions: { database: db_a },
            },
            {
              storageOptions: { database: db_b },
            },
          );
          const {
            sessionA: { topic },
          } = await testConnectMethod(clients);

          let rejection: JsonRpcError;

          await Promise.all([
            new Promise<void>((resolve) => {
              clients.B.on("session_request", async (args) => {
                // delete client B so it can be reinstated
                await deleteClients({ A: undefined, B: clients.B });

                await throttle(1_000);

                // restart
                clients.B = await SignClient.init({
                  ...TEST_SIGN_CLIENT_OPTIONS_B,
                  storageOptions: { database: db_b },
                });
                const pendingRequests = clients.B.getPendingSessionRequests();
                const { id, topic, params } = pendingRequests[0];
                expect(params).toEqual(args.params);
                expect(topic).toEqual(args.topic);
                expect(id).toEqual(args.id);
                rejection = formatJsonRpcError(id, getSdkError("USER_REJECTED_METHODS").message);

                await clients.B.respond({
                  topic,
                  response: rejection,
                });

                resolve();
              });
            }),
            new Promise<void>(async (resolve) => {
              try {
                await clients.A.request({
                  topic,
                  ...TEST_REQUEST_PARAMS,
                });
              } catch (err) {
                expect(err.message).toMatch(rejection.error.message);
                resolve();
              }
            }),
          ]);

          // delete
          await deleteClients(clients);
        });

        it("should complete a session after dapp restart", async () => {
          const db_a = generateClientDbName("client_a");
          const db_b = generateClientDbName("client_b");
          const clients = await initTwoClients(
            {
              storageOptions: { database: db_a },
            },
            {
              storageOptions: { database: db_b },
            },
          );

          const wallet = clients.B;

          const { uri } = await clients.A.connect({});

          if (!uri) {
            throw new Error("uri is undefined");
          }

          await deleteClients({ A: clients.A, B: undefined });

          const dapp = await SignClient.init({
            ...TEST_SIGN_CLIENT_OPTIONS_A,
            storageOptions: { database: db_a },
          });

          let dappSessionTopic: string | undefined;
          let walletSessionTopic: string | undefined;

          await Promise.all([
            new Promise<void>((resolve) => {
              dapp.on("session_connect", ({ session }) => {
                expect(session).to.exist;
                dappSessionTopic = session.topic;
                resolve();
              });
            }),
            new Promise<void>((resolve) => {
              wallet.on("session_proposal", async (args) => {
                const { id } = args;
                const session = await wallet.approve({ id, namespaces: TEST_NAMESPACES });
                walletSessionTopic = session.topic;
                resolve();
              });
            }),
            wallet.pair({ uri }),
          ]);

          expect(dappSessionTopic).to.be.a("string");
          expect(walletSessionTopic).to.be.a("string");
          expect(dappSessionTopic).toEqual(walletSessionTopic);

          // delete
          await deleteClients(clients);
        });
      });
    });
  });
  describe("mailbox", () => {
    /**
     * this test simulates case where a dapp is offline while the wallet performs normal operations such as adding new accounts & emitting events
     * the dapp should receive all requests when it comes back online and process them in the expected order
     */
    it("should process incoming mailbox messages after restart", async () => {
      const chains = ["eip155:1"];
      const accounts = ["0x0000000", "0x1111111", "0x2222222"];
      const requiredNamespaces = {
        eip155: {
          chains,
          methods: ["eth_sendTransaction"],
          events: ["chainChanged", "accountsChanged"],
        },
      };

      const approvedNamespaces = {
        eip155: {
          ...requiredNamespaces.eip155,
          accounts: [`${chains[0]}:${accounts[0]}`],
        },
      };

      const db_a = generateClientDbName("client_a");
      const clients = await initTwoClients({
        storageOptions: { database: db_a },
      });
      const {
        sessionA: { topic },
      } = await testConnectMethod(clients, {
        requiredNamespaces,
        namespaces: approvedNamespaces,
      });

      // delete client B
      await deleteClients({ A: clients.A, B: undefined });
      await throttle(500);
      await clients.B.update({
        topic,
        namespaces: {
          eip155: {
            ...approvedNamespaces.eip155,
            accounts: approvedNamespaces.eip155.accounts.concat([`${chains[0]}:${accounts[1]}`]),
          },
        },
      });
      await throttle(500);
      const lastWalletSessionNamespacesValue = {
        eip155: {
          ...approvedNamespaces.eip155,
          accounts: approvedNamespaces.eip155.accounts.concat([
            `${chains[0]}:${accounts[1]}`,
            `${chains[0]}:${accounts[2]}`,
          ]),
        },
      };

      await clients.B.update({
        topic,
        namespaces: lastWalletSessionNamespacesValue,
      });
      await clients.B.emit({
        topic,
        event: {
          name: "accountsChanged",
          data: [`${chains[0]}:${accounts[1]}`],
        },
        chainId: "eip155:1",
      });
      await throttle(500);
      await clients.B.emit({
        topic,
        event: {
          name: "accountsChanged",
          data: [`${chains[0]}:${accounts[2]}`],
        },
        chainId: "eip155:1",
      });

      const lastAccountsChangedValue = [`${chains[0]}:${accounts[1]}`];
      await clients.B.emit({
        topic,
        event: {
          name: "accountsChanged",
          data: lastAccountsChangedValue,
        },
        chainId: "eip155:1",
      });
      // restart the client
      clients.A = await SignClient.init({
        ...TEST_SIGN_CLIENT_OPTIONS_A,
        storageOptions: { database: db_a },
      });
      let lastAccountEvent: any;
      await Promise.all([
        new Promise<void>((resolve) => {
          clients.A.on("session_update", (event) => {
            resolve();
          });
        }),
        new Promise<void>((resolve) => {
          clients.A.on("session_event", (event) => {
            lastAccountEvent = event.params.event.data;
            if (lastAccountEvent[0] === lastAccountsChangedValue[0]) {
              resolve();
            }
          });
        }),
      ]);

      await throttle(2_000);

      const session = clients.A.session.get(topic);
      expect(session).toBeDefined();
      expect(session.namespaces).toEqual(lastWalletSessionNamespacesValue);
      expect(lastAccountEvent).toEqual(lastAccountsChangedValue);

      await deleteClients(clients);
    });
    /**
     * this test simulates a case where `Core` receives a message mid initialization
     * before the implementing client (sign-client) is ready to process it
     * the message should be queued and processed after the client is ready
     */
    it("should process pending messages after restart", async () => {
      const db_a = generateClientDbName("client_a");
      const clients = await initTwoClients(
        {
          storageOptions: { database: db_a },
        },
        {},
      );
      const {
        sessionA: { topic },
      } = await testConnectMethod(clients);
      let messageEvent: RelayerTypes.MessageEvent;
      await Promise.all([
        new Promise<void>((resolve) => {
          clients.A.core.relayer.once(
            RELAYER_EVENTS.message,
            (event: RelayerTypes.MessageEvent) => {
              messageEvent = event;
              resolve();
            },
          );
        }),
        clients.B.ping({ topic }),
      ]);
      await clients.A.core.relayer.transportClose();
      await throttle(1000);
      const core = new Core({
        storageOptions: { database: db_a },
        projectId: process.env.TEST_PROJECT_ID,
      });
      let onMessageEventTimestamp: number;
      core.relayer.on(RELAYER_EVENTS.connect, async () => {
        // delete the message from the relayer so it can be processed again
        await core.relayer.messages.del(topic);
        // @ts-expect-error - private method
        await core.relayer.onMessageEvent(messageEvent);
        onMessageEventTimestamp = Date.now();
        if (core.relayer.messages.messagesWithoutClientAck.size !== 1) {
          throw new Error("message not queued for processing");
        }
      });

      const wallet = await SignClient.init({
        name: TEST_SIGN_CLIENT_NAME_A,
        metadata: TEST_APP_METADATA_A,
        core,
      });
      const walletInitTimestamp = Date.now();

      // validate that the message was received before the wallet was initialized
      expect(walletInitTimestamp).toBeGreaterThan(onMessageEventTimestamp);
      // validate that the message was processed by the wallet even though it was received before the wallet was initialized
      await new Promise<void>((resolve) => {
        wallet.on("session_ping", () => {
          resolve();
        });
      });
      await throttle(1000);
      expect(core.relayer.messages.messagesWithoutClientAck.size).toBe(0);
      await deleteClients({ A: wallet, B: clients.B });
    });
  });
});
</file>

<file path="packages/sign-client/test/sdk/transport.spec.ts">
import { describe, expect, it } from "vitest";
import {
  initTwoClients,
  testConnectMethod,
  deleteClients,
  throttle,
  initTwoPairedClients,
} from "../shared";

describe("Sign Client Transport Tests", () => {
  describe("transport", () => {
    it("should disconnect & reestablish socket transport", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients();
      await clients.A.core.relayer.restartTransport();
      await clients.B.core.relayer.restartTransport();
      await Promise.all([
        new Promise((resolve) => {
          clients.B.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise((resolve) => {
          clients.A.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise<void>(async (resolve, reject) => {
          try {
            await clients.A.ping({ topic });
            await clients.B.ping({ topic });
            resolve();
          } catch (error) {
            reject(error);
          }
        }),
      ]);
      await deleteClients(clients);
    });
    it("should disconnect & reestablish socket transport with delay", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients();
      await clients.A.core.relayer.restartTransport();
      await throttle(2000);
      await clients.B.core.relayer.restartTransport();
      await Promise.all([
        new Promise((resolve) => {
          clients.B.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise((resolve) => {
          clients.A.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise<void>(async (resolve, reject) => {
          try {
            await clients.A.ping({ topic });
            await clients.B.ping({ topic });
            resolve();
          } catch (error) {
            reject(error);
          }
        }),
      ]);
      await deleteClients(clients);
    });
    it("should automatically start transport on request after being closed. Case 1", async () => {
      const {
        clients,
        sessionA: { topic },
      } = await initTwoPairedClients();
      await clients.A.core.relayer.transportClose();
      await throttle(2000);
      await Promise.all([
        new Promise((resolve) => {
          clients.B.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise((resolve) => {
          clients.A.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise<void>(async (resolve, reject) => {
          try {
            await clients.A.ping({ topic });
            await clients.B.ping({ topic });
            resolve();
          } catch (error) {
            reject(error);
          }
        }),
      ]);
      await deleteClients(clients);
    });
    it("should automatically start transport on request after being closed. Case 2", async () => {
      const clients = await initTwoClients();

      // both clients should be auto disconnected
      expect(clients.A.core.relayer.connected).toBe(false);
      expect(clients.B.core.relayer.connected).toBe(false);

      const {
        sessionA: { topic },
      } = await testConnectMethod(clients);
      await Promise.all([
        new Promise((resolve) => {
          clients.B.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise((resolve) => {
          clients.A.on("session_ping", (event: any) => {
            resolve(event);
          });
        }),
        new Promise<void>(async (resolve, reject) => {
          try {
            await clients.A.ping({ topic });
            await clients.B.ping({ topic });
            resolve();
          } catch (error) {
            reject(error);
          }
        }),
      ]);
      await deleteClients(clients);
    });
  });
});
</file>

<file path="packages/sign-client/test/sdk/validation.spec.ts">
// @ts-nocheck
import { expect, describe, it, beforeAll, afterAll } from "vitest";
import {
  initTwoClients,
  testConnectMethod,
  TEST_APPROVE_PARAMS,
  TEST_CONNECT_PARAMS,
  TEST_REJECT_PARAMS,
  TEST_UPDATE_PARAMS,
  TEST_REQUEST_PARAMS,
  TEST_EMIT_PARAMS,
  TEST_RESPOND_PARAMS,
  TEST_NAMESPACES,
  TEST_REQUIRED_NAMESPACES,
  TEST_NAMESPACES_INVALID_METHODS,
  TEST_NAMESPACES_INVALID_CHAIN,
  deleteClients,
  Clients,
  throttle,
} from "../shared";
import SignClient from "../../src";

let clients: Clients;
let proposalId: number;
let pairingTopic: string;
let topic: string;

describe("Sign Client Validation", () => {
  beforeAll(async () => {
    clients = await initTwoClients();
    await testConnectMethod(clients);
    pairingTopic = clients.A.pairing.keys[0];
    topic = clients.A.session.keys[0];
    proposalId = await clients.A.connect({}).then(() => {
      return clients.A.proposal.keys[0];
    });
  });

  afterAll(async () => {
    await deleteClients(clients);
  });
  describe("connect", () => {
    it("throws when invalid pairingTopic is provided", async () => {
      await expect(
        clients.A.connect({ ...TEST_CONNECT_PARAMS, pairingTopic: 123 }),
      ).rejects.toThrowError("Missing or invalid. pairing topic should be a string: 123");
    });

    it("throws when empty pairingTopic is provided", async () => {
      await expect(
        clients.A.connect({ ...TEST_CONNECT_PARAMS, pairingTopic: "" }),
      ).rejects.toThrowError("Missing or invalid. pairing topic should be a string: ");
    });

    it("throws when non existent pairingTopic is provided", async () => {
      await expect(
        clients.A.connect({ ...TEST_CONNECT_PARAMS, pairingTopic: "none" }),
      ).rejects.toThrowError("No matching key. pairing topic doesn't exist: none");
    });

    it("throws when invalid requiredNamespaces & optionalNamespaces are provided", async () => {
      await expect(
        clients.A.connect({
          ...TEST_CONNECT_PARAMS,
          pairingTopic,
          requiredNamespaces: [],
          optionalNamespaces: [],
        }),
      ).rejects.toThrowError(
        "Missing or invalid. connect(), requiredNamespaces should be an object with data",
      );
    });

    it("throws when invalid optionalNamespaces are provided", async () => {
      await expect(
        clients.A.connect({
          ...TEST_CONNECT_PARAMS,
          pairingTopic,
          requiredNamespaces: {},
          optionalNamespaces: [],
        }),
      ).rejects.toThrowError(
        "Missing or invalid. connect(), optionalNamespaces should be an object with data",
      );
    });
    it("throws when no chains are specified within requiredNamespaces", async () => {
      await expect(
        clients.A.connect({
          requiredNamespaces: {
            eip155: {
              chains: [],
            },
          },
        }),
      ).rejects.toThrowError(
        `Unsupported chains. connect() requiredNamespaces, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`,
      );
    });
    it("throws when no chains are specified within optionalNamespaces", async () => {
      await expect(
        clients.A.connect({
          optionalNamespaces: {
            eip155: {
              chains: [],
            },
          },
        }),
      ).rejects.toThrowError(
        `Unsupported chains. connect() optionalNamespaces, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`,
      );
    });
    it("should create pairing with inline defined chain", async () => {
      const connect = await clients.A.connect({
        optionalNamespaces: {
          "eip155:1": {
            methods: [],
            events: [],
          },
        },
      });
      expect(connect).toBeDefined();
      expect(connect).toHaveProperty("uri");
      expect(connect.uri).to.be.string;
    });
    it("should reject connect with scopedProperties when not defined in requiredNamespaces or optionalNamespaces", async () => {
      await expect(
        clients.A.connect({
          scopedProperties: {
            "eip155:1": {},
          },
        }),
      ).rejects.toThrowError(
        `Scoped properties must be a subset of required/optional namespaces, received: {"eip155:1":{}}, required/optional namespaces: []`,
      );
    });
  });

  describe("approve", () => {
    it("should reject approve with scopedProperties when not defined in namespaces", async () => {
      const proposalId = await clients.A.connect(TEST_CONNECT_PARAMS).then(() => {
        return clients.A.proposal.keys[0];
      });
      await expect(
        clients.A.approve({
          id: proposalId,
          namespaces: TEST_APPROVE_PARAMS.namespaces,
          scopedProperties: {
            solana: "test",
          },
        }),
      ).rejects.toThrowError(
        `Scoped properties must be a subset of approved namespaces, received: {"solana":"test"}, approved namespaces: ${Object.keys(
          TEST_APPROVE_PARAMS.namespaces,
        ).join(", ")}`,
      );
    });
    it("throws when no params are passed", async () => {
      await expect(clients.A.approve()).rejects.toThrowError(
        "Missing or invalid. proposal id should be a number: undefined",
      );
    });

    it("throws when invalid id is provided", async () => {
      await expect(clients.A.approve({ ...TEST_APPROVE_PARAMS, id: "123" })).rejects.toThrowError(
        "Missing or invalid. proposal id should be a number: 123",
      );
    });

    it("throws when empty id is provided", async () => {
      await expect(clients.A.approve({ ...TEST_APPROVE_PARAMS, id: "" })).rejects.toThrowError(
        "Missing or invalid. proposal id should be a number: ",
      );
    });

    it("throws when no id is provided", async () => {
      await expect(
        clients.A.approve({ ...TEST_APPROVE_PARAMS, id: undefined }),
      ).rejects.toThrowError("Missing or invalid. proposal id should be a number: undefined");
    });

    it("throws when non existent id is provided", async () => {
      await expect(clients.A.approve({ ...TEST_APPROVE_PARAMS, id: 123 })).rejects.toThrowError(
        "No matching key. proposal id doesn't exist: 123",
      );
    });

    it("throws when invalid namespaces are provided", async () => {
      await expect(
        clients.A.approve({ ...TEST_APPROVE_PARAMS, id: proposalId, namespaces: [] }),
      ).rejects.toThrowError(
        "Missing or invalid. approve(), namespaces should be an object with data",
      );
    });

    it("throws when empty namespaces are provided", async () => {
      await expect(
        clients.A.approve({ ...TEST_APPROVE_PARAMS, id: proposalId, namespaces: {} }),
      ).rejects.toThrowError(
        "Missing or invalid. approve(), namespaces should be an object with data",
      );
    });

    it("throws when no namespaces are provided", async () => {
      await expect(
        clients.A.approve({ ...TEST_APPROVE_PARAMS, id: proposalId, namespaces: undefined }),
      ).rejects.toThrowError(
        "Missing or invalid. approve(), namespaces should be an object with data",
      );
    });

    it("throws when invalid relayProtocol is provided", async () => {
      await expect(
        clients.A.approve({ ...TEST_APPROVE_PARAMS, id: proposalId, relayProtocol: 123 }),
      ).rejects.toThrowError("Missing or invalid. approve() relayProtocol: 123");
    });

    it("throws when empty relayProtocol is provided", async () => {
      await expect(
        clients.A.approve({ ...TEST_APPROVE_PARAMS, id: proposalId, relayProtocol: "" }),
      ).rejects.toThrowError("Missing or invalid. approve() relayProtocol: ");
    });
  });

  describe("reject", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.reject()).rejects.toThrowError(
        "Missing or invalid. reject() params: undefined",
      );
    });

    it("throws when invalid id is provided", async () => {
      await expect(clients.A.reject({ ...TEST_REJECT_PARAMS, id: "123" })).rejects.toThrowError(
        "Missing or invalid. proposal id should be a number: 123",
      );
    });

    it("throws when empty id is provided", async () => {
      await expect(clients.A.reject({ ...TEST_REJECT_PARAMS, id: "" })).rejects.toThrowError(
        "Missing or invalid. proposal id should be a number: ",
      );
    });

    it("throws when no id is provided", async () => {
      await expect(clients.A.reject({ ...TEST_REJECT_PARAMS, id: undefined })).rejects.toThrowError(
        "Missing or invalid. proposal id should be a number: undefined",
      );
    });

    it("throws when empty reason is provided", async () => {
      await expect(
        clients.A.reject({ ...TEST_REJECT_PARAMS, id: proposalId, reason: {} }),
      ).rejects.toThrowError("Missing or invalid. reject() reason: {}");
    });

    it("throws when invalid reason is provided", async () => {
      await expect(
        clients.A.reject({ ...TEST_REJECT_PARAMS, id: proposalId, reason: [] }),
      ).rejects.toThrowError("Missing or invalid. reject() reason: []");
    });

    it("throws when no reason is provided", async () => {
      await expect(
        clients.A.reject({ ...TEST_REJECT_PARAMS, id: proposalId, reason: undefined }),
      ).rejects.toThrowError("Missing or invalid. reject() reason: undefined");
    });

    it("throws when invalid reason code is provided", async () => {
      await expect(
        clients.A.reject({
          ...TEST_REJECT_PARAMS,
          id: proposalId,
          reason: { ...TEST_REJECT_PARAMS.reason, code: "1" },
        }),
      ).rejects.toThrowError(
        `Missing or invalid. reject() reason: {"code":"1","message":"GENERIC"}`,
      );
    });

    it("throws when empty reason code is provided", async () => {
      await expect(
        clients.A.reject({
          ...TEST_REJECT_PARAMS,
          id: proposalId,
          reason: { ...TEST_REJECT_PARAMS.reason, code: "" },
        }),
      ).rejects.toThrowError(
        `Missing or invalid. reject() reason: {"code":"","message":"GENERIC"}`,
      );
    });

    it("throws when no reason code is provided", async () => {
      await expect(
        clients.A.reject({
          ...TEST_REJECT_PARAMS,
          id: proposalId,
          reason: { ...TEST_REJECT_PARAMS.reason, code: undefined },
        }),
      ).rejects.toThrowError(`Missing or invalid. reject() reason: {"message":"GENERIC"}`);
    });

    it("throws when invalid reason message is provided", async () => {
      await expect(
        clients.A.reject({
          ...TEST_REJECT_PARAMS,
          id: proposalId,
          reason: { ...TEST_REJECT_PARAMS.reason, message: 123 },
        }),
      ).rejects.toThrowError(`Missing or invalid. reject() reason: {"code":0,"message":123}`);
    });

    it("throws when empty reason message is provided", async () => {
      await expect(
        clients.A.reject({
          ...TEST_REJECT_PARAMS,
          id: proposalId,
          reason: { ...TEST_REJECT_PARAMS.reason, message: "" },
        }),
      ).rejects.toThrowError(`Missing or invalid. reject() reason: {"code":0,"message":""}`);
    });

    it("throws when no reason message is provided", async () => {
      await expect(
        clients.A.reject({
          ...TEST_REJECT_PARAMS,
          id: proposalId,
          reason: { ...TEST_REJECT_PARAMS.reason, message: undefined },
        }),
      ).rejects.toThrowError(`Missing or invalid. reject() reason: {"code":0}`);
    });
  });

  describe("update", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.update()).rejects.toThrowError(
        "Missing or invalid. update() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.update({ ...TEST_UPDATE_PARAMS, topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.update({ ...TEST_UPDATE_PARAMS, topic: "" })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(
        clients.A.update({ ...TEST_UPDATE_PARAMS, topic: undefined }),
      ).rejects.toThrowError("Missing or invalid. session topic should be a string: undefined");
    });

    it("throws when non existent topic is provided", async () => {
      await expect(clients.A.update({ ...TEST_UPDATE_PARAMS, topic: "none" })).rejects.toThrowError(
        "No matching key. session topic doesn't exist: none",
      );
    });

    it("throws when invalid namespaces are provided", async () => {
      await expect(clients.A.update({ topic, namespaces: {} })).rejects.toThrowError(
        "Missing or invalid. update(), namespaces should be an object with data",
      );
    });

    it("throws when empty namespaces are provided", async () => {
      await expect(clients.A.update({ topic, namespaces: [] })).rejects.toThrowError(
        "Missing or invalid. update(), namespaces should be an object with data",
      );
    });

    it("throws when no namespaces are provided", async () => {
      await expect(clients.A.update({ topic, namespaces: undefined })).rejects.toThrowError(
        "Missing or invalid. update(), namespaces should be an object with data",
      );
    });

    it("throws when incompatible namespaces methods are provided", async () => {
      await expect(
        clients.A.update({
          topic,
          namespaces: TEST_NAMESPACES_INVALID_METHODS,
        }),
      ).rejects.toThrowError(
        "Non conforming namespaces. update() namespaces methods don't satisfy namespace methods for eip155",
      );
    });

    it("throws when incompatible namespaces chains are provided", async () => {
      await expect(
        clients.A.update({
          topic,
          namespaces: TEST_NAMESPACES_INVALID_CHAIN,
        }),
      ).rejects.toThrowError(
        `Non conforming namespaces. update() namespaces keys don't satisfy requiredNamespaces.
      Required: eip155
      Received: eip1111`,
      );
    });
  });

  describe("extend", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.extend()).rejects.toThrowError(
        "Missing or invalid. extend() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.extend({ topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.extend({ topic: "" })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(clients.A.extend({ topic: undefined })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: undefined",
      );
    });

    it("throws when non existent topic is provided", async () => {
      await expect(clients.A.extend({ topic: "none" })).rejects.toThrowError(
        "No matching key. session topic doesn't exist: none",
      );
    });
  });

  describe("request", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.request()).rejects.toThrowError(
        "Missing or invalid. request() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.request({ ...TEST_REQUEST_PARAMS, topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.request({ ...TEST_REQUEST_PARAMS, topic: "" })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic: undefined }),
      ).rejects.toThrowError("Missing or invalid. session topic should be a string: undefined");
    });

    it("throws when non existent topic is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic: "none" }),
      ).rejects.toThrowError("No matching key. session topic doesn't exist: none");
    });

    it("throws when invalid chainId is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, chainId: 123 }),
      ).rejects.toThrowError("Missing or invalid. request() chainId: 123");
    });

    it("throws when empty chainId is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, chainId: "" }),
      ).rejects.toThrowError("Missing or invalid. request() chainId: ");
    });

    it("throws when chain id is not in session namespace", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, chainId: "eip000:0" }),
      ).rejects.toThrowError("Missing or invalid. request() chainId: eip000:0");
    });

    it("throws when invalid request is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: 123 }),
      ).rejects.toThrowError("Missing or invalid. request() 123");
    });

    it("throws when empty request is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: {} }),
      ).rejects.toThrowError("Missing or invalid. request() {}");
    });

    it("throws when no request is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: undefined }),
      ).rejects.toThrowError("Missing or invalid. request() undefined");
    });

    it("throws when invalid request method is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: { method: 123 } }),
      ).rejects.toThrowError(`Missing or invalid. request() {"method":123}`);
    });

    it("throws when empty request method is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: { method: "" } }),
      ).rejects.toThrowError(`Missing or invalid. request() {"method":""}`);
    });

    it("throws when no request method is provided", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: { method: undefined } }),
      ).rejects.toThrowError("Missing or invalid. request() {}");
    });

    it("throws when request doesn't exist for given chainId", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, request: { method: "unknown" } }),
      ).rejects.toThrowError("Missing or invalid. request() method: unknown");
    });

    it("throws when invalid expiry is provider", async () => {
      await expect(
        clients.A.request({ ...TEST_REQUEST_PARAMS, topic, expiry: 10 }),
      ).rejects.toThrowError(
        "Missing or invalid. request() expiry: 10. Expiry must be a number (in seconds) between 300 and 604800",
      );
    });
  });

  describe("respond", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.respond()).rejects.toThrowError(
        "Missing or invalid. respond() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.respond({ ...TEST_REQUEST_PARAMS, topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.respond({ ...TEST_RESPOND_PARAMS, topic: "" })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(
        clients.A.respond({ ...TEST_RESPOND_PARAMS, topic: undefined }),
      ).rejects.toThrowError("Missing or invalid. session topic should be a string: undefined");
    });

    it("throws when no response or error is passed", async () => {
      await expect(
        clients.A.respond({
          ...TEST_RESPOND_PARAMS,
          topic,
          response: undefined,
          error: undefined,
        }),
      ).rejects.toThrowError("Missing or invalid. respond() response: undefined");
    });

    it("throws when no id is passed", async () => {
      await expect(
        clients.A.respond({
          ...TEST_RESPOND_PARAMS,
          topic,
          response: { ...TEST_RESPOND_PARAMS.response, id: undefined },
        }),
      ).rejects.toThrowError(
        `Missing or invalid. respond() response: {"jsonrpc":"2.0","result":{}}`,
      );
    });

    it("throws when invalid id is passed", async () => {
      await expect(
        clients.A.respond({
          ...TEST_RESPOND_PARAMS,
          topic,
          response: { ...TEST_RESPOND_PARAMS.response, id: "123" },
        }),
      ).rejects.toThrowError(
        `Missing or invalid. respond() response: {"id":"123","jsonrpc":"2.0","result":{}}`,
      );
    });

    it("throws when no jsonrpc is passed", async () => {
      await expect(
        clients.A.respond({
          ...TEST_RESPOND_PARAMS,
          topic,
          response: { ...TEST_RESPOND_PARAMS.response, jsonrpc: undefined },
        }),
      ).rejects.toThrowError(`Missing or invalid. respond() response: {"id":1,"result":{}}`);
    });

    it("throws when invalid jsonrpc is passed", async () => {
      await expect(
        clients.A.respond({
          ...TEST_RESPOND_PARAMS,
          topic,
          response: { ...TEST_RESPOND_PARAMS.response, jsonrpc: 123 },
        }),
      ).rejects.toThrowError(
        `Missing or invalid. respond() response: {"id":1,"jsonrpc":123,"result":{}}`,
      );
    });

    it("throws when empty jsonrpc is passed", async () => {
      await expect(
        clients.A.respond({
          ...TEST_RESPOND_PARAMS,
          topic,
          response: { ...TEST_RESPOND_PARAMS.response, jsonrpc: "" },
        }),
      ).rejects.toThrowError(
        `Missing or invalid. respond() response: {"id":1,"jsonrpc":"","result":{}}`,
      );
    });
  });

  describe("ping", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.ping()).rejects.toThrowError(
        "Missing or invalid. ping() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.ping({ topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session or pairing topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.ping({ topic: "" })).rejects.toThrowError(
        "Missing or invalid. session or pairing topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(clients.A.ping({ topic: undefined })).rejects.toThrowError(
        "Missing or invalid. session or pairing topic should be a string: undefined",
      );
    });

    it("throws when non existent topic is provided", async () => {
      await expect(clients.A.ping({ topic: "none" })).rejects.toThrowError(
        "No matching key. session or pairing topic doesn't exist: none",
      );
    });
  });

  describe("emit", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.emit()).rejects.toThrowError(
        "Missing or invalid. emit() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.emit({ ...TEST_EMIT_PARAMS, topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.emit({ ...TEST_EMIT_PARAMS, topic: "" })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(clients.A.emit({ ...TEST_EMIT_PARAMS, topic: undefined })).rejects.toThrowError(
        "Missing or invalid. session topic should be a string: undefined",
      );
    });

    it("throws when non existent topic is provided", async () => {
      await expect(clients.A.emit({ ...TEST_EMIT_PARAMS, topic: "none" })).rejects.toThrowError(
        "No matching key. session topic doesn't exist: none",
      );
    });

    it("throws when invalid chainId is provided", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, chainId: 123 }),
      ).rejects.toThrowError("Missing or invalid. emit() chainId: 123");
    });

    it("throws when empty chainId is provided", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, chainId: "" }),
      ).rejects.toThrowError("Missing or invalid. emit() chainId: ");
    });

    it("throws when invalid event is provided", async () => {
      await expect(clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: 123 })).rejects.toThrowError(
        "Missing or invalid. emit() event: 123",
      );
    });

    it("throws when empty event is provided", async () => {
      await expect(clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: {} })).rejects.toThrowError(
        "Missing or invalid. emit() event: {}",
      );
    });

    it("throws when no event is provided", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: undefined }),
      ).rejects.toThrowError("Missing or invalid. emit() event: undefined");
    });

    it("throws when invalid event name is provided", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: { name: 123 } }),
      ).rejects.toThrowError(`Missing or invalid. emit() event: {"name":123}`);
    });

    it("throws when empty event name is provided", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: { name: "" } }),
      ).rejects.toThrowError(`Missing or invalid. emit() event: {"name":""}`);
    });

    it("throws when no event name is provided", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: { name: undefined } }),
      ).rejects.toThrowError(`Missing or invalid. emit() event: {}`);
    });

    it("throws when event doesn't exist for given chainId", async () => {
      await expect(
        clients.A.emit({ ...TEST_EMIT_PARAMS, topic, event: { name: "unknown" } }),
      ).rejects.toThrowError(`Missing or invalid. emit() event: {"name":"unknown"}`);
    });
  });

  describe("disconnect", () => {
    it("throws when no params are passed", async () => {
      await expect(clients.A.disconnect()).rejects.toThrowError(
        "Missing or invalid. disconnect() params: undefined",
      );
    });

    it("throws when invalid topic is provided", async () => {
      await expect(clients.A.disconnect({ topic: 123 })).rejects.toThrowError(
        "Missing or invalid. session or pairing topic should be a string: 123",
      );
    });

    it("throws when empty topic is provided", async () => {
      await expect(clients.A.disconnect({ topic: "" })).rejects.toThrowError(
        "Missing or invalid. session or pairing topic should be a string: ",
      );
    });

    it("throws when no topic is provided", async () => {
      await expect(clients.A.disconnect({ topic: undefined })).rejects.toThrowError(
        "Missing or invalid. session or pairing topic should be a string: undefined",
      );
    });

    it("throws when non existent topic is provided", async () => {
      await expect(clients.A.disconnect({ topic: "none" })).rejects.toThrowError(
        "No matching key. session or pairing topic doesn't exist: none",
      );
    });
  });
  describe("miscellaneous", () => {
    it("should cleanup recentlyDeletedMap when size limit is reached", async () => {
      const client = clients.A.engine;
      client.recentlyDeletedMap.clear();
      const itemsToDelete = client.recentlyDeletedLimit - 1;
      // populate recentlyDeleted just below the limit
      for (let i = 0; i < itemsToDelete; i++) {
        const key = `key${i}`;
        const value = `session`;
        await client.addToRecentlyDeleted(key, value);
      }
      //@ts-expect-error
      expect(client.recentlyDeletedMap.size).to.be.greaterThan(1);
      //@ts-expect-error
      expect(client.recentlyDeletedMap.size).to.equal(itemsToDelete);
      // add one more to reach the limit
      await client.addToRecentlyDeleted("test", "session");

      // check that the recentlyDeleted list has been halved
      //@ts-expect-error
      expect(client.recentlyDeletedMap.size).to.be.greaterThan(1);
      //@ts-expect-error
      expect(client.recentlyDeletedMap.size).to.equal(client.recentlyDeletedLimit / 2);
    });
  });
});
</file>

<file path="packages/sign-client/test/shared/connect.ts">
import { parseUri } from "@walletconnect/utils";
import {
  EngineTypes,
  PairingTypes,
  RelayerTypes,
  ProposalTypes,
  SessionTypes,
} from "@walletconnect/types";
import { throttle } from "./../shared";
import {
  TEST_RELAY_OPTIONS,
  TEST_NAMESPACES,
  TEST_REQUIRED_NAMESPACES,
  TEST_OPTIONAL_NAMESPACES,
  TEST_SESSION_PROPERTIES,
  TEST_SESSION_PROPERTIES_APPROVE,
} from "./values";
import { Clients } from "./init";
import { expect } from "vitest";

export interface TestConnectParams {
  requiredNamespaces?: ProposalTypes.RequiredNamespaces;
  optionalNamespaces?: ProposalTypes.OptionalNamespaces;
  namespaces?: SessionTypes.Namespaces;
  sessionProperties?: ProposalTypes.SessionProperties;
  relays?: RelayerTypes.ProtocolOptions[];
  pairingTopic?: string;
  qrCodeScanLatencyMs?: number;
}

export async function testConnectMethod(clients: Clients, params?: TestConnectParams) {
  const start = Date.now();
  const { A, B } = clients;

  const connectParams: EngineTypes.ConnectParams = {
    requiredNamespaces: params?.requiredNamespaces || TEST_REQUIRED_NAMESPACES,
    optionalNamespaces: params?.optionalNamespaces || TEST_OPTIONAL_NAMESPACES,
    sessionProperties: params?.sessionProperties || TEST_SESSION_PROPERTIES,
    relays: params?.relays || undefined,
    pairingTopic: params?.pairingTopic || undefined,
  };

  const approveParams: Omit<EngineTypes.ApproveParams, "id"> = {
    namespaces: params?.namespaces || TEST_NAMESPACES,
    sessionProperties: TEST_SESSION_PROPERTIES_APPROVE,
  };

  // We need to kick off the promise that binds the listener for `session_proposal` before `A.connect()`
  // is called, to avoid race conditions.
  const resolveSessionProposal = new Promise<void>((resolve, reject) => {
    B.once("session_proposal", async (proposal) => {
      try {
        expect(proposal.params.requiredNamespaces).to.eql(connectParams.requiredNamespaces);
        expect(proposal.params.optionalNamespaces).to.eql(connectParams.optionalNamespaces);
        expect(proposal.params.sessionProperties).to.eql(TEST_SESSION_PROPERTIES);
        const { acknowledged } = await B.approve({
          id: proposal.id,
          ...approveParams,
        });
        if (!sessionB) {
          sessionB = await acknowledged();
        }
        resolve();
      } catch (e) {
        reject(e);
      }
    });
  });

  const connect: Promise<{
    uri?: string | undefined;
    approval: () => Promise<SessionTypes.Struct>;
  }> = new Promise(async function (resolve, reject) {
    const connectTimeoutMs = 800_000;
    const timeout = setTimeout(() => {
      return reject(new Error(`Connect timed out after ${connectTimeoutMs}ms - ${A.core.name}`));
    }, connectTimeoutMs);
    try {
      const result = await A.connect(connectParams);
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      clearTimeout(timeout);
    }
  });

  const { uri, approval } = await connect;
  const clientAConnectLatencyMs = Date.now() - start;

  let pairingA: PairingTypes.Struct | undefined;
  let pairingB: PairingTypes.Struct | undefined;

  if (!connectParams.pairingTopic) {
    // This is a new pairing. Let's apply a timeout to mimic
    // QR code scanning
    if (!uri) throw new Error("uri is missing");
    if (params?.qrCodeScanLatencyMs) await throttle(params?.qrCodeScanLatencyMs);

    const uriParams = parseUri(uri);

    pairingA = A.pairing.get(uriParams.topic);
    expect(pairingA.topic).to.eql(uriParams.topic);
    expect(pairingA.relay).to.eql(uriParams.relay);
  } else {
    pairingA = A.pairing.get(connectParams.pairingTopic);
    pairingB = B.pairing.get(connectParams.pairingTopic);
  }

  if (!pairingA) throw new Error("expect pairing A to be defined");

  let sessionA: SessionTypes.Struct | undefined;
  let sessionB: SessionTypes.Struct | undefined;

  const pair: (uri: string) => Promise<PairingTypes.Struct> = (uri: string) =>
    new Promise(async function (resolve, reject) {
      const pairTimeoutMs = 800_000;
      const timeout = setTimeout(() => {
        return reject(new Error(`Pair timed out after ${pairTimeoutMs}ms`));
      }, pairTimeoutMs);
      try {
        const result = await B.pair({ uri });
        clearTimeout(timeout);
        resolve(result);
      } catch (error) {
        reject(error);
      } finally {
        clearTimeout(timeout);
      }
    });
  await Promise.all([
    resolveSessionProposal,
    new Promise<void>(async (resolve, reject) => {
      // immediately resolve if pairingTopic is provided
      if (connectParams.pairingTopic) return resolve();
      try {
        if (uri) {
          pairingB = await pair(uri);
          if (!pairingA) throw new Error("pairingA is missing");
          expect(pairingB.topic).to.eql(pairingA.topic);
          expect(pairingB.relay).to.eql(pairingA.relay);

          resolve();
        } else {
          reject(new Error("missing uri"));
        }
      } catch (error) {
        reject(error);
      }
    }),
    new Promise<void>(async (resolve, reject) => {
      try {
        if (!sessionA) {
          sessionA = await approval();
        }
        resolve();
      } catch (error) {
        reject(error);
      }
    }),
  ]);
  const settlePairingLatencyMs = Date.now() - start - (params?.qrCodeScanLatencyMs || 0);

  if (!sessionA) throw new Error("expect session A to be defined");
  if (!sessionB) throw new Error("expect session B to be defined");

  // topic
  expect(sessionA.topic).to.eql(sessionB.topic);
  // relay
  expect(sessionA.relay).to.eql(TEST_RELAY_OPTIONS);
  expect(sessionA.relay).to.eql(sessionB.relay);
  // namespaces
  expect(sessionA.namespaces).to.eql(approveParams.namespaces);
  expect(sessionA.namespaces).to.eql(sessionB.namespaces);
  expect(sessionA.sessionProperties).to.eql(TEST_SESSION_PROPERTIES_APPROVE);
  // testing expiry is not reliable as on slow networks we take longer to settle
  // expect(Math.abs(sessionA.expiry - sessionB.expiry)).to.be.lessThanOrEqual(5);
  // participants
  expect(sessionA.self).to.eql(sessionB.peer);
  expect(sessionA.peer).to.eql(sessionB.self);
  // controller
  expect(sessionA.controller).to.eql(sessionB.controller);
  expect(sessionA.controller).to.eql(sessionA.peer.publicKey);
  expect(sessionB.controller).to.eql(sessionB.self.publicKey);
  // metadata
  expect(sessionA.self.metadata).to.eql(sessionB.peer.metadata);
  expect(sessionB.self.metadata).to.eql(sessionA.peer.metadata);

  if (!pairingA) throw new Error("expect pairing A to be defined");
  if (!pairingB) throw new Error("expect pairing B to be defined");

  // update pairing state beforehand
  pairingA = A.pairing.get(pairingA.topic);
  pairingB = B.pairing.get(pairingB.topic);

  // topic
  expect(pairingA.topic).to.eql(pairingB.topic);
  // relay
  expect(pairingA.relay).to.eql(TEST_RELAY_OPTIONS);
  expect(pairingA.relay).to.eql(pairingB.relay);
  // active
  expect(pairingA.active).to.eql(true);
  expect(pairingA.active).to.eql(pairingB.active);
  // metadata
  expect(pairingA.peerMetadata).to.eql(sessionA.peer.metadata);
  expect(pairingB.peerMetadata).to.eql(sessionB.peer.metadata);
  await throttle(200); // allow for relay to update
  return { pairingA, sessionA, clientAConnectLatencyMs, settlePairingLatencyMs };
}

export function batchArray(array: any[], size: number) {
  const result: any[] = [];
  for (let i = 0; i < array.length; i += size) {
    const batch: any = array.slice(i, i + size);
    result.push(batch);
  }
  return result;
}
</file>

<file path="packages/sign-client/test/shared/helpers.ts">
import SignClient from "../../src";
import { disconnectSocket } from "./ws";

export async function deleteClients(clients: {
  A: SignClient | undefined;
  B: SignClient | undefined;
}) {
  for (const client of [clients.A, clients.B]) {
    if (!client) continue;
    client.core.events.removeAllListeners();
    client.core.relayer.events.removeAllListeners();
    client.core.heartbeat.stop();
    client.core.relayer?.provider?.events?.removeAllListeners();
    client.core.relayer.subscriber.events.removeAllListeners();
    client.core.relayer?.provider?.connection?.events?.removeAllListeners();
    client.events.removeAllListeners();
    await disconnectSocket(client.core);
  }
  delete clients.A;
  delete clients.B;
}

export async function throttle(timeout: number) {
  return await new Promise<void>((resolve) =>
    setTimeout(() => {
      resolve();
    }, timeout),
  );
}
</file>

<file path="packages/sign-client/test/shared/index.ts">
export * from "./connect";
export * from "./init";
export * from "./values";
export * from "./helpers";
export * from "./metrics";
export * from "./status";
export * from "./ws";
</file>

<file path="packages/sign-client/test/shared/init.ts">
/* eslint-disable no-console */
import { PairingTypes, SessionTypes, SignClientTypes } from "@walletconnect/types";
import { createExpiringPromise } from "@walletconnect/utils";
import { testConnectMethod, TestConnectParams } from ".";
import SignClient from "../../src";
import { deleteClients, throttle } from "./helpers";
import {
  TESTS_CONNECT_RETRIES,
  TESTS_CONNECT_TIMEOUT,
  TEST_SIGN_CLIENT_OPTIONS_A,
  TEST_SIGN_CLIENT_OPTIONS_B,
} from "./values";

export interface Clients {
  A: SignClient;
  B: SignClient;
}

export async function initTwoClients(
  clientOptsA: SignClientTypes.Options = {},
  clientOptsB: SignClientTypes.Options = {},
  sharedClientOpts: SignClientTypes.Options = {},
) {
  const A = await SignClient.init({
    name: "A",
    ...TEST_SIGN_CLIENT_OPTIONS_A,
    ...sharedClientOpts,
    ...clientOptsA,
  });

  const B = await SignClient.init({
    name: "B",
    ...TEST_SIGN_CLIENT_OPTIONS_B,
    ...sharedClientOpts,
    ...clientOptsB,
  });
  A.core.relayer.publisher.publishTimeout = 120_000;
  B.core.relayer.publisher.publishTimeout = 120_000;
  return { A, B };
}

export async function initTwoPairedClients(
  clientOptsA: SignClientTypes.Options = {},
  clientOptsB: SignClientTypes.Options = {},
  sharedClientOpts: SignClientTypes.Options = {},
  connectParams?: TestConnectParams,
) {
  let clients: Clients;
  let pairingA;
  let sessionA;
  let retries = 0;
  while (!pairingA) {
    if (retries > TESTS_CONNECT_RETRIES) {
      throw new Error("Could not pair clients");
    }
    try {
      clients = (await createExpiringPromise(
        initTwoClients(clientOptsA, clientOptsB, sharedClientOpts),
        TESTS_CONNECT_TIMEOUT,
      )) as Clients;
      const settled: any = await createExpiringPromise(
        new Promise((resolve, reject) => {
          testConnectMethod(clients, connectParams).then(resolve).catch(reject);
        }),
        TESTS_CONNECT_TIMEOUT * 2,
        "testConnectMethod(clients)",
      );
      pairingA = settled.pairingA;
      sessionA = settled.sessionA;
    } catch (e) {
      console.error("Error initTwoPairedClients, attempts: ", retries, e);
    }
    retries++;
  }

  return { clients, pairingA, sessionA };
}
</file>

<file path="packages/sign-client/test/shared/metrics.ts">
import { CloudWatch, PutMetricDataCommandInput } from "@aws-sdk/client-cloudwatch";

const tag = process.env.TAG || "default";

export const uploadCanaryResultsToCloudWatch = async (
  env: string,
  region: string,
  target: string,
  metricsPrefix: string,
  isTestPassed: boolean,
  testDurationMs: number,
  otherLatencies: object[],
) => {
  const cloudwatch = new CloudWatch({ region: "eu-central-1" });
  const ts = new Date();
  const metrics = [
    {
      MetricName: `${metricsPrefix}.success`,
      Dimensions: [
        {
          Name: "Target",
          Value: target,
        },
        {
          Name: "Region",
          Value: region,
        },
        {
          Name: "Tag",
          Value: tag,
        },
      ],
      Unit: "Count",
      Value: isTestPassed ? 1 : 0,
      Timestamp: ts,
    },
    {
      MetricName: `${metricsPrefix}.failure`,
      Dimensions: [
        {
          Name: "Target",
          Value: target,
        },
        {
          Name: "Region",
          Value: region,
        },
        {
          Name: "Tag",
          Value: tag,
        },
      ],
      Unit: "Count",
      Value: isTestPassed ? 0 : 1,
      Timestamp: ts,
    },
  ];

  if (isTestPassed) {
    metrics.push({
      MetricName: `${metricsPrefix}.latency`,
      Dimensions: [
        {
          Name: "Target",
          Value: target,
        },
        {
          Name: "Region",
          Value: region,
        },
        {
          Name: "Tag",
          Value: tag,
        },
      ],
      Unit: "Milliseconds",
      Value: testDurationMs,
      Timestamp: ts,
    });
  }

  const latencies = otherLatencies.map((metric) => {
    const metricName = Object.keys(metric)[0];
    return {
      MetricName: `${metricsPrefix}.${metricName}`,
      Dimensions: [
        {
          Name: "Target",
          Value: target,
        },
        {
          Name: "Region",
          Value: region,
        },
        {
          Name: "Tag",
          Value: tag,
        },
      ],
      Unit: "Milliseconds",
      Value: metric[metricName],
      Timestamp: ts,
    };
  });

  const params: PutMetricDataCommandInput = {
    MetricData: [...metrics, ...latencies],
    Namespace: `${env}_Canary_SignClient`,
  };

  await new Promise<void>((resolve) => {
    cloudwatch.putMetricData(params, function (err: Error) {
      if (err) {
        console.error("Failed to upload metrics to CloudWatch", err, err.stack);
        // Swallow error as
        // Test shouldn't fail despite CW failing
        // we will report on missing metrics
      }
      resolve();
    });
  });
};

export const uploadLoadTestConnectionDataToCloudWatch = async (
  env: string,
  target: string,
  metricsPrefix: string,
  successfullyConnected: number,
  failedToConnect: number,
  averagePairingTimeMs: number,
  averageHandshakeTimeMs: number,
) => {
  const cloudwatch = new CloudWatch({ region: "eu-central-1" });
  const ts = new Date();

  const params: PutMetricDataCommandInput = {
    MetricData: [
      {
        MetricName: `${metricsPrefix}.connect.successful`,
        Dimensions: [
          {
            Name: "Target",
            Value: target,
          },
          {
            Name: "Tag",
            Value: tag,
          },
        ],
        Unit: "Count",
        Value: successfullyConnected,
        Timestamp: ts,
      },
      {
        MetricName: `${metricsPrefix}.connect.failed`,
        Dimensions: [
          {
            Name: "Target",
            Value: target,
          },
          {
            Name: "Tag",
            Value: tag,
          },
        ],
        Unit: "Count",
        Value: failedToConnect,
        Timestamp: ts,
      },
      {
        MetricName: `${metricsPrefix}.latency`,
        Dimensions: [
          {
            Name: "Target",
            Value: target,
          },
          {
            Name: "Tag",
            Value: tag,
          },
        ],
        Unit: "Milliseconds",
        Value: averagePairingTimeMs,
        Timestamp: ts,
      },
      {
        MetricName: `${metricsPrefix}.handshake.latency`,
        Dimensions: [
          {
            Name: "Target",
            Value: target,
          },
          {
            Name: "Tag",
            Value: tag,
          },
        ],
        Unit: "Milliseconds",
        Value: averageHandshakeTimeMs,
        Timestamp: ts,
      },
    ],
    Namespace: `${env}_LoadTest_SignClient`,
  };

  await new Promise<void>((resolve) => {
    cloudwatch.putMetricData(params, function (err: Error) {
      if (err) {
        console.warn("Failed to upload metrics to CloudWatch", err, err.stack);
        // Swallow error as
        // Test shouldn't fail despite CW failing
        // we will report on missing metrics
      } else {
        console.log("Successfully uploaded metrics to CloudWatch");
      }
      resolve();
    });
  });
};
</file>

<file path="packages/sign-client/test/shared/status.ts">
import https from "https";

const apiKey = process.env.STATUSPAGE_API_KEY;
const pageId = "0z72kp3p7j8h";
const latencyMetricId = "dzjbt55mfxks";
const apiBase = "https://api.statuspage.io/v1";

const url = apiBase + "/pages/" + pageId + "/metrics/data";
const headers = { Authorization: "OAuth " + apiKey, "Content-Type": "application/json" };
const options = { method: "POST", headers: headers };

export const publishToStatusPage = (latencyMs: number) => {
  const timestampEpichSeconds = new Date().getTime() / 1000;
  const data = { data: {} };
  data.data[latencyMetricId] = [{ timestamp: timestampEpichSeconds, value: latencyMs / 1000 }];

  return new Promise((resolve, reject) => {
    const request = https.request(url, options, function (res) {
      if (res.statusMessage === "Unauthorized") {
        return reject(new Error("Statuspage Call Unauthorized"));
      }
      res.setEncoding("utf8");
      const responseParts: string[] = [];
      res.on("end", function () {
        const response = responseParts.join("");
        if (res.statusCode! >= 500) {
          console.log(
            `Call to Statuspage failed with status code ${res.statusCode} and response ${response}`,
          );
          return resolve(false);
        }
        if (res.statusCode! >= 300) {
          return reject(
            new Error(
              `Call to Statuspage failed with status code ${res.statusCode} and response ${response}`,
            ),
          );
        }
        return resolve(true);
      });
      res.on("data", function (data: string) {
        responseParts.push(data);
      });
      res.on("error", (error) => {
        return reject(error);
      });
    });
    request.end(JSON.stringify(data));
  });
};
</file>

<file path="packages/sign-client/test/shared/values.ts">
import { RelayerTypes, SignClientTypes } from "@walletconnect/types";

export const PACKAGE_NAME = "sign-client";

export const TEST_RELAY_URL = process.env.TEST_RELAY_URL
  ? process.env.TEST_RELAY_URL
  : "ws://0.0.0.0:5555";

export const TEST_RELAY_URL_US = "wss://us-east-1.relay.walletconnect.com";
export const TEST_RELAY_URL_EU = "wss://eu-central-1.relay.walletconnect.com";
export const TEST_RELAY_URL_AP = "wss://ap-southeast-1.relay.walletconnect.com";

// See https://github.com/WalletConnect/push-webhook-test-server
export const TEST_WEBHOOK_ENDPOINT = "https://webhook-push-test.walletconnect.com/";
export const TEST_WEBHOOK_DELAY_MS = process.env.TEST_WEBHOOK_DELAY_MS
  ? process.env.TEST_WEBHOOK_DELAY_MS
  : 1000;

export const TEST_PROJECT_ID = process.env.TEST_PROJECT_ID
  ? process.env.TEST_PROJECT_ID
  : undefined;

export const TEST_SIGN_CLIENT_OPTIONS: SignClientTypes.Options = {
  logger: "warn",
  relayUrl: TEST_RELAY_URL,
  projectId: TEST_PROJECT_ID,
  storageOptions: {
    database: ":memory:",
  },
  metadata: {
    redirect: {
      universal: "App A (Proposer)",
    },
    name: "App A (Proposer)",
    description: "Description of Proposer App run by client A",
    url: "https://walletconnect.com",
    icons: ["https://avatars.githubusercontent.com/u/37784886"],
  },
};

export const TEST_SIGN_CLIENT_OPTIONS_USA: SignClientTypes.Options = {
  logger: "error",
  relayUrl: TEST_RELAY_URL_US,
  projectId: TEST_PROJECT_ID,
  storageOptions: {
    database: ":memory:",
  },
};

export const TEST_SIGN_CLIENT_OPTIONS_EU: SignClientTypes.Options = {
  logger: "error",
  relayUrl: TEST_RELAY_URL_EU,
  projectId: TEST_PROJECT_ID,
  storageOptions: {
    database: ":memory:",
  },
};

export const TEST_SIGN_CLIENT_OPTIONS_AP: SignClientTypes.Options = {
  logger: "error",
  relayUrl: TEST_RELAY_URL_AP,
  projectId: TEST_PROJECT_ID,
  storageOptions: {
    database: ":memory:",
  },
};

export const TEST_SIGN_CLIENT_NAME_A = "client_a";
export const TEST_APP_METADATA_A: SignClientTypes.Metadata = {
  name: "App A (Proposer)",
  description: "Description of Proposer App run by client A",
  url: "https://app.a.walletconnect.com",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
  redirect: {
    universal: "App A (Proposer)",
    native: "App A Native (Proposer)",
  },
};

export const TEST_SIGN_CLIENT_NAME_B = "client_b";
export const TEST_APP_METADATA_B: SignClientTypes.Metadata = {
  name: "App B (Responder)",
  description: "Description of Responder App run by client B",
  url: "https://app.b.walletconnect.com",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
  redirect: {
    universal: "App B (Responder)",
    native: "App B Native (Responder)",
  },
};

export const TEST_RELAY_PROTOCOL = "irn";
export const TEST_RELAY_OPTIONS: RelayerTypes.ProtocolOptions = {
  protocol: TEST_RELAY_PROTOCOL,
};

export const TEST_SIGN_CLIENT_OPTIONS_A = {
  ...TEST_SIGN_CLIENT_OPTIONS,
  name: TEST_SIGN_CLIENT_NAME_A,
  metadata: TEST_APP_METADATA_A,
};

export const TEST_SIGN_CLIENT_OPTIONS_B = {
  ...TEST_SIGN_CLIENT_OPTIONS,
  name: TEST_SIGN_CLIENT_NAME_B,
  metadata: TEST_APP_METADATA_B,
};

export const TEST_ETHEREUM_CHAIN = "eip155:1";
export const TEST_ARBITRUM_CHAIN = "eip155:42161";
export const TEST_AVALANCHE_CHAIN = "eip155:43114";
export const TEST_POLKADOT_CHAIN = "polkadot:91b171bb158e2d3848fa23a9f1c25182";

export const TEST_CHAINS = [TEST_ETHEREUM_CHAIN, TEST_ARBITRUM_CHAIN];
export const TEST_METHODS = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "personal_sign",
  "eth_signTypedData",
];
export const TEST_POLKADOT_METHODS = ["polkadot_signTransaction", "polkadot_signMessage"];
export const TEST_EVENTS = ["chainChanged", "accountsChanged"];

export const TEST_ETHEREUM_ADDRESS = "0x3c582121909DE92Dc89A36898633C1aE4790382b";
export const TEST_POLKADOT_ADDRESS = "8cGfbK9Q4zbsNzhZsZUtpsQgX5LG2UCPEDuXYV33whktGt7";
export const TEST_ETHEREUM_ACCOUNT = `${TEST_ETHEREUM_CHAIN}:${TEST_ETHEREUM_ADDRESS}`;
export const TEST_ARBITRUM_ACCOUNT = `${TEST_ARBITRUM_CHAIN}:${TEST_ETHEREUM_ADDRESS}`;
export const TEST_AVALANCHE_ACCOUNT = `${TEST_AVALANCHE_CHAIN}:${TEST_ETHEREUM_ADDRESS}`;
export const TEST_POLKADOT_ACCOUNT = `${TEST_POLKADOT_CHAIN}:${TEST_POLKADOT_ADDRESS}`;

export const TEST_ACCOUNTS = [TEST_ETHEREUM_ACCOUNT, TEST_ARBITRUM_ACCOUNT];

export const TEST_POLKADOT_CHAINS = ["polkadot:91b171bb158e2d3848fa23a9f1c25182"];
export const TEST_POLKADOT_ACCOUNTS = [TEST_POLKADOT_ACCOUNT];

export const TEST_REQUIRED_NAMESPACES = {
  eip155: {
    methods: TEST_METHODS,
    chains: TEST_CHAINS,
    events: TEST_EVENTS,
  },
};

export const TEST_REQUIRED_NAMESPACES_V2 = {
  eip155: {
    methods: TEST_METHODS,
    chains: TEST_CHAINS,
    events: TEST_EVENTS,
  },
  [TEST_AVALANCHE_CHAIN]: {
    methods: TEST_METHODS,
    events: TEST_EVENTS,
  },
};

export const TEST_OPTIONAL_NAMESPACES = {
  polkadot: {
    methods: TEST_POLKADOT_METHODS,
    chains: TEST_POLKADOT_CHAINS,
    events: TEST_EVENTS,
  },
};

export const TEST_NAMESPACES = {
  eip155: {
    chains: TEST_CHAINS,
    methods: TEST_METHODS,
    accounts: TEST_ACCOUNTS,
    events: TEST_EVENTS,
  },
  polkadot: {
    chains: TEST_POLKADOT_CHAINS,
    methods: TEST_POLKADOT_METHODS,
    accounts: TEST_POLKADOT_ACCOUNTS,
    events: TEST_EVENTS,
  },
};

export const TEST_NAMESPACES_V2 = {
  eip155: {
    methods: TEST_METHODS,
    accounts: [TEST_ETHEREUM_ACCOUNT, TEST_AVALANCHE_ACCOUNT, TEST_ARBITRUM_ACCOUNT],
    events: TEST_EVENTS,
  },
};

export const TEST_SESSION_PROPERTIES = {
  expiry: "2022-12-24T17:07:31+00:00",
  "caip154-mandatory": "true",
};

export const TEST_SESSION_PROPERTIES_APPROVE = {
  expiry: "2022-12-24T17:07:31+00:00",
};

export const TEST_NAMESPACES_INVALID_METHODS = {
  eip155: { ...TEST_NAMESPACES.eip155, methods: ["eth_invalid"] },
};
export const TEST_NAMESPACES_INVALID_CHAIN = { eip1111: { ...TEST_NAMESPACES.eip155 } };

export const TEST_MESSAGE = "My name is John Doe";
export const TEST_SIGNATURE =
  "0xc8906b32c9f74d0805226ffff5ecd6897ea55cdf58f54a53a2e5b5d5a21fb67f43ef1d4c2ed790a724a1549b4cc40137403048c4aed9825cfd5ba6c1d15bd0721c";

export const TEST_SIGN_METHOD = "personal_sign";
export const TEST_SIGN_PARAMS = [TEST_MESSAGE, TEST_ETHEREUM_ADDRESS];
export const TEST_SIGN_REQUEST = { method: TEST_SIGN_METHOD, params: TEST_SIGN_PARAMS };

export const TEST_RANDOM_REQUEST = { method: "random_method", params: [] };

export const TEST_CONNECT_PARAMS = {
  requiredNamespaces: TEST_REQUIRED_NAMESPACES,
  relays: [TEST_RELAY_OPTIONS],
};

export const TEST_APPROVE_PARAMS = {
  id: 123,
  namespaces: TEST_NAMESPACES,
};

export const TEST_REJECT_PARAMS = {
  id: 123,
  reason: {
    code: 0,
    message: "GENERIC",
  },
};

export const TEST_UPDATE_PARAMS = {
  namespaces: TEST_NAMESPACES,
};

export const TEST_REQUEST_PARAMS = {
  request: { method: TEST_METHODS[0], params: [] },
  chainId: TEST_CHAINS[0],
};

export const TEST_REQUEST_PARAMS_OPTIONAL_NAMESPACE = {
  request: { method: TEST_POLKADOT_METHODS[0], params: [] },
  chainId: TEST_POLKADOT_CHAIN,
};

export const TEST_RESPOND_PARAMS = {
  response: {
    id: 1,
    jsonrpc: "2.0",
    result: {},
  },
};

export const TEST_EMIT_PARAMS = {
  event: { name: TEST_EVENTS[0], data: "" },
  chainId: TEST_CHAINS[0],
};

type RelayerType = {
  value: string;
  label: string;
};

export const TEST_SIGN_REQUEST_PARAMS = {
  method: "eth_signTransaction",
  params: [
    {
      from: TEST_ETHEREUM_ACCOUNT,
      to: TEST_ETHEREUM_ACCOUNT,
      data: "0x",
      nonce: "0x01",
      gasPrice: "0x020a7ac094",
      gasLimit: "0x5208",
      value: "0x00",
    },
  ],
};

export const TESTS_CONNECT_RETRIES = 5;
export const TESTS_CONNECT_TIMEOUT = 60_000;

export const TEST_EMPTY_METADATA: SignClientTypes.Metadata = {
  name: "",
  description: "",
  url: "",
  icons: [],
};
export const TEST_INVALID_METADATA: SignClientTypes.Metadata = {
  name: "test",
  description: "",
  url: "",
  icons: ["test"],
};

export const TEST_WALLET_METADATA = {
  name: "Test Wallet",
  description: "Test Wallet for WalletConnect",
  url: "https://walletconnect.com/",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
};
</file>

<file path="packages/sign-client/test/shared/ws.ts">
import { ICore } from "@walletconnect/types";

export async function disconnectSocket(core: ICore) {
  if (core.relayer.connected) {
    await core.relayer.transportClose();
  }
}
</file>

<file path="packages/sign-client/test/xregion/xregion.spec.ts">
import { expect, describe, it } from "vitest";
import {
  TEST_RELAY_URL,
  TEST_RELAY_URL_US,
  TEST_RELAY_URL_AP,
  TEST_RELAY_URL_EU,
  TEST_PROJECT_ID,
  throttle,
  deleteClients,
  initTwoPairedClients,
} from "../shared";

describe("X Region", () => {
  describe("pairing+ping", () => {
    it.each(regionEndpointPermutations)(
      "pairs client in '%s' with client in '%s'",
      async (clientAUrl: string, clientBUrl: string) => {
        const { clients, pairingA, sessionA } = await initTwoPairedClients(
          { relayUrl: clientAUrl },
          { relayUrl: clientBUrl },
          { projectId: TEST_PROJECT_ID },
        );
        const { A, B } = clients;
        log(
          `Clients initialized (relay 'A:${A.core.opts?.relayUrl};B:${
            B.core.opts?.relayUrl
          }'), client ids: A:'${await A.core.crypto.getClientId()}';B:'${await B.core.crypto.getClientId()}'`,
        );
        log(
          `Clients connected (relay 'A:${A.core.opts?.relayUrl};B:${
            B.core.opts?.relayUrl
          }', client ids: A:'${await A.core.crypto.getClientId()}';B:'${await B.core.crypto.getClientId()}' pairing topic '${
            pairingA.topic
          }', session topic '${sessionA.topic}')`,
        );
        // Send a ping
        await throttle(500); // Introduce some realistic timeout and allow backend to replicate
        await new Promise<void>(async (resolve, reject) => {
          try {
            B.once("session_ping", (event) => {
              expect(sessionA.topic).to.eql(event.topic);
              resolve();
            });

            await A.ping({ topic: sessionA.topic });
          } catch (e) {
            reject(e);
          }
        });
        await deleteClients({ A, B });
      },
    );
  });
});

const log = (log: string) => {
  // eslint-disable-next-line no-console
  console.log(log);
};

/**
 * Get all unique permutations of provided regions in pairs
 * @param array the regions to permutate
 * @returns
 */
const getRegionEndpointPermutations = (array: string[]) => {
  const regions: string[][] = [];

  const isDev = TEST_RELAY_URL.includes("dev.");
  const isStaging = TEST_RELAY_URL.includes("staging.");

  for (let i = 0; i < array.length; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (i == j) continue;
      const list: string[] = [];

      let from = array[i];
      let to = array[j];

      if (isDev) {
        from = from.replace("wss://", "wss://dev.");
        to = to.replace("wss://", "wss://dev.");
      } else if (isStaging) {
        from = from.replace("wss://", "wss://staging.");
        to = to.replace("wss://", "wss://staging.");
      }

      list.push(from);
      list.push(to);
      regions.push(list);
    }
  }

  return regions;
};

const regionEndpointPermutations = getRegionEndpointPermutations([
  TEST_RELAY_URL_EU,
  TEST_RELAY_URL_US,
  TEST_RELAY_URL_AP,
]);
</file>

<file path="packages/sign-client/.npmignore">
*.log
npm-debug.log*

# Coverage directory used by tools like istanbul
coverage
.nyc_output

# Dependency directories
node_modules

# npm package lock
package-lock.json
yarn.lock

# project files
src
test
CHANGELOG.md
.travis.yml
.editorconfig
.eslintignore
.eslintrc
.babelrc
.gitignore
.watchmanconfig
</file>

<file path="packages/sign-client/CHANGELOG.md">
# @walletconnect/sign-client

## 2.20.0

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.20.0
  - @walletconnect/core@2.20.0
  - @walletconnect/types@2.20.0

## 2.19.4

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.19.4
  - @walletconnect/core@2.19.4
  - @walletconnect/types@2.19.4

## 2.19.3

### Patch Changes

- Updated dependencies []:
  - @walletconnect/utils@2.19.3
  - @walletconnect/core@2.19.3
  - @walletconnect/types@2.19.3
</file>

<file path="packages/sign-client/Dockerfile">
FROM node:21-alpine as base

WORKDIR /

RUN apk --update --no-cache \
    add g++ make python3

FROM base as build

WORKDIR /

COPY ../ ./
RUN npm ci
RUN npm run build

WORKDIR /packages/sign-client/

CMD ["node", "-v"]
</file>

<file path="packages/sign-client/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="packages/sign-client/package.json">
{
  "name": "@walletconnect/sign-client",
  "description": "Sign Client for WalletConnect Protocol",
  "version": "2.20.0",
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
  "license": "Apache-2.0",
  "main": "dist/index.cjs.js",
  "module": "dist/index.es.js",
  "unpkg": "dist/index.umd.js",
  "types": "dist/types/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "keywords": [
    "wallet",
    "walletconnect"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build:pre": "npm run clean",
    "build:types": "tsc",
    "build:source": "rollup --config rollup.config.js",
    "build": "npm run build:pre; npm run build:source; npm run build:types",
    "test:pre": "rm -rf ./test/tmp && mkdir ./test/tmp",
    "test:run": "vitest run --dir test/sdk",
    "test:concurrency": "vitest run --dir test/concurrency",
    "test:xregion": "vitest run --dir test/xregion -- --dangerouslyIgnoreUnhandledErrors --segfault-retry=3",
    "test": "npm run test:pre; npm run test:run",
    "test:integration": "vitest run --dir test/sdk/integration",
    "test:ignoreUnhandled": "npm run test:pre; npm run test:integration -- --dangerouslyIgnoreUnhandledErrors --segfault-retry=3",
    "test:canary": "vitest run --dir test/canary",
    "test:lifecycle": "vitest run --dir test/lifecycle -- --dangerouslyIgnoreUnhandledErrors --segfault-retry=3",
    "canary": "npm run test:pre; npm run test:canary",
    "loadtest": "npm run test:pre; npm run test:concurrency",
    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
    "prettier": "prettier --check '{src,test}/**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@walletconnect/core": "2.20.0",
    "@walletconnect/events": "1.0.1",
    "@walletconnect/heartbeat": "1.2.2",
    "@walletconnect/jsonrpc-utils": "1.0.8",
    "@walletconnect/logger": "2.1.2",
    "@walletconnect/time": "1.0.2",
    "@walletconnect/types": "2.20.0",
    "@walletconnect/utils": "2.20.0",
    "events": "3.3.0"
  },
  "devDependencies": {
    "@aws-sdk/client-cloudwatch": "3.450.0"
  }
}
</file>

<file path="packages/sign-client/README.md">
# @walletconnect/sign-client

Sign Client for WalletConnect Protocol

## Description

This library provides a Sign Client for WalletConnect v2.0 Protocol for both Dapps and Wallets. Integration will differ from the perspective of each client as the Proposer and Responder, respectively. It's compatible with NodeJS, Browser and React-Native applications (NodeJS modules required to be polyfilled for React-Native)

## Documentation

Check out documentation [here](https://docs.walletconnect.com/).

Also available quick start for [Dapps](https://docs.reown.com/api/sign/dapp-usage) and for [Wallets](https://docs.reown.com/api/sign/wallet-usage)

## License

Apache 2.0
</file>

<file path="packages/sign-client/rollup.config.js">
import { name, dependencies } from "./package.json";
import createConfig from "../../rollup.config";

export default createConfig(name, Object.keys(dependencies));
</file>

<file path="packages/sign-client/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["./src/**/*"],
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "./dist/types",
    "emitDeclarationOnly": true
  }
}
</file>

<file path="packages/types/src/core/core.ts">
import { IEvents } from "@walletconnect/events";
import { IHeartBeat } from "@walletconnect/heartbeat";
import { IKeyValueStorage, KeyValueStorageOptions } from "@walletconnect/keyvaluestorage";

import { ICrypto } from "./crypto";
import { IRelayer } from "./relayer";
import { IKeyChain } from "./keychain";
import { IJsonRpcHistory } from "./history";
import { IExpirer } from "./expirer";
import { IPairing } from "./pairing";
import { Logger } from "@walletconnect/logger";
import { IVerify } from "./verify";
import { IEchoClient } from "./echo";
import { IEventClient } from "./events";
export declare namespace CoreTypes {
  interface Options {
    projectId?: string;
    name?: string;
    relayUrl?: string;
    logger?: string | Logger;
    keychain?: IKeyChain;
    storage?: IKeyValueStorage;
    storageOptions?: KeyValueStorageOptions;
    maxLogBlobSizeInBytes?: number;
    customStoragePrefix?: string;
    telemetryEnabled?: boolean;
  }

  interface Metadata {
    name: string;
    description: string;
    url: string;
    icons: string[];
    verifyUrl?: string;
    redirect?: {
      native?: string;
      universal?: string;
      linkMode?: boolean;
    };
  }
}

export abstract class ICore extends IEvents {
  public readonly protocol = "wc";
  public readonly version = 2;

  public abstract readonly name: string;
  public abstract readonly context: string;
  public abstract readonly relayUrl?: string;
  public abstract readonly projectId?: string;
  public abstract readonly customStoragePrefix: string;

  public abstract logger: Logger;
  public abstract heartbeat: IHeartBeat;
  public abstract crypto: ICrypto;
  public abstract relayer: IRelayer;
  public abstract storage: IKeyValueStorage;
  public abstract history: IJsonRpcHistory;
  public abstract expirer: IExpirer;
  public abstract pairing: IPairing;
  public abstract verify: IVerify;
  public abstract echoClient: IEchoClient;
  public abstract linkModeSupportedApps: string[];
  public abstract eventClient: IEventClient;

  constructor(public opts?: CoreTypes.Options) {
    super();
  }

  public abstract start(): Promise<void>;
  public abstract dispatchEnvelope(params: {
    topic: string;
    message: string;
    sessionExists: boolean;
  }): void;

  public abstract addLinkModeSupportedApp(universalLink: string): void;
}
</file>

<file path="packages/types/src/core/crypto.ts">
import { JsonRpcPayload } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";
import { IKeyChain } from "./keychain";

export declare namespace CryptoTypes {
  export type EncodingType = "base64pad" | "base64url";

  export interface Participant {
    publicKey: string;
  }

  export interface KeyPair {
    privateKey: string;
    publicKey: string;
  }

  export interface EncryptParams {
    message: string;
    symKey: string;
    type?: number;
    iv?: string;
    senderPublicKey?: string;
    encoding?: EncodingType;
  }

  export interface DecryptParams {
    symKey: string;
    encoded: string;
    encoding?: EncodingType;
  }

  export interface EncodingParams {
    type: Uint8Array;
    sealed: Uint8Array;
    iv: Uint8Array;
    senderPublicKey?: Uint8Array;
    encoding?: EncodingType;
  }

  export interface DecodingParams {
    encoded: string;
    encoding?: EncodingType;
  }

  export interface EncodeOptions {
    type?: number;
    senderPublicKey?: string;
    receiverPublicKey?: string;
    encoding?: EncodingType;
  }

  export interface DecodeOptions {
    receiverPublicKey?: string;
    encoding?: EncodingType;
  }

  export interface EncodingValidation {
    type: number;
    senderPublicKey?: string;
    receiverPublicKey?: string;
  }

  export interface TypeOneParams {
    type: 1;
    senderPublicKey: string;
    receiverPublicKey: string;
  }
}

export abstract class ICrypto {
  public abstract name: string;

  public abstract readonly context: string;

  public abstract keychain: IKeyChain;

  public abstract readonly randomSessionIdentifier: string;

  constructor(
    public core: ICore,
    public logger: Logger,
    // @ts-ignore
    keychain?: IKeyChain,
  ) {}

  public abstract init(): Promise<void>;

  public abstract hasKeys(tag: string): boolean;

  public abstract getClientId(): Promise<string>;

  public abstract generateKeyPair(): Promise<string>;

  public abstract generateSharedKey(
    selfPublicKey: string,
    peerPublicKey: string,
    overrideTopic?: string,
  ): Promise<string>;

  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;

  public abstract deleteKeyPair(publicKey: string): Promise<void>;

  public abstract deleteSymKey(topic: string): Promise<void>;

  public abstract encode(
    topic: string,
    payload: JsonRpcPayload,
    opts?: CryptoTypes.EncodeOptions,
  ): Promise<string>;

  public abstract decode(
    topic: string,
    encoded: string,
    opts?: CryptoTypes.DecodeOptions,
  ): Promise<JsonRpcPayload>;

  public abstract signJWT(aud: string): Promise<string>;
  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;
  public abstract getPayloadSenderPublicKey(
    encoded: string,
    encoding?: CryptoTypes.EncodingType,
  ): string | undefined;
}
</file>

<file path="packages/types/src/core/echo.ts">
import { Logger } from "@walletconnect/logger";

export declare namespace EchoClientTypes {
  type RegisterDeviceTokenParams = {
    clientId: string;
    token: string;
    notificationType: "fcm" | "apns" | "apns-sandbox" | "noop";
    enableEncrypted?: boolean;
  };
}
export abstract class IEchoClient {
  public abstract readonly context: string;
  constructor(
    public projectId: string,
    public logger: Logger,
  ) {}

  public abstract registerDeviceToken(
    params: EchoClientTypes.RegisterDeviceTokenParams,
  ): Promise<void>;
}
</file>

<file path="packages/types/src/core/events.ts">
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export declare namespace EventClientTypes {
  export interface Event {
    eventId: string;
    bundleId: string;
    timestamp: number;
    props: Props;
    addTrace: (trace: string) => void;
    setError: (error: string) => void;
  }

  export interface Props {
    event: string;
    type: string;
    properties: Properties;
  }

  export interface Properties {
    topic: string;
    trace: Trace;
  }

  export type Trace = string[];
}

export abstract class IEventClient {
  public abstract readonly context: string;

  constructor(
    public core: ICore,
    public logger: Logger,
    public telemetryEnabled: boolean,
  ) {}

  public abstract init(): Promise<void>;

  public abstract createEvent(params: {
    event?: "ERROR";
    type?: string;
    properties: {
      topic: string;
      trace: EventClientTypes.Trace;
    };
  }): EventClientTypes.Event;

  public abstract getEvent(params: {
    eventId?: string;
    topic?: string;
  }): EventClientTypes.Event | undefined;

  public abstract deleteEvent(params: { eventId: string }): void;
}
</file>

<file path="packages/types/src/core/expirer.ts">
import { IEvents } from "@walletconnect/events";
import { Logger } from "@walletconnect/logger";

import { ICore } from "./core";

export declare namespace ExpirerTypes {
  interface Expiration {
    target: string;
    expiry: number;
  }

  interface Created {
    target: string;
    expiration: Expiration;
  }

  interface Deleted {
    target: string;
    expiration: Expiration;
  }

  interface Expired {
    target: string;
    expiration: Expiration;
  }
}

export abstract class IExpirer extends IEvents {
  public abstract name: string;

  public abstract readonly context: string;

  public abstract readonly length: number;

  public abstract readonly keys: string[];

  public abstract readonly values: ExpirerTypes.Expiration[];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract has(key: string | number): boolean;

  public abstract set(key: string | number, expiry: number): void;

  public abstract get(key: string | number): ExpirerTypes.Expiration;

  public abstract del(key: string | number): void;
}
</file>

<file path="packages/types/src/core/history.ts">
import { IEvents } from "@walletconnect/events";
import {
  ErrorResponse,
  JsonRpcRequest,
  JsonRpcResponse,
  RequestArguments,
} from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";

import { ICore } from "./core";

export interface JsonRpcRecord {
  id: number;
  topic: string;
  request: RequestArguments;
  chainId?: string;
  response?: { result: any } | { error: ErrorResponse };
  expiry?: number;
}

export interface RequestEvent {
  topic: string;
  request: JsonRpcRequest;
  chainId?: string;
}

export abstract class IJsonRpcHistory extends IEvents {
  public records = new Map<number, JsonRpcRecord>();

  public abstract readonly context: string;

  public abstract readonly size: number;

  public abstract readonly keys: number[];

  public abstract readonly values: JsonRpcRecord[];

  public abstract readonly pending: RequestEvent[];

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;

  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;

  public abstract resolve(response: JsonRpcResponse): Promise<void>;

  public abstract delete(topic: string, id?: number): void;

  public abstract exists(topic: string, id: number): Promise<boolean>;
}
</file>

<file path="packages/types/src/core/index.ts">
export * from "./core";
export * from "./crypto";
export * from "./history";
export * from "./messages";
export * from "./publisher";
export * from "./relayer";
export * from "./store";
export * from "./subscriber";
export * from "./keychain";
export * from "./expirer";
export * from "./pairing";
export * from "./verify";
export * from "./echo";
export * from "./events";
</file>

<file path="packages/types/src/core/keychain.ts">
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export abstract class IKeyChain {
  public abstract keychain: Map<string, string>;

  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public core: ICore,
    public logger: Logger,
  ) {}

  public abstract init(): Promise<void>;

  public abstract has(tag: string, opts?: any): boolean;

  public abstract set(tag: string, key: string, opts?: any): Promise<void>;

  public abstract get(tag: string, opts?: any): string;

  public abstract del(tag: string, opts?: any): Promise<void>;
}
</file>

<file path="packages/types/src/core/messages.ts">
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export type MessageRecord = Record<string, string>;

export abstract class IMessageTracker {
  public abstract messages: Map<string, MessageRecord>;
  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;

  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public logger: Logger,
    public core: ICore,
  ) {}

  public abstract init(): Promise<void>;

  public abstract set(
    topic: string,
    message: string,
    direction?: "inbound" | "outbound",
  ): Promise<string>;

  public abstract get(topic: string): MessageRecord;

  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;

  public abstract has(topic: string, message: string): boolean;

  public abstract del(topic: string): Promise<void>;

  public abstract ack(topic: string, message: string): Promise<void>;
}
</file>

<file path="packages/types/src/core/pairing.ts">
import {
  ErrorResponse,
  JsonRpcRequest,
  JsonRpcResponse,
  JsonRpcResult,
  JsonRpcError,
} from "@walletconnect/jsonrpc-types";
import EventEmitter from "events";

import { ICore, CoreTypes } from "./core";
import { IStore } from "./store";

import { RelayerTypes } from "../core/relayer";
import { Logger } from "@walletconnect/logger";

export declare namespace PairingTypes {
  interface Struct {
    topic: string;
    expiry: number;
    relay: RelayerTypes.ProtocolOptions;
    active: boolean;
    peerMetadata?: CoreTypes.Metadata;
    methods?: string[];
  }
}

export declare namespace PairingJsonRpcTypes {
  // -- core ------------------------------------------------------- //
  type DefaultResponse = true | ErrorResponse;

  type WcMethod = "wc_pairingDelete" | "wc_pairingPing";

  type Error = ErrorResponse;

  // -- requests --------------------------------------------------- //

  interface RequestParams {
    wc_pairingDelete: {
      code: number;
      message: string;
    };
    wc_pairingPing: Record<string, unknown>;
  }

  // -- responses -------------------------------------------------- //
  interface Results {
    wc_pairingDelete: true;
    wc_pairingPing: true;
  }

  // -- events ----------------------------------------------------- //
  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
    topic: string;
    payload: T;
  }
}

export type IPairingStore = IStore<string, PairingTypes.Struct>;

export abstract class IPairing {
  public abstract name: string;
  public abstract readonly context: string;
  public abstract events: EventEmitter;
  public abstract pairings: IPairingStore;

  constructor(
    public logger: Logger,
    public core: ICore,
  ) {}

  public abstract init(): Promise<void>;

  public abstract pair(params: {
    uri: string;
    activatePairing?: boolean;
  }): Promise<PairingTypes.Struct>;

  // for proposer to create inactive pairing
  public abstract create(params?: {
    methods?: string[];
    transportType?: RelayerTypes.SubscribeOptions["transportType"];
  }): Promise<{ topic: string; uri: string }>;

  // for either to activate a previously created pairing
  public abstract activate(params: { topic: string }): Promise<void>;

  // for both to subscribe on methods requests
  public abstract register(params: { methods: string[] }): void;

  // for either to update the expiry of an existing pairing.
  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;

  // for either to update the metadata of an existing pairing.
  public abstract updateMetadata(params: {
    topic: string;
    metadata: CoreTypes.Metadata;
  }): Promise<void>;

  // query pairings
  public abstract getPairings(): PairingTypes.Struct[];

  // for either to ping a peer
  public abstract ping(params: { topic: string }): Promise<void>;

  // for either peer to disconnect a pairing
  public abstract disconnect(params: { topic: string }): Promise<void>;

  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;
}

export interface IPairingPrivate {
  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(
    topic: string,
    method: M,
    params: PairingJsonRpcTypes.RequestParams[M],
  ): Promise<number>;

  sendResult<M extends PairingJsonRpcTypes.WcMethod>(
    id: number,
    topic: string,
    result: PairingJsonRpcTypes.Results[M],
  ): Promise<void>;

  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;

  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;

  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;

  onPairingPingRequest(
    topic: string,
    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams["wc_pairingPing"]>,
  ): Promise<void>;

  onPairingPingResponse(
    topic: string,
    payload: JsonRpcResult<PairingJsonRpcTypes.Results["wc_pairingPing"]> | JsonRpcError,
  ): void;

  onPairingDeleteRequest(
    topic: string,
    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams["wc_pairingDelete"]>,
  ): Promise<void>;

  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;

  onUnknownRpcMethodResponse(method: string): void;

  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;
}
</file>

<file path="packages/types/src/core/publisher.ts">
import { IEvents } from "@walletconnect/events";
import { Logger } from "@walletconnect/logger";

import { IRelayer, RelayerTypes } from "./relayer";

export declare namespace PublisherTypes {
  export interface Params {
    topic: string;
    message: string;
    opts: Omit<RelayerTypes.PublishOptions, "internal">;
  }
}

export abstract class IPublisher extends IEvents {
  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super();
  }

  public abstract publish(
    topic: string,
    message: string,
    opts?: RelayerTypes.PublishOptions,
  ): Promise<void>;
}
</file>

<file path="packages/types/src/core/relayer.ts">
import { IEvents } from "@walletconnect/events";
import { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";

import { ICore } from "./core";
import { IMessageTracker } from "./messages";
import { IPublisher } from "./publisher";
import { ISubscriber } from "./subscriber";

export declare namespace RelayerTypes {
  export interface ProtocolOptions {
    protocol: string;
    data?: string;
  }
  export interface PublishOptions {
    relay?: ProtocolOptions;
    ttl?: number;
    prompt?: boolean;
    tag?: number;
    id?: number;
    internal?: {
      throwOnFailedPublish?: boolean;
    };
    tvf?: ITVF;
    attestation?: string;
  }

  export type TransportType = "relay" | "link_mode";

  export interface SubscribeOptions {
    relay?: ProtocolOptions;
    transportType?: TransportType;
    internal?: {
      throwOnFailedPublish?: boolean;
    };
  }

  export interface UnsubscribeOptions {
    id?: string;
    relay: ProtocolOptions;
  }

  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;

  export interface PublishPayload {
    topic: string;
    message: string;
    opts?: RelayerTypes.PublishOptions;
  }
  export interface MessageEvent {
    topic: string;
    message: string;
    publishedAt: number;
    transportType?: TransportType;
    attestation?: string;
  }

  export interface RpcUrlParams {
    protocol: string;
    version: number;
    auth: string;
    relayUrl: string;
    sdkVersion: string;
    projectId?: string;
    useOnCloseEvent?: boolean;
    bundleId?: string;
    packageName?: string;
  }

  export interface ITVF {
    correlationId?: number;
    rpcMethods?: string[];
    chainId?: string;
    txHashes?: string[];
    contractAddresses?: string[];
  }

  export type MessageDirection = "inbound" | "outbound";
}

export interface RelayerOptions {
  core: ICore;
  logger?: string | Logger;
  relayUrl?: string;
  projectId?: string;
}

export interface RelayerClientMetadata {
  protocol: string;
  version: number;
  env: string;
  host?: string;
}

export abstract class IRelayer extends IEvents {
  public abstract protocol: string;

  public abstract version: number;

  public abstract core: ICore;

  public abstract logger: Logger;

  public abstract subscriber: ISubscriber;

  public abstract publisher: IPublisher;

  public abstract messages: IMessageTracker;

  public abstract provider: IJsonRpcProvider;

  public abstract name: string;

  public abstract transportExplicitlyClosed: boolean;

  public abstract readonly context: string;

  public abstract readonly connected: boolean;

  public abstract readonly connecting: boolean;

  constructor(
    // @ts-ignore
    opts: RelayerOptions,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract publish(
    topic: string,
    message: string,
    opts?: RelayerTypes.PublishOptions,
  ): Promise<void>;

  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;

  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;

  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;
  public abstract transportClose(): Promise<void>;
  public abstract transportOpen(relayUrl?: string): Promise<void>;
  public abstract restartTransport(relayUrl?: string): Promise<void>;
  public abstract confirmOnlineStateOrThrow(): Promise<void>;
  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;
  public abstract onLinkMessageEvent(
    messageEvent: RelayerTypes.MessageEvent,
    opts?: { sessionExists?: boolean },
  ): Promise<void>;
}
</file>

<file path="packages/types/src/core/store.ts">
import { ErrorResponse } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";
import { ICore } from "./core";

export abstract class IStore<Key, Value> {
  public abstract map: Map<Key, Value>;

  public abstract readonly context: string;

  public abstract readonly length: number;

  public abstract readonly keys: Key[];

  public abstract readonly values: Value[];

  constructor(
    public core: ICore,
    public logger: Logger,
    public name: string,
    // @ts-ignore
    storagePrefix?: string,
  ) {}

  public abstract init(): Promise<void>;

  public abstract set(key: Key, value: Value): Promise<void>;

  public abstract get(key: Key): Value;

  public abstract getAll(filter?: Partial<Value>): Value[];

  public abstract update(key: Key, update: Partial<Value>): Promise<void>;

  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;
}
</file>

<file path="packages/types/src/core/subscriber.ts">
import { IEvents } from "@walletconnect/events";
import { ErrorResponse } from "@walletconnect/jsonrpc-types";
import { Logger } from "@walletconnect/logger";

import { IRelayer, RelayerTypes } from "./relayer";

export declare namespace SubscriberTypes {
  export interface Params extends RelayerTypes.SubscribeOptions {
    topic: string;
  }

  export interface Active extends Params {
    id: string;
  }
}

export declare namespace SubscriberEvents {
  export type Created = SubscriberTypes.Active;

  export interface Deleted extends SubscriberTypes.Active {
    reason: ErrorResponse;
  }

  export type Expired = Deleted;
}

export abstract class ISubscriberTopicMap {
  public map = new Map<string, string[]>();

  public abstract readonly topics: string[];

  public abstract set(topic: string, id: string): void;

  public abstract get(topic: string): string[];

  public abstract exists(topic: string, id: string): boolean;

  public abstract delete(topic: string, id?: string): void;

  public abstract clear(): void;
}

export abstract class ISubscriber extends IEvents {
  public abstract subscriptions: Map<string, SubscriberTypes.Active>;

  public abstract topicMap: ISubscriberTopicMap;

  public abstract pending: Map<string, SubscriberTypes.Params>;

  public abstract readonly length: number;

  public abstract readonly ids: string[];

  public abstract readonly values: SubscriberTypes.Active[];

  public abstract readonly topics: string[];

  public abstract readonly hasAnyTopics: boolean;

  public abstract name: string;

  public abstract readonly context: string;

  constructor(
    public relayer: IRelayer,
    public logger: Logger,
  ) {
    super();
  }

  public abstract init(): Promise<void>;

  public abstract subscribe(
    topic: string,
    opts?: RelayerTypes.SubscribeOptions,
  ): Promise<string | null>;

  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;

  public abstract isSubscribed(topic: string): Promise<boolean>;

  public abstract isKnownTopic(topic: string): Promise<boolean>;

  public abstract start(): Promise<void>;

  public abstract stop(): Promise<void>;
}
</file>

<file path="packages/types/src/core/verify.ts">
import { Logger } from "@walletconnect/logger";
import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";
import { ICore } from "./core";

export declare namespace Verify {
  export interface Context {
    verified: {
      origin: string;
      validation: "UNKNOWN" | "VALID" | "INVALID";
      verifyUrl: string;
      isScam?: boolean;
    };
  }
}

export abstract class IVerify {
  public abstract readonly context: string;

  constructor(
    public core: ICore,
    public logger: Logger,
    public store: IKeyValueStorage,
  ) {}

  public abstract register(params: {
    id: string;
    decryptedId: string;
  }): Promise<string | undefined>;

  public abstract resolve(params: {
    attestationId?: string;
    hash?: string;
    encryptedId?: string;
    verifyUrl?: string;
  }): Promise<{ origin: string; isScam?: boolean }>;
}
</file>

<file path="packages/types/src/sign-client/auth.ts">
import {
  ErrorResponse,
  JsonRpcError,
  JsonRpcRequest,
  JsonRpcResponse,
  JsonRpcResult,
} from "@walletconnect/jsonrpc-types";
import { CoreTypes, ICore, IStore, RelayerTypes, Verify } from "../core";
import { SessionTypes } from "./session";

export declare namespace AuthTypes {
  type Event = "session_authenticate";

  interface AuthRequestEventArgs {
    requester: Participant;
    authPayload: PayloadParams;
    expiryTimestamp: number;
    transportType?: RelayerTypes.TransportType;
  }

  type AuthResponseEventArgs =
    | { message: string; code: number }
    | JsonRpcResult<Cacao>
    | JsonRpcError;

  interface BaseEventArgs<T = unknown> {
    id: number;
    topic: string;
    params: T;
    verifyContext?: Verify.Context;
  }

  interface EventArguments {
    auth_request: BaseEventArgs<AuthRequestEventArgs>;
    auth_response: BaseEventArgs<AuthResponseEventArgs>;
    sign_request: BaseEventArgs<{
      request: { method: string; params: any };
      chainId: string;
    }>;
    sign_response: BaseEventArgs<JsonRpcResult | JsonRpcError>;
  }

  interface Options extends CoreTypes.Options {
    metadata: Metadata;
    core?: ICore;
    projectId: string;
  }

  interface Metadata {
    name: string;
    description: string;
    url: string;
    icons: string[];
    redirect?: {
      native?: string;
      universal?: string;
      linkMode?: boolean;
    };
    verifyUrl?: string;
  }

  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
    topic: string;
    payload: T;
  }

  /**
   * `aud` is used in protocol request
   * `uri` is more descriptive and is used in client APIs
   * formatMessageParams should accept either `aud` or `uri` as a parameter to construct the message
   */
  type FormatMessageParams = {
    aud?: string;
    uri?: string;
  } & Omit<BaseAuthRequestParams, "aud" | "chainId">;

  interface BaseAuthRequestParams {
    domain: string;
    aud: string;
    nonce: string;
    version?: string;
    iat?: string;
    nbf?: string;
    exp?: string;
    chainId?: string;
    statement?: string;
    requestId?: string;
    resources?: string[];
    expiry?: number;
    type?: string;
  }

  // https://github.com/ChainAgnostic/CAIPs/pull/74
  type RequestParams = {
    chains: string[];
  } & BaseAuthRequestParams;

  type SessionAuthenticateParams = {
    pairingTopic?: string;
    methods?: string[];
    uri: string;
  } & Omit<RequestParams, "aud">;

  type PayloadParams = {
    version: string;
    iat: string;
  } & RequestParams;

  type CacaoPayload = {
    iss: string;
  } & BaseAuthRequestParams;

  interface CacaoHeader {
    t: "caip122";
  }

  interface CacaoSignature {
    t: "eip191" | "eip1271";
    s: string;
    m?: string;
  }

  interface Cacao {
    h: CacaoHeader;
    p: CacaoPayload;
    s: CacaoSignature;
  }

  interface PendingRequest {
    id: number;
    pairingTopic: string;
    requester: Participant;
    expiryTimestamp: number;
    authPayload: PayloadParams;
    verifyContext: Verify.Context;
    transportType?: RelayerTypes.TransportType;
  }

  interface ApproveSessionAuthenticateParams {
    id: number;
    auths: Cacao[];
  }

  interface SessionAuthenticateResponseParams {
    responder: Participant;
    cacaos: Cacao[];
  }

  interface AuthErrorResponse {
    id: number;
    error: ErrorResponse;
  }

  type AuthResponse = SessionAuthenticateResponseParams["cacaos"];

  interface Participant {
    publicKey: string;
    metadata: Metadata;
  }

  interface SessionAuthenticateRequestParams {
    requester: Participant;
    authPayload: PayloadParams;
    expiryTimestamp: number;
  }

  interface SessionAuthenticateRequest extends SessionAuthenticateRequestParams {
    verifyContext: Verify.Context;
  }

  type AuthenticateResponseResult = {
    auths?: AuthTypes.AuthResponse;
    session: SessionTypes.Struct;
  };
}

export type IAuth = {
  init(): Promise<void>;
  authKeys: IStore<string, { responseTopic: string; publicKey: string }>;
  pairingTopics: IStore<string, { topic: string; pairingTopic: string }>;
  requests: IStore<number, AuthTypes.PendingRequest>;
};
</file>

<file path="packages/types/src/sign-client/client.ts">
import { Logger } from "@walletconnect/logger";
import EventEmmiter from "events";
import { CoreTypes, ICore } from "../core/core";
import { IEngine } from "./engine";
import { IPendingRequest } from "./pendingRequest";
import { IProposal, ProposalTypes } from "./proposal";
import { ISession, SessionTypes } from "./session";
import { Verify } from "../core/verify";
import { IAuth, AuthTypes } from "./auth";
import { RelayerTypes } from "../core";

export declare namespace SignClientTypes {
  type Event =
    | "session_proposal"
    | "session_update"
    | "session_extend"
    | "session_ping"
    | "session_delete"
    | "session_expire"
    | "session_request"
    | "session_request_sent"
    | "session_event"
    | "session_authenticate"
    | "proposal_expire"
    | "session_request_expire"
    | "session_connect";

  interface BaseEventArgs<T = unknown> {
    id: number;
    topic: string;
    params: T;
  }
  interface EventArguments {
    session_proposal: {
      verifyContext: Verify.Context;
    } & Omit<BaseEventArgs<ProposalTypes.Struct>, "topic">;
    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;
    session_extend: Omit<BaseEventArgs, "params">;
    session_ping: Omit<BaseEventArgs, "params">;
    session_delete: Omit<BaseEventArgs, "params">;
    session_expire: { topic: string };
    session_request: {
      verifyContext: Verify.Context;
    } & BaseEventArgs<{
      request: { method: string; params: any; expiryTimestamp?: number };
      chainId: string;
    }>;
    session_request_sent: {
      request: { method: string; params: any };
      topic: string;
      chainId: string;
      id: number;
    };
    session_event: BaseEventArgs<{
      event: { name: string; data: any };
      chainId: string;
    }>;
    session_authenticate: {
      verifyContext: Verify.Context;
      transportType?: RelayerTypes.TransportType;
    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;
    proposal_expire: { id: number };
    session_request_expire: { id: number };
    session_connect: { session: SessionTypes.Struct };
  }

  type Metadata = CoreTypes.Metadata;

  type SignConfig = {
    disableRequestQueue?: boolean;
  };

  interface Options extends CoreTypes.Options {
    core?: ICore;
    metadata?: Metadata;
    signConfig?: SignConfig;
  }
}

export abstract class ISignClientEvents extends EventEmmiter {
  constructor() {
    super();
  }

  public abstract emit: <E extends SignClientTypes.Event>(
    event: E,
    args: SignClientTypes.EventArguments[E],
  ) => boolean;

  public abstract on: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract once: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract off: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract removeListener: <E extends SignClientTypes.Event>(
    event: E,
    listener: (args: SignClientTypes.EventArguments[E]) => any,
  ) => this;

  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;
}

export abstract class ISignClient {
  public readonly protocol = "wc";
  public readonly version = 2;

  public abstract readonly name: string;
  public abstract readonly context: string;
  public abstract readonly metadata: SignClientTypes.Metadata;

  public abstract core: ICore;
  public abstract logger: Logger;
  public abstract events: ISignClientEvents;
  public abstract engine: IEngine;
  public abstract session: ISession;
  public abstract proposal: IProposal;
  public abstract pendingRequest: IPendingRequest;
  public abstract auth: IAuth;
  public abstract signConfig?: SignClientTypes.SignConfig;

  constructor(public opts?: SignClientTypes.Options) {}

  public abstract connect: IEngine["connect"];
  public abstract pair: IEngine["pair"];
  public abstract approve: IEngine["approve"];
  public abstract reject: IEngine["reject"];
  public abstract update: IEngine["update"];
  public abstract extend: IEngine["extend"];
  public abstract request: IEngine["request"];
  public abstract respond: IEngine["respond"];
  public abstract ping: IEngine["ping"];
  public abstract emit: IEngine["emit"];
  public abstract disconnect: IEngine["disconnect"];
  public abstract find: IEngine["find"];
  public abstract getPendingSessionRequests: IEngine["getPendingSessionRequests"];
  public abstract authenticate: IEngine["authenticate"];
  public abstract formatAuthMessage: IEngine["formatAuthMessage"];
  public abstract approveSessionAuthenticate: IEngine["approveSessionAuthenticate"];
  public abstract rejectSessionAuthenticate: IEngine["rejectSessionAuthenticate"];
}
</file>

<file path="packages/types/src/sign-client/engine.ts">
import {
  JsonRpcResponse,
  JsonRpcRequest,
  ErrorResponse,
  JsonRpcResult,
  JsonRpcError,
} from "@walletconnect/jsonrpc-types";
import { ISignClient } from "./client";
import { RelayerTypes } from "../core/relayer";
import { SessionTypes } from "./session";
import { ProposalTypes } from "./proposal";
import { PairingTypes } from "../core/pairing";
import { JsonRpcTypes } from "./jsonrpc";
import { EventEmitter } from "events";
import { PendingRequestTypes } from "./pendingRequest";
import { AuthTypes } from "./auth";
import { CryptoTypes } from "../core";

export declare namespace EngineTypes {
  type Event =
    | "session_connect"
    | "session_approve"
    | "session_update"
    | "session_extend"
    | "session_ping"
    | "pairing_ping"
    | "session_request";

  interface EventArguments {
    session_connect: {
      error?: ErrorResponse;
      session?: SessionTypes.Struct;
    };
    session_approve: { error?: ErrorResponse };
    session_update: { error?: ErrorResponse };
    session_extend: { error?: ErrorResponse };
    session_ping: { error?: ErrorResponse };
    pairing_ping: { error?: ErrorResponse };
    session_request: { error?: ErrorResponse; result?: any };
  }

  interface UriParameters {
    protocol: string;
    version: number;
    topic: string;
    symKey: string;
    relay: RelayerTypes.ProtocolOptions;
    methods?: string[];
    expiryTimestamp?: number;
  }

  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
    topic: string;
    payload: T;
    transportType?: RelayerTypes.MessageEvent["transportType"];
    attestation?: string;
    encryptedId?: string;
  }

  interface ConnectParams {
    requiredNamespaces?: ProposalTypes.RequiredNamespaces;
    optionalNamespaces?: ProposalTypes.OptionalNamespaces;
    sessionProperties?: ProposalTypes.SessionProperties;
    scopedProperties?: ProposalTypes.ScopedProperties;
    pairingTopic?: string;
    relays?: RelayerTypes.ProtocolOptions[];
  }

  interface PairParams {
    uri: string;
  }

  interface ApproveParams {
    id: number;
    namespaces: SessionTypes.Namespaces;
    sessionProperties?: ProposalTypes.SessionProperties;
    scopedProperties?: ProposalTypes.ScopedProperties;
    sessionConfig?: SessionTypes.SessionConfig;
    relayProtocol?: string;
  }

  interface RejectParams {
    id: number;
    reason: ErrorResponse;
  }

  interface UpdateParams {
    topic: string;
    namespaces: SessionTypes.Namespaces;
  }

  interface ExtendParams {
    topic: string;
  }

  interface RequestParams {
    topic: string;
    request: {
      method: string;
      params: any;
    };
    chainId: string;
    expiry?: number;
  }

  interface RespondParams {
    topic: string;
    response: JsonRpcResponse;
  }

  interface EmitParams {
    topic: string;
    event: {
      name: string;
      data: any;
    };
    chainId: string;
  }

  interface PingParams {
    topic: string;
  }

  interface DisconnectParams {
    topic: string;
    reason: ErrorResponse;
  }

  interface FindParams {
    requiredNamespaces: ProposalTypes.RequiredNamespaces;
  }

  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;

  type SessionAuthenticateResponsePromise = {
    uri: string;
    response: () => Promise<AuthTypes.AuthenticateResponseResult>;
  };

  interface RpcOpts {
    req: RelayerTypes.PublishOptions & {
      ttl: number;
    };
    res: RelayerTypes.PublishOptions & {
      ttl: number;
    };
    reject?: RelayerTypes.PublishOptions & {
      ttl: number;
    };
    autoReject?: RelayerTypes.PublishOptions & {
      ttl: number;
    };
  }

  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;

  type EngineQueue<T> = {
    state: "IDLE" | "ACTIVE";
    queue: T[];
  };
}

export abstract class IEngineEvents extends EventEmitter {
  constructor() {
    super();
  }

  public abstract emit: <E extends EngineTypes.Event>(
    event: string,
    args: EngineTypes.EventArguments[E],
  ) => boolean;

  public abstract once: <E extends EngineTypes.Event>(
    event: string,
    listener: (args: EngineTypes.EventArguments[E]) => any,
  ) => this;
}

// -- private method interface -------------------------------------- //

export interface EnginePrivate {
  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {
    topic: string;
    method: M;
    params: JsonRpcTypes.RequestParams[M];
    expiry?: number;
    relayRpcId?: number;
    clientRpcId?: number;
    throwOnFailedPublish?: boolean;
    appLink?: string;
    tvf?: RelayerTypes.ITVF;
  }): Promise<number>;

  sendResult<M extends JsonRpcTypes.WcMethod>(args: {
    id: number;
    topic: string;
    result: JsonRpcTypes.Results[M];
    throwOnFailedPublish?: boolean;
    encodeOpts?: CryptoTypes.EncodeOptions;
    appLink?: string;
  }): Promise<void>;

  sendError(params: {
    id: number;
    topic: string;
    error: JsonRpcTypes.Error;
    encodeOpts?: CryptoTypes.EncodeOptions;
    rpcOpts?: RelayerTypes.PublishOptions;
    appLink?: string;
  }): Promise<void>;

  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;

  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;

  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;

  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;

  deleteSession(params: {
    topic: string;
    expirerHasDeleted?: boolean;
    id?: number;
    emitEvent?: boolean;
  }): Promise<void>;

  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;

  setExpiry(topic: string, expiry: number): Promise<void>;

  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;

  setAuthRequest(
    id: number,
    params: {
      request: AuthTypes.SessionAuthenticateRequest;
      pairingTopic: string;
      transportType?: RelayerTypes.MessageEvent["transportType"];
    },
  ): Promise<void>;

  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;

  deletePendingSessionRequest(
    id: number,
    reason: ErrorResponse,
    expirerHasDeleted?: boolean,
  ): Promise<void>;

  deletePendingAuthRequest(
    id: number,
    reason: ErrorResponse,
    expirerHasDeleted?: boolean,
  ): Promise<void>;

  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;

  cleanup(): Promise<void>;

  onSessionProposeRequest(params: {
    topic: string;
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionPropose"]>;
    attestation?: string;
    encryptedId?: string;
  }): Promise<void>;

  onSessionProposeResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionPropose"]> | JsonRpcError,
    transportType?: RelayerTypes.MessageEvent["transportType"],
  ): Promise<void>;

  onSessionSettleRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionSettle"]>,
  ): Promise<void>;

  onSessionSettleResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionSettle"]> | JsonRpcError,
  ): Promise<void>;

  onSessionUpdateRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionUpdate"]>,
  ): Promise<void>;

  onSessionUpdateResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionUpdate"]> | JsonRpcError,
  ): void;

  onSessionExtendRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionExtend"]>,
  ): Promise<void>;

  onSessionExtendResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionExtend"]> | JsonRpcError,
  ): void;

  onSessionPingRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionPing"]>,
  ): Promise<void>;

  onSessionPingResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionPing"]> | JsonRpcError,
  ): void;

  onSessionDeleteRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionDelete"]>,
  ): Promise<void>;

  onSessionRequest(params: {
    topic: string;
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionRequest"]>;
    transportType?: RelayerTypes.MessageEvent["transportType"];
    attestation?: string;
    encryptedId?: string;
  }): Promise<void>;

  onSessionRequestResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionRequest"]> | JsonRpcError,
  ): void;

  onSessionEventRequest(
    topic: string,
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionEvent"]>,
  ): Promise<void>;

  onSessionAuthenticateRequest(params: {
    topic: string;
    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionAuthenticate"]>;
    transportType?: RelayerTypes.MessageEvent["transportType"];
    attestation?: string;
    encryptedId?: string;
  }): Promise<void>;

  onSessionAuthenticateResponse(
    topic: string,
    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionAuthenticate"]> | JsonRpcError,
  ): void;

  // -- Validators ---------------------------------------------------- //
  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;

  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams["wc_sessionSettle"]): void;

  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;

  isValidReject(params: EngineTypes.RejectParams): Promise<void>;

  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;

  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;

  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;

  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;

  isValidPing(params: EngineTypes.PingParams): Promise<void>;

  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;

  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;
}

// -- class interface ----------------------------------------------- //

export abstract class IEngine {
  constructor(public client: ISignClient) {}

  public abstract init(): Promise<void>;

  public abstract connect(
    params: EngineTypes.ConnectParams,
  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;

  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;

  public abstract approve(
    params: EngineTypes.ApproveParams,
  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;

  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;

  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;

  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;

  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;

  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;

  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;

  public abstract ping(params: EngineTypes.PingParams): Promise<void>;

  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;

  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];

  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];

  public abstract authenticate: (
    params: AuthTypes.SessionAuthenticateParams,
    walletUniversalLink?: string,
  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;

  public abstract approveSessionAuthenticate: (
    params: AuthTypes.ApproveSessionAuthenticateParams,
  ) => Promise<{ session: SessionTypes.Struct | undefined }>;

  public abstract formatAuthMessage: (params: {
    request: AuthTypes.BaseAuthRequestParams;
    iss: string;
  }) => string;

  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;

  public abstract processRelayMessageCache(): void;
}
</file>

<file path="packages/types/src/sign-client/index.ts">
export * from "./client";
export * from "./engine";
export * from "./jsonrpc";
export * from "./proposal";
export * from "./session";
export * from "./pendingRequest";
export * from "./auth";
</file>

<file path="packages/types/src/sign-client/jsonrpc.ts">
import { ErrorResponse, JsonRpcResult } from "@walletconnect/jsonrpc-types";
import { SignClientTypes } from "./client";
import { RelayerTypes } from "../core/relayer";
import { SessionTypes } from "./session";
import { ProposalTypes } from "./proposal";
import { AuthTypes } from ".";

export declare namespace JsonRpcTypes {
  // -- core ------------------------------------------------------- //
  export type DefaultResponse = true | ErrorResponse;

  export type WcMethod =
    | "wc_sessionPropose"
    | "wc_sessionSettle"
    | "wc_sessionUpdate"
    | "wc_sessionExtend"
    | "wc_sessionDelete"
    | "wc_sessionPing"
    | "wc_sessionRequest"
    | "wc_sessionEvent"
    | "wc_sessionAuthenticate";

  // -- requests --------------------------------------------------- //

  export interface RequestParams {
    wc_pairingDelete: {
      code: number;
      message: string;
    };
    wc_pairingPing: Record<string, unknown>;
    wc_sessionPropose: {
      relays: RelayerTypes.ProtocolOptions[];
      requiredNamespaces: ProposalTypes.RequiredNamespaces;
      optionalNamespaces: ProposalTypes.OptionalNamespaces;
      sessionProperties?: ProposalTypes.SessionProperties;
      proposer: {
        publicKey: string;
        metadata: SignClientTypes.Metadata;
      };
      expiryTimestamp?: number;
    };
    wc_sessionSettle: {
      relay: RelayerTypes.ProtocolOptions;
      namespaces: SessionTypes.Namespaces;
      sessionProperties?: ProposalTypes.SessionProperties;
      scopedProperties?: ProposalTypes.ScopedProperties;
      sessionConfig?: SessionTypes.SessionConfig;
      expiry: number;
      controller: {
        publicKey: string;
        metadata: SignClientTypes.Metadata;
      };
    };
    wc_sessionUpdate: {
      namespaces: SessionTypes.Namespaces;
    };
    wc_sessionExtend: Record<string, unknown>;
    wc_sessionDelete: {
      code: number;
      message: string;
    };
    wc_sessionPing: Record<string, unknown>;
    wc_sessionRequest: {
      request: {
        method: string;
        params: any;
        expiryTimestamp?: number;
      };
      chainId: string;
    };
    wc_sessionEvent: {
      event: {
        name: string;
        data: unknown;
      };
      chainId: string;
    };
    wc_sessionAuthenticate: AuthTypes.SessionAuthenticateRequestParams;
  }

  // -- responses -------------------------------------------------- //
  export interface Results {
    wc_pairingDelete: true;
    wc_pairingPing: true;
    wc_sessionPropose: {
      relay: RelayerTypes.ProtocolOptions;
      responderPublicKey: string;
    };
    wc_sessionSettle: true;
    wc_sessionUpdate: true;
    wc_sessionExtend: true;
    wc_sessionDelete: true;
    wc_sessionPing: true;
    wc_sessionRequest: JsonRpcResult;
    wc_sessionEvent: true;
    wc_sessionAuthenticate: AuthTypes.SessionAuthenticateResponseParams;
  }

  export type Error = ErrorResponse;
}
</file>

<file path="packages/types/src/sign-client/pendingRequest.ts">
import { IStore, Verify } from "../core";
import { SignClientTypes } from "./";

export declare namespace PendingRequestTypes {
  export interface Struct {
    topic: string;
    id: number;
    params: SignClientTypes.EventArguments["session_request"]["params"];
    verifyContext: Verify.Context;
  }
}
export type IPendingRequest = IStore<number, PendingRequestTypes.Struct>;
</file>

<file path="packages/types/src/sign-client/proposal.ts">
import { SignClientTypes } from "./client";
import { RelayerTypes } from "../core/relayer";
import { IStore } from "../core/store";

export declare namespace ProposalTypes {
  interface BaseRequiredNamespace {
    chains?: string[];
    methods: string[];
    events: string[];
  }

  type RequiredNamespace = BaseRequiredNamespace;

  type RequiredNamespaces = Record<string, RequiredNamespace>;
  type OptionalNamespaces = Record<string, RequiredNamespace>;
  type SessionProperties = Record<string, string>;
  type ScopedProperties = Record<string, unknown>;

  export interface Struct {
    id: number;
    /**
     * @deprecated in favor of expiryTimestamp
     */
    expiry?: number;
    expiryTimestamp: number;
    relays: RelayerTypes.ProtocolOptions[];
    proposer: {
      publicKey: string;
      metadata: SignClientTypes.Metadata;
    };
    requiredNamespaces: RequiredNamespaces;
    optionalNamespaces: OptionalNamespaces;
    sessionProperties?: SessionProperties;
    scopedProperties?: ScopedProperties;
    pairingTopic: string;
  }
}

export type IProposal = IStore<number, ProposalTypes.Struct>;
</file>

<file path="packages/types/src/sign-client/session.ts">
import { RelayerTypes } from "../core/relayer";
import { IStore } from "../core/store";
import { SignClientTypes } from "./client";
import { ProposalTypes } from "./proposal";
import { AuthTypes } from "./auth";

export declare namespace SessionTypes {
  type Expiry = number;

  interface BaseNamespace {
    chains?: string[];
    accounts: string[];
    methods: string[];
    events: string[];
  }

  type Namespace = BaseNamespace;

  type Namespaces = Record<string, Namespace>;

  type SessionProperties = ProposalTypes.SessionProperties;
  type ScopedProperties = ProposalTypes.ScopedProperties;

  interface SessionConfig {
    disableDeepLink?: boolean;
  }

  interface Struct {
    topic: string;
    pairingTopic: string;
    relay: RelayerTypes.ProtocolOptions;
    expiry: Expiry;
    acknowledged: boolean;
    controller: string;
    namespaces: Namespaces;
    requiredNamespaces: ProposalTypes.RequiredNamespaces;
    optionalNamespaces: ProposalTypes.OptionalNamespaces;
    sessionProperties?: SessionProperties;
    scopedProperties?: ScopedProperties;
    sessionConfig?: SessionConfig;
    self: {
      publicKey: string;
      metadata: SignClientTypes.Metadata;
    };
    peer: {
      publicKey: string;
      metadata: SignClientTypes.Metadata;
    };
    authentication?: AuthTypes.Cacao[];
    transportType?: RelayerTypes.TransportType;
  }
}

export type ISession = IStore<string, SessionTypes.Struct>;
</file>

<file path="packages/types/src/index.ts">
export * from "./core";
export * from "./sign-client";
</file>

<file path="packages/types/.npmignore">
*.log
npm-debug.log*

# Coverage directory used by tools like istanbul
coverage
.nyc_output

# Dependency directories
node_modules

# npm package lock
package-lock.json
yarn.lock

# project files
src
test
CHANGELOG.md
.travis.yml
.editorconfig
.eslintignore
.eslintrc
.babelrc
.gitignore
.watchmanconfig
</file>

<file path="packages/types/CHANGELOG.md">
# @walletconnect/types

## 2.20.0

## 2.19.4

## 2.19.3
</file>

<file path="packages/types/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="packages/types/package.json">
{
  "name": "@walletconnect/types",
  "description": "Typings for WalletConnect Protocol",
  "version": "2.20.0",
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
  "license": "Apache-2.0",
  "main": "dist/index.cjs.js",
  "module": "dist/index.es.js",
  "unpkg": "dist/index.umd.js",
  "types": "dist/types/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "keywords": [
    "wallet",
    "walletconnect"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build:pre": "npm run clean",
    "build:types": "tsc",
    "build:source": "rollup --config rollup.config.js",
    "build": "npm run build:pre; npm run build:source; npm run build:types",
    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
    "prettier": "prettier --check 'src/**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@walletconnect/events": "1.0.1",
    "@walletconnect/heartbeat": "1.2.2",
    "@walletconnect/jsonrpc-types": "1.0.4",
    "@walletconnect/keyvaluestorage": "1.1.1",
    "@walletconnect/logger": "2.1.2",
    "events": "3.3.0"
  }
}
</file>

<file path="packages/types/README.md">
# @walletconnect/types

Typings for WalletConnect Protocol
</file>

<file path="packages/types/rollup.config.js">
import { name, dependencies } from "./package.json";
import createConfig from "../../rollup.config";

export default createConfig(name, Object.keys(dependencies));
</file>

<file path="packages/types/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["./src/**/*"],
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "./dist/types",
    "emitDeclarationOnly": true
  }
}
</file>

<file path="packages/utils/src/cacao.ts">
import { AuthTypes } from "@walletconnect/types";
import { getCommonValuesInArrays } from "./misc";
import { verifySignature } from "./signatures";
const didPrefix = "did:pkh:";
export const getDidAddressSegments = (iss: string) => {
  return iss?.split(":");
};

export const getDidChainId = (iss: string) => {
  const segments = iss && getDidAddressSegments(iss);
  if (segments) {
    return iss.includes(didPrefix) ? segments[3] : segments[1];
  }
  return undefined;
};

export const getNamespacedDidChainId = (iss: string) => {
  const segments = iss && getDidAddressSegments(iss);
  if (segments) {
    return segments[2] + ":" + segments[3];
  }
  return undefined;
};

export const getDidAddress = (iss: string) => {
  const segments = iss && getDidAddressSegments(iss);
  if (segments) {
    return segments.pop();
  }
  return undefined;
};

export async function validateSignedCacao(params: { cacao: AuthTypes.Cacao; projectId?: string }) {
  const { cacao, projectId } = params;
  const { s: signature, p: payload } = cacao;
  const reconstructed = formatMessage(payload, payload.iss);
  const walletAddress = getDidAddress(payload.iss) as string;
  const isValid = await verifySignature(
    walletAddress,
    reconstructed,
    signature,
    getNamespacedDidChainId(payload.iss) as string,
    projectId as string,
  );

  return isValid;
}

export const formatMessage = (cacao: AuthTypes.FormatMessageParams, iss: string) => {
  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;
  const walletAddress = getDidAddress(iss);

  if (!cacao.aud && !cacao.uri) {
    throw new Error("Either `aud` or `uri` is required to construct the message");
  }

  let statement = cacao.statement || undefined;
  const uri = `URI: ${cacao.aud || cacao.uri}`;
  const version = `Version: ${cacao.version}`;
  const chainId = `Chain ID: ${getDidChainId(iss)}`;
  const nonce = `Nonce: ${cacao.nonce}`;
  const issuedAt = `Issued At: ${cacao.iat}`;
  const expirationTime = cacao.exp ? `Expiration Time: ${cacao.exp}` : undefined;
  const notBefore = cacao.nbf ? `Not Before: ${cacao.nbf}` : undefined;
  const requestId = cacao.requestId ? `Request ID: ${cacao.requestId}` : undefined;
  const resources = cacao.resources
    ? `Resources:${cacao.resources.map((resource) => `\n- ${resource}`).join("")}`
    : undefined;
  const recap = getRecapFromResources(cacao.resources);
  if (recap) {
    const decoded = decodeRecap(recap);
    statement = formatStatementFromRecap(statement, decoded);
  }

  const message = [
    header,
    walletAddress,
    ``,
    statement,
    ``,
    uri,
    version,
    chainId,
    nonce,
    issuedAt,
    expirationTime,
    notBefore,
    requestId,
    resources,
  ]
    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines
    .join("\n");

  return message;
};

export function buildAuthObject(
  requestPayload: AuthTypes.PayloadParams,
  signature: AuthTypes.CacaoSignature,
  iss: string,
) {
  if (!iss.includes("did:pkh:")) {
    iss = `did:pkh:${iss}`;
  }

  const authObject: AuthTypes.Cacao = {
    h: {
      t: "caip122",
    },
    p: {
      iss,
      domain: requestPayload.domain,
      aud: requestPayload.aud,
      version: requestPayload.version,
      nonce: requestPayload.nonce,
      iat: requestPayload.iat,
      statement: requestPayload.statement,
      requestId: requestPayload.requestId,
      resources: requestPayload.resources,
      nbf: requestPayload.nbf,
      exp: requestPayload.exp,
    },
    s: signature,
  };
  return authObject;
}
type PopulateAuthPayloadParams = {
  authPayload: AuthTypes.PayloadParams;
  chains: string[];
  methods: string[];
};
export function populateAuthPayload(params: PopulateAuthPayloadParams): AuthTypes.PayloadParams {
  const { authPayload, chains, methods } = params;
  const statement = authPayload.statement || "";

  if (!chains?.length) return authPayload;

  const requested = authPayload.chains;
  const supported = chains;

  const supportedChains = getCommonValuesInArrays<string>(requested, supported);
  if (!supportedChains?.length) {
    throw new Error("No supported chains");
  }

  const requestedRecaps = getDecodedRecapFromResources(authPayload.resources);
  if (!requestedRecaps) return authPayload;

  isValidRecap(requestedRecaps);
  const resource = getRecapResource(requestedRecaps, "eip155");
  let updatedResources = authPayload?.resources || [];

  if (resource?.length) {
    const actions = getReCapActions(resource);
    const supportedActions = getCommonValuesInArrays<string>(actions, methods);
    if (!supportedActions?.length) {
      throw new Error(
        `Supported methods don't satisfy the requested: ${JSON.stringify(
          actions,
        )}, supported: ${JSON.stringify(methods)}`,
      );
    }
    const formattedActions = assignAbilityToActions("request", supportedActions as string[], {
      chains: supportedChains,
    });
    const updatedRecap = addResourceToRecap(requestedRecaps, "eip155", formattedActions);
    // remove recap from resources as we will add the updated one
    updatedResources = authPayload?.resources?.slice(0, -1) || [];
    updatedResources.push(encodeRecap(updatedRecap));
  }

  return {
    ...authPayload,
    statement: buildRecapStatement(statement, getRecapFromResources(updatedResources)),
    chains: supportedChains,
    resources: authPayload?.resources || updatedResources.length > 0 ? updatedResources : undefined,
  };
}

export function getDecodedRecapFromResources(resources?: string[]) {
  const resource = getRecapFromResources(resources);
  if (!resource) return;
  if (!isRecap(resource)) return;
  return decodeRecap(resource);
}

export function recapHasResource(recap: any, resource: string) {
  return recap?.att?.hasOwnProperty(resource);
}

export function getRecapResource(recap: any, resource: string): any[] {
  return recap?.att?.[resource] ? Object.keys(recap?.att?.[resource]) : [];
}

export function getRecapAbilitiesFromResource(actions: any[]) {
  return actions?.map((action) => Object.keys(action)) || [];
}

export function getReCapActions(abilities: any[]) {
  return abilities?.map((ability) => ability.split("/")?.[1]) || [];
}

export function base64Encode(input: unknown): string {
  return Buffer.from(JSON.stringify(input)).toString("base64");
}

export function base64Decode(encodedString: string): string {
  return JSON.parse(Buffer.from(encodedString, "base64").toString("utf-8"));
}

export function isValidRecap(recap: any) {
  if (!recap) throw new Error("No recap provided, value is undefined");
  if (!recap.att) throw new Error("No `att` property found");
  const resources = Object.keys(recap.att);
  if (!resources?.length) throw new Error("No resources found in `att` property");
  resources.forEach((resource) => {
    const resourceAbilities = recap.att[resource];
    if (Array.isArray(resourceAbilities))
      throw new Error(`Resource must be an object: ${resource}`);
    if (typeof resourceAbilities !== "object")
      throw new Error(`Resource must be an object: ${resource}`);
    if (!Object.keys(resourceAbilities).length)
      throw new Error(`Resource object is empty: ${resource}`);

    Object.keys(resourceAbilities).forEach((ability) => {
      const limits = resourceAbilities[ability];
      if (!Array.isArray(limits))
        throw new Error(`Ability limits ${ability} must be an array of objects, found: ${limits}`);
      if (!limits.length)
        throw new Error(`Value of ${ability} is empty array, must be an array with objects`);
      limits.forEach((limit) => {
        if (typeof limit !== "object")
          throw new Error(
            `Ability limits (${ability}) must be an array of objects, found: ${limit}`,
          );
      });
    });
  });
}

export function createRecap(resource: string, ability: string, actions: string[], limits = {}) {
  actions?.sort((a, b) => a.localeCompare(b));
  return {
    att: { [resource]: assignAbilityToActions(ability, actions, limits) },
  };
}

type RecapType = {
  att: {
    [key: string]: Record<string, unknown>;
  };
};
export function addResourceToRecap(recap: RecapType, resource: string, actions: unknown[]) {
  recap.att[resource] = {
    ...actions,
  };
  const keys = Object.keys(recap.att)?.sort((a, b) => a.localeCompare(b));
  const baseRecap: RecapType = { att: {} };
  const sorted = keys.reduce((obj, key) => {
    obj.att[key] = recap.att[key];
    return obj;
  }, baseRecap);
  return sorted;
}

export function assignAbilityToActions(ability: string, actions: string[], limits = {}) {
  // sort resources alphabetically
  actions = actions?.sort((a, b) => a.localeCompare(b));
  const abilities = actions.map((action) => {
    return {
      [`${ability}/${action}`]: [limits],
    };
  });
  return Object.assign({}, ...abilities);
}

export function encodeRecap(recap: any) {
  isValidRecap(recap);
  // remove the padding from the base64 string as per recap spec
  return `urn:recap:${base64Encode(recap).replace(/=/g, "")}`;
}

export function decodeRecap(recap: any): RecapType {
  // base64Decode adds padding internally so don't need to add it back if it was removed
  const decoded = base64Decode(recap.replace("urn:recap:", ""));
  isValidRecap(decoded);
  return decoded as unknown as RecapType;
}

export function createEncodedRecap(resource: string, ability: string, actions: string[]): string {
  const recap = createRecap(resource, ability, actions);
  return encodeRecap(recap);
}

export function isRecap(resource: string) {
  return resource && resource.includes("urn:recap:");
}

export function mergeEncodedRecaps(recap1: string, recap2: string) {
  const decoded1 = decodeRecap(recap1);
  const decoded2 = decodeRecap(recap2);
  const merged = mergeRecaps(decoded1, decoded2);
  return encodeRecap(merged);
}

export function mergeRecaps(recap1: RecapType, recap2: RecapType) {
  isValidRecap(recap1);
  isValidRecap(recap2);
  const keys = Object.keys(recap1.att)
    .concat(Object.keys(recap2.att))
    .sort((a, b) => a.localeCompare(b));
  const mergedRecap: RecapType = { att: {} };
  keys.forEach((key) => {
    const actions = Object.keys(recap1.att?.[key] || {})
      .concat(Object.keys(recap2.att?.[key] || {}))
      .sort((a, b) => a.localeCompare(b));
    actions.forEach((action) => {
      mergedRecap.att[key] = {
        ...mergedRecap.att[key],
        [action]: recap1.att[key]?.[action] || recap2.att[key]?.[action],
      };
    });
  });
  return mergedRecap;
}

export function formatStatementFromRecap(statement = "", recap: RecapType) {
  isValidRecap(recap);
  const base = "I further authorize the stated URI to perform the following actions on my behalf: ";

  if (statement.includes(base)) return statement;

  const statementForRecap: string[] = [];
  let currentCounter = 0;
  Object.keys(recap.att).forEach((resource) => {
    const actions = Object.keys(recap.att[resource]).map((ability: any) => {
      return {
        ability: ability.split("/")[0],
        action: ability.split("/")[1],
      };
    });
    //
    actions.sort((a, b) => a.action.localeCompare(b.action));
    const uniqueAbilities: Record<string, string[]> = {};
    actions.forEach((action: any) => {
      if (!uniqueAbilities[action.ability]) {
        uniqueAbilities[action.ability] = [];
      }
      uniqueAbilities[action.ability].push(action.action);
    });
    const abilities = Object.keys(uniqueAbilities).map((ability) => {
      currentCounter++;
      return `(${currentCounter}) '${ability}': '${uniqueAbilities[ability].join(
        "', '",
      )}' for '${resource}'.`;
    });
    statementForRecap.push(abilities.join(", ").replace(".,", "."));
  });

  const recapStatemet = statementForRecap.join(" ");
  const recapStatement = `${base}${recapStatemet}`;
  // add a space if there is a statement
  return `${statement ? statement + " " : ""}${recapStatement}`;
}

export function getMethodsFromRecap(recap: string) {
  const decoded = decodeRecap(recap);
  isValidRecap(decoded);
  // methods are only available for eip155 as per the current implementation
  const resource = decoded.att?.eip155;
  if (!resource) return [];
  return Object.keys(resource).map((ability: any) => ability.split("/")[1]);
}

export function getChainsFromRecap(recap: string) {
  const decoded = decodeRecap(recap);
  isValidRecap(decoded);
  const chains: string[] = [];

  Object.values(decoded.att).forEach((resource: any) => {
    Object.values(resource).forEach((ability: any) => {
      if (ability?.[0]?.chains) {
        chains.push(ability[0].chains);
      }
    });
  });
  return [...new Set(chains.flat())];
}

export function buildRecapStatement(statement: string, recap: unknown) {
  if (!recap) return statement;
  const decoded = decodeRecap(recap);
  isValidRecap(decoded);
  return formatStatementFromRecap(statement, decoded);
}

export function getRecapFromResources(resources?: string[]) {
  if (!resources) return;
  // per spec, recap is always the last resource
  const resource = resources?.[resources.length - 1];
  return isRecap(resource) ? resource : undefined;
}
</file>

<file path="packages/utils/src/caip.ts">
import { SessionTypes, ProposalTypes } from "@walletconnect/types";

interface ChainIdParams {
  namespace: string;
  reference: string;
}

interface AccountIdParams extends ChainIdParams {
  address: string;
}

const CAIP_DELIMITER = ":";

export function parseChainId(chain: string): ChainIdParams {
  const [namespace, reference] = chain.split(CAIP_DELIMITER);
  return { namespace, reference };
}

export function formatChainId(params: ChainIdParams): string {
  const { namespace, reference } = params;
  return [namespace, reference].join(CAIP_DELIMITER);
}

export function parseAccountId(account: string): AccountIdParams {
  const [namespace, reference, address] = account.split(CAIP_DELIMITER);
  return { namespace, reference, address };
}

export function formatAccountId(params: AccountIdParams): string {
  const { namespace, reference, address } = params;
  return [namespace, reference, address].join(CAIP_DELIMITER);
}

export function getUniqueValues(array: string[], parser: (str: string) => string): string[] {
  const unique: string[] = [];
  array.forEach((str) => {
    const value = parser(str);
    if (!unique.includes(value)) unique.push(value);
  });
  return unique;
}

export function getAddressFromAccount(account: string) {
  const { address } = parseAccountId(account);
  return address;
}

export function getChainFromAccount(account: string) {
  const { namespace, reference } = parseAccountId(account);
  const chain = formatChainId({ namespace, reference });
  return chain;
}

export function formatAccountWithChain(address: string, chain: string) {
  const { namespace, reference } = parseChainId(chain);
  const account = formatAccountId({ namespace, reference, address });
  return account;
}

export function getAddressesFromAccounts(accounts: string[]) {
  return getUniqueValues(accounts, getAddressFromAccount);
}

export function getChainsFromAccounts(accounts: string[]) {
  return getUniqueValues(accounts, getChainFromAccount);
}

export function getAccountsFromNamespaces(
  namespaces: SessionTypes.Namespaces,
  keys: string[] = [],
): string[] {
  const accounts: string[] = [];
  Object.keys(namespaces).forEach((key) => {
    if (keys.length && !keys.includes(key)) return;
    const ns = namespaces[key];
    accounts.push(...ns.accounts);
  });
  return accounts;
}

export function getChainsFromNamespaces(
  namespaces: SessionTypes.Namespaces,
  keys: string[] = [],
): string[] {
  const chains: string[] = [];
  Object.keys(namespaces).forEach((key) => {
    if (keys.length && !keys.includes(key)) return;
    const ns = namespaces[key];
    chains.push(...getChainsFromAccounts(ns.accounts));
  });
  return chains;
}

export function getChainsFromRequiredNamespaces(
  requiredNamespaces: ProposalTypes.RequiredNamespaces,
  keys: string[] = [],
): string[] {
  const chains: string[] = [];
  Object.keys(requiredNamespaces).forEach((key) => {
    if (keys.length && !keys.includes(key)) return;
    const ns = requiredNamespaces[key];
    chains.push(...getChainsFromNamespace(key, ns));
  });
  return chains;
}

export function getChainsFromNamespace(
  namespace: string,
  namespaceProps: ProposalTypes.BaseRequiredNamespace,
) {
  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]
  return namespace.includes(":") ? [namespace] : namespaceProps.chains || [];
}
</file>

<file path="packages/utils/src/crypto.ts">
import { chacha20poly1305 } from "@noble/ciphers/chacha";
import { hkdf } from "@noble/hashes/hkdf";
import { randomBytes } from "@noble/hashes/utils";
import { sha256 } from "@noble/hashes/sha256";
import { x25519 } from "@noble/curves/ed25519";
import { p256 } from "@noble/curves/p256";
import { CryptoTypes } from "@walletconnect/types";
import { decodeJWT } from "@walletconnect/relay-auth";
import { concat, fromString, toString } from "uint8arrays";

export const BASE10 = "base10";
export const BASE16 = "base16";
export const BASE64 = "base64pad";
export const BASE64URL = "base64url";
export const UTF8 = "utf8";

export const TYPE_0 = 0;
export const TYPE_1 = 1;
export const TYPE_2 = 2;

export type P256KeyDataType = {
  crv: "P-256" | string;
  ext: true | boolean;
  key_ops: ["verify"] | string[];
  kty: string;
  x: string;
  y: string;
};

const ZERO_INDEX = 0;
const TYPE_LENGTH = 1;
const IV_LENGTH = 12;
const KEY_LENGTH = 32;

export function generateKeyPair(): CryptoTypes.KeyPair {
  const privateKey = x25519.utils.randomPrivateKey();
  const publicKey = x25519.getPublicKey(privateKey);
  return {
    privateKey: toString(privateKey, BASE16),
    publicKey: toString(publicKey, BASE16),
  };
}

export function generateRandomBytes32(): string {
  const random = randomBytes(KEY_LENGTH);
  return toString(random, BASE16);
}

export function deriveSymKey(privateKeyA: string, publicKeyB: string): string {
  const sharedKey = x25519.getSharedSecret(
    fromString(privateKeyA, BASE16),
    fromString(publicKeyB, BASE16),
  );
  const symKey = hkdf(sha256, sharedKey, undefined, undefined, KEY_LENGTH);
  return toString(symKey, BASE16);
}

export function hashKey(key: string): string {
  const result = sha256(fromString(key, BASE16));
  return toString(result, BASE16);
}

export function hashMessage(message: string): string {
  const result = sha256(fromString(message, UTF8));
  return toString(result, BASE16);
}

export function encodeTypeByte(type: number): Uint8Array {
  return fromString(`${type}`, BASE10);
}

export function decodeTypeByte(byte: Uint8Array): number {
  return Number(toString(byte, BASE10));
}

function toBase64URL(base64: string): string {
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

function fromBase64URL(base64url: string): string {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = (4 - (base64.length % 4)) % 4;
  return base64 + "=".repeat(padding);
}

export function encrypt(params: CryptoTypes.EncryptParams): string {
  const type = encodeTypeByte(typeof params.type !== "undefined" ? params.type : TYPE_0);
  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === "undefined") {
    throw new Error("Missing sender public key for type 1 envelope");
  }
  const senderPublicKey =
    typeof params.senderPublicKey !== "undefined"
      ? fromString(params.senderPublicKey, BASE16)
      : undefined;

  const iv =
    typeof params.iv !== "undefined" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);
  const key = fromString(params.symKey, BASE16);
  const box = chacha20poly1305(key, iv);
  const sealed = box.encrypt(fromString(params.message, UTF8));
  const result = serialize({ type, sealed, iv, senderPublicKey });
  return params.encoding === BASE64URL ? toBase64URL(result) : result;
}

export function decrypt(params: CryptoTypes.DecryptParams): string {
  const key = fromString(params.symKey, BASE16);
  const { sealed, iv } = deserialize({ encoded: params.encoded, encoding: params.encoding });
  const box = chacha20poly1305(key, iv);
  const message = box.decrypt(sealed);
  if (message === null) throw new Error("Failed to decrypt");
  return toString(message, UTF8);
}

export function encodeTypeTwoEnvelope(
  message: string,
  encoding?: CryptoTypes.EncodingType,
): string {
  const type = encodeTypeByte(TYPE_2);
  // iv is not used in type 2 envelopes
  const iv = randomBytes(IV_LENGTH);
  const sealed = fromString(message, UTF8);
  const result = serialize({ type, sealed, iv });
  return encoding === BASE64URL ? toBase64URL(result) : result;
}

export function decodeTypeTwoEnvelope(
  encoded: string,
  encoding?: CryptoTypes.EncodingType,
): string {
  const { sealed } = deserialize({ encoded, encoding });
  return toString(sealed, UTF8);
}

export function serialize(params: CryptoTypes.EncodingParams): string {
  if (decodeTypeByte(params.type) === TYPE_2) {
    return toString(concat([params.type, params.sealed]), BASE64);
  }
  if (decodeTypeByte(params.type) === TYPE_1) {
    if (typeof params.senderPublicKey === "undefined") {
      throw new Error("Missing sender public key for type 1 envelope");
    }
    return toString(
      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),
      BASE64,
    );
  }
  // default to type 0 envelope
  return toString(concat([params.type, params.iv, params.sealed]), BASE64);
}

export function deserialize(params: CryptoTypes.DecodingParams): CryptoTypes.EncodingParams {
  const encoding = params.encoding || BASE64;
  const normalizedEncoded = encoding === BASE64URL ? fromBase64URL(params.encoded) : params.encoded;
  const bytes = fromString(normalizedEncoded, BASE64);
  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);
  const slice1 = TYPE_LENGTH;
  if (decodeTypeByte(type) === TYPE_1) {
    const slice2 = slice1 + KEY_LENGTH;
    const slice3 = slice2 + IV_LENGTH;
    const senderPublicKey = bytes.slice(slice1, slice2);
    const iv = bytes.slice(slice2, slice3);
    const sealed = bytes.slice(slice3);
    return { type, sealed, iv, senderPublicKey };
  }
  if (decodeTypeByte(type) === TYPE_2) {
    const sealed = bytes.slice(slice1);
    // iv is not used in type 2 envelopes
    const iv = randomBytes(IV_LENGTH);
    return { type, sealed, iv };
  }
  // default to type 0 envelope
  const slice2 = slice1 + IV_LENGTH;
  const iv = bytes.slice(slice1, slice2);
  const sealed = bytes.slice(slice2);
  return { type, sealed, iv };
}

export function validateDecoding(
  encoded: string,
  opts?: CryptoTypes.DecodeOptions,
): CryptoTypes.EncodingValidation {
  const deserialized = deserialize({ encoded, encoding: opts?.encoding });
  return validateEncoding({
    type: decodeTypeByte(deserialized.type),
    senderPublicKey:
      typeof deserialized.senderPublicKey !== "undefined"
        ? toString(deserialized.senderPublicKey, BASE16)
        : undefined,
    receiverPublicKey: opts?.receiverPublicKey,
  });
}

export function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {
  const type = opts?.type || TYPE_0;
  if (type === TYPE_1) {
    if (typeof opts?.senderPublicKey === "undefined") {
      throw new Error("missing sender public key");
    }
    if (typeof opts?.receiverPublicKey === "undefined") {
      throw new Error("missing receiver public key");
    }
  }
  return {
    type,
    senderPublicKey: opts?.senderPublicKey,
    receiverPublicKey: opts?.receiverPublicKey,
  };
}

export function isTypeOneEnvelope(
  result: CryptoTypes.EncodingValidation,
): result is CryptoTypes.TypeOneParams {
  return (
    result.type === TYPE_1 &&
    typeof result.senderPublicKey === "string" &&
    typeof result.receiverPublicKey === "string"
  );
}

export function isTypeTwoEnvelope(
  result: CryptoTypes.EncodingValidation,
): result is CryptoTypes.TypeOneParams {
  return result.type === TYPE_2;
}

export function getCryptoKeyFromKeyData(keyData: P256KeyDataType): Uint8Array {
  const xBuffer = Buffer.from(keyData.x, "base64");
  const yBuffer = Buffer.from(keyData.y, "base64");

  // Concatenate x and y coordinates with 0x04 prefix (uncompressed point format)
  return concat([new Uint8Array([0x04]), xBuffer, yBuffer]);
}

export function verifyP256Jwt<T>(token: string, keyData: P256KeyDataType) {
  const [headerBase64Url, payloadBase64Url, signatureBase64Url] = token.split(".");

  // Decode the signature
  const signatureBuffer = Buffer.from(fromBase64URL(signatureBase64Url), "base64");

  // Check if signature length is correct (64 bytes for P-256)
  if (signatureBuffer.length !== 64) {
    throw new Error("Invalid signature length");
  }

  // Extract r and s from the signature
  const r = signatureBuffer.slice(0, 32);
  const s = signatureBuffer.slice(32, 64);

  // Create the signing input
  const signingInput = `${headerBase64Url}.${payloadBase64Url}`;

  // Hash the signing input
  const messageHash = sha256(signingInput);

  // Get the public key in uncompressed point format
  const publicKey = getCryptoKeyFromKeyData(keyData);

  // Verify the signature using noble/curves p256
  const isValid = p256.verify(
    concat([r, s]), // signature bytes
    messageHash, // message hash
    publicKey, // public key in uncompressed format
  );

  if (!isValid) {
    throw new Error("Invalid signature");
  }

  const data = decodeJWT(token) as unknown as { payload: T };
  return data.payload;
}
</file>

<file path="packages/utils/src/errors.ts">
/**
 * Types
 */
export type SdkErrorKey = keyof typeof SDK_ERRORS;
export type InternalErrorKey = keyof typeof INTERNAL_ERRORS;

/**
 * Constants
 */
export const SDK_ERRORS = {
  /* ----- INVALID (1xxx) ----- */
  INVALID_METHOD: {
    message: "Invalid method.",
    code: 1001,
  },
  INVALID_EVENT: {
    message: "Invalid event.",
    code: 1002,
  },
  INVALID_UPDATE_REQUEST: {
    message: "Invalid update request.",
    code: 1003,
  },
  INVALID_EXTEND_REQUEST: {
    message: "Invalid extend request.",
    code: 1004,
  },
  INVALID_SESSION_SETTLE_REQUEST: {
    message: "Invalid session settle request.",
    code: 1005,
  },
  /* ----- UNAUTHORIZED (3xxx) ----- */
  UNAUTHORIZED_METHOD: {
    message: "Unauthorized method.",
    code: 3001,
  },
  UNAUTHORIZED_EVENT: {
    message: "Unauthorized event.",
    code: 3002,
  },
  UNAUTHORIZED_UPDATE_REQUEST: {
    message: "Unauthorized update request.",
    code: 3003,
  },
  UNAUTHORIZED_EXTEND_REQUEST: {
    message: "Unauthorized extend request.",
    code: 3004,
  },
  /* ----- REJECTED (5xxx) ----- */
  USER_REJECTED: {
    message: "User rejected.",
    code: 5000,
  },
  USER_REJECTED_CHAINS: {
    message: "User rejected chains.",
    code: 5001,
  },
  USER_REJECTED_METHODS: {
    message: "User rejected methods.",
    code: 5002,
  },
  USER_REJECTED_EVENTS: {
    message: "User rejected events.",
    code: 5003,
  },
  UNSUPPORTED_CHAINS: {
    message: "Unsupported chains.",
    code: 5100,
  },
  UNSUPPORTED_METHODS: {
    message: "Unsupported methods.",
    code: 5101,
  },
  UNSUPPORTED_EVENTS: {
    message: "Unsupported events.",
    code: 5102,
  },
  UNSUPPORTED_ACCOUNTS: {
    message: "Unsupported accounts.",
    code: 5103,
  },
  UNSUPPORTED_NAMESPACE_KEY: {
    message: "Unsupported namespace key.",
    code: 5104,
  },
  /* ----- REASON (6xxx) ----- */
  USER_DISCONNECTED: {
    message: "User disconnected.",
    code: 6000,
  },
  /* ----- FAILURE (7xxx) ----- */
  SESSION_SETTLEMENT_FAILED: {
    message: "Session settlement failed.",
    code: 7000,
  },
  /* ----- PAIRING (10xxx) ----- */
  WC_METHOD_UNSUPPORTED: {
    message: "Unsupported wc_ method.",
    code: 10001,
  },
};

export const INTERNAL_ERRORS = {
  NOT_INITIALIZED: {
    message: "Not initialized.",
    code: 1,
  },
  NO_MATCHING_KEY: {
    message: "No matching key.",
    code: 2,
  },
  RESTORE_WILL_OVERRIDE: {
    message: "Restore will override.",
    code: 3,
  },
  RESUBSCRIBED: {
    message: "Resubscribed.",
    code: 4,
  },
  MISSING_OR_INVALID: {
    message: "Missing or invalid.",
    code: 5,
  },
  EXPIRED: {
    message: "Expired.",
    code: 6,
  },
  UNKNOWN_TYPE: {
    message: "Unknown type.",
    code: 7,
  },
  MISMATCHED_TOPIC: {
    message: "Mismatched topic.",
    code: 8,
  },
  NON_CONFORMING_NAMESPACES: {
    message: "Non conforming namespaces.",
    code: 9,
  },
};

/**
 * Utilities
 */
export function getInternalError(key: InternalErrorKey, context?: string | number) {
  const { message, code } = INTERNAL_ERRORS[key];
  return {
    message: context ? `${message} ${context}` : message,
    code,
  };
}

export function getSdkError(key: SdkErrorKey, context?: string | number) {
  const { message, code } = SDK_ERRORS[key];
  return {
    message: context ? `${message} ${context}` : message,
    code,
  };
}
</file>

<file path="packages/utils/src/index.ts">
export * from "./caip";
export * from "./cacao";
export * from "./crypto";
export * from "./misc";
export * from "./relay";
export * from "./uri";
export * from "./validators";
export * from "./errors";
export * from "./namespaces";
export * from "./network";
export * from "./memoryStore";
export * from "./signatures";
</file>

<file path="packages/utils/src/memoryStore.ts">
const memoryStore: Record<string, any> = {};

export abstract class MemoryStore {
  static get<T = unknown>(key: string) {
    return memoryStore[key] as T | undefined;
  }

  static set(key: string, value: unknown) {
    memoryStore[key] = value;
  }

  static delete(key: string) {
    delete memoryStore[key];
  }
}
</file>

<file path="packages/utils/src/misc.ts">
import { detect } from "detect-browser";
import { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from "@walletconnect/time";
import {
  SignClientTypes,
  RelayerClientMetadata,
  EngineTypes,
  RelayerTypes,
} from "@walletconnect/types";
import { getDocument, getLocation, getNavigator } from "@walletconnect/window-getters";
import { getWindowMetadata } from "@walletconnect/window-metadata";
import { ErrorResponse } from "@walletconnect/jsonrpc-utils";
import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";

// -- constants -----------------------------------------//
export const REACT_NATIVE_PRODUCT = "ReactNative";

export const ENV_MAP = {
  reactNative: "react-native",
  node: "node",
  browser: "browser",
  unknown: "unknown",
};

export const EMPTY_SPACE = " ";

export const COLON = ":";

export const SLASH = "/";

export const DEFAULT_DEPTH = 2;

export const ONE_THOUSAND = 1000;

export const SDK_TYPE = "js";

// -- env -----------------------------------------------//

export function isNode(): boolean {
  return (
    typeof process !== "undefined" &&
    typeof process.versions !== "undefined" &&
    typeof process.versions.node !== "undefined"
  );
}

export function isReactNative(): boolean {
  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;
}

export function isAndroid(): boolean {
  return (
    isReactNative() &&
    typeof global !== "undefined" &&
    typeof (global as any)?.Platform !== "undefined" &&
    (global as any)?.Platform.OS === "android"
  );
}

export function isIos(): boolean {
  return (
    isReactNative() &&
    typeof global !== "undefined" &&
    typeof (global as any)?.Platform !== "undefined" &&
    (global as any)?.Platform.OS === "ios"
  );
}

export function isBrowser(): boolean {
  return !isNode() && !!getNavigator() && !!getDocument();
}

export function getEnvironment(): string {
  if (isReactNative()) return ENV_MAP.reactNative;
  if (isNode()) return ENV_MAP.node;
  if (isBrowser()) return ENV_MAP.browser;
  return ENV_MAP.unknown;
}

export function getAppId(): string | undefined {
  try {
    if (
      isReactNative() &&
      typeof global !== "undefined" &&
      typeof (global as any)?.Application !== "undefined"
    ) {
      return (global as any).Application?.applicationId;
    }
    return undefined;
  } catch {
    return undefined;
  }
}

// -- query -----------------------------------------------//

export function appendToQueryString(
  queryString: string,
  newQueryParams: Record<string, any>,
): string {
  const urlSearchParams = new URLSearchParams(queryString);

  for (const key of Object.keys(newQueryParams).sort()) {
    if (newQueryParams.hasOwnProperty(key)) {
      const value = newQueryParams[key];
      if (value !== undefined) {
        urlSearchParams.set(key, value);
      }
    }
  }

  return urlSearchParams.toString();
}

// -- metadata ----------------------------------------------//

export function populateAppMetadata(metadata?: SignClientTypes.Metadata): SignClientTypes.Metadata {
  const appMetadata = getAppMetadata();
  try {
    if (metadata?.url && appMetadata.url) {
      if (metadata.url !== appMetadata.url) {
        console.warn(
          `The configured WalletConnect 'metadata.url':${metadata.url} differs from the actual page url:${appMetadata.url}. This is probably unintended and can lead to issues.`,
        );
        metadata.url = appMetadata.url;
      }
    }

    if (metadata?.icons?.length && metadata.icons.length > 0) {
      metadata.icons = metadata.icons.filter((icon) => icon !== "");
    }

    return {
      ...appMetadata,
      ...metadata,
      url: metadata?.url || appMetadata.url,
      name: metadata?.name || appMetadata.name,
      description: metadata?.description || appMetadata.description,
      icons:
        metadata?.icons?.length && metadata.icons.length > 0 ? metadata.icons : appMetadata.icons,
    };
  } catch (error) {
    console.warn("Error populating app metadata", error);
    return metadata || appMetadata;
  }
}

export function getAppMetadata(): SignClientTypes.Metadata {
  return (
    getWindowMetadata() || {
      name: "",
      description: "",
      url: "",
      icons: [""],
    }
  );
}

export function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {
  const env = getEnvironment();

  const metadata: RelayerClientMetadata = { protocol, version, env };
  if (env === "browser") {
    metadata.host = getLocation()?.host || "unknown";
  }
  return metadata;
}

// -- rpcUrl ----------------------------------------------//

export function getJavascriptOS() {
  const env = getEnvironment();
  // global.Platform is set by react-native-compat
  if (
    env === ENV_MAP.reactNative &&
    typeof global !== "undefined" &&
    typeof (global as any)?.Platform !== "undefined"
  ) {
    const { OS, Version } = (global as any).Platform;
    return [OS, Version].join("-");
  }

  const info = detect();
  if (info === null) return "unknown";
  const os = info.os ? info.os.replace(" ", "").toLowerCase() : "unknown";
  if (info.type === "browser") {
    return [os, info.name, info.version].join("-");
  }
  return [os, info.version].join("-");
}

export function getJavascriptID() {
  const env = getEnvironment();
  return env === ENV_MAP.browser ? [env, getLocation()?.host || "unknown"].join(":") : env;
}

export function formatUA(protocol: string, version: number, sdkVersion: string) {
  const os = getJavascriptOS();
  const id = getJavascriptID();
  return [[protocol, version].join("-"), [SDK_TYPE, sdkVersion].join("-"), os, id].join("/");
}
console;

export function formatRelayRpcUrl({
  protocol,
  version,
  relayUrl,
  sdkVersion,
  auth,
  projectId,
  useOnCloseEvent,
  bundleId,
  packageName,
}: RelayerTypes.RpcUrlParams) {
  const splitUrl = relayUrl.split("?");
  const ua = formatUA(protocol, version, sdkVersion);
  const params = {
    auth,
    ua,
    projectId,
    useOnCloseEvent: useOnCloseEvent || undefined,
    packageName: packageName || undefined,
    bundleId: bundleId || undefined,
  };
  const queryString = appendToQueryString(splitUrl[1] || "", params);
  return splitUrl[0] + "?" + queryString;
}

export function getHttpUrl(url: string) {
  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url
  const matches = url.match(/^[^:]+(?=:\/\/)/gi) || [];
  let protocol = matches[0];
  const domain = typeof protocol !== "undefined" ? url.split("://")[1] : url;
  protocol = protocol === "wss" ? "https" : "http";
  return [protocol, domain].join("://");
}

// -- assert ------------------------------------------------- //

export function assertType(obj: any, key: string, type: string) {
  // eslint-disable-next-line valid-typeof
  if (!obj[key] || typeof obj[key] !== type) {
    throw new Error(`Missing or invalid "${key}" param`);
  }
}

// -- context ------------------------------------------------- //

export function parseContextNames(context: string, depth = DEFAULT_DEPTH) {
  return getLastItems(context.split(SLASH), depth);
}

export function formatMessageContext(context: string): string {
  return parseContextNames(context).join(EMPTY_SPACE);
}

// -- array ------------------------------------------------- //

export function hasOverlap(a: any[], b: any[]): boolean {
  const matches = a.filter((x) => b.includes(x));
  return matches.length === a.length;
}

export function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {
  return arr.slice(Math.max(arr.length - depth, 0));
}

// -- map ------------------------------------------------- //

export function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {
  return Object.fromEntries(map.entries());
}

export function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {
  return new Map<string, T>(Object.entries<T>(obj));
}

export function mapEntries<A = any, B = any>(
  obj: Record<string, A>,
  cb: (x: A) => B,
): Record<string, B> {
  const res: any = {};
  Object.keys(obj).forEach((key) => {
    res[key] = cb(obj[key]);
  });
  return res;
}

// -- enum ------------------------------------------------- //

// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
export const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;

// -- string ------------------------------------------------- //

export function capitalizeWord(word: string) {
  return word.trim().replace(/^\w/, (c) => c.toUpperCase());
}

export function capitalize(str: string) {
  return str
    .split(EMPTY_SPACE)
    .map((w) => capitalizeWord(w))
    .join(EMPTY_SPACE);
}

// -- promises --------------------------------------------- //
export function createDelayedPromise<T>(
  expiry: number = FIVE_MINUTES,
  expireErrorMessage?: string,
) {
  const timeout = toMiliseconds(expiry || FIVE_MINUTES);
  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);
  let cacheReject: undefined | ((value?: ErrorResponse) => void);
  let cacheTimeout: undefined | NodeJS.Timeout;
  let result: Promise<Awaited<T>> | Promise<T> | undefined;

  const done = () =>
    new Promise<T>((promiseResolve, promiseReject) => {
      if (result) {
        return promiseResolve(result);
      }
      cacheTimeout = setTimeout(() => {
        const err = new Error(expireErrorMessage);
        result = Promise.reject(err);
        promiseReject(err);
      }, timeout);
      cacheResolve = promiseResolve;
      cacheReject = promiseReject;
    });
  const resolve = (value?: T) => {
    if (cacheTimeout && cacheResolve) {
      clearTimeout(cacheTimeout);
      cacheResolve(value as T);
      result = Promise.resolve(value) as Promise<Awaited<T>>;
    }
  };
  const reject = (value?: ErrorResponse) => {
    if (cacheTimeout && cacheReject) {
      clearTimeout(cacheTimeout);
      cacheReject(value);
    }
  };

  return {
    resolve,
    reject,
    done,
  };
}

export function createExpiringPromise<T>(
  promise: Promise<T>,
  expiry: number,
  expireErrorMessage?: string,
) {
  return new Promise(async (resolve, reject) => {
    const timeout = setTimeout(() => reject(new Error(expireErrorMessage)), expiry);
    try {
      const result = await promise;
      resolve(result);
    } catch (error) {
      reject(error);
    }
    clearTimeout(timeout);
  });
}

// -- expirer --------------------------------------------- //

export function formatExpirerTarget(type: "topic" | "id", value: string | number): string {
  if (typeof value === "string" && value.startsWith(`${type}:`)) return value;
  if (type.toLowerCase() === "topic") {
    if (typeof value !== "string")
      throw new Error(`Value must be "string" for expirer target type: topic`);
    return `topic:${value}`;
  } else if (type.toLowerCase() === "id") {
    if (typeof value !== "number")
      throw new Error(`Value must be "number" for expirer target type: id`);
    return `id:${value}`;
  }
  throw new Error(`Unknown expirer target type: ${type}`);
}

export function formatTopicTarget(topic: string): string {
  return formatExpirerTarget("topic", topic);
}

export function formatIdTarget(id: number): string {
  return formatExpirerTarget("id", id);
}

export function parseExpirerTarget(target: string) {
  const [type, value] = target.split(":");
  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };
  if (type === "topic" && typeof value === "string") {
    parsed.topic = value;
  } else if (type === "id" && Number.isInteger(Number(value))) {
    parsed.id = Number(value);
  } else {
    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);
  }

  return parsed;
}

export function calcExpiry(ttl: number, now?: number): number {
  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));
}

export function isExpired(expiry: number) {
  return Date.now() >= toMiliseconds(expiry);
}

// -- events ---------------------------------------------- //

export function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {
  return `${event}${id ? `:${id}` : ""}`;
}

export function mergeArrays<T>(a: T[] = [], b: T[] = []): T[] {
  return [...new Set([...a, ...b])];
}

export async function handleDeeplinkRedirect({
  id,
  topic,
  wcDeepLink,
}: {
  id: number;
  topic: string;
  wcDeepLink: string;
}) {
  try {
    if (!wcDeepLink) return;

    const json = typeof wcDeepLink === "string" ? JSON.parse(wcDeepLink) : wcDeepLink;
    const deeplink = json?.href;
    if (typeof deeplink !== "string") return;
    const link = formatDeeplinkUrl(deeplink, id, topic);
    const env = getEnvironment();

    if (env === ENV_MAP.browser) {
      if (!getDocument()?.hasFocus()) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }

      openDeeplink(link);
    } else if (env === ENV_MAP.reactNative) {
      // global.Linking is set by react-native-compat
      if (typeof (global as any)?.Linking !== "undefined") {
        await (global as any).Linking.openURL(link);
      }
    }
  } catch (err) {
    // Silent error, just log in console
    // eslint-disable-next-line no-console
    console.error(err);
  }
}

export function formatDeeplinkUrl(deeplink: string, requestId: number, sessionTopic: string) {
  const payload = `requestId=${requestId}&sessionTopic=${sessionTopic}`;
  if (deeplink.endsWith("/")) deeplink = deeplink.slice(0, -1);
  let link = `${deeplink}`;
  if (deeplink.startsWith("https://t.me")) {
    const startApp = deeplink.includes("?") ? "&startapp=" : "?startapp=";
    link = `${link}${startApp}${toBase64(payload, true)}`;
  } else {
    link = `${link}/wc?${payload}`;
  }
  return link;
}

export function openDeeplink(url: string) {
  let target = "_self";
  if (isIframe()) {
    target = "_top";
  } else if (isTelegram() || url.startsWith("https://") || url.startsWith("http://")) {
    target = "_blank";
  }

  window.open(url, target, "noreferrer noopener");
}

export async function getDeepLink(storage: IKeyValueStorage, key: string) {
  let link: string | undefined = "";
  try {
    if (isBrowser()) {
      link = localStorage.getItem(key) as string;
      if (link) return link;
    }
    link = await storage.getItem(key);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error(err);
  }
  return link;
}

export function getCommonValuesInArrays<T = string | number | boolean>(arr1: T[], arr2: T[]): T[] {
  return arr1.filter((value) => arr2.includes(value));
}

export function getSearchParamFromURL(url: string, param: any) {
  const include = url.includes(param);
  if (!include) return null;
  const params = url.split(/([&,?,=])/);
  const index = params.indexOf(param);
  const value = params[index + 2];
  return value;
}

export function uuidv4() {
  if (typeof crypto !== "undefined" && crypto?.randomUUID) {
    return crypto.randomUUID();
  }

  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;

    return v.toString(16);
  });
}

export function isTestRun() {
  return typeof process !== "undefined" && process.env.IS_VITEST === "true";
}

export function isTelegram() {
  return (
    typeof window !== "undefined" &&
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Boolean((window as any).TelegramWebviewProxy) ||
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Boolean((window as any).Telegram) ||
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Boolean((window as any).TelegramWebviewProxyProto))
  );
}

export function isIframe() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}

export function toBase64(input: string, removePadding = false): string {
  const encoded = Buffer.from(input).toString("base64");
  return removePadding ? encoded.replace(/[=]/g, "") : encoded;
}

export function fromBase64(encodedString: string): string {
  return Buffer.from(encodedString, "base64").toString("utf-8");
}

export function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="packages/utils/src/namespaces.ts">
import { ProposalTypes, SessionTypes } from "@walletconnect/types";
import { mergeArrays } from "./misc";
import { isConformingNamespaces, isValidNamespaces, isValidObject } from "./validators";

export function getAccountsChains(accounts: SessionTypes.Namespace["accounts"]) {
  const chains: string[] = [];
  accounts.forEach((account) => {
    const [chain, chainId] = account.split(":");
    chains.push(`${chain}:${chainId}`);
  });

  return chains;
}

export function getNamespacesChains(namespaces: SessionTypes.Namespaces) {
  const chains: string[] = [];
  Object.values(namespaces).forEach((namespace) => {
    chains.push(...getAccountsChains(namespace.accounts));
  });

  return chains;
}

export function getNamespacesMethodsForChainId(
  namespaces: SessionTypes.Namespaces,
  chainId: string,
) {
  const methods: SessionTypes.Namespace["methods"] = [];
  Object.values(namespaces).forEach((namespace) => {
    const chains = getAccountsChains(namespace.accounts);
    if (chains.includes(chainId)) methods.push(...namespace.methods);
  });

  return methods;
}

export function getNamespacesEventsForChainId(
  namespaces: SessionTypes.Namespaces,
  chainId: string,
) {
  const events: SessionTypes.Namespace["events"] = [];
  Object.values(namespaces).forEach((namespace) => {
    const chains = getAccountsChains(namespace.accounts);
    if (chains.includes(chainId)) events.push(...namespace.events);
  });

  return events;
}

export function getRequiredNamespacesFromNamespaces(
  namespaces: SessionTypes.Namespaces,
  caller: string,
): ProposalTypes.RequiredNamespaces {
  const validNamespacesError = isValidNamespaces(namespaces, caller);
  if (validNamespacesError) throw new Error(validNamespacesError.message);

  const required: ProposalTypes.RequiredNamespaces = {};
  for (const [namespace, values] of Object.entries(namespaces)) {
    required[namespace] = {
      methods: values.methods,
      events: values.events,
      chains: values.accounts.map((account) => `${account.split(":")[0]}:${account.split(":")[1]}`),
    };
  }
  return required;
}

export type BuildApprovedNamespacesParams = {
  proposal: ProposalTypes.Struct;
  supportedNamespaces: Record<
    string,
    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }
  >;
};

/**
 * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.
 * It takes required & optional namespaces provided in the session proposal
 * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object
 * @param {BuildApprovedNamespacesParams} params
 * @returns {SessionTypes.Namespaces}
 */
export function buildApprovedNamespaces(
  params: BuildApprovedNamespacesParams,
): SessionTypes.Namespaces {
  const {
    proposal: { requiredNamespaces, optionalNamespaces = {} },
    supportedNamespaces,
  } = params;
  const normalizedRequired = normalizeNamespaces(requiredNamespaces);
  const normalizedOptional = normalizeNamespaces(optionalNamespaces);

  // build approved namespaces
  const namespaces: SessionTypes.Namespaces = {};
  Object.keys(supportedNamespaces).forEach((namespace) => {
    const supportedChains = supportedNamespaces[namespace].chains;
    const supportedMethods = supportedNamespaces[namespace].methods;
    const supportedEvents = supportedNamespaces[namespace].events;
    const supportedAccounts = supportedNamespaces[namespace].accounts;

    supportedChains.forEach((chain) => {
      if (!supportedAccounts.some((account) => account.includes(chain))) {
        throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);
      }
    });

    namespaces[namespace] = {
      chains: supportedChains,
      methods: supportedMethods,
      events: supportedEvents,
      accounts: supportedAccounts,
    };
  });

  // verify all required namespaces are supported
  const err = isConformingNamespaces(requiredNamespaces, namespaces, "approve()");
  if (err) throw new Error(err.message);

  const approvedNamespaces: SessionTypes.Namespaces = {};

  // if both required & optional namespaces are empty, return all supported namespaces by the wallet
  if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)
    return namespaces;

  // assign accounts for the required namespaces
  Object.keys(normalizedRequired).forEach((requiredNamespace) => {
    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>
      normalizedRequired[requiredNamespace]?.chains?.includes(chain),
    );
    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>
      normalizedRequired[requiredNamespace]?.methods?.includes(method),
    );
    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>
      normalizedRequired[requiredNamespace]?.events?.includes(event),
    );

    const accounts = chains
      .map((chain: string) =>
        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>
          account.includes(`${chain}:`),
        ),
      )
      .flat();

    approvedNamespaces[requiredNamespace] = {
      chains,
      methods,
      events,
      accounts,
    };
  });

  // add optional namespaces
  Object.keys(normalizedOptional).forEach((optionalNamespace) => {
    if (!supportedNamespaces[optionalNamespace]) return;

    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>
      supportedNamespaces[optionalNamespace].chains.includes(chain),
    );
    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>
      normalizedOptional[optionalNamespace]?.methods?.includes(method),
    );
    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>
      normalizedOptional[optionalNamespace]?.events?.includes(event),
    );

    const accountsToAdd = chainsToAdd
      ?.map((chain: string) =>
        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>
          account.includes(`${chain}:`),
        ),
      )
      .flat();

    approvedNamespaces[optionalNamespace] = {
      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),
      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),
      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),
      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),
    };
  });

  return approvedNamespaces;
}

export function isCaipNamespace(namespace: string): boolean {
  return namespace.includes(":");
}

export function parseNamespaceKey(namespace: string) {
  return isCaipNamespace(namespace) ? namespace.split(":")[0] : namespace;
}

/**
 * Converts
 * ```
 * {
 *  "eip155:1": {...},
 *  "eip155:2": {...},
 * }
 * ```
 * into
 * ```
 * {
 *  "eip155": {
 *      chains: ["eip155:1", "eip155:2"],
 *      ...
 *    }
 * }
 *```
 */
export function normalizeNamespaces(
  namespaces: ProposalTypes.RequiredNamespaces,
): ProposalTypes.RequiredNamespaces {
  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;
  if (!isValidObject(namespaces)) return normalizedNamespaces;
  for (const [key, values] of Object.entries(namespaces)) {
    const chains = isCaipNamespace(key) ? [key] : values.chains;
    const methods = values.methods || [];
    const events = values.events || [];
    const normalizedKey = parseNamespaceKey(key);
    normalizedNamespaces[normalizedKey] = {
      ...normalizedNamespaces[normalizedKey],
      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),
      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),
      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),
    };
  }
  return normalizedNamespaces;
}

export function getNamespacesFromAccounts(accounts: string[]) {
  const namespaces: SessionTypes.Namespaces = {};
  accounts?.forEach((account) => {
    const [namespace, chainId] = account.split(":");
    if (!namespaces[namespace]) {
      namespaces[namespace] = {
        accounts: [],
        chains: [],
        events: [],
        methods: [],
      };
    }
    namespaces[namespace].accounts.push(account);
    namespaces[namespace].chains?.push(`${namespace}:${chainId}`);
  });

  return namespaces;
}

export function buildNamespacesFromAuth(methods: string[], accounts: string[]) {
  accounts = accounts.map((account) => account.replace("did:pkh:", ""));

  const namespaces = getNamespacesFromAccounts(accounts);

  for (const [_, values] of Object.entries(namespaces) as [string, SessionTypes.Namespace][]) {
    if (!values.methods) {
      values.methods = methods;
    } else {
      values.methods = mergeArrays(values.methods, methods);
    }
    values.events = ["chainChanged", "accountsChanged"];
  }
  return namespaces;
}
</file>

<file path="packages/utils/src/network.ts">
import { getEnvironment, ENV_MAP, isBrowser, isReactNative } from "./misc";

export function isOnline(): Promise<boolean> {
  const env = getEnvironment();
  return new Promise((resolve) => {
    switch (env) {
      case ENV_MAP.browser:
        resolve(getBrowserOnlineStatus());
        break;
      case ENV_MAP.reactNative:
        resolve(getReactNativeOnlineStatus());
        break;
      case ENV_MAP.node:
        resolve(getNodeOnlineStatus());
        break;
      default:
        resolve(true);
    }
  });
}

export function getBrowserOnlineStatus() {
  return isBrowser() && navigator?.onLine;
}

export async function getReactNativeOnlineStatus(): Promise<boolean> {
  // global.NetInfo is set in react-native-compat
  if (isReactNative() && typeof global !== "undefined" && (global as any)?.NetInfo) {
    const state = await (global as any)?.NetInfo.fetch();
    return state?.isConnected;
  }
  // fallback to true if global.NetInfo is undefined, meaning an older version of react-native-compat is used
  return true;
}

export function getNodeOnlineStatus() {
  /**
   * TODO: need to implement
   */
  return true;
}

export function subscribeToNetworkChange(callbackHandler: (connected: boolean) => void) {
  const env = getEnvironment();
  switch (env) {
    case ENV_MAP.browser:
      subscribeToBrowserNetworkChange(callbackHandler);
      break;
    case ENV_MAP.reactNative:
      subscribeToReactNativeNetworkChange(callbackHandler);
      break;
    case ENV_MAP.node:
      // wip: need to implement
      break;
    default:
      break;
  }
}

export function subscribeToBrowserNetworkChange(callbackHandler: (connected: boolean) => void) {
  if (!isReactNative() && isBrowser()) {
    window.addEventListener("online", () => callbackHandler(true));
    window.addEventListener("offline", () => callbackHandler(false));
  }
}

// global.NetInfo is set in react-native-compat
export function subscribeToReactNativeNetworkChange(callbackHandler: (connected: boolean) => void) {
  if (isReactNative() && typeof global !== "undefined" && (global as any)?.NetInfo) {
    (global as any)?.NetInfo.addEventListener((state: any) => callbackHandler(state?.isConnected));
  }
}
</file>

<file path="packages/utils/src/relay.ts">
import { RELAY_JSONRPC } from "@walletconnect/relay-api";
import { RelayerTypes } from "@walletconnect/types";

export const RELAYER_DEFAULT_PROTOCOL = "irn";

export function getRelayProtocolName(
  opts?: RelayerTypes.RequestOptions,
): RelayerTypes.ProtocolOptions {
  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };
}

export function getRelayProtocolApi(protocol: string) {
  const jsonrpc = RELAY_JSONRPC[protocol];
  if (typeof jsonrpc === "undefined") {
    throw new Error(`Relay Protocol not supported: ${protocol}`);
  }
  return jsonrpc;
}
</file>

<file path="packages/utils/src/signatures.ts">
import { keccak_256 } from "@noble/hashes/sha3";
import { recoverAddress } from "viem";
import { AuthTypes } from "@walletconnect/types";
import bs58 from "bs58";

import { parseChainId } from "./caip";

const DEFAULT_RPC_URL = "https://rpc.walletconnect.org/v1";

export function hashEthereumMessage(message: string) {
  const prefix = `\x19Ethereum Signed Message:\n${message.length}`;
  const prefixedMessage = new TextEncoder().encode(prefix + message);
  return "0x" + Buffer.from(keccak_256(prefixedMessage)).toString("hex");
}

export async function verifySignature(
  address: string,
  reconstructedMessage: string,
  cacaoSignature: AuthTypes.CacaoSignature,
  chainId: string,
  projectId: string,
  baseRpcUrl?: string,
): Promise<boolean> {
  // Determine if this signature is from an EOA or a contract.
  switch (cacaoSignature.t) {
    case "eip191":
      return await isValidEip191Signature(address, reconstructedMessage, cacaoSignature.s);
    case "eip1271":
      return await isValidEip1271Signature(
        address,
        reconstructedMessage,
        cacaoSignature.s,
        chainId,
        projectId,
        baseRpcUrl,
      );
      break;
    default:
      throw new Error(
        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${cacaoSignature.t}`,
      );
  }
}

export async function isValidEip191Signature(
  address: string,
  message: string,
  signature: string,
): Promise<boolean> {
  const recoveredAddress = await recoverAddress({
    hash: hashEthereumMessage(message) as `0x${string}`,
    signature: signature as `0x${string}`,
  });
  return recoveredAddress.toLowerCase() === address.toLowerCase();
}

export async function isValidEip1271Signature(
  address: string,
  reconstructedMessage: string,
  signature: string,
  chainId: string,
  projectId: string,
  baseRpcUrl?: string,
) {
  const parsedChain = parseChainId(chainId);
  if (!parsedChain.namespace || !parsedChain.reference) {
    throw new Error(
      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${chainId}`,
    );
  }
  try {
    const eip1271MagicValue = "0x1626ba7e";
    const dynamicTypeOffset = "0000000000000000000000000000000000000000000000000000000000000040";
    const dynamicTypeLength = "0000000000000000000000000000000000000000000000000000000000000041";
    const nonPrefixedSignature = signature.substring(2);
    const nonPrefixedHashedMessage = hashEthereumMessage(reconstructedMessage).substring(2);

    const data =
      eip1271MagicValue +
      nonPrefixedHashedMessage +
      dynamicTypeOffset +
      dynamicTypeLength +
      nonPrefixedSignature;
    const response = await fetch(
      `${baseRpcUrl || DEFAULT_RPC_URL}/?chainId=${chainId}&projectId=${projectId}`,
      {
        method: "POST",
        body: JSON.stringify({
          id: generateJsonRpcId(),
          jsonrpc: "2.0",
          method: "eth_call",
          params: [{ to: address, data }, "latest"],
        }),
      },
    );
    const { result } = await response.json();
    if (!result) return false;

    // Remove right-padded zeros from result to get only the concrete recovered value.
    const recoveredValue = result.slice(0, eip1271MagicValue.length);
    return recoveredValue.toLowerCase() === eip1271MagicValue.toLowerCase();
  } catch (error: any) {
    // eslint-disable-next-line no-console
    console.error("isValidEip1271Signature: ", error);
    return false;
  }
}

function generateJsonRpcId() {
  return Date.now() + Math.floor(Math.random() * 1000);
}

export function extractSolanaTransactionId(solanaTransaction: string): string {
  const binary = atob(solanaTransaction);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }

  // Check signature count (first byte)
  const signatureCount = bytes[0];
  if (signatureCount === 0) {
    throw new Error("No signatures found");
  }

  // Verify we have enough bytes for all signatures
  // Each signature is 64 bytes
  const signatureEndPos = 1 + signatureCount * 64;
  if (bytes.length < signatureEndPos) {
    throw new Error("Transaction data too short for claimed signature count");
  }

  // A transaction must have at least some minimum length
  if (bytes.length < 100) {
    throw new Error("Transaction too short");
  }

  const transactionBuffer = Buffer.from(solanaTransaction, "base64");

  const signatureBuffer = transactionBuffer.slice(1, 65);

  return bs58.encode(signatureBuffer);
}
</file>

<file path="packages/utils/src/uri.ts">
import { EngineTypes, RelayerTypes } from "@walletconnect/types";
import { fromBase64 } from "./misc";

// -- uri -------------------------------------------------- //

export function parseRelayParams(params: any, delimiter = "-"): RelayerTypes.ProtocolOptions {
  const relay: any = {};
  const prefix = "relay" + delimiter;
  Object.keys(params).forEach((key) => {
    if (key.startsWith(prefix)) {
      const name = key.replace(prefix, "");
      const value = params[key];
      relay[name] = value;
    }
  });
  return relay;
}

export function parseUri(str: string): EngineTypes.UriParameters {
  if (!str.includes("wc:")) {
    const parsed = fromBase64(str);
    if (parsed?.includes("wc:")) {
      str = parsed;
    }
  }

  // remove android schema prefix
  str = str.includes("wc://") ? str.replace("wc://", "") : str;
  // remove ios schema prefix
  str = str.includes("wc:") ? str.replace("wc:", "") : str;
  const pathStart: number = str.indexOf(":");
  const pathEnd: number | undefined = str.indexOf("?") !== -1 ? str.indexOf("?") : undefined;
  const protocol: string = str.substring(0, pathStart);
  const path: string = str.substring(pathStart + 1, pathEnd);
  const requiredValues = path.split("@");
  const queryString: string = typeof pathEnd !== "undefined" ? str.substring(pathEnd) : "";
  const urlSearchParams = new URLSearchParams(queryString);
  const queryParams: Record<string, string> = {};
  urlSearchParams.forEach((value, key) => {
    queryParams[key] = value;
  });
  const methods =
    typeof queryParams.methods === "string" ? queryParams.methods.split(",") : undefined;
  const result = {
    protocol,
    topic: parseTopic(requiredValues[0]),
    version: parseInt(requiredValues[1], 10),
    symKey: queryParams.symKey as string,
    relay: parseRelayParams(queryParams),
    methods,
    expiryTimestamp: queryParams.expiryTimestamp
      ? parseInt(queryParams.expiryTimestamp as string, 10)
      : undefined,
  };
  return result;
}

export function parseTopic(topic: string): string {
  return topic.startsWith("//") ? topic.substring(2) : topic;
}

export function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = "-") {
  const prefix = "relay";
  const params: any = {};
  Object.keys(relay).forEach((key) => {
    const typedKey = key as keyof typeof relay;
    const k = prefix + delimiter + typedKey;
    if (relay[typedKey]) {
      params[k] = relay[typedKey];
    }
  });
  return params;
}

export function formatUri(params: EngineTypes.UriParameters): string {
  const urlSearchParams = new URLSearchParams();

  const relayParams = formatRelayParams(params.relay);
  Object.keys(relayParams)
    .sort()
    .forEach((key) => {
      urlSearchParams.set(key, relayParams[key]);
    });

  urlSearchParams.set("symKey", params.symKey);
  if (params.expiryTimestamp)
    urlSearchParams.set("expiryTimestamp", params.expiryTimestamp.toString());

  if (params.methods) {
    urlSearchParams.set("methods", params.methods.join(","));
  }

  const queryString = urlSearchParams.toString();
  return `${params.protocol}:${params.topic}@${params.version}?${queryString}`;
}

export function getLinkModeURL(
  universalLink: string,
  topic: string,
  encodedEnvelope: string,
): string {
  return `${universalLink}?wc_ev=${encodedEnvelope}&topic=${topic}`;
}
</file>

<file path="packages/utils/src/validators.ts">
import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from "@walletconnect/types";
import { ErrorResponse } from "@walletconnect/jsonrpc-types";
import {
  getNamespacesChains,
  getNamespacesMethodsForChainId,
  getNamespacesEventsForChainId,
  getAccountsChains,
} from "./namespaces";
import { getSdkError, getInternalError } from "./errors";
import { fromBase64, hasOverlap } from "./misc";
import { getChainsFromNamespace } from "./caip";

export type ErrorObject = { message: string; code: number } | null;

// -- types validation ----------------------------------------------------- //

export function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {
  if (Array.isArray(arr)) {
    if (typeof itemCondition !== "undefined" && arr.length) {
      return arr.every(itemCondition);
    } else {
      return true;
    }
  }
  return false;
}

export function isValidObject(obj: any) {
  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;
}

export function isUndefined(input: any): input is undefined {
  return typeof input === "undefined";
}

export function isValidString(input: any, optional: boolean): input is string {
  if (optional && isUndefined(input)) return true;

  return typeof input === "string" && Boolean(input.trim().length);
}

export function isValidNumber(input: any, optional: boolean) {
  if (optional && isUndefined(input)) return true;

  return typeof input === "number" && !isNaN(input);
}

// -- protocol validation -------------------------------------------------- //

export function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {
  const { requiredNamespaces } = params;
  const sessionKeys = Object.keys(session.namespaces);
  const paramsKeys = Object.keys(requiredNamespaces);
  let compatible = true;

  if (!hasOverlap(paramsKeys, sessionKeys)) return false;

  sessionKeys.forEach((key) => {
    const { accounts, methods, events } = session.namespaces[key];
    const chains = getAccountsChains(accounts);
    const requiredNamespace = requiredNamespaces[key];
    if (
      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||
      !hasOverlap(requiredNamespace.methods, methods) ||
      !hasOverlap(requiredNamespace.events, events)
    ) {
      compatible = false;
    }
  });

  return compatible;
}

export function isValidChainId(value: any) {
  if (isValidString(value, false) && value.includes(":")) {
    const split = value.split(":");
    return split.length === 2;
  }
  return false;
}

export function isValidAccountId(value: any) {
  if (isValidString(value, false) && value.includes(":")) {
    const split = value.split(":");
    if (split.length === 3) {
      const chainId = split[0] + ":" + split[1];
      return !!split[2] && isValidChainId(chainId);
    }
  }
  return false;
}

export function isValidUrl(value: any) {
  function validateUrl(blob: string) {
    try {
      const url = new URL(blob);
      return typeof url !== "undefined";
    } catch (e) {
      return false;
    }
  }
  try {
    if (isValidString(value, false)) {
      const isValid = validateUrl(value);
      if (isValid) return true;

      const decoded = fromBase64(value);
      return validateUrl(decoded);
    }
  } catch (e) {}
  return false;
}

export function isProposalStruct(input: any): input is ProposalTypes.Struct {
  return input?.proposer?.publicKey;
}

export function isSessionStruct(input: any): input is SessionTypes.Struct {
  return input?.topic;
}

export function isValidController(input: any, method: string) {
  let error: ErrorObject = null;
  if (!isValidString(input?.publicKey, false)) {
    error = getInternalError(
      "MISSING_OR_INVALID",
      `${method} controller public key should be a string`,
    );
  }

  return error;
}

export function isValidNamespaceMethodsOrEvents(input: any): input is string {
  let valid = true;
  if (isValidArray(input)) {
    if (input.length) {
      valid = input.every((item: any) => isValidString(item, false));
    }
  } else {
    valid = false;
  }

  return valid;
}

export function isValidChains(key: string, chains: any, context: string) {
  let error: ErrorObject = null;

  if (isValidArray(chains) && chains.length) {
    chains.forEach((chain: any) => {
      if (error) return;
      if (!isValidChainId(chain)) {
        error = getSdkError(
          "UNSUPPORTED_CHAINS",
          `${context}, chain ${chain} should be a string and conform to "namespace:chainId" format`,
        );
      }
    });
  } else if (!isValidChainId(key)) {
    error = getSdkError(
      "UNSUPPORTED_CHAINS",
      `${context}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`,
    );
  }

  return error;
}

export function isValidNamespaceChains(namespaces: any, method: string, type: string) {
  let error: ErrorObject = null;
  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {
    if (error) return;
    const validChainsError = isValidChains(
      key,
      getChainsFromNamespace(key, namespace),
      `${method} ${type}`,
    );
    if (validChainsError) {
      error = validChainsError;
    }
  });

  return error;
}

export function isValidAccounts(accounts: any, context: string) {
  let error: ErrorObject = null;
  if (isValidArray(accounts)) {
    accounts.forEach((account: any) => {
      if (error) return;
      if (!isValidAccountId(account)) {
        error = getSdkError(
          "UNSUPPORTED_ACCOUNTS",
          `${context}, account ${account} should be a string and conform to "namespace:chainId:address" format`,
        );
      }
    });
  } else {
    error = getSdkError(
      "UNSUPPORTED_ACCOUNTS",
      `${context}, accounts should be an array of strings conforming to "namespace:chainId:address" format`,
    );
  }

  return error;
}

export function isValidNamespaceAccounts(input: any, method: string) {
  let error: ErrorObject = null;
  Object.values(input).forEach((namespace: any) => {
    if (error) return;
    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);
    if (validAccountsError) {
      error = validAccountsError;
    }
  });

  return error;
}

export function isValidActions(namespace: any, context: string) {
  let error: ErrorObject = null;
  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {
    error = getSdkError(
      "UNSUPPORTED_METHODS",
      `${context}, methods should be an array of strings or empty array for no methods`,
    );
  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {
    error = getSdkError(
      "UNSUPPORTED_EVENTS",
      `${context}, events should be an array of strings or empty array for no events`,
    );
  }

  return error;
}

export function isValidNamespaceActions(input: any, method: string) {
  let error: ErrorObject = null;
  Object.values(input).forEach((namespace: any) => {
    if (error) return;
    const validActionsError = isValidActions(namespace, `${method}, namespace`);
    if (validActionsError) {
      error = validActionsError;
    }
  });

  return error;
}

export function isValidRequiredNamespaces(input: any, method: string, type: string) {
  let error: ErrorObject = null;
  if (input && isValidObject(input)) {
    const validActionsError = isValidNamespaceActions(input, method);
    if (validActionsError) {
      error = validActionsError;
    }
    const validChainsError = isValidNamespaceChains(input, method, type);
    if (validChainsError) {
      error = validChainsError;
    }
  } else {
    error = getInternalError(
      "MISSING_OR_INVALID",
      `${method}, ${type} should be an object with data`,
    );
  }

  return error;
}

export function isValidNamespaces(input: any, method: string) {
  let error: ErrorObject = null;
  if (input && isValidObject(input)) {
    const validActionsError = isValidNamespaceActions(input, method);
    if (validActionsError) {
      error = validActionsError;
    }
    const validAccountsError = isValidNamespaceAccounts(input, method);
    if (validAccountsError) {
      error = validAccountsError;
    }
  } else {
    error = getInternalError(
      "MISSING_OR_INVALID",
      `${method}, namespaces should be an object with data`,
    );
  }

  return error;
}

export function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {
  return isValidString(input.protocol, true);
}

export function isValidRelays(
  input: any,
  optional: boolean,
): input is RelayerTypes.ProtocolOptions[] {
  let valid = false;

  if (optional && !input) valid = true;
  else if (input && isValidArray(input) && input.length) {
    input.forEach((relay: RelayerTypes.ProtocolOptions) => {
      valid = isValidRelay(relay);
    });
  }

  return valid;
}

export function isValidId(input: any) {
  return typeof input === "number";
}

export function isValidParams(input: any) {
  // eslint-disable-next-line valid-typeof
  return typeof input !== "undefined" && typeof input !== null;
}

export function isValidErrorReason(input: any): input is ErrorResponse {
  if (!input) return false;
  if (typeof input !== "object") return false;
  if (!input.code || !isValidNumber(input.code, false)) return false;
  if (!input.message || !isValidString(input.message, false)) return false;

  return true;
}

export function isValidRequest(request: any) {
  if (isUndefined(request)) return false;
  if (!isValidString(request.method, false)) return false;
  return true;
}

export function isValidResponse(response: any) {
  if (isUndefined(response)) return false;
  if (isUndefined(response.result) && isUndefined(response.error)) return false;
  if (!isValidNumber(response.id, false)) return false;
  if (!isValidString(response.jsonrpc, false)) return false;
  return true;
}

export function isValidEvent(event: any) {
  if (isUndefined(event)) return false;
  if (!isValidString(event.name, false)) return false;
  return true;
}

export function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {
  if (!isValidChainId(chainId)) return false;
  const chains = getNamespacesChains(namespaces);
  if (!chains.includes(chainId)) return false;

  return true;
}

export function isValidNamespacesRequest(
  namespaces: SessionTypes.Namespaces,
  chainId: string,
  method: string,
) {
  if (!isValidString(method, false)) return false;
  const methods = getNamespacesMethodsForChainId(namespaces, chainId);
  return methods.includes(method);
}

export function isValidNamespacesEvent(
  namespaces: SessionTypes.Namespaces,
  chainId: string,
  eventName: string,
) {
  if (!isValidString(eventName, false)) return false;
  const events = getNamespacesEventsForChainId(namespaces, chainId);
  return events.includes(eventName);
}

export function isConformingNamespaces(
  requiredNamespaces: ProposalTypes.RequiredNamespaces,
  namespaces: SessionTypes.Namespaces,
  context: string,
) {
  let error: ErrorObject = null;

  const parsedRequired = parseNamespaces(requiredNamespaces);
  const parsedApproved = parseApprovedNamespaces(namespaces);
  const requiredChains = Object.keys(parsedRequired);
  const approvedChains = Object.keys(parsedApproved);

  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));
  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));
  const missingRequiredNamespaces = uniqueRequired.filter(
    (namespace) => !uniqueApproved.includes(namespace),
  );

  if (missingRequiredNamespaces.length) {
    error = getInternalError(
      "NON_CONFORMING_NAMESPACES",
      `${context} namespaces keys don't satisfy requiredNamespaces.
      Required: ${missingRequiredNamespaces.toString()}
      Received: ${Object.keys(namespaces).toString()}`,
    );
  }

  if (!hasOverlap(requiredChains, approvedChains)) {
    error = getInternalError(
      "NON_CONFORMING_NAMESPACES",
      `${context} namespaces chains don't satisfy required namespaces.
      Required: ${requiredChains.toString()}
      Approved: ${approvedChains.toString()}`,
    );
  }

  // validate inline defined chains with approved accounts
  Object.keys(namespaces).forEach((chain) => {
    if (!chain.includes(":")) return;
    if (error) return;
    const chains = getAccountsChains(namespaces[chain].accounts);
    if (!chains.includes(chain)) {
      error = getInternalError(
        "NON_CONFORMING_NAMESPACES",
        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}
        Required: ${chain}
        Approved: ${chains.toString()}`,
      );
    }
  });

  requiredChains.forEach((chain) => {
    if (error) return;

    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {
      error = getInternalError(
        "NON_CONFORMING_NAMESPACES",
        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,
      );
    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {
      error = getInternalError(
        "NON_CONFORMING_NAMESPACES",
        `${context} namespaces events don't satisfy namespace events for ${chain}`,
      );
    }
  });

  return error;
}

function parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {
  const parsed: ProposalTypes.RequiredNamespaces = {};
  Object.keys(namespaces).forEach((key) => {
    // e.g. `eip155:1`
    const isInlineChainDefinition = key.includes(":");

    if (isInlineChainDefinition) {
      parsed[key] = namespaces[key];
    } else {
      namespaces[key].chains?.forEach((chain) => {
        parsed[chain] = {
          methods: namespaces[key].methods,
          events: namespaces[key].events,
        };
      });
    }
  });
  return parsed;
}

function filterDuplicateNamespaces(namespaces: string[]) {
  return [
    ...new Set(
      namespaces.map((namespace) =>
        namespace.includes(":") ? namespace.split(":")[0] : namespace,
      ),
    ),
  ];
}

function parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {
  const parsed: SessionTypes.Namespaces = {};
  Object.keys(namespaces).forEach((key) => {
    const isInlineChainDefinition = key.includes(":");
    if (isInlineChainDefinition) {
      parsed[key] = namespaces[key];
    } else {
      const chains = getAccountsChains(namespaces[key].accounts);
      chains?.forEach((chain) => {
        parsed[chain] = {
          accounts: namespaces[key].accounts.filter((account: string) =>
            account.includes(`${chain}:`),
          ),
          methods: namespaces[key].methods,
          events: namespaces[key].events,
        };
      });
    }
  });
  return parsed;
}

export function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {
  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;
}
</file>

<file path="packages/utils/test/shared/index.ts">
export * from "./values";
</file>

<file path="packages/utils/test/shared/values.ts">
import { SignClientTypes, SessionTypes } from "@walletconnect/types";

export const TEST_PAIRING_TOPIC =
  "c9e6d30fb34afe70a15c14e9337ba8e4d5a35dd695c39b94884b0ee60c69d168";

export const TEST_SESSION_TOPIC =
  "f5d3f03946b6a2a3b22661fae1385cd1639bfb6f6c070115699b0a2ec1decd8c";

export const TEST_KEY_PAIRS = {
  A: {
    privateKey: "1fb63fca5c6ac731246f2f069d3bc2454345d5208254aa8ea7bffc6d110c8862",
    publicKey: "ff7a7d5767c362b0a17ad92299ebdb7831dcbd9a56959c01368c7404543b3342",
  },
  B: {
    privateKey: "36bf507903537de91f5e573666eaa69b1fa313974f23b2b59645f20fea505854",
    publicKey: "590c2c627be7af08597091ff80dd41f7fa28acd10ef7191d7e830e116d3a186a",
  },
};

export const TEST_SHARED_KEY = "9c87e48e69b33a613907515bcd5b1b4cc10bbaf15167b19804b00f0a9217e607";
export const TEST_HASHED_KEY = "a492906ccc809a411bb53a84572b57329375378c6ad7566f3e1c688200123e77";
export const TEST_SYM_KEY = "0653ca620c7b4990392e1c53c4a51c14a2840cd20f0f1524cf435b17b6fe988c";

export const TEST_RELAY_OPTIONS = {
  protocol: "irn",
  data: undefined,
};

export const TEST_SESSION_METADATA = {
  name: "My App",
  description: "App that requests wallet signature",
  url: "http://myapp.com",
  icons: ["http://myapp.com/logo.png"],
};

export const TEST_ETHEREUM_NAMESPACE = "eip155";

export const TEST_ETHEREUM_CHAIN_A = `${TEST_ETHEREUM_NAMESPACE}:1`;

export const TEST_ETHEREUM_CHAIN_B = `${TEST_ETHEREUM_NAMESPACE}:137`;

export const TEST_ETHEREUM_ADDRESS = ["0x1d85568eEAbad713fBB5293B45ea066e552A90De"];

export const TEST_ETHEREUM_ACCOUNT_A = `${TEST_ETHEREUM_CHAIN_A}:${TEST_ETHEREUM_ADDRESS}`;

export const TEST_ETHEREUM_ACCOUNT_B = `${TEST_ETHEREUM_CHAIN_B}:${TEST_ETHEREUM_ADDRESS}`;

export const TEST_CHAINS: string[] = [TEST_ETHEREUM_CHAIN_A, TEST_ETHEREUM_CHAIN_B];

export const TEST_ACCOUNTS: string[] = [TEST_ETHEREUM_ACCOUNT_A, TEST_ETHEREUM_ACCOUNT_B];

export const TEST_METHODS = ["personal_sign", "eth_signTypedData", "eth_sendTransaction"];

export const TEST_EVENTS = ["chainChanged", "accountsChanged"];

export const TEST_DATE_NOW = 1649874082376;

export const TEST_EXPIRY_1D = 1649960482376;

export const TEST_EXPIRY_7D = 1650478882376;

export const TEST_EXPIRY_30D = 1652466082376;

export const TEST_SESSION: SessionTypes.Struct = {
  expiry: TEST_EXPIRY_7D,
  topic: TEST_SESSION_TOPIC,
  relay: TEST_RELAY_OPTIONS,
  acknowledged: true,
  controller: TEST_KEY_PAIRS.A.publicKey,
  self: {
    publicKey: TEST_KEY_PAIRS.A.publicKey,
    metadata: TEST_SESSION_METADATA as SignClientTypes.Metadata,
  },
  peer: {
    publicKey: TEST_KEY_PAIRS.B.publicKey,
    metadata: TEST_SESSION_METADATA as SignClientTypes.Metadata,
  },
  requiredNamespaces: {
    [TEST_ETHEREUM_NAMESPACE]: {
      chains: TEST_CHAINS,
      methods: TEST_METHODS,
      events: TEST_EVENTS,
    },
  },
  namespaces: {
    [TEST_ETHEREUM_NAMESPACE]: {
      accounts: TEST_ACCOUNTS,
      methods: TEST_METHODS,
      events: TEST_EVENTS,
    },
  },
};
</file>

<file path="packages/utils/test/cacao.spec.ts">
import { describe, expect, it } from "vitest";
import {
  createEncodedRecap,
  createRecap,
  decodeRecap,
  encodeRecap,
  formatMessage,
  getChainsFromRecap,
  getCommonValuesInArrays,
  getDecodedRecapFromResources,
  getMethodsFromRecap,
  isValidRecap,
  mergeRecaps,
  populateAuthPayload,
} from "../src";

describe("URI", () => {
  describe("merge recaps", () => {
    it("should merge recaps", () => {
      const recap1 = {
        att: {
          "https://notify.walletconnect.com": { "manage/all-apps-notifications": [{}] },
        },
      };
      const recap2 = {
        att: {
          eip155: {
            "request/eth_chainId": [{}],
            "request/eth_signTypedData_v4": [{}],
            "request/personal_sign": [{}],
          },
        },
      };
      const recap = mergeRecaps(recap1, recap2);

      const expected = {
        att: {
          eip155: {
            "request/eth_chainId": [{}],
            "request/eth_signTypedData_v4": [{}],
            "request/personal_sign": [{}],
          },
          "https://notify.walletconnect.com": { "manage/all-apps-notifications": [{}] },
        },
      };
      expect(JSON.stringify(recap)).to.eql(JSON.stringify(expected));
    });
    it("should merge recaps with different keys", () => {
      const recap1 = createRecap("https://web3inbox.com", "push", ["notifications", "alerts"]);
      const recap2 = createRecap("eip155", "request", ["personal_sign", "eth_sendTransaction"]);
      const expected = {
        att: {
          eip155: {
            "request/eth_sendTransaction": [{}],
            "request/personal_sign": [{}],
          },
          "https://web3inbox.com": {
            "push/alerts": [{}],
            "push/notifications": [{}],
          },
        },
      };
      const mergedRecap = mergeRecaps(recap1, recap2);
      expect(JSON.stringify(mergedRecap)).to.eql(JSON.stringify(expected));
    });
    it("should merge recaps with same resource", () => {
      const recap1 = createRecap("eip155", "push", ["notifications", "alerts"]);
      const recap2 = createRecap("eip155", "request", ["personal_sign", "eth_sendTransaction"]);
      const expected = {
        att: {
          eip155: {
            "push/alerts": [{}],
            "push/notifications": [{}],
            "request/eth_sendTransaction": [{}],
            "request/personal_sign": [{}],
          },
        },
      };
      const mergedRecap = mergeRecaps(recap1, recap2);
      expect(JSON.stringify(mergedRecap)).to.eql(JSON.stringify(expected));
    });
    it("should merge recaps with same resource & actions", () => {
      const recap1 = createRecap("eip155", "request", ["personal_sign", "notifications"]);
      const recap2 = createRecap("eip155", "request", ["alerts", "eth_sendTransaction"]);
      const expected = {
        att: {
          eip155: {
            "request/alerts": [{}],
            "request/eth_sendTransaction": [{}],
            "request/notifications": [{}],
            "request/personal_sign": [{}],
          },
        },
      };
      const mergedRecap = mergeRecaps(recap1, recap2);
      expect(JSON.stringify(mergedRecap)).to.eql(JSON.stringify(expected));
    });
  });

  it("should encode recap", () => {
    const recap = createRecap("eip155", "request", ["personal_sign", "eth_signTypedData_v4"]);
    isValidRecap(recap);
    const encoded = encodeRecap(recap);
    expect(encoded).to.be.a("string");
    expect(encoded).to.include("urn:recap:");
    const decoded = decodeRecap(encoded);
    expect(decoded).to.eql(recap);
  });

  it("should get methods from recap DONE", () => {
    const recap = {
      att: {
        eip155: {
          "push/eth_signTypedData": [{}],
          "push/personal_sign": [{}],
        },
      },
    };

    const methods = getMethodsFromRecap(encodeRecap(recap));
    expect(methods).to.eql(["eth_signTypedData", "personal_sign"]);
  });

  it("should get chains from recap", () => {
    const recap = {
      att: {
        eip155: {
          "push/messages": [{ chains: ["eip155:1", "eip155:2"] }],
          "push/test": [{ chains: ["eip155:2", "eip155:3"] }],
        },
      },
    };
    const chains = getChainsFromRecap(encodeRecap(recap));
    expect(chains).to.eql(["eip155:1", "eip155:2", "eip155:3"]);
  });

  it("should find common values in two arrays", () => {
    const arr1 = ["eip155:1", "eip155:2"];
    const arr2 = ["eip155:1", "eip155:3"];
    const result = getCommonValuesInArrays(arr1, arr2);
    expect(result).to.eql(["eip155:1"]);
  });
  it("should get recap from resources", () => {
    const resources = [
      "https://example.com",
      "urn:recap:eyJhdHQiOnsiZWlwMTU1Ijp7InJlcXVlc3QvZXRoX2NoYWluSWQiOlt7fV0sInJlcXVlc3QvZXRoX3NpZ25UeXBlZERhdGFfdjQiOlt7fV0sInB1c2gvcGVyc29uYWxfc2lnbiI6W3t9XX0sImh0dHBzOi8vbm90aWZ5LndhbGxldGNvbm5lY3QuY29tIjp7Im1hbmFnZS9hbGwtYXBwcy1ub3RpZmljYXRpb25zIjpbe31dLCJlbWl0L2FsZXJ0cyI6W3t9XX19fQ==",
    ];
    const result = getDecodedRecapFromResources(resources);
    expect(result).to.exist;
    expect(result).to.be.an("object");

    const expectFail = ["https://example.com"];
    const resFail = getDecodedRecapFromResources(expectFail);
    expect(resFail).to.eql(undefined);
  });
  it("should populate authPayload with supported chains/methods", () => {
    const encoded = createEncodedRecap("eip155", "request", [
      "personal_sign",
      "eth_signTypedData_v4",
    ]);

    const requestedChains = ["eip155:1", "eip155:2"];
    const authPayload = {
      chains: requestedChains,
      aud: "aud",
      domain: "localhost",
      version: "1",
      nonce: "1",
      iat: "2023-12-14T08:48:37.902Z",
      resources: ["https://example.com", encoded],
    };

    const supportedChains = ["eip155:2", "eip155:3"];
    const supportedMethods = ["personal_sign", "eth_signTypedData"];
    const updatedAuthPayload = populateAuthPayload({
      authPayload,
      chains: supportedChains,
      methods: supportedMethods,
    });

    const approvedChains = ["eip155:2"];
    expect(updatedAuthPayload.chains).to.eql(approvedChains);
    const recap = getDecodedRecapFromResources(updatedAuthPayload.resources);
    expect(recap).to.exist;
    isValidRecap(recap);

    const approvedMethods = ["personal_sign"];
    expect(getMethodsFromRecap(encodeRecap(recap))).to.eql(approvedMethods);
  });

  it("should populate authPayload with supported chains/methods for siwe", () => {
    const requestedChains = ["eip155:1", "eip155:2"];
    const authPayload = {
      chains: requestedChains,
      aud: "aud",
      domain: "localhost",
      version: "1",
      nonce: "1",
      iat: "2023-12-14T08:48:37.902Z",
      resources: [
        "https://example.com",
        "urn:recap:eyJhdHQiOnsiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    };

    const supportedChains = ["eip155:2", "eip155:3"];
    const supportedMethods = ["personal_sign", "eth_signTypedData"];
    const updatedAuthPayload = populateAuthPayload({
      authPayload,
      chains: supportedChains,
      methods: supportedMethods,
    });

    const approvedChains = ["eip155:2"];
    expect(updatedAuthPayload.chains).to.eql(approvedChains);
    const recap = getDecodedRecapFromResources(updatedAuthPayload.resources);
    expect(recap).to.exist;
    isValidRecap(recap);

    // it's siwe so no methods should be added
    const approvedMethods = [];
    expect(getMethodsFromRecap(encodeRecap(recap))).to.eql(approvedMethods);
  });

  it("should numerate unique recap abilities correctly", () => {
    const request = {
      type: "caip122",
      chains: ["eip155:1"],
      statement: "I accept the ServiceOrg Terms of Service: https://app.web3inbox.com/tos",
      aud: "https://app.web3inbox.com/login",
      domain: "app.web3inbox",
      version: "1",
      nonce: "32891756",
      iat: "2024-03-13T09:00:43.888Z",
      resources: [
        "urn:recap:eyJhdHQiOnsiZWlwMTU1Ijp7InJlcXVlc3QvZXRoX3NlbmRUcmFuc2FjdGlvbiI6W3t9XSwicmVxdWVzdC9wZXJzb25hbF9zaWduIjpbe31dfSwiaHR0cHM6Ly9ub3RpZnkud2FsbGV0Y29ubmVjdC5jb20iOnsibWFuYWdlL2FsbC1hcHBzLW5vdGlmaWNhdGlvbnMiOlt7fV19fX0",
      ],
    };

    const message = formatMessage(
      request,
      "did:pkh:eip155:1:0x3613699A6c5D8BC97a08805876c8005543125F09",
    );

    // the above resources[] should produce 2 capability statements
    expect(message).to.include("(1)");
    expect(message).to.include("(2)");
    expect(message).to.include(
      "I further authorize the stated URI to perform the following actions on my behalf: (1) 'request': 'eth_sendTransaction', 'personal_sign' for 'eip155'. (2) 'manage': 'all-apps-notifications' for 'https://notify.walletconnect.com'.",
    );

    expect(message).to.include("Version: 1");
    expect(message).to.include("Nonce: 32891756");
    expect(message).to.include(`URI: ${request.aud}`);
  });
  describe("resources", () => {
    it("should not add resources to siwe message when missing from request", () => {
      const request = {
        type: "caip122",
        chains: ["eip155:1"],
        aud: "https://example.com",
        domain: "http://localhost:3000",
        version: "1",
        nonce: "1",
        iat: "2024-02-19T09:29:21.394Z",
        statement: "Requesting access to your account",
      };

      const message = formatMessage(
        request as any,
        "did:pkh:eip155:1:0x3613699A6c5D8BC97a08805876c8005543125F09",
      );

      expect(message).to.include("Version: 1");
      expect(message).to.include("Nonce: 1");
      expect(message).to.include(`URI: ${request.aud}`);
      expect(message).to.not.include(`Resources:`);
    });
    it("should add resources to siwe message when is empty array DONE", () => {
      const request = {
        type: "caip122",
        chains: ["eip155:1"],
        aud: "https://example.com",
        domain: "http://localhost:3000",
        version: "1",
        nonce: "1",
        iat: "2024-02-19T09:29:21.394Z",
        statement: "Requesting access to your account",
        resources: [],
      };

      const message = formatMessage(
        request as any,
        "did:pkh:eip155:1:0x3613699A6c5D8BC97a08805876c8005543125F09",
      );

      expect(message).to.include("Version: 1");
      expect(message).to.include("Nonce: 1");
      expect(message).to.include(`URI: ${request.aud}`);
      expect(message).to.include(`Resources:`);
    });

    it("should add resources items to siwe message DONE", () => {
      const request = {
        type: "caip122",
        chains: ["eip155:1"],
        aud: "https://example.com",
        domain: "http://localhost:3000",
        version: "1",
        nonce: "1",
        iat: "2024-02-19T09:29:21.394Z",
        statement: "Requesting access to your account",
        resources: [
          "https://example.com",
          "urn:recap:eyJhdHQiOnsiZWlwMTU1Ijp7InJlcXVlc3QvZXRoX2NoYWluSWQiOlt7fV0sInJlcXVlc3QvZXRoX3NpZ25UeXBlZERhdGFfdjQiOlt7fV0sInB1c2gvcGVyc29uYWxfc2lnbiI6W3t9XX0sImh0dHBzOi8vbm90aWZ5LndhbGxldGNvbm5lY3QuY29tIjp7Im1hbmFnZS9hbGwtYXBwcy1ub3RpZmljYXRpb25zIjpbe31dLCJlbWl0L2FsZXJ0cyI6W3t9XX19fQ",
        ],
      };

      const message = formatMessage(
        request as any,
        "did:pkh:eip155:1:0x3613699A6c5D8BC97a08805876c8005543125F09",
      );

      expect(message).to.include("Version: 1");
      expect(message).to.include("Nonce: 1");
      expect(message).to.include(`URI: ${request.aud}`);
      expect(message).to.include(`Resources:`);
      expect(message).to.include(request.resources[0]);
    });

    it("should add optional params to siwe message", () => {
      const request = {
        type: "caip122",
        chains: ["eip155:1"],
        aud: "https://example.com",
        domain: "http://localhost:3000",
        version: "1",
        nonce: "1",
        iat: "2024-02-19T09:29:21.394Z",
        exp: "2024-02-25T09:29:21.394Z",
        nbf: "2024-02-20T09:29:21.394Z",
        requestId: "123",
        statement: "Requesting access to your account",
        resources: [
          "https://example.com",
          "urn:recap:eyJhdHQiOnsiZWlwMTU1Ijp7InJlcXVlc3QvZXRoX2NoYWluSWQiOlt7fV0sInJlcXVlc3QvZXRoX3NpZ25UeXBlZERhdGFfdjQiOlt7fV0sInB1c2gvcGVyc29uYWxfc2lnbiI6W3t9XX0sImh0dHBzOi8vbm90aWZ5LndhbGxldGNvbm5lY3QuY29tIjp7Im1hbmFnZS9hbGwtYXBwcy1ub3RpZmljYXRpb25zIjpbe31dLCJlbWl0L2FsZXJ0cyI6W3t9XX19fQ",
        ],
      };

      const message = formatMessage(
        request as any,
        "did:pkh:eip155:1:0x3613699A6c5D8BC97a08805876c8005543125F09",
      );

      expect(message).to.include("Version: 1");
      expect(message).to.include("Nonce: 1");
      expect(message).to.include(`URI: ${request.aud}`);
      expect(message).to.include(`Issued At: ${request.iat}`);
      expect(message).to.include(`Expiration Time: ${request.exp}`);
      expect(message).to.include(`Not Before: ${request.nbf}`);
      expect(message).to.include(`Request ID: ${request.requestId}`);
      expect(message).to.include(`Resources:`);
      expect(message).to.include(request.resources[0]);
    });
  });
});
</file>

<file path="packages/utils/test/crypto.spec.ts">
import { expect, describe, it } from "vitest";
import { toString, fromString } from "uint8arrays";
import { safeJsonStringify } from "@walletconnect/safe-json";
import * as x25519 from "@stablelib/x25519";
import Sinon from "sinon";

import {
  BASE16,
  encrypt,
  decrypt,
  encodeTypeTwoEnvelope,
  decodeTypeTwoEnvelope,
  deriveSymKey,
  deserialize,
  generateKeyPair,
  hashKey,
  hashMessage,
  validateDecoding,
  isTypeOneEnvelope,
  generateRandomBytes32,
  BASE64URL,
  verifyP256Jwt,
} from "../src";

import { TEST_KEY_PAIRS, TEST_SHARED_KEY, TEST_HASHED_KEY, TEST_SYM_KEY } from "./shared";

const TEST_MESSAGE = safeJsonStringify({
  id: 1,
  jsonrpc: "2.0",
  method: "test_method",
  params: {},
});

const TEST_SELF = TEST_KEY_PAIRS.A;
const TEST_PEER = TEST_KEY_PAIRS.B;

const TEST_IV = "717765636661617364616473";

const TEST_SEALED =
  "7a5a1e843debf98b01d6a75718b5ee27115eafa3caba9703ca1c5601a6af2419045320faec2073cc8b6b8dc439e63e21612ff3883c867e0bdcd72c833eb7f7bb2034a9ec35c2fb03d93732";

const TEST_ENCODED_TYPE_0 =
  "AHF3ZWNmYWFzZGFkc3paHoQ96/mLAdanVxi17icRXq+jyrqXA8ocVgGmryQZBFMg+uwgc8yLa43EOeY+IWEv84g8hn4L3Ncsgz6397sgNKnsNcL7A9k3Mg==";

const TEST_ENCODED_TYPE_0_BASE64URL =
  "AHF3ZWNmYWFzZGFkc3paHoQ96_mLAdanVxi17icRXq-jyrqXA8ocVgGmryQZBFMg-uwgc8yLa43EOeY-IWEv84g8hn4L3Ncsgz6397sgNKnsNcL7A9k3Mg";

const TEST_ENCODED_TYPE_1 =
  "Af96fVdnw2KwoXrZIpnr23gx3L2aVpWcATaMdARUOzNCcXdlY2ZhYXNkYWRzeloehD3r+YsB1qdXGLXuJxFer6PKupcDyhxWAaavJBkEUyD67CBzzItrjcQ55j4hYS/ziDyGfgvc1yyDPrf3uyA0qew1wvsD2Tcy";

const TEST_ENCODED_TYPE_1_BASE64URL =
  "Af96fVdnw2KwoXrZIpnr23gx3L2aVpWcATaMdARUOzNCcXdlY2ZhYXNkYWRzeloehD3r-YsB1qdXGLXuJxFer6PKupcDyhxWAaavJBkEUyD67CBzzItrjcQ55j4hYS_ziDyGfgvc1yyDPrf3uyA0qew1wvsD2Tcy";

const TEST_ENCODED_TYPE_2 =
  "AnsiaWQiOjEsImpzb25ycGMiOiIyLjAiLCJtZXRob2QiOiJ0ZXN0X21ldGhvZCIsInBhcmFtcyI6e319";

const TEST_HASHED_MESSAGE = "15112289b5b794e68d1ea3cd91330db55582a37d0596f7b99ea8becdf9d10496";

describe("Crypto", () => {
  it("generateRandomBytes32", () => {
    const bytes = generateRandomBytes32();
    expect(bytes).to.not.be.undefined;
    expect(bytes.length).to.eql(64); // hex
  });
  it("generateKeyPair", () => {
    const keyPair = generateKeyPair();
    expect(keyPair).to.not.be.undefined;
    expect(keyPair.privateKey).to.not.be.undefined;
    expect(keyPair.publicKey).to.not.be.undefined;
    expect(keyPair.privateKey.length).to.eql(64);
    expect(keyPair.publicKey.length).to.eql(64);
  });
  it("generateKeyPair (cross-test)", () => {
    // Since pairs generated randomly, we cannot test them, only reasonable thing to test is
    // interoperability between old library and new.
    const keyPair = generateKeyPair();
    const stableKeyPair = x25519.generateKeyPair();
    const stablePrivateKey = toString(stableKeyPair.secretKey, BASE16);
    const stablePublicKey = toString(stableKeyPair.publicKey, BASE16);
    const sharedKeyA = x25519.sharedKey(
      fromString(keyPair.privateKey, BASE16),
      fromString(stablePublicKey, BASE16),
      true,
    );
    const sharedKeyB = x25519.sharedKey(
      fromString(stablePrivateKey, BASE16),
      fromString(keyPair.publicKey, BASE16),
      true,
    );
    expect(sharedKeyA).to.eql(sharedKeyB);
  });
  it("generateKeyPair (same random)", () => {
    // Check if returns same key if random is same
    const random = new Uint8Array(32).fill(1);
    const randomValuesStub = Sinon.stub(crypto, "getRandomValues").returns(random);
    const stableKeyPair = x25519.generateKeyPair({
      isAvailable: true,
      randomBytes(length: number) {
        return new Uint8Array(length).fill(1);
      },
    });
    const stablePrivateKey = toString(stableKeyPair.secretKey, BASE16);
    const stablePublicKey = toString(stableKeyPair.publicKey, BASE16);
    const keyPair = generateKeyPair();
    expect(keyPair.privateKey).to.eql(stablePrivateKey);
    expect(keyPair.publicKey).to.eql(stablePublicKey);
    expect(randomValuesStub.calledOnce).toBe(true);
    randomValuesStub.restore();
  });
  it("deriveSymKey", () => {
    const symKeyA = deriveSymKey(TEST_SELF.privateKey, TEST_PEER.publicKey);
    expect(symKeyA).to.eql(TEST_SYM_KEY);
    const symKeyB = deriveSymKey(TEST_PEER.privateKey, TEST_SELF.publicKey);
    expect(symKeyB).to.eql(TEST_SYM_KEY);
  });
  it("hashKey", () => {
    const hashedKey = hashKey(TEST_SHARED_KEY);
    expect(hashedKey).to.eql(TEST_HASHED_KEY);
  });
  it("hashMessage", () => {
    const hashedMessage = hashMessage(TEST_MESSAGE);
    expect(hashedMessage).to.eql(TEST_HASHED_MESSAGE);
  });
  it("encrypt (type 0)", () => {
    const encoded = encrypt({ symKey: TEST_SYM_KEY, message: TEST_MESSAGE, iv: TEST_IV });
    expect(encoded).to.eql(TEST_ENCODED_TYPE_0);
    const deserialized = deserialize({ encoded });
    const iv = toString(deserialized.iv, BASE16);
    expect(iv).to.eql(TEST_IV);
    const sealed = toString(deserialized.sealed, BASE16);
    expect(sealed).to.eql(TEST_SEALED);
  });
  it("decrypt (type 0)", () => {
    const decrypted = decrypt({ symKey: TEST_SYM_KEY, encoded: TEST_ENCODED_TYPE_0 });
    expect(decrypted).to.eql(TEST_MESSAGE);
  });
  it("encrypt (type 0) for link-mode", () => {
    const encoding = BASE64URL;
    const encoded = encrypt({ symKey: TEST_SYM_KEY, message: TEST_MESSAGE, iv: TEST_IV, encoding });
    expect(encoded).to.eql(TEST_ENCODED_TYPE_0_BASE64URL);
    const deserialized = deserialize({ encoded, encoding });
    const iv = toString(deserialized.iv, BASE16);
    expect(iv).to.eql(TEST_IV);
    const sealed = toString(deserialized.sealed, BASE16);
    expect(sealed).to.eql(TEST_SEALED);
  });
  it("decrypt (type 0) for link-mode", () => {
    const encoding = BASE64URL;
    const decrypted = decrypt({
      symKey: TEST_SYM_KEY,
      encoded: TEST_ENCODED_TYPE_0_BASE64URL,
      encoding,
    });
    expect(decrypted).to.eql(TEST_MESSAGE);
  });
  it("encrypt (type 1)", () => {
    const encoded = encrypt({
      type: 1,
      symKey: TEST_SYM_KEY,
      senderPublicKey: TEST_SELF.publicKey,
      message: TEST_MESSAGE,
      iv: TEST_IV,
    });
    expect(encoded).to.eql(TEST_ENCODED_TYPE_1);
    const deserialized = deserialize({ encoded });
    const iv = toString(deserialized.iv, BASE16);
    expect(iv).to.eql(TEST_IV);
    const sealed = toString(deserialized.sealed, BASE16);
    expect(sealed).to.eql(TEST_SEALED);
  });
  it("decrypt (type 1)", () => {
    const encoded = TEST_ENCODED_TYPE_1;
    const params = validateDecoding(encoded, {
      receiverPublicKey: TEST_PEER.publicKey,
    });
    expect(isTypeOneEnvelope(params)).to.eql(true);
    if (!isTypeOneEnvelope(params)) return;
    expect(params.type).to.eql(1);
    expect(params.senderPublicKey).to.eql(TEST_SELF.publicKey);
    expect(params.receiverPublicKey).to.eql(TEST_PEER.publicKey);
    const symKey = deriveSymKey(TEST_PEER.privateKey, params.senderPublicKey);
    expect(symKey).to.eql(TEST_SYM_KEY);
    const decrypted = decrypt({ symKey, encoded });
    expect(decrypted).to.eql(TEST_MESSAGE);
  });
  it("encrypt (type 1) for link-mode", () => {
    const encoding = BASE64URL;
    const encoded = encrypt({
      type: 1,
      symKey: TEST_SYM_KEY,
      senderPublicKey: TEST_SELF.publicKey,
      message: TEST_MESSAGE,
      iv: TEST_IV,
      encoding,
    });
    expect(encoded).to.eql(TEST_ENCODED_TYPE_1_BASE64URL);
    const deserialized = deserialize({ encoded, encoding });
    const iv = toString(deserialized.iv, BASE16);
    expect(iv).to.eql(TEST_IV);
    const sealed = toString(deserialized.sealed, BASE16);
    expect(sealed).to.eql(TEST_SEALED);
  });
  it("decrypt (type 1) for link-mode", () => {
    const encoding = BASE64URL;
    const encoded = TEST_ENCODED_TYPE_1_BASE64URL;
    const params = validateDecoding(encoded, {
      receiverPublicKey: TEST_PEER.publicKey,
      encoding,
    });
    expect(isTypeOneEnvelope(params)).to.eql(true);
    if (!isTypeOneEnvelope(params)) return;
    expect(params.type).to.eql(1);
    expect(params.senderPublicKey).to.eql(TEST_SELF.publicKey);
    expect(params.receiverPublicKey).to.eql(TEST_PEER.publicKey);
    const symKey = deriveSymKey(TEST_PEER.privateKey, params.senderPublicKey);
    expect(symKey).to.eql(TEST_SYM_KEY);
    const decrypted = decrypt({ symKey, encoded, encoding });
    expect(decrypted).to.eql(TEST_MESSAGE);
  });
  it("encode (type 2) for link-mode", () => {
    const encoded = encodeTypeTwoEnvelope(TEST_MESSAGE, BASE64URL);
    expect(encoded).to.eql(TEST_ENCODED_TYPE_2);
  });
  it("decode (type 2) for link-mode", () => {
    const decoded = decodeTypeTwoEnvelope(TEST_ENCODED_TYPE_2, BASE64URL);
    expect(decoded).to.eql(TEST_MESSAGE);
  });
  it("calls generateRandomBytes32", () => {
    expect(generateRandomBytes32()).toBeTruthy();
  });
  it("should validate verify v2 jwt", async () => {
    const token =
      "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MjM2MzI1MDQsImlkIjoiMDkxN2YzMzk0YTdmMzkyZTg3ZTM1ZjM4OTg2OWU2NDEzZjkyNTBlMGIxZTE4YjUzMDhkNzBhM2VjOTJjZDQ3OCIsIm9yaWdpbiI6Imh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCIsImlzU2NhbSI6bnVsbCwiaXNWZXJpZmllZCI6ZmFsc2V9.RehA28c0Ae8D_ixvGS8uG9J9eTJtpGfaC_7kNE9ZNAVFREWBY6Dl_SXc0_E0RSvYkHpupfmXlmjenuDqNcyoeg";

    const publicKey = {
      publicKey: {
        crv: "P-256",
        ext: true,
        key_ops: ["verify"],
        kty: "EC",
        x: "CbL4DOYOb1ntd-8OmExO-oS0DWCMC00DntrymJoB8tk",
        y: "KTFwjHtQxGTDR91VsOypcdBfvbo6sAMj5p4Wb-9hRA0",
      },
      expiresAt: 1726209328,
    };

    const result = verifyP256Jwt<{
      exp: number;
      id: string;
      origin: string;
      isScam: boolean;
      isVerified: true;
    }>(token, publicKey.publicKey);
    expect(result).to.exist;
    expect(result).to.exist;
    expect(result.isVerified).to.be.false;
    expect(result.exp).to.exist;
    expect(result.origin).to.exist;
    expect(result.isScam).to.be.null;
    await new Promise((resolve) => setTimeout(resolve, 1000));
  });
  it("should fail to validate invalid jwt with public key", async () => {
    const token =
      "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.oiMDkxN2YzMzk0YTdmMzkyZTg3ZTM1ZjM4OTg2OWU2NDEzZjkyNTBlMGIxZTE4YjUzMDhkNzBhM2VjOTJjZDQ3OCIsIm9yaWdpbiI6Imh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCIsImlzU2NhbSI6bnVsbCwiaXNWZXJpZmllZCI6ZmFsc2V9.RehA28c0Ae8D_ixvGS8uG9J9eTJtpGfaC_7kNE9ZNAVFREWBY6Dl_SXc0_E0RSvYkHpupfmXlmjenuDqNcyoeg";

    const publicKey = {
      publicKey: {
        crv: "P-256",
        ext: true,
        key_ops: ["verify"],
        kty: "EC",
        x: "CbL4DOYOb1ntd-8OmExO-oS0DWCMC00DntrymJoB8tk",
        y: "KTFwjHtQxGTDR91VsOypcdBfvbo6sAMj5p4Wb-9hRA0",
      },
      expiresAt: 1726209328,
    };

    expect(() =>
      verifyP256Jwt<{
        exp: number;
        id: string;
        origin: string;
        isScam: boolean;
        isVerified: true;
      }>(token, publicKey.publicKey),
    ).to.throw();
  });
  it("should fail to validate validate verify v2 jwt with invalid public key", async () => {
    const token =
      "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MjM2MzI1MDQsImlkIjoiMDkxN2YzMzk0YTdmMzkyZTg3ZTM1ZjM4OTg2OWU2NDEzZjkyNTBlMGIxZTE4YjUzMDhkNzBhM2VjOTJjZDQ3OCIsIm9yaWdpbiI6Imh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCIsImlzU2NhbSI6bnVsbCwiaXNWZXJpZmllZCI6ZmFsc2V9.RehA28c0Ae8D_ixvGS8uG9J9eTJtpGfaC_7kNE9ZNAVFREWBY6Dl_SXc0_E0RSvYkHpupfmXlmjenuDqNcyoeg";

    const publicKey = {
      publicKey: {
        crv: "P-256",
        ext: true,
        key_ops: ["verify"],
        kty: "EC",
        x: "CbL4DOYOb1ntd-8OmExO-oS0DWCMC00Dn",
        y: "KTFwjHtQxGTDR91VsOypcdBfvbo6sAMj5p4Wb-9hRA0",
      },
      expiresAt: 1726209328,
    };

    expect(() =>
      verifyP256Jwt<{
        exp: number;
        id: string;
        origin: string;
        isScam: boolean;
        isVerified: true;
      }>(token, publicKey.publicKey),
    ).to.throw();
  });
});
</file>

<file path="packages/utils/test/metadata.spec.ts">
import { vi, expect, describe, it } from "vitest";
import { SignClientTypes } from "@walletconnect/types";
import { populateAppMetadata } from "../src/misc";
const mockedMetadata: SignClientTypes.Metadata = {
  name: "Mocked App Name",
  description: "Mocked App Description",
  url: "https://mocked-app.com",
  icons: ["https://mocked-app.com/icon.png"],
};
// Mock both getWindowMetadata and getAppMetadata
vi.mock("@walletconnect/window-metadata", () => {
  return {
    getWindowMetadata: vi.fn().mockReturnValue({
      name: "Mocked App Name",
      description: "Mocked App Description",
      url: "https://mocked-app.com",
      icons: ["https://mocked-app.com/icon.png"],
    }),
  };
});
describe("metadata", () => {
  it("should populate app metadata", () => {
    const metadata: SignClientTypes.Metadata = {
      name: "",
      description: "",
      url: "",
      icons: [""],
    };
    const populated = populateAppMetadata(metadata);
    expect(populated).to.eql(mockedMetadata);
  });
  it("should partially populate app metadata with empty metadata", () => {
    const metadata: SignClientTypes.Metadata = {
      name: "partially populated metadata",
      description: "",
      url: "",
      icons: [""],
    };
    const populated = populateAppMetadata(metadata);
    expect(populated).to.exist;
    expect(populated.description).to.eql(mockedMetadata.description);
    expect(populated.url).to.eql(mockedMetadata.url);
    expect(populated.icons).to.eql(mockedMetadata.icons);

    expect(populated.name).to.eql(metadata.name);
  });
  it("should partially populate app metadata with empty metadata. 2", () => {
    const metadata: SignClientTypes.Metadata = {
      name: "partially populated metadata",
      description: "",
      url: "",
      icons: ["test"],
    };
    const populated = populateAppMetadata(metadata);
    expect(populated.description).to.eql(mockedMetadata.description);
    expect(populated.url).to.eql(mockedMetadata.url);

    expect(populated.icons).to.eql(metadata.icons);
    expect(populated.name).to.eql(metadata.name);
  });
  it("should populate app metadata with empty metadata. 3", () => {
    const metadata: SignClientTypes.Metadata = {
      name: "",
      description: "",
      url: "https://something.com",
      icons: [""],
    };
    const populated = populateAppMetadata(metadata);
    expect(populated.description).to.eql(mockedMetadata.description);
    expect(populated.url).to.eql(mockedMetadata.url);
    expect(populated.icons).to.eql(mockedMetadata.icons);
  });
});
</file>

<file path="packages/utils/test/misc.spec.ts">
import { afterAll, afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import {
  calcExpiry,
  formatDeeplinkUrl,
  formatRelayRpcUrl,
  formatUA,
  getSearchParamFromURL,
  hasOverlap,
  isExpired,
  toBase64,
  openDeeplink,
  isIframe,
} from "../src";

const RELAY_URL = "wss://relay.walletconnect.org";

const PROJECT_ID = "27e484dcd9e3efcfd25a83a78777cdf1";

const PROTOCOL = "wc";

const VERSION = 2;

const SDK_VERSION = "2.0.0-rc.1";

const AUTH = "auth.jwt.example";

const PACKAGE_NAME = "com.example.app";

const BUNDLE_ID = "com.example.app.bundle";

const EXPECTED_RPC_URL_1 =
  RELAY_URL + `?auth=${AUTH}&ua=${encodeURIComponent(formatUA(PROTOCOL, VERSION, SDK_VERSION))}`;

const EXPECTED_RPC_URL_2 =
  RELAY_URL +
  `?auth=${AUTH}&projectId=${PROJECT_ID}&ua=${encodeURIComponent(
    formatUA(PROTOCOL, VERSION, SDK_VERSION),
  )}`;

const EXPECTED_RPC_URL_3 =
  RELAY_URL +
  `?auth=${AUTH}&projectId=${PROJECT_ID}&ua=${encodeURIComponent(
    formatUA(PROTOCOL, VERSION, SDK_VERSION),
  )}&useOnCloseEvent=true`;

const EXPECTED_RPC_URL_4 =
  RELAY_URL +
  `?auth=${AUTH}&packageName=${PACKAGE_NAME}&projectId=${PROJECT_ID}&ua=${encodeURIComponent(
    formatUA(PROTOCOL, VERSION, SDK_VERSION),
  )}`;

const EXPECTED_RPC_URL_5 =
  RELAY_URL +
  `?auth=${AUTH}&bundleId=${BUNDLE_ID}&projectId=${PROJECT_ID}&ua=${encodeURIComponent(
    formatUA(PROTOCOL, VERSION, SDK_VERSION),
  )}`;

const SEVEN_DAYS_IN_SECONDS = 604800;

describe("Misc", () => {
  it("formatRpcRelayUrl", () => {
    expect(
      formatRelayRpcUrl({
        protocol: PROTOCOL,
        version: VERSION,
        sdkVersion: SDK_VERSION,
        relayUrl: RELAY_URL,
        auth: AUTH,
      }),
    ).to.eql(EXPECTED_RPC_URL_1);
    expect(
      formatRelayRpcUrl({
        protocol: PROTOCOL,
        version: VERSION,
        sdkVersion: SDK_VERSION,
        relayUrl: RELAY_URL,
        projectId: PROJECT_ID,
        auth: AUTH,
      }),
    ).to.eql(EXPECTED_RPC_URL_2);
    expect(
      formatRelayRpcUrl({
        protocol: PROTOCOL,
        version: VERSION,
        sdkVersion: SDK_VERSION,
        relayUrl: RELAY_URL,
        projectId: PROJECT_ID,
        auth: AUTH,
        useOnCloseEvent: true,
      }),
    ).to.eql(EXPECTED_RPC_URL_3);
    expect(
      formatRelayRpcUrl({
        protocol: PROTOCOL,
        version: VERSION,
        sdkVersion: SDK_VERSION,
        relayUrl: RELAY_URL,
        projectId: PROJECT_ID,
        auth: AUTH,
        packageName: PACKAGE_NAME,
      }),
    ).to.eql(EXPECTED_RPC_URL_4);
    expect(
      formatRelayRpcUrl({
        protocol: PROTOCOL,
        version: VERSION,
        sdkVersion: SDK_VERSION,
        relayUrl: RELAY_URL,
        projectId: PROJECT_ID,
        auth: AUTH,
        bundleId: BUNDLE_ID,
      }),
    ).to.eql(EXPECTED_RPC_URL_5);
  });
  it("hasOverlap", () => {
    expect(hasOverlap([], [])).to.be.true;
    expect(hasOverlap(["dog"], ["dog", "cat"])).to.be.true;
    expect(hasOverlap(["dog", "cat"], ["dog"])).to.be.false;
    expect(hasOverlap(["dog"], [])).to.be.false;
  });
  it("getSearchParamFromURL", () => {
    const url = "https://example.com?foo=bar&baz=qux";
    const searchParam1 = "foo";
    const expectedValue1 = "bar";
    const searchParam2 = "baz";
    const expectedValue2 = "qux";
    expect(getSearchParamFromURL(url, searchParam1)).to.eql(expectedValue1);
    expect(getSearchParamFromURL(url, searchParam2)).to.eql(expectedValue2);
  });

  describe("expiry utils", () => {
    beforeEach(() => {
      // Use mocked time for each test run.
      vi.useFakeTimers();
    });
    afterEach(() => {
      // Restore non-mocked date after each.
      vi.useRealTimers();
    });
    describe("calcExpiry", () => {
      const timestampInMs = 1628166822000;
      const expectedExpiry = 1628771622;
      it("returns the expected expiry based on `Date.now()`", () => {
        // Set system time to reference timestamp.
        vi.setSystemTime(new Date(timestampInMs));
        expect(calcExpiry(SEVEN_DAYS_IN_SECONDS)).to.eql(expectedExpiry);
      });
      it("returns the expected expiry based on the provided reference timestamp", () => {
        expect(calcExpiry(SEVEN_DAYS_IN_SECONDS, timestampInMs)).to.eql(expectedExpiry);
      });
    });
    describe("isExpired", () => {
      const expiry = 1675702595; // Feb 06 2023 16:56:35 GMT+0000
      it("is `false` if the provided expiry is less than the current timestamp", () => {
        // Set system time to 2 minutes PRE-expiry.
        vi.setSystemTime(new Date(expiry * 1000 - 120_000));
        expect(isExpired(expiry)).to.be.false;
      });
      it("is `true` if the provided expiry is equal or greater than the current timestamp", () => {
        // Set system time to exactly expiry.
        vi.setSystemTime(new Date(expiry * 1000));
        expect(isExpired(expiry)).to.be.true;
      });
    });
  });
  describe("deep links", () => {
    it("should format universal link", () => {
      const deepLink = "https://example.com";
      const requestId = 123;
      const sessionTopic = "randomSessionTopic";
      const expectedDeepLink = `${deepLink}/wc?requestId=${requestId}&sessionTopic=${sessionTopic}`;
      const formatted = formatDeeplinkUrl(deepLink, requestId, sessionTopic);
      expect(formatted).to.eql(expectedDeepLink);
    });
    it("should format deep link", () => {
      const deepLink = "trust://";
      const requestId = 123;
      const sessionTopic = "randomSessionTopic";
      const expectedDeepLink = `${deepLink}wc?requestId=${requestId}&sessionTopic=${sessionTopic}`;
      const formatted = formatDeeplinkUrl(deepLink, requestId, sessionTopic);
      expect(formatted).to.eql(expectedDeepLink);
    });
    it("should format telegram universal link", async () => {
      const deepLink = "https://t.me";
      const requestId = 123;
      const sessionTopic = "randomSessionTopic";
      const partToEncode = `requestId=${requestId}&sessionTopic=${sessionTopic}`;
      const expectedDeepLink = `${deepLink}?startapp=${toBase64(partToEncode, true)}`;
      const formatted = formatDeeplinkUrl(deepLink, requestId, sessionTopic);
      expect(formatted).to.eql(expectedDeepLink);
      const decoded = atob(formatted.split("startapp=")[1]);
      expect(decoded).to.eql(partToEncode);
    });

    describe("openDeeplink", () => {
      const previousWindow = globalThis.window;

      beforeEach(() => {
        Object.assign(globalThis, {
          window: {
            open: vi.fn(),
          },
        });
      });

      afterAll(() => {
        Object.assign(globalThis, {
          window: previousWindow,
        });
      });

      it("should target '_blank' if link starts with 'https://'", () => {
        const url = "https://example.com";
        openDeeplink(url);
        expect(window.open).toHaveBeenCalledWith(url, "_blank", "noreferrer noopener");
      });

      it("should target '_blank' if link starts with 'http://'", () => {
        const url = "http://example.com";
        openDeeplink(url);
        expect(window.open).toHaveBeenCalledWith(url, "_blank", "noreferrer noopener");
      });

      it("should target '_blank' for telegram deep link", () => {
        Object.assign(window, {
          Telegram: {},
        });

        const url = "scheme://example.com";
        openDeeplink(url);
        expect(window.open).toHaveBeenCalledWith(url, "_blank", "noreferrer noopener");

        (window as any).Telegram = undefined;
      });

      it("should target '_top' if is an iframe", () => {
        Object.assign(window, {
          top: {},
        });

        const url = "scheme://example.com";
        openDeeplink(url);
        expect(window.open).toHaveBeenCalledWith(url, "_top", "noreferrer noopener");
      });

      it("should target '_self' for other cases", () => {
        const url = "scheme://example.com";
        openDeeplink(url);
        expect(window.open).toHaveBeenCalledWith(url, "_self", "noreferrer noopener");
      });
    });
  });

  describe("isIframe", () => {
    const previousWindow = globalThis.window;

    afterEach(() => {
      Object.assign(globalThis, { window: previousWindow });
    });

    it("should return true if window.top is not equal to window", () => {
      Object.assign(globalThis, {
        window: {
          top: {},
        },
      });
      expect(isIframe()).to.be.true;
    });

    it("should return false if window.top is equal to window", () => {
      expect(isIframe()).to.be.false;
    });
  });
});
</file>

<file path="packages/utils/test/signatures.spec.ts">
import { AuthTypes } from "@walletconnect/types";
import { describe, expect, it } from "vitest";
import { extractSolanaTransactionId, isValidEip191Signature, verifySignature } from "../src";

describe("utils/signature", () => {
  describe("EIP-1271 signatures", () => {
    const chainId = "eip155:1";
    const projectId = process.env.TEST_PROJECT_ID!;
    const address = "0x2faf83c542b68f1b4cdc0e770e8cb9f567b08f71";
    const reconstructedMessage = `localhost wants you to sign in with your Ethereum account:
0x2faf83c542b68f1b4cdc0e770e8cb9f567b08f71

URI: http://localhost:3000/
Version: 1
Chain ID: 1
Nonce: 1665443015700
Issued At: 2022-10-10T23:03:35.700Z
Expiration Time: 2022-10-11T23:03:35.700Z`;

    it("passes for a valid signature", async () => {
      const cacaoSignature: AuthTypes.CacaoSignature = {
        t: "eip1271",
        s: "0xc1505719b2504095116db01baaf276361efd3a73c28cf8cc28dabefa945b8d536011289ac0a3b048600c1e692ff173ca944246cf7ceb319ac2262d27b395c82b1c",
      };

      const isValid = await verifySignature(
        address,
        reconstructedMessage,
        cacaoSignature,
        chainId,
        projectId,
      );
      expect(isValid).to.be.true;
    });
    it("fails for a bad signature", async () => {
      const cacaoSignature: AuthTypes.CacaoSignature = {
        t: "eip1271",
        s: "0xdead5719b2504095116db01baaf276361efd3a73c28cf8cc28dabefa945b8d536011289ac0a3b048600c1e692ff173ca944246cf7ceb319ac2262d27b395c82b1c",
      };

      const isValid = await verifySignature(
        address,
        reconstructedMessage,
        cacaoSignature,
        chainId,
        projectId,
      );
      expect(isValid).toBe(false);
    });
    it("fails for a bad chainid", async () => {
      const cacaoSignature: AuthTypes.CacaoSignature = {
        t: "eip1271",
        s: "0xdead5719b2504095116db01baaf276361efd3a73c28cf8cc28dabefa945b8d536011289ac0a3b048600c1e692ff173ca944246cf7ceb319ac2262d27b395c82b1c",
      };
      const invalidChainIdOne = "1";
      await expect(
        verifySignature(
          address,
          reconstructedMessage,
          cacaoSignature,
          invalidChainIdOne,
          projectId,
        ),
      ).rejects.toThrow(
        `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${invalidChainIdOne}`,
      );
      const invalidChainIdTwo = ":1";
      await expect(
        verifySignature(
          address,
          reconstructedMessage,
          cacaoSignature,
          invalidChainIdTwo,
          projectId,
        ),
      ).rejects.toThrow(
        `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${invalidChainIdTwo}`,
      );
      const invalidChainIdThree = "1:";
      await expect(
        verifySignature(
          address,
          reconstructedMessage,
          cacaoSignature,
          invalidChainIdThree,
          projectId,
        ),
      ).rejects.toThrow(
        `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${invalidChainIdThree}`,
      );
    });
  });
  describe("EIP-191 signatures", () => {
    it("should validate a valid signature", async () => {
      const address = "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52";
      const message = `Hello AppKit!`;
      const signature =
        "0xd7ec09eb8ecb1ba9af45380e14d3ef1a1ec2376e0adfc0a9b591e7c3519a00d702cbe063aa55ff681265eed2d1646a217f0bf23f12ab4cd326455ab4134e12691b";
      const isValid = await isValidEip191Signature(address, message, signature);
      expect(isValid).toBe(true);
    });
    it("should fail to validate an invalid signature", async () => {
      const address = "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52";
      const message = `Hello AppKit!`;
      const signature = "0xd7ec09eb8ecb1ba9af45380e14d3ef1a1ec2376e0adfc0a9b591e";
      await expect(isValidEip191Signature(address, message, signature)).rejects.toThrow();
    });
    it("should fail to validate a valid signature with wrong address", async () => {
      const address = "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C54";
      const message = `Hello AppKit!`;
      const signature = "0xd7ec09eb8ecb1ba9af45380e14d3ef1a1ec2376e0adfc0a9b591e";
      await expect(isValidEip191Signature(address, message, signature)).rejects.toThrow();
    });
    it("should fail to validate an valid signature with wrong message", async () => {
      const address = "0x13A2Ff792037AA2cd77fE1f4B522921ac59a9C52";
      const message = `Hello AppKit! 0xyadayada`;
      const signature = "0xd7ec09eb8ecb1ba9af45380e14d3ef1a1ec2376e0adfc0a9b591e";
      await expect(isValidEip191Signature(address, message, signature)).rejects.toThrow();
    });

    it("should extract the transaction id from a solana transaction", () => {
      const transaction =
        "AeJw688VKMWEeOHsYhe03By/2rqJHTQeq6W4L1ZLdbT2l/Nim8ctL3erMyH9IWPsQP73uaarRmiVfanEJHx7uQ4BAAIDb3ObYkq6BFd46JrMFy1h0Q+dGmyRGtpelqTKkIg82isAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAAtIy17v5fs39LuoitzpBhVrg8ZIQF/3ih1N9dQ+X3shEDAgAFAlgCAAABAgAADAIAAACghgEAAAAAAAIACQMjTgAAAAAAAA==";
      const expectedTransactionId =
        "5XanD5KnkqzH3RjyqHzPCSRrNXYW2ADH4bge4oMi9KnDBrkFvugagH3LytFZFmBhZEEcyxPsZqeyF4cgLpEXVFR7";
      const transactionId = extractSolanaTransactionId(transaction);
      expect(transactionId).toBe(expectedTransactionId);
    });
    it("should fail to extract the transaction id from an invalid solana transaction", () => {
      const transaction =
        "+dGmyRGtpelqTKkIg82isAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAAtIy17v5fs39LuoitzpBhVrg8ZIQF/3ih1N9dQ+X3shEDAgAFAlgCAAABAgAADAIAAACghgEAAAAAAAIACQMjTgAAAAAAAA==";
      expect(() => extractSolanaTransactionId(transaction)).to.throw();
    });
  });
});
</file>

<file path="packages/utils/test/uri.spec.ts">
import { EngineTypes } from "@walletconnect/types";
import { expect, describe, it } from "vitest";
import { formatUri, generateRandomBytes32, parseUri, toBase64 } from "../src";
import { TEST_PAIRING_TOPIC, TEST_RELAY_OPTIONS, TEST_SYM_KEY } from "./shared";

const TEST_URI_PARAMS: EngineTypes.UriParameters = {
  protocol: "wc",
  version: 2,
  topic: TEST_PAIRING_TOPIC,
  symKey: TEST_SYM_KEY,
  relay: TEST_RELAY_OPTIONS,
};

const TEST_URI_STRING = `${TEST_URI_PARAMS.protocol}:${TEST_URI_PARAMS.topic}@${TEST_URI_PARAMS.version}?relay-protocol=${TEST_RELAY_OPTIONS.protocol}&symKey=${TEST_URI_PARAMS.symKey}`;

describe("URI", () => {
  it("formatUri", () => {
    const uri = formatUri(TEST_URI_PARAMS);
    expect(uri).to.eql(TEST_URI_STRING);
  });
  it("parseUri", () => {
    const uriParams = parseUri(TEST_URI_STRING);
    expect(uriParams.version).to.eql(TEST_URI_PARAMS.version);
    expect(uriParams.topic).to.eql(TEST_URI_PARAMS.topic);
    expect(uriParams.symKey).to.eql(TEST_URI_PARAMS.symKey);
    expect(uriParams.relay.data).to.eql(TEST_URI_PARAMS.relay.data);
    expect(uriParams.relay.protocol).to.eql(TEST_URI_PARAMS.relay.protocol);
  });
  it("parseTopic", () => {
    const topic = generateRandomBytes32();
    const androidSchemaTopic = `//${topic}`;
    TEST_URI_PARAMS.topic = androidSchemaTopic;
    expect(parseUri(formatUri(TEST_URI_PARAMS)).topic).to.not.eql(androidSchemaTopic);
    expect(parseUri(formatUri(TEST_URI_PARAMS)).topic).to.eql(topic);
    expect(parseUri(formatUri(TEST_URI_PARAMS)).topic.startsWith("//")).to.be.false;
  });
  it("should parse base64 uri", () => {
    const encodedUri = toBase64(TEST_URI_STRING);
    const uriParams = parseUri(TEST_URI_STRING);
    const encodedUriParams = parseUri(encodedUri);
    expect(uriParams).to.eql(encodedUriParams);
    expect(uriParams.version).to.eql(encodedUriParams.version);
    expect(uriParams.topic).to.eql(encodedUriParams.topic);
    expect(uriParams.symKey).to.eql(encodedUriParams.symKey);
    expect(uriParams.relay.data).to.eql(encodedUriParams.relay.data);
  });
});
</file>

<file path="packages/utils/test/validators.spec.ts">
import { expect, describe, it } from "vitest";
import {
  TEST_CHAINS,
  TEST_ETHEREUM_CHAIN_A,
  TEST_ETHEREUM_NAMESPACE,
  TEST_EVENTS,
  TEST_METHODS,
  TEST_SESSION,
} from "./shared/values";

import { buildApprovedNamespaces, isConformingNamespaces, isSessionCompatible } from "../src";

describe("Validators", () => {
  it("isSessionCompatible", () => {
    // exact
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: TEST_CHAINS,
            methods: TEST_METHODS,
            events: TEST_EVENTS,
          },
        },
      }),
    ).to.be.true;
    // chains
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: [TEST_ETHEREUM_CHAIN_A],
            methods: TEST_METHODS,
            events: TEST_EVENTS,
          },
        },
      }),
    ).to.be.true;
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: [...TEST_CHAINS, "eip155:100"],
            methods: TEST_METHODS,
            events: TEST_EVENTS,
          },
        },
      }),
    ).to.be.false;
    // methods
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: TEST_CHAINS,
            methods: ["personal_sign"],
            events: TEST_EVENTS,
          },
        },
      }),
    ).to.be.true;
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: TEST_CHAINS,
            methods: [...TEST_METHODS, "blockchain_signMessage"],
            events: TEST_EVENTS,
          },
        },
      }),
    ).to.be.false;
    // events
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: TEST_CHAINS,
            methods: TEST_METHODS,
            events: ["accountsChanged"],
          },
        },
      }),
    ).to.be.true;
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          [TEST_ETHEREUM_NAMESPACE]: {
            chains: TEST_CHAINS,
            methods: TEST_METHODS,
            events: [...TEST_EVENTS, `colorChanged`],
          },
        },
      }),
    ).to.be.false;
    // wrong namespace
    expect(
      isSessionCompatible(TEST_SESSION, {
        requiredNamespaces: {
          cosmos: {
            chains: TEST_CHAINS,
            methods: TEST_METHODS,
            events: TEST_EVENTS,
          },
        },
      }),
    ).to.be.false;
  });
  it("should validate namespaces (configuration 1)", () => {
    const required = {
      eip155: {
        chains: ["eip155:1", "eip155:2", "eip155:3"],
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
      "eip155:4": {
        events: [],
        methods: ["eth_accounts"],
      },
      solana: {
        chains: ["solana:1", "solana:2", "solana:3"],
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
    };

    const approved = {
      eip155: {
        accounts: [
          "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        ],
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
      "eip155:4": {
        events: [],
        methods: ["eth_accounts"],
        accounts: ["eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
      },
      "eip155:5": {
        events: [],
        methods: ["eth_sendTransaction"],
        accounts: ["eip155:5:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
      },
      solana: {
        accounts: [
          "solana:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "solana:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "solana:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        ],
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
    };
    const err = isConformingNamespaces(required, approved, "validators");
    expect(err).to.be.null;
  });
  it("should validate namespaces (configuration 2)", () => {
    const required = {
      "eip155:1": {
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
      "eip155:2": {
        events: [],
        methods: ["eth_accounts"],
      },
      "solana:1": {
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
    };

    const approved = {
      eip155: {
        accounts: [
          "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        ],
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
      solana: {
        accounts: ["solana:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: [],
        methods: ["eth_accounts", "personal_sign"],
      },
    };
    const err = isConformingNamespaces(required, approved, "validators");
    expect(err).to.be.null;
  });
  it("should validate namespaces (configuration 3)", () => {
    const required = {
      eip155: {
        chains: ["eip155:1"],
        events: [],
        methods: ["eth_accounts"],
      },
    };

    const approved = {
      eip155: {
        accounts: [
          "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        ],
        events: ["chainChanged"],
        methods: ["eth_accounts", "personal_sign"],
      },
    };
    const err = isConformingNamespaces(required, approved, "validators");
    expect(err).to.be.null;
  });

  it("should validate namespaces (configuration 4)", () => {
    const required = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        events: [],
        methods: ["eth_accounts"],
      },
    };

    const approved = {
      "eip155:1": {
        accounts: ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["eth_accounts"],
      },
      "eip155:2": {
        accounts: ["eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["eth_accounts"],
      },
    };
    const err = isConformingNamespaces(required, approved, "validators");
    expect(err).to.be.null;
  });

  it("should throw on invalid accounts", () => {
    const required = {
      eip155: {
        chains: ["eip155:1"],
        events: [],
        methods: ["eth_accounts"],
      },
    };

    const approved = {
      eip155: {
        accounts: ["eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["eth_accounts", "personal_sign"],
      },
    };
    const error = isConformingNamespaces(required, approved, "validators");
    expect(error).to.not.be.null;
    expect(error).to.throw;
  });
  it("should throw on invalid namespace", () => {
    const required = {
      eip155: {
        chains: ["eip155:1"],
        events: [],
        methods: ["eth_accounts"],
      },
    };

    const approved = {
      solana: {
        accounts: ["solana:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["eth_accounts", "personal_sign"],
      },
    };
    const error = isConformingNamespaces(required, approved, "validators");
    expect(error).to.not.be.null;
    expect(error).to.throw;
  });

  it("should throw on invalid methods", () => {
    const required = {
      eip155: {
        chains: ["eip155:1"],
        events: [],
        methods: ["eth_accounts"],
      },
    };

    const approved = {
      eip155: {
        accounts: ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["personal_sign"],
      },
    };
    const error = isConformingNamespaces(required, approved, "validators");
    expect(error).to.not.be.null;
    expect(error).to.throw;
  });

  it("should throw on CAIP-2 namespace not including that CAIP-2 in accounts", () => {
    const required = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        events: [],
        methods: ["eth_accounts"],
      },
    };

    const approved = {
      "eip155:1": {
        accounts: ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["eth_accounts"],
      },
      "eip155:2": {
        accounts: ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
        events: ["chainChanged"],
        methods: ["eth_accounts"],
      },
    };
    const error = isConformingNamespaces(required, approved, "validators");
    expect(error).to.not.be.null;
    expect(error).to.throw;
  });
});
describe("buildApprovedNamespaces (validators)", () => {
  const TEST_PROPOSAL = {
    id: 1,
    pairingTopic: "0x123",
    expiry: 1680622315,
    requiredNamespaces: {},
    optionalNamespaces: {},
    relays: [{ protocol: "irn" }],
    proposer: {
      publicKey: "c743d1c3d8aeac99267359ece5c33838411d812e576bc9728f66fca1899dd25f",
      metadata: {
        name: "App A (Proposer)",
        description: "Description of Proposer App run by client A",
        url: "https://walletconnect.com",
        icons: [],
      },
    },
    sessionProperties: { expiry: "2022-12-24T17:07:31+00:00", "caip154-mandatory": "true" },
  };
  it("should build namespaces (config 1 - optional method)", () => {
    const required = {
      eip155: {
        chains: ["eip155:1"],
        events: ["chainChanged"],
        methods: ["personal_sign"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:1"],
        events: [""],
        methods: ["eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:3"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];
    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts: [accounts[0]],
      },
    };
    expect(approvedNamespaces).to.deep.equal(expected);
  });
  it("should build namespaces (config 2 - optional chain)", () => {
    const required = {
      eip155: {
        chains: ["eip155:1"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:2"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:3"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts: [accounts[0], accounts[1]],
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 3 - inline chain)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:2"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:3"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts: [accounts[0], accounts[1]],
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 4 - multiple inline chains)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:3"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:3"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2", "eip155:3"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts,
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 5 - multiple inline chains)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:3"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:4": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:3", "eip155:4"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2", "eip155:4", "eip155:3"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts,
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 6 - unsupported optional chains)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:3"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:4": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts,
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 7 - partially supported optional chains)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:3"],
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:4": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:4"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2", "eip155:4"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts,
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 8 - partially supported optional methods)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        events: ["chainChanged"],
        methods: [
          "personal_sign",
          "eth_sendTransaction",
          "eth_signTransaction",
          "eth_signTypedData",
        ],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:4"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction", "eth_signTransaction"],
        events,
        accounts: [accounts[0], accounts[1]],
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 9 - partially supported optional events)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        events: ["chainChanged", "accountsChanged"],
        methods: [
          "personal_sign",
          "eth_sendTransaction",
          "eth_signTransaction",
          "eth_signTypedData",
        ],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:4"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged", "accountsChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction", "eth_signTransaction"],
        events,
        accounts: [accounts[0], accounts[1]],
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 10 - extra supported chains)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      "eip155:2": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        events: ["chainChanged", "accountsChanged"],
        methods: [
          "personal_sign",
          "eth_sendTransaction",
          "eth_signTransaction",
          "eth_signTypedData",
        ],
      },
    };

    const chains = ["eip155:1", "eip155:2", "eip155:11"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged", "accountsChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:11:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction", "eth_signTransaction"],
        events,
        accounts: [
          "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        ],
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 11 - multiple namespaces - required)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
      cosmos: {
        chains: ["cosmos:cosmoshub-4"],
        events: ["cosmos_event"],
        methods: ["cosmos_method"],
      },
    };
    const optional = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        events: ["chainChanged", "accountsChanged"],
        methods: [
          "personal_sign",
          "eth_sendTransaction",
          "eth_signTransaction",
          "eth_signTypedData",
        ],
      },
    };

    const chainsEip = ["eip155:1", "eip155:2", "eip155:4"];
    const chainsCosmos = ["cosmos:cosmoshub-4"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged", "accountsChanged"];
    const accountsEip = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:4:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];
    const accountsCosmos = ["cosmos:cosmoshub-4:cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02"];
    const eventsCosmos = ["cosmos_event"];
    const methodsCosmos = ["cosmos_method"];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains: chainsEip,
          methods,
          events,
          accounts: accountsEip,
        },
        cosmos: {
          chains: chainsCosmos,
          methods: methodsCosmos,
          events: eventsCosmos,
          accounts: accountsCosmos,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1", "eip155:2"],
        methods: ["personal_sign", "eth_sendTransaction", "eth_signTransaction"],
        events,
        accounts: [
          "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
          "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        ],
      },
      cosmos: {
        chains: chainsCosmos,
        methods: methodsCosmos,
        events: eventsCosmos,
        accounts: accountsCosmos,
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 12 - chains fuzzing)", () => {
    const required = {
      "eip155:1": {
        events: ["chainChanged"],
        methods: ["personal_sign", "eth_sendTransaction"],
      },
    };
    const optional = {};

    const chains = ["eip155:1", "eip155:11", "eip155:111"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:11:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:111:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });

    const expected = {
      eip155: {
        chains: ["eip155:1"],
        methods: ["personal_sign", "eth_sendTransaction"],
        events,
        accounts: ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"],
      },
    };
    expect(approvedNamespaces).to.deep.eq(expected);
  });
  it("should build namespaces (config 13 - required & optional empty)", () => {
    const required = {};
    const optional = {};

    const chains = ["eip155:1", "eip155:2", "eip155:3"];
    const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
    const events = ["chainChanged"];
    const accounts = [
      "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      "eip155:3:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
    ];

    const approvedNamespaces = buildApprovedNamespaces({
      proposal: {
        ...TEST_PROPOSAL,
        requiredNamespaces: required,
        optionalNamespaces: optional,
      },
      supportedNamespaces: {
        eip155: {
          chains,
          methods,
          events,
          accounts,
        },
      },
    });
    const expected = {
      eip155: {
        chains,
        methods,
        events,
        accounts,
      },
    };
    expect(approvedNamespaces).to.deep.equal(expected);
  });

  it.fails(
    "should throw while building namespaces (config 1 - no supported required chains)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
        cosmos: {
          chains: ["cosmos:cosmoshub-4"],
          events: ["cosmos_event"],
          methods: ["cosmos_method"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:5"];
      const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
      const events = ["chainChanged", "accountsChanged"];
      const accountsEip = ["eip155:5:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
  it.fails(
    "should throw while building namespaces (config 2 - partially supported required chains)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
        cosmos: {
          chains: ["cosmos:cosmoshub-4"],
          events: ["cosmos_event"],
          methods: ["cosmos_method"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:1", "eip155:5"];
      const methods = ["personal_sign", "eth_sendTransaction", "eth_signTransaction"];
      const events = ["chainChanged", "accountsChanged"];
      const accountsEip = [
        "eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        "eip155:5:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      ];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
  it.fails(
    "should throw while building namespaces (config 3 - no supported required methods)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:1"];
      const methods = ["personal_sign"];
      const events = ["chainChanged", "accountsChanged"];
      const accountsEip = ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
  it.fails(
    "should throw while building namespaces (config 4 - no supported required events)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:1"];
      const methods = ["personal_sign", "eth_sendTransaction"];
      const events = [] as string[];
      const accountsEip = ["eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
  it.fails(
    "should throw while building namespaces (config 5 - no accounts for required chain)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:1"];
      const methods = ["personal_sign", "eth_sendTransaction"];
      const events = ["chainChanged"];
      const accountsEip = ["eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
  it.fails(
    "should throw while building namespaces (config 6 - partial accounts for required chain)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
        "eip155:2": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:1", "eip155:2"];
      const methods = ["personal_sign", "eth_sendTransaction"];
      const events = ["chainChanged"];
      const accountsEip = ["eip155:2:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092"];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
  it.fails(
    "should throw while building namespaces (config 7 - misconfigured supported accounts - caip10)",
    () => {
      const required = {
        "eip155:1": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
        "eip155:2": {
          events: ["chainChanged"],
          methods: ["personal_sign", "eth_sendTransaction"],
        },
      };
      const optional = {
        eip155: {
          chains: ["eip155:1", "eip155:2"],
          events: ["chainChanged", "accountsChanged"],
          methods: [
            "personal_sign",
            "eth_sendTransaction",
            "eth_signTransaction",
            "eth_signTypedData",
          ],
        },
      };

      const chainsEip = ["eip155:1", "eip155:2"];
      const methods = ["personal_sign", "eth_sendTransaction"];
      const events = ["chainChanged"];
      const accountsEip = [
        "0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
        "0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092",
      ];

      buildApprovedNamespaces({
        proposal: {
          ...TEST_PROPOSAL,
          requiredNamespaces: required,
          optionalNamespaces: optional,
        },
        supportedNamespaces: {
          eip155: {
            chains: chainsEip,
            methods,
            events,
            accounts: accountsEip,
          },
        },
      });
    },
  );
});
</file>

<file path="packages/utils/.npmignore">
*.log
npm-debug.log*

# Coverage directory used by tools like istanbul
coverage
.nyc_output

# Dependency directories
node_modules

# npm package lock
package-lock.json
yarn.lock

# project files
src
test
CHANGELOG.md
.travis.yml
.editorconfig
.eslintignore
.eslintrc
.babelrc
.gitignore
.watchmanconfig
</file>

<file path="packages/utils/CHANGELOG.md">
# @walletconnect/utils

## 2.20.0

### Patch Changes

- Updated dependencies []:
  - @walletconnect/types@2.20.0

## 2.19.4

### Patch Changes

- Updated dependencies []:
  - @walletconnect/types@2.19.4

## 2.19.3

### Patch Changes

- Updated dependencies []:
  - @walletconnect/types@2.19.3
</file>

<file path="packages/utils/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="packages/utils/package.json">
{
  "name": "@walletconnect/utils",
  "description": "Utilities for WalletConnect Protocol",
  "version": "2.20.0",
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
  "license": "Apache-2.0",
  "main": "dist/index.cjs.js",
  "module": "dist/index.es.js",
  "unpkg": "dist/index.umd.js",
  "types": "dist/types/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "keywords": [
    "wallet",
    "walletconnect"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build:pre": "npm run clean",
    "build:types": "tsc",
    "build:source": "rollup --config rollup.config.js",
    "build": "npm run build:pre; npm run build:source; npm run build:types",
    "test:pre": "rm -rf ./test/test.db",
    "test:run": "vitest run --dir test",
    "test": "npm run test:pre; npm run test:run",
    "test:ignoreUnhandled": "npm run test:pre; npm run test:run -- --dangerouslyIgnoreUnhandledErrors",
    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
    "prettier": "prettier --check '{src,test}/**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@noble/ciphers": "1.2.1",
    "@noble/curves": "1.8.1",
    "@noble/hashes": "1.7.1",
    "@walletconnect/jsonrpc-utils": "1.0.8",
    "@walletconnect/keyvaluestorage": "1.1.1",
    "@walletconnect/relay-api": "1.0.11",
    "@walletconnect/relay-auth": "1.1.0",
    "@walletconnect/safe-json": "1.0.2",
    "@walletconnect/time": "1.0.2",
    "@walletconnect/types": "2.20.0",
    "@walletconnect/window-getters": "1.0.1",
    "@walletconnect/window-metadata": "1.0.1",
    "bs58": "6.0.0",
    "detect-browser": "5.3.0",
    "query-string": "7.1.3",
    "uint8arrays": "3.1.0",
    "viem": "2.23.2"
  },
  "devDependencies": {
    "@stablelib/x25519": "1.0.3",
    "@walletconnect/jsonrpc-types": "1.0.4"
  }
}
</file>

<file path="packages/utils/README.md">
# @walletconnect/utils

Utilities for WalletConnect Protocol
</file>

<file path="packages/utils/rollup.config.js">
import { name, dependencies } from "./package.json";
import createConfig from "../../rollup.config";

export default createConfig(name, Object.keys(dependencies));
</file>

<file path="packages/utils/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["./src/**/*"],
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "./dist/types",
    "emitDeclarationOnly": true
  }
}
</file>

</files>
