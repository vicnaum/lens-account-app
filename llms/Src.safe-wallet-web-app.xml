This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.test.*, cypress, **/tests, mocks, scripts, **/terms, **/privacy, **/*.svg, **/*.png, LICENSE, **/cookie*.*, **/license*.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.storybook/
  main.ts
  preview.ts
docs/
  code-style.md
  environments.md
  release-procedure.md
  update-patch.md
  update-terms.md
public/
  .well-known/
    apple-app-site-association
  fonts/
    fonts.css
  safe.webmanifest
src/
  components/
    address-book/
      AddressBookHeader/
        index.tsx
      AddressBookTable/
        index.tsx
        styles.module.css
      EntryDialog/
        index.tsx
      ExportDialog/
        index.tsx
      ImportDialog/
        index.tsx
        styles.module.css
        validation.ts
      RemoveDialog/
        index.tsx
    balances/
      AssetsHeader/
        index.tsx
      AssetsTable/
        FiatBalance.tsx
        FiatChange.tsx
        index.tsx
        SendButton.tsx
        styles.module.css
        useHideAssets.ts
      CurrencySelect/
        index.tsx
        useCurrencies.ts
      HiddenTokenButton/
        index.tsx
        styles.module.css
      TokenListSelect/
        index.tsx
      TokenMenu/
        index.tsx
        styles.module.css
    batch/
      BatchIndicator/
        BatchTooltip.tsx
        index.tsx
      BatchSidebar/
        BatchTxItem.tsx
        BatchTxList.tsx
        EmptyBatch.tsx
        index.tsx
        styles.module.css
    common/
      AddFunds/
        index.tsx
      AddressBookInput/
        index.tsx
        styles.module.css
      AddressInput/
        index.tsx
        styles.module.css
        useNameResolver.ts
      AddressInputReadOnly/
        index.tsx
        styles.module.css
      BlockedAddress/
        index.tsx
        styles.module.css
      Breadcrumbs/
        BreadcrumbItem.tsx
        index.tsx
        styles.module.css
      BuyCryptoButton/
        index.tsx
        styles.module.css
      ChainIndicator/
        index.tsx
        styles.module.css
      ChainSwitcher/
        index.tsx
        styles.module.css
      CheckWallet/
        index.tsx
      CheckWalletWithPermission/
        index.tsx
      Chip/
        index.tsx
      ChoiceButton/
        index.tsx
        styles.module.css
      ConnectWallet/
        AccountCenter.tsx
        ConnectionCenter.tsx
        ConnectWalletButton.tsx
        index.tsx
        styles.module.css
        useConnectWallet.ts
      ContextMenu/
        index.tsx
        styles.module.css
      CookieAndTermBanner/
        index.tsx
        styles.module.css
      CooldownButton/
        index.tsx
      CopyAddressButton/
        index.tsx
      CopyButton/
        index.stories.tsx
        index.tsx
      CopyTooltip/
        ConfirmCopyModal.tsx
        index.tsx
        styles.module.css
      Countdown/
        index.tsx
      CustomLink/
        index.tsx
      CustomTooltip/
        index.tsx
      DatePickerInput/
        index.tsx
      DateTime/
        DateTime.stories.tsx
        DateTime.tsx
        DateTimeContainer.tsx
        index.tsx
      Disclaimer/
        index.stories.tsx
        index.tsx
        styles.module.css
      EnhancedTable/
        index.tsx
        styles.module.css
      ErrorBoundary/
        index.tsx
        styles.module.css
      EthHashInfo/
        SrcEthHashInfo/
          index.stories.tsx
          index.tsx
          styles.module.css
        index.stories.tsx
        index.tsx
      ExplorerButton/
        index.tsx
      ExternalLink/
        index.tsx
      FiatValue/
        index.tsx
      FileUpload/
        index.tsx
        styles.module.css
      Footer/
        index.tsx
        styles.module.css
      GeoblockingProvider/
        index.tsx
      Header/
        index.tsx
        styles.module.css
      icons/
        CircularIcon/
          index.tsx
          styles.module.css
        KeyholeIcon/
          index.tsx
      Identicon/
        index.tsx
        styles.module.css
      ImageFallback/
        index.tsx
      InfiniteScroll/
        index.tsx
      InputValueHelper/
        index.tsx
      LegalDisclaimerContent/
        index.tsx
        styles.module.css
      MetaTags/
        index.tsx
      ModalDialog/
        index.tsx
        styles.module.css
      Mui/
        index.tsx
      NamedAddressInfo/
        index.tsx
      NameInput/
        index.tsx
      Navigate/
        index.tsx
      NavTabs/
        index.tsx
        styles.module.css
      NestedSafeBreadcrumbs/
        index.tsx
      NetworkInput/
        index.tsx
        styles.module.css
      NetworkSelector/
        index.tsx
        NetworkMultiSelector.tsx
        styles.module.css
        useChangeNetworkLink.ts
      Notifications/
        index.tsx
        styles.module.css
        useCounter.ts
      NumberField/
        index.tsx
      OnboardingTooltip/
        index.tsx
      OnlyOwner/
        index.tsx
      PageHeader/
        index.tsx
        styles.module.css
      PageLayout/
        index.tsx
        SideDrawer.tsx
        styles.module.css
      PagePlaceholder/
        index.tsx
        styles.module.css
      PaginatedTxns/
        index.tsx
        SkeletonTxList.tsx
      PaperViewToggle/
        index.tsx
      Popup/
        index.tsx
      ProgressBar/
        index.tsx
        styles.module.css
      QRCode/
        index.tsx
      SafeIcon/
        index.tsx
        styles.module.css
      SafeLoadingError/
        index.tsx
      SafeTokenWidget/
        index.tsx
        styles.module.css
      SpendingLimitLabel/
        index.tsx
      SplitMenuButton/
        index.tsx
      Sticky/
        index.tsx
      Table/
        DataRow.stories.tsx
        DataRow.tsx
        DataTable.stories.tsx
        DataTable.tsx
        EmptyRow.tsx
        styles.module.css
      ToggleButtonGroup/
        index.tsx
      TokenAmount/
        index.stories.tsx
        index.tsx
        styles.module.css
      TokenAmountInput/
        index.tsx
        styles.module.css
      TokenExplorerLink/
        index.tsx
      TokenIcon/
        index.tsx
        styles.module.css
      Track/
        index.tsx
      TxModalDialog/
        index.tsx
        styles.module.css
      UnreadBadge/
        index.tsx
      WalletBalance/
        index.tsx
      WalletIcon/
        index.tsx
      WalletInfo/
        index.tsx
        styles.module.css
      WalletOverview/
        index.tsx
        styles.module.css
      WalletProvider/
        index.tsx
      WidgetDisclaimer/
        index.tsx
        styles.module.css
    dashboard/
      Assets/
        index.tsx
      FirstSteps/
        index.tsx
        styles.module.css
      GovernanceSection/
        GovernanceSection.tsx
        styles.module.css
      Overview/
        Overview.tsx
      PendingTxs/
        PendingRecoveryListItem.tsx
        PendingTxListItem.tsx
        PendingTxsList.tsx
        styles.module.css
      SafeAppsDashboardSection/
        SafeAppsDashboardSection.tsx
        styles.module.css
      StakingBanner/
        index.tsx
        styles.module.css
      index.tsx
      styled.tsx
      styles.module.css
    new-safe/
      CardStepper/
        index.tsx
        styles.module.css
        useCardStepper.ts
      create/
        CreateSafeInfos/
          index.tsx
        InfoWidget/
          index.tsx
          styles.module.css
        logic/
          address-book.ts
          index.ts
          utils.ts
        NetworkWarning/
          index.tsx
        NoWalletConnectedWarning/
          index.tsx
        OverviewWidget/
          index.tsx
          styles.module.css
        steps/
          AdvancedOptionsStep/
            index.tsx
          OwnerPolicyStep/
            index.tsx
            useSafeSetupHints.ts
          ReviewStep/
            index.tsx
            styles.module.css
          SetNameStep/
            index.tsx
            styles.module.css
          StatusStep/
            LoadingSpinner/
              index.tsx
              styles.module.css
            index.tsx
            StatusMessage.tsx
            StatusStep.tsx
            styles.module.css
            useUndeployedSafe.ts
        AdvancedCreateSafe.tsx
        index.tsx
        styles.module.css
        types.d.ts
        useEstimateSafeCreationGas.ts
        useSyncSafeCreationStep.ts
      load/
        steps/
          SafeOwnerStep/
            index.tsx
          SafeReviewStep/
            index.tsx
          SetAddressStep/
            index.tsx
        index.tsx
      OwnerRow/
        index.tsx
        styles.module.css
      ReviewRow/
        index.tsx
    nfts/
      NftCollections/
        index.tsx
      NftGrid/
        index.tsx
      NftPreviewModal/
        index.tsx
        styles.module.css
      NftSendForm/
        index.tsx
      config.ts
    notification-center/
      NotificationCenter/
        index.tsx
        styles.module.css
      NotificationCenterItem/
        index.tsx
        styles.module.css
      NotificationCenterList/
        index.tsx
        styles.module.css
      NotificationRenewal/
        index.tsx
    safe-apps/
      AddCustomAppModal/
        CustomApp.tsx
        CustomAppPlaceholder.tsx
        index.tsx
        styles.module.css
      AddCustomSafeAppCard/
        index.tsx
      AppFrame/
        TransactionQueueBar/
          index.tsx
          styles.module.css
        index.tsx
        SafeAppIframe.tsx
        styles.module.css
        ThirdPartyCookiesWarning.tsx
        useAppCommunicator.ts
        useAppIsLoading.ts
        useFromAppAnalytics.ts
        useGetSafeInfo.ts
        useThirdPartyCookies.ts
        useTransactionQueueBarState.ts
      hooks/
        useShareSafeAppUrl.ts
      NativeSwapsCard/
        index.stories.tsx
        index.tsx
        styles.module.css
      SafeAppActionButtons/
        index.tsx
      SafeAppCard/
        index.tsx
        styles.module.css
      SafeAppIconCard/
        index.tsx
      SafeAppLandingPage/
        AppActions.tsx
        constants.ts
        index.tsx
        SafeAppDetails.tsx
        TryDemo.tsx
      SafeAppList/
        index.tsx
        styles.module.css
      SafeAppPreviewDrawer/
        index.tsx
        styles.module.css
      SafeAppsErrorBoundary/
        index.tsx
        SafeAppsLoadError.tsx
        styles.module.css
      SafeAppsFilters/
        index.tsx
        styles.module.css
      SafeAppsHeader/
        index.tsx
        styles.module.css
      SafeAppsInfoModal/
        AllowedFeaturesList.tsx
        constants.ts
        Domain.tsx
        index.tsx
        Slider.tsx
        styles.module.css
        UnknownAppWarning.tsx
        useSafeAppsInfoModal.ts
      SafeAppsListHeader/
        index.tsx
        styles.module.css
      SafeAppSocialLinksCard/
        index.tsx
        styles.module.css
      SafeAppsSDKLink/
        index.tsx
        styles.module.css
      SafeAppsZeroResultsPlaceholder/
        index.tsx
      SafeAppTags/
        index.tsx
        styles.module.css
      PermissionCheckbox.tsx
      PermissionsPrompt.tsx
      RemoveCustomAppModal.tsx
      types.ts
      utils.ts
    safe-messages/
      DecodedMsg/
        index.tsx
        styles.module.css
      InfoBox/
        index.tsx
        styles.module.css
      Msg/
        index.tsx
        styles.module.css
      MsgDetails/
        index.tsx
      MsgList/
        index.tsx
      MsgListItem/
        ExpandableMsgItem.tsx
        index.tsx
      MsgShareLink/
        index.tsx
      MsgSigners/
        index.tsx
        styles.module.css
      MsgSummary/
        index.tsx
      MsgType/
        index.tsx
      PaginatedMsgs/
        index.tsx
      SignMsgButton/
        index.tsx
      SingleMsg/
        index.tsx
    settings/
      ClearPendingTxs/
        index.tsx
      ContractVersion/
        index.tsx
      DataManagement/
        FileListCard.tsx
        ImportDialog.tsx
        ImportFileUpload.tsx
        index.tsx
        styles.module.css
        useGlobalImportFileParser.ts
      EnvironmentVariables/
        EnvHintButton/
          index.tsx
          styles.module.css
        index.tsx
      FallbackHandler/
        index.tsx
      NestedSafesList/
        index.tsx
      owner/
        EditOwnerDialog/
          index.tsx
        OwnerList/
          index.tsx
      ProposersList/
        index.tsx
      PushNotifications/
        hooks/
          useNotificationPreferences.ts
          useNotificationRegistrations.ts
          useNotificationsRenewal.ts
          useNotificationsTokenVersion.ts
          useNotificationTracking.ts
          useShowNotificationsRenewalMessage.ts
        constants.ts
        GlobalPushNotifications.tsx
        index.tsx
        logic.ts
        styles.module.css
      RequiredConfirmations/
        index.tsx
      SafeAppsPermissions/
        index.tsx
      SafeAppsSigningMethod/
        index.tsx
      SafeModules/
        index.tsx
      SecurityLogin/
        index.tsx
      SecuritySettings/
        index.tsx
      SettingsHeader/
        index.tsx
      SpendingLimits/
        index.tsx
        NoSpendingLimits.tsx
        SpendingLimitsTable.tsx
      TransactionGuards/
        index.tsx
        styles.module.css
    sidebar/
      DebugToggle/
        index.tsx
      IndexingStatus/
        index.tsx
      NestedSafeInfo/
        index.tsx
      NestedSafesButton/
        index.tsx
        styles.module.css
      NestedSafesList/
        index.tsx
      NestedSafesPopover/
        index.tsx
      NewTxButton/
        index.tsx
      QrCodeButton/
        index.tsx
        QrModal.tsx
      SafeListContextMenu/
        index.tsx
        MultiAccountContextMenu.tsx
      SafeListRemoveDialog/
        index.tsx
      Sidebar/
        index.tsx
        styles.module.css
      SidebarFooter/
        index.tsx
      SidebarHeader/
        index.tsx
        styles.module.css
      SidebarList/
        index.tsx
        styles.module.css
      SidebarNavigation/
        config.tsx
        index.tsx
    theme/
      darkPalette.ts
      lightPalette.ts
      safeTheme.ts
      SafeThemeProvider.tsx
      typography.ts
    transactions/
      BatchExecuteButton/
        BatchExecuteHoverProvider.tsx
        index.tsx
      BulkTxListGroup/
        index.tsx
        styles.module.css
      ExecuteTxButton/
        index.tsx
      GroupedTxListItems/
        index.tsx
        ReplaceTxHoverProvider.tsx
        styles.module.css
      GroupLabel/
        index.tsx
        styles.module.css
      HexEncodedData/
        index.tsx
        styles.module.css
      ImitationTransactionWarning/
        index.tsx
        styles.module.css
      InfoDetails/
        index.tsx
        styles.module.css
      MaliciousTxWarning/
        index.tsx
      RejectTxButton/
        index.tsx
      SafeCreationTx/
        index.tsx
        styles.module.css
      SignedMessagesHelpLink/
        index.tsx
      SignTxButton/
        index.tsx
        styles.module.css
      SingleTx/
        index.tsx
      TrustedToggle/
        index.tsx
        TrustedToggleButton.tsx
      TxConfirmations/
        index.tsx
      TxDateLabel/
        index.tsx
        styles.module.css
      TxDetails/
        Summary/
          SafeTxHashDataRow/
            index.tsx
          TxDataRow/
            index.tsx
          DecoderLinks.tsx
          index.tsx
        TxData/
          DecodedData/
            MethodDetails/
              index.tsx
            Multisend/
              index.tsx
              styles.module.css
            SingleTxDecoded/
              index.tsx
              styles.module.css
            ValueArray/
              index.tsx
              styles.module.css
            index.tsx
            MethodCall.tsx
          MigrationToL2TxData/
            index.tsx
          NestedTransaction/
            ExecTransaction/
              index.tsx
            OnChainConfirmation/
              index.tsx
            NestedTransaction.tsx
          Rejection/
            index.tsx
          SafeUpdate/
            index.tsx
          SettingsChange/
            index.tsx
          SpendingLimits/
            index.tsx
            styles.module.css
          Transfer/
            index.tsx
            TransferActions.tsx
          index.tsx
        index.tsx
        SafeTxGasForm.tsx
        styles.module.css
      TxFilterForm/
        index.tsx
        styles.module.css
      TxHeader/
        index.tsx
      TxInfo/
        index.tsx
        styles.module.css
      TxList/
        index.tsx
        styles.module.css
      TxListItem/
        ExpandableTransactionItem.tsx
        index.tsx
        styles.module.css
      TxNavigation/
        index.tsx
      TxShareLink/
        index.tsx
        styles.module.css
        TxShareButton.tsx
        TxShareLink.tsx
      TxSigners/
        index.tsx
        styles.module.css
      TxStatusChip/
        index.stories.tsx
        index.tsx
      TxStatusLabel/
        index.tsx
      TxSummary/
        index.tsx
        QueueActions.tsx
        styles.module.css
      TxType/
        index.tsx
        styles.module.css
      Warning/
        index.tsx
        styles.module.css
    tx/
      AdvancedParams/
        AdvancedParamsForm.tsx
        GasLimitInput.tsx
        index.tsx
        types.ts
        useAdvancedParams.ts
        useUserNonce.ts
      ApprovalEditor/
        hooks/
          useApprovalInfos.ts
        utils/
          approvals.ts
        ApprovalEditorForm.tsx
        ApprovalItem.tsx
        Approvals.tsx
        ApprovalValueField.tsx
        EditableApprovalItem.tsx
        index.tsx
        SpenderField.tsx
        styles.module.css
      BalanceInfo/
        index.tsx
        styles.module.css
      ColorCodedTxAccordion/
        HelpTooltip.tsx
        index.tsx
      confirmation-views/
        BatchTransactions/
          BatchTransactions.stories.tsx
          index.tsx
          mockData.ts
        ChangeThreshold/
          ChangeThreshold.stories.tsx
          index.tsx
        MigrateToL2Information/
          index.tsx
        NestedSafeCreation/
          index.tsx
        SettingsChange/
          index.tsx
          mockData.ts
          SettingsChange.stories.tsx
          UntrustedFallbackHandlerTxAlert.tsx
        StakingTx/
          index.tsx
        SwapOrder/
          index.tsx
        UpdateSafe/
          index.tsx
        index.tsx
        types.d.ts
        useTxPreview.ts
        utils.ts
      ConfirmationOrder/
        ConfirmationOrderHeader.tsx
      ConfirmTxDetails/
        index.tsx
        NameChip.tsx
        TxDetails.tsx
        TxDetailsRow.tsx
      ConfirmTxReceipt/
        index.tsx
      ErrorMessage/
        index.tsx
        styles.module.css
      ExecuteCheckbox/
        index.tsx
        styles.module.css
      ExecutionMethodSelector/
        index.tsx
        styles.module.css
      FieldsGrid/
        index.tsx
      GasParams/
        index.tsx
        styles.module.css
      RemainingRelays/
        index.tsx
      ReviewTransaction/
        index.tsx
        ReviewTransactionContent.tsx
        ReviewTransactionSkeleton.tsx
      ReviewTransactionV2/
        index.tsx
        ReviewTransactionContent.tsx
        ReviewTransactionSkeleton.tsx
      security/
        blockaid/
          BlockaidBalanceChange.tsx
          BlockaidHint.tsx
          ContractChangeWarning.tsx
          index.tsx
          styles.module.css
          useBlockaid.ts
        shared/
          styles.module.css
          TxSecurityContext.tsx
        tenderly/
          index.tsx
          styles.module.css
          useSimulation.ts
          utils.ts
        SecurityWarnings.tsx
        useDelegateCallModule.ts
        utils.ts
      SendFromBlock/
        index.tsx
        styles.module.css
      SendToBlock/
        index.tsx
      SignOrExecuteForm/
        ConfirmationTitle.tsx
        hooks.ts
        index.tsx
        NonOwnerError.tsx
        RiskConfirmationError.tsx
        SignForm.tsx
        SignOrExecuteForm.tsx
        SignOrExecuteFormV2.tsx
        SignOrExecuteSkeleton.tsx
        styles.module.css
        tracking.ts
        UnknownContractError.tsx
        WalletRejectionError.tsx
      SponsoredBy/
        index.tsx
        styles.module.css
      SuccessMessage/
        index.tsx
        styles.module.css
    tx-flow/
      actions/
        Batching/
          BatchButton.tsx
          index.tsx
        Execute/
          ExecuteForm.tsx
          index.tsx
          styles.module.css
        ExecuteThroughRole/
          ExecuteThroughRoleForm/
            hooks.ts
            index.tsx
            styles.module.css
          index.tsx
        Propose/
          index.tsx
          ProposerForm.tsx
        Sign/
          index.tsx
          SignForm.tsx
        ComboSubmit.tsx
        Counterfactual.tsx
        index.ts
      common/
        OwnerList/
          index.tsx
          styles.module.css
        TxCard/
          index.tsx
        TxFlowContent/
          index.tsx
          styles.module.css
        TxLayout/
          index.tsx
          styles.module.css
        TxNonce/
          index.tsx
          styles.module.css
        TxStatusWidget/
          index.tsx
          styles.module.css
        constants.ts
        styles.module.css
        TxButton.tsx
      features/
        SignerSelect/
          SignerForm/
            index.tsx
            styles.module.css
          index.tsx
        TxChecks/
          index.tsx
          styles.module.css
          TxChecks.tsx
        ExecuteCheckbox.tsx
        index.ts
        TxNote.tsx
      flows/
        AddOwner/
          ChooseOwner.tsx
          context.ts
          index.tsx
          ReviewOwner.tsx
        CancelRecovery/
          CancelRecoveryFlowReview.tsx
          CancelRecoveryOverview.tsx
          index.tsx
          styles.module.css
        ChangeThreshold/
          ChooseThreshold.tsx
          index.tsx
        ConfirmBatch/
          index.tsx
        ConfirmTx/
          ConfirmProposedTx.tsx
          index.tsx
        CreateNestedSafe/
          index.tsx
          ReviewNestedSafe.tsx
          SetupNestedSafe.tsx
          styles.module.css
        ExecuteBatch/
          DecodedTxs.tsx
          index.tsx
          ReviewBatch.tsx
        MigrateSafeL2/
          index.tsx
          MigrateSafeL2Review.tsx
        NestedTxSuccessScreen/
          index.tsx
          styles.module.css
        NewSpendingLimit/
          CreateSpendingLimit.tsx
          index.tsx
          ReviewSpendingLimit.tsx
        NewTx/
          index.tsx
          styles.module.css
        NftTransfer/
          index.tsx
          ReviewNftBatch.tsx
          SendNftBatch.tsx
        RecoverAccount/
          index.tsx
          RecoverAccountFlowReview.tsx
          RecoverAccountFlowSetup.tsx
        RecoveryAttempt/
          index.tsx
          RecoveryAttemptReview.tsx
        RejectTx/
          index.tsx
          RejectTx.tsx
        RemoveGuard/
          index.tsx
          ReviewRemoveGuard.tsx
        RemoveModule/
          index.tsx
          ReviewRemoveModule.tsx
        RemoveOwner/
          index.tsx
          ReviewRemoveOwner.tsx
          SetThreshold.tsx
          styles.module.css
        RemoveRecovery/
          index.tsx
          RemoveRecoveryFlowOverview.tsx
          RemoveRecoveryFlowReview.tsx
        RemoveSpendingLimit/
          index.tsx
          RemoveSpendingLimit.tsx
        ReplaceOwner/
          index.tsx
        ReplaceTx/
          DeleteTxModal.tsx
          index.tsx
          styles.module.css
        SafeAppsTx/
          ConfirmSafeAppsTxDetails.tsx
          index.tsx
          ReviewSafeAppsTx.tsx
        SignMessage/
          index.tsx
          SignMessage.tsx
        SignMessageOnChain/
          ConfirmSignMessageOnChainDetails.tsx
          index.tsx
          ReviewSignMessageOnChain.tsx
        SuccessScreen/
          statuses/
            DefaultStatus.tsx
            IndexingStatus.tsx
            ProcessingStatus.tsx
          index.tsx
          StatusMessage.tsx
          StatusStepper.tsx
          styles.module.css
        TokenTransfer/
          CSVAirdropAppModal/
            index.tsx
          RecipientRow/
            index.tsx
          SpendingLimitRow/
            index.tsx
            styles.module.css
          CreateTokenTransfer.tsx
          index.tsx
          ReviewRecipientRow.tsx
          ReviewSpendingLimitTx.tsx
          ReviewTokenTransfer.tsx
          ReviewTokenTx.tsx
          SendAmountBlock.tsx
          utils.ts
        UpdateSafe/
          index.tsx
          UpdateSafeReview.tsx
        UpsertRecovery/
          index.tsx
          RecovererSmartContractWarning.tsx
          styles.module.css
          UpsertRecoveryFlowIntro.tsx
          UpsertRecoveryFlowReview.tsx
          UpsertRecoveryFlowSettings.tsx
          useRecoveryPeriods.ts
          utils.ts
        index.ts
      slots/
        hooks/
          index.ts
          useRegisterSlot.ts
          useSlot.ts
          useSlotContext.ts
          useSlotIds.ts
        index.ts
        Slot.tsx
        SlotProvider.tsx
        withSlot.tsx
      index.tsx
      SafeTxProvider.tsx
      TxFlow.tsx
      TxFlowProvider.tsx
      TxFlowStep.tsx
      TxInfoProvider.tsx
      useTxStepper.tsx
    welcome/
      WelcomeLogin/
        index.tsx
        styles.module.css
        WalletLogin.tsx
      NewSafe.tsx
      styles.module.css
    wrappers/
      DisclaimerWrapper/
        index.tsx
      FeatureWrapper/
        index.tsx
      SanctionWrapper/
        index.tsx
  config/
    chains.ts
    constants.ts
    gateway.ts
    routes.ts
    securityHeaders.ts
  features/
    bridge/
      components/
        Bridge/
          index.tsx
        BridgeWidget/
          index.tsx
      hooks/
        useIsBridgeFeatureEnabled.ts
    counterfactual/
      hooks/
        useDeployGasLimit.ts
        useIsCounterfactualSafe.ts
        usePendingSafeNotifications.ts
        usePendingSafeStatuses.ts
      services/
        safeCreationEvents.ts
      store/
        undeployedSafesSlice.ts
      ActivateAccountButton.tsx
      ActivateAccountFlow.tsx
      CheckBalance.tsx
      CounterfactualForm.tsx
      CounterfactualHooks.tsx
      CounterfactualStatusButton.tsx
      CounterfactualSuccessScreen.tsx
      FirstTxFlow.tsx
      LazyCounterfactual.tsx
      PayNowPayLater.tsx
      styles.module.css
      useCounterfactualBalances.ts
      utils.ts
    multichain/
      components/
        CreateSafeOnNewChain/
          index.tsx
        NetworkLogosList/
          index.tsx
          styles.module.css
        SignerSetupWarning/
          ChangeSignerSetupWarning.tsx
          InconsistentSignerSetupWarning.tsx
        UnsupportedMastercopyWarning/
          UnsupportedMasterCopyWarning.tsx
      hooks/
        useCompatibleNetworks.ts
        useIsMultichainSafe.ts
        useSafeCreationData.ts
      utils/
        utils.ts
    myAccounts/
      components/
        AccountInfoChips/
          index.tsx
          styles.module.css
        AccountItems/
          MultiAccountItem.tsx
          SingleAccountItem.tsx
          styles.module.css
        AccountListFilters/
          index.tsx
        AccountsHeader/
          index.tsx
        AccountsList/
          index.tsx
        AccountsNavigation/
          index.tsx
        AddNetworkButton/
          index.tsx
        AllSafes/
          index.tsx
        CreateButton/
          index.tsx
        CurrentSafe/
          index.tsx
        DataWidget/
          index.tsx
          styles.module.css
        FilteredSafes/
          index.tsx
        OrderByButton/
          index.tsx
        PinnedSafes/
          index.tsx
        QueueActions/
          index.tsx
          styles.module.css
        SafesList/
          index.tsx
      hooks/
        __tests__/
          useAllSafesGrouped.ts
        useAllOwnedSafes.ts
        useAllSafes.ts
        useAllSafesGrouped.ts
        useGetHref.ts
        useHasSafes.ts
        useSafesSearch.ts
        useTrackedSafesCount.ts
        useVisitedSafes.ts
      utils/
        utils.ts
      index.tsx
      styles.module.css
    proposers/
      components/
        DeleteProposerDialog.tsx
        EditProposerDialog.tsx
        TxProposalChip.tsx
        UpsertProposer.tsx
      utils/
        utils.ts
    recovery/
      components/
        CancelRecoveryButton/
          index.tsx
        ExecuteRecoveryButton/
          index.tsx
        GroupedRecoveryListItems/
          index.tsx
          styles.module.css
        Recovery/
          index.tsx
          LazyRecovery.tsx
        RecoveryCards/
          RecoveryInProgressCard.tsx
          RecoveryProposalCard.tsx
          styles.module.css
        RecoveryContext/
          index.tsx
          RecoveryContextHooks.tsx
          useRecoveryDelayModifiers.ts
          useRecoveryPendingTxs.ts
          useRecoveryState.ts
          useRecoverySuccessEvents.ts
        RecoveryDescription/
          index.tsx
        RecoveryDetails/
          index.tsx
        RecoveryHeader/
          index.tsx
        RecoveryInfo/
          index.tsx
        RecoveryList/
          index.tsx
          LazyRecoveryList.tsx
        RecoveryListItem/
          index.tsx
          RecoveryListItemContext.tsx
        RecoveryModal/
          index.tsx
        RecoverySettings/
          ChooseRecoveryMethodModal.tsx
          DelayModifierRow.tsx
          index.tsx
          styles.module.css
          ZkEmailFakeDoorModal.tsx
        RecoverySigners/
          index.tsx
        RecoveryStatus/
          index.tsx
        RecoverySummary/
          index.tsx
        RecoveryType/
          index.tsx
        RecoveryValidationErrors/
          index.tsx
      hooks/
        useIsRecoverer.ts
        useIsRecoveryEnabled.ts
        useIsRecoverySupported.ts
        useIsValidRecoveryExecution.ts
        useRecovery.ts
        useRecoveryQueue.ts
        useRecoveryTxNotification.ts
        useRecoveryTxState.ts
      services/
        delay-modifier.ts
        proxies.ts
        recovery-sender.ts
        recovery-state.ts
        recoveryEvents.ts
        selectors.ts
        setup.ts
        transaction-list.ts
        transaction.ts
    spaces/
      components/
        AddAccounts/
          AddManually.tsx
          index.tsx
          SafesList.tsx
          styles.module.css
        AddMemberModal/
          index.tsx
          MemberInfoForm.tsx
          styles.module.css
        AuthState/
          index.tsx
        Dashboard/
          AddAccountsCard.tsx
          AggregatedBalances.tsx
          DashboardMembersList.tsx
          index.tsx
          MembersCard.tsx
          NewFeaturesCard.tsx
          SpacesCTACard.tsx
          styles.module.css
        InitialsAvatar/
          index.tsx
          styles.module.css
        InviteBanner/
          AcceptButton.tsx
          AcceptInviteDialog.tsx
          DeclineButton.tsx
          DeclineInviteDialog.tsx
          index.tsx
          PreviewInvite.tsx
          styles.module.css
        LoadingState/
          index.tsx
        Members/
          index.tsx
        MembersList/
          EditMemberDialog.tsx
          index.tsx
          MemberName.tsx
          RemoveMemberDialog.tsx
        SafeAccounts/
          EmptySafeAccounts.tsx
          index.tsx
          RemoveSafeDialog.tsx
          SendTransactionButton.tsx
          SpaceSafeContextMenu.tsx
          styles.module.css
        SearchInput/
          index.tsx
        SignedOutState/
          index.tsx
        SignInButton/
          index.tsx
        SpaceBreadcrumbs/
          index.tsx
          styles.module.css
        SpaceCard/
          index.tsx
          SpaceContextMenu.tsx
          styles.module.css
        SpaceCreationModal/
          index.tsx
        SpaceInfoModal/
          index.tsx
        SpacesDashboardWidget/
          index.tsx
        SpaceSettings/
          DeleteSpaceDialog.tsx
          index.tsx
          styles.module.css
          UpdateSpaceDialog.tsx
          UpdateSpaceForm.tsx
        SpaceSidebar/
          index.tsx
          styles.module.css
        SpaceSidebarNavigation/
          config.tsx
          index.tsx
        SpaceSidebarSelector/
          index.tsx
          styles.module.css
        SpacesList/
          index.tsx
          styles.module.css
        UnauthorizedState/
          index.tsx
        UserSettings/
          index.tsx
          styles.module.css
      hooks/
        useCurrentSpaceId.ts
        useFeatureFlagRedirect.ts
        useMembersSearch.ts
        useSpaceMembers.tsx
        useSpaceSafeCount.tsx
        useSpaceSafes.tsx
        useTrackSpace.ts
      utils.ts
    speedup/
      components/
        SpeedUpModal.tsx
        SpeedUpMonitor.tsx
      hooks/
        useSafeTransaction.tsx
      utils/
        IsSpeedableTx.tsx
    stake/
      components/
        InfoTooltip/
          index.tsx
        StakeButton/
          index.tsx
        StakePage/
          index.tsx
        StakingConfirmationTx/
          Deposit.tsx
          Exit.tsx
          index.tsx
          Withdraw.tsx
        StakingStatus/
          index.tsx
        StakingTxDepositDetails/
          index.tsx
        StakingTxDepositInfo/
          index.tsx
        StakingTxExitDetails/
          index.tsx
        StakingTxExitInfo/
          index.tsx
        StakingTxWithdrawDetails/
          index.tsx
        StakingTxWithdrawInfo/
          index.tsx
        StakingWidget/
          index.tsx
      helpers/
        utils.ts
      hooks/
        useGetStakeWidgetUrl.ts
        useIsStakingBannerEnabled.ts
        useIsStakingFeatureEnabled.ts
      constants.ts
      useStakeConsent.ts
    swap/
      components/
        HelpIconTooltip/
          index.tsx
        OrderId/
          index.stories.tsx
          index.tsx
        StatusLabel/
          index.stories.tsx
          index.tsx
        SwapButton/
          index.tsx
        SwapOrder/
          rows/
            PartBuyAmount.tsx
            PartDuration.tsx
            PartSellAmount.tsx
            SurplusFee.tsx
          index.tsx
          styles.module.css
          swap.stories.tsx
          twap.stories.tsx
        SwapOrderConfirmationView/
          index.stories.tsx
          index.tsx
          OrderFeeConfirmationView.tsx
          styles.module.css
        SwapProgress/
          index.stories.tsx
          index.tsx
        SwapTokens/
          index.stories.tsx
          index.tsx
        SwapTxInfo/
          SwapTx.tsx
        TwapFallbackHandlerWarning/
          index.tsx
      helpers/
        data/
          stablecoins.ts
        fee.ts
        swapOrderBuilder.ts
        utils.ts
      hooks/
        useIsExpiredSwap.ts
        useIsSwapFeatureEnabled.ts
        useIsTWAPFallbackHandler.ts
      store/
        swapParamsSlice.ts
      constants.ts
      index.tsx
      styles.module.css
      useSwapConsent.ts
    targetedFeatures/
      hooks/
        useIsOutreachSafe.ts
        useIsTargetedFeature.ts
      constants.ts
    targetedOutreach/
      components/
        OutreachPopup/
          index.tsx
          OutreachPopup.tsx
          styles.module.css
      hooks/
        useShowOutreachPopup.tsx
      constants.ts
    tx-notes/
      encodeTxNote.ts
      index.tsx
      TxNote.tsx
      TxNoteForm.tsx
      TxNoteInput.tsx
    walletconnect/
      components/
        WalletConnectProvider/
          index.tsx
        WalletConnectUi/
          index.tsx
        WcConnectionForm/
          index.tsx
          styles.module.css
        WcConnectionState/
          index.tsx
          styles.module.css
        WcErrorMessage/
          index.tsx
          styles.module.css
        WcHeaderWidget/
          index.tsx
          WcIcon.tsx
        WcHints/
          index.tsx
          styles.module.css
        WcInput/
          index.tsx
        WcLogoHeader/
          index.tsx
          styles.module.css
        WcProposalForm/
          CompatibilityWarning.tsx
          index.tsx
          ProposalVerification.tsx
          styles.module.css
          useCompatibilityWarning.ts
        WcSessionList/
          index.tsx
          styles.module.css
          WcNoSessions.tsx
        WcSessionManager/
          index.tsx
        index.tsx
      hooks/
        useWalletConnectClipboardUri.ts
        useWalletConnectSearchParamUri.ts
        useWalletConnectSessions.ts
        useWcUri.ts
      services/
        tracking.ts
        utils.ts
        WalletConnectWallet.ts
      constants.ts
      WalletConnectContext.tsx
  hooks/
    Beamer/
      useBeamer.ts
    coreSDK/
      safeCoreSDK.ts
      useInitSafeCoreSDK.ts
    loadables/
      useLoadBalances.ts
      useLoadChains.ts
      useLoadSafeInfo.ts
      useLoadSafeMessages.ts
      useLoadSpendingLimits.ts
      useLoadTxHistory.ts
      useLoadTxQueue.ts
    messages/
      useDecodedSafeMessage.ts
      useIsSafeMessagePending.ts
      useIsSafeMessageSignableBy.ts
      useSafeMessage.ts
      useSafeMessageNotifications.ts
      useSafeMessagePendingStatuses.ts
      useSafeMessages.ts
      useSafeMessageStatus.ts
      useSafeMsgTracking.ts
      useSyncSafeMessageSigner.ts
    safe-apps/
      permissions/
        index.ts
        useBrowserPermissions.ts
        useSafePermissions.ts
      useAppsFilterByCategory.ts
      useAppsFilterByOptimizedForBatch.ts
      useAppsSearch.ts
      useCategoryFilter.ts
      useCustomAppCommunicator.tsx
      useCustomSafeApps.ts
      useOpenedSafeApps.ts
      usePinnedSafeApps.ts
      useRankedSafeApps.ts
      useRemoteSafeApps.ts
      useRemoveAppModal.ts
      useSafeAppFromBackend.ts
      useSafeAppFromManifest.ts
      useSafeAppPreviewDrawer.ts
      useSafeApps.ts
      useSafeAppsFilters.ts
      useSafeAppUrl.ts
      useTxBuilderApp.ts
    useMnemonicName/
      dict.ts
      index.ts
    wallets/
      consts.ts
      useInitWeb3.ts
      useOnboard.ts
      useWallet.ts
      useWalletBalance.ts
      wallets.ts
      web3.ts
    useAddressBook.ts
    useAddressResolver.ts
    useAdjustUrl.ts
    useAllAddressBooks.ts
    useBalances.ts
    useBatchedTxs.ts
    useChainId.ts
    useChains.ts
    useChangedValue.ts
    useClock.ts
    useCollectibles.ts
    useCompatibilityFallbackHandlerDeployments.ts
    useDarkMode.ts
    useDebounce.ts
    useDraftBatch.ts
    useGasLimit.ts
    useGasPrice.ts
    useHiddenTokens.ts
    useHighlightHiddenTab.ts
    useInitSession.ts
    useIntervalCounter.ts
    useIsGeoblockedFeatureEnabled.ts
    useIsMac.ts
    useIsNestedSafeOwner.ts
    useIsOfficialFallbackHandler.ts
    useIsOfficialHost.ts
    useIsOnlySpendingLimitBeneficiary.tsx
    useIsPending.ts
    useIsSafeOwner.ts
    useIsSidebarRoute.ts
    useIsSpaceRoute.ts
    useIsValidExecution.ts
    useIsWrongChain.ts
    useLastSafe.ts
    useLoadableStores.ts
    useMasterCopies.ts
    useNestedSafeOwners.tsx
    useOnceVisible.ts
    useOrigin.ts
    useOwnedSafes.ts
    useParentSafe.ts
    usePendingActions.ts
    usePendingTxs.ts
    usePredictSafeAddressFromTxDetails.ts
    usePreviousNonces.ts
    useProposers.ts
    useRemainingRelays.ts
    useSafeAddress.ts
    useSafeAddressFromUrl.ts
    useSafeInfo.ts
    useSafeNotifications.ts
    useSafeTokenAllocation.ts
    useSafeTokenEnabled.ts
    useSanctionedAddress.ts
    useSpendingLimit.ts
    useSpendingLimitGas.ts
    useTransactionStatus.ts
    useTransactionType.tsx
    useTxDetails.ts
    useTxHistory.ts
    useTxNotifications.ts
    useTxPendingStatuses.ts
    useTxQueue.ts
    useTxTracking.ts
    useValidateTxData.ts
    useVisibleBalances.ts
    useWalletCanPay.ts
    useWalletCanRelay.ts
  pages/
    apps/
      bookmarked.tsx
      custom.tsx
      index.tsx
      open.tsx
    balances/
      index.tsx
      nfts.tsx
    new-safe/
      advanced-create.tsx
      create.tsx
      load.tsx
    settings/
      safe-apps/
        index.tsx
      appearance.tsx
      data.tsx
      environment-variables.tsx
      index.tsx
      modules.tsx
      notifications.tsx
      security.tsx
      setup.tsx
    share/
      safe-app.tsx
    spaces/
      index.tsx
      members.tsx
      safe-accounts.tsx
      settings.tsx
    transactions/
      history.tsx
      index.tsx
      messages.tsx
      msg.tsx
      queue.tsx
      tx.tsx
    welcome/
      accounts.tsx
      index.tsx
      spaces.tsx
    _app.tsx
    _document.tsx
    _offline.tsx
    403.tsx
    404.tsx
    addOwner.tsx
    address-book.tsx
    bridge.tsx
    home.tsx
    imprint.tsx
    index.tsx
    privacy.tsx
    stake.tsx
    swap.tsx
    terms.tsx
    user-settings.tsx
    wc.tsx
  permissions/
    hoc/
      withPermission.tsx
      withRole.tsx
    hooks/
      useHasPermission.ts
      useHasRoles.ts
      usePermission.ts
      useRoleProps.ts
      useRoles.ts
    config.ts
    getRolePermissions.ts
  service-workers/
    firebase-messaging/
      firebase-messaging-sw.ts
      notification-mapper.ts
      notifications.ts
      webhook-types.ts
    index.ts
  services/
    analytics/
      events/
        addressBook.ts
        assets.ts
        batching.ts
        bridge.ts
        counterfactual.ts
        createLoadSafe.ts
        index.ts
        modals.ts
        nested-safes.ts
        nfts.ts
        outreach.ts
        overview.ts
        push-notifications.ts
        recovery.ts
        reject-tx.ts
        safeApps.ts
        settings.ts
        spaces.ts
        stake.ts
        swaps.ts
        transactions.ts
        txList.ts
        wallet.ts
        walletconnect.ts
      Analytics.tsx
      gtm.ts
      index.ts
      spindl.ts
      tx-tracking.ts
      types.ts
      useGtm.ts
      useMetaEvents.ts
    beamer/
      index.ts
      types.ts
    contracts/
      ContractErrorCodes.ts
      safeContracts.ts
      spendingLimitContracts.ts
    datadog/
      index.ts
    ens/
      index.ts
    exceptions/
      index.ts
    local-storage/
      local.ts
      session.ts
      Storage.ts
      storageHelpers.ts
      useLocalStorage.ts
    ls-migration/
      addedSafes.ts
      addressBook.ts
      common.ts
    onboard/
      ledger-module.ts
    private-key-module/
      icon.ts
      index.ts
      pk-popup-store.ts
      PkModulePopup.tsx
    push-notifications/
      firebase.ts
      preferences.ts
      tracking.ts
    safe-apps/
      AppCommunicator.ts
      manifest.ts
      track-app-usage-count.ts
    safe-messages/
      safeMsgEvents.ts
      safeMsgNotifications.ts
      safeMsgSender.ts
    safe-wallet-provider/
      index.ts
      notifications.ts
      useSafeWalletProvider.tsx
    siwe/
      utils/
        index.ts
      useSiwe.tsx
    tracking/
      abTesting.ts
      useAbTesting.ts
    transactions/
      index.tests.ts
      index.ts
    tx/
      tx-sender/
        create.ts
        dispatch.ts
        index.ts
        recommendedNonce.ts
        sdk.ts
        spendingLimit.ts
      encodeSignatures.ts
      extractTxInfo.ts
      proposeTransaction.ts
      safeUpdateParams.ts
      spendingLimitParams.ts
      tokenTransferParams.ts
      txEvents.ts
      txMonitor.ts
    EventBus.ts
    onboard.ts
    sentry.ts
  store/
    api/
      gateway/
        index.ts
        proposers.ts
        safeOverviews.ts
      ofac.ts
      safePass.ts
    addedSafesSlice.ts
    addressBookSlice.ts
    authSlice.ts
    balancesSlice.ts
    batchSlice.ts
    broadcast.ts
    chainsSlice.ts
    common.ts
    index.ts
    notificationsSlice.ts
    orderByPreferenceSlice.ts
    pendingSafeMessagesSlice.ts
    pendingTxsSlice.ts
    persistStore.ts
    popupSlice.ts
    safeAppsSlice.ts
    safeInfoSlice.ts
    safeMessagesSlice.ts
    sessionSlice.ts
    settingsSlice.ts
    slices.ts
    spendingLimitsSlice.ts
    swapOrderSlice.ts
    txHistorySlice.ts
    txQueueSlice.ts
    useHydrateStore.ts
    visitedSafesSlice.ts
  stories/
    Configure.mdx
    storeDecorator.tsx
  styles/
    accordion.module.css
    globals.css
    inputs.module.css
    onboard.css
    spacings.ts
    vars.css
  utils/
    providers/
      UncheckedJsonRpcSigner.ts
    chains.ts
    clipboard.ts
    createEmotionCache.ts
    ethers-utils.ts
    featureToggled.tsx
    gateway.ts
    helpers.ts
    hex.ts
    mad-props.tsx
    nested-safe-wallet.ts
    nested-safes.ts
    relaying.ts
    safe-hashes.ts
    safe-message-guards.ts
    safe-migrations.ts
    safe-versions.ts
    signers.ts
    SimpleTxWatcher.ts
    tokens.ts
    transaction-calldata.ts
    transaction-guards.ts
    transactions.ts
    tx-history-filter.ts
    tx-link.ts
    tx-list.ts
    url.ts
    wallets.ts
  definitions.d.ts
.dockerignore
.env.example
.gitignore
cypress.config.js
Dockerfile
eslint.config.mjs
jest.config.cjs
jest.setup.js
next-env.d.ts
next.config.mjs
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".storybook/main.ts">
import type { StorybookConfig } from '@storybook/nextjs'
import path from 'path'

const config: StorybookConfig = {
  stories: ['../src/**/*.mdx', '../src/**/*.stories.@(js|jsx|mjs|ts|tsx)'],
  addons: [
    '@storybook/addon-onboarding',
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@chromatic-com/storybook',
    '@storybook/addon-interactions',
    '@storybook/addon-themes',
    '@storybook/addon-designs',
  ],
  /**
   * In our monorepo setup, if we just specify the name,
   * we end up with the wrong path to webpack5 preset. We need to
   * resolve the path:
   *
   * https://github.com/storybookjs/storybook/issues/21216#issuecomment-2187481646
   */
  framework: path.resolve(require.resolve('@storybook/nextjs/preset'), '..'),
  webpackFinal: async (config) => {
    config.module = config.module || {}
    config.module.rules = config.module.rules || []

    // This modifies the existing image rule to exclude .svg files
    // since you want to handle those files with @svgr/webpack
    const imageRule = config.module.rules.find((rule) => rule?.['test']?.test('.svg'))
    if (imageRule) {
      imageRule['exclude'] = /\.svg$/
    }

    config.module.rules.push({
      test: /\.svg$/i,
      issuer: { and: [/\.(js|ts|md)x?$/] },
      use: [
        {
          loader: '@svgr/webpack',
          options: {
            prettier: false,
            svgo: false,
            svgoConfig: {
              plugins: [
                {
                  name: 'preset-default',
                  params: {
                    overrides: { removeViewBox: false },
                  },
                },
              ],
            },
            titleProp: true,
          },
        },
      ],
    })

    return config
  },
  docs: {
    autodocs: 'tag',
  },
  staticDirs: ['../public'],

  typescript: {
    reactDocgen: 'react-docgen-typescript',
    reactDocgenTypescriptOptions: {
      // Speeds up Storybook build time
      compilerOptions: {
        allowSyntheticDefaultImports: false,
        esModuleInterop: false,
      },
      // Makes union prop types like variant and size appear as select controls
      shouldExtractLiteralValuesFromEnum: true,
      // Makes string and boolean types that can be undefined appear as inputs and switches
      shouldRemoveUndefinedFromOptional: true,
      // Filter out third-party props from node_modules except @mui packages
      propFilter: (prop) => (prop.parent ? !/node_modules\/(?!@mui)/.test(prop.parent.fileName) : true),
    },
  },
}
export default config
</file>

<file path=".storybook/preview.ts">
import type { Preview } from '@storybook/react'

import { ThemeProvider, CssBaseline } from '@mui/material'
import { withThemeFromJSXProvider } from '@storybook/addon-themes'
import createSafeTheme from '../src/components/theme/safeTheme'

import '../src/styles/globals.css'

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
  },

  decorators: [
    withThemeFromJSXProvider({
      GlobalStyles: CssBaseline,
      Provider: ThemeProvider,
      themes: {
        light: createSafeTheme('light'),
        dark: createSafeTheme('dark'),
      },
      defaultTheme: 'light',
    }),
  ],
}

export default preview
</file>

<file path="docs/code-style.md">
# 💝 Code Style Guidelines

## Principles

- Rely on automation/IDE
- Strive for pragmatism
- Don’t add bells and whistles (newlines, spaces for “beauty”, ordering imports etc.)
- Avoid unnecessary stylistic changes
  - They increase the chance of git conflicts (esp. in imports)
  - They make it harder to review the PR
  - Ultimately, a waste of time

## Functional code style

- Write small functions that do one thing with no side-effects
- Compose small functions to do more things
- Same with components: don’t write giant components, write small composable components
- Prefer `map`/`filter` over `reduce`/`forEach`
- Watch out when using destructive methods like `pop` or `sort` (yes, `sort` is destructive!)
- Avoid initializing things on the module level, prefer to export an init function instead

## Reactive programming

- Keep in mind the React component life-cycle, avoid excessive re-renders
- Glue regular JS functions and events with React using hooks
- Write small `useEffect` hooks that do just one thing and have only necessary dependencies

## Variable/function naming

Infamously, the hardest problem in computer science.

- Components are classes, so their names should be in PascalCase
- Config-like constants should be in UPPER_CASE, e.g. `INFURA_URL`
- Regular `const` variables should be in camelCase
- Avoid prepositions in variable names:
  - ~`restoreFromLocalStorage`~ 🙅
  - `restoreStoredValue` 👍
- Try to name boolean vars with `is`, e.g. `isLoading` vs `loading`
- If something needs to be exported just for unit tests, export it with a `_` prefix, e.g. `_getOnboardConfig`
</file>

<file path="docs/environments.md">
# Environments

We have several environments where the app can be deployed:

| Env        | URL                                             | Purpose                              | How it's deployed                                                      | Backend env                  |
| ---------- | ----------------------------------------------- | ------------------------------------ | ---------------------------------------------------------------------- | ---------------------------- |
| local      | http://localhost:3000/app                       | local development                    | `yarn start`                                                           | staging                      |
| PRs        | `https://<PR_NAME>--walletweb.review.5afe.dev/` | peer review & feature QA             | for all PRs on push                                                    | staging                      |
| dev        | https://safe-wallet-web.dev.5afe.dev/           | preview of all WIP features          | on push to the `dev` branch                                            | staging                      |
| staging    | https://safe-wallet-web.staging.5afe.dev/       | preview of features before a release | on push to `main`                                                      | **production** (for testing) |
| production | https://app.safe.global/                        | live app                             | deployed by DevOps (see the [Release Procedure](release-procedure.md)) | **production**               |

## Lifecycle of a feature

After a feature enters the development cycle (i.e. is in a sprint), it goes through the following steps:

### Development & QA

1. Developer starts working on the feature
2. Developer creates a Pull Request and assigns a reviewer
3. Reviewer leaves feedback until the PR is approved
4. QA engineer starts testing the branch on a deployed site (each PR has one, see the table above)
5. Once QA gives a green light, the branch is merged to the `dev` branch

### Release

1. All merged branches sit on `dev`, which is occasionally reviewed on the [dev site](https://safe-wallet-web.dev.5afe.dev/).
2. In case some regression is noticed, it's fixed on dev.
3. Once a sufficient amount of features are ready for a release (at least once in a sprint), a release branch is made (normally from the HEAD of `dev`) and a PR to `main` is created.
4. QA does regression testing on the release branch. The backend APIs are pointing to production on this branch so that all chains can be tested.
5. Once QA passes, the branch is merged to `main` and is automatically deployed to the [staging site](https://safe-wallet-web.staging.5afe.dev/).
6. It sits on staging for a short while where QA and the release manager briefly do a final check before going live.
7. DevOps are requested to deploy the code from `main` to the production env.
8. Once it's done, brief sanity checks are done on the [production site](https://app.safe.global/).
</file>

<file path="docs/release-procedure.md">
# Releasing to production

The code is being actively developed on the `dev` branch. Pull requests are made against this branch.

We prepare at least one release every sprint. Sprints are two weeks long.

When it's time to make a release, we "freeze" the code by creating a release branch off of the `dev` branch. A release PR is created from that branch, and sent to QA.

### Preparing a release branch

- Create a code-freeze branch named `release`
  - If it's a regular release, this branch is typically based off of `dev`
  - For hot fixes, it would be `main` + cherry-picked commits
- Bump the version in the `package.json` as a separate commit with the commit message equal to the exact version
- Create a PR with the list of changes

  > 💡 To generate a quick changelog:
  >
  > ```bash
  > git log origin/main..origin/dev --pretty=format:'* %s'
  > ```

```bash
git checkout release # switch to the release branch
git fetch --all; git reset --hard origin/dev # sync it with dev
```

Change the version in `app/web/package.json` to the new version.

```bash
git add .
git commit -m '1.54.0' # where 1.54.0 is the new version
git push
```

Once pushed:
* Create a PR from `release` to `main`.
* Add the PR to the Wallet project and set the status to `Ready for QA`

### QA

- The QA team do regression testing on this branch
- If issues are found, bugfixes are merged into this branch
- Once the QA is done, proceed to the next step

### Releasing to production

After the PR is tested and approved by QA:

- Switch to the main branch and make sure it's up to date:

```
git checkout main
git fetch --all
git reset --hard origin/main
```

- Pull from the release branch:

```
git pull origin release
```

- Push:

```
git push
```

A deployment workflow will be triggered and it will do the following things:

- Deploy the build to [staging](https://safe-wallet-web.staging.5afe.dev/)
- Create a new git tag from the version in `package.json`
- Create a draft [GitHub release](https://github.com/safe-global/safe-wallet-web/releases) linked to this tag, with a changelog taken from the release PR

After that, the release manager should:

- Publish the draft release. This will trigger a build and upload the code to an S3 bucket – wait for the job to finish
- Notify devops on Slack and send them the release link to deploy to production
- Back-merge `main` into the `dev` branch to keep them in sync unless the release branch was based on `dev`
</file>

<file path="docs/update-patch.md">
# Update yarn patches

You can find all patches that are currently applied inside the `.yarn/patches` directory. The name of the package that the patch applies to can be found in the file name of the patch.

Following are the steps to update a patch in case an update to the dependency needs to be done.

1. Run `yarn add <package-name>@<version>` to update the dependency

### If the file you are patching hasn't changed after the update:

1. Update the patch file name inside `.yarn/patches` to reflect the new version
   1. e.g. `next-npm-15.2.3-06a6671f62.patch` -> `next-npm-15.2.4-06a6671f62.patch`
2. Update the dependency inside `package.json` again to apply the patch
   1. e.g. `"next": "15.2.4"` -> `"next": "patch:next@15.2.4#../../.yarn/patches/next-npm-15.2.4-06a6671f62.patch"`
3. Run `yarn install` to update lock file
4. Go to the package directory inside `node_modules` and check that the patch is applied

### If the file you are patching has changed after the update:

1. Run `yarn patch <package-name>` e.g. `yarn patch next@npm:15.2.4`
2. Follow the instructions from your CLI
3. Check the generated patch file inside `.yarn/patches` and make sure it contains the expected changes
4. Update the dependency inside `package.json`
   1. e.g. `"next": "15.2.4"` -> `"next": "patch:next@15.2.4#../../.yarn/patches/next-npm-15.2.4-06a6671f62.patch"`
5. Run `yarn install` to update lock file
6. Go to the package directory inside `node_modules` and check that the patch is applied
</file>

<file path="docs/update-terms.md">
# How to update Terms & Conditions

To update the terms and conditions, follow these steps:

1. Export the terms and conditions from Google Docs as a Markdown file.
2. Replace the content of the src/markdown/terms/terms.md file with the exported content.
3. If significant changes were made, update the version and last updated date in `version.ts` in the same folder.

That’s it!

The updated terms and conditions will be displayed in the app with the correct version number and date. A popup banner
will automatically appear for users who haven’t accepted the new terms.

## How does this work?

We rely on the version number from `version.ts`. When the Redux store is rehydrated, we check the version stored in
the store against the version in the frontmatter. If they differ, we reset the accepted terms, forcing the user to
accept the new version.

The Markdown file is automatically converted to HTML and displayed in the app. Note that because the Markdown was
generated
from Google Docs, we require the remark-heading-id plugin. Additionally, since Google Docs uses {# ...} syntax, it will
fail in an MDX file.

For Cypress, we follow a similar process. We read the version from the frontmatter and pass it as an environment
variable.

For Jest tests, we mock the file and read the version from the mock.
</file>

<file path="public/.well-known/apple-app-site-association">
{
    "applinks": {
        "details": [
            {
                "appIDs": [
                    "ZKG876RKJ8.io.gnosis.multisig.prod.mainnet",
                    "ZKG876RKJ8.io.gnosis.multisig.prerelease",
                    "ZKG876RKJ8.io.gnosis.multisig.dev.mainnet",
                    "ZKG876RKJ8.io.gnosis.multisig.dev.rinkeby",
                    "ZKG876RKJ8.io.gnosis.multisig.staging.mainnet",
                    "ZKG876RKJ8.io.gnosis.multisig.staging.rinkeby"
                ],
                "components": [
                    {
                        "/": "*",
                        "comment": "Matches all universal links"
                    }
                ]
            }
        ]
    }
}
</file>

<file path="public/fonts/fonts.css">
@font-face {
  font-family: 'DM Sans';
  font-display: swap;
  font-weight: 400;
  /** check that the font is loaded on the website. IDEs fail to find the file */
  src: url('/fonts/DMSansRegular.woff2') format('woff2');
}

@font-face {
  font-family: 'DM Sans';
  font-display: swap;
  font-weight: bold;
  /** check that the font is loaded on the website. IDEs fail to find the file */
  src: url('/fonts/DMSans700.woff2') format('woff2');
}
</file>

<file path="public/safe.webmanifest">
{
  "name": "Safe",
  "short_name": "Safe",
  "description": "Safe (prev. Gnosis Safe) is the most trusted platform to manage digital assets on Ethereum and multiple EVMs. Over $40B secured.",
  "icons": [
    {
      "src": "/favicons/android-chrome-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicons/android-chrome-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": "/",
  "display": "standalone"
}
</file>

<file path="src/components/address-book/AddressBookHeader/index.tsx">
import { Button, SvgIcon, Grid } from '@mui/material'
import type { ReactElement, ElementType } from 'react'
import InputAdornment from '@mui/material/InputAdornment'
import SearchIcon from '@/public/images/common/search.svg'
import TextField from '@mui/material/TextField'

import Track from '@/components/common/Track'
import { ADDRESS_BOOK_EVENTS } from '@/services/analytics/events/addressBook'
import PageHeader from '@/components/common/PageHeader'
import { ModalType } from '../AddressBookTable'
import { useAppSelector } from '@/store'
import { type AddressBookState, selectAllAddressBooks } from '@/store/addressBookSlice'
import ImportIcon from '@/public/images/common/import.svg'
import ExportIcon from '@/public/images/common/export.svg'
import AddCircleIcon from '@/public/images/common/add-outlined.svg'
import mapProps from '@/utils/mad-props'

const HeaderButton = ({
  icon,
  onClick,
  disabled,
  children,
}: {
  icon: ElementType
  onClick: () => void
  disabled?: boolean
  children: string
}): ReactElement => {
  const svg = <SvgIcon component={icon} inheritViewBox fontSize="small" />

  return (
    <Button onClick={onClick} disabled={disabled} variant="text" color="primary" size="small" startIcon={svg}>
      {children}
    </Button>
  )
}

type Props = {
  allAddressBooks: AddressBookState
  handleOpenModal: (type: ModalType) => () => void
  searchQuery: string
  onSearchQueryChange: (searchQuery: string) => void
}

function AddressBookHeader({
  allAddressBooks,
  handleOpenModal,
  searchQuery,
  onSearchQueryChange,
}: Props): ReactElement {
  const canExport = Object.values(allAddressBooks).some((addressBook) => Object.keys(addressBook || {}).length > 0)

  return (
    <PageHeader
      title="Address book"
      noBorder
      action={
        <Grid
          container
          spacing={1}
          sx={{
            pb: 1,
          }}
        >
          <Grid item xs={12} md={5} xl={4.5}>
            <TextField
              placeholder="Search"
              variant="filled"
              hiddenLabel
              value={searchQuery}
              onChange={(e) => {
                onSearchQueryChange(e.target.value)
              }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SvgIcon component={SearchIcon} inheritViewBox color="border" />
                  </InputAdornment>
                ),
                disableUnderline: true,
              }}
              fullWidth
              size="small"
            />
          </Grid>
          <Grid
            item
            xs={12}
            md={7}
            sx={{
              display: 'flex',
              justifyContent: ['space-between', , 'flex-end'],
              alignItems: 'center',
            }}
          >
            <Track {...ADDRESS_BOOK_EVENTS.IMPORT_BUTTON}>
              <HeaderButton onClick={handleOpenModal(ModalType.IMPORT)} icon={ImportIcon}>
                Import
              </HeaderButton>
            </Track>

            <Track {...ADDRESS_BOOK_EVENTS.DOWNLOAD_BUTTON}>
              <HeaderButton onClick={handleOpenModal(ModalType.EXPORT)} icon={ExportIcon} disabled={!canExport}>
                Export
              </HeaderButton>
            </Track>

            <Track {...ADDRESS_BOOK_EVENTS.CREATE_ENTRY}>
              <HeaderButton onClick={handleOpenModal(ModalType.ENTRY)} icon={AddCircleIcon}>
                Create entry
              </HeaderButton>
            </Track>
          </Grid>
        </Grid>
      }
    />
  )
}

const useAllAddressBooks = () => useAppSelector(selectAllAddressBooks)

export default mapProps(AddressBookHeader, {
  allAddressBooks: useAllAddressBooks,
})
</file>

<file path="src/components/address-book/AddressBookTable/index.tsx">
import { useContext, useMemo, useState } from 'react'
import { Box } from '@mui/material'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'

import EnhancedTable from '@/components/common/EnhancedTable'
import type { AddressEntry } from '@/components/address-book/EntryDialog'
import EntryDialog from '@/components/address-book/EntryDialog'
import ExportDialog from '@/components/address-book/ExportDialog'
import ImportDialog from '@/components/address-book/ImportDialog'
import EditIcon from '@/public/images/common/edit.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import Button from '@mui/material/Button'
import IconButton from '@mui/material/IconButton'
import Tooltip from '@mui/material/Tooltip'
import RemoveDialog from '@/components/address-book/RemoveDialog'
import EthHashInfo from '@/components/common/EthHashInfo'
import AddressBookHeader from '../AddressBookHeader'
import useAddressBook from '@/hooks/useAddressBook'
import Track from '@/components/common/Track'
import { ADDRESS_BOOK_EVENTS } from '@/services/analytics/events/addressBook'
import SvgIcon from '@mui/material/SvgIcon'
import PagePlaceholder from '@/components/common/PagePlaceholder'
import NoEntriesIcon from '@/public/images/address-book/no-entries.svg'
import { useCurrentChain } from '@/hooks/useChains'
import tableCss from '@/components/common/EnhancedTable/styles.module.css'
import { TxModalContext, type TxModalContextType } from '@/components/tx-flow'
import { TokenTransferFlow } from '@/components/tx-flow/flows'
import CheckWallet from '@/components/common/CheckWallet'
import madProps from '@/utils/mad-props'

const headCells = [
  { id: 'name', label: 'Name' },
  { id: 'address', label: 'Address' },
  { id: 'actions', label: '' },
]

export enum ModalType {
  EXPORT = 'export',
  IMPORT = 'import',
  ENTRY = 'entry',
  REMOVE = 'remove',
}

const defaultOpen = {
  [ModalType.EXPORT]: false,
  [ModalType.IMPORT]: false,
  [ModalType.ENTRY]: false,
  [ModalType.REMOVE]: false,
}

type AddressBookTableProps = {
  chain?: ChainInfo
  setTxFlow: TxModalContextType['setTxFlow']
}

function AddressBookTable({ chain, setTxFlow }: AddressBookTableProps) {
  const [open, setOpen] = useState<typeof defaultOpen>(defaultOpen)
  const [searchQuery, setSearchQuery] = useState('')
  const [defaultValues, setDefaultValues] = useState<AddressEntry | undefined>(undefined)

  const handleOpenModal = (type: keyof typeof open) => () => {
    setOpen((prev) => ({ ...prev, [type]: true }))
  }

  const handleOpenModalWithValues = (modal: ModalType, address: string, name: string) => {
    setDefaultValues({ address, name })
    handleOpenModal(modal)()
  }

  const handleClose = () => {
    setOpen(defaultOpen)
    setDefaultValues(undefined)
  }

  const addressBook = useAddressBook()
  const addressBookEntries = Object.entries(addressBook)
  const filteredEntries = useMemo(() => {
    if (!searchQuery) {
      return addressBookEntries
    }

    const query = searchQuery.toLowerCase()
    return addressBookEntries.filter(([address, name]) => {
      return address.toLowerCase().includes(query) || name.toLowerCase().includes(query)
    })
  }, [addressBookEntries, searchQuery])

  const rows = filteredEntries.map(([address, name]) => ({
    cells: {
      name: {
        rawValue: name,
        content: name,
      },
      address: {
        rawValue: address,
        content: <EthHashInfo address={address} showName={false} shortAddress={false} hasExplorer showCopyButton />,
      },
      actions: {
        rawValue: '',
        sticky: true,
        content: (
          <div className={tableCss.actions}>
            <Track {...ADDRESS_BOOK_EVENTS.EDIT_ENTRY}>
              <Tooltip title="Edit entry" placement="top">
                <IconButton onClick={() => handleOpenModalWithValues(ModalType.ENTRY, address, name)} size="small">
                  <SvgIcon component={EditIcon} inheritViewBox color="border" fontSize="small" />
                </IconButton>
              </Tooltip>
            </Track>

            <Track {...ADDRESS_BOOK_EVENTS.DELETE_ENTRY}>
              <Tooltip title="Delete entry" placement="top">
                <IconButton onClick={() => handleOpenModalWithValues(ModalType.REMOVE, address, name)} size="small">
                  <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
                </IconButton>
              </Tooltip>
            </Track>

            <CheckWallet>
              {(isOk) => (
                <Track {...ADDRESS_BOOK_EVENTS.SEND}>
                  <Button
                    data-testid="send-btn"
                    variant="contained"
                    color="primary"
                    size="small"
                    onClick={() => setTxFlow(<TokenTransferFlow recipients={[{ recipient: address }]} />)}
                    disabled={!isOk}
                  >
                    Send
                  </Button>
                </Track>
              )}
            </CheckWallet>
          </div>
        ),
      },
    },
  }))

  return (
    <>
      <AddressBookHeader
        handleOpenModal={handleOpenModal}
        searchQuery={searchQuery}
        onSearchQueryChange={setSearchQuery}
      />

      <main>
        {filteredEntries.length > 0 ? (
          <EnhancedTable rows={rows} headCells={headCells} mobileVariant />
        ) : (
          <Box bgcolor="background.paper" borderRadius={1}>
            <PagePlaceholder
              img={<NoEntriesIcon />}
              text={`No entries found${chain ? ` on ${chain.chainName}` : ''}`}
            />
          </Box>
        )}
      </main>

      {open[ModalType.EXPORT] && <ExportDialog handleClose={handleClose} />}

      {open[ModalType.IMPORT] && <ImportDialog handleClose={handleClose} />}

      {open[ModalType.ENTRY] && (
        <EntryDialog
          handleClose={handleClose}
          defaultValues={defaultValues}
          disableAddressInput={Boolean(defaultValues?.name)}
        />
      )}

      {open[ModalType.REMOVE] && <RemoveDialog handleClose={handleClose} address={defaultValues?.address || ''} />}
    </>
  )
}

const useSetTxFlow = () => useContext(TxModalContext).setTxFlow

export default madProps(AddressBookTable, {
  chain: useCurrentChain,
  setTxFlow: useSetTxFlow,
})
</file>

<file path="src/components/address-book/AddressBookTable/styles.module.css">
.container tbody tr {
  transition: background-color 100ms linear;
}

.container tbody tr:hover {
  background-color: var(--color-secondary-background);
}

.container td:last-of-type button {
  opacity: 0;
  transition: opacity 200ms 100ms ease-in-out;
}

.container tr:hover td:last-of-type button {
  opacity: 1;
}

.headerButtonWrapper {
  display: flex;
  justify-content: flex-end;
  align-items: flex-start;
  gap: 8px;
  margin-bottom: 8px;
}

@media (max-width: 599.95px) {
  .container td:last-of-type button {
    opacity: 1;
  }
}
</file>

<file path="src/components/address-book/EntryDialog/index.tsx">
import type { ReactElement, BaseSyntheticEvent } from 'react'
import { Box, Button, DialogActions, DialogContent } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'

import AddressInput from '@/components/common/AddressInput'
import ModalDialog from '@/components/common/ModalDialog'
import NameInput from '@/components/common/NameInput'
import useChainId from '@/hooks/useChainId'
import { useAppDispatch } from '@/store'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'
import { useChain } from '@/hooks/useChains'

export type AddressEntry = {
  name: string
  address: string
}

function EntryDialog({
  handleClose,
  defaultValues = {
    name: '',
    address: '',
  },
  disableAddressInput = false,
  chainIds,
  currentChainId,
}: {
  handleClose: () => void
  defaultValues?: AddressEntry
  disableAddressInput?: boolean
  chainIds?: string[]
  currentChainId?: string
}): ReactElement {
  const chainId = useChainId()
  const actualChainId = currentChainId ?? chainId
  const currentChain = useChain(actualChainId)
  const dispatch = useAppDispatch()

  const methods = useForm<AddressEntry>({
    defaultValues,
    mode: 'onChange',
  })

  const { handleSubmit, formState } = methods

  const submitCallback = handleSubmit((data: AddressEntry) => {
    dispatch(upsertAddressBookEntries({ ...data, chainIds: chainIds ?? [actualChainId] }))
    handleClose()
  })

  const onSubmit = (e: BaseSyntheticEvent) => {
    e.stopPropagation()
    submitCallback(e)
  }

  return (
    <ModalDialog
      data-testid="entry-dialog"
      open
      onClose={handleClose}
      dialogTitle={defaultValues.name ? 'Edit entry' : 'Create entry'}
      hideChainIndicator={chainIds && chainIds.length > 1}
      chainId={chainIds?.[0]}
    >
      <FormProvider {...methods}>
        <form onSubmit={onSubmit}>
          <DialogContent>
            <Box mb={2}>
              <NameInput data-testid="name-input" label="Name" autoFocus name="name" required />
            </Box>

            <Box>
              <AddressInput
                name="address"
                label="Contact"
                variant="outlined"
                fullWidth
                required
                disabled={disableAddressInput}
                chain={currentChain}
                showPrefix={!!currentChainId}
              />
            </Box>
          </DialogContent>

          <DialogActions>
            <Button data-testid="cancel-btn" onClick={handleClose}>
              Cancel
            </Button>
            <Button
              data-testid="save-btn"
              type="submit"
              variant="contained"
              disabled={!formState.isValid}
              disableElevation
            >
              Save
            </Button>
          </DialogActions>
        </form>
      </FormProvider>
    </ModalDialog>
  )
}

export default EntryDialog
</file>

<file path="src/components/address-book/ExportDialog/index.tsx">
import DialogContent from '@mui/material/DialogContent'
import DialogActions from '@mui/material/DialogActions'
import Button from '@mui/material/Button'
import Typography from '@mui/material/Typography'
import { useCSVDownloader } from 'react-papaparse'
import type { SyntheticEvent } from 'react'
import { useMemo, type ReactElement } from 'react'

import ModalDialog from '@/components/common/ModalDialog'
import { type AddressBookState, selectAllAddressBooks } from '@/store/addressBookSlice'
import { useAppSelector } from '@/store'
import { trackEvent, ADDRESS_BOOK_EVENTS } from '@/services/analytics'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'
import madProps from '@/utils/mad-props'

const COL_1 = 'address'
const COL_2 = 'name'
const COL_3 = 'chainId'

type CsvData = { [COL_1]: string; [COL_2]: string; [COL_3]: string }[]

export const _getCsvData = (addressBooks: AddressBookState): CsvData => {
  const csvData = Object.entries(addressBooks).reduce<CsvData>((acc, [chainId, entries]) => {
    Object.entries(entries).forEach(([address, name]) => {
      acc.push({
        [COL_1]: address,
        [COL_2]: name,
        [COL_3]: chainId,
      })
    })

    return acc
  }, [])

  return csvData
}

function ExportDialog({
  allAddressBooks,
  handleClose,
}: {
  allAddressBooks: AddressBookState
  handleClose: () => void
}): ReactElement {
  const length = Object.values(allAddressBooks).reduce<number>((acc, entries) => acc + Object.keys(entries).length, 0)
  const { CSVDownloader } = useCSVDownloader()
  // safe-address-book-1970-01-01
  const filename = `safe-address-book-${new Date().toISOString().slice(0, 10)}`

  const csvData = useMemo(() => _getCsvData(allAddressBooks), [allAddressBooks])

  const onSubmit = (e: SyntheticEvent) => {
    e.preventDefault()

    trackEvent(ADDRESS_BOOK_EVENTS.EXPORT)

    setTimeout(() => {
      handleClose()
    }, 300)
  }

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Export address book" hideChainIndicator>
      <DialogContent sx={{ p: '24px !important' }}>
        <Typography data-testid="export-summary">
          You&apos;re about to export a CSV file with{' '}
          <b>
            {length} address book {length === 1 ? 'entry' : 'entries'}
          </b>
          .
        </Typography>

        <Typography mt={1}>
          <ExternalLink
            href={HelpCenterArticle.ADDRESS_BOOK_DATA}
            title="Learn about the address book import and export"
          >
            Learn about the address book import and export
          </ExternalLink>
        </Typography>
      </DialogContent>

      <DialogActions>
        <Button onClick={handleClose}>Cancel</Button>
        <CSVDownloader filename={filename} bom config={{ delimiter: ',' }} data={csvData} style={{ order: 2 }}>
          <Button data-testid="export-modal-btn" variant="contained" disableElevation onClick={onSubmit}>
            Export
          </Button>
        </CSVDownloader>
      </DialogActions>
    </ModalDialog>
  )
}

const useAllAddressBooks = () => useAppSelector(selectAllAddressBooks)

export default madProps(ExportDialog, {
  allAddressBooks: useAllAddressBooks,
})
</file>

<file path="src/components/address-book/ImportDialog/index.tsx">
import DialogContent from '@mui/material/DialogContent'
import DialogActions from '@mui/material/DialogActions'
import Button from '@mui/material/Button'
import Typography from '@mui/material/Typography'
import { useCSVReader, formatFileSize } from 'react-papaparse'
import type { ParseResult } from 'papaparse'
import { type ReactElement, useState, type MouseEvent, useMemo } from 'react'

import ModalDialog from '@/components/common/ModalDialog'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'
import { useAppDispatch } from '@/store'

import css from './styles.module.css'
import { trackEvent, ADDRESS_BOOK_EVENTS } from '@/services/analytics'
import { abCsvReaderValidator, abOnUploadValidator } from './validation'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { Errors, logError } from '@/services/exceptions'
import FileUpload, { FileTypes, type FileInfo } from '@/components/common/FileUpload'
import ExternalLink from '@/components/common/ExternalLink'
import { BRAND_NAME, HelpCenterArticle } from '@/config/constants'

type AddressBookCSVRow = ['address', 'name', 'chainId']

// https://react-papaparse.js.org/docs#errors
type PapaparseErrorType = {
  type: 'Quotes' | 'Delimiter' | 'FieldMismatch'
  code: 'MissingQuotes' | 'UndetectableDelimiter' | 'TooFewFields' | 'TooManyFields'
  message: string
  row?: number
  index?: number
}

const hasEntry = (entry: string[]) => {
  return entry.length === 3 && entry[0] && entry[1] && entry[2]
}

const ImportDialog = ({ handleClose }: { handleClose: () => void }): ReactElement => {
  const [zoneHover, setZoneHover] = useState<boolean>(false)
  const [csvData, setCsvData] = useState<ParseResult<AddressBookCSVRow>>()
  const [error, setError] = useState<string>()

  // Count how many entries are in the CSV file
  const [entryCount, chainCount] = useMemo(() => {
    if (!csvData) return [0, 0]
    const entries = csvData.data.slice(1).filter(hasEntry)
    const entryLen = entries.length
    const chainLen = new Set(entries.map((entry) => entry[2].trim())).size
    return [entryLen, chainLen]
  }, [csvData])

  const dispatch = useAppDispatch()
  const { CSVReader } = useCSVReader()

  const handleImport = () => {
    if (!csvData) {
      return
    }

    const [, ...entries] = csvData.data

    for (const entry of entries) {
      const [address, name, chainId] = entry
      dispatch(upsertAddressBookEntries({ address, name, chainIds: [chainId.trim()] }))
    }

    trackEvent({ ...ADDRESS_BOOK_EVENTS.IMPORT, label: entries.length })

    handleClose()
  }

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Import address book" hideChainIndicator>
      <DialogContent>
        <CSVReader
          accept="text/csv"
          multiple={false}
          onDragOver={() => {
            setZoneHover(true)
          }}
          onDragLeave={() => {
            setZoneHover(false)
          }}
          validator={abCsvReaderValidator}
          onUploadRejected={(result: { file: File; errors?: Array<Error | string | PapaparseErrorType> }[]) => {
            setZoneHover(false)
            setError(undefined)

            // csvReaderValidator error
            const error = result?.[0].errors?.pop()

            if (error) {
              const errorDescription = typeof error === 'string' ? error.toString() : error.message
              setError(errorDescription)
              logError(Errors._703, errorDescription)
            }
          }}
          onUploadAccepted={(result: ParseResult<['address', 'name', 'chainId']>) => {
            setZoneHover(false)
            setError(undefined)

            // Remove empty rows
            const cleanResult = {
              ...result,
              data: result.data.filter(hasEntry),
            }

            const message = abOnUploadValidator(cleanResult)

            if (message) {
              setError(message)
            } else {
              setCsvData(cleanResult)
            }
          }}
        >
          {/* https://github.com/Bunlong/react-papaparse/blob/master/src/useCSVReader.tsx */}
          {({ getRootProps, acceptedFile, getRemoveFileProps }: any) => {
            const { onClick } = getRemoveFileProps()

            const onRemove = (e: MouseEvent<HTMLSpanElement>) => {
              setCsvData(undefined)
              setError(undefined)
              onClick(e)
            }

            const fileInfo: FileInfo | undefined = acceptedFile
              ? {
                  name: acceptedFile.name,
                  additionalInfo: formatFileSize(acceptedFile.size),
                  summary: [
                    <Typography data-testid="summary-message" key="abSummary">
                      {`Found ${entryCount} entries on ${chainCount} ${chainCount > 1 ? 'chains' : 'chain'}`}
                    </Typography>,
                  ],
                }
              : undefined

            return (
              <FileUpload
                fileInfo={fileInfo}
                fileType={FileTypes.CSV}
                getRootProps={getRootProps}
                isDragActive={zoneHover}
                onRemove={onRemove}
              />
            )
          }}
        </CSVReader>

        <div className={css.horizontalDivider} />

        {error && <ErrorMessage>{error}</ErrorMessage>}

        <Typography>
          Only CSV files exported from a {BRAND_NAME} can be imported.
          <br />
          <ExternalLink
            href={HelpCenterArticle.ADDRESS_BOOK_DATA}
            title="Learn about the address book import and export"
          >
            Learn about the address book import and export
          </ExternalLink>
        </Typography>
      </DialogContent>
      <DialogActions>
        <Button data-testid="cancel-btn" onClick={handleClose}>
          Cancel
        </Button>
        <Button
          data-testid="import-btn"
          onClick={handleImport}
          variant="contained"
          disableElevation
          disabled={!csvData || !!error}
        >
          Import
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}

export default ImportDialog
</file>

<file path="src/components/address-book/ImportDialog/styles.module.css">
.horizontalDivider {
  display: flex;
  margin: 24px -24px;
  border-top: 2px solid rgba(0, 0, 0, 0.12);
}
</file>

<file path="src/components/address-book/ImportDialog/validation.ts">
import type { ParseResult } from 'papaparse'

import { validateAddress } from '@safe-global/utils/utils/validation'

export const abCsvReaderValidator = ({ size }: File): string[] | undefined => {
  if (size > 1_000_000) {
    return ['Address book cannot be larger than 1MB']
  }
}

export const hasValidAbHeader = (header: string[]) => {
  return header.length === 3 && header[0] === 'address' && header[1] === 'name' && header[2] === 'chainId'
}

export const hasValidAbEntryAddresses = (entries: string[][]) => {
  return entries.every((entry) => entry.length >= 1 && !validateAddress(entry[0]))
}

export const hasValidAbNames = (entries: string[][]) => {
  return entries.every((entry) => entry.length >= 2 && !!entry[1])
}

export const abOnUploadValidator = ({ data, errors }: ParseResult<string[]>): string | undefined => {
  const [header, ...entries] = data

  // papaparse error
  if (errors.length > 0) {
    return errors[0].message
  }

  // Empty CSV
  if (data.length === 0) {
    return 'CSV file is empty'
  }

  // Wrong header
  if (!hasValidAbHeader(header)) {
    return 'Invalid or corrupt address book header'
  }

  // No entries
  if (entries.length === 0) {
    return 'No entries found in address book'
  }

  // We + 2 to each row to make up for header and index

  // An entry has invalid address
  if (!hasValidAbEntryAddresses(entries)) {
    const i = entries.findIndex((entry) => (entry.length >= 1 ? validateAddress(entry[0]) : true))
    return `Address book contains an invalid address on row ${i + 2}`
  }

  // An entry has invalid name
  if (!hasValidAbNames(entries)) {
    const i = entries.findIndex((entry) => (entry.length >= 2 ? !entry[1] : true))
    return `Address book contains an invalid name on row ${i + 2}`
  }
}
</file>

<file path="src/components/address-book/RemoveDialog/index.tsx">
import DialogContent from '@mui/material/DialogContent'
import DialogActions from '@mui/material/DialogActions'
import Typography from '@mui/material/Typography'
import Button from '@mui/material/Button'
import type { ReactElement } from 'react'

import ModalDialog from '@/components/common/ModalDialog'
import { useAppDispatch } from '@/store'
import { removeAddressBookEntry } from '@/store/addressBookSlice'
import useChainId from '@/hooks/useChainId'
import useAddressBook from '@/hooks/useAddressBook'

const RemoveDialog = ({ handleClose, address }: { handleClose: () => void; address: string }): ReactElement => {
  const dispatch = useAppDispatch()
  const chainId = useChainId()
  const addressBook = useAddressBook()

  const name = addressBook?.[address]

  const handleConfirm = () => {
    dispatch(removeAddressBookEntry({ chainId, address }))
    handleClose()
  }

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Delete entry">
      <DialogContent sx={{ p: '24px !important' }}>
        <Typography>
          Are you sure you want to permanently delete <b>{name}</b> from your address book?
        </Typography>
      </DialogContent>

      <DialogActions>
        <Button onClick={handleClose}>Cancel</Button>
        <Button onClick={handleConfirm} variant="danger" disableElevation>
          Delete
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}

export default RemoveDialog
</file>

<file path="src/components/balances/AssetsHeader/index.tsx">
import { useMemo, type ReactElement, type ReactNode } from 'react'

import NavTabs from '@/components/common/NavTabs'
import PageHeader from '@/components/common/PageHeader'
import { balancesNavItems } from '@/components/sidebar/SidebarNavigation/config'

import css from '@/components/common/PageHeader/styles.module.css'
import { useCurrentChain } from '@/hooks/useChains'
import { isRouteEnabled } from '@/utils/chains'

const AssetsHeader = ({ children }: { children?: ReactNode }): ReactElement => {
  const chain = useCurrentChain()
  const navItems = useMemo(() => balancesNavItems.filter((item) => isRouteEnabled(item.href, chain)), [chain])

  return (
    <PageHeader
      title="Assets"
      action={
        <div className={css.pageHeader}>
          <div className={css.navWrapper}>
            <NavTabs tabs={navItems} />
          </div>
          {children && <div className={css.actionsWrapper}>{children}</div>}
        </div>
      }
    />
  )
}

export default AssetsHeader
</file>

<file path="src/components/balances/AssetsTable/FiatBalance.tsx">
import FiatValue from '@/components/common/FiatValue'
import { Stack, SvgIcon, Tooltip } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import type { Balance } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

export const FiatBalance = ({ balanceItem }: { balanceItem: Balance }) => {
  const isMissingFiatConversion = balanceItem.fiatConversion === '0' && balanceItem.fiatBalance === '0'

  return (
    <Stack direction="row" spacing={0.5} alignItems="center" justifyContent="flex-end">
      <FiatValue value={isMissingFiatConversion ? null : balanceItem.fiatBalance} />

      {isMissingFiatConversion && (
        <Tooltip
          title="Provided values are indicative and we are unable to accommodate pricing requests for individual assets"
          placement="top"
          arrow
        >
          <SvgIcon component={InfoIcon} inheritViewBox color="error" fontSize="small" />
        </Tooltip>
      )}
    </Stack>
  )
}
</file>

<file path="src/components/balances/AssetsTable/FiatChange.tsx">
import { Chip, SvgIcon, Tooltip, Typography } from '@mui/material'
import { type Balance } from '@safe-global/store/gateway/AUTO_GENERATED/balances'
import { formatPercentage } from '@safe-global/utils/utils/formatters'
import ArrowDown from '@/public/images/balances/change-down.svg'
import ArrowUp from '@/public/images/balances/change-up.svg'

export const FiatChange = ({ balanceItem }: { balanceItem: Balance }) => {
  if (!balanceItem.fiatBalance24hChange) {
    return (
      <Typography variant="caption" color="text.secondary" paddingLeft={3} display="block">
        n/a
      </Typography>
    )
  }

  const changeAsNumber = Number(balanceItem.fiatBalance24hChange) / 100
  const changeLabel = formatPercentage(changeAsNumber)
  const direction = changeAsNumber < 0 ? 'down' : changeAsNumber > 0 ? 'up' : 'none'

  const backgroundColor =
    direction === 'down' ? 'error.background' : direction === 'up' ? 'success.background' : 'default'
  const color = direction === 'down' ? 'error.main' : direction === 'up' ? 'success.main' : 'default'

  return (
    <Tooltip title="24h change">
      <Chip
        size="small"
        sx={{
          backgroundColor,
          color,
          padding: '2px 8px',
        }}
        label={changeLabel}
        icon={
          direction === 'down' ? (
            <SvgIcon color="error" inheritViewBox component={ArrowDown} sx={{ width: '9px', height: '6px' }} />
          ) : direction === 'up' ? (
            <SvgIcon color="success" inheritViewBox component={ArrowUp} sx={{ width: '9px', height: '6px' }} />
          ) : (
            <>-</>
          )
        }
      />
    </Tooltip>
  )
}
</file>

<file path="src/components/balances/AssetsTable/index.tsx">
import CheckBalance from '@/features/counterfactual/CheckBalance'
import { type ReactElement } from 'react'
import { Box, IconButton, Checkbox, Skeleton, Tooltip, Typography } from '@mui/material'
import css from './styles.module.css'
import TokenAmount from '@/components/common/TokenAmount'
import TokenIcon from '@/components/common/TokenIcon'
import EnhancedTable, { type EnhancedTableProps } from '@/components/common/EnhancedTable'
import TokenExplorerLink from '@/components/common/TokenExplorerLink'
import Track from '@/components/common/Track'
import { ASSETS_EVENTS } from '@/services/analytics/events/assets'
import { VisibilityOutlined } from '@mui/icons-material'
import TokenMenu from '../TokenMenu'
import useBalances from '@/hooks/useBalances'
import { useHideAssets, useVisibleAssets } from './useHideAssets'
import AddFundsCTA from '@/components/common/AddFunds'
import SwapButton from '@/features/swap/components/SwapButton'
import { SWAP_LABELS } from '@/services/analytics/events/swaps'
import SendButton from './SendButton'
import useIsSwapFeatureEnabled from '@/features/swap/hooks/useIsSwapFeatureEnabled'
import useIsStakingFeatureEnabled from '@/features/stake/hooks/useIsStakingFeatureEnabled'
import { STAKE_LABELS } from '@/services/analytics/events/stake'
import StakeButton from '@/features/stake/components/StakeButton'
import { FiatBalance } from './FiatBalance'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import { type Balance } from '@safe-global/store/gateway/AUTO_GENERATED/balances'
import { FiatChange } from './FiatChange'

const skeletonCells: EnhancedTableProps['rows'][0]['cells'] = {
  asset: {
    rawValue: '0x0',
    content: (
      <div className={css.token}>
        <Skeleton variant="rounded" width="26px" height="26px" />
        <Typography>
          <Skeleton width="80px" />
        </Typography>
      </div>
    ),
  },
  balance: {
    rawValue: '0',
    content: (
      <Typography>
        <Skeleton width="32px" />
      </Typography>
    ),
  },
  value: {
    rawValue: '0',
    content: (
      <Typography>
        <Skeleton width="32px" />
      </Typography>
    ),
  },
  change: {
    rawValue: '0',
    content: (
      <Typography>
        <Skeleton width="32px" />
      </Typography>
    ),
  },
  actions: {
    rawValue: '',
    sticky: true,
    content: <div></div>,
  },
}

const skeletonRows: EnhancedTableProps['rows'] = Array(3).fill({ cells: skeletonCells })

const isNativeToken = (tokenInfo: Balance['tokenInfo']) => {
  return tokenInfo.type === TokenType.NATIVE_TOKEN
}

const headCells = [
  {
    id: 'asset',
    label: 'Asset',
    width: '44%',
  },
  {
    id: 'balance',
    label: 'Balance',
    width: '14%',
  },
  {
    id: 'value',
    label: 'Value',
    width: '14%',
    align: 'right',
  },
  {
    id: 'change',
    label: '24h change',
    width: '14%',
    align: 'left',
  },
  {
    id: 'actions',
    label: '',
    width: '14%',
    sticky: true,
  },
]

const AssetsTable = ({
  showHiddenAssets,
  setShowHiddenAssets,
}: {
  showHiddenAssets: boolean
  setShowHiddenAssets: (hidden: boolean) => void
}): ReactElement => {
  const { balances, loading } = useBalances()
  const isSwapFeatureEnabled = useIsSwapFeatureEnabled()
  const isStakingFeatureEnabled = useIsStakingFeatureEnabled()

  const { isAssetSelected, toggleAsset, hidingAsset, hideAsset, cancel, deselectAll, saveChanges } = useHideAssets(() =>
    setShowHiddenAssets(false),
  )

  const visible = useVisibleAssets()
  const visibleAssets = showHiddenAssets ? balances.items : visible

  const hasNoAssets = !loading && balances.items.length === 1 && balances.items[0].balance === '0'

  const selectedAssetCount = visibleAssets?.filter((item) => isAssetSelected(item.tokenInfo.address)).length || 0

  const rows = loading
    ? skeletonRows
    : (visibleAssets || []).map((item) => {
        const rawFiatValue = parseFloat(item.fiatBalance)
        const isNative = isNativeToken(item.tokenInfo)
        const isSelected = isAssetSelected(item.tokenInfo.address)

        return {
          key: item.tokenInfo.address,
          selected: isSelected,
          collapsed: item.tokenInfo.address === hidingAsset,
          cells: {
            asset: {
              rawValue: item.tokenInfo.name,
              collapsed: item.tokenInfo.address === hidingAsset,
              content: (
                <div className={css.token}>
                  <TokenIcon logoUri={item.tokenInfo.logoUri} tokenSymbol={item.tokenInfo.symbol} />

                  <Typography>{item.tokenInfo.name}</Typography>

                  {isStakingFeatureEnabled && item.tokenInfo.type === TokenType.NATIVE_TOKEN && (
                    <StakeButton tokenInfo={item.tokenInfo} trackingLabel={STAKE_LABELS.asset} />
                  )}

                  {!isNative && <TokenExplorerLink address={item.tokenInfo.address} />}
                </div>
              ),
            },
            balance: {
              rawValue: Number(item.balance) / 10 ** (item.tokenInfo.decimals ?? 0),
              collapsed: item.tokenInfo.address === hidingAsset,
              content: (
                <TokenAmount
                  value={item.balance}
                  decimals={item.tokenInfo.decimals}
                  tokenSymbol={item.tokenInfo.symbol}
                />
              ),
            },
            value: {
              rawValue: rawFiatValue,
              collapsed: item.tokenInfo.address === hidingAsset,
              content: <FiatBalance balanceItem={item} />,
            },
            change: {
              rawValue: item.fiatBalance24hChange ? Number(item.fiatBalance24hChange) : null,
              collapsed: item.tokenInfo.address === hidingAsset,
              content: <FiatChange balanceItem={item} />,
            },
            actions: {
              rawValue: Number(item.fiatBalance24hChange),
              sticky: true,
              collapsed: item.tokenInfo.address === hidingAsset,
              content: (
                <Box display="flex" flexDirection="row" gap={1} alignItems="center">
                  <>
                    <SendButton tokenInfo={item.tokenInfo} />

                    {isSwapFeatureEnabled && (
                      <SwapButton tokenInfo={item.tokenInfo} amount="0" trackingLabel={SWAP_LABELS.asset} />
                    )}

                    {showHiddenAssets ? (
                      <Checkbox size="small" checked={isSelected} onClick={() => toggleAsset(item.tokenInfo.address)} />
                    ) : (
                      <Track {...ASSETS_EVENTS.HIDE_TOKEN}>
                        <Tooltip title="Hide asset" arrow disableInteractive>
                          <IconButton
                            disabled={hidingAsset !== undefined}
                            size="medium"
                            onClick={() => hideAsset(item.tokenInfo.address)}
                          >
                            <VisibilityOutlined fontSize="small" />
                          </IconButton>
                        </Tooltip>
                      </Track>
                    )}
                  </>
                </Box>
              ),
            },
          },
        }
      })

  return (
    <>
      <TokenMenu
        saveChanges={saveChanges}
        cancel={cancel}
        deselectAll={deselectAll}
        selectedAssetCount={selectedAssetCount}
        showHiddenAssets={showHiddenAssets}
      />

      {hasNoAssets ? (
        <AddFundsCTA />
      ) : (
        <div className={css.container}>
          <EnhancedTable rows={rows} headCells={headCells} />
        </div>
      )}

      <CheckBalance />
    </>
  )
}

export default AssetsTable
</file>

<file path="src/components/balances/AssetsTable/SendButton.tsx">
import { useContext } from 'react'
import type { TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { Button } from '@mui/material'
import ArrowIconNW from '@/public/images/common/arrow-top-right.svg'
import CheckWallet from '@/components/common/CheckWallet'
import useSpendingLimit from '@/hooks/useSpendingLimit'
import Track from '@/components/common/Track'
import { ASSETS_EVENTS } from '@/services/analytics/events/assets'
import { TokenTransferFlow } from '@/components/tx-flow/flows'
import { TxModalContext } from '@/components/tx-flow'

const SendButton = ({ tokenInfo, isOutlined }: { tokenInfo: TokenInfo; isOutlined?: boolean }) => {
  const spendingLimit = useSpendingLimit(tokenInfo)
  const { setTxFlow } = useContext(TxModalContext)

  const onSendClick = () => {
    setTxFlow(<TokenTransferFlow recipients={[{ tokenAddress: tokenInfo.address }]} />)
  }

  return (
    <CheckWallet allowSpendingLimit={!!spendingLimit}>
      {(isOk) => (
        <Track {...ASSETS_EVENTS.SEND}>
          <Button
            data-testid="send-button"
            variant={isOutlined ? 'outlined' : 'contained'}
            color="primary"
            size="small"
            startIcon={<ArrowIconNW />}
            onClick={onSendClick}
            disabled={!isOk}
            sx={{ height: '37.5px' }}
          >
            Send
          </Button>
        </Track>
      )}
    </CheckWallet>
  )
}

export default SendButton
</file>

<file path="src/components/balances/AssetsTable/styles.module.css">
.container td:last-of-type button {
  opacity: 0;
  transition: opacity 0.2s;
}

.container tr:hover td:last-of-type button,
.container td:last-of-type button:focus-visible {
  opacity: 1;
}

.token {
  display: flex;
  align-items: center;
  gap: var(--space-1);
}

@media (max-width: 599.95px) {
  .container td:last-of-type,
  .container th:last-of-type {
    display: none;
  }
}
</file>

<file path="src/components/balances/AssetsTable/useHideAssets.ts">
import { useCallback, useMemo, useState } from 'react'
import useBalances from '@/hooks/useBalances'
import useChainId from '@/hooks/useChainId'
import useHiddenTokens from '@/hooks/useHiddenTokens'
import { useAppDispatch } from '@/store'
import { setHiddenTokensForChain } from '@/store/settingsSlice'

// This is the default for MUI Collapse
export const COLLAPSE_TIMEOUT_MS = 300

export const useHideAssets = (closeDialog: () => void) => {
  const dispatch = useAppDispatch()
  const chainId = useChainId()
  const { balances } = useBalances()

  const [assetsToHide, setAssetsToHide] = useState<string[]>([])
  const [assetsToUnhide, setAssetsToUnhide] = useState<string[]>([])
  const [hidingAsset, setHidingAsset] = useState<string>()
  const hiddenAssets = useHiddenTokens()

  const toggleAsset = useCallback(
    (address: string) => {
      if (assetsToHide.includes(address)) {
        setAssetsToHide(assetsToHide.filter((asset) => asset !== address))
        return
      }

      if (assetsToUnhide.includes(address)) {
        setAssetsToUnhide(assetsToUnhide.filter((asset) => asset !== address))
        return
      }

      const assetIsHidden = hiddenAssets.includes(address)
      if (!assetIsHidden) {
        setAssetsToHide(assetsToHide.concat(address))
      } else {
        setAssetsToUnhide(assetsToUnhide.concat(address))
      }
    },
    [assetsToHide, assetsToUnhide, hiddenAssets],
  )

  /**
   * Unhide all assets which are included in the current Safe's balance.
   */
  const deselectAll = useCallback(() => {
    setAssetsToHide([])
    setAssetsToUnhide([
      ...hiddenAssets.filter((asset) => balances.items.some((item) => item.tokenInfo.address === asset)),
    ])
  }, [hiddenAssets, balances])

  // Assets are selected if they are either hidden or marked for hiding
  const isAssetSelected = useCallback(
    (address: string) =>
      (hiddenAssets.includes(address) && !assetsToUnhide.includes(address)) || assetsToHide.includes(address),
    [assetsToHide, assetsToUnhide, hiddenAssets],
  )

  const cancel = useCallback(() => {
    setAssetsToHide([])
    setAssetsToUnhide([])
    closeDialog()
  }, [closeDialog])

  const hideAsset = useCallback(
    (address: string) => {
      setHidingAsset(address)
      setTimeout(() => {
        const newHiddenAssets = [...hiddenAssets, address]
        dispatch(setHiddenTokensForChain({ chainId, assets: newHiddenAssets }))
        setHidingAsset(undefined)
      }, COLLAPSE_TIMEOUT_MS)
    },
    [chainId, dispatch, hiddenAssets],
  )

  const saveChanges = useCallback(() => {
    const newHiddenAssets = [...hiddenAssets.filter((asset) => !assetsToUnhide.includes(asset)), ...assetsToHide]
    dispatch(setHiddenTokensForChain({ chainId, assets: newHiddenAssets }))
    cancel()
  }, [assetsToHide, assetsToUnhide, chainId, dispatch, hiddenAssets, cancel])

  return {
    hideAsset,
    saveChanges,
    cancel,
    toggleAsset,
    isAssetSelected,
    deselectAll,
    hidingAsset,
  }
}

export const useVisibleAssets = () => {
  const hiddenAssets = useHiddenTokens()
  const { balances } = useBalances()
  return useMemo(
    () => balances.items?.filter((item) => !hiddenAssets.includes(item.tokenInfo.address)),
    [hiddenAssets, balances.items],
  )
}
</file>

<file path="src/components/balances/CurrencySelect/index.tsx">
import type { ReactElement } from 'react'
import type { SelectChangeEvent } from '@mui/material'
import { FormControl, InputLabel, MenuItem, Select } from '@mui/material'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectCurrency, setCurrency } from '@/store/settingsSlice'
import useCurrencies from './useCurrencies'
import { trackEvent, ASSETS_EVENTS } from '@/services/analytics'

const CurrencySelect = (): ReactElement => {
  const currency = useAppSelector(selectCurrency)
  const dispatch = useAppDispatch()
  const fiatCurrencies = useCurrencies() || [currency.toUpperCase()]

  const handleChange = (e: SelectChangeEvent<string>) => {
    const currency = e.target.value

    trackEvent({
      ...ASSETS_EVENTS.CHANGE_CURRENCY,
      label: currency.toUpperCase(),
    })

    dispatch(setCurrency(currency.toLowerCase()))
  }

  const handleTrack = (label: 'Open' | 'Close') => {
    trackEvent({
      ...ASSETS_EVENTS.CURRENCY_MENU,
      label,
    })
  }

  return (
    <FormControl size="small">
      <InputLabel id="currency-label">Currency</InputLabel>

      <Select
        data-testid="currency-selector"
        labelId="currency-label"
        id="currency"
        value={currency.toUpperCase()}
        label="Currency"
        onChange={handleChange}
        onOpen={() => handleTrack('Open')}
        onClose={() => handleTrack('Close')}
      >
        {fiatCurrencies.map((item) => (
          <MenuItem data-testid="currency-item" key={item} value={item} sx={{ overflow: 'hidden' }}>
            {item.toUpperCase()}
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  )
}

export default CurrencySelect
</file>

<file path="src/components/balances/CurrencySelect/useCurrencies.ts">
import type { FiatCurrencies } from '@safe-global/store/gateway/types'

import { useBalancesGetSupportedFiatCodesV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

const useCurrencies = (): FiatCurrencies | undefined => {
  const { data } = useBalancesGetSupportedFiatCodesV1Query()

  return data
}

export default useCurrencies
</file>

<file path="src/components/balances/HiddenTokenButton/index.tsx">
import { type ReactElement } from 'react'
import { Typography, Button } from '@mui/material'
import { ASSETS_EVENTS } from '@/services/analytics'
import useHiddenTokens from '@/hooks/useHiddenTokens'
import useBalances from '@/hooks/useBalances'
import VisibilityOutlined from '@mui/icons-material/VisibilityOutlined'
import Track from '@/components/common/Track'

import css from './styles.module.css'
import { maybePlural } from '@safe-global/utils/utils/formatters'

const HiddenTokenButton = ({
  toggleShowHiddenAssets,
  showHiddenAssets,
}: {
  toggleShowHiddenAssets?: () => void
  showHiddenAssets?: boolean
}): ReactElement | null => {
  const { balances } = useBalances()
  const currentHiddenAssets = useHiddenTokens()

  const hiddenAssetCount =
    balances.items?.filter((item) => currentHiddenAssets.includes(item.tokenInfo.address)).length || 0

  return (
    <div className={css.hiddenTokenButton}>
      <Track {...ASSETS_EVENTS.SHOW_HIDDEN_ASSETS}>
        <Button
          sx={{
            gap: 1,
            padding: 1,
            borderWidth: '1px !important',
            borderColor: ({ palette }) => palette.border.main,
          }}
          disabled={showHiddenAssets}
          onClick={toggleShowHiddenAssets}
          data-testid="toggle-hidden-assets"
          variant="outlined"
        >
          <>
            <VisibilityOutlined fontSize="small" />
            <Typography fontSize="medium">
              {hiddenAssetCount === 0
                ? 'Hide tokens'
                : `${hiddenAssetCount} hidden token${maybePlural(hiddenAssetCount)}`}{' '}
            </Typography>
          </>
        </Button>
      </Track>
    </div>
  )
}

export default HiddenTokenButton
</file>

<file path="src/components/balances/HiddenTokenButton/styles.module.css">
@media (max-width: 599.95px) {
  .hiddenTokenButton {
    display: none;
  }
}
</file>

<file path="src/components/balances/TokenListSelect/index.tsx">
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setTokenList, TOKEN_LISTS } from '@/store/settingsSlice'
import type { SelectChangeEvent } from '@mui/material'
import { Box, SvgIcon, Tooltip, Typography, FormControl, InputLabel, Select, MenuItem } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { OnboardingTooltip } from '@/components/common/OnboardingTooltip'
import Track from '@/components/common/Track'
import { ASSETS_EVENTS, trackEvent } from '@/services/analytics'
import { HelpCenterArticle } from '@/config/constants'
import { useHasFeature } from '@/hooks/useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'

const LS_TOKENLIST_ONBOARDING = 'tokenlist_onboarding'

const TokenListLabel = {
  [TOKEN_LISTS.TRUSTED]: 'Default tokens',
  [TOKEN_LISTS.ALL]: 'All tokens',
}

const TokenListSelect = () => {
  const dispatch = useAppDispatch()
  const settings = useAppSelector(selectSettings)
  const hasDefaultTokenlist = useHasFeature(FEATURES.DEFAULT_TOKENLIST)

  const handleSelectTokenList = (event: SelectChangeEvent<TOKEN_LISTS>) => {
    const selectedString = event.target.value as TOKEN_LISTS
    dispatch(setTokenList(selectedString))
  }

  if (!hasDefaultTokenlist) {
    return null
  }

  return (
    <FormControl size="small">
      <InputLabel id="tokenlist-select-label">Token list</InputLabel>

      <OnboardingTooltip
        widgetLocalStorageId={LS_TOKENLIST_ONBOARDING}
        text={
          <>
            Spam filter on!
            <br />
            Switch to &quot;All tokens&quot; to see all of your tokens.
          </>
        }
      >
        <Select
          labelId="tokenlist-select-label"
          id="tokenlist-select"
          value={settings.tokenList}
          label="Tokenlist"
          onChange={handleSelectTokenList}
          renderValue={(value) => TokenListLabel[value]}
          onOpen={() => trackEvent(ASSETS_EVENTS.OPEN_TOKEN_LIST_MENU)}
          sx={{ minWidth: '152px' }}
        >
          <MenuItem value={TOKEN_LISTS.TRUSTED}>
            <Track {...ASSETS_EVENTS.SHOW_DEFAULT_TOKENS}>
              <Box display="flex" flexDirection="row" gap="4px" alignItems="center" minWidth={155}>
                {TokenListLabel.TRUSTED}
                <Tooltip
                  arrow
                  title={
                    <Typography>
                      Learn more about <ExternalLink href={HelpCenterArticle.SPAM_TOKENS}>default tokens</ExternalLink>
                    </Typography>
                  }
                >
                  <span>
                    <SvgIcon sx={{ display: 'block' }} color="border" fontSize="small" component={InfoIcon} />
                  </span>
                </Tooltip>
              </Box>
            </Track>
          </MenuItem>

          <MenuItem value={TOKEN_LISTS.ALL}>
            <Track {...ASSETS_EVENTS.SHOW_ALL_TOKENS}>
              <span>{TokenListLabel.ALL}</span>
            </Track>
          </MenuItem>
        </Select>
      </OnboardingTooltip>
    </FormControl>
  )
}

export default TokenListSelect
</file>

<file path="src/components/balances/TokenMenu/index.tsx">
import { Sticky } from '@/components/common/Sticky'
import Track from '@/components/common/Track'
import { ASSETS_EVENTS } from '@/services/analytics'
import { VisibilityOffOutlined } from '@mui/icons-material'
import { Box, Typography, Button } from '@mui/material'

import css from './styles.module.css'

const TokenMenu = ({
  saveChanges,
  cancel,
  selectedAssetCount,
  showHiddenAssets,
  deselectAll,
}: {
  saveChanges: () => void
  cancel: () => void
  deselectAll: () => void
  selectedAssetCount: number
  showHiddenAssets: boolean
}) => {
  if (selectedAssetCount === 0 && !showHiddenAssets) {
    return null
  }
  return (
    <Sticky>
      <Box className={css.wrapper}>
        <Box className={css.hideTokensHeader}>
          <VisibilityOffOutlined />
          <Typography variant="body2" lineHeight="inherit">
            {selectedAssetCount} {selectedAssetCount === 1 ? 'token' : 'tokens'} selected
          </Typography>
        </Box>
        <Box display="flex" flexDirection="row" gap={1}>
          <Track {...ASSETS_EVENTS.CANCEL_HIDE_DIALOG}>
            <Button onClick={cancel} className={css.cancelButton} size="small" variant="outlined">
              Cancel
            </Button>
          </Track>
          <Track {...ASSETS_EVENTS.DESELECT_ALL_HIDE_DIALOG}>
            <Button onClick={deselectAll} className={css.cancelButton} size="small" variant="outlined">
              Deselect all
            </Button>
          </Track>
          <Track {...ASSETS_EVENTS.SAVE_HIDE_DIALOG}>
            <Button onClick={saveChanges} className={css.applyButton} size="small" variant="contained">
              Save
            </Button>
          </Track>
        </Box>
      </Box>
    </Sticky>
  )
}

export default TokenMenu
</file>

<file path="src/components/balances/TokenMenu/styles.module.css">
.hideTokensHeader {
  display: flex;
  flex-direction: row;
  flex: 1;
  gap: var(--space-1);
  padding: 5px var(--space-2);
  background-color: var(--color-background-light);
  border-radius: 6px;
  min-width: 185px;
}

.wrapper {
  display: flex;
  flex-wrap: wrap;
  flex-direction: row;
  align-items: center;
  gap: var(--space-3);
}

.cancelButton {
  padding: 4px 10px;
}

.applyButton {
  padding: 6px var(--space-3);
}
</file>

<file path="src/components/batch/BatchIndicator/BatchTooltip.tsx">
import { type ReactElement, useEffect, useState } from 'react'
import { Box, SvgIcon } from '@mui/material'

import SuccessIcon from '@/public/images/common/success.svg'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'
import { CustomTooltip } from '@/components/common/CustomTooltip'

const BatchTooltip = ({ children }: { children: ReactElement }) => {
  const [showTooltip, setShowTooltip] = useState<boolean>(false)

  // Click outside to close the tooltip
  useEffect(() => {
    const handleClickOutside = () => setShowTooltip(false)
    document.addEventListener('click', handleClickOutside)
    return () => document.removeEventListener('click', handleClickOutside)
  }, [])

  // Show tooltip when tx is added to batch
  useEffect(() => {
    return txSubscribe(TxEvent.BATCH_ADD, () => setShowTooltip(true))
  }, [])

  return (
    <CustomTooltip
      open={showTooltip}
      onClose={() => setShowTooltip(false)}
      title={
        <Box display="flex" flexDirection="column" alignItems="center" p={2} gap={2}>
          <Box fontSize="53px">
            <SvgIcon component={SuccessIcon} inheritViewBox fontSize="inherit" />
          </Box>
          Transaction is added to batch
        </Box>
      }
    >
      <div>{children}</div>
    </CustomTooltip>
  )
}

export default BatchTooltip
</file>

<file path="src/components/batch/BatchIndicator/index.tsx">
import { Badge, ButtonBase, SvgIcon } from '@mui/material'
import BatchIcon from '@/public/images/common/batch.svg'
import { useDraftBatch } from '@/hooks/useDraftBatch'
import Track from '@/components/common/Track'
import { BATCH_EVENTS } from '@/services/analytics'
import BatchTooltip from './BatchTooltip'

const BatchIndicator = ({ onClick }: { onClick?: () => void }) => {
  const { length } = useDraftBatch()

  return (
    <BatchTooltip>
      <Track {...BATCH_EVENTS.BATCH_SIDEBAR_OPEN} label={length}>
        <ButtonBase title="Batch" onClick={onClick} sx={{ p: 2 }}>
          <Badge
            variant="standard"
            badgeContent={length}
            color="secondary"
            anchorOrigin={{
              vertical: 'bottom',
              horizontal: 'right',
            }}
          >
            <SvgIcon component={BatchIcon} inheritViewBox fontSize="medium" />
          </Badge>
        </ButtonBase>
      </Track>
    </BatchTooltip>
  )
}

export default BatchIndicator
</file>

<file path="src/components/batch/BatchSidebar/BatchTxItem.tsx">
import { type SyntheticEvent, useMemo, useCallback } from 'react'
import { Accordion, AccordionDetails, AccordionSummary, Box, ButtonBase, ListItem, SvgIcon } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import css from './styles.module.css'
import { type DraftBatchItem } from '@/store/batchSlice'
import TxType from '@/components/transactions/TxType'
import TxInfo from '@/components/transactions/TxInfo'
import DeleteIcon from '@/public/images/common/delete.svg'
import TxData from '@/components/transactions/TxDetails/TxData'
import { MethodDetails } from '@/components/transactions/TxDetails/TxData/DecodedData/MethodDetails'
import { TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { dateString } from '@safe-global/utils/utils/formatters'
import { BATCH_EVENTS, trackEvent } from '@/services/analytics'

type BatchTxItemProps = DraftBatchItem & {
  id: string
  count: number
  onDelete?: (id: string) => void
}

const BatchTxItem = ({ id, count, timestamp, txDetails, onDelete }: BatchTxItemProps) => {
  const txSummary = useMemo(
    () => ({
      timestamp,
      id: txDetails.txId,
      txInfo: txDetails.txInfo,
      txStatus: txDetails.txStatus,
      safeAppInfo: txDetails.safeAppInfo,
      txHash: txDetails.txHash || null,
    }),
    [timestamp, txDetails],
  )

  const handleDelete = useCallback(
    (e: SyntheticEvent) => {
      e.stopPropagation()
      if (confirm('Are you sure you want to delete this transaction?')) {
        onDelete?.(id)
        trackEvent(BATCH_EVENTS.BATCH_DELETE_TX)
      }
    },
    [onDelete, id],
  )

  const handleExpand = () => {
    trackEvent(BATCH_EVENTS.BATCH_EXPAND_TX)
  }

  return (
    <ListItem disablePadding sx={{ gap: 2, alignItems: 'flex-start' }}>
      <div className={css.number}>{count}</div>
      <Accordion elevation={0} sx={{ flex: 1 }} onChange={handleExpand}>
        <AccordionSummary expandIcon={<ExpandMoreIcon />} className={css.accordion}>
          <Box
            sx={{
              flex: 1,
              display: 'flex',
              alignItems: 'center',
              gap: 2,
              py: 0.4,
              width: '100%',
            }}
          >
            <TxType tx={txSummary} />

            <Box flex={1}>
              <TxInfo info={txDetails.txInfo} />
            </Box>

            {onDelete && (
              <>
                <Box className={css.separator} />

                <ButtonBase onClick={handleDelete} title="Delete transaction" sx={{ p: 0.5 }}>
                  <SvgIcon component={DeleteIcon} inheritViewBox fontSize="small" />
                </ButtonBase>

                <Box className={css.separator} mr={2} />
              </>
            )}
          </Box>
        </AccordionSummary>

        <AccordionDetails>
          <div className={css.details}>
            <TxData
              txInfo={txDetails.txInfo}
              txData={txDetails.txData}
              txDetails={txDetails}
              trusted
              imitation={false}
            />

            <TxDataRow title="Created:">{timestamp ? dateString(timestamp) : null}</TxDataRow>

            {txDetails.txData?.dataDecoded && (
              <MethodDetails data={txDetails.txData.dataDecoded} addressInfoIndex={txDetails.txData.addressInfoIndex} />
            )}
          </div>
        </AccordionDetails>
      </Accordion>
    </ListItem>
  )
}

export default BatchTxItem
</file>

<file path="src/components/batch/BatchSidebar/BatchTxList.tsx">
import type { DraftBatchItem } from '@/store/batchSlice'
import BatchTxItem from './BatchTxItem'
import { List } from '@mui/material'

const BatchTxList = ({ txItems, onDelete }: { txItems: DraftBatchItem[]; onDelete?: (id: string) => void }) => {
  return (
    <>
      <List sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
        {txItems.map((item, index) => (
          <BatchTxItem key={item.id} count={index + 1} {...item} onDelete={onDelete} />
        ))}
      </List>
    </>
  )
}

export default BatchTxList
</file>

<file path="src/components/batch/BatchSidebar/EmptyBatch.tsx">
import { type ReactNode } from 'react'
import EmptyBatchIcon from '@/public/images/common/empty-batch.svg'
import InfoIcon from '@/public/images/notifications/info.svg'
import AssetsIcon from '@/public/images/sidebar/assets.svg'
import AppsIcon from '@/public/images/apps/apps-icon.svg'
import SettingsIcon from '@/public/images/sidebar/settings.svg'
import { Box, SvgIcon, Typography } from '@mui/material'

const EmptyBatch = ({ children }: { children: ReactNode }) => (
  <Box display="flex" flexWrap="wrap" justifyContent="center" textAlign="center" mt={3} px={4}>
    <SvgIcon component={EmptyBatchIcon} inheritViewBox sx={{ fontSize: 110 }} />

    <Typography variant="h4" fontWeight={700}>
      Add an initial transaction to the batch
    </Typography>

    <Typography variant="body2" mt={2} mb={4} px={8} sx={{ textWrap: 'balance' }}>
      Save gas and signatures by adding multiple Safe transactions to a single batch transaction. You can reorder and
      delete individual transactions in a batch.
    </Typography>

    {children}

    <Typography variant="body2" color="border.main" mt={8}>
      <Box mb={1}>
        <SvgIcon component={InfoIcon} inheritViewBox />
      </Box>

      <b>What type of transactions can you add to the batch?</b>

      <Box display="flex" mt={3} gap={6}>
        <div>
          <SvgIcon component={AssetsIcon} inheritViewBox />
          <div>Token and NFT transfers</div>
        </div>

        <div>
          <SvgIcon component={AppsIcon} inheritViewBox />
          <div>Safe App transactions</div>
        </div>

        <div>
          <SvgIcon component={SettingsIcon} inheritViewBox />
          <div>Safe Account settings</div>
        </div>
      </Box>
    </Typography>
  </Box>
)

export default EmptyBatch
</file>

<file path="src/components/batch/BatchSidebar/index.tsx">
import { type SyntheticEvent, useEffect } from 'react'
import { useCallback, useContext } from 'react'
import { Button, Divider, Drawer, IconButton, SvgIcon, Typography } from '@mui/material'
import CloseIcon from '@mui/icons-material/Close'
import { useDraftBatch, useUpdateBatch } from '@/hooks/useDraftBatch'
import css from './styles.module.css'
import { NewTxFlow } from '@/components/tx-flow/flows'
import { TxModalContext } from '@/components/tx-flow'
import { ConfirmBatchFlow } from '@/components/tx-flow/flows'
import Track from '@/components/common/Track'
import { BATCH_EVENTS } from '@/services/analytics'
import CheckWallet from '@/components/common/CheckWallet'
import PlusIcon from '@/public/images/common/plus.svg'
import EmptyBatch from './EmptyBatch'
import BatchTxList from './BatchTxList'

const BatchSidebar = ({ isOpen, onToggle }: { isOpen: boolean; onToggle: (open: boolean) => void }) => {
  const { txFlow, setTxFlow } = useContext(TxModalContext)
  const batchTxs = useDraftBatch()
  const [, deleteTx] = useUpdateBatch()

  const closeSidebar = useCallback(() => {
    onToggle(false)
  }, [onToggle])

  const clearBatch = useCallback(() => {
    batchTxs.forEach((item) => deleteTx(item.id))
  }, [deleteTx, batchTxs])

  // Close confirmation flow when batch is empty
  const isConfirmationFlow = txFlow?.type === ConfirmBatchFlow
  const shouldExitFlow = isConfirmationFlow && batchTxs.length === 0
  useEffect(() => {
    if (shouldExitFlow) {
      setTxFlow(undefined)
    }
  }, [setTxFlow, shouldExitFlow])

  const onAddClick = useCallback(
    (e: SyntheticEvent) => {
      e.preventDefault()
      setTxFlow(<NewTxFlow />, undefined, false)
    },
    [setTxFlow],
  )

  const onConfirmClick = useCallback(
    async (e: SyntheticEvent) => {
      e.preventDefault()
      if (!batchTxs.length) return
      closeSidebar()
      setTxFlow(<ConfirmBatchFlow onSubmit={clearBatch} />, undefined, false)
    },
    [setTxFlow, batchTxs, closeSidebar, clearBatch],
  )

  // Close sidebar when txFlow modal is opened
  useEffect(() => {
    if (txFlow) closeSidebar()
  }, [txFlow, closeSidebar])

  return (
    <Drawer variant="temporary" anchor="right" open={isOpen} onClose={closeSidebar} transitionDuration={100}>
      <aside className={css.aside}>
        <Typography variant="h4" fontWeight={700} mb={1}>
          Batched transactions
        </Typography>

        <Divider />

        {batchTxs.length ? (
          <>
            <div className={css.txs}>
              <BatchTxList txItems={batchTxs} onDelete={deleteTx} />
            </div>

            <CheckWallet>
              {(isOk) => (
                <Track {...BATCH_EVENTS.BATCH_NEW_TX}>
                  <Button onClick={onAddClick} disabled={!isOk}>
                    <SvgIcon component={PlusIcon} inheritViewBox fontSize="small" sx={{ mr: 1 }} />
                    Add new transaction
                  </Button>
                </Track>
              )}
            </CheckWallet>

            <Divider />

            <CheckWallet>
              {(isOk) => (
                <Track {...BATCH_EVENTS.BATCH_CONFIRM} label={batchTxs.length}>
                  <Button
                    variant="contained"
                    onClick={onConfirmClick}
                    disabled={!batchTxs.length || !isOk}
                    className={css.confirmButton}
                  >
                    Confirm batch
                  </Button>
                </Track>
              )}
            </CheckWallet>
          </>
        ) : (
          <EmptyBatch>
            <CheckWallet>
              {(isOk) => (
                <Track {...BATCH_EVENTS.BATCH_NEW_TX}>
                  <Button onClick={onAddClick} variant="contained" disabled={!isOk}>
                    New transaction
                  </Button>
                </Track>
              )}
            </CheckWallet>
          </EmptyBatch>
        )}

        <IconButton className={css.close} aria-label="close" onClick={closeSidebar} size="small">
          <CloseIcon fontSize="medium" />
        </IconButton>
      </aside>
    </Drawer>
  )
}

export default BatchSidebar
</file>

<file path="src/components/batch/BatchSidebar/styles.module.css">
.aside {
  margin-top: var(--header-height);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  width: 700px;
  max-width: 100vw;
  padding-bottom: var(--space-3);
}

.aside h4 {
  width: 100%;
  padding: var(--space-3) var(--space-3) 0;
  margin: 0;
}

.aside hr {
  width: 100%;
  margin: var(--space-3) 0;
}

.txs {
  width: 100%;
}

.txs ul {
  padding: 0 var(--space-3) var(--space-2);
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
  list-style: none;
}

.txs li {
  margin: 0;
  padding: 0;
}

.separator {
  border-left: 1px solid var(--color-border-light);
  height: calc(100% + 31px);
}

.confirmButton {
  margin-top: var(--space-1);
}

.txs svg {
  color: var(--color-border-main);
  transition: color 0.1s ease-in;
  transform: scale(1.2);
}

.txs button:hover svg {
  color: var(--color-primary);
}

.number {
  background-color: var(--color-border-light);
  border-radius: 100%;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  margin-top: var(--space-2);
}

.close {
  position: absolute;
  right: var(--space-2);
  top: var(--space-2);
  z-index: 1;
  padding: var(--space-1);
  color: var(--color-border-main);
}

.details {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  padding: var(--space-2);
  margin: calc(-1 * var(--space-2));
  border-top: 1px solid var(--color-secondary-light);
}

.dragHandle {
  cursor: grab;
}

.dragHandle:active {
  cursor: grabbing;
}

.accordion {
  opacity: 1 !important;
}

.accordion :global .MuiAccordionSummary-content {
  width: 100%;
  overflow: hidden;
  margin: 0;
  padding: 12px 0px;
}
</file>

<file path="src/components/common/AddFunds/index.tsx">
import { Box, FormControlLabel, Grid, Paper, Switch, Typography } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import QRCode from '@/components/common/QRCode'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeAddress from '@/hooks/useSafeAddress'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setQrShortName } from '@/store/settingsSlice'
import BuyCryptoButton from '@/components/common/BuyCryptoButton'

const AddFundsCTA = () => {
  const safeAddress = useSafeAddress()
  const chain = useCurrentChain()
  const dispatch = useAppDispatch()
  const settings = useAppSelector(selectSettings)
  const qrPrefix = settings.shortName.qr ? `${chain?.shortName}:` : ''
  const qrCode = `${qrPrefix}${safeAddress}`

  return (
    <Paper data-testid="add-funds-section">
      <Grid
        container
        sx={{
          gap: 3,
          alignItems: 'center',
          justifyContent: 'center',
          p: 4,
        }}
      >
        <Grid item>
          <div>
            <Box
              sx={{
                p: 2,
                border: '1px solid',
                borderColor: 'border.light',
                borderRadius: 1,
                display: 'inline-block',
              }}
            >
              <QRCode value={qrCode} size={195} />
            </Box>
          </div>

          <FormControlLabel
            control={
              <Switch checked={settings.shortName.qr} onChange={(e) => dispatch(setQrShortName(e.target.checked))} />
            }
            label={<>QR code with chain prefix</>}
          />
        </Grid>

        <Grid
          item
          container
          xs={12}
          md={6}
          sx={{
            gap: 2,
            flexDirection: 'column',
          }}
        >
          <Typography
            variant="h3"
            sx={{
              fontWeight: 'bold',
            }}
          >
            Add funds to get started
          </Typography>

          <Typography>
            Add funds directly from your bank account or copy your address to send tokens from a different account.
          </Typography>

          <Box
            sx={{
              bgcolor: 'background.main',
              p: 2,
              borderRadius: '6px',
              alignSelf: 'flex-start',
              fontSize: '14px',
            }}
          >
            <EthHashInfo address={safeAddress} shortAddress={false} showCopyButton hasExplorer avatarSize={24} />
          </Box>

          <Box
            sx={{
              alignSelf: 'flex-start',
            }}
          >
            <BuyCryptoButton />
          </Box>
        </Grid>
      </Grid>
    </Paper>
  )
}

export default AddFundsCTA
</file>

<file path="src/components/common/AddressBookInput/index.tsx">
import { type ReactElement, useState, useMemo } from 'react'
import { Controller, useFormContext, useWatch } from 'react-hook-form'
import { SvgIcon, Typography } from '@mui/material'
import Autocomplete, { createFilterOptions } from '@mui/material/Autocomplete'
import useAddressBook from '@/hooks/useAddressBook'
import AddressInput, { type AddressInputProps } from '../AddressInput'
import EthHashInfo from '../EthHashInfo'
import InfoIcon from '@/public/images/notifications/info.svg'
import EntryDialog from '@/components/address-book/EntryDialog'
import css from './styles.module.css'
import inputCss from '@/styles/inputs.module.css'
import { isValidAddress } from '@safe-global/utils/utils/validation'
import { sameAddress } from '@safe-global/utils/utils/addresses'

const abFilterOptions = createFilterOptions({
  stringify: (option: { label: string; name: string }) => option.name + ' ' + option.label,
})

/**
 *  Temporary component until revamped safe components are done
 */
const AddressBookInput = ({ name, canAdd, ...props }: AddressInputProps & { canAdd?: boolean }): ReactElement => {
  const addressBook = useAddressBook()
  const { setValue, control } = useFormContext()
  const addressValue = useWatch({ name, control })
  const [open, setOpen] = useState(false)
  const [openAddressBook, setOpenAddressBook] = useState<boolean>(false)

  const addressBookEntries = Object.entries(addressBook).map(([address, name]) => ({
    label: address,
    name,
  }))

  const hasVisibleOptions = useMemo(
    () => !!addressBookEntries.filter((entry) => entry.label.includes(addressValue)).length,
    [addressBookEntries, addressValue],
  )

  const isInAddressBook = useMemo(
    () => addressBookEntries.some((entry) => sameAddress(entry.label, addressValue)),
    [addressBookEntries, addressValue],
  )

  const customFilterOptions = (options: any, state: any) => {
    // Don't show suggestions from the address book once a valid address has been entered.
    if (isValidAddress(addressValue)) return []
    return abFilterOptions(options, state)
  }

  const handleOpenAutocomplete = () => {
    setOpen((value) => !value)
  }

  const onAddressBookClick = canAdd
    ? () => {
        setOpenAddressBook(true)
      }
    : undefined

  return (
    <>
      <Controller
        name={name}
        control={control}
        // eslint-disable-next-line
        render={({ field: { ref, ...field } }) => (
          <Autocomplete
            {...field}
            className={inputCss.input}
            disableClearable
            disabled={props.disabled}
            readOnly={props.InputProps?.readOnly}
            freeSolo
            options={addressBookEntries}
            onChange={(_, value) => (typeof value === 'string' ? field.onChange(value) : field.onChange(value.label))}
            onInputChange={(_, value) => setValue(name, value)}
            filterOptions={customFilterOptions}
            componentsProps={{
              paper: {
                elevation: 2,
              },
            }}
            renderOption={(props, option) => {
              const { key, ...rest } = props
              return (
                <Typography data-testid="address-item" component="li" variant="body2" {...rest} key={key}>
                  <EthHashInfo address={option.label} name={option.name} shortAddress={false} copyAddress={false} />
                </Typography>
              )
            }}
            renderInput={(params) => (
              <AddressInput
                data-testid="address-item"
                {...params}
                {...props}
                focused={props.focused || !addressValue}
                name={name}
                onOpenListClick={hasVisibleOptions ? handleOpenAutocomplete : undefined}
                isAutocompleteOpen={open}
                onAddressBookClick={canAdd && !isInAddressBook ? onAddressBookClick : undefined}
              />
            )}
          />
        )}
      />

      {canAdd && !isInAddressBook ? (
        <Typography variant="body2" className={css.unknownAddress}>
          <SvgIcon component={InfoIcon} fontSize="small" />
          <span>
            This is an unknown address. You can{' '}
            <a role="button" onClick={onAddressBookClick}>
              add it to your address book
            </a>
            .
          </span>
        </Typography>
      ) : null}

      {openAddressBook && (
        <EntryDialog
          handleClose={() => setOpenAddressBook(false)}
          defaultValues={{ name: '', address: addressValue }}
        />
      )}
    </>
  )
}

export default AddressBookInput
</file>

<file path="src/components/common/AddressBookInput/styles.module.css">
.unknownAddress {
  margin-top: calc(-1 * var(--space-2));
  padding: 20px 12px 4px;
  background-color: var(--color-background-main);
  color: var(--color-text-secondary);
  display: flex;
  gap: var(--space-1);
  width: 100%;
  border-radius: 6px;
}

.unknownAddress svg {
  height: auto;
}

.unknownAddress a {
  color: inherit;
  text-decoration: underline;
  cursor: pointer;
}
</file>

<file path="src/components/common/AddressInput/index.tsx">
import AddressInputReadOnly from '@/components/common/AddressInputReadOnly'
import useAddressBook from '@/hooks/useAddressBook'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'
import { useEffect, useCallback, useRef, useMemo } from 'react'
import {
  InputAdornment,
  TextField,
  type TextFieldProps,
  CircularProgress,
  IconButton,
  SvgIcon,
  Skeleton,
  Box,
} from '@mui/material'
import { useFormContext, useWatch, type Validate, get } from 'react-hook-form'
import { validatePrefixedAddress } from '@safe-global/utils/utils/validation'
import { useCurrentChain } from '@/hooks/useChains'
import useNameResolver from './useNameResolver'
import { cleanInputValue, parsePrefixedAddress } from '@safe-global/utils/utils/addresses'
import useDebounce from '@/hooks/useDebounce'
import CaretDownIcon from '@/public/images/common/caret-down.svg'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import classnames from 'classnames'
import css from './styles.module.css'
import inputCss from '@/styles/inputs.module.css'
import Identicon from '../Identicon'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

export type AddressInputProps = TextFieldProps & {
  name: string
  address?: string
  onOpenListClick?: () => void
  isAutocompleteOpen?: boolean
  validate?: Validate<string>
  deps?: string | string[]
  onAddressBookClick?: () => void
  chain?: ChainInfo
  showPrefix?: boolean
}

const AddressInput = ({
  name,
  validate,
  required = true,
  onOpenListClick,
  isAutocompleteOpen,
  onAddressBookClick,
  deps,
  chain,
  showPrefix = true,
  ...props
}: AddressInputProps): ReactElement => {
  const {
    register,
    setValue,
    control,
    formState: { errors, isValidating },
    trigger,
  } = useFormContext()

  const currentChain = useCurrentChain()
  const rawValueRef = useRef<string>('')
  const watchedValue = useWatch({ name, control })
  const currentShortName = chain?.shortName || currentChain?.shortName || ''

  const addressBook = useAddressBook()

  // Fetch an ENS resolution for the current address
  const isDomainLookupEnabled = !!currentChain && hasFeature(currentChain, FEATURES.DOMAIN_LOOKUP)
  const { address, resolverError, resolving } = useNameResolver(isDomainLookupEnabled ? watchedValue : '')

  // errors[name] doesn't work with nested field names like 'safe.address', need to use the lodash get
  const fieldError = resolverError || get(errors, name)

  // Debounce the field error unless there's no error or it's resolving a domain
  let error = useDebounce(fieldError, 500)
  if (resolverError) error = resolverError
  if (!fieldError || resolving) error = undefined

  // Validation function based on the current chain prefix
  const validatePrefixed = useMemo(() => validatePrefixedAddress(currentShortName), [currentShortName])

  const transformAddressValue = useCallback(
    (value: string): string => {
      // Clean the input value
      const cleanValue = cleanInputValue(value)
      rawValueRef.current = cleanValue
      // This also checksums the address
      if (validatePrefixed(cleanValue) === undefined) {
        // if the prefix is correct we remove it from the value
        return parsePrefixedAddress(cleanValue).address
      } else {
        // we keep invalid prefixes such that the validation error is persistent
        return cleanValue
      }
    },
    [validatePrefixed],
  )

  // Update the input value
  const setAddressValue = useCallback(
    (value: string) => setValue(name, value, { shouldValidate: true }),
    [setValue, name],
  )

  // On ENS resolution, update the input value
  useEffect(() => {
    if (address) {
      setAddressValue(`${currentShortName}:${address}`)
    }
  }, [address, currentShortName, setAddressValue])

  // Retransform the value when chain changes
  useEffect(() => {
    if (address) return

    if (watchedValue) {
      const transformedValue = transformAddressValue(watchedValue)
      setAddressValue(transformedValue)
    }
  }, [address, currentShortName, setAddressValue, transformAddressValue, watchedValue])

  const endAdornment = (
    <InputAdornment position="end">
      {resolving || isValidating ? (
        <CircularProgress size={20} />
      ) : !props.disabled ? (
        <>
          {onAddressBookClick && (
            <IconButton onClick={onAddressBookClick}>
              <SvgIcon component={SaveAddressIcon} inheritViewBox fontSize="small" color="primary" />
            </IconButton>
          )}

          {onOpenListClick && (
            <IconButton
              onClick={onOpenListClick}
              className={classnames(css.openButton, { [css.rotated]: isAutocompleteOpen })}
              color="primary"
            >
              <SvgIcon component={CaretDownIcon} inheritViewBox fontSize="small" />
            </IconButton>
          )}
        </>
      ) : null}
    </InputAdornment>
  )

  const resetName = () => {
    if (!props.disabled && addressBook[watchedValue]) {
      setValue(name, '')
    }
  }

  return (
    <>
      <TextField
        {...props}
        className={inputCss.input}
        autoComplete="off"
        autoFocus={props.focused}
        label={<>{error?.message || props.label || `Recipient address${isDomainLookupEnabled ? ' or ENS' : ''}`}</>}
        error={!!error}
        fullWidth
        onClick={resetName}
        spellCheck={false}
        InputProps={{
          ...(props.InputProps || {}),
          className: addressBook[watchedValue] ? css.readOnly : undefined,

          startAdornment: addressBook[watchedValue] ? (
            <AddressInputReadOnly address={watchedValue} showPrefix={showPrefix} chainId={chain?.chainId} />
          ) : (
            // Display the current short name in the adornment, unless the value contains the same prefix
            <InputAdornment position="end" sx={{ ml: 0 }}>
              <Box mr={1}>
                {watchedValue && !fieldError ? (
                  <Identicon address={watchedValue} size={32} />
                ) : (
                  <Skeleton variant="circular" width={32} height={32} animation={false} />
                )}
              </Box>

              {showPrefix && !rawValueRef.current.startsWith(`${currentShortName}:`) && <Box>{currentShortName}:</Box>}
            </InputAdornment>
          ),

          endAdornment,
        }}
        InputLabelProps={{
          ...(props.InputLabelProps || {}),
          shrink: true,
        }}
        {...register(name, {
          deps,

          required,

          setValueAs: transformAddressValue,

          validate: async () => {
            const value = rawValueRef.current
            if (value) {
              return validatePrefixed(value) || (await validate?.(parsePrefixedAddress(value).address))
            }
          },

          // Workaround for a bug in react-hook-form that it restores a cached error state on blur
          onBlur: () => setTimeout(() => trigger(name), 100),
        })}
        // Workaround for a bug in react-hook-form when `register().value` is cached after `setValueAs`
        // Only seems to occur on the `/load` route
        value={watchedValue}
      />
    </>
  )
}

export default AddressInput
</file>

<file path="src/components/common/AddressInput/styles.module.css">
.wrapper :global .MuiInputLabel-root.Mui-error[data-shrink='false'] {
  padding: 5px 4px;
}

.wrapper :global .MuiInputAdornment-root {
  margin-left: 0;
}

.openButton svg {
  transition: transform 0.3s ease-in-out;
}

.rotated svg {
  transform: rotate(180deg);
}

.readOnly :global .MuiInputBase-input {
  visibility: hidden;
}
</file>

<file path="src/components/common/AddressInput/useNameResolver.ts">
import { useMemo } from 'react'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { isDomain, resolveName } from '@/services/ens'
import useDebounce from '@/hooks/useDebounce'

const useNameResolver = (
  value?: string,
): { address: string | undefined; resolverError?: Error; resolving: boolean } => {
  const ethersProvider = useWeb3ReadOnly()
  const debouncedValue = useDebounce((value || '').trim(), 200)

  // Fetch an ENS resolution for the current address
  const [ens, resolverError, isResolving] = useAsync<{ name: string; address: string } | undefined>(() => {
    if (!ethersProvider || !debouncedValue || !isDomain(debouncedValue)) return

    return resolveName(ethersProvider, debouncedValue).then((address) => {
      if (!address) throw Error('Failed to resolve the address')
      return { name: debouncedValue, address }
    })
  }, [debouncedValue, ethersProvider])

  const resolving = isResolving && !!ethersProvider && !!debouncedValue
  const address = ens && ens.name === value ? ens.address : undefined

  return useMemo(
    () => ({
      address,
      resolverError,
      resolving,
    }),
    [address, resolverError, resolving],
  )
}

export default useNameResolver
</file>

<file path="src/components/common/AddressInputReadOnly/index.tsx">
import { type ReactElement } from 'react'
import { InputAdornment, Typography } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import css from './styles.module.css'

const AddressInputReadOnly = ({
  address,
  showPrefix,
  chainId,
}: {
  address: string
  showPrefix?: boolean
  chainId?: string
}): ReactElement => {
  return (
    <div className={css.input} data-testid="address-book-recipient">
      <InputAdornment position="start">
        <Typography variant="body2" component="div" width={1}>
          <EthHashInfo
            address={address}
            shortAddress={false}
            copyAddress={false}
            chainId={chainId}
            showPrefix={showPrefix}
          />
        </Typography>
      </InputAdornment>
    </div>
  )
}

export default AddressInputReadOnly
</file>

<file path="src/components/common/AddressInputReadOnly/styles.module.css">
.input {
  width: calc(100% - 40px);
}

.input :global .MuiInputBase-input {
  padding: var(--space-1) var(--space-2);
}

.input input[type='text'] {
  padding-left: 0;
  padding-right: 0;
}

.input [title] {
  font-weight: bold;
  color: var(--color-text-primary);
}

.value {
  width: 100%;
}
</file>

<file path="src/components/common/BlockedAddress/index.tsx">
import type { ReactElement } from 'react'
import { useMediaQuery, useTheme } from '@mui/material'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import { useRouter } from 'next/router'
import Disclaimer from '@/components/common/Disclaimer'
import { AppRoutes } from '@/config/routes'

export const BlockedAddress = ({
  address,
  featureTitle,
  onClose,
}: {
  address: string
  featureTitle: string
  onClose?: () => void
}): ReactElement => {
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))
  const displayAddress = address && isMobile ? shortenAddress(address) : address
  const router = useRouter()

  const handleAccept = () => {
    router.push({ pathname: AppRoutes.home, query: router.query })
  }

  return (
    <Disclaimer
      title="Blocked address"
      subtitle={displayAddress}
      content={`The above address is part of the OFAC SDN list and the ${featureTitle} is unavailable for sanctioned addresses.`}
      onAccept={onClose ?? handleAccept}
    />
  )
}

export default BlockedAddress
</file>

<file path="src/components/common/BlockedAddress/styles.module.css">
.container {
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.iconCircle {
  color: var(--color-info-main);
  border-radius: 50%;
  display: flex;
  padding: var(--space-1);
  background: #d7f6ff;
}
</file>

<file path="src/components/common/Breadcrumbs/BreadcrumbItem.tsx">
import Link from 'next/link'
import type { UrlObject } from 'url'
import { Tooltip, Typography, useMediaQuery, useTheme } from '@mui/material'
import useAddressBook from '@/hooks/useAddressBook'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import css from './styles.module.css'
import Identicon from '@/components/common/Identicon'

export const BreadcrumbItem = ({ title, address, href }: { title: string; address: string; href?: UrlObject }) => {
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))
  const addressBook = useAddressBook()
  const name = addressBook[address] ?? (isMobile ? shortenAddress(address) : address)

  return (
    <Tooltip title={title}>
      <div className={css.breadcrumb}>
        <Identicon address={address} size={20} />
        {href ? (
          <Link href={href}>
            <Typography variant="body2" color="text.secondary">
              {name}
            </Typography>
          </Link>
        ) : (
          <Typography variant="body2">{name}</Typography>
        )}
      </div>
    </Tooltip>
  )
}
</file>

<file path="src/components/common/Breadcrumbs/index.tsx">
import css from './styles.module.css'
import SpaceBreadcrumbs from '@/features/spaces/components/SpaceBreadcrumbs'
import { NestedSafeBreadcrumbs } from '@/components/common/NestedSafeBreadcrumbs'

const Breadcrumbs = () => {
  return (
    <div className={css.container} data-testid="safe-breadcrumb-container">
      <SpaceBreadcrumbs />
      <NestedSafeBreadcrumbs />
    </div>
  )
}

export default Breadcrumbs
</file>

<file path="src/components/common/Breadcrumbs/styles.module.css">
.container {
  height: 36px;
  display: flex;
  align-items: center;
  background-color: var(--color-background-paper);
  border-bottom: 1px solid var(--color-border-light);
  padding: var(--space-1) var(--space-3);
  gap: var(--space-1);
}

.container:empty {
  display: none;
}

.breadcrumb {
  display: flex;
  align-items: center;
  gap: calc(var(--space-1) / 2);
}
</file>

<file path="src/components/common/BuyCryptoButton/index.tsx">
import { useTheme } from '@mui/material/styles'
import { usePathname, useSearchParams } from 'next/navigation'
import Link, { type LinkProps } from 'next/link'
import { Alert, Box, Button, ButtonBase, Typography, useMediaQuery } from '@mui/material'
import AddIcon from '@mui/icons-material/Add'
import { SafeAppsTag } from '@/config/constants'
import { AppRoutes } from '@/config/routes'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'
import madProps from '@/utils/mad-props'
import { type ReactNode, useMemo } from 'react'
import Track from '../Track'
import { OVERVIEW_EVENTS } from '@/services/analytics'
import RampLogo from '@/public/images/common/ramp_logo.svg'
import css from './styles.module.css'
import ChevronRightRoundedIcon from '@mui/icons-material/ChevronRightRounded'

const useOnrampAppUrl = (): string | undefined => {
  const [onrampApps] = useRemoteSafeApps({ tag: SafeAppsTag.ONRAMP })
  return onrampApps?.[0]?.url
}

const useBuyCryptoHref = (): LinkProps['href'] | undefined => {
  const query = useSearchParams()
  const safe = query?.get('safe')
  const appUrl = useOnrampAppUrl()

  return useMemo(() => {
    if (!safe || !appUrl) return undefined
    return { pathname: AppRoutes.apps.open, query: { safe, appUrl } }
  }, [safe, appUrl])
}

const buttonStyles = {
  minHeight: '37.5px',
}

const BuyCryptoOption = ({ name, children }: { name: string; children: ReactNode }) => {
  return (
    <ButtonBase className={css.button}>
      <Typography display="flex" alignItems="center" fontWeight="bold" fontSize="18px" gap={1}>
        {children}
        {name}
      </Typography>
      <ChevronRightRoundedIcon color="border" />
    </ButtonBase>
  )
}

const _BuyCryptoOptions = ({ rampLink }: { rampLink?: LinkProps['href'] }) => {
  if (rampLink) {
    return (
      <Box position="relative">
        <Track {...OVERVIEW_EVENTS.BUY_CRYPTO_BUTTON} label="onboarding">
          <Link href={rampLink} passHref>
            <BuyCryptoOption name="Ramp">
              <RampLogo />
            </BuyCryptoOption>
          </Link>
        </Track>
      </Box>
    )
  }

  return (
    <Alert severity="info">
      Find an on-ramp provider that supports your region and on-ramp funds to your Safe Account address.
    </Alert>
  )
}

const InternalBuyCryptoButton = ({ href, pagePath }: { href?: LinkProps['href']; pagePath: string }) => {
  const theme = useTheme()
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'))

  if (!href) return null

  return (
    <>
      <Track {...OVERVIEW_EVENTS.BUY_CRYPTO_BUTTON} label={pagePath}>
        <Link href={href} passHref>
          <Button
            variant="contained"
            size={isSmallScreen ? 'medium' : 'small'}
            sx={buttonStyles}
            startIcon={<AddIcon />}
            className={css.buyCryptoButton}
            fullWidth
          >
            Buy crypto
          </Button>
        </Link>
      </Track>
    </>
  )
}

const BuyCryptoButton = madProps(InternalBuyCryptoButton, {
  href: useBuyCryptoHref,
  pagePath: usePathname,
})

export const BuyCryptoOptions = madProps(_BuyCryptoOptions, {
  rampLink: useBuyCryptoHref,
})

export default BuyCryptoButton
</file>

<file path="src/components/common/BuyCryptoButton/styles.module.css">
.button {
  justify-content: space-between;
  padding: var(--space-2);
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
  width: 100%;
  color: var(--color-text-primary);
}

.button:hover {
  border-color: var(--color-primary-main);
}

@media (max-width: 400px) {
  .buyCryptoButton {
    width: 100%;
  }
}
</file>

<file path="src/components/common/ChainIndicator/index.tsx">
import type { ReactElement } from 'react'
import { useMemo } from 'react'
import classnames from 'classnames'
import { useAppSelector } from '@/store'
import { selectChainById, selectChains } from '@/store/chainsSlice'
import css from './styles.module.css'
import useChainId from '@/hooks/useChainId'
import { Skeleton, Stack, Typography } from '@mui/material'
import isEmpty from 'lodash/isEmpty'
import FiatValue from '../FiatValue'

type ChainIndicatorProps = {
  chainId?: string
  inline?: boolean
  className?: string
  showUnknown?: boolean
  showLogo?: boolean
  onlyLogo?: boolean
  responsive?: boolean
  fiatValue?: string
}

const fallbackChainConfig = {
  chainName: 'Unknown chain',
  chainId: '-1',
  theme: {
    backgroundColor: '#ddd',
    textColor: '#000',
  },
  chainLogoUri: null,
}

const ChainIndicator = ({
  chainId,
  fiatValue,
  className,
  inline = false,
  showUnknown = true,
  showLogo = true,
  responsive = false,
  onlyLogo = false,
}: ChainIndicatorProps): ReactElement | null => {
  const currentChainId = useChainId()
  const id = chainId || currentChainId
  const chains = useAppSelector(selectChains)
  const chainConfig =
    useAppSelector((state) => selectChainById(state, id)) || (showUnknown ? fallbackChainConfig : null)
  const noChains = isEmpty(chains.data)

  const style = useMemo(() => {
    if (!chainConfig) return
    const { theme } = chainConfig

    return {
      backgroundColor: theme.backgroundColor,
      color: theme.textColor,
    }
  }, [chainConfig])

  return noChains ? (
    <Skeleton width="100%" height="22px" variant="rectangular" sx={{ flexShrink: 0 }} />
  ) : chainConfig ? (
    <span
      data-testid="chain-logo"
      style={showLogo ? undefined : style}
      className={classnames(className || '', {
        [css.inlineIndicator]: inline,
        [css.indicator]: !inline,
        [css.withLogo]: showLogo,
        [css.responsive]: responsive,
        [css.onlyLogo]: onlyLogo,
      })}
    >
      {showLogo && (
        <img
          src={chainConfig.chainLogoUri ?? undefined}
          alt={`${chainConfig.chainName} Logo`}
          width={24}
          height={24}
          loading="lazy"
        />
      )}
      {!onlyLogo && (
        <Stack>
          <span className={css.name}>{chainConfig.chainName}</span>
          {fiatValue && (
            <Typography fontWeight={700} textAlign="left" fontSize="14px">
              <FiatValue value={fiatValue} />
            </Typography>
          )}
        </Stack>
      )}
    </span>
  ) : null
}

export default ChainIndicator
</file>

<file path="src/components/common/ChainIndicator/styles.module.css">
.indicator {
  display: flex;
  align-items: center;
  min-width: 70px;
  font-size: 12px;
  justify-content: center;
}

.inlineIndicator {
  display: inline-block;
  min-width: 70px;
  font-size: 11px;
  line-height: normal;
  text-align: center;
  border-radius: 4px;
  padding: 4px 8px;
}

.withLogo {
  display: flex;
  align-items: center;
  gap: var(--space-1);
  padding: 0;
  min-width: 115px;
  font-size: 14px;
  justify-content: flex-start;
}

.onlyLogo {
  min-width: 0;
}

@media (max-width: 899.95px) {
  .indicator {
    min-width: 35px;
  }
  .responsive {
    min-width: 0;
  }
  .responsive .name {
    display: none;
  }
}

@container my-accounts-container (max-width: 500px) {
  .responsive {
    min-width: 0;
  }
  .responsive .name {
    display: none;
  }
}
</file>

<file path="src/components/common/ChainSwitcher/index.tsx">
import type { ReactElement } from 'react'
import { useCallback, useState } from 'react'
import { Button, CircularProgress, Typography } from '@mui/material'
import { useCurrentChain } from '@/hooks/useChains'
import useOnboard from '@/hooks/wallets/useOnboard'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import { switchWalletChain } from '@/services/tx/tx-sender/sdk'

const ChainSwitcher = ({
  fullWidth,
  primaryCta = false,
}: {
  fullWidth?: boolean
  primaryCta?: boolean
}): ReactElement | null => {
  const chain = useCurrentChain()
  const onboard = useOnboard()
  const isWrongChain = useIsWrongChain()
  const [loading, setIsLoading] = useState<boolean>(false)

  const handleChainSwitch = useCallback(async () => {
    if (!onboard || !chain) return
    setIsLoading(true)
    await switchWalletChain(onboard, chain.chainId)
    setIsLoading(false)
  }, [chain, onboard])

  if (!isWrongChain) return null

  return (
    <Button
      onClick={handleChainSwitch}
      variant={primaryCta ? 'contained' : 'outlined'}
      sx={{ minWidth: '200px' }}
      size={primaryCta ? 'medium' : 'small'}
      fullWidth={fullWidth}
      color="primary"
      disabled={loading}
    >
      {loading ? (
        <CircularProgress size={20} />
      ) : (
        <>
          <Typography noWrap>Switch to&nbsp;</Typography>
          <img
            src={chain?.chainLogoUri ?? undefined}
            alt={`${chain?.chainName} Logo`}
            width={24}
            height={24}
            loading="lazy"
          />
          <Typography noWrap>&nbsp;{chain?.chainName}</Typography>
        </>
      )}
    </Button>
  )
}

export default ChainSwitcher
</file>

<file path="src/components/common/ChainSwitcher/styles.module.css">
.circle {
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  margin-left: 0.2em;
}
</file>

<file path="src/components/common/CheckWallet/index.tsx">
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { useIsWalletProposer } from '@/hooks/useProposers'
import { useMemo, type ReactElement } from 'react'
import useIsOnlySpendingLimitBeneficiary from '@/hooks/useIsOnlySpendingLimitBeneficiary'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import useWallet from '@/hooks/wallets/useWallet'
import useConnectWallet from '../ConnectWallet/useConnectWallet'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import { Tooltip } from '@mui/material'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useIsNestedSafeOwner } from '@/hooks/useIsNestedSafeOwner'

type CheckWalletProps = {
  children: (ok: boolean) => ReactElement
  allowSpendingLimit?: boolean
  allowNonOwner?: boolean
  noTooltip?: boolean
  checkNetwork?: boolean
  allowUndeployedSafe?: boolean
  allowProposer?: boolean
}

enum Message {
  WalletNotConnected = 'Please connect your wallet',
  SDKNotInitialized = 'SDK is not initialized yet',
  NotSafeOwner = 'Your connected wallet is not a signer of this Safe Account',
  SafeNotActivated = 'You need to activate the Safe before transacting',
}

const CheckWallet = ({
  children,
  allowSpendingLimit,
  allowNonOwner,
  noTooltip,
  checkNetwork = false,
  allowUndeployedSafe = false,
  allowProposer = true,
}: CheckWalletProps): ReactElement => {
  const wallet = useWallet()
  const isSafeOwner = useIsSafeOwner()
  const isOnlySpendingLimit = useIsOnlySpendingLimitBeneficiary()
  const connectWallet = useConnectWallet()
  const isWrongChain = useIsWrongChain()
  const sdk = useSafeSDK()
  const isProposer = useIsWalletProposer()

  const { safe, safeLoaded } = useSafeInfo()

  const isNestedSafeOwner = useIsNestedSafeOwner()

  const isUndeployedSafe = !safe.deployed

  const message = useMemo(() => {
    if (!wallet) {
      return Message.WalletNotConnected
    }
    if (!sdk && safeLoaded) {
      return Message.SDKNotInitialized
    }

    if (isUndeployedSafe && !allowUndeployedSafe) {
      return Message.SafeNotActivated
    }

    if (
      !allowNonOwner &&
      !isSafeOwner &&
      !isProposer &&
      !isNestedSafeOwner &&
      (!isOnlySpendingLimit || !allowSpendingLimit)
    ) {
      return Message.NotSafeOwner
    }

    if (!allowProposer && isProposer && !isSafeOwner) {
      return Message.NotSafeOwner
    }
  }, [
    allowNonOwner,
    allowProposer,
    allowSpendingLimit,
    allowUndeployedSafe,
    isProposer,
    isNestedSafeOwner,
    isOnlySpendingLimit,
    isSafeOwner,
    isUndeployedSafe,
    sdk,
    wallet,
    safeLoaded,
  ])

  if (checkNetwork && isWrongChain) return children(false)
  if (!message) return children(true)
  if (noTooltip) return children(false)

  return (
    <Tooltip title={message}>
      <span onClick={wallet ? undefined : connectWallet}>{children(false)}</span>
    </Tooltip>
  )
}

export default CheckWallet
</file>

<file path="src/components/common/CheckWalletWithPermission/index.tsx">
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { useMemo, type ReactElement } from 'react'
import useWallet from '@/hooks/wallets/useWallet'
import useConnectWallet from '../ConnectWallet/useConnectWallet'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import { Tooltip } from '@mui/material'
import useSafeInfo from '@/hooks/useSafeInfo'
import type { Permission, PermissionProps } from '@/permissions/config'
import { useHasPermission } from '@/permissions/hooks/useHasPermission'

type CheckWalletWithPermissionProps<
  P extends Permission,
  PProps = PermissionProps<P> extends undefined ? { permissionProps?: never } : { permissionProps: PermissionProps<P> },
> = {
  children: (ok: boolean) => ReactElement
  permission: P
  noTooltip?: boolean
  checkNetwork?: boolean
  allowUndeployedSafe?: boolean
} & PProps

enum Message {
  WalletNotConnected = 'Please connect your wallet',
  SDKNotInitialized = 'SDK is not initialized yet',
  NotSafeOwner = 'Your connected wallet is not a signer of this Safe Account',
  SafeNotActivated = 'You need to activate the Safe before transacting',
}

const CheckWalletWithPermission = <P extends Permission>({
  children,
  permission,
  permissionProps,
  noTooltip,
  checkNetwork = false,
  allowUndeployedSafe = false,
}: CheckWalletWithPermissionProps<P>): ReactElement => {
  const wallet = useWallet()
  const connectWallet = useConnectWallet()
  const isWrongChain = useIsWrongChain()
  const sdk = useSafeSDK()
  const hasPermission = useHasPermission(
    permission,
    ...((permissionProps ? [permissionProps] : []) as PermissionProps<P> extends undefined
      ? []
      : [props: PermissionProps<P>]),
  )

  const { safe, safeLoaded } = useSafeInfo()

  const isUndeployedSafe = !safe.deployed

  const message = useMemo(() => {
    if (!wallet) {
      return Message.WalletNotConnected
    }

    if (!sdk && safeLoaded) {
      return Message.SDKNotInitialized
    }

    if (isUndeployedSafe && !allowUndeployedSafe) {
      return Message.SafeNotActivated
    }

    if (!hasPermission) {
      return Message.NotSafeOwner
    }
  }, [allowUndeployedSafe, hasPermission, isUndeployedSafe, sdk, wallet, safeLoaded])

  if (checkNetwork && isWrongChain) return children(false)
  if (!message) return children(true)
  if (noTooltip) return children(false)

  return (
    <Tooltip title={message}>
      <span onClick={wallet ? undefined : connectWallet}>{children(false)}</span>
    </Tooltip>
  )
}

export default CheckWalletWithPermission
</file>

<file path="src/components/common/Chip/index.tsx">
import { Typography, Chip as MuiChip, type ChipProps } from '@mui/material'

type Props = {
  label?: string
  sx?: ChipProps['sx']
}

export function Chip({ sx, label = 'New' }: Props) {
  return (
    <MuiChip
      size="small"
      component="span"
      sx={{
        ...sx,
        mt: '-2px',
      }}
      label={
        <Typography
          variant="caption"
          fontWeight="bold"
          display="flex"
          alignItems="center"
          gap={1}
          letterSpacing="1px"
          component="span"
        >
          {label}
        </Typography>
      }
    />
  )
}
</file>

<file path="src/components/common/ChoiceButton/index.tsx">
import { type ElementType } from 'react'
import { Box, ButtonBase, SvgIcon, type SvgIconOwnProps, Typography } from '@mui/material'
import ChevronRightRoundedIcon from '@mui/icons-material/ChevronRightRounded'
import css from './styles.module.css'

const ChoiceButton = ({
  title,
  description,
  icon,
  iconColor,
  onClick,
  disabled,
  chip,
}: {
  title: string
  description?: string
  icon: ElementType
  iconColor?: SvgIconOwnProps['color']
  onClick: () => void
  disabled?: boolean
  chip?: string
}) => {
  return (
    <ButtonBase data-testid="choice-btn" className={css.txButton} onClick={onClick} disabled={disabled}>
      <Box
        className={css.iconBg}
        sx={{ backgroundColor: iconColor ? `var(--color-${iconColor}-background) !important` : '' }}
      >
        <SvgIcon component={icon} fontSize="small" inheritViewBox color={iconColor} />
      </Box>
      <Box
        sx={{
          py: 0.2,
        }}
      >
        <Typography
          sx={{
            fontWeight: 'bold',
          }}
        >
          {title}
        </Typography>

        {description && (
          <Typography
            variant="body2"
            sx={{
              color: 'primary.light',
            }}
          >
            {description}
          </Typography>
        )}
      </Box>
      <SvgIcon component={ChevronRightRoundedIcon} color="border" sx={{ ml: 'auto' }} />
      {chip && <Box className={css.chip}>{chip}</Box>}
    </ButtonBase>
  )
}

export default ChoiceButton
</file>

<file path="src/components/common/ChoiceButton/styles.module.css">
.txButton {
  justify-content: flex-start;
  text-align: left;
  padding: var(--space-2);
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
  width: 100%;
  color: var(--color-text-primary);
  gap: var(--space-2);
  position: relative;
}

.txButton:disabled {
  opacity: 0.5;
}

.txButton:hover {
  border-color: var(--color-primary-main);
}

.iconBg {
  background-color: var(--color-background-main);
  display: inline-flex;
  border-radius: 50%;
  padding: var(--space-1);
}

.chip {
  position: absolute;
  z-index: 1;
  top: 0;
  right: var(--space-2);
  background-color: var(--color-background-default);
  color: var(--color-primary-light);
  border-radius: 0 0 4px 4px;
  font-size: 12px;
  padding: 2px 8px;
}
</file>

<file path="src/components/common/ConnectWallet/AccountCenter.tsx">
import type { MouseEvent } from 'react'
import { useState } from 'react'
import { Box, ButtonBase, Paper, Popover } from '@mui/material'
import css from '@/components/common/ConnectWallet/styles.module.css'
import ExpandLessIcon from '@mui/icons-material/ExpandLess'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import { type ConnectedWallet } from '@/hooks/wallets/useOnboard'
import WalletOverview from '../WalletOverview'
import WalletInfo from '@/components/common/WalletInfo'

export const AccountCenter = ({ wallet }: { wallet: ConnectedWallet }) => {
  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null)
  const { balance } = wallet

  const openWalletInfo = (event: MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget)
  }

  const closeWalletInfo = () => {
    setAnchorEl(null)
  }

  const open = Boolean(anchorEl)
  const id = open ? 'simple-popover' : undefined

  return (
    <>
      <ButtonBase
        onClick={openWalletInfo}
        aria-describedby={id}
        disableRipple
        sx={{ alignSelf: 'stretch' }}
        data-testid="open-account-center"
      >
        <Box className={css.buttonContainer}>
          <WalletOverview wallet={wallet} balance={balance} showBalance />

          <Box display="flex" alignItems="center" justifyContent="flex-end" ml="auto">
            {open ? <ExpandLessIcon color="border" /> : <ExpandMoreIcon color="border" />}
          </Box>
        </Box>
      </ButtonBase>

      <Popover
        id={id}
        open={open}
        anchorEl={anchorEl}
        onClose={closeWalletInfo}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'center',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'center',
        }}
        sx={{
          '& > .MuiPaper-root': {
            top: 'var(--header-height) !important',
          },
        }}
        transitionDuration={0}
      >
        <Paper className={css.popoverContainer}>
          <WalletInfo wallet={wallet} handleClose={closeWalletInfo} balance={balance} />
        </Paper>
      </Popover>
    </>
  )
}

export default AccountCenter
</file>

<file path="src/components/common/ConnectWallet/ConnectionCenter.tsx">
import ConnectWalletButton from '@/components/common/ConnectWallet/ConnectWalletButton'
import { Box } from '@mui/material'
import { type ReactElement } from 'react'
import css from '@/components/common/ConnectWallet/styles.module.css'

const ConnectionCenter = (): ReactElement => {
  return (
    <Box className={css.buttonContainer}>
      <ConnectWalletButton small={true} />
    </Box>
  )
}

export default ConnectionCenter
</file>

<file path="src/components/common/ConnectWallet/ConnectWalletButton.tsx">
import { Button } from '@mui/material'
import useConnectWallet from '@/components/common/ConnectWallet/useConnectWallet'

const ConnectWalletButton = ({
  onConnect,
  contained = true,
  small = false,
  text,
}: {
  onConnect?: () => void
  contained?: boolean
  small?: boolean
  text?: string
}): React.ReactElement => {
  const connectWallet = useConnectWallet()

  const handleConnect = () => {
    onConnect?.()
    connectWallet()
  }

  return (
    <Button
      data-testid="connect-wallet-btn"
      onClick={handleConnect}
      variant={contained ? 'contained' : 'text'}
      size={small ? 'small' : 'medium'}
      disableElevation
      fullWidth
      sx={{ fontSize: small ? ['12px', '13px'] : '' }}
    >
      {text || 'Connect'}
    </Button>
  )
}

export default ConnectWalletButton
</file>

<file path="src/components/common/ConnectWallet/index.tsx">
import type { ReactElement } from 'react'
import useWallet from '@/hooks/wallets/useWallet'
import AccountCenter from '@/components/common/ConnectWallet/AccountCenter'
import ConnectionCenter from './ConnectionCenter'

const ConnectWallet = (): ReactElement => {
  const wallet = useWallet()

  return wallet ? <AccountCenter wallet={wallet} /> : <ConnectionCenter />
}

export default ConnectWallet
</file>

<file path="src/components/common/ConnectWallet/styles.module.css">
.connectedContainer {
  display: flex;
  align-items: center;
}

.buttonContainer {
  display: flex;
  align-items: center;
  text-align: left;
  gap: var(--space-1);
  padding: 0 var(--space-2);
}

.popoverContainer {
  padding: var(--space-2);
  width: 300px;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.largeGap {
  gap: var(--space-2);
}

.addressName {
  text-align: center;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  width: 100%;
}

.profileImg {
  border-radius: var(--space-2);
  width: 32px;
  height: 32px;
}

.profileData {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.address {
  height: 40px;
}

.address div[title] {
  font-weight: bold;
}

.rowContainer {
  align-self: stretch;
  border: 1px solid var(--color-border-light);
  border-radius: 4px;
}

.row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--color-border-light);
  padding: 12px;
  margin-top: -2px;
}

.row:first-of-type {
  border: 0;
}

.loginButton {
  min-height: 42px;
}

.loginError {
  width: 100%;
  margin: 0;
}

@media (max-width: 599.95px) {
  .notConnected {
    display: none;
  }
}
</file>

<file path="src/components/common/ConnectWallet/useConnectWallet.ts">
import { useCallback } from 'react'
import useOnboard, { connectWallet } from '@/hooks/wallets/useOnboard'

const useConnectWallet = () => {
  const onboard = useOnboard()

  return useCallback(() => {
    if (!onboard) {
      return Promise.resolve(undefined)
    }

    return connectWallet(onboard)
  }, [onboard])
}

export default useConnectWallet
</file>

<file path="src/components/common/ContextMenu/index.tsx">
import React from 'react'
import { Menu, type MenuProps } from '@mui/material'

import css from './styles.module.css'

const ContextMenu = (props: MenuProps) => <Menu className={css.menu} {...props} />

export default ContextMenu
</file>

<file path="src/components/common/ContextMenu/styles.module.css">
.menu :global .MuiPaper-root {
  border-radius: 8px !important;
}

.menu :global .MuiList-root {
  padding: 4px;
}

.menu :global .MuiMenuItem-root {
  padding-left: 12px;
  min-height: 40px;
  border-radius: 8px !important;
}

.menu :global .MuiMenuItem-root:hover {
  background-color: var(--color-secondary-background);
}

.menu :global .MuiListItemIcon-root {
  min-width: 26px;
}
</file>

<file path="src/components/common/CookieAndTermBanner/index.tsx">
import { useEffect, type ReactElement } from 'react'
import classnames from 'classnames'
import type { CheckboxProps } from '@mui/material'
import { Grid, Button, Checkbox, FormControlLabel, Typography, Paper, SvgIcon, Box } from '@mui/material'
import WarningIcon from '@/public/images/notifications/warning.svg'
import { useForm } from 'react-hook-form'
import * as metadata from '@/markdown/terms/version'

import { useAppDispatch, useAppSelector } from '@/store'
import {
  selectCookies,
  CookieAndTermType,
  saveCookieAndTermConsent,
  hasAcceptedTerms,
} from '@/store/cookiesAndTermsSlice'
import { selectCookieBanner, openCookieBanner, closeCookieBanner } from '@/store/popupSlice'

import css from './styles.module.css'
import { AppRoutes } from '@/config/routes'
import ExternalLink from '../ExternalLink'

const COOKIE_AND_TERM_WARNING: Record<CookieAndTermType, string> = {
  [CookieAndTermType.TERMS]: '',
  [CookieAndTermType.NECESSARY]: '',
  [CookieAndTermType.UPDATES]: `You attempted to open the "What's new" section but need to accept the "Beamer" cookies first.`,
  [CookieAndTermType.ANALYTICS]: '',
}

const CookieCheckbox = ({
  checkboxProps,
  label,
  checked,
}: {
  label: string
  checked: boolean
  checkboxProps: CheckboxProps
}) => <FormControlLabel label={label} checked={checked} control={<Checkbox {...checkboxProps} />} sx={{ mt: '-9px' }} />

export const CookieAndTermBanner = ({
  warningKey,
  inverted,
}: {
  warningKey?: CookieAndTermType
  inverted?: boolean
}): ReactElement => {
  const warning = warningKey ? COOKIE_AND_TERM_WARNING[warningKey] : undefined
  const dispatch = useAppDispatch()
  const cookies = useAppSelector(selectCookies)

  const { register, watch, getValues, setValue } = useForm({
    defaultValues: {
      [CookieAndTermType.TERMS]: true,
      [CookieAndTermType.NECESSARY]: true,
      [CookieAndTermType.UPDATES]: cookies[CookieAndTermType.UPDATES] ?? false,
      [CookieAndTermType.ANALYTICS]: cookies[CookieAndTermType.ANALYTICS] ?? false,
      ...(warningKey ? { [warningKey]: true } : {}),
    },
  })

  const handleAccept = () => {
    const values = getValues()
    dispatch(
      saveCookieAndTermConsent({
        ...values,
        termsVersion: metadata.version,
      }),
    )
    dispatch(closeCookieBanner())
  }

  const handleAcceptAll = () => {
    setValue(CookieAndTermType.UPDATES, true)
    setValue(CookieAndTermType.ANALYTICS, true)
    setTimeout(handleAccept, 300)
  }

  return (
    <Paper data-testid="cookies-popup" className={classnames(css.container, { [css.inverted]: inverted })}>
      {warning && (
        <Typography
          align="center"
          variant="body2"
          sx={{
            mb: 2,
            color: 'warning.background',
          }}
        >
          <SvgIcon component={WarningIcon} inheritViewBox fontSize="small" color="error" sx={{ mb: -0.4 }} /> {warning}
        </Typography>
      )}
      <form>
        <Grid
          container
          sx={{
            alignItems: 'center',
          }}
        >
          <Grid item xs>
            <Typography
              variant="body2"
              sx={{
                mb: 2,
              }}
            >
              By browsing this page, you accept our{' '}
              <ExternalLink href={AppRoutes.terms}>Terms & Conditions</ExternalLink> (last updated{' '}
              {metadata.lastUpdated}) and the use of necessary cookies. By clicking &quot;Accept all&quot; you
              additionally agree to the use of Beamer and Analytics cookies as listed below.{' '}
              <ExternalLink href={AppRoutes.cookie}>Cookie policy</ExternalLink>
            </Typography>

            <Grid
              container
              sx={{
                alignItems: 'center',
                gap: 4,
              }}
            >
              <Grid item xs={12} sm>
                <Box
                  sx={{
                    mb: 2,
                  }}
                >
                  <CookieCheckbox checkboxProps={{ id: 'necessary', disabled: true }} label="Necessary" checked />
                  <br />
                  <Typography variant="body2">Locally stored data for core functionality</Typography>
                </Box>

                <Box
                  sx={{
                    mb: 2,
                  }}
                >
                  <CookieCheckbox
                    checkboxProps={{ ...register(CookieAndTermType.UPDATES), id: 'beamer' }}
                    label="Beamer"
                    checked={watch(CookieAndTermType.UPDATES)}
                  />
                  <br />
                  <Typography variant="body2">New features and product announcements</Typography>
                </Box>

                <Box>
                  <CookieCheckbox
                    checkboxProps={{ ...register(CookieAndTermType.ANALYTICS), id: 'ga' }}
                    label="Analytics"
                    checked={watch(CookieAndTermType.ANALYTICS)}
                  />
                  <br />
                  <Typography variant="body2">
                    Opt in for Google Analytics cookies to help us analyze app usage patterns.
                  </Typography>
                </Box>
              </Grid>
            </Grid>

            <Grid
              container
              sx={{
                alignItems: 'center',
                justifyContent: 'center',
                mt: 4,
                gap: 2,
              }}
            >
              <Grid item>
                <Typography>
                  <Button onClick={handleAccept} variant="text" size="small" color="inherit" disableElevation>
                    Save settings
                  </Button>
                </Typography>
              </Grid>

              <Grid item>
                <Button onClick={handleAcceptAll} variant="contained" color="secondary" size="small" disableElevation>
                  Accept all
                </Button>
              </Grid>
            </Grid>
          </Grid>
        </Grid>
      </form>
    </Paper>
  )
}

const CookieBannerPopup = (): ReactElement | null => {
  const cookiePopup = useAppSelector(selectCookieBanner)
  const dispatch = useAppDispatch()

  const hasAccepted = useAppSelector(hasAcceptedTerms)
  const shouldOpen = !hasAccepted

  useEffect(() => {
    if (shouldOpen) {
      dispatch(openCookieBanner({}))
    } else {
      dispatch(closeCookieBanner())
    }
  }, [dispatch, shouldOpen])

  return cookiePopup.open ? (
    <div className={css.popup}>
      <CookieAndTermBanner warningKey={cookiePopup.warningKey} inverted />
    </div>
  ) : null
}
export default CookieBannerPopup
</file>

<file path="src/components/common/CookieAndTermBanner/styles.module.css">
.popup {
  position: fixed;
  z-index: 1300;
  bottom: var(--space-2);
  right: var(--space-2);
  max-width: 400px;
}

.container {
  padding: var(--space-2);
  border-radius: 0 !important;
}

.container label,
.container input {
  user-select: none;
}

@media (max-width: 599.95px) {
  .popup {
    right: 0;
    bottom: 0;
  }
}

.container.inverted {
  background: var(--color-text-primary);
}

.container.inverted,
.container.inverted :global(.MuiCheckbox-root),
.container.inverted a {
  color: var(--color-background-paper);
}

.container.inverted :global(.Mui-checked) {
  color: var(--color-background-paper);
}

.container.inverted :global(.Mui-checked.Mui-disabled) {
  opacity: 0.5;
}
</file>

<file path="src/components/common/CooldownButton/index.tsx">
import { Button } from '@mui/material'
import { useState, useCallback, useEffect, type ReactNode } from 'react'

// TODO: Extract into a hook so it can be reused for links and not just buttons
const CooldownButton = ({
  onClick,
  cooldown,
  startDisabled = false,
  children,
}: {
  onClick: () => void
  startDisabled?: boolean
  cooldown: number // Cooldown in seconds
  children: ReactNode
}) => {
  const [remainingSeconds, setRemainingSeconds] = useState(startDisabled ? cooldown : 0)
  const [lastSendTime, setLastSendTime] = useState(startDisabled ? Date.now() : 0)

  const adjustSeconds = useCallback(() => {
    const remainingCoolDownSeconds = Math.max(0, cooldown * 1000 - (Date.now() - lastSendTime)) / 1000
    setRemainingSeconds(remainingCoolDownSeconds)
  }, [cooldown, lastSendTime])

  useEffect(() => {
    // Counter for progress
    const interval = setInterval(adjustSeconds, 1000)
    return () => clearInterval(interval)
  }, [adjustSeconds])

  const handleClick = () => {
    setLastSendTime(Date.now())
    setRemainingSeconds(cooldown)
    onClick()
  }

  const isDisabled = remainingSeconds > 0

  return (
    <Button onClick={handleClick} variant="contained" size="small" disabled={isDisabled}>
      <span>
        {children}
        {remainingSeconds > 0 && ` in ${Math.floor(remainingSeconds)}s`}
      </span>
    </Button>
  )
}

export default CooldownButton
</file>

<file path="src/components/common/CopyAddressButton/index.tsx">
import { checksumAddress } from '@safe-global/utils/utils/addresses'
import { Box, Typography } from '@mui/material'
import type { ReactNode, ReactElement } from 'react'
import CopyButton from '../CopyButton'
import EthHashInfo from '../EthHashInfo'

const CopyAddressButton = ({
  prefix,
  address,
  copyPrefix,
  children,
  trusted = true,
}: {
  prefix?: string
  address: string
  copyPrefix?: boolean
  children?: ReactNode
  trusted?: boolean
}): ReactElement => {
  const addressText = copyPrefix && prefix ? `${prefix}:${address}` : address

  const checksummedAddress = checksumAddress(address)

  const dialogContent = trusted ? undefined : (
    <Box display="flex" flexDirection="column" gap={2}>
      <EthHashInfo
        address={checksummedAddress}
        shortAddress={false}
        copyAddress={false}
        showCopyButton={false}
        hasExplorer
      />
      <Typography>
        The copied address is linked to a transaction with an untrusted token. Make sure you are interacting with the
        right address.
      </Typography>
    </Box>
  )

  return (
    <CopyButton text={addressText} dialogContent={dialogContent}>
      {children}
    </CopyButton>
  )
}

export default CopyAddressButton
</file>

<file path="src/components/common/CopyButton/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import CopyButton from './index'
const meta = {
  component: CopyButton,
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
} satisfies Meta<typeof CopyButton>

export default meta
type Story = StoryObj<typeof meta>

// More on writing stories with args: https://storybook.js.org/docs/writing-stories/args
export const Default: Story = {
  args: {
    text: 'Copy',
  },
}
</file>

<file path="src/components/common/CopyButton/index.tsx">
import type { ReactNode } from 'react'
import React, { type ReactElement } from 'react'
import CopyIcon from '@/public/images/common/copy.svg'
import { IconButton, SvgIcon } from '@mui/material'
import CopyTooltip from '../CopyTooltip'

export interface ButtonProps {
  text: string
  className?: string
  children?: ReactNode
  initialToolTipText?: string
  ariaLabel?: string
  onCopy?: () => void
  dialogContent?: ReactElement
}

const CopyButton = ({
  text,
  className,
  children,
  initialToolTipText = 'Copy to clipboard',
  onCopy,
  dialogContent,
}: ButtonProps): ReactElement => {
  return (
    <CopyTooltip text={text} onCopy={onCopy} initialToolTipText={initialToolTipText} dialogContent={dialogContent}>
      {children ?? (
        <IconButton aria-label={initialToolTipText} size="small" className={className}>
          <SvgIcon data-testid="copy-btn-icon" component={CopyIcon} inheritViewBox color="border" fontSize="small" />
        </IconButton>
      )}
    </CopyTooltip>
  )
}

export default CopyButton
</file>

<file path="src/components/common/CopyTooltip/ConfirmCopyModal.tsx">
import { Close } from '@mui/icons-material'
import {
  Dialog,
  DialogTitle,
  SvgIcon,
  Typography,
  IconButton,
  Divider,
  DialogContent,
  DialogActions,
  Button,
  Box,
} from '@mui/material'
import WarningIcon from '@/public/images/notifications/warning.svg'
import { type ReactElement, useEffect, type SyntheticEvent } from 'react'
import { trackEvent, TX_LIST_EVENTS } from '@/services/analytics'
import Track from '../Track'

import css from './styles.module.css'

export type ConfirmCopyModalProps = {
  open: boolean
  onClose: () => void
  onCopy: { (e: SyntheticEvent): void }
  children: ReactElement
}

const ConfirmCopyModal = ({ open, onClose, onCopy, children }: ConfirmCopyModalProps) => {
  useEffect(() => {
    if (open) {
      trackEvent(TX_LIST_EVENTS.COPY_WARNING_SHOWN)
    }
  }, [open])

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>
        <Box data-testid="untrusted-token-warning" display="flex" flexDirection="row" alignItems="center" gap={1}>
          <SvgIcon component={WarningIcon} inheritViewBox color="warning" sx={{ mb: -0.4 }} />
          <Typography variant="h6" fontWeight={700}>
            Before you copy
          </Typography>
          <IconButton aria-label="close" onClick={onClose} sx={{ marginLeft: 'auto' }}>
            <Close />
          </IconButton>
        </Box>
      </DialogTitle>
      <Divider />
      <DialogContent>{children}</DialogContent>
      <Divider />
      <DialogActions sx={{ padding: 3 }}>
        <Box className={css.dialogActions} gap={1}>
          <Track {...TX_LIST_EVENTS.COPY_WARNING_PROCEED}>
            <Button size="small" variant="text" color="primary" onClick={onCopy} fullWidth>
              Proceed and copy
            </Button>
          </Track>
          <Track {...TX_LIST_EVENTS.COPY_WARNING_CLOSE}>
            <Button size="small" variant="contained" color="primary" onClick={onClose} fullWidth>
              Do not copy
            </Button>
          </Track>
        </Box>
      </DialogActions>
    </Dialog>
  )
}

export default ConfirmCopyModal
</file>

<file path="src/components/common/CopyTooltip/index.tsx">
import type { ReactNode } from 'react'
import React, { type ReactElement, type SyntheticEvent, useCallback, useState } from 'react'
import { Tooltip } from '@mui/material'
import ConfirmCopyModal from './ConfirmCopyModal'

const spanStyle = { cursor: 'pointer' }

const CopyTooltip = ({
  text,
  children,
  initialToolTipText = 'Copy to clipboard',
  onCopy,
  dialogContent,
}: {
  text: string
  children?: ReactNode
  initialToolTipText?: string
  onCopy?: () => void
  dialogContent?: ReactElement
}): ReactElement => {
  const [tooltipText, setTooltipText] = useState(initialToolTipText)
  const [showTooltip, setShowTooltip] = useState(false)
  const [isCopyEnabled, setIsCopyEnabled] = useState(true)
  const [showConfirmation, setShowConfirmation] = useState(false)

  const handleCopy = useCallback(
    (e: SyntheticEvent) => {
      e.preventDefault()
      e.stopPropagation()

      if (dialogContent && !showConfirmation) {
        setShowConfirmation(true)
        return
      }
      let timeout: NodeJS.Timeout | undefined

      try {
        navigator.clipboard.writeText(text).then(() => setTooltipText('Copied'))
        setShowConfirmation(false)
        setShowTooltip(true)
        timeout = setTimeout(() => {
          if (isCopyEnabled) {
            setShowTooltip(false)
            setTooltipText(initialToolTipText)
          }
        }, 750)
        onCopy?.()
      } catch (err) {
        setIsCopyEnabled(false)
        setTooltipText('Copying is disabled in your browser')
      }

      return () => clearTimeout(timeout)
    },
    [dialogContent, showConfirmation, text, onCopy, isCopyEnabled, initialToolTipText],
  )

  return (
    <>
      <Tooltip
        title={tooltipText}
        open={showTooltip}
        onOpen={() => setShowTooltip(true)}
        onClose={() => setShowTooltip(false)}
        placement="top"
        TransitionProps={{
          // Otherwise the initialToolTipText is briefly visible during the exit animation
          exit: false,
        }}
      >
        <span onClick={handleCopy} style={spanStyle}>
          {children}
        </span>
      </Tooltip>
      {dialogContent !== undefined && (
        <ConfirmCopyModal onClose={() => setShowConfirmation(false)} onCopy={handleCopy} open={showConfirmation}>
          {dialogContent}
        </ConfirmCopyModal>
      )}
    </>
  )
}

export default CopyTooltip
</file>

<file path="src/components/common/CopyTooltip/styles.module.css">
.dialogActions {
  display: flex;
  flex-direction: row;
  align-items: center;
}

@media (max-width: 599.95px) {
  .dialogActions {
    flex-direction: column;
    width: 100%;
  }
  .dialogActions > span {
    width: 100%;
  }
}
</file>

<file path="src/components/common/Countdown/index.tsx">
import { Typography, Box } from '@mui/material'
import type { ReactElement } from 'react'

export function _getCountdown(seconds: number): { days: number; hours: number; minutes: number } {
  const MINUTE_IN_SECONDS = 60
  const HOUR_IN_SECONDS = 60 * MINUTE_IN_SECONDS
  const DAY_IN_SECONDS = 24 * HOUR_IN_SECONDS

  const days = Math.floor(seconds / DAY_IN_SECONDS)

  const remainingSeconds = seconds % DAY_IN_SECONDS
  const hours = Math.floor(remainingSeconds / HOUR_IN_SECONDS)
  const minutes = Math.floor((remainingSeconds % HOUR_IN_SECONDS) / MINUTE_IN_SECONDS)

  return { days, hours, minutes }
}

export function Countdown({ seconds }: { seconds: number }): ReactElement | null {
  if (seconds <= 0) {
    return null
  }

  if (seconds <= 60) {
    return (
      <Typography fontWeight={700} component="span">
        {'< 1 min'}
      </Typography>
    )
  }

  const { days, hours, minutes } = _getCountdown(seconds)

  return (
    <Box display="flex" gap={1}>
      <TimeLeft value={days} unit="day" />
      <TimeLeft value={hours} unit="hr" />
      <TimeLeft value={minutes} unit="min" />
    </Box>
  )
}

function TimeLeft({ value, unit }: { value: number; unit: string }): ReactElement | null {
  if (value === 0) {
    return null
  }

  return (
    <div>
      <Typography fontWeight={700} component="span">
        {value}
      </Typography>{' '}
      <Typography color="primary.light" component="span">
        {value === 1 ? unit : `${unit}s`}
      </Typography>
    </div>
  )
}
</file>

<file path="src/components/common/CustomLink/index.tsx">
import MUILink from '@mui/material/Link'
import type { LinkProps as MUILinkProps } from '@mui/material/Link/Link'
import type { LinkProps as NextLinkProps } from 'next/dist/client/link'
import NextLink from 'next/link'

const CustomLink: React.FC<
  React.PropsWithChildren<Omit<MUILinkProps, 'href'> & Pick<NextLinkProps, 'href' | 'as'>>
> = ({ href = '', as, children, ...other }) => {
  const isExternal = href.toString().startsWith('http')
  return (
    <NextLink href={href} as={as} passHref legacyBehavior>
      <MUILink target={isExternal ? '_blank' : ''} rel="noreferrer" {...other}>
        {children}
      </MUILink>
    </NextLink>
  )
}

export default CustomLink
</file>

<file path="src/components/common/CustomTooltip/index.tsx">
import { styled } from '@mui/material/styles'
import Tooltip, { tooltipClasses } from '@mui/material/Tooltip'
import { type TooltipProps } from '@mui/material/Tooltip'

export const CustomTooltip = styled(({ className, ...props }: TooltipProps) => (
  <Tooltip {...props} classes={{ popper: className }} arrow />
))(({ theme }) => ({
  [`& .${tooltipClasses.tooltip}`]: {
    backgroundColor: theme.palette.background.paper,
    color: theme.palette.text.primary,
    fontSize: theme.typography.pxToRem(16),
    fontWeight: 700,
    border: `1px solid ${theme.palette.border.light}`,
    marginTop: theme.spacing(2) + ' !important',
  },
  [`& .${tooltipClasses.arrow}`]: {
    color: theme.palette.background.paper,
  },
  [`& .${tooltipClasses.arrow}:before`]: {
    border: `1px solid ${theme.palette.border.light}`,
  },
}))
</file>

<file path="src/components/common/DatePickerInput/index.tsx">
import { useFormContext, Controller } from 'react-hook-form'
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider'
import { DatePicker } from '@mui/x-date-pickers/DatePicker'
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns'
import { isFuture, isValid, startOfDay } from 'date-fns'

import inputCss from '@/styles/inputs.module.css'

const DatePickerInput = ({
  name,
  label,
  deps,
  disableFuture = true,
  validate,
}: {
  name: string
  label: string
  deps?: string[]
  disableFuture?: boolean
  validate?: (value: Date | null) => string | undefined
}) => {
  const { control } = useFormContext()

  return (
    <Controller
      name={name}
      control={control}
      rules={{
        deps,
        validate: (val) => {
          if (!val) {
            return
          }

          if (!isValid(val)) {
            return 'Invalid date'
          }

          // Compare days using `startOfDay` to ignore timezone offset
          if (disableFuture && isFuture(startOfDay(val))) {
            return 'Date cannot be in the future'
          }

          return validate?.(val)
        },
      }}
      render={({ field, fieldState }) => (
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DatePicker
            className={inputCss.input}
            label={label}
            format="dd/MM/yyyy"
            {...field}
            disableFuture={disableFuture}
            slotProps={{
              textField: { fullWidth: true, label: fieldState.error?.message || label, error: !!fieldState.error },
            }}
          />
        </LocalizationProvider>
      )}
    />
  )
}

export default DatePickerInput
</file>

<file path="src/components/common/DateTime/DateTime.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { DateTime } from './DateTime'

const meta = {
  component: DateTime,
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
} satisfies Meta<typeof DateTime>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    value: 1712552729000,
    showDateTime: true,
    showTime: true,
  },
}
</file>

<file path="src/components/common/DateTime/DateTime.tsx">
import type { ReactElement } from 'react'
import { Tooltip } from '@mui/material'
import { formatDateTime, formatTime, formatTimeInWords } from '@safe-global/utils/utils/date'

type DateTimeProps = {
  value: number
  showDateTime: boolean
  showTime: boolean
}

export const DateTime = ({ value, showDateTime, showTime }: DateTimeProps): ReactElement => {
  const showTooltip = !showDateTime || showTime

  return (
    <Tooltip title={showTooltip && formatDateTime(value)} placement="top">
      <span>{showTime ? formatTime(value) : showDateTime ? formatDateTime(value) : formatTimeInWords(value)}</span>
    </Tooltip>
  )
}
</file>

<file path="src/components/common/DateTime/DateTimeContainer.tsx">
import type { ReactElement } from 'react'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import { useTxFilter } from '@/utils/tx-history-filter'
import { DateTime } from './DateTime'

const DAYS_THRESHOLD = 60

/**
 * If queue, show relative time until threshold then show full date and time
 * If history, show time (as date labels are present)
 * If filter, show full date and time
 */

const DateTimeContainer = ({ value }: { value: number }): ReactElement => {
  const [filter] = useTxFilter()
  const router = useRouter()

  // (non-filtered) history is the endpoint that returns date labels
  const showTime = router.pathname === AppRoutes.transactions.history && !filter

  const isOld = Math.floor((Date.now() - value) / 1000 / 60 / 60 / 24) > DAYS_THRESHOLD

  return <DateTime value={value} showDateTime={isOld} showTime={showTime} />
}

export default DateTimeContainer
</file>

<file path="src/components/common/DateTime/index.tsx">
import DateTimeContainer from './DateTimeContainer'

export default DateTimeContainer
</file>

<file path="src/components/common/Disclaimer/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import Disclaimer from './index'
import LegalDisclaimerContent from '@/components/common/LegalDisclaimerContent'

const meta = {
  component: Disclaimer,
  parameters: {
    componentSubtitle: 'Renders a Block for displaying information to the user, with a button to accept.',
  },
  tags: ['autodocs'],
} satisfies Meta<typeof Disclaimer>

export default meta
type Story = StoryObj<typeof meta>

export const BlockedAddress: Story = {
  args: {
    subtitle: '0xD3a484faEa53313eF85b5916C9302a3E304ae622',
    title: 'Blocked Address',
    content:
      'This signer address is blocked by the Safe interface, due to being associated with the blocked activities by the U.S. Department of Treasury in the Specially Designated Nationals (SDN) list.',
    onAccept: () => {},
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?node-id=6167%3A14371&mode=dev',
    },
  },
}

export const LegalDisclaimer: Story = {
  args: {
    title: 'Legal Disclaimer',
    content: <LegalDisclaimerContent withTitle={false} />,
    buttonText: 'Continue',
    onAccept: () => {},
  },
}
</file>

<file path="src/components/common/Disclaimer/index.tsx">
import type { ReactElement, ReactNode } from 'react'
import { Box, Button, Divider, Paper, Stack, SvgIcon, Typography } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import css from './styles.module.css'

export const Disclaimer = ({
  title,
  subtitle,
  buttonText,
  content,
  onAccept,
}: {
  title: string
  subtitle?: string
  buttonText?: string
  content: ReactNode
  onAccept: () => void
}): ReactElement => {
  return (
    <div className={css.container}>
      <Paper sx={{ maxWidth: '500px' }}>
        <Stack
          sx={[
            {
              padding: 'var(--space-3)',
              gap: 2,
              display: 'flex',
              alignItems: 'center',
            },
            ({ palette }) => ({ borderBottom: `1px solid ${palette.border.light}` }),
          ]}
        >
          {subtitle && (
            <Typography
              sx={{
                color: 'var(--color-text-secondary)',
              }}
            >
              {subtitle}
            </Typography>
          )}

          <Box className={css.iconCircle}>
            <SvgIcon component={InfoIcon} inheritViewBox fontSize="medium" />
          </Box>
          <Typography
            variant="h3"
            sx={{
              fontWeight: 700,
            }}
          >
            {title}
          </Typography>
          <Typography variant="body2">{content}</Typography>
          <Divider />
        </Stack>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'center',
            pt: 3,
            pb: 2,
          }}
        >
          <Button variant="contained" size="small" sx={{ px: '16px' }} onClick={onAccept}>
            {buttonText || 'Got it'}
          </Button>
        </Box>
      </Paper>
    </div>
  )
}

export default Disclaimer
</file>

<file path="src/components/common/Disclaimer/styles.module.css">
.container {
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.iconCircle {
  color: var(--color-info-main);
  border-radius: 50%;
  display: flex;
  padding: var(--space-1);
  background: #d7f6ff;
}
</file>

<file path="src/components/common/EnhancedTable/index.tsx">
import type { ChangeEvent, ReactNode } from 'react'
import React, { useState } from 'react'
import Box from '@mui/material/Box'
import Table from '@mui/material/Table'
import TableBody from '@mui/material/TableBody'
import type { SortDirection } from '@mui/material/TableCell'
import TableCell from '@mui/material/TableCell'
import TableContainer from '@mui/material/TableContainer'
import TableHead from '@mui/material/TableHead'
import TablePagination from '@mui/material/TablePagination'
import TableRow from '@mui/material/TableRow'
import TableSortLabel from '@mui/material/TableSortLabel'
import Paper from '@mui/material/Paper'
import { visuallyHidden } from '@mui/utils'
import classNames from 'classnames'

import css from './styles.module.css'
import { Collapse } from '@mui/material'

type EnhancedCell = {
  content: ReactNode
  rawValue: string | number | null
  sticky?: boolean
}

type EnhancedRow = {
  selected?: boolean
  collapsed?: boolean
  key?: string
  cells: Record<string, EnhancedCell>
}

type EnhancedHeadCell = {
  id: string
  label: ReactNode
  width?: string
  align?: string
  sticky?: boolean
}

function descendingComparator(a: string | number, b: string | number) {
  if (b < a) {
    return -1
  }
  if (b > a) {
    return 1
  }
  return 0
}

function getComparator(order: SortDirection, orderBy: string) {
  return (a: EnhancedRow, b: EnhancedRow) => {
    const aValue = a.cells[orderBy].rawValue
    const bValue = b.cells[orderBy].rawValue

    // Handle null/undefined values - always sort to end
    if (aValue == null) return 1
    if (bValue == null) return -1
    if (aValue == null && bValue == null) return 0

    // Use existing comparator for non-null values
    return order === 'desc' ? descendingComparator(aValue, bValue) : -descendingComparator(aValue, bValue)
  }
}

type EnhancedTableHeadProps = {
  headCells: EnhancedHeadCell[]
  onRequestSort: (property: string) => void
  order: 'asc' | 'desc'
  orderBy: string
}

function EnhancedTableHead(props: EnhancedTableHeadProps) {
  const { headCells, order, orderBy, onRequestSort } = props
  const createSortHandler = (property: string) => () => {
    onRequestSort(property)
  }

  return (
    <TableHead>
      <TableRow>
        {headCells.map((headCell) => (
          <TableCell
            key={headCell.id}
            align="left"
            padding="normal"
            sortDirection={orderBy === headCell.id ? order : false}
            sx={{
              width: headCell.width ? headCell.width : '',
              textAlign: headCell.align ? headCell.align : '',
            }}
            className={classNames({ sticky: headCell.sticky })}
          >
            {headCell.label && (
              <>
                <TableSortLabel
                  active={orderBy === headCell.id}
                  direction={orderBy === headCell.id ? order : 'asc'}
                  onClick={createSortHandler(headCell.id)}
                  sx={{ mr: [0, '-26px'], textWrap: 'nowrap' }}
                >
                  {headCell.label}
                  {orderBy === headCell.id ? (
                    <Box component="span" sx={visuallyHidden}>
                      {order === 'desc' ? 'sorted descending' : 'sorted ascending'}
                    </Box>
                  ) : null}
                </TableSortLabel>
              </>
            )}
          </TableCell>
        ))}
      </TableRow>
    </TableHead>
  )
}

export type EnhancedTableProps = {
  rows: EnhancedRow[]
  headCells: EnhancedHeadCell[]
  mobileVariant?: boolean
}

const pageSizes = [10, 25, 100]

function EnhancedTable({ rows, headCells, mobileVariant }: EnhancedTableProps) {
  const [order, setOrder] = useState<'asc' | 'desc'>('asc')
  const [orderBy, setOrderBy] = useState<string>('')
  const [page, setPage] = useState<number>(0)
  const [rowsPerPage, setRowsPerPage] = useState<number>(pageSizes[1])

  const handleRequestSort = (property: string) => {
    const isAsc = orderBy === property && order === 'asc'
    setOrder(isAsc ? 'desc' : 'asc')
    setOrderBy(property)
  }

  const handleChangePage = (_: any, newPage: number) => {
    setPage(newPage)
  }

  const handleChangeRowsPerPage = (event: ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10))
    setPage(0)
  }

  const orderedRows = orderBy ? rows.slice().sort(getComparator(order, orderBy)) : rows
  const pagedRows = orderedRows.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)

  return (
    <Box sx={{ width: '100%' }}>
      <TableContainer data-testid="table-container" component={Paper} sx={{ width: '100%', mb: 2 }}>
        <Table aria-labelledby="tableTitle" className={mobileVariant ? css.mobileColumn : undefined}>
          <EnhancedTableHead headCells={headCells} order={order} orderBy={orderBy} onRequestSort={handleRequestSort} />
          <TableBody>
            {pagedRows.length > 0 ? (
              pagedRows.map((row, index) => (
                <TableRow
                  data-testid="table-row"
                  tabIndex={-1}
                  key={row.key ?? index}
                  selected={row.selected}
                  className={row.collapsed ? css.collapsedRow : undefined}
                >
                  {Object.entries(row.cells).map(([key, cell]) => (
                    <TableCell
                      key={key}
                      className={classNames({
                        sticky: cell.sticky,
                        [css.collapsedCell]: row.collapsed,
                      })}
                    >
                      <Collapse key={index} in={!row.collapsed} enter={false}>
                        {cell.content}
                      </Collapse>
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              // Prevent no `tbody` rows hydration error
              <TableRow>
                <TableCell />
              </TableRow>
            )}
          </TableBody>
        </Table>
      </TableContainer>

      {rows.length > pagedRows.length && (
        <TablePagination
          data-testid="table-pagination"
          rowsPerPageOptions={pageSizes}
          component="div"
          count={rows.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
        />
      )}
    </Box>
  )
}

export default EnhancedTable
</file>

<file path="src/components/common/EnhancedTable/styles.module.css">
.tableCell {
  transition: padding 0s;
}

.collapsedCell {
  padding: 0px !important;
  transition: padding 300ms ease-in-out;
}

.collapsedRow {
  border-bottom: none !important;
}

.actions {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  gap: var(--space-1);
}

@media (max-width: 899.95px) {
  .mobileColumn thead th {
    display: none;
  }

  .mobileColumn thead th:first-of-type {
    display: block;
  }

  .mobileColumn tbody td {
    display: block;
    padding-left: var(--space-2) !important;
    background: inherit;
  }
}
</file>

<file path="src/components/common/ErrorBoundary/index.tsx">
import { Typography, Link } from '@mui/material'

import { HELP_CENTER_URL, IS_PRODUCTION } from '@/config/constants'
import { AppRoutes } from '@/config/routes'
import WarningIcon from '@/public/images/notifications/warning.svg'

import css from '@/components/common/ErrorBoundary/styles.module.css'
import CircularIcon from '../icons/CircularIcon'
import ExternalLink from '../ExternalLink'
interface ErrorBoundaryProps {
  error: Error
  componentStack: string
}

const ErrorBoundary = ({ error, componentStack }: ErrorBoundaryProps) => {
  return (
    <div className={css.container}>
      <div className={css.wrapper}>
        <Typography
          variant="h3"
          sx={{
            color: 'text.primary',
          }}
        >
          Something went wrong,
          <br />
          please try again.
        </Typography>

        <CircularIcon icon={WarningIcon} badgeColor="warning" />

        {IS_PRODUCTION ? (
          <Typography
            sx={{
              color: 'text.primary',
            }}
          >
            In case the problem persists, please reach out to us via our{' '}
            <ExternalLink href={HELP_CENTER_URL}>Help Center</ExternalLink>
          </Typography>
        ) : (
          <>
            {/* Error may be undefined despite what the type says */}
            <Typography color="error">{error?.toString()}</Typography>
            <Typography color="error">{componentStack}</Typography>
          </>
        )}
        <Link
          href={AppRoutes.welcome.index}
          color="primary"
          sx={{
            mt: 2,
          }}
        >
          Go home
        </Link>
      </div>
    </div>
  )
}

export default ErrorBoundary
</file>

<file path="src/components/common/ErrorBoundary/styles.module.css">
.container {
  width: 100%;
  height: 100%;
  margin-top: 50px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
}

.wrapper {
  max-width: 400px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  gap: 16px;
  text-align: center;
  padding: var(--space-2);
}
</file>

<file path="src/components/common/EthHashInfo/SrcEthHashInfo/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import SrcEthHashInfo from './index'
import { Paper } from '@mui/material'

const meta = {
  component: SrcEthHashInfo,
  parameters: {
    componentSubtitle: 'Renders a hash address with options for copy and explorer link',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof SrcEthHashInfo>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    address: '0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552',
  },
}

export const WithName: Story = {
  args: {
    address: '0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552',
    name: 'Real OG',
  },
}

export const WithOnlyName: Story = {
  args: {
    address: '0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552',
    name: 'Real OG',
    onlyName: true,
  },
}

export const WithAvatar: Story = {
  args: {
    address: '0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552',
    name: 'Real OG',
    showAvatar: true,
    avatarSize: 30,
  },
}
</file>

<file path="src/components/common/EthHashInfo/SrcEthHashInfo/index.tsx">
import classnames from 'classnames'
import type { ReactNode, ReactElement, SyntheticEvent } from 'react'
import { isAddress } from 'ethers'
import { useTheme } from '@mui/material/styles'
import { Box, SvgIcon, Tooltip } from '@mui/material'
import AddressBookIcon from '@/public/images/sidebar/address-book.svg'
import useMediaQuery from '@mui/material/useMediaQuery'
import Identicon from '../../Identicon'
import CopyAddressButton from '../../CopyAddressButton'
import ExplorerButton, { type ExplorerButtonProps } from '../../ExplorerButton'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import ImageFallback from '../../ImageFallback'
import css from './styles.module.css'

export type EthHashInfoProps = {
  address: string
  chainId?: string
  name?: string | null
  showAvatar?: boolean
  onlyName?: boolean
  showCopyButton?: boolean
  prefix?: string
  showPrefix?: boolean
  copyPrefix?: boolean
  shortAddress?: boolean
  copyAddress?: boolean
  customAvatar?: string
  hasExplorer?: boolean
  avatarSize?: number
  children?: ReactNode
  trusted?: boolean
  ExplorerButtonProps?: ExplorerButtonProps
  isAddressBookName?: boolean
  highlight4bytes?: boolean
}

const stopPropagation = (e: SyntheticEvent) => e.stopPropagation()

const SrcEthHashInfo = ({
  address,
  customAvatar,
  prefix = '',
  copyPrefix = true,
  showPrefix = true,
  shortAddress = true,
  copyAddress = true,
  showAvatar = true,
  onlyName = false,
  avatarSize,
  name,
  showCopyButton,
  hasExplorer,
  ExplorerButtonProps,
  children,
  trusted = true,
  isAddressBookName = false,
  highlight4bytes = false,
}: EthHashInfoProps): ReactElement => {
  const shouldPrefix = isAddress(address)
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))
  const identicon = <Identicon address={address} size={avatarSize} />
  const shouldCopyPrefix = shouldPrefix && copyPrefix

  const highlightedAddress = highlight4bytes ? (
    <>
      {address.slice(0, 2)}
      <b>{address.slice(2, 6)}</b>
      {address.slice(6, -4)}
      <b>{address.slice(-4)}</b>
    </>
  ) : (
    address
  )

  const addressElement = (
    <>
      {showPrefix && shouldPrefix && prefix && <b>{prefix}:</b>}
      <span>{shortAddress || isMobile ? shortenAddress(address) : highlightedAddress}</span>
    </>
  )

  return (
    <div className={css.container}>
      {showAvatar && (
        <div
          className={css.avatarContainer}
          style={avatarSize !== undefined ? { width: `${avatarSize}px`, height: `${avatarSize}px` } : undefined}
        >
          {customAvatar ? (
            <ImageFallback src={customAvatar} fallbackComponent={identicon} width={avatarSize} height={avatarSize} />
          ) : (
            identicon
          )}
        </div>
      )}

      <Box overflow="hidden" className={onlyName ? css.inline : undefined} gap={0.5}>
        {name && (
          <Box title={name} className="ethHashInfo-name" display="flex" alignItems="center" gap={0.5}>
            <Box overflow="hidden" textOverflow="ellipsis">
              {name}
            </Box>

            {isAddressBookName && (
              <Tooltip title="From your address book" placement="top">
                <span style={{ lineHeight: 0 }}>
                  <SvgIcon component={AddressBookIcon} inheritViewBox color="border" fontSize="small" />
                </span>
              </Tooltip>
            )}
          </Box>
        )}

        <div className={classnames(css.addressContainer, { [css.inline]: onlyName })}>
          {(!onlyName || !name) && (
            <Box fontWeight="inherit" fontSize="inherit" overflow="hidden" textOverflow="ellipsis">
              {copyAddress ? (
                <CopyAddressButton prefix={prefix} address={address} copyPrefix={shouldCopyPrefix} trusted={trusted}>
                  {addressElement}
                </CopyAddressButton>
              ) : (
                addressElement
              )}
            </Box>
          )}

          {showCopyButton && (
            <CopyAddressButton prefix={prefix} address={address} copyPrefix={shouldCopyPrefix} trusted={trusted} />
          )}

          {hasExplorer && ExplorerButtonProps && (
            <Box color="border.main">
              <ExplorerButton {...ExplorerButtonProps} onClick={stopPropagation} />
            </Box>
          )}

          {children}
        </div>
      </Box>
    </div>
  )
}

export default SrcEthHashInfo
</file>

<file path="src/components/common/EthHashInfo/SrcEthHashInfo/styles.module.css">
.container {
  display: flex;
  align-items: center;
  gap: 0.5em;
  line-height: 1.4;
  width: 100%;
}

.avatarContainer {
  flex-shrink: 0;
  position: relative;
}

.avatarContainer > * {
  width: 100% !important;
  height: 100% !important;
}

.addressContainer {
  display: flex;
  align-items: center;
  white-space: nowrap;
}

.inline {
  display: flex;
  align-items: center;
}
</file>

<file path="src/components/common/EthHashInfo/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import EthHashInfo from './index'
import { Paper } from '@mui/material'

import { StoreDecorator } from '@/stories/storeDecorator'

const meta = {
  component: EthHashInfo,
  parameters: {
    componentSubtitle: 'Renders a hash address with options for copy and explorer link',
  },

  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{}}>
          <Paper sx={{ padding: 2 }}>
            <Story />
          </Paper>
        </StoreDecorator>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof EthHashInfo>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    address: '0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552',
  },
}
</file>

<file path="src/components/common/EthHashInfo/index.tsx">
import { useChain } from '@/hooks/useChains'
import { type ReactElement } from 'react'
import useAllAddressBooks from '@/hooks/useAllAddressBooks'
import useChainId from '@/hooks/useChainId'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import SrcEthHashInfo, { type EthHashInfoProps } from './SrcEthHashInfo'

const EthHashInfo = ({
  showName = true,
  avatarSize = 40,
  ...props
}: EthHashInfoProps & { showName?: boolean }): ReactElement => {
  const settings = useAppSelector(selectSettings)
  const currentChainId = useChainId()
  const chain = useChain(props.chainId || currentChainId)
  const addressBooks = useAllAddressBooks()
  const link = chain && props.hasExplorer ? getBlockExplorerLink(chain, props.address) : undefined
  const addressBookName = chain ? addressBooks?.[chain.chainId]?.[props.address] : undefined
  const name = showName ? addressBookName || props.name : undefined

  return (
    <SrcEthHashInfo
      prefix={chain?.shortName}
      copyPrefix={settings.shortName.copy}
      {...props}
      name={name}
      isAddressBookName={!!addressBookName}
      customAvatar={props.customAvatar}
      ExplorerButtonProps={{ title: link?.title || '', href: link?.href || '' }}
      avatarSize={avatarSize}
    >
      {props.children}
    </SrcEthHashInfo>
  )
}

export default EthHashInfo
</file>

<file path="src/components/common/ExplorerButton/index.tsx">
import type { ReactElement, ComponentType, SyntheticEvent } from 'react'
import { Box, IconButton, SvgIcon, Tooltip, Typography, type TypographyProps } from '@mui/material'
import LinkIcon from '@/public/images/common/link.svg'
import Link from 'next/link'

export type ExplorerButtonProps = {
  title?: string
  href?: string
  className?: string
  icon?: ComponentType
  onClick?: (e: SyntheticEvent) => void
  isCompact?: boolean
  fontSize?: TypographyProps['fontSize']
}

const ExplorerButton = ({
  title = '',
  href = '',
  icon = LinkIcon,
  className,
  onClick,
  isCompact = true,
  fontSize = 'small',
}: ExplorerButtonProps): ReactElement | null => {
  if (!href) return null

  return isCompact ? (
    <Tooltip title={title} placement="top">
      <IconButton
        data-testid="explorer-btn"
        className={className}
        target="_blank"
        rel="noreferrer"
        href={href}
        size="small"
        sx={{ color: 'inherit' }}
        onClick={onClick}
      >
        <SvgIcon component={icon} inheritViewBox fontSize="small" />
      </IconButton>
    </Tooltip>
  ) : (
    <Link
      data-testid="explorer-btn"
      className={className}
      target="_blank"
      rel="noreferrer"
      href={href}
      onClick={onClick}
    >
      <Box display="flex" alignItems="center">
        <Typography fontWeight={700} fontSize={fontSize} mr="var(--space-1)" noWrap>
          View on explorer
        </Typography>

        <SvgIcon component={icon} inheritViewBox fontSize="small" />
      </Box>
    </Link>
  )
}

export default ExplorerButton
</file>

<file path="src/components/common/ExternalLink/index.tsx">
import type { ReactElement } from 'react'
import { OpenInNewRounded } from '@mui/icons-material'
import { Box, Button, Link, type LinkProps } from '@mui/material'

/**
 * Renders an external Link which always sets the noopener and noreferrer rel attribute and the target to _blank.
 * It also always adds the external link icon as end adornment.
 */
const ExternalLink = ({
  noIcon = false,
  children,
  href,
  mode = 'link',
  ...props
}: Omit<LinkProps, 'target' | 'rel'> & { noIcon?: boolean; mode?: 'button' | 'link' }): ReactElement => {
  if (!href) return <>{children}</>

  const linkContent = (
    <Box
      component="span"
      sx={{
        display: 'inline-flex',
        alignItems: 'center',
        gap: 0.2,
        cursor: 'pointer',
      }}
    >
      {children ?? href}
      {!noIcon && <OpenInNewRounded fontSize="small" />}
    </Box>
  )
  return mode === 'link' ? (
    <Link href={href} rel="noreferrer noopener" target="_blank" {...props}>
      {linkContent}
    </Link>
  ) : (
    <Button variant="outlined" href={href} rel="noreferrer noopener" target="_blank" sx={props.sx}>
      {linkContent}
    </Button>
  )
}

export default ExternalLink
</file>

<file path="src/components/common/FiatValue/index.tsx">
import type { CSSProperties, ReactElement } from 'react'
import { useMemo } from 'react'
import { Tooltip, Typography } from '@mui/material'
import { useAppSelector } from '@/store'
import { selectCurrency } from '@/store/settingsSlice'
import { formatCurrency, formatCurrencyPrecise } from '@safe-global/utils/utils/formatNumber'

const style = { whiteSpace: 'nowrap' } as CSSProperties

const FiatValue = ({
  value,
  maxLength,
  precise,
}: {
  value: string | number | null
  maxLength?: number
  precise?: boolean
}): ReactElement => {
  const currency = useAppSelector(selectCurrency)

  const fiat = useMemo(() => {
    return value != null ? formatCurrency(value, currency, maxLength) : null
  }, [value, currency, maxLength])

  const preciseFiat = useMemo(() => {
    return value != null ? formatCurrencyPrecise(value, currency) : null
  }, [value, currency])

  const [whole, decimals, endCurrency] = useMemo(() => {
    const match = (preciseFiat ?? '').match(/(.+)(\D\d+)(\D+)?$/)
    return match ? match.slice(1) : ['', preciseFiat, '', '']
  }, [preciseFiat])

  if (fiat == null) {
    return (
      <Typography component="span" color="text.secondary">
        --
      </Typography>
    )
  }

  return (
    <Tooltip title={precise ? undefined : preciseFiat}>
      <span suppressHydrationWarning style={style}>
        {precise ? (
          <>
            {whole}
            {decimals && (
              <Typography component="span" color="text.secondary" fontSize="inherit" fontWeight="inherit">
                {decimals}
              </Typography>
            )}
            {endCurrency}
          </>
        ) : (
          fiat
        )}
      </span>
    </Tooltip>
  )
}

export default FiatValue
</file>

<file path="src/components/common/FileUpload/index.tsx">
import css from './styles.module.css'
import { Box, Grid, IconButton, Link, SvgIcon, type SvgIconTypeMap, Typography } from '@mui/material'
import HighlightOffIcon from '@mui/icons-material/HighlightOff'
import FileIcon from '@/public/images/settings/data/file.svg'
import type { MouseEventHandler, ReactElement } from 'react'
import type { DropzoneInputProps, DropzoneRootProps } from 'react-dropzone'

export type FileInfo = {
  name: string
  additionalInfo?: string
  summary: ReactElement[]
  error?: string
}

export enum FileTypes {
  JSON = 'JSON',
  CSV = 'CSV',
}

const ColoredFileIcon = ({ color }: { color: SvgIconTypeMap['props']['color'] }) => (
  <SvgIcon component={FileIcon} inheritViewBox fontSize="small" color={color} sx={{ fill: 'none' }} />
)

const UploadSummary = ({ fileInfo, onRemove }: { fileInfo: FileInfo; onRemove: (() => void) | MouseEventHandler }) => {
  return (
    <Grid
      container
      direction="column"
      sx={{
        gap: 1,
        mt: 3,
      }}
    >
      <Grid
        container
        sx={{
          gap: 1,
          display: 'flex',
          alignItems: 'center',
        }}
      >
        <Grid item xs={1}>
          <ColoredFileIcon color="primary" />
        </Grid>
        <Grid item xs={7}>
          {fileInfo.name}
          {fileInfo.additionalInfo && ` - ${fileInfo.additionalInfo}`}
        </Grid>

        <Grid
          item
          xs
          sx={{
            display: 'flex',
            justifyContent: 'flex-end',
          }}
        >
          <IconButton onClick={onRemove} size="small">
            <HighlightOffIcon color="primary" />
          </IconButton>
        </Grid>
      </Grid>
      <Grid
        item
        xs={12}
        sx={{
          display: 'flex',
          justifyContent: 'flex-start',
        }}
      >
        <div className={css.verticalLine} />
      </Grid>
      <>
        {fileInfo.summary.map((summaryItem, idx) => (
          <Grid
            key={`${fileInfo.name}${idx}`}
            container
            sx={{
              display: 'flex',
              gap: 1,
              alignItems: 'center',
            }}
          >
            <Grid item xs={1}>
              <ColoredFileIcon color="border" />
            </Grid>
            <Grid item xs>
              <Typography>{summaryItem}</Typography>
            </Grid>
          </Grid>
        ))}
        {fileInfo.error && (
          <Grid
            container
            sx={{
              display: 'flex',
              gap: 1,
              alignItems: 'center',
            }}
          >
            <Grid item xs={1}>
              <ColoredFileIcon color="border" />
            </Grid>
            <Grid item xs>
              <Typography color="error">
                <strong>{fileInfo.error}</strong>
              </Typography>
            </Grid>
          </Grid>
        )}
      </>
    </Grid>
  )
}

const FileUpload = ({
  getRootProps,
  getInputProps,
  isDragReject = false,
  isDragActive = false,
  fileType,
  fileInfo,
  onRemove,
}: {
  isDragReject?: boolean
  isDragActive?: boolean
  fileType: FileTypes
  getInputProps?: <T extends DropzoneInputProps>(props?: T | undefined) => T
  getRootProps: <T extends DropzoneRootProps>(props?: T | undefined) => T
  fileInfo?: FileInfo
  onRemove: (() => void) | MouseEventHandler
}) => {
  if (fileInfo) {
    return <UploadSummary fileInfo={fileInfo} onRemove={onRemove} />
  }
  return (
    <Box
      data-testid="file-upload-section"
      {...getRootProps()}
      className={css.dropbox}
      sx={{
        cursor: isDragReject ? 'not-allowed' : undefined,
        background: ({ palette }) => `${isDragReject ? palette.error.light : undefined} !important`,
        border: ({ palette }) =>
          `1px dashed ${
            isDragReject ? palette.error.dark : isDragActive ? palette.primary.main : palette.secondary.dark
          }`,
      }}
    >
      {getInputProps && <input {...getInputProps()} />}
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          gap: 1,
        }}
      >
        <SvgIcon
          component={FileIcon}
          inheritViewBox
          fontSize="small"
          sx={{ fill: 'none', color: ({ palette }) => palette.primary.light }}
        />
        <Typography>
          Drag and drop a {fileType} file or <Link color="secondary">choose a file</Link>
        </Typography>
      </Box>
    </Box>
  )
}

export default FileUpload
</file>

<file path="src/components/common/FileUpload/styles.module.css">
.dropbox {
  align-items: center;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  cursor: pointer;
  padding: var(--space-3) var(--space-5);
  margin: var(--space-3) 0;
  background: var(--color-secondary-background);
  color: var(--color-primary-light);
  transition:
    border 0.5s,
    background 0.5s;
}

.verticalLine {
  display: flex;
  height: 18px;
  border-right: 1px solid var(--color-primary-main);
  margin-left: 7px;
  margin-top: -8px;
}
</file>

<file path="src/components/common/Footer/index.tsx">
import type { ReactElement, ReactNode } from 'react'
import { SvgIcon, Typography } from '@mui/material'
import GitHubIcon from '@mui/icons-material/GitHub'
import Link from 'next/link'
import { useRouter } from 'next/router'
import css from './styles.module.css'
import { AppRoutes } from '@/config/routes'
import packageJson from '../../../../package.json'
import ExternalLink from '../ExternalLink'
import MUILink from '@mui/material/Link'
import { HELP_CENTER_URL } from '@/config/constants'
import { useIsOfficialHost } from '@/hooks/useIsOfficialHost'

const footerPages = [
  AppRoutes.welcome.index,
  AppRoutes.settings.index,
  AppRoutes.imprint,
  AppRoutes.privacy,
  AppRoutes.cookie,
  AppRoutes.terms,
  AppRoutes.licenses,
]

const FooterLink = ({ children, href }: { children: ReactNode; href: string }): ReactElement => {
  return href ? (
    <Link href={href} passHref legacyBehavior>
      <MUILink>{children}</MUILink>
    </Link>
  ) : (
    <MUILink>{children}</MUILink>
  )
}

const Footer = (): ReactElement | null => {
  const router = useRouter()
  const isOfficialHost = useIsOfficialHost()

  if (!footerPages.some((path) => router.pathname.startsWith(path))) {
    return null
  }

  const getHref = (path: string): string => {
    return router.pathname === path ? '' : path
  }

  return (
    <footer className={css.container}>
      <ul>
        {isOfficialHost ? (
          <>
            <li>
              <Typography variant="caption">&copy;2022–{new Date().getFullYear()} Core Contributors GmbH</Typography>
            </li>
            <li>
              <FooterLink href={getHref(AppRoutes.terms)}>Terms</FooterLink>
            </li>
            <li>
              <FooterLink href={getHref(AppRoutes.privacy)}>Privacy</FooterLink>
            </li>
            <li>
              <FooterLink href={getHref(AppRoutes.licenses)}>Licenses</FooterLink>
            </li>
            <li>
              <FooterLink href={getHref(AppRoutes.imprint)}>Imprint</FooterLink>
            </li>
            <li>
              <FooterLink href={getHref(AppRoutes.cookie)}>Cookie policy</FooterLink>
            </li>
            <li>
              <FooterLink href={getHref(AppRoutes.settings.index)}>Preferences</FooterLink>
            </li>
            <li>
              <ExternalLink href={HELP_CENTER_URL} noIcon sx={{ span: { textDecoration: 'underline' } }}>
                Help
              </ExternalLink>
            </li>
          </>
        ) : (
          <li>This is an unofficial distribution of the app</li>
        )}

        <li>
          <ExternalLink href={`${packageJson.homepage}/releases/tag/v${packageJson.version}`} noIcon>
            <SvgIcon component={GitHubIcon} inheritViewBox fontSize="inherit" sx={{ mr: 0.5 }} /> v{packageJson.version}
          </ExternalLink>
        </li>
      </ul>
    </footer>
  )
}

export default Footer
</file>

<file path="src/components/common/Footer/styles.module.css">
.container {
  padding: var(--space-2);
  font-size: 13px;
}

.container ul {
  display: flex;
  flex-wrap: wrap;
  list-style: none;
  margin: 0;
  padding: 0;
  justify-content: center;
  row-gap: 0.2em;
  column-gap: var(--space-2);
  align-items: center;
}

.container li {
  padding: 0;
  margin: 0;
}

.container li:not(:last-of-type):after {
  content: '|';
  margin-left: var(--space-2);
}

.container li a:not([href]) {
  text-decoration: none;
  pointer-events: none;
}

@media (max-width: 599.95px) {
  .container li:not(:last-of-type):after {
    visibility: hidden;
  }
}
</file>

<file path="src/components/common/GeoblockingProvider/index.tsx">
import { AppRoutes } from '@/config/routes'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { createContext, type ReactElement, type ReactNode } from 'react'

export const GeoblockingContext = createContext<boolean | null>(null)

const checkBlocked = async () => {
  const res = await fetch(AppRoutes.swap, { method: 'HEAD' })
  return res.status === 403
}

/**
 * Endpoint returns a 403 if the requesting user is from one of the OFAC sanctioned countries
 */
const GeoblockingProvider = ({ children }: { children: ReactNode }): ReactElement => {
  const [isBlockedCountry = null] = useAsync(checkBlocked, [])

  return <GeoblockingContext.Provider value={isBlockedCountry}>{children}</GeoblockingContext.Provider>
}

export default GeoblockingProvider
</file>

<file path="src/components/common/Header/index.tsx">
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useIsWalletProposer } from '@/hooks/useProposers'
import type { Dispatch, SetStateAction } from 'react'
import { type ReactElement } from 'react'
import { useRouter } from 'next/router'
import type { Url } from 'next/dist/shared/lib/router/router'
import { IconButton, Paper } from '@mui/material'
import MenuIcon from '@mui/icons-material/Menu'
import classnames from 'classnames'
import css from './styles.module.css'
import ConnectWallet from '@/components/common/ConnectWallet'
import NetworkSelector from '@/components/common/NetworkSelector'
import SafeTokenWidget from '@/components/common/SafeTokenWidget'
import NotificationCenter from '@/components/notification-center/NotificationCenter'
import { AppRoutes } from '@/config/routes'
import SafeLogo from '@/public/images/logo.svg'
import SafeLogoMobile from '@/public/images/logo-no-text.svg'
import Link from 'next/link'
import useSafeAddress from '@/hooks/useSafeAddress'
import BatchIndicator from '@/components/batch/BatchIndicator'
import WalletConnect from '@/features/walletconnect/components'
import { useHasFeature } from '@/hooks/useChains'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { useSafeTokenEnabled } from '@/hooks/useSafeTokenEnabled'
import { useIsOfficialHost } from '@/hooks/useIsOfficialHost'
import { BRAND_LOGO, BRAND_NAME } from '@/config/constants'
import { FEATURES } from '@safe-global/utils/utils/chains'

type HeaderProps = {
  onMenuToggle?: Dispatch<SetStateAction<boolean>>
  onBatchToggle?: Dispatch<SetStateAction<boolean>>
}

function getLogoLink(router: ReturnType<typeof useRouter>): Url {
  return router.pathname === AppRoutes.home || !router.query.safe
    ? router.pathname === AppRoutes.welcome.accounts
      ? AppRoutes.welcome.index
      : AppRoutes.welcome.accounts
    : { pathname: AppRoutes.home, query: { safe: router.query.safe } }
}

const Header = ({ onMenuToggle, onBatchToggle }: HeaderProps): ReactElement => {
  const safeAddress = useSafeAddress()
  const showSafeToken = useSafeTokenEnabled()
  const isProposer = useIsWalletProposer()
  const isSafeOwner = useIsSafeOwner()
  const router = useRouter()
  const enableWc = useHasFeature(FEATURES.NATIVE_WALLETCONNECT)
  const isOfficialHost = useIsOfficialHost()

  // If on the home page, the logo should link to the Accounts or Welcome page, otherwise to the home page
  const logoHref = getLogoLink(router)

  const handleMenuToggle = () => {
    if (onMenuToggle) {
      onMenuToggle((isOpen) => !isOpen)
    } else {
      router.push(logoHref)
    }
  }

  const handleBatchToggle = () => {
    if (onBatchToggle) {
      onBatchToggle((isOpen) => !isOpen)
    }
  }

  const showBatchButton = safeAddress && (!isProposer || isSafeOwner)

  return (
    <Paper className={css.container}>
      <div className={classnames(css.element, css.menuButton)}>
        {onMenuToggle && (
          <IconButton onClick={handleMenuToggle} size="large" color="default" aria-label="menu">
            <MenuIcon />
          </IconButton>
        )}
      </div>

      <div className={classnames(css.element, css.logoMobile)}>
        <Link href={logoHref} passHref>
          {isOfficialHost ? <SafeLogoMobile alt="Safe logo" /> : null}
        </Link>
      </div>

      <div className={classnames(css.element, css.hideMobile, css.logo)}>
        <Link href={logoHref} passHref>
          {isOfficialHost ? <SafeLogo alt={BRAND_NAME} /> : BRAND_LOGO && <img src={BRAND_LOGO} alt={BRAND_NAME} />}
        </Link>
      </div>

      {showSafeToken && (
        <div className={classnames(css.element, css.hideMobile)}>
          <SafeTokenWidget />
        </div>
      )}

      <div data-testid="notifications-center" className={css.element}>
        <NotificationCenter />
      </div>

      {showBatchButton && (
        <div className={classnames(css.element, css.hideMobile)}>
          <BatchIndicator onClick={handleBatchToggle} />
        </div>
      )}

      {enableWc && (
        <div className={classnames(css.element, css.hideMobile)}>
          <WalletConnect />
        </div>
      )}

      <div className={classnames(css.element, css.connectWallet)}>
        <Track label={OVERVIEW_LABELS.top_bar} {...OVERVIEW_EVENTS.OPEN_ONBOARD}>
          <ConnectWallet />
        </Track>
      </div>

      {safeAddress && (
        <div className={classnames(css.element, css.networkSelector)}>
          <NetworkSelector offerSafeCreation />
        </div>
      )}
    </Paper>
  )
}

export default Header
</file>

<file path="src/components/common/Header/styles.module.css">
.container {
  height: var(--header-height);
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  align-items: center;
  position: relative;
  border-radius: 0 !important;
  background-color: var(--color-background-paper);
  border-bottom: 1px solid var(--color-border-light);
}

.element {
  height: 100%;
  border-right: 1px solid var(--color-border-light);
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.element :global(.MuiBadge-standard) {
  font-size: 12px;
  width: 18px;
  height: 18px;
  min-width: 18px;
}

[data-theme='dark'] .element :global(.MuiBadge-standard) {
  background-color: var(--color-primary-main);
}

.menuButton,
.logo {
  flex: 1;
  border: none;
  align-items: flex-start;
}

.logoMobile {
  display: none;
}

.logo img,
.logo svg,
.logoMobile svg {
  width: auto;
  display: block;
  color: var(--color-logo-main);
  height: 20px;
}

.logo {
  padding: var(--space-2);
}

.menuButton {
  display: none;
}

.networkSelector {
  border-right: none;
}

.connectWallet {
  flex-shrink: 0;
}

@media (max-width: 899.95px) {
  .logo {
    display: none;
  }

  .logoMobile {
    display: flex;
    flex: 1;
    border: none;
    align-items: flex-start;
    margin-left: var(--space-2);
  }

  .menuButton {
    display: flex;
    flex: 0;
  }
}

@media (max-width: 599.95px) {
  .hideMobile {
    display: none;
  }
}
</file>

<file path="src/components/common/icons/CircularIcon/index.tsx">
import { Badge, SvgIcon, type BadgeProps } from '@mui/material'

import Box from '@mui/material/Box'
import css from './styles.module.css'

const CircularIcon = ({
  icon,
  size = 40,
  badgeColor,
}: {
  icon: any // Using SvgIconProps['component'] (any) directly causes type error
  badgeColor?: BadgeProps['color']
  size?: number
}) => {
  return (
    <Badge
      color={badgeColor}
      overlap="circular"
      variant="dot"
      invisible={!badgeColor}
      anchorOrigin={{
        vertical: 'bottom',
        horizontal: 'right',
      }}
      className={css.badge}
    >
      <Box className={css.circle} width={size} height={size}>
        <SvgIcon
          component={icon}
          inheritViewBox
          sx={{
            height: size / 2,
            width: size / 2,
            '& path': {
              fill: ({ palette }) => palette.primary.light,
            },
          }}
        />
      </Box>
    </Badge>
  )
}

export default CircularIcon
</file>

<file path="src/components/common/icons/CircularIcon/styles.module.css">
.circle {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  position: relative;
  background-color: var(--color-background-main);
}

.badge :global .MuiBadge-badge {
  border: 2px solid var(--color-background-paper);
  border-radius: 50%;
  box-sizing: content-box;
}
</file>

<file path="src/components/common/icons/KeyholeIcon/index.tsx">
import css from '@/components/common/icons/CircularIcon/styles.module.css'
import LockIcon from '@/public/images/common/lock.svg'
import { Badge, SvgIcon } from '@mui/material'

const KeyholeIcon = ({ size = 28 }: { size?: number }) => {
  return (
    <Badge
      color="error"
      overlap="circular"
      variant="dot"
      anchorOrigin={{
        vertical: 'bottom',
        horizontal: 'right',
      }}
      className={css.badge}
    >
      <SvgIcon
        color="border"
        component={LockIcon}
        inheritViewBox
        sx={{
          height: size,
          width: size,
        }}
      />
    </Badge>
  )
}

export default KeyholeIcon
</file>

<file path="src/components/common/Identicon/index.tsx">
import type { ReactElement, CSSProperties } from 'react'
import { useMemo } from 'react'
import { blo } from 'blo'
import Skeleton from '@mui/material/Skeleton'

import css from './styles.module.css'
import { isAddress } from 'ethers'

export interface IdenticonProps {
  address: string
  size?: number
}

const Identicon = ({ address, size = 40 }: IdenticonProps): ReactElement => {
  const style = useMemo<CSSProperties | null>(() => {
    try {
      if (!isAddress(address)) {
        return null
      }
      const blockie = blo(address as `0x${string}`)
      return {
        backgroundImage: `url(${blockie})`,
        width: `${size}px`,
        height: `${size}px`,
      }
    } catch (e) {
      return null
    }
  }, [address, size])

  return !style ? (
    <Skeleton variant="circular" width={size} height={size} />
  ) : (
    <div className={css.icon} style={style} />
  )
}

export default Identicon
</file>

<file path="src/components/common/Identicon/styles.module.css">
.icon {
  width: auto;
  height: 100%;
  border-radius: 50%;
  background-size: cover;
}
</file>

<file path="src/components/common/ImageFallback/index.tsx">
import type { ReactElement } from 'react'
import { useState } from 'react'

type ImageAttributes = React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>

type ImageFallbackProps = ImageAttributes &
  (
    | {
        fallbackSrc: string
        fallbackComponent?: ReactElement
      }
    | {
        fallbackSrc?: string
        fallbackComponent: ReactElement
      }
  )

const ImageFallback = ({ src, fallbackSrc, fallbackComponent, ...props }: ImageFallbackProps): React.ReactElement => {
  const [isError, setIsError] = useState<boolean>(false)

  if (isError && fallbackComponent) return fallbackComponent

  return (
    <img
      {...props}
      alt={props.alt || ''}
      src={isError || src === undefined ? fallbackSrc : src}
      onError={() => setIsError(true)}
    />
  )
}

export default ImageFallback
</file>

<file path="src/components/common/InfiniteScroll/index.tsx">
import { useEffect, useRef, type ReactElement } from 'react'
import useOnceVisible from '@/hooks/useOnceVisible'

const InfiniteScroll = ({ onLoadMore }: { onLoadMore: () => void }): ReactElement => {
  const elementRef = useRef<HTMLDivElement | null>(null)
  const isVisible = useOnceVisible(elementRef)

  useEffect(() => {
    if (isVisible) {
      onLoadMore()
    }
  }, [isVisible, onLoadMore])

  return <div ref={elementRef} />
}

export default InfiniteScroll
</file>

<file path="src/components/common/InputValueHelper/index.tsx">
import type { ReactNode, SyntheticEvent } from 'react'
import { InputAdornment, Link } from '@mui/material'
import type { InputAdornmentProps } from '@mui/material'

type InputValueHelperProps = {
  children: ReactNode
  onClick: () => void
  disabled?: boolean
  position?: InputAdornmentProps['position']
}

const InputValueHelper = ({ children, onClick, disabled = false, position = 'end' }: InputValueHelperProps) => {
  const handleClick = (e: SyntheticEvent) => {
    e.preventDefault()
    onClick()
  }

  return (
    <InputAdornment position={position}>
      <Link type="button" component="button" onClick={handleClick} sx={disabled ? { visibility: 'hidden' } : undefined}>
        {children}
      </Link>
    </InputAdornment>
  )
}

export default InputValueHelper
</file>

<file path="src/components/common/LegalDisclaimerContent/index.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import { AppRoutes } from '@/config/routes'
import { Typography } from '@mui/material'
import { type ReactElement } from 'react'
import css from './styles.module.css'

const LegalDisclaimerContent = ({
  withTitle = true,
  isSafeApps = true,
}: {
  withTitle?: boolean
  isSafeApps?: boolean
}): ReactElement => (
  <div className={css.disclaimerContainer}>
    {withTitle && (
      <Typography variant="h3" fontWeight={700} my={3}>
        Disclaimer
      </Typography>
    )}
    <div className={css.disclaimerInner}>
      <Typography mb={4}>
        You are now accessing {isSafeApps ? 'third-party apps' : 'a third-party app'}, which we do not own, control,
        maintain or audit. We are not liable for any loss you may suffer in connection with interacting with the{' '}
        {isSafeApps ? 'apps' : 'app'}, which is at your own risk.
      </Typography>

      <Typography mb={4}>
        You must read our Terms, which contain more detailed provisions binding on you relating to the{' '}
        {isSafeApps ? 'apps' : 'app'}.
      </Typography>

      <Typography>
        I have read and understood the{' '}
        <ExternalLink href={AppRoutes.terms} sx={{ textDecoration: 'none' }}>
          Terms
        </ExternalLink>{' '}
        and this Disclaimer, and agree to be bound by them.
      </Typography>
    </div>
  </div>
)

export default LegalDisclaimerContent
</file>

<file path="src/components/common/LegalDisclaimerContent/styles.module.css">
.disclaimerContainer p,
.disclaimerContainer h3 {
  line-height: 24px;
}

.disclaimerInner p {
  text-align: justify;
}
</file>

<file path="src/components/common/MetaTags/index.tsx">
import { BRAND_NAME, IS_PRODUCTION } from '@/config/constants'
import { ContentSecurityPolicy, StrictTransportSecurity } from '@/config/securityHeaders'
import lightPalette from '@/components/theme/lightPalette'
import darkPalette from '@/components/theme/darkPalette'

const descriptionText = `${BRAND_NAME} is the most trusted smart account wallet on Ethereum with over $100B secured.`
const titleText = BRAND_NAME

const MetaTags = ({ prefetchUrl }: { prefetchUrl: string }) => (
  <>
    <meta name="description" content={descriptionText} />
    {!IS_PRODUCTION && <meta name="robots" content="noindex" />}

    {/* Social sharing */}
    <meta name="og:image" content="https://app.safe.global/images/social-share.png" />
    <meta name="og:description" content={descriptionText} />
    <meta name="og:title" content={titleText} />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@safe" />
    <meta name="twitter:title" content={titleText} />
    <meta name="twitter:description" content={descriptionText} />
    <meta name="twitter:image" content="https://app.safe.global/images/social-share.png" />

    {/* CSP */}
    <meta httpEquiv="Content-Security-Policy" content={ContentSecurityPolicy} />
    {IS_PRODUCTION && <meta httpEquiv="Strict-Transport-Security" content={StrictTransportSecurity} />}

    {/* Prefetch the backend domain */}
    <link rel="dns-prefetch" href={prefetchUrl} />
    <link rel="preconnect" href={prefetchUrl} crossOrigin="" />

    {/* Mobile tags */}
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    {/* PWA primary color and manifest */}
    <meta name="theme-color" content={lightPalette.background.main} media="(prefers-color-scheme: light)" />
    <meta name="theme-color" content={darkPalette.background.main} media="(prefers-color-scheme: dark)" />
    <link rel="manifest" href="/safe.webmanifest" />

    {/* Favicons */}
    <link rel="shortcut icon" href="/favicons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png" />
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000" />
  </>
)

export default MetaTags
</file>

<file path="src/components/common/ModalDialog/index.tsx">
import { type ReactElement, type ReactNode } from 'react'
import { IconButton, type ModalProps } from '@mui/material'
import {
  Dialog,
  DialogTitle,
  type DialogProps,
  type DialogTitleProps as MuiDialogTitleProps,
  useMediaQuery,
} from '@mui/material'
import { useTheme } from '@mui/material/styles'
import ChainIndicator from '@/components/common/ChainIndicator'
import CloseIcon from '@mui/icons-material/Close'

import css from './styles.module.css'

interface ModalDialogProps extends DialogProps {
  dialogTitle?: React.ReactNode
  hideChainIndicator?: boolean
  chainId?: string
}

interface DialogTitleProps {
  children: ReactNode
  onClose?: ModalProps['onClose']
  hideChainIndicator?: boolean
  chainId?: string
  sx?: MuiDialogTitleProps['sx']
}

export const ModalDialogTitle = ({
  children,
  onClose,
  hideChainIndicator = false,
  chainId,
  sx = {},
  ...other
}: DialogTitleProps) => {
  return (
    <DialogTitle
      data-testid="modal-title"
      sx={{ m: 0, px: 3, pt: 3, pb: 2, display: 'flex', alignItems: 'center', fontWeight: 'bold', ...sx }}
      {...other}
    >
      {children}
      <span style={{ flex: 1 }} />
      {!hideChainIndicator && <ChainIndicator chainId={chainId} inline />}
      {onClose ? (
        <IconButton
          data-testid="modal-dialog-close-btn"
          aria-label="close"
          onClick={(e) => {
            onClose(e, 'backdropClick')
          }}
          size="small"
          sx={{
            ml: 2,
            color: 'border.main',
          }}
        >
          <CloseIcon />
        </IconButton>
      ) : null}
    </DialogTitle>
  )
}

const ModalDialog = ({
  dialogTitle,
  hideChainIndicator,
  children,
  fullScreen = false,
  chainId,
  ...restProps
}: ModalDialogProps): ReactElement => {
  const theme = useTheme()
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'))
  const isFullScreen = fullScreen || isSmallScreen

  return (
    <Dialog
      data-testid="modal-view"
      {...restProps}
      fullScreen={isFullScreen}
      scroll={fullScreen ? 'paper' : 'body'}
      className={css.dialog}
      onClick={(e) => e.stopPropagation()}
    >
      {dialogTitle && (
        <ModalDialogTitle onClose={restProps.onClose} hideChainIndicator={hideChainIndicator} chainId={chainId}>
          {dialogTitle}
        </ModalDialogTitle>
      )}

      {children}
    </Dialog>
  )
}

export default ModalDialog
</file>

<file path="src/components/common/ModalDialog/styles.module.css">
.dialog :global .MuiDialogActions-root {
  border-top: 1px solid var(--color-border-light);
  padding: var(--space-2) var(--space-3);
}

.dialog :global .MuiDialogActions-root > :last-of-type:not(:first-of-type) {
  order: 2;
}

.dialog :global .MuiDialogActions-root:after {
  content: '';
  order: 1;
  flex: 1;
}

.dialog :global .MuiDialogTitle-root {
  border-bottom: 1px solid var(--color-border-light);
}

@media (min-width: 600px) {
  .dialog :global .MuiDialog-paper {
    min-width: 600px;
    margin: 0;
  }
}
</file>

<file path="src/components/common/Mui/index.tsx">
import { memo } from 'react'
import { default as MuiBox, type BoxProps } from '@mui/material/Box'
import { default as MuiTypograpahy, type TypographyProps } from '@mui/material/Typography'
import omitBy from 'lodash/omitBy'
import isUndefined from 'lodash/isUndefined'

export * from '@mui/material/index'

export const Box = memo(function Box({
  m,
  mt,
  mr,
  mb,
  ml,
  mx,
  my,
  p,
  pt,
  pr,
  pb,
  pl,
  px,
  py,
  width,
  height,
  minWidth,
  minHeight,
  maxWidth,
  maxHeight,
  display,
  flex,
  flexWrap,
  flexGrow,
  flexShrink,
  flexDirection,
  alignItems,
  justifyItems,
  alignContent,
  justifyContent,
  gap,
  color,
  textAlign,
  position,
  overflow,
  textOverflow,
  border,
  borderRadius,
  borderBottom,
  borderColor,
  bgcolor,
  gridArea,
  lineHeight,
  sx,
  ...props
}: BoxProps['sx'] & BoxProps) {
  return (
    <MuiBox
      sx={omitBy(
        {
          m,
          mt,
          mr,
          mb,
          ml,
          mx,
          my,
          p,
          pt,
          pr,
          pb,
          pl,
          px,
          py,
          width,
          height,
          minWidth,
          minHeight,
          maxWidth,
          maxHeight,
          display,
          flex,
          flexWrap,
          flexGrow,
          flexShrink,
          flexDirection,
          alignItems,
          justifyItems,
          alignContent,
          justifyContent,
          gap,
          color,
          textAlign,
          position,
          overflow,
          textOverflow,
          border,
          borderRadius,
          borderBottom,
          borderColor,
          bgcolor,
          gridArea,
          lineHeight,
          ...sx,
        },
        isUndefined,
      )}
      {...props}
    />
  )
})

export const Typography = memo(function Typography({
  m,
  mt,
  mr,
  mb,
  ml,
  mx,
  my,
  p,
  pt,
  pr,
  pb,
  pl,
  px,
  py,
  display,
  flex,
  flexWrap,
  flexGrow,
  flexShrink,
  flexDirection,
  alignItems,
  justifyItems,
  alignContent,
  justifyContent,
  gap,
  color,
  textAlign,
  fontSize,
  fontWeight,
  fontStyle,
  lineHeight,
  letterSpacing,
  whiteSpace,
  width,
  sx,
  ...props
}: TypographyProps['sx'] & TypographyProps) {
  return (
    <MuiTypograpahy
      sx={omitBy(
        {
          m,
          mt,
          mr,
          mb,
          ml,
          mx,
          my,
          p,
          pt,
          pr,
          pb,
          pl,
          px,
          py,
          display,
          flex,
          flexWrap,
          flexGrow,
          flexShrink,
          flexDirection,
          alignItems,
          justifyItems,
          alignContent,
          justifyContent,
          gap,
          color,
          textAlign,
          fontSize,
          fontWeight,
          fontStyle,
          lineHeight,
          letterSpacing,
          whiteSpace,
          width,
          ...sx,
        },
        isUndefined,
      )}
      {...props}
    />
  )
})
</file>

<file path="src/components/common/NamedAddressInfo/index.tsx">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import { getContract } from '@safe-global/safe-gateway-typescript-sdk'
import EthHashInfo from '../EthHashInfo'
import type { EthHashInfoProps } from '../EthHashInfo/SrcEthHashInfo'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import useSafeAddress from '@/hooks/useSafeAddress'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { memo, useMemo } from 'react'

const useIsUnverifiedContract = (address?: string, error?: Error): boolean => {
  const web3 = useWeb3ReadOnly()

  const [isUnverifiedContract] = useAsync<boolean>(async () => {
    if (!error || !address) return false // Only check via RPC if getContract returned an error
    const code = await web3?.getCode(address)
    return code !== '0x'
  }, [address, web3, error])

  return isUnverifiedContract ?? false
}

export function useAddressName(address?: string, name?: string | null, customAvatar?: string) {
  const chainId = useChainId()

  const [contract, error] = useAsync(
    () => (!name && address ? getContract(chainId, address) : undefined),
    [address, chainId, name],
    false,
  )

  const isUnverifiedContract = useIsUnverifiedContract(address, error)

  return useMemo(
    () => ({
      name:
        name || contract?.displayName || contract?.name || (isUnverifiedContract ? 'Unverified contract' : undefined),
      logoUri: customAvatar || contract?.logoUri,
      isUnverifiedContract,
    }),
    [name, contract, customAvatar, isUnverifiedContract],
  )
}

const NamedAddressInfo = ({ address, name, customAvatar, ...props }: EthHashInfoProps) => {
  const safeAddress = useSafeAddress()

  name = sameAddress(address, safeAddress) ? 'This Safe Account' : name

  const { name: finalName, logoUri: finalAvatar } = useAddressName(address, name, customAvatar)

  return <EthHashInfo address={address} name={finalName} customAvatar={finalAvatar} {...props} />
}

export default memo(NamedAddressInfo)
</file>

<file path="src/components/common/NameInput/index.tsx">
import type { TextFieldProps } from '@mui/material'
import { TextField } from '@mui/material'
import get from 'lodash/get'
import { type FieldError, useFormContext } from 'react-hook-form'
import inputCss from '@/styles/inputs.module.css'

const NameInput = ({
  name,
  required = false,
  ...props
}: Omit<TextFieldProps, 'error' | 'variant' | 'ref' | 'fullWidth'> & {
  name: string
  required?: boolean
}) => {
  const { register, formState } = useFormContext() || {}
  // the name can be a path: e.g. "owner.3.name"
  const fieldError = get(formState.errors, name) as FieldError | undefined

  return (
    <TextField
      {...props}
      variant="outlined"
      label={<>{fieldError?.type === 'maxLength' ? 'Maximum 50 symbols' : fieldError?.message || props.label}</>}
      error={Boolean(fieldError)}
      fullWidth
      required={required}
      className={inputCss.input}
      onKeyDown={(e) => e.stopPropagation()}
      {...register(name, {
        maxLength: 50,
        required,
        setValueAs: (value) => value.trim(),
      })}
    />
  )
}

export default NameInput
</file>

<file path="src/components/common/Navigate/index.tsx">
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

export function Navigate({ to, replace = false }: { to: string; replace?: boolean }): null {
  const router = useRouter()

  useEffect(() => {
    if (replace) {
      router.replace(to)
    } else {
      router.push(to)
    }
  }, [replace, router, to])

  return null
}
</file>

<file path="src/components/common/NavTabs/index.tsx">
import React from 'react'
import NextLink from 'next/link'
import { Tab, Tabs, Typography } from '@mui/material'
import { useRouter } from 'next/router'
import type { NavItem } from '@/components/sidebar/SidebarNavigation/config'
import css from './styles.module.css'

const NavTabs = ({ tabs }: { tabs: NavItem[] }) => {
  const router = useRouter()
  const activeTab = Math.max(0, tabs.map((tab) => tab.href).indexOf(router.pathname))
  const query = router.query.safe ? { safe: router.query.safe } : undefined

  return (
    <Tabs value={activeTab} variant="scrollable" allowScrollButtonsMobile className={css.tabs}>
      {tabs.map((tab, idx) => (
        <Tab
          key={tab.href}
          href={{ pathname: tab.href, query }}
          component={NextLink}
          tabIndex={0}
          className={css.tab}
          label={
            <Typography
              variant="body2"
              fontWeight={700}
              color={activeTab === idx ? 'primary' : 'primary.light'}
              className={css.label}
            >
              {tab.label}
            </Typography>
          }
        />
      ))}
    </Tabs>
  )
}

export default NavTabs
</file>

<file path="src/components/common/NavTabs/styles.module.css">
.tabs {
  overflow: initial;
}

/* Scroll buttons */
.tabs :global .MuiTabs-scrollButtons.Mui-disabled {
  opacity: 0.3;
}

.tabs :global .MuiTabScrollButton-root ~ .MuiTabs-scroller p {
  padding-bottom: 0;
}

.tabs :global .MuiTabScrollButton-root:first-of-type {
  margin-left: calc(var(--space-2) * -1);
}

.tabs :global .MuiTabScrollButton-root:last-of-type {
  margin-right: calc(var(--space-2) * -1);
}

.tab {
  opacity: 1;
  padding: 0 var(--space-3);
  position: relative;
  z-index: 2;
}

.label {
  text-transform: none;
  padding-bottom: 6px;
}
</file>

<file path="src/components/common/NestedSafeBreadcrumbs/index.tsx">
import { useRouter } from 'next/router'
import { Typography } from '@mui/material'
import type { ReactElement } from 'react'

import useSafeInfo from '@/hooks/useSafeInfo'
import { useParentSafe } from '@/hooks/useParentSafe'
import { BreadcrumbItem } from '@/components/common/Breadcrumbs/BreadcrumbItem'
import { formatPrefixedAddress } from '@safe-global/utils/utils/addresses'
import { useChain } from '@/hooks/useChains'

export function NestedSafeBreadcrumbs(): ReactElement | null {
  const { pathname, query } = useRouter()
  const { safeAddress } = useSafeInfo()
  const parentSafe = useParentSafe()
  const currentChain = useChain(parentSafe?.chainId || '')

  if (!parentSafe) {
    return null
  }

  const prefixedAddress = formatPrefixedAddress(parentSafe.address.value, currentChain?.shortName)

  return (
    <>
      <BreadcrumbItem
        title="Parent Safe"
        address={parentSafe.address.value}
        href={{
          pathname,
          query: { ...query, safe: prefixedAddress },
        }}
      />
      <Typography variant="body2">/</Typography>
      <BreadcrumbItem title="Nested Safe" address={safeAddress} />
    </>
  )
}
</file>

<file path="src/components/common/NetworkInput/index.tsx">
import ChainIndicator from '@/components/common/ChainIndicator'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useTheme } from '@mui/material/styles'
import { FormControl, InputLabel, ListSubheader, MenuItem, Select, Typography } from '@mui/material'
import partition from 'lodash/partition'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import css from './styles.module.css'
import { type ReactElement, useCallback, useMemo } from 'react'
import { Controller, useFormContext } from 'react-hook-form'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'

const NetworkInput = ({
  name,
  required = false,
  chainConfigs,
}: {
  name: string
  required?: boolean
  chainConfigs: (ChainInfo & { available: boolean })[]
}): ReactElement => {
  const isDarkMode = useDarkMode()
  const theme = useTheme()
  const [testNets, prodNets] = useMemo(() => partition(chainConfigs, (config) => config.isTestnet), [chainConfigs])
  const { control } = useFormContext() || {}

  const renderMenuItem = useCallback(
    (chainId: string, isDisabled: boolean) => {
      const chain = chainConfigs.find((chain) => chain.chainId === chainId)
      if (!chain) return null
      return (
        <MenuItem
          disabled={isDisabled}
          key={chainId}
          value={chainId}
          sx={{ '&:hover': { backgroundColor: 'inherit' } }}
        >
          <ChainIndicator chainId={chain.chainId} />
          {isDisabled && (
            <Typography variant="caption" component="span" className={css.disabledChip}>
              Not available
            </Typography>
          )}
        </MenuItem>
      )
    },
    [chainConfigs],
  )

  return (
    <Controller
      name={name}
      rules={{ required }}
      control={control}
      // eslint-disable-next-line
      render={({ field: { ref, ...field } }) => (
        <FormControl fullWidth>
          <InputLabel id="network-input-label">Network</InputLabel>
          <Select
            {...field}
            labelId="network-input-label"
            id="network-input"
            fullWidth
            label="Network"
            IconComponent={ExpandMoreIcon}
            renderValue={(value) => renderMenuItem(value, false)}
            MenuProps={{
              sx: {
                '& .MuiPaper-root': {
                  overflow: 'auto',
                },
                ...(isDarkMode
                  ? {
                      '& .Mui-selected, & .Mui-selected:hover': {
                        backgroundColor: `${theme.palette.secondary.background} !important`,
                      },
                    }
                  : {}),
              },
            }}
          >
            {prodNets.map((chain) => renderMenuItem(chain.chainId, !chain.available))}

            {testNets.length > 0 && <ListSubheader className={css.listSubHeader}>Testnets</ListSubheader>}

            {testNets.map((chain) => renderMenuItem(chain.chainId, !chain.available))}
          </Select>
        </FormControl>
      )}
    />
  )
}

export default NetworkInput
</file>

<file path="src/components/common/NetworkInput/styles.module.css">
.select {
  height: 100%;
}

.select:after,
.select:before {
  display: none;
}

.select *:focus-visible {
  outline: 5px auto Highlight;
  outline: 5px auto -webkit-focus-ring-color;
}

.select :global .MuiSelect-select {
  padding-right: 40px !important;
  padding-left: 16px;
  height: 100%;
  display: flex;
  align-items: center;
}

.select :global .MuiSelect-icon {
  margin-right: var(--space-2);
}

.select :global .Mui-disabled {
  pointer-events: none;
}

.select :global .MuiMenuItem-root {
  padding: 0;
}

.listSubHeader {
  text-transform: uppercase;
  font-size: 11px;
  font-weight: bold;
  line-height: 32px;
}

.newChip {
  font-weight: bold;
  letter-spacing: -0.1px;
  margin-top: -18px;
  margin-left: -14px;
  transform: scale(0.7);
}

.item {
  display: flex;
  align-items: center;
  gap: var(--space-1);
}

.disabledChip {
  background-color: var(--color-border-light);
  border-radius: 4px;
  color: var(--color-text-primary);
  padding: 4px 8px;
  margin-left: auto;
}
</file>

<file path="src/components/common/NetworkSelector/index.tsx">
import ChainIndicator from '@/components/common/ChainIndicator'
import Track from '@/components/common/Track'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useAppSelector } from '@/store'
import { selectChains } from '@/store/chainsSlice'
import { useTheme } from '@mui/material/styles'
import Link from 'next/link'
import {
  Box,
  ButtonBase,
  CircularProgress,
  Collapse,
  Divider,
  MenuItem,
  Select,
  Skeleton,
  Stack,
  Tooltip,
  Typography,
} from '@mui/material'
import partition from 'lodash/partition'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import useChains, { useCurrentChain } from '@/hooks/useChains'
import type { NextRouter } from 'next/router'
import { useRouter } from 'next/router'
import css from './styles.module.css'
import { useChainId } from '@/hooks/useChainId'
import { type ReactElement, useCallback, useMemo, useState } from 'react'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS, trackEvent } from '@/services/analytics'

import { useAllSafesGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import useSafeAddress from '@/hooks/useSafeAddress'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import uniq from 'lodash/uniq'
import { useCompatibleNetworks } from '@/features/multichain/hooks/useCompatibleNetworks'
import { useSafeCreationData } from '@/features/multichain/hooks/useSafeCreationData'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import PlusIcon from '@/public/images/common/plus.svg'
import useAddressBook from '@/hooks/useAddressBook'
import { CreateSafeOnSpecificChain } from '@/features/multichain/components/CreateSafeOnNewChain'
import { useGetSafeOverviewQuery } from '@/store/api/gateway'
import { InfoOutlined } from '@mui/icons-material'
import { selectUndeployedSafe } from '@/store/slices'
import { skipToken } from '@reduxjs/toolkit/query'
import { hasMultiChainAddNetworkFeature } from '@/features/multichain/utils/utils'

const ChainIndicatorWithFiatBalance = ({
  isSelected,
  chain,
  safeAddress,
}: {
  isSelected: boolean
  chain: ChainInfo
  safeAddress: string
}) => {
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, chain.chainId, safeAddress))
  const { data: safeOverview } = useGetSafeOverviewQuery(
    undeployedSafe ? skipToken : { safeAddress, chainId: chain.chainId },
  )

  return (
    <ChainIndicator
      responsive={isSelected}
      chainId={chain.chainId}
      fiatValue={safeOverview ? safeOverview.fiatTotal : undefined}
      inline
    />
  )
}

export const getNetworkLink = (router: NextRouter, safeAddress: string, networkShortName: string) => {
  const isSafeOpened = safeAddress !== ''

  const query = (
    isSafeOpened
      ? {
          safe: `${networkShortName}:${safeAddress}`,
        }
      : { chain: networkShortName }
  ) as {
    safe?: string
    chain?: string
    safeViewRedirectURL?: string
  }

  const route = {
    pathname: router.pathname,
    query,
  }

  if (router.query?.safeViewRedirectURL) {
    route.query.safeViewRedirectURL = router.query?.safeViewRedirectURL.toString()
  }

  return route
}

const UndeployedNetworkMenuItem = ({
  chain,
  isSelected = false,
  onSelect,
}: {
  chain: ChainInfo & { available: boolean }
  isSelected?: boolean
  onSelect: (chain: ChainInfo) => void
}) => {
  const isDisabled = !chain.available

  return (
    <Track {...OVERVIEW_EVENTS.ADD_NEW_NETWORK} label={OVERVIEW_LABELS.top_bar}>
      <Tooltip data-testid="add-network-tooltip" title="Add network" arrow placement="left">
        <MenuItem
          value={chain.chainId}
          sx={{ '&:hover': { backgroundColor: 'inherit' } }}
          onClick={() => onSelect(chain)}
          disabled={isDisabled}
        >
          <Box className={css.item}>
            <ChainIndicator responsive={isSelected} chainId={chain.chainId} inline />
            {isDisabled ? (
              <Typography variant="caption" component="span" className={css.comingSoon}>
                Not available
              </Typography>
            ) : (
              <PlusIcon className={css.plusIcon} />
            )}
          </Box>
        </MenuItem>
      </Tooltip>
    </Track>
  )
}

const NetworkSkeleton = () => {
  return (
    <Stack
      direction="row"
      spacing={1}
      sx={{
        alignItems: 'center',
        p: '4px 0px',
      }}
    >
      <Skeleton variant="circular" width="24px" height="24px" />
      <Skeleton variant="rounded" sx={{ flexGrow: 1 }} />
    </Stack>
  )
}

const TestnetDivider = () => {
  return (
    <Divider sx={{ m: '0px !important', '& .MuiDivider-wrapper': { p: '0px 16px' } }}>
      <Typography
        variant="overline"
        sx={{
          color: 'border.main',
        }}
      >
        Testnets
      </Typography>
    </Divider>
  )
}

const UndeployedNetworks = ({
  deployedChains,
  chains,
  safeAddress,
  closeNetworkSelect,
}: {
  deployedChains: string[]
  chains: ChainInfo[]
  safeAddress: string
  closeNetworkSelect: () => void
}) => {
  const [open, setOpen] = useState(false)
  const [replayOnChain, setReplayOnChain] = useState<ChainInfo>()
  const addressBook = useAddressBook()
  const safeName = addressBook[safeAddress]
  const deployedChainInfos = useMemo(
    () => chains.filter((chain) => deployedChains.includes(chain.chainId)),
    [chains, deployedChains],
  )
  const safeCreationResult = useSafeCreationData(safeAddress, deployedChainInfos)
  const [safeCreationData, safeCreationDataError, safeCreationLoading] = safeCreationResult

  const allCompatibleChains = useCompatibleNetworks(safeCreationData)
  const isUnsupportedSafeCreationVersion = Boolean(!allCompatibleChains?.length)

  const availableNetworks = useMemo(
    () =>
      allCompatibleChains?.filter(
        (config) => !deployedChains.includes(config.chainId) && hasMultiChainAddNetworkFeature(config),
      ) || [],
    [allCompatibleChains, deployedChains],
  )

  const [testNets, prodNets] = useMemo(
    () => partition(availableNetworks, (config) => config.isTestnet),
    [availableNetworks],
  )

  const noAvailableNetworks = useMemo(() => availableNetworks.every((config) => !config.available), [availableNetworks])

  const onSelect = (chain: ChainInfo) => {
    setReplayOnChain(chain)
  }

  if (safeCreationLoading) {
    return (
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          my: 1,
        }}
      >
        <CircularProgress size={18} />
      </Box>
    )
  }

  const errorMessage =
    safeCreationDataError || (safeCreationData && noAvailableNetworks) ? (
      <Stack
        direction="row"
        spacing={1}
        sx={{
          alignItems: 'center',
        }}
      >
        {safeCreationDataError?.message && (
          <Tooltip title={safeCreationDataError?.message}>
            <InfoOutlined color="info" fontSize="medium" />
          </Tooltip>
        )}
        <Typography>Adding another network is not possible for this Safe. </Typography>
      </Stack>
    ) : isUnsupportedSafeCreationVersion ? (
      'This account was created from an outdated mastercopy. Adding another network is not possible.'
    ) : (
      ''
    )

  if (errorMessage) {
    return (
      <Box
        sx={{
          px: 2,
          py: 1,
        }}
      >
        <Typography
          sx={{
            color: 'text.secondary',
            fontSize: '14px',
            maxWidth: 300,
          }}
        >
          {errorMessage}
        </Typography>
      </Box>
    )
  }

  const onFormClose = () => {
    setReplayOnChain(undefined)
    closeNetworkSelect()
  }

  const onShowAllNetworks = () => {
    !open && trackEvent(OVERVIEW_EVENTS.SHOW_ALL_NETWORKS)
    setOpen((prev) => !prev)
  }

  return (
    <>
      <ButtonBase className={css.listSubHeader} onClick={onShowAllNetworks} tabIndex={-1}>
        <Stack
          direction="row"
          spacing={1}
          sx={{
            alignItems: 'center',
          }}
        >
          <div data-testid="show-all-networks">Show all networks</div>

          <ExpandMoreIcon
            fontSize="small"
            sx={{
              transform: open ? 'rotate(180deg)' : undefined,
            }}
          />
        </Stack>
      </ButtonBase>
      <Collapse in={open} timeout="auto" unmountOnExit>
        {!safeCreationData ? (
          <Box
            sx={{
              p: '0px 16px',
            }}
          >
            <NetworkSkeleton />
            <NetworkSkeleton />
          </Box>
        ) : (
          <>
            {prodNets.map((chain) => (
              <UndeployedNetworkMenuItem chain={chain} onSelect={onSelect} key={chain.chainId} />
            ))}
            {testNets.length > 0 && <TestnetDivider />}
            {testNets.map((chain) => (
              <UndeployedNetworkMenuItem chain={chain} onSelect={onSelect} key={chain.chainId} />
            ))}
          </>
        )}
      </Collapse>
      {replayOnChain && safeCreationData && (
        <CreateSafeOnSpecificChain
          chain={replayOnChain}
          safeAddress={safeAddress}
          open
          onClose={onFormClose}
          currentName={safeName ?? ''}
          safeCreationResult={safeCreationResult}
        />
      )}
    </>
  )
}

const NetworkSelector = ({
  onChainSelect,
  offerSafeCreation = false,
}: {
  onChainSelect?: () => void
  offerSafeCreation?: boolean
}): ReactElement => {
  const [open, setOpen] = useState<boolean>(false)
  const isDarkMode = useDarkMode()
  const theme = useTheme()
  const { configs } = useChains()
  const chainId = useChainId()
  const router = useRouter()
  const safeAddress = useSafeAddress()
  const currentChain = useCurrentChain()
  const chains = useAppSelector(selectChains)

  const isSafeOpened = safeAddress !== ''

  const addNetworkFeatureEnabled = hasMultiChainAddNetworkFeature(currentChain)

  const safesGrouped = useAllSafesGrouped()
  const availableChainIds = useMemo(() => {
    if (!isSafeOpened) {
      // Offer all chains
      return configs.map((config) => config.chainId)
    }
    return uniq([
      chainId,
      ...(safesGrouped.allMultiChainSafes
        ?.find((item) => sameAddress(item.address, safeAddress))
        ?.safes.map((safe) => safe.chainId) ?? []),
    ])
  }, [chainId, configs, isSafeOpened, safeAddress, safesGrouped.allMultiChainSafes])

  const [testNets, prodNets] = useMemo(
    () =>
      partition(
        configs.filter((config) => availableChainIds.includes(config.chainId)),
        (config) => config.isTestnet,
      ),
    [availableChainIds, configs],
  )

  const renderMenuItem = useCallback(
    (chainId: string, isSelected: boolean) => {
      const chain = chains.data.find((chain) => chain.chainId === chainId)
      if (!chain) return null

      const onSwitchNetwork = () => {
        trackEvent({ ...OVERVIEW_EVENTS.SWITCH_NETWORK, label: chainId })
      }

      return (
        <MenuItem
          data-testid="network-selector-item"
          key={chainId}
          value={chainId}
          sx={{ '&:hover': { backgroundColor: isSelected ? 'transparent' : 'inherit' } }}
          disableRipple={isSelected}
          onClick={onSwitchNetwork}
        >
          <Link
            href={getNetworkLink(router, safeAddress, chain.shortName)}
            onClick={onChainSelect}
            className={css.item}
          >
            <ChainIndicatorWithFiatBalance chain={chain} safeAddress={safeAddress} isSelected={isSelected} />
          </Link>
        </MenuItem>
      )
    },
    [chains.data, onChainSelect, router, safeAddress],
  )

  const handleClose = () => {
    setOpen(false)
  }

  const handleOpen = () => {
    setOpen(true)
    offerSafeCreation && trackEvent({ ...OVERVIEW_EVENTS.EXPAND_MULTI_SAFE, label: OVERVIEW_LABELS.top_bar })
  }

  return configs.length ? (
    <Select
      open={open}
      onClose={handleClose}
      onOpen={handleOpen}
      value={chainId}
      size="small"
      className={css.select}
      variant="standard"
      IconComponent={ExpandMoreIcon}
      renderValue={(value) => renderMenuItem(value, true)}
      MenuProps={{
        transitionDuration: 0,
        sx: {
          '& .MuiPaper-root': {
            overflow: 'auto',
            minWidth: '260px !important',
          },
          ...(isDarkMode
            ? {
                '& .Mui-selected, & .Mui-selected:hover': {
                  backgroundColor: `${theme.palette.secondary.background} !important`,
                },
              }
            : {}),
        },
      }}
      sx={{
        '& .MuiSelect-select': {
          py: 0,
        },
      }}
    >
      {prodNets.map((chain) => renderMenuItem(chain.chainId, false))}

      {testNets.length > 0 && <TestnetDivider />}

      {testNets.map((chain) => renderMenuItem(chain.chainId, false))}

      {offerSafeCreation && isSafeOpened && addNetworkFeatureEnabled && (
        <UndeployedNetworks
          chains={configs}
          deployedChains={availableChainIds}
          safeAddress={safeAddress}
          closeNetworkSelect={handleClose}
        />
      )}
    </Select>
  ) : (
    <Skeleton width={94} height={31} sx={{ mx: 2 }} />
  )
}

export default NetworkSelector
</file>

<file path="src/components/common/NetworkSelector/NetworkMultiSelector.tsx">
import useChains, { useCurrentChain } from '@/hooks/useChains'
import useSafeAddress from '@/hooks/useSafeAddress'
import { useCallback, useEffect, type ReactElement } from 'react'
import { Checkbox, Autocomplete, TextField, Chip, Box } from '@mui/material'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import ChainIndicator from '../ChainIndicator'
import css from './styles.module.css'
import { Controller, useFormContext, useWatch } from 'react-hook-form'
import { useRouter } from 'next/router'
import { getNetworkLink } from '.'
import { SetNameStepFields } from '@/components/new-safe/create/steps/SetNameStep'
import { getSafeSingletonDeployments, getSafeToL2SetupDeployments } from '@safe-global/safe-deployments'
import { hasCanonicalDeployment } from '@safe-global/utils/services/contracts/deployments'
import { hasMultiChainCreationFeatures } from '@/features/multichain/utils/utils'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

const NetworkMultiSelector = ({
  name,
  isAdvancedFlow = false,
}: {
  name: string
  isAdvancedFlow?: boolean
}): ReactElement => {
  const { configs } = useChains()
  const router = useRouter()
  const safeAddress = useSafeAddress()
  const currentChain = useCurrentChain()

  const {
    formState: { errors },
    control,
    getValues,
    setValue,
  } = useFormContext()

  const selectedNetworks: ChainInfo[] = useWatch({ control, name: SetNameStepFields.networks })

  const updateCurrentNetwork = useCallback(
    (chains: ChainInfo[]) => {
      if (chains.length !== 1) return
      const shortName = chains[0].shortName
      const networkLink = getNetworkLink(router, safeAddress, shortName)
      router.replace(networkLink)
    },
    [router, safeAddress],
  )

  const handleDelete = useCallback(
    (deletedChainId: string) => {
      const currentValues: ChainInfo[] = getValues(name) || []
      const updatedValues = currentValues.filter((chain) => chain.chainId !== deletedChainId)
      updateCurrentNetwork(updatedValues)
      setValue(name, updatedValues, { shouldValidate: true })
    },
    [getValues, name, setValue, updateCurrentNetwork],
  )

  const isOptionDisabled = useCallback(
    (optionNetwork: ChainInfo) => {
      // Initially all networks are always available
      if (selectedNetworks.length === 0) {
        return false
      }

      const firstSelectedNetwork = selectedNetworks[0]

      // do not allow multi chain safes for advanced setup flow.
      if (isAdvancedFlow) return optionNetwork.chainId != firstSelectedNetwork.chainId

      // Check required feature toggles
      const optionIsSelectedNetwork = firstSelectedNetwork.chainId === optionNetwork.chainId
      if (!hasMultiChainCreationFeatures(optionNetwork) || !hasMultiChainCreationFeatures(firstSelectedNetwork)) {
        return !optionIsSelectedNetwork
      }

      // Check if required deployments are available
      const optionHasCanonicalSingletonDeployment =
        hasCanonicalDeployment(
          getSafeSingletonDeployments({
            network: optionNetwork.chainId,
            version: getLatestSafeVersion(firstSelectedNetwork),
          }),
          optionNetwork.chainId,
        ) &&
        hasCanonicalDeployment(
          getSafeToL2SetupDeployments({ network: optionNetwork.chainId, version: '1.4.1' }),
          optionNetwork.chainId,
        )

      const selectedHasCanonicalSingletonDeployment =
        hasCanonicalDeployment(
          getSafeSingletonDeployments({
            network: firstSelectedNetwork.chainId,
            version: getLatestSafeVersion(firstSelectedNetwork),
          }),
          firstSelectedNetwork.chainId,
        ) &&
        hasCanonicalDeployment(
          getSafeToL2SetupDeployments({ network: firstSelectedNetwork.chainId, version: '1.4.1' }),
          firstSelectedNetwork.chainId,
        )

      // Only 1.4.1 safes with canonical deployment addresses and SafeToL2Setup can be deployed as part of a multichain group
      if (!selectedHasCanonicalSingletonDeployment) return !optionIsSelectedNetwork
      return !optionHasCanonicalSingletonDeployment
    },
    [isAdvancedFlow, selectedNetworks],
  )

  useEffect(() => {
    if (selectedNetworks.length === 1 && selectedNetworks[0].chainId !== currentChain?.chainId) {
      updateCurrentNetwork([selectedNetworks[0]])
    }
  }, [selectedNetworks, currentChain, updateCurrentNetwork])

  return (
    <>
      <Controller
        name={name}
        control={control}
        defaultValue={[]}
        render={({ field }) => (
          <Autocomplete
            {...field}
            multiple
            value={field.value || []}
            disableCloseOnSelect
            options={configs}
            renderTags={(selectedOptions) =>
              selectedOptions.map((chain) => (
                <Chip
                  variant="outlined"
                  key={chain.chainId}
                  avatar={<ChainIndicator chainId={chain.chainId} onlyLogo inline />}
                  label={chain.chainName}
                  onDelete={() => handleDelete(chain.chainId)}
                  className={css.multiChainChip}
                ></Chip>
              ))
            }
            renderOption={(props, chain, { selected }) => {
              const { key, ...rest } = props

              return (
                <Box component="li" key={key} {...rest}>
                  <Checkbox data-testid="network-checkbox" size="small" checked={selected} />
                  <ChainIndicator chainId={chain.chainId} inline />
                </Box>
              )
            }}
            getOptionLabel={(option) => option.chainName}
            getOptionDisabled={isOptionDisabled}
            renderInput={(params) => (
              <TextField
                {...params}
                error={!!errors.networks}
                helperText={errors.networks ? 'Select at least one network' : ''}
              />
            )}
            filterOptions={(options, { inputValue }) =>
              options.filter((option) => option.chainName.toLowerCase().includes(inputValue.toLowerCase()))
            }
            isOptionEqualToValue={(option, value) => option.chainId === value.chainId}
            onChange={(_, data) => {
              updateCurrentNetwork(data)
              return field.onChange(data)
            }}
          />
        )}
        rules={{ required: true }}
      />
    </>
  )
}

export default NetworkMultiSelector
</file>

<file path="src/components/common/NetworkSelector/styles.module.css">
.select {
  height: 100%;
}

.select:after,
.select:before {
  display: none;
}

.select *:focus-visible {
  outline: 5px auto Highlight;
  outline: 5px auto -webkit-focus-ring-color;
}

.select :global .MuiSelect-select {
  padding-right: 40px !important;
  padding-left: 16px;
  height: 100%;
  display: flex;
  align-items: center;
}

.select :global .MuiSelect-icon {
  margin-right: var(--space-2);
}

.select :global .Mui-disabled {
  pointer-events: none;
}

.select :global .MuiMenuItem-root {
  padding: 0;
}

.listSubHeader {
  background-color: var(--color-background-main);
  text-transform: uppercase;
  font-size: 11px;
  font-weight: bold;
  line-height: 32px;
  text-align: center;
  letter-spacing: 1px;
  width: 100%;
  margin-top: var(--space-1);
}

[data-theme='dark'] .undeployedNetworksHeader {
  background-color: var(--color-secondary-background);
}

.plusIcon {
  background-color: var(--color-background-main);
  color: var(--color-border-main);
  border-radius: 100%;
  height: 20px;
  width: 20px;
  padding: 4px;
  margin-left: auto;
}

.newChip {
  font-weight: bold;
  letter-spacing: -0.1px;
  margin-top: -18px;
  margin-left: -14px;
  transform: scale(0.7);
}

.item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-1);
  width: 100%;
}

.multiChainChip {
  padding: var(--space-2) 0;
  margin: 2px;
  border-color: var(--color-border-main);
}

.comingSoon {
  background-color: var(--color-border-light);
  border-radius: 4px;
  color: var(--color-text-primary);
  padding: 4px 8px;
}
</file>

<file path="src/components/common/NetworkSelector/useChangeNetworkLink.ts">
import { AppRoutes } from '@/config/routes'
import useWallet from '@/hooks/wallets/useWallet'
import { useRouter } from 'next/router'

export const useChangeNetworkLink = (networkShortName: string) => {
  const router = useRouter()
  const isWalletConnected = !!useWallet()
  const pathname = router.pathname

  const shouldKeepPath = !router.query.safe

  const route = {
    pathname: shouldKeepPath ? pathname : isWalletConnected ? AppRoutes.welcome.accounts : AppRoutes.welcome.index,
    query: {
      chain: networkShortName,
    } as {
      chain: string
      safeViewRedirectURL?: string
    },
  }

  if (router.query?.safeViewRedirectURL) {
    route.query.safeViewRedirectURL = router.query?.safeViewRedirectURL.toString()
  }

  return route
}
</file>

<file path="src/components/common/Notifications/index.tsx">
import type { ReactElement, SyntheticEvent } from 'react'
import React, { useCallback, useEffect } from 'react'
import groupBy from 'lodash/groupBy'
import { useAppDispatch, useAppSelector } from '@/store'
import type { Notification } from '@/store/notificationsSlice'
import { closeNotification, readNotification, selectNotifications } from '@/store/notificationsSlice'
import type { AlertColor, SnackbarCloseReason } from '@mui/material'
import { Alert, Box, Link, Snackbar, Typography } from '@mui/material'
import css from './styles.module.css'
import NextLink from 'next/link'
import ChevronRightIcon from '@mui/icons-material/ChevronRight'
import { OVERVIEW_EVENTS } from '@/services/analytics/events/overview'
import Track from '../Track'
import { isRelativeUrl } from '@/utils/url'

const toastStyle = { position: 'static', margin: 1 }

export const NotificationLink = ({
  link,
  onClick,
}: {
  link: Notification['link']
  onClick: (_: Event | SyntheticEvent) => void
}): ReactElement | null => {
  if (!link) {
    return null
  }

  const LinkWrapper = ({ children }: React.PropsWithChildren) =>
    'href' in link ? (
      <NextLink href={link.href} passHref legacyBehavior>
        {children}
      </NextLink>
    ) : (
      <Box display="flex">{children}</Box>
    )

  const handleClick = (event: SyntheticEvent) => {
    if ('onClick' in link) {
      link.onClick()
    }
    onClick(event)
  }

  const isExternal =
    'href' in link &&
    (typeof link.href === 'string' ? !isRelativeUrl(link.href) : !!(link.href.host || link.href.hostname))

  return (
    <Track {...OVERVIEW_EVENTS.NOTIFICATION_INTERACTION} label={link.title} as="span">
      <LinkWrapper>
        <Link
          className={css.link}
          onClick={handleClick}
          sx={{ cursor: 'pointer' }}
          {...(isExternal && { target: '_blank', rel: 'noopener noreferrer' })}
        >
          {link.title}
          <ChevronRightIcon />
        </Link>
      </LinkWrapper>
    </Track>
  )
}

const Toast = ({
  title,
  message,
  detailedMessage,
  variant,
  link,
  onClose,
  id,
}: {
  variant: AlertColor
  onClose: () => void
} & Notification) => {
  const dispatch = useAppDispatch()

  const handleClose = (_: Event | SyntheticEvent, reason?: SnackbarCloseReason) => {
    if (reason === 'clickaway') return

    // Manually closed
    if (!reason) {
      dispatch(readNotification({ id }))
    }

    onClose()
  }

  const autoHideDuration = variant === 'info' || variant === 'success' ? 5000 : undefined

  return (
    <Snackbar open onClose={handleClose} sx={toastStyle} autoHideDuration={autoHideDuration}>
      <Alert severity={variant} onClose={handleClose} elevation={3} sx={{ width: '340px' }}>
        {title && (
          <Typography variant="body2" fontWeight="700">
            {title}
          </Typography>
        )}

        {message}

        {detailedMessage && (
          <details>
            <Link component="summary">Details</Link>
            <pre>{detailedMessage}</pre>
          </details>
        )}
        <NotificationLink link={link} onClick={handleClose} />
      </Alert>
    </Snackbar>
  )
}

const getVisibleNotifications = (notifications: Notification[]) => {
  return notifications.filter((notification) => !notification.isDismissed)
}

const Notifications = (): ReactElement | null => {
  const notifications = useAppSelector(selectNotifications)
  const dispatch = useAppDispatch()

  const visible = getVisibleNotifications(notifications)

  const visibleItems = visible.length

  const handleClose = useCallback(
    (item: Notification) => {
      dispatch(closeNotification(item))
      item.onClose?.()
    },
    [dispatch],
  )

  // Close previous notifications in the same group
  useEffect(() => {
    const groups: Record<string, Notification[]> = groupBy(notifications, 'groupKey')

    Object.values(groups).forEach((items) => {
      const previous = getVisibleNotifications(items).slice(0, -1)
      previous.forEach(handleClose)
    })
  }, [notifications, handleClose])

  if (visibleItems === 0) {
    return null
  }

  return (
    <div className={css.container}>
      {visible.map((item) => (
        <div className={css.row} key={item.id}>
          <Toast {...item} onClose={() => handleClose(item)} />
        </div>
      ))}
    </div>
  )
}

export default Notifications
</file>

<file path="src/components/common/Notifications/styles.module.css">
.container {
  position: fixed;
  top: var(--header-height);
  right: 0;
  z-index: 2000;
}

.row {
  max-width: 400px;
  display: flex;
  justify-content: flex-end;
  word-break: break-word;
}

.link {
  text-decoration: none;
  font-weight: 700;
  display: flex;
  align-items: center;
  margin-top: 0.3em;
}

.container details {
  margin-bottom: var(--space-1);
  max-height: 200px;
  overflow: auto;
}

.container pre {
  margin: var(--space-1) 0 var(--space-2);
  white-space: pre-wrap;
  color: var(--color-primary-light);
}

.container summary {
  text-decoration: underline;
  cursor: pointer;
  list-style: none;
  margin-top: 4px;
}

.container summary::-webkit-details-marker {
  display: none;
}
</file>

<file path="src/components/common/Notifications/useCounter.ts">
import { useEffect, useState } from 'react'

export const useCounter = (startTimestamp: number | undefined) => {
  const [counter, setCounter] = useState<number>()

  useEffect(() => {
    const update = () => {
      if (startTimestamp) {
        setCounter(Math.floor((Date.now() - startTimestamp) / 1000))
      }
    }

    const interval = setInterval(update, 1000)

    return () => clearInterval(interval)
  }, [startTimestamp])

  return counter
}
</file>

<file path="src/components/common/NumberField/index.tsx">
import { TextField } from '@mui/material'
import { forwardRef } from 'react'
import type { TextFieldProps } from '@mui/material'
import type { ReactElement } from 'react'

export const _formatNumber = (value: string) => {
  value = value.trim()

  if (value === '') {
    return value
  }

  // Replace commas with dots (used as decimal separator)
  value = value.replace(/,/g, '.')

  let index = 0
  // replace all dots except the first one
  value = value.replace(/\./g, (item) => (index++ === 0 ? item : ''))

  // Remove all characters except numbers and dots
  value = value.replace(/[^0-9.]/g, '')

  if (value.length > 1) {
    // Remove leading zeros from the string
    value = value.replace(/^0+/, '')
  }

  // If the string starts with a decimal point, add a leading zero
  if (value.startsWith('.')) {
    value = '0' + value
  }

  return value
}

const NumberField = forwardRef<HTMLInputElement, TextFieldProps>(({ onChange, ...props }, ref): ReactElement => {
  return (
    <TextField
      autoComplete="off"
      ref={ref}
      onChange={(event) => {
        event.target.value = _formatNumber(event.target.value)
        return onChange?.(event)
      }}
      {...props}
      inputProps={{
        ...props.inputProps,
        // Autocomplete passes `onChange` in `inputProps`
        onChange: (event) => {
          // inputProps['onChange'] is generically typed
          if ('value' in event.target && typeof event.target.value === 'string') {
            event.target.value = _formatNumber(event.target.value)
            return props.inputProps?.onChange?.(event)
          }
        },
      }}
    />
  )
})

NumberField.displayName = 'NumberField'

export default NumberField
</file>

<file path="src/components/common/OnboardingTooltip/index.tsx">
import type { ReactElement } from 'react'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import type { TooltipProps } from '@mui/material'
import { Box, Button, SvgIcon, Tooltip } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import { useDarkMode } from '@/hooks/useDarkMode'

/**
 * The OnboardingTooltip renders a sticky Tooltip with an arrow pointing towards the wrapped component.
 * This Tooltip contains a button to hide it. This decision will be stored in the local storage such that the OnboardingTooltip will only popup until clicked away once.
 */
export const OnboardingTooltip = ({
  children,
  widgetLocalStorageId,
  text,
  initiallyShown = true,
  className,
  placement,
}: {
  children: ReactElement // NB: this has to be an actual HTML element, otherwise the Tooltip will not work
  widgetLocalStorageId: string
  text: string | ReactElement
  initiallyShown?: boolean
  className?: string
  placement?: TooltipProps['placement']
}): ReactElement => {
  const [widgetHidden = !initiallyShown, setWidgetHidden] = useLocalStorage<boolean>(widgetLocalStorageId)
  const isDarkMode = useDarkMode()

  return widgetHidden || !text ? (
    children
  ) : (
    <Tooltip
      PopperProps={{
        className,
        disablePortal: true,
      }}
      open
      placement={placement}
      arrow
      title={
        <Box display="flex" alignItems="center" gap={1} p={1}>
          <SvgIcon component={InfoIcon} inheritViewBox fontSize="small" />
          <div style={{ minWidth: '150px' }}>{text}</div>
          <Button
            size="small"
            color={isDarkMode ? 'background' : 'secondary'}
            variant="text"
            sx={{ whiteSpace: 'nowrap' }}
            onClick={() => setWidgetHidden(true)}
          >
            Got it!
          </Button>
        </Box>
      }
    >
      {children}
    </Tooltip>
  )
}
</file>

<file path="src/components/common/OnlyOwner/index.tsx">
import { useMemo, type ReactElement } from 'react'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import useWallet from '@/hooks/wallets/useWallet'
import useConnectWallet from '../ConnectWallet/useConnectWallet'
import { Tooltip } from '@mui/material'

type CheckWalletProps = {
  children: (ok: boolean) => ReactElement
}

enum Message {
  WalletNotConnected = 'Please connect your wallet',
  NotSafeOwner = 'Your connected wallet is not a signer of this Safe Account',
}

const OnlyOwner = ({ children }: CheckWalletProps): ReactElement => {
  const wallet = useWallet()
  const isSafeOwner = useIsSafeOwner()
  const connectWallet = useConnectWallet()

  const message = useMemo(() => {
    if (!wallet) {
      return Message.WalletNotConnected
    }

    if (!isSafeOwner) {
      return Message.NotSafeOwner
    }
  }, [isSafeOwner, wallet])

  if (!message) return children(true)

  return (
    <Tooltip title={message}>
      <span onClick={wallet ? undefined : connectWallet}>{children(false)}</span>
    </Tooltip>
  )
}

export default OnlyOwner
</file>

<file path="src/components/common/PageHeader/index.tsx">
import { Box, Typography } from '@mui/material'
import classNames from 'classnames'

import type { ReactElement } from 'react'

import css from './styles.module.css'

const PageHeader = ({
  title,
  action,
  noBorder,
}: {
  title: string
  action?: ReactElement
  noBorder?: boolean
}): ReactElement => {
  return (
    <Box className={classNames(css.container, { [css.border]: !noBorder })}>
      <Typography variant="h3" className={css.title}>
        {title}
      </Typography>
      {action}
    </Box>
  )
}

export default PageHeader
</file>

<file path="src/components/common/PageHeader/styles.module.css">
.container {
  padding: var(--space-4) var(--space-3) 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  background-color: var(--color-background-main);
  z-index: 2;
  width: 100%;
  position: sticky !important;
  top: calc(var(--header-height) - 76px);
}

.title {
  font-weight: 700;
  margin-bottom: var(--space-3);
}

.border {
  border-bottom: 1px solid var(--color-border-light);
}

.pageHeader,
.actionsWrapper {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.actionsWrapper {
  gap: var(--space-1);
}

@media (max-width: 599.95px) {
  .container {
    padding: var(--space-3) var(--space-2) 0;
  }

  .border {
    border: 0;
  }

  .pageHeader {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--space-3);
  }

  .navWrapper {
    border-bottom: 1px solid var(--color-border-light);
    margin-left: calc(var(--space-2) * -1);
    padding-left: var(--space-2);
    margin-right: calc(var(--space-2) * -1);
    padding-right: var(--space-2);
    align-self: stretch;
  }

  .actionsWrapper {
    padding-bottom: 16px;
  }
}
</file>

<file path="src/components/common/PageLayout/index.tsx">
import { useContext, useEffect, useState, type ReactElement } from 'react'
import classnames from 'classnames'

import Header from '@/components/common/Header'
import css from './styles.module.css'
import SafeLoadingError from '../SafeLoadingError'
import Footer from '../Footer'
import SideDrawer from './SideDrawer'
import { useIsSidebarRoute } from '@/hooks/useIsSidebarRoute'
import { TxModalContext } from '@/components/tx-flow'
import BatchSidebar from '@/components/batch/BatchSidebar'
import Breadcrumbs from '@/components/common/Breadcrumbs'

const PageLayout = ({ pathname, children }: { pathname: string; children: ReactElement }): ReactElement => {
  const [isSidebarRoute, isAnimated] = useIsSidebarRoute(pathname)
  const [isSidebarOpen, setSidebarOpen] = useState<boolean>(true)
  const [isBatchOpen, setBatchOpen] = useState<boolean>(false)
  const { setFullWidth } = useContext(TxModalContext)

  useEffect(() => {
    setFullWidth(!isSidebarOpen)
  }, [isSidebarOpen, setFullWidth])

  return (
    <>
      <header className={css.header}>
        <Header onMenuToggle={isSidebarRoute ? setSidebarOpen : undefined} onBatchToggle={setBatchOpen} />
      </header>

      {isSidebarRoute ? <SideDrawer isOpen={isSidebarOpen} onToggle={setSidebarOpen} /> : null}

      <div
        className={classnames(css.main, {
          [css.mainNoSidebar]: !isSidebarOpen || !isSidebarRoute,
          [css.mainAnimated]: isSidebarRoute && isAnimated,
        })}
      >
        <div className={css.content}>
          <SafeLoadingError>
            <Breadcrumbs />
            {children}
          </SafeLoadingError>
        </div>

        <BatchSidebar isOpen={isBatchOpen} onToggle={setBatchOpen} />

        <Footer />
      </div>
    </>
  )
}

export default PageLayout
</file>

<file path="src/components/common/PageLayout/SideDrawer.tsx">
import SpaceSidebar from 'src/features/spaces/components/SpaceSidebar'
import { useIsSpaceRoute } from '@/hooks/useIsSpaceRoute'
import { useRouter } from 'next/router'
import { useEffect, type ReactElement } from 'react'
import { IconButton, Drawer, useMediaQuery } from '@mui/material'
import { useTheme } from '@mui/material/styles'
import DoubleArrowRightIcon from '@mui/icons-material/KeyboardDoubleArrowRightRounded'
import DoubleArrowLeftIcon from '@mui/icons-material/KeyboardDoubleArrowLeftRounded'

import classnames from 'classnames'
import Sidebar from '@/components/sidebar/Sidebar'
import css from './styles.module.css'
import useDebounce from '@/hooks/useDebounce'
import { useIsSidebarRoute } from '@/hooks/useIsSidebarRoute'

type SideDrawerProps = {
  isOpen: boolean
  onToggle: (isOpen: boolean) => void
}

const SideDrawer = ({ isOpen, onToggle }: SideDrawerProps): ReactElement => {
  const { breakpoints } = useTheme()
  const isSmallScreen = useMediaQuery(breakpoints.down('md'))
  const [, isSafeAppRoute] = useIsSidebarRoute()
  const isSpaceRoute = useIsSpaceRoute()

  const showSidebarToggle = isSafeAppRoute && !isSmallScreen
  // Keep the sidebar hidden on small screens via CSS until we collapse it via JS.
  // With a small delay to avoid flickering.
  const smDrawerHidden = useDebounce(!isSmallScreen, 300)
  const router = useRouter()

  useEffect(() => {
    const closeSidebar = isSmallScreen || isSafeAppRoute
    onToggle(!closeSidebar)
  }, [isSmallScreen, isSafeAppRoute, onToggle])

  // Close the drawer whenever the route changes
  useEffect(() => {
    const onRouteChange = () => isSmallScreen && onToggle(false)
    router.events.on('routeChangeStart', onRouteChange)

    return () => {
      router.events.off('routeChangeStart', onRouteChange)
    }
  }, [onToggle, router, isSmallScreen])

  const SidebarComponent = isSpaceRoute ? SpaceSidebar : Sidebar

  return (
    <>
      <Drawer
        variant={isSmallScreen ? 'temporary' : 'persistent'}
        anchor="left"
        open={isOpen}
        onClose={() => onToggle(false)}
        sx={{
          // fixes a bug on small screens where the drawer is not visible,
          // but it steals all the events from the rest of the page
          position: 'relative',
        }}
        className={smDrawerHidden ? css.smDrawerHidden : undefined}
      >
        <aside>
          <SidebarComponent />
        </aside>
      </Drawer>

      {showSidebarToggle && (
        <div className={classnames(css.sidebarTogglePosition, isOpen && css.sidebarOpen)}>
          <div className={css.sidebarToggle} role="button" onClick={() => onToggle(!isOpen)}>
            <IconButton aria-label="collapse sidebar" size="small" disableRipple>
              {isOpen ? <DoubleArrowLeftIcon fontSize="inherit" /> : <DoubleArrowRightIcon fontSize="inherit" />}
            </IconButton>
          </div>
        </div>
      )}
    </>
  )
}

export default SideDrawer
</file>

<file path="src/components/common/PageLayout/styles.module.css">
.header {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  z-index: 1201;
  background: var(--color-background-paper);
  padding-top: env(safe-area-inset-top);
}

.main {
  background-color: var(--color-background-main);
  padding-left: 230px;
  padding-top: calc(var(--header-height) + env(safe-area-inset-top));
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.mainAnimated {
  transition: padding 225ms cubic-bezier(0, 0, 0.2, 1) 0ms;
}

.mainNoSidebar {
  padding-left: 0;
}

.content {
  flex: 1;
  position: relative;
  display: flex;
  flex-direction: column;
  flex-wrap: wrap;
}

.content main {
  padding: var(--space-3);
}

.sidebarTogglePosition {
  position: fixed;
  z-index: 4;
  left: 0;
  top: 0;
  /* mimics MUI drawer animation */
  transition: transform 225ms cubic-bezier(0, 0, 0.2, 1) 0ms;
}

.sidebarTogglePosition.sidebarOpen {
  transform: translateX(230px);
}

.sidebarToggle {
  height: 100vh;
  width: var(--space-1);
  background-color: var(--color-border-light);
  transition: background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
  cursor: pointer;
}

.sidebarToggle button {
  position: absolute;
  z-index: 1;
  top: 50%;
  left: -3px;
  transform: translateY(-50%);
  background-color: var(--color-border-light);
  clip-path: inset(0 -14px 0 0);
  transition: background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
}

.sidebarToggle:hover,
.sidebarToggle:hover button {
  background-color: var(--color-background-light);
}

@media (max-width: 899.95px) {
  .main {
    padding-left: 0;
  }

  .smDrawerHidden {
    display: none;
  }
}

@media (max-width: 599.95px) {
  .main main {
    padding: var(--space-2);
  }
}
</file>

<file path="src/components/common/PagePlaceholder/index.tsx">
import type { ReactElement, ReactNode } from 'react'
import { Typography } from '@mui/material'
import css from './styles.module.css'

type PagePlaceholderProps = {
  img: ReactNode
  text: ReactNode
  children?: ReactNode
}

const PagePlaceholder = ({ img, text, children }: PagePlaceholderProps): ReactElement => {
  return (
    <div className={css.container}>
      {img}

      {typeof text === 'string' ? (
        <Typography variant="body1" color="primary.light" mt={2}>
          {text}
        </Typography>
      ) : (
        text
      )}

      {children}
    </div>
  )
}

export default PagePlaceholder
</file>

<file path="src/components/common/PagePlaceholder/styles.module.css">
.container {
  padding: 5vh 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  flex: 1;
}
</file>

<file path="src/components/common/PaginatedTxns/index.tsx">
import { type ReactElement, useEffect, useState } from 'react'
import { Box } from '@mui/material'
import TxList from '@/components/transactions/TxList'
import { type TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import ErrorMessage from '@/components/tx/ErrorMessage'
import type useTxHistory from '@/hooks/useTxHistory'
import useTxQueue from '@/hooks/useTxQueue'
import PagePlaceholder from '../PagePlaceholder'
import InfiniteScroll from '../InfiniteScroll'
import SkeletonTxList from './SkeletonTxList'
import { type TxFilter, useTxFilter } from '@/utils/tx-history-filter'
import { isTransactionListItem } from '@/utils/transaction-guards'
import NoTransactionsIcon from '@/public/images/transactions/no-transactions.svg'
import { useHasPendingTxs } from '@/hooks/usePendingTxs'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useRecoveryQueue } from '@/features/recovery/hooks/useRecoveryQueue'

const NoQueuedTxns = () => {
  return <PagePlaceholder img={<NoTransactionsIcon />} text="Queued transactions will appear here" />
}

const getFilterResultCount = (filter: TxFilter, page: TransactionListPage) => {
  const count = page.results.filter(isTransactionListItem).length

  return `${page.next ? '> ' : ''}${count} ${filter.type} transactions found`.toLowerCase()
}

const TxPage = ({
  pageUrl,
  useTxns,
  onNextPage,
  isFirstPage,
}: {
  pageUrl: string
  useTxns: typeof useTxHistory | typeof useTxQueue
  onNextPage?: (pageUrl: string) => void
  isFirstPage: boolean
}): ReactElement => {
  const { page, error, loading } = useTxns(pageUrl)
  const [filter] = useTxFilter()
  const isQueue = useTxns === useTxQueue
  const recoveryQueue = useRecoveryQueue()
  const hasPending = useHasPendingTxs()

  return (
    <>
      {isFirstPage && filter && page && (
        <Box display="flex" flexDirection="column" alignItems="flex-end" pt={[2, 0]} pb={3}>
          {getFilterResultCount(filter, page)}
        </Box>
      )}

      {page && page.results.length > 0 && <TxList items={page.results} />}

      {isQueue && page?.results.length === 0 && recoveryQueue.length === 0 && !hasPending && <NoQueuedTxns />}

      {error && <ErrorMessage>Error loading transactions</ErrorMessage>}

      {/* No skeletons for pending as they are shown above the queue which has them */}
      {loading && !hasPending && <SkeletonTxList />}

      {page?.next && onNextPage && (
        <Box my={4} textAlign="center">
          <InfiniteScroll onLoadMore={() => onNextPage(page.next!)} />
        </Box>
      )}
    </>
  )
}

const PaginatedTxns = ({ useTxns }: { useTxns: typeof useTxHistory | typeof useTxQueue }): ReactElement => {
  const [pages, setPages] = useState<string[]>([''])
  const [filter] = useTxFilter()
  const { safeAddress, safe } = useSafeInfo()

  // Reset the pages when the Safe Account or filter changes
  useEffect(() => {
    setPages([''])
  }, [filter, safe.chainId, safeAddress, useTxns])

  // Trigger the next page load
  const onNextPage = (pageUrl: string) => {
    setPages((prev) => prev.concat(pageUrl))
  }

  return (
    <Box position="relative">
      {pages.map((pageUrl, index) => (
        <TxPage
          key={pageUrl}
          pageUrl={pageUrl}
          useTxns={useTxns}
          isFirstPage={index === 0}
          onNextPage={index === pages.length - 1 ? onNextPage : undefined}
        />
      ))}
    </Box>
  )
}

export default PaginatedTxns
</file>

<file path="src/components/common/PaginatedTxns/SkeletonTxList.tsx">
import { Skeleton } from '@mui/material'

const SkeletonTxList = () => {
  const label = <Skeleton variant="text" width="10em" sx={{ mt: '20px', mb: 1 }} />

  const item = (i: number) => <Skeleton key={String(i)} height={54} sx={{ mb: '6px' }} variant="rounded" />

  return (
    <>
      {label}
      {Array.from(Array(3).keys()).map(item)}

      {label}
      {Array.from(Array(2).keys()).map(item)}
    </>
  )
}

export default SkeletonTxList
</file>

<file path="src/components/common/PaperViewToggle/index.tsx">
import type { ReactNode } from 'react'
import React, { useState } from 'react'
import { Paper, Stack } from '@mui/material'
import { ToggleButtonGroup } from '@/components/common/ToggleButtonGroup'

type PaperViewToggleProps = {
  children: {
    title: ReactNode
    content: ReactNode
  }[]
  activeView?: number
  leftAlign?: boolean
}

export const PaperViewToggle = ({ children, leftAlign, activeView = 0 }: PaperViewToggleProps) => {
  const [active, setActive] = useState(activeView)

  const onChangeView = (index: number) => {
    setActive(index)
  }

  const Content = ({ index }: { index: number }) => children?.[index]?.content || null

  return (
    <Paper
      sx={{
        backgroundColor: 'background.main',
        pt: 1,
        pb: 1.5,
      }}
    >
      <Stack spacing={2}>
        <Stack direction={leftAlign ? 'row' : 'row-reverse'} justifyContent="space-between" px={2} py={1}>
          <ToggleButtonGroup onChange={onChangeView}>{children}</ToggleButtonGroup>
        </Stack>

        <Content index={active} />
      </Stack>
    </Paper>
  )
}
</file>

<file path="src/components/common/Popup/index.tsx">
import { Paper, Popover } from '@mui/material'
import type { PopoverProps } from '@mui/material'
import type { ReactElement } from 'react'

const Popup = ({ children, ...props }: PopoverProps): ReactElement => {
  return (
    <Popover
      anchorOrigin={{
        vertical: 'bottom',
        horizontal: 'center',
      }}
      transformOrigin={{
        vertical: 'top',
        horizontal: 'center',
      }}
      sx={{
        '& > .MuiPaper-root': {
          top: 'var(--header-height) !important',
          overflowY: 'auto',
        },
      }}
      {...props}
    >
      <Paper sx={{ p: 4, width: '454px' }}>{children}</Paper>
    </Popover>
  )
}

export default Popup
</file>

<file path="src/components/common/ProgressBar/index.tsx">
import { LinearProgress } from '@mui/material'
import type { LinearProgressProps } from '@mui/material'

import css from './styles.module.css'

export const ProgressBar = (props: LinearProgressProps) => {
  return <LinearProgress className={css.progressBar} variant="determinate" color="secondary" {...props} />
}
</file>

<file path="src/components/common/ProgressBar/styles.module.css">
.progressBar {
  height: 6px;
  border-radius: 6px;
  background-color: var(--color-border-light);
}

.progressBar :global .MuiLinearProgress-bar {
  background: var(--color-primary-main);
  border-radius: 6px;
}

[data-theme='light'] .progressBar :global .MuiLinearProgress-bar {
  background: var(--color-secondary-main);
}

@media (max-width: 599.95px) {
  .progressBar {
    border-radius: 0;
  }
}
</file>

<file path="src/components/common/QRCode/index.tsx">
import QRCodeReact from 'qrcode.react'
import { Skeleton } from '@mui/material'
import { useTheme } from '@mui/material/styles'
import type { ReactElement } from 'react'

const QR_LOGO_SIZE = 20

const QRCode = ({ value, size }: { value?: string; size: number }): ReactElement => {
  const { palette } = useTheme()

  return value ? (
    <QRCodeReact
      value={value}
      size={size}
      bgColor={palette.background.paper}
      fgColor={palette.text.primary}
      imageSettings={{
        src: '/images/safe-logo-green.png',
        width: QR_LOGO_SIZE,
        height: QR_LOGO_SIZE,
        excavate: true,
      }}
    />
  ) : (
    <Skeleton variant="rectangular" width={size} height={size} />
  )
}

export default QRCode
</file>

<file path="src/components/common/SafeIcon/index.tsx">
import type { ReactElement } from 'react'
import { Box, Skeleton } from '@mui/material'

import css from './styles.module.css'
import Identicon, { type IdenticonProps } from '../Identicon'
import { useChain } from '@/hooks/useChains'

interface ThresholdProps {
  threshold: number | string
  owners: number | string
}
const Threshold = ({ threshold, owners }: ThresholdProps): ReactElement => (
  <Box className={css.threshold} sx={{ color: ({ palette }) => palette.static.main }}>
    {threshold}/{owners}
  </Box>
)

interface SafeIconProps extends IdenticonProps {
  threshold?: ThresholdProps['threshold']
  owners?: ThresholdProps['owners']
  size?: number
  chainId?: string
  isMultiChainItem?: boolean
}

export const ChainIcon = ({ chainId }: { chainId: string }) => {
  const chainConfig = useChain(chainId)

  if (!chainConfig) {
    return <Skeleton variant="circular" width={40} height={40} />
  }

  return (
    <img
      src={chainConfig.chainLogoUri ?? undefined}
      alt={`${chainConfig.chainName} Logo`}
      width={40}
      height={40}
      loading="lazy"
    />
  )
}

const SafeIcon = ({
  address,
  threshold,
  owners,
  size,
  chainId,
  isMultiChainItem = false,
}: SafeIconProps): ReactElement => {
  return (
    <div data-testid="safe-icon" className={css.container}>
      {threshold && owners ? <Threshold threshold={threshold} owners={owners} /> : null}
      {isMultiChainItem && chainId ? <ChainIcon chainId={chainId} /> : <Identicon address={address} size={size} />}
    </div>
  )
}

export default SafeIcon
</file>

<file path="src/components/common/SafeIcon/styles.module.css">
.container {
  position: relative;
}

.threshold {
  position: absolute;
  top: -6px;
  right: -6px;
  z-index: 2;
  border-radius: 100%;
  font-size: 12px;
  min-width: 24px;
  min-height: 24px;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  line-height: 16px;
  font-weight: 700;
  background-color: var(--color-secondary-light);
}
</file>

<file path="src/components/common/SafeLoadingError/index.tsx">
import type { ReactElement, ReactNode } from 'react'
import { Button } from '@mui/material'
import useSafeInfo from '@/hooks/useSafeInfo'
import PagePlaceholder from '../PagePlaceholder'
import { AppRoutes } from '@/config/routes'
import Link from 'next/link'

const SafeLoadingError = ({ children }: { children: ReactNode }): ReactElement => {
  const { safeError } = useSafeInfo()

  if (!safeError) return <>{children}</>

  return (
    <PagePlaceholder
      img={<img src="/images/common/error.png" alt="A vault with a red icon in the bottom right corner" />}
      text="This Safe Account couldn't be loaded"
    >
      <Link href={AppRoutes.welcome.index} passHref legacyBehavior>
        <Button variant="contained" color="primary" size="large" sx={{ mt: 2 }}>
          Go to the main page
        </Button>
      </Link>
    </PagePlaceholder>
  )
}

export default SafeLoadingError
</file>

<file path="src/components/common/SafeTokenWidget/index.tsx">
import UnreadBadge from '@/components/common/UnreadBadge'
import { IS_PRODUCTION, SAFE_TOKEN_ADDRESSES, SAFE_LOCKING_ADDRESS } from '@/config/constants'
import { AppRoutes } from '@/config/routes'
import useChainId from '@/hooks/useChainId'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import type { Vesting } from '@/hooks/useSafeTokenAllocation'
import useSafeTokenAllocation, { useSafeVotingPower } from '@/hooks/useSafeTokenAllocation'
import { OVERVIEW_EVENTS } from '@/services/analytics'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { Box, ButtonBase, Divider, Skeleton, SvgIcon, Tooltip, Typography } from '@mui/material'
import Link from 'next/link'
import { useSearchParams } from 'next/navigation'
import Track from '../Track'
import SafeTokenIcon from '@/public/images/common/safe-token.svg'
import SafePassStar from '@/public/images/common/safe-pass-star.svg'
import css from './styles.module.css'
import { useSanctionedAddress } from '@/hooks/useSanctionedAddress'
import useSafeAddress from '@/hooks/useSafeAddress'
import { skipToken } from '@reduxjs/toolkit/query/react'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useGetOwnGlobalCampaignRankQuery } from '@/store/api/safePass'
import { formatAmount } from '@safe-global/utils/utils/formatNumber'

const TOKEN_DECIMALS = 18

const canRedeemSAPUnboostedAllocation = (allocation?: Vesting[]): boolean => {
  const sapUnboostedAllocation = allocation?.find(({ tag }) => tag === 'sap_unboosted')

  if (!sapUnboostedAllocation) {
    return false
  }

  return !sapUnboostedAllocation.isRedeemed && !sapUnboostedAllocation.isExpired
}

const SAP_REDEEM_DEADLINE = '06.12.2025'

export const getSafeTokenAddress = (chainId: string): string | undefined => {
  return SAFE_TOKEN_ADDRESSES[chainId]
}

export const getSafeLockingAddress = (chainId: string): string | undefined => {
  return SAFE_LOCKING_ADDRESS[chainId]
}

const GOVERNANCE_APP_URL = IS_PRODUCTION ? 'https://community.safe.global' : 'https://safe-dao-governance.dev.5afe.dev'

const SafeTokenWidget = () => {
  const chainId = useChainId()
  const safeAddress = useSafeAddress()
  const query = useSearchParams()
  const darkMode = useDarkMode()
  const isSafeOwner = useIsSafeOwner()

  const [allocationData, , allocationDataLoading] = useSafeTokenAllocation()
  const [allocation, , allocationLoading] = useSafeVotingPower(allocationData)

  const sanctionedAddress = useSanctionedAddress()
  const { data: ownGlobalRank, isLoading: ownGlobalRankLoading } = useGetOwnGlobalCampaignRankQuery(
    chainId !== '1' && chainId !== '11155111' ? skipToken : { chainId, safeAddress },
    { refetchOnFocus: false },
  )

  const tokenAddress = getSafeTokenAddress(chainId)
  if (!tokenAddress || Boolean(sanctionedAddress)) {
    return null
  }

  const url = {
    pathname: AppRoutes.apps.open,
    query: { safe: query?.get('safe'), appUrl: GOVERNANCE_APP_URL },
  }

  const flooredSafeBalance = formatVisualAmount(allocation || BigInt(0), TOKEN_DECIMALS, 0)
  const canRedeemSAPUnboosted = canRedeemSAPUnboostedAllocation(allocationData) && isSafeOwner

  return (
    <Box className={css.container}>
      <Tooltip
        title={
          url
            ? canRedeemSAPUnboosted
              ? `Redeem your allocation before ${SAP_REDEEM_DEADLINE} to be eligible!`
              : 'Go to Safe{DAO} Governance'
            : ''
        }
      >
        <span>
          <Track {...OVERVIEW_EVENTS.SAFE_TOKEN_WIDGET}>
            <Link href={url} passHref legacyBehavior>
              <ButtonBase aria-describedby="safe-token-widget" className={css.tokenButton} disabled={url === undefined}>
                <SafeTokenIcon width={24} height={24} />
                <Typography
                  component="div"
                  variant="body2"
                  lineHeight={1}
                  // Badge does not accept className so must be here
                  className={css.allocationBadge}
                >
                  <UnreadBadge
                    invisible={!canRedeemSAPUnboosted}
                    anchorOrigin={{
                      vertical: 'bottom',
                      horizontal: 'right',
                    }}
                  >
                    {allocationDataLoading || allocationLoading ? (
                      <Skeleton width="16px" animation="wave" />
                    ) : (
                      flooredSafeBalance
                    )}
                  </UnreadBadge>
                </Typography>

                <Divider orientation="vertical" />
                <SvgIcon
                  component={SafePassStar}
                  width={24}
                  height={24}
                  inheritViewBox
                  color={darkMode ? 'primary' : undefined}
                />
                <Typography
                  component="div"
                  variant="body2"
                  lineHeight="20px"
                  // Badge does not accept className so must be here
                  className={css.allocationBadge}
                >
                  {ownGlobalRankLoading ? (
                    <Skeleton width="16px" animation="wave" />
                  ) : (
                    formatAmount(Math.floor(ownGlobalRank?.totalBoostedPoints ?? 0), 0)
                  )}
                </Typography>
              </ButtonBase>
            </Link>
          </Track>
        </span>
      </Tooltip>
    </Box>
  )
}

export default SafeTokenWidget
</file>

<file path="src/components/common/SafeTokenWidget/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-1);
  height: 100%;
  justify-content: center;
  margin: 0 var(--space-2);
}

.tokenButton {
  display: flex;
  border-radius: 6px;
  padding: 0px var(--space-1) 0px var(--space-1);
  background-color: var(--color-border-background);
  margin: var(--space-1);
  height: 30px;
  align-items: center;
  justify-content: center;
  gap: var(--space-1);
  margin-left: 0;
  margin-right: 0;
  align-self: stretch;
}

.sep5 {
  height: 42px;
}

[data-theme='dark'] .allocationBadge :global .MuiBadge-dot {
  background-color: var(--color-primary-main);
}

.redeemButton {
  margin-left: var(--space-1);
  padding: calc(var(--space-1) / 2) var(--space-1);
}
</file>

<file path="src/components/common/SpendingLimitLabel/index.tsx">
import React, { type ReactElement } from 'react'
import { Box, SvgIcon, Typography } from '@mui/material'
import SpeedIcon from '@/public/images/settings/spending-limit/speed.svg'
import type { BoxProps } from '@mui/system'

const SpendingLimitLabel = ({
  label,
  isOneTime = false,
  ...rest
}: { label: string | ReactElement; isOneTime?: boolean } & BoxProps) => {
  return (
    <Box display="flex" alignItems="center" gap="4px" {...rest}>
      {!isOneTime && <SvgIcon component={SpeedIcon} inheritViewBox color="border" fontSize="medium" />}
      {typeof label === 'string' ? <Typography>{label}</Typography> : label}
    </Box>
  )
}

export default SpendingLimitLabel
</file>

<file path="src/components/common/SplitMenuButton/index.tsx">
import { useEffect, useMemo, useRef, useState, type SyntheticEvent } from 'react'
import Button from '@mui/material/Button'
import ButtonGroup from '@mui/material/ButtonGroup'
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown'
import MenuItem from '@mui/material/MenuItem'
import MenuList from '@mui/material/MenuList'
import { Box, CircularProgress, ListItemText, Popover, Tooltip } from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'

type Option = {
  id: string
  label?: string
}

export default function SplitMenuButton({
  options,
  disabled = false,
  tooltip,
  onClick,
  onChange,
  selected,
  disabledIndex,
  loading = false,
}: {
  options: Option[]
  disabled?: boolean
  tooltip?: string
  onClick?: (option: Option, e: SyntheticEvent) => void
  onChange?: (option: Option) => void
  selected?: Option['id']
  disabledIndex?: number
  loading?: boolean
}) {
  const [open, setOpen] = useState(false)
  const anchorRef = useRef<HTMLDivElement>(null)
  const [selectedIndex, setSelectedIndex] = useState(0)

  useEffect(() => {
    if (selected) {
      const index = options.findIndex((option) => option.id === selected)
      if (index !== -1) {
        setSelectedIndex(index)
      }
    }
  }, [selected, options])

  const handleClick = (e: SyntheticEvent) => {
    onClick?.(options[selectedIndex], e)
  }

  const handleMenuItemClick = (e: React.MouseEvent<HTMLLIElement, MouseEvent>, index: number) => {
    e.preventDefault()

    if (index !== selectedIndex) {
      setSelectedIndex(index)
      setOpen(false)
      onChange?.(options[index])
    }
  }

  const handleToggle = () => {
    setOpen((prevOpen) => !prevOpen)
  }

  const handleClose = (event: Event) => {
    if (anchorRef.current && anchorRef.current.contains(event.target as HTMLElement)) {
      return
    }

    setOpen(false)
  }

  const { label, id } = useMemo(() => options[selectedIndex] || {}, [options, selectedIndex])
  const maxCharLen = Math.max(...options.map(({ id, label }) => (label || id).length)) + 2

  return (
    <>
      <ButtonGroup variant="contained" ref={anchorRef} aria-label="Button group with a nested menu" fullWidth>
        <Tooltip title={tooltip} placement="top">
          <Box flex={1}>
            <Button
              data-testid={`combo-submit-${id}`}
              onClick={handleClick}
              type="submit"
              disabled={disabled}
              sx={{ minWidth: `${maxCharLen}ch !important` }}
            >
              {loading ? <CircularProgress size={20} /> : label || id}
            </Button>
          </Box>
        </Tooltip>

        {options.length > 1 && (
          <Button
            size="small"
            aria-expanded={open ? 'true' : undefined}
            aria-label="select action"
            aria-haspopup="menu"
            onClick={handleToggle}
            disabled={loading}
            sx={{ minWidth: '0 !important', maxWidth: 48, px: 1.5 }}
          >
            <ArrowDropDownIcon />
          </Button>
        )}
      </ButtonGroup>

      <Popover
        open={open}
        anchorEl={anchorRef.current}
        onClose={handleClose}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'right',
        }}
        transformOrigin={{ horizontal: 'right', vertical: -2 }}
        slotProps={{
          root: { slotProps: { backdrop: { sx: { backgroundColor: 'transparent' } } } },
        }}
      >
        <MenuList autoFocusItem>
          {options.map((option, index) => (
            <MenuItem
              key={option.id}
              selected={index === selectedIndex}
              disabled={disabledIndex === index}
              onClick={(event) => handleMenuItemClick(event, index)}
              sx={{ gap: 2 }}
            >
              <ListItemText>{option.label || option.id}</ListItemText>
              {index === selectedIndex ? <CheckIcon /> : <Box sx={{ width: 24 }} />}
            </MenuItem>
          ))}
        </MenuList>
      </Popover>
    </>
  )
}
</file>

<file path="src/components/common/Sticky/index.tsx">
import { Box } from '@mui/material'
import type { ReactElement } from 'react'

const stickyTop = { xs: '103px', md: '111px' }
export const Sticky = ({ children }: { children: ReactElement }): ReactElement => (
  <Box
    sx={{
      position: 'sticky',
      zIndex: '1',
      top: stickyTop,
      py: 1,
      bgcolor: 'background.main',
      mt: -1,
      mb: 1,
    }}
  >
    {children}
  </Box>
)
</file>

<file path="src/components/common/Table/DataRow.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { DataRow } from './DataRow'
import { Paper } from '@mui/material'

const meta = {
  component: DataRow,
  parameters: {
    componentSubtitle: 'A simple label<=>value pair row for a table',
  },
  argTypes: {
    title: {
      description: 'The label for the data row',
      table: {
        type: { summary: 'ReactNode' },
        defaultValue: { summary: 'undefined' },
      },
      control: {
        type: 'text',
      },
    },
    children: {
      description: 'Value for the row. It can be a ReactNode or a string.',
      table: {
        type: { summary: 'ReactNode | String' },
        defaultValue: { summary: 'undefined' },
      },
      control: {
        type: 'text',
      },
    },
  },
  tags: ['autodocs'],
} satisfies Meta<typeof DataRow>

export default meta
type Story = StoryObj<typeof meta>

/**
 * The Data Row component is used mainly at places where we need to display
 * transaction data. It is a simple label<=>value pair row for a table. On small displays
 * label<=>value shifts to
 * label
 * value
 */
export const StringValue: Story = {
  args: {
    title: 'Transaction Hash',
    children: '0x536e...94f9',
  },
  decorators: [
    (Story) => (
      <Paper sx={{ padding: 2 }}>
        <Story />
      </Paper>
    ),
  ],
}
</file>

<file path="src/components/common/Table/DataRow.tsx">
import type { ReactElement, ReactNode } from 'react'
import { Typography } from '@mui/material'
import FieldsGrid from '@/components/tx/FieldsGrid'

type DataRowProps = {
  datatestid?: String
  title: ReactNode
  children?: ReactNode
}

export const DataRow = ({ datatestid, title, children }: DataRowProps): ReactElement | null => {
  if (children == undefined) return null

  return (
    <FieldsGrid data-testid={datatestid} title={title}>
      <Typography variant="body2">{children}</Typography>
    </FieldsGrid>
  )
}
</file>

<file path="src/components/common/Table/DataTable.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { DataTable } from './DataTable'
import { Paper } from '@mui/material'
import { DataRow } from '@/components/common/Table/DataRow'

const meta = {
  component: DataTable,
  tags: ['autodocs'],
} satisfies Meta<typeof DataTable>

export default meta
type Story = StoryObj<typeof meta>

/**
 * The Data Table component renders a header and a list of DataRow components.
 */
export const Default: Story = {
  args: {
    header: 'Simple Data Table',
    rows: [
      <DataRow key="1" title="Transaction Hash">
        0x536e...94f9
      </DataRow>,
      <DataRow key="2" title="Block Number">
        123456
      </DataRow>,
      <DataRow key="3" title="Gas Used">
        21000
      </DataRow>,
    ],
  },
  decorators: [
    (Story) => (
      <Paper sx={{ padding: 2 }}>
        <Story />
      </Paper>
    ),
  ],
}
</file>

<file path="src/components/common/Table/DataTable.tsx">
import type { ReactElement } from 'react'
import { Stack, Typography } from '@mui/material'
import type { DataRow } from '@/components/common/Table/DataRow'

type DataTableProps = {
  header?: string
  rows: ReactElement<typeof DataRow>[]
}

export const DataTable = ({ header, rows }: DataTableProps): ReactElement | null => {
  return (
    <Stack
      sx={{
        gap: '4px',
      }}
    >
      {header && (
        <Typography variant="body1">
          <b>{header}</b>
        </Typography>
      )}
      {rows.map((row) => {
        return row
      })}
    </Stack>
  )
}
</file>

<file path="src/components/common/Table/EmptyRow.tsx">
import type { ReactElement } from 'react'
import css from './styles.module.css'

export const EmptyRow = (): ReactElement | null => {
  return <div className={css.gridEmptyRow}></div>
}
</file>

<file path="src/components/common/Table/styles.module.css">
.gridRow {
  display: grid;
  grid-template-columns: 25% auto;
  gap: var(--space-1);
  justify-content: flex-start;
  max-width: 900px;
  overflow-x: auto;
  margin-top: 4px;
}

.gridRow:first-of-type {
  margin-bottom: 0;
}

.gridEmptyRow {
  display: grid;
  grid-template-columns: 35% auto;
  gap: var(--space-1);
  justify-content: flex-start;
  max-width: 900px;
  margin-top: var(--space-1);
  margin-bottom: var(--space-1);
  border-top: 1px solid var(--color-border-light);
}

.title {
  color: var(--color-primary-light);
  font-weight: 400;
  word-break: break-all;
}

.title span:nth-child(2) {
  word-break: normal;
}

.gridRow > * {
  flex-shrink: 0;
}

.valueWrapper {
  min-width: 50%;
  flex-shrink: 0;
}

.rawData {
  display: flex;
  align-items: center;
}

@media (max-width: 599.95px) {
  .gridRow {
    grid-template-columns: 1fr;
    gap: 0;
    margin-top: var(--space-1);
  }
}
</file>

<file path="src/components/common/ToggleButtonGroup/index.tsx">
import type { ReactNode, ReactElement } from 'react'
import React from 'react'
import {
  ToggleButtonGroup as MuiToggleButtonGroup,
  ToggleButton,
  toggleButtonGroupClasses,
  styled,
  svgIconClasses,
  Box,
} from '@mui/material'

// @ts-ignore
const StyledMuiToggleButtonGroup = styled(MuiToggleButtonGroup)(({ theme }) => ({
  '&': {
    backgroundColor: theme.palette.background.paper,
  },
  [`& .${toggleButtonGroupClasses.grouped}`]: {
    margin: theme.spacing(0.5),
    padding: theme.spacing(0.5),
    border: 0,
    borderRadius: theme.shape.borderRadius,
    [`&.${toggleButtonGroupClasses.disabled}`]: {
      border: 0,
    },
  },
  [`& .${toggleButtonGroupClasses.middleButton},& .${toggleButtonGroupClasses.lastButton}`]: {
    marginLeft: -1,
    borderLeft: '1px solid transparent',
  },
  [`& .${svgIconClasses.root}`]: {
    width: 16,
    height: 16,
  },
}))

interface ToggleButtonGroupProps {
  value?: number
  children: {
    title: ReactNode
    content: ReactNode
  }[]
  onChange?: (newValue: number) => void
}

export const ToggleButtonGroup = ({ value = 0, children, onChange }: ToggleButtonGroupProps): ReactElement | null => {
  const [currentValue, setCurrentValue] = React.useState(value)

  const changeView = (_: React.MouseEvent, newValue: number) => {
    if (newValue != null) {
      setCurrentValue(newValue)
      onChange?.(newValue)
    }
  }

  return (
    <StyledMuiToggleButtonGroup
      size="small"
      value={currentValue}
      exclusive
      onChange={changeView}
      aria-label="text alignment"
    >
      {children.map(({ title }, index) => (
        <ToggleButton key={index} value={index}>
          <Box px={1}>{title}</Box>
        </ToggleButton>
      ))}
    </StyledMuiToggleButtonGroup>
  )
}
</file>

<file path="src/components/common/TokenAmount/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import TokenAmount from './index'
import { Paper } from '@mui/material'

const meta = {
  component: TokenAmount,
  parameters: {
    componentSubtitle: 'Renders a token Amount with Token Symbol and Logo',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof TokenAmount>

export default meta
type Story = StoryObj<typeof meta>

export const WithTokenLogo: Story = {
  args: {
    value: '100',
    logoUri: 'https://safe-transaction-assets.staging.5afe.dev/chains/1/currency_logo.png',
    tokenSymbol: 'ETH',
  },
}

export const WithoutTokenLogo: Story = {
  args: {
    value: '100',
    tokenSymbol: 'ETH',
  },
}
</file>

<file path="src/components/common/TokenAmount/index.tsx">
import { type ReactElement } from 'react'
import { Tooltip } from '@mui/material'
import { TransferDirection } from '@safe-global/safe-gateway-typescript-sdk'
import css from './styles.module.css'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import TokenIcon from '../TokenIcon'
import classNames from 'classnames'

const PRECISION = 20

const TokenAmount = ({
  value,
  decimals,
  logoUri,
  tokenSymbol,
  direction,
  fallbackSrc,
  preciseAmount,
}: {
  value: string
  decimals?: number | null
  logoUri?: string
  tokenSymbol?: string
  direction?: TransferDirection
  fallbackSrc?: string
  preciseAmount?: boolean
}): ReactElement => {
  const sign = direction === TransferDirection.OUTGOING ? '-' : ''
  const amount =
    decimals !== undefined ? formatVisualAmount(value, decimals, preciseAmount ? PRECISION : undefined) : value

  const fullAmount =
    decimals !== undefined ? sign + formatVisualAmount(value, decimals, PRECISION) + ' ' + tokenSymbol : value

  return (
    <Tooltip title={fullAmount}>
      <span className={classNames(css.container, { [css.verticalAlign]: logoUri })}>
        {logoUri && <TokenIcon logoUri={logoUri} tokenSymbol={tokenSymbol} fallbackSrc={fallbackSrc} />}
        <b className={css.tokenText}>
          {sign}
          {amount} {tokenSymbol}
        </b>
      </span>
    </Tooltip>
  )
}

export default TokenAmount
</file>

<file path="src/components/common/TokenAmount/styles.module.css">
.container {
  display: inline-flex;
  align-items: center;
  gap: var(--space-1);
  color: var(--color-text-primary);
  max-width: 100%;
}

.verticalAlign {
  vertical-align: middle;
}

.tokenText {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</file>

<file path="src/components/common/TokenAmountInput/index.tsx">
import NumberField from '@/components/common/NumberField'
import { AutocompleteItem } from '@/components/tx-flow/flows/TokenTransfer/CreateTokenTransfer'
import { safeFormatUnits, safeParseUnits } from '@safe-global/utils/utils/formatters'
import { validateDecimalLength, validateLimitedAmount } from '@safe-global/utils/utils/validation'
import { Button, Divider, FormControl, InputLabel, MenuItem, TextField } from '@mui/material'
import { type SafeBalanceResponse } from '@safe-global/safe-gateway-typescript-sdk'
import classNames from 'classnames'
import { useCallback } from 'react'
import { get, useFormContext } from 'react-hook-form'
import type { FieldArrayPath, FieldValues } from 'react-hook-form'
import css from './styles.module.css'
import { MultiTokenTransferFields, type MultiTokenTransferParams } from '@/components/tx-flow/flows/TokenTransfer'
import { sameAddress } from '@safe-global/utils/utils/addresses'

export enum TokenAmountFields {
  tokenAddress = 'tokenAddress',
  amount = 'amount',
}

export const InsufficientFundsValidationError = 'Insufficient funds'

const getFieldName = (field: TokenAmountFields, fieldArray?: TokenAmountInputProps['fieldArray']) =>
  fieldArray ? `${fieldArray.name}.${fieldArray.index}.${field}` : field

type TokenAmountInputProps = {
  balances: SafeBalanceResponse['items']
  selectedToken: SafeBalanceResponse['items'][number] | undefined
  maxAmount?: bigint
  validate?: (value: string) => string | undefined
  fieldArray?: { name: FieldArrayPath<FieldValues>; index: number }
  deps?: string[]
}

const TokenAmountInput = ({
  balances,
  selectedToken,
  maxAmount,
  validate,
  fieldArray,
  deps,
}: TokenAmountInputProps) => {
  const {
    formState: { errors, defaultValues },
    register,
    resetField,
    watch,
    setValue,
    trigger,
  } = useFormContext()

  const { getValues } = useFormContext<MultiTokenTransferParams>()

  const tokenAddressField = getFieldName(TokenAmountFields.tokenAddress, fieldArray)
  const amountField = getFieldName(TokenAmountFields.amount, fieldArray)

  const tokenAddress = watch(tokenAddressField)

  const isAmountError = !!get(errors, tokenAddressField) || !!get(errors, amountField)

  const validateAmount = useCallback(
    (value: string) => {
      const decimals = selectedToken?.tokenInfo.decimals
      const maxAmountString = maxAmount?.toString()

      const valueValidationError =
        validateLimitedAmount(value, decimals, maxAmountString) || validateDecimalLength(value, decimals)

      if (valueValidationError) {
        return valueValidationError
      }

      // Validate the total amount of the selected token in the multi transfer
      const recipients = getValues(MultiTokenTransferFields.recipients)
      const sumAmount = recipients.reduce<bigint>((acc, item) => {
        const value = safeParseUnits(item.amount || '0', decimals) || 0n
        return acc + (sameAddress(item.tokenAddress, tokenAddress) ? value : 0n)
      }, 0n)

      return validateLimitedAmount(sumAmount.toString(), 0, maxAmountString, InsufficientFundsValidationError)
    },
    [maxAmount, selectedToken?.tokenInfo.decimals, getValues, tokenAddress],
  )

  const onMaxAmountClick = useCallback(() => {
    if (!selectedToken || maxAmount === undefined) return

    setValue(amountField, safeFormatUnits(maxAmount.toString(), selectedToken.tokenInfo.decimals), {
      shouldValidate: true,
    })

    trigger(deps)
  }, [maxAmount, selectedToken, setValue, amountField, trigger, deps])

  const onChangeToken = useCallback(() => {
    const amountDefaultValue = get(
      defaultValues,
      getFieldName(TokenAmountFields.amount, fieldArray ? { ...fieldArray, index: 0 } : undefined),
    )

    resetField(amountField, amountDefaultValue)

    trigger(deps)
  }, [resetField, amountField, trigger, deps, defaultValues, fieldArray])

  return (
    <FormControl
      data-testid="token-amount-section"
      className={classNames(css.outline, { [css.error]: isAmountError })}
      fullWidth
    >
      <InputLabel shrink required className={css.label}>
        {get(errors, tokenAddressField)?.message?.toString() ||
          get(errors, amountField)?.message?.toString() ||
          'Amount'}
      </InputLabel>
      <div className={css.inputs}>
        <NumberField
          data-testid="token-amount-field"
          variant="standard"
          InputProps={{
            disableUnderline: true,
            endAdornment: maxAmount !== undefined && (
              <Button data-testid="max-btn" className={css.max} onClick={onMaxAmountClick}>
                Max
              </Button>
            ),
          }}
          className={css.amount}
          required
          placeholder="0"
          {...register(amountField, {
            required: true,
            validate: validate ?? validateAmount,
            deps,
          })}
        />
        <Divider orientation="vertical" flexItem />
        <TextField
          data-testid="token-balance"
          select
          variant="standard"
          InputProps={{
            disableUnderline: true,
          }}
          className={css.select}
          {...register(tokenAddressField, {
            required: true,
            onChange: onChangeToken,
          })}
          value={tokenAddress}
          required
        >
          {balances.map((item) => (
            <MenuItem data-testid="token-item" key={item.tokenInfo.address} value={item.tokenInfo.address}>
              <AutocompleteItem {...item} />
            </MenuItem>
          ))}
        </TextField>
      </div>
    </FormControl>
  )
}

export default TokenAmountInput
</file>

<file path="src/components/common/TokenAmountInput/styles.module.css">
.outline {
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
}

.error {
  border-color: var(--color-error-main);
}

.error :global(.MuiFormLabel-root) {
  color: var(--color-error-main);
}

.label {
  background-color: var(--color-background-paper);
  padding-left: 6px;
  padding-right: 6px;
  margin-left: -6px;
}

.inputs {
  display: inline-flex;
  align-items: center;
}

.amount {
  min-width: 130px;
  flex-grow: 1;
}

.amount :global(.MuiInput-input) {
  padding-left: var(--space-2);
}

.max {
  text-transform: uppercase;
  background-color: var(--color-background-main);
  color: var(--color-text-primary);
  font-size: 12px;
  margin-right: var(--space-1);
  min-height: 50px;
  padding: var(--space-2);
}

.select {
  flex-shrink: 0;
}

.select :global(.MuiSelect-select) {
  margin: var(--space-1);
  display: flex;
  background-color: var(--color-background-main);
  border-radius: 6px;
  padding: var(--space-1) var(--space-5) var(--space-1) var(--space-2) !important;
}

.select :global(.MuiSelect-icon) {
  margin-right: var(--space-2);
}
</file>

<file path="src/components/common/TokenExplorerLink/index.tsx">
import { type ReactElement } from 'react'
import ExplorerButton from '@/components/common/ExplorerButton'
import { useCurrentChain } from '@/hooks/useChains'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import { Typography } from '@mui/material'

const ExplorerLink = ({ address }: { address: string }): ReactElement | null => {
  const currentChain = useCurrentChain()
  const link = currentChain ? getBlockExplorerLink(currentChain, address) : undefined

  if (!link) return null

  return (
    <Typography component="span" color="border.main">
      <ExplorerButton href={link.href} title={link.title} />
    </Typography>
  )
}

export default ExplorerLink
</file>

<file path="src/components/common/TokenIcon/index.tsx">
import { useMemo, type ReactElement } from 'react'
import ImageFallback from '../ImageFallback'
import css from './styles.module.css'

const FALLBACK_ICON = '/images/common/token-placeholder.svg'
const COINGECKO_THUMB = '/thumb/'
const COINGECKO_SMALL = '/small/'

const TokenIcon = ({
  logoUri,
  tokenSymbol,
  size = 26,
  fallbackSrc,
}: {
  logoUri?: string
  tokenSymbol?: string
  size?: number
  fallbackSrc?: string
}): ReactElement => {
  const src = useMemo(() => {
    return logoUri?.replace(COINGECKO_THUMB, COINGECKO_SMALL)
  }, [logoUri])

  return (
    <ImageFallback
      src={src}
      alt={tokenSymbol}
      fallbackSrc={fallbackSrc || FALLBACK_ICON}
      height={size}
      className={css.image}
      referrerPolicy="no-referrer"
      loading="lazy"
    />
  )
}

export default TokenIcon
</file>

<file path="src/components/common/TokenIcon/styles.module.css">
.image {
  display: block;
  width: auto;
}

[data-theme='dark'] .image {
  background: var(--color-secondary-main);
  border-radius: 4px;
  padding: 2px;
}
</file>

<file path="src/components/common/Track/index.tsx">
import type { ReactElement } from 'react'
import { Fragment, useEffect, useRef } from 'react'
import { trackEvent, type EventLabel } from '@/services/analytics'

type Props = {
  children: ReactElement
  as?: 'span' | 'div'
  category: string
  action: string
  label?: EventLabel
}

const shouldTrack = (el: HTMLDivElement) => {
  const disabledChildren = el.querySelectorAll('*[disabled]')
  return disabledChildren.length === 0
}

const Track = ({ children, as: Wrapper = 'span', ...trackData }: Props): typeof children => {
  const el = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (!el.current) {
      return
    }

    const trackEl = el.current

    const handleClick = () => {
      if (shouldTrack(trackEl)) {
        trackEvent(trackData)
      }
    }

    // We cannot use onClick as events in children do not always bubble up
    trackEl.addEventListener('click', handleClick)
    return () => {
      trackEl.removeEventListener('click', handleClick)
    }
  }, [el, trackData])

  if (children.type === Fragment) {
    throw new Error('Fragments cannot be tracked.')
  }

  return (
    <Wrapper data-track={`${trackData.category}: ${trackData.action}`} ref={el}>
      {children}
    </Wrapper>
  )
}

export default Track
</file>

<file path="src/components/common/TxModalDialog/index.tsx">
import { Dialog, DialogContent, DialogContentText, DialogTitle, IconButton, type DialogProps } from '@mui/material'
import classnames from 'classnames'
import type { ReactElement } from 'react'
import CloseIcon from '@mui/icons-material/Close'
import css from './styles.module.css'

const TxModalDialog = ({
  children,
  onClose,
  fullScreen = false,
  fullWidth = false,
  ...restProps
}: DialogProps): ReactElement => {
  return (
    <Dialog
      {...restProps}
      fullScreen={true}
      scroll={fullScreen ? 'paper' : 'body'}
      className={classnames(css.dialog, { [css.fullWidth]: fullWidth })}
      onClick={(e) => e.stopPropagation()}
      hideBackdrop
      PaperProps={{
        className: css.paper,
      }}
    >
      <DialogTitle className={css.title}>
        <div className={css.buttons}>
          <IconButton
            className={css.close}
            aria-label="close"
            onClick={(e) => onClose?.(e, 'backdropClick')}
            size="small"
          >
            <CloseIcon fontSize="large" />
          </IconButton>
        </div>
      </DialogTitle>
      <DialogContent dividers={false}>
        <DialogContentText component="div" tabIndex={-1} color="text.primary">
          {children}
        </DialogContentText>
      </DialogContent>
    </Dialog>
  )
}

export default TxModalDialog
</file>

<file path="src/components/common/TxModalDialog/styles.module.css">
.dialog {
  top: 52px;
  left: 230px;
  z-index: 3;
  transition: left 225ms cubic-bezier(0, 0, 0.2, 1) 0ms;
}

.dialog.fullWidth {
  left: 0;
}

.dialog :global .MuiDialogActions-root {
  border-top: 2px solid var(--color-border-light);
  padding: var(--space-3);
}

.dialog :global .MuiDialogActions-root > :last-of-type:not(:first-of-type) {
  order: 2;
}

.dialog :global .MuiDialogActions-root:after {
  content: '';
  order: 1;
  flex: 1;
}

.title {
  display: flex;
  align-items: center;
  padding: 0;
}

.buttons {
  margin-left: auto;
  padding: var(--space-1);
}

.close {
  color: var(--color-border-main);
  padding: var(--space-1);
  background-color: var(--color-border-light);
}

.paper {
  padding-bottom: var(--space-8);
  background-color: var(--color-border-background);
}

@media (min-width: 600px) {
  .dialog :global .MuiDialog-paper {
    min-width: 600px;
    margin: 0;
  }
}

@media (min-width: 900px) {
  .title {
    position: sticky;
    top: 0;
  }
}

@media (max-width: 899.95px) {
  .dialog {
    left: 0;
    top: 0;
    z-index: 1300;
  }

  .dialog :global .MuiDialogActions-root {
    padding: 0;
  }

  .title {
    margin-bottom: var(--space-3);
    background-color: var(--color-background-paper);
  }

  .close {
    background-color: unset;
  }

  .close svg {
    font-size: 1.5rem;
  }
}
</file>

<file path="src/components/common/UnreadBadge/index.tsx">
import React from 'react'
import Badge, { type BadgeProps } from '@mui/material/Badge'

const UnreadBadge = ({
  children,
  count,
  ...props
}: Pick<BadgeProps, 'children' | 'invisible' | 'anchorOrigin'> & { count?: number }) => (
  <Badge
    variant={count !== undefined ? 'standard' : 'dot'}
    badgeContent={count}
    color={count !== undefined ? 'secondary' : 'success'}
    {...props}
  >
    {children}
  </Badge>
)

export default UnreadBadge
</file>

<file path="src/components/common/WalletBalance/index.tsx">
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { Skeleton } from '@mui/material'
import { useCurrentChain } from '@/hooks/useChains'

const WalletBalance = ({ balance }: { balance: string | bigint | undefined }) => {
  const currentChain = useCurrentChain()

  if (balance === undefined) {
    return <Skeleton width={30} variant="text" sx={{ display: 'inline-block' }} />
  }

  if (typeof balance === 'string') {
    return <>{balance}</>
  }

  return (
    <>
      {formatVisualAmount(balance, currentChain?.nativeCurrency.decimals ?? 18)}{' '}
      {currentChain?.nativeCurrency.symbol ?? 'ETH'}
    </>
  )
}

export default WalletBalance
</file>

<file path="src/components/common/WalletIcon/index.tsx">
import { Skeleton } from '@mui/material'

const WalletIcon = ({
  provider,
  width = 30,
  height = 30,
  icon,
}: {
  provider: string
  width?: number
  height?: number
  icon?: string
}) => {
  return icon ? (
    <img
      width={width}
      height={height}
      src={icon.startsWith('data:') ? icon : `data:image/svg+xml;utf8,${encodeURIComponent(icon)}`}
      alt={`${provider} logo`}
    />
  ) : (
    <Skeleton variant="circular" width={width} height={height} />
  )
}

export default WalletIcon
</file>

<file path="src/components/common/WalletInfo/index.tsx">
import WalletBalance from '@/components/common/WalletBalance'
import { WalletIdenticon } from '@/components/common/WalletOverview'
import { Box, Button, Typography } from '@mui/material'
import css from './styles.module.css'
import EthHashInfo from '@/components/common/EthHashInfo'
import ChainSwitcher from '@/components/common/ChainSwitcher'
import useOnboard, { type ConnectedWallet, switchWallet } from '@/hooks/wallets/useOnboard'
import useAddressBook from '@/hooks/useAddressBook'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectChainById } from '@/store/chainsSlice'
import madProps from '@/utils/mad-props'
import PowerSettingsNewIcon from '@mui/icons-material/PowerSettingsNew'
import useChainId from '@/hooks/useChainId'
import { useAuthLogoutV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/auth'
import { setUnauthenticated } from '@/store/authSlice'
import { logError, Errors } from '@/services/exceptions'

type WalletInfoProps = {
  wallet: ConnectedWallet
  balance?: string | bigint
  currentChainId: ReturnType<typeof useChainId>
  onboard: ReturnType<typeof useOnboard>
  addressBook: ReturnType<typeof useAddressBook>
  handleClose: () => void
}

export const WalletInfo = ({ wallet, balance, currentChainId, onboard, addressBook, handleClose }: WalletInfoProps) => {
  const [authLogout] = useAuthLogoutV1Mutation()
  const dispatch = useAppDispatch()
  const chainInfo = useAppSelector((state) => selectChainById(state, wallet.chainId))
  const prefix = chainInfo?.shortName

  const handleSwitchWallet = () => {
    if (onboard) {
      handleClose()
      switchWallet(onboard)
    }
  }

  const handleDisconnect = async () => {
    onboard?.disconnectWallet({
      label: wallet.label,
    })
    try {
      await authLogout()
      dispatch(setUnauthenticated())
    } catch (error) {
      logError(Errors._108, error)
    }

    handleClose()
  }

  return (
    <>
      <Box display="flex" gap="12px">
        <WalletIdenticon wallet={wallet} size={36} />

        <Typography variant="body2" className={css.address} component="div">
          <EthHashInfo
            address={wallet.address}
            name={addressBook[wallet.address] || wallet.ens || wallet.label}
            showAvatar={false}
            showPrefix={false}
            hasExplorer
            showCopyButton
            prefix={prefix}
          />
        </Typography>
      </Box>

      <Box className={css.rowContainer}>
        <Box className={css.row}>
          <Typography variant="body2" color="primary.light">
            Wallet
          </Typography>
          <Typography variant="body2">{wallet.label}</Typography>
        </Box>

        <Box className={css.row}>
          <Typography variant="body2" color="primary.light">
            Balance
          </Typography>
          <Typography variant="body2" textAlign="right">
            <WalletBalance balance={balance} />

            {currentChainId !== chainInfo?.chainId && (
              <>
                <Typography variant="body2" color="primary.light">
                  ({chainInfo?.chainName || 'Unknown chain'})
                </Typography>
              </>
            )}
          </Typography>
        </Box>
      </Box>

      <Box display="flex" flexDirection="column" gap={2} width={1}>
        <ChainSwitcher fullWidth />

        <Button variant="contained" size="small" onClick={handleSwitchWallet} fullWidth>
          Switch wallet
        </Button>

        <Button
          onClick={handleDisconnect}
          variant="danger"
          size="small"
          fullWidth
          disableElevation
          startIcon={<PowerSettingsNewIcon />}
        >
          Disconnect
        </Button>
      </Box>
    </>
  )
}

export default madProps(WalletInfo, {
  onboard: useOnboard,
  addressBook: useAddressBook,
  currentChainId: useChainId,
})
</file>

<file path="src/components/common/WalletInfo/styles.module.css">
.container {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.accountContainer {
  width: 100%;
  margin-bottom: var(--space-1);
}

.accountContainer > span {
  border-radius: 8px 8px 0 0;
}

.addressContainer {
  border-radius: 0 0 8px 8px;
  padding: 12px;
  border: 1px solid var(--color-border-light);
  border-top: 0;
  font-size: 14px;
}

.warningButton {
  background-color: var(--color-warning-background);
  color: var(--color-warning-main);
  font-size: 12px;
}

.warningButton:global.MuiButton-root:hover {
  background-color: var(--color-warning-background);
}

.address {
  height: 40px;
}

.address div[title] {
  font-weight: bold;
}

.rowContainer {
  align-self: stretch;
  border: 1px solid var(--color-border-light);
  border-radius: 4px;
}

.row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--color-border-light);
  padding: 12px;
  margin-top: -2px;
}

.row:first-of-type {
  border: 0;
}
</file>

<file path="src/components/common/WalletOverview/index.tsx">
import Identicon from '@/components/common/Identicon'
import { Box, Typography } from '@mui/material'
import { Suspense } from 'react'
import type { ReactElement } from 'react'

import EthHashInfo from '@/components/common/EthHashInfo'
import WalletIcon from '@/components/common/WalletIcon'
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { useAppSelector } from '@/store'
import { selectChainById } from '@/store/chainsSlice'
import WalletBalance from '@/components/common/WalletBalance'

import css from './styles.module.css'

export const WalletIdenticon = ({ wallet, size = 32 }: { wallet: ConnectedWallet; size?: number }) => {
  return (
    <Box className={css.imageContainer}>
      <Identicon address={wallet.address} size={size} />
      <Suspense>
        <Box className={css.walletIcon}>
          <WalletIcon provider={wallet.label} icon={wallet.icon} width={size / 2} height={size / 2} />
        </Box>
      </Suspense>
    </Box>
  )
}

const WalletOverview = ({
  wallet,
  balance,
  showBalance,
}: {
  wallet: ConnectedWallet
  balance?: string
  showBalance?: boolean
}): ReactElement => {
  const walletChain = useAppSelector((state) => selectChainById(state, wallet.chainId))
  const prefix = walletChain?.shortName

  return (
    <Box className={css.container}>
      <WalletIdenticon wallet={wallet} />

      <Box className={css.walletDetails}>
        <Typography variant="body2" component="div">
          {wallet.ens ? (
            <div>{wallet.ens}</div>
          ) : (
            <EthHashInfo
              prefix={prefix || ''}
              address={wallet.address}
              showName={false}
              showAvatar={false}
              avatarSize={12}
              copyAddress={false}
            />
          )}
        </Typography>

        {showBalance && (
          <Typography variant="caption" component="div" fontWeight="bold" display={{ xs: 'none', sm: 'block' }}>
            <WalletBalance balance={balance} />
          </Typography>
        )}
      </Box>
    </Box>
  )
}

export default WalletOverview
</file>

<file path="src/components/common/WalletOverview/styles.module.css">
.container {
  display: flex;
  align-items: center;
  gap: var(--space-1);
  justify-content: center;
}

.imageContainer {
  display: flex;
  justify-content: center;
  position: relative;
}

.walletIcon {
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  bottom: -6px;
  right: -6px;
  border-radius: 50%;
  border: 2px solid var(--color-background-paper);
  background-color: var(--color-background-main);
  overflow: hidden;
}

.walletIcon img {
  padding: 2px;
}

[data-theme='dark'] .imageContainer img[alt*='Ledger'] {
  filter: invert(100%);
}

@media (max-width: 599.95px) {
  .buttonContainer button {
    font-size: 12px;
  }

  .imageContainer img {
    width: 22px;
    height: auto;
  }
}

@media (max-width: 899.95px) {
  .walletDetails {
    display: none;
  }
}
</file>

<file path="src/components/common/WalletProvider/index.tsx">
import { createContext, type ReactElement, type ReactNode, useEffect, useState, useMemo } from 'react'
import useOnboard, { type ConnectedWallet, getConnectedWallet } from '@/hooks/wallets/useOnboard'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { getSafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { useCurrentChain } from '@/hooks/useChains'
import { useRouter } from 'next/router'
import { type Eip1193Provider } from 'ethers'
import { getNestedWallet } from '@/utils/nested-safe-wallet'
import { sameAddress } from '@safe-global/utils/utils/addresses'

export type SignerWallet = {
  provider: Eip1193Provider | null
  address: string
  chainId: string
  isSafe?: boolean
}

export type WalletContextType = {
  connectedWallet: ConnectedWallet | null
  signer: SignerWallet | null
  setSignerAddress: (address: string | undefined) => void
}

export const WalletContext = createContext<WalletContextType | null>(null)

const WalletProvider = ({ children }: { children: ReactNode }): ReactElement => {
  const onboard = useOnboard()
  const currentChain = useCurrentChain()
  const web3ReadOnly = useWeb3ReadOnly()
  const router = useRouter()
  const onboardWallets = onboard?.state.get().wallets || []
  const [wallet, setWallet] = useState<ConnectedWallet | null>(getConnectedWallet(onboardWallets))

  const [signerAddress, setSignerAddress] = useState<string>()

  const [nestedSafeInfo] = useAsync(() => {
    if (signerAddress && !sameAddress(signerAddress, wallet?.address) && currentChain) {
      return getSafeInfo(currentChain.chainId, signerAddress)
    }
  }, [currentChain, signerAddress, wallet?.address])

  useEffect(() => {
    if (!onboard) return

    const walletSubscription = onboard.state.select('wallets').subscribe((wallets) => {
      const newWallet = getConnectedWallet(wallets)

      setWallet(newWallet)
    })

    return () => {
      walletSubscription.unsubscribe()
    }
  }, [onboard])

  const signer = useMemo(() => {
    if (wallet && nestedSafeInfo && web3ReadOnly) {
      return getNestedWallet(wallet, nestedSafeInfo, web3ReadOnly, router)
    }
    return wallet
  }, [wallet, nestedSafeInfo, web3ReadOnly, router])

  return (
    <WalletContext.Provider
      value={{
        connectedWallet: wallet,
        signer,
        setSignerAddress,
      }}
    >
      {children}
    </WalletContext.Provider>
  )
}

export default WalletProvider
</file>

<file path="src/components/common/WidgetDisclaimer/index.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import { AppRoutes } from '@/config/routes'
import { Typography } from '@mui/material'

import css from './styles.module.css'

const linkSx = {
  textDecoration: 'none',
}

const WidgetDisclaimer = ({ widgetName }: { widgetName: string }) => (
  <div className={css.disclaimerContainer}>
    <div className={css.disclaimerInner}>
      <Typography mb={4} mt={4}>
        You are now accessing a third party widget.
      </Typography>

      <Typography mb={4}>
        Please note that we do not own, control, maintain or audit the {widgetName}. Use of the widget is subject to
        third party terms & conditions. We are not liable for any loss you may suffer in connection with interacting
        with the widget, which is at your own risk.
      </Typography>

      <Typography mb={4}>
        Our{' '}
        <ExternalLink href={AppRoutes.terms} sx={linkSx}>
          terms
        </ExternalLink>{' '}
        contain more detailed provisions binding on you relating to such third party content.
      </Typography>
      <Typography>
        By clicking &quot;continue&quot; you re-confirm to have read and understood our{' '}
        <ExternalLink href={AppRoutes.terms} sx={linkSx}>
          terms
        </ExternalLink>{' '}
        and this message, and agree to them.
      </Typography>
    </div>
  </div>
)

export default WidgetDisclaimer
</file>

<file path="src/components/common/WidgetDisclaimer/styles.module.css">
.disclaimerContainer p,
.disclaimerContainer h3 {
  line-height: 24px;
}

.disclaimerInner p {
  text-align: justify;
}
</file>

<file path="src/components/dashboard/Assets/index.tsx">
import { useMemo } from 'react'
import { Box, Skeleton, Typography, Paper } from '@mui/material'
import useBalances from '@/hooks/useBalances'
import TokenAmount from '@/components/common/TokenAmount'
import SwapButton from '@/features/swap/components/SwapButton'
import { AppRoutes } from '@/config/routes'
import { WidgetContainer, WidgetBody, ViewAllLink } from '../styled'
import css from '../PendingTxs/styles.module.css'
import { useRouter } from 'next/router'
import { SWAP_LABELS } from '@/services/analytics/events/swaps'
import { useVisibleAssets } from '@/components/balances/AssetsTable/useHideAssets'
import BuyCryptoButton from '@/components/common/BuyCryptoButton'
import SendButton from '@/components/balances/AssetsTable/SendButton'
import useIsSwapFeatureEnabled from '@/features/swap/hooks/useIsSwapFeatureEnabled'
import { FiatBalance } from '@/components/balances/AssetsTable/FiatBalance'
import { type Balances } from '@safe-global/store/gateway/AUTO_GENERATED/balances'
import { FiatChange } from '@/components/balances/AssetsTable/FiatChange'

const MAX_ASSETS = 5

const AssetsDummy = () => (
  <Box className={css.container}>
    <Skeleton variant="circular" width={26} height={26} />
    {Array.from({ length: 2 }).map((_, index) => (
      <Skeleton variant="text" sx={{ flex: 1 }} key={index} />
    ))}
    <Skeleton variant="text" width={88} />
  </Box>
)

const NoAssets = () => (
  <Paper elevation={0} sx={{ p: 5 }}>
    <Typography variant="h3" fontWeight="bold" mb={1}>
      Add funds to get started
    </Typography>

    <Typography>
      Add funds directly from your bank account or copy your address to send tokens from a different account.
    </Typography>

    <Box display="flex" mt={2}>
      <BuyCryptoButton />
    </Box>
  </Paper>
)

const AssetRow = ({ item, showSwap }: { item: Balances['items'][number]; showSwap?: boolean }) => (
  <Box className={css.container} key={item.tokenInfo.address}>
    <Box flex={1}>
      <TokenAmount
        value={item.balance}
        decimals={item.tokenInfo.decimals}
        tokenSymbol={item.tokenInfo.symbol}
        logoUri={item.tokenInfo.logoUri}
      />
    </Box>

    <Box flex={1} display={['none', 'block']} pr={4}>
      <FiatBalance balanceItem={item} />
    </Box>

    <Box flex={1} display={['none', 'block']} pr={4}>
      <FiatChange balanceItem={item} />
    </Box>

    <Box my={-0.7}>
      {showSwap ? (
        <SwapButton tokenInfo={item.tokenInfo} amount="0" trackingLabel={SWAP_LABELS.dashboard_assets} />
      ) : (
        <SendButton tokenInfo={item.tokenInfo} isOutlined />
      )}
    </Box>
  </Box>
)

const AssetList = ({ items }: { items: Balances['items'] }) => {
  const isSwapFeatureEnabled = useIsSwapFeatureEnabled()

  return (
    <Box display="flex" flexDirection="column" gap={1}>
      {items.map((item) => (
        <AssetRow item={item} key={item.tokenInfo.address} showSwap={isSwapFeatureEnabled} />
      ))}
    </Box>
  )
}

const isNonZeroBalance = (item: Balances['items'][number]) => item.balance !== '0'

const AssetsWidget = () => {
  const router = useRouter()
  const { safe } = router.query
  const { loading } = useBalances()
  const visibleAssets = useVisibleAssets()

  const items = useMemo(() => {
    return visibleAssets.filter(isNonZeroBalance).slice(0, MAX_ASSETS)
  }, [visibleAssets])

  const viewAllUrl = useMemo(
    () => ({
      pathname: AppRoutes.balances.index,
      query: { safe },
    }),
    [safe],
  )

  return (
    <WidgetContainer data-testid="assets-widget">
      <div className={css.title}>
        <Typography component="h2" variant="subtitle1" fontWeight={700} mb={2}>
          Top assets
        </Typography>

        {items.length > 0 && <ViewAllLink url={viewAllUrl} text={`View all (${visibleAssets.length})`} />}
      </div>

      <WidgetBody>
        {loading ? <AssetsDummy /> : items.length > 0 ? <AssetList items={items} /> : <NoAssets />}
      </WidgetBody>
    </WidgetContainer>
  )
}

export default AssetsWidget
</file>

<file path="src/components/dashboard/FirstSteps/index.tsx">
import { BuyCryptoOptions } from '@/components/common/BuyCryptoButton'
import CheckWallet from '@/components/common/CheckWallet'
import EthHashInfo from '@/components/common/EthHashInfo'
import ExternalLink from '@/components/common/ExternalLink'
import ModalDialog from '@/components/common/ModalDialog'
import QRCode from '@/components/common/QRCode'
import Track from '@/components/common/Track'
import FirstTxFlow from '@/features/counterfactual/FirstTxFlow'
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import useBalances from '@/hooks/useBalances'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { OVERVIEW_EVENTS } from '@/services/analytics'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setQrShortName } from '@/store/settingsSlice'
import { selectOutgoingTransactions } from '@/store/txHistorySlice'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import classnames from 'classnames'
import { type ReactNode, useState } from 'react'
import { Card, WidgetBody, WidgetContainer } from '@/components/dashboard/styled'
import { Box, Button, CircularProgress, Divider, FormControlLabel, Grid, Switch, Typography } from '@mui/material'
import CircleOutlinedIcon from '@mui/icons-material/CircleOutlined'
import CheckCircleRoundedIcon from '@mui/icons-material/CheckCircleRounded'
import CheckCircleOutlineRoundedIcon from '@mui/icons-material/CheckCircleOutlineRounded'
import LightbulbOutlinedIcon from '@mui/icons-material/LightbulbOutlined'
import css from './styles.module.css'
import ActivateAccountButton from '@/features/counterfactual/ActivateAccountButton'
import { isReplayedSafeProps } from '@/features/counterfactual/utils'
import { getExplorerLink } from '@safe-global/utils/utils/gateway'

const calculateProgress = (items: boolean[]) => {
  const totalNumberOfItems = items.length
  const completedItems = items.filter((item) => item)
  return Math.round((completedItems.length / totalNumberOfItems) * 100)
}

const StatusCard = ({
  badge,
  title,
  content,
  completed,
  children,
}: {
  badge: ReactNode
  title: string
  content: string
  completed: boolean
  children?: ReactNode
}) => {
  return (
    <Card className={css.card}>
      <div className={css.topBadge}>{badge}</div>
      <div className={css.status}>
        {completed ? (
          <CheckCircleRoundedIcon color="success" fontSize="medium" />
        ) : (
          <CircleOutlinedIcon color="inherit" fontSize="medium" />
        )}
      </div>
      <Typography
        variant="h4"
        sx={{
          fontWeight: 'bold',
          mb: 2,
        }}
      >
        {title}
      </Typography>
      <Typography
        variant="body2"
        sx={{
          color: 'primary.light',
        }}
      >
        {content}
      </Typography>
      {children}
    </Card>
  )
}

const ActivationStatusWidget = ({ explorerLink }: { explorerLink?: string }) => {
  return (
    <StatusCard
      badge={
        <Typography
          variant="body2"
          sx={{ backgroundColor: 'border.light', borderRadius: '0 0 4px 4px', padding: '4px 8px' }}
        >
          Just submitted
        </Typography>
      }
      title="Transaction pending"
      content="Depending on network usage, it can take some time until the transaction is successfully processed and executed."
      completed={false}
    >
      {explorerLink && (
        <ExternalLink href={explorerLink} sx={{ mt: 2 }}>
          View Explorer
        </ExternalLink>
      )}
    </StatusCard>
  )
}

const UsefulHintsWidget = () => {
  return (
    <StatusCard
      badge={
        <Typography variant="body2" className={classnames(css.badgeText, css.badgeTextInfo)}>
          <LightbulbOutlinedIcon fontSize="small" sx={{ mr: 0.5 }} />
          Did you know
        </Typography>
      }
      title="Explore over 70+ dApps"
      content="In our Safe App section you can connect your Safe to over 70 dApps directly or via Wallet Connect to interact with any application."
      completed={false}
    />
  )
}

const AddFundsWidget = ({ completed }: { completed: boolean }) => {
  const [open, setOpen] = useState<boolean>(false)
  const { safeAddress } = useSafeInfo()
  const chain = useCurrentChain()
  const dispatch = useAppDispatch()
  const settings = useAppSelector(selectSettings)
  const qrPrefix = settings.shortName.qr ? `${chain?.shortName}:` : ''
  const qrCode = `${qrPrefix}${safeAddress}`

  const title = 'Add native assets'
  const content = `Receive ${chain?.nativeCurrency.name} to start interacting with your account.`

  const toggleDialog = () => {
    setOpen((prev) => !prev)
  }

  return (
    <StatusCard
      badge={
        <Typography variant="body2" className={css.badgeText}>
          First interaction
        </Typography>
      }
      title={title}
      content={content}
      completed={completed}
    >
      {!completed && (
        <>
          <Box
            sx={{
              mt: 2,
            }}
          >
            <Track {...OVERVIEW_EVENTS.ADD_FUNDS}>
              <Button
                data-testid="add-funds-btn"
                onClick={toggleDialog}
                variant="contained"
                size="small"
                sx={{ minHeight: '40px' }}
              >
                Add funds
              </Button>
            </Track>
          </Box>
          <ModalDialog
            open={open}
            onClose={toggleDialog}
            dialogTitle="Add funds to your Safe Account"
            hideChainIndicator
          >
            <Box
              sx={{
                px: 4,
                pb: 5,
                pt: 4,
              }}
            >
              <Grid
                container
                spacing={2}
                sx={{
                  alignItems: 'center',
                  justifyContent: 'center',
                  mb: 4,
                }}
              >
                <Grid
                  data-testid="qr-code"
                  item
                  sx={{
                    textAlign: 'center',
                  }}
                >
                  <Box
                    sx={{
                      p: 1,
                      border: 1,
                      borderRadius: '6px',
                      borderColor: 'border.light',
                      display: 'inline-flex',
                    }}
                  >
                    <QRCode value={qrCode} size={132} />
                  </Box>
                  <Box>
                    <FormControlLabel
                      control={
                        <Switch
                          data-testid="qr-code-switch"
                          checked={settings.shortName.qr}
                          onChange={(e) => dispatch(setQrShortName(e.target.checked))}
                        />
                      }
                      label={
                        <>
                          QR code with chain prefix (<b>{chain?.shortName}:</b>)
                        </>
                      }
                    />
                  </Box>
                </Grid>
                <Grid item xs>
                  <Typography
                    sx={{
                      mb: 2,
                    }}
                  >
                    Add funds directly from your bank account or copy your address to send tokens from a different
                    account.
                  </Typography>

                  <Box
                    data-testid="address-info"
                    sx={{
                      bgcolor: 'background.main',
                      p: 2,
                      borderRadius: '6px',
                      alignSelf: 'flex-start',
                      fontSize: '14px',
                    }}
                  >
                    <EthHashInfo
                      address={safeAddress}
                      showName={false}
                      shortAddress={false}
                      showCopyButton
                      hasExplorer
                      avatarSize={24}
                    />
                  </Box>
                </Grid>
              </Grid>

              <Box
                sx={{
                  mb: 4,
                  position: 'relative',
                  textAlign: 'center',
                }}
              >
                <Typography className={css.orDivider}>or</Typography>
                <Divider />
              </Box>

              <Typography
                sx={{
                  mb: 2,
                }}
              >
                Buy crypto with fiat:
              </Typography>
              <BuyCryptoOptions />
            </Box>
          </ModalDialog>
        </>
      )}
    </StatusCard>
  )
}

const FirstTransactionWidget = ({ completed }: { completed: boolean }) => {
  const [open, setOpen] = useState<boolean>(false)

  const title = 'Create your first transaction'
  const content = 'Simply send funds, add a new signer or swap tokens through a safe app.'

  return (
    <>
      <StatusCard
        badge={
          <Typography variant="body2" className={css.badgeText}>
            First interaction
          </Typography>
        }
        title={title}
        content={content}
        completed={completed}
      >
        {!completed && (
          <CheckWallet>
            {(isOk) => (
              <Track {...OVERVIEW_EVENTS.NEW_TRANSACTION} label="onboarding">
                <Button
                  data-testid="create-tx-btn"
                  onClick={() => setOpen(true)}
                  variant="outlined"
                  size="small"
                  sx={{ mt: 2, minHeight: '40px' }}
                  disabled={!isOk}
                >
                  Create transaction
                </Button>
              </Track>
            )}
          </CheckWallet>
        )}
      </StatusCard>
      <FirstTxFlow open={open} onClose={() => setOpen(false)} />
    </>
  )
}

const ActivateSafeWidget = ({ chain }: { chain: ChainInfo | undefined }) => {
  const [open, setOpen] = useState<boolean>(false)

  const title = `Activate account ${chain ? 'on ' + chain.chainName : ''}`
  const content = 'Activate your account to start using all benefits of Safe'

  return (
    <>
      <StatusCard
        badge={
          <Typography variant="body2" className={css.badgeText}>
            First interaction
          </Typography>
        }
        title={title}
        completed={false}
        content={content}
      >
        <Box
          sx={{
            mt: 2,
          }}
        >
          <ActivateAccountButton />
        </Box>
      </StatusCard>
      <FirstTxFlow open={open} onClose={() => setOpen(false)} />
    </>
  )
}

const AccountReadyWidget = () => {
  return (
    <Card className={classnames(css.card, css.accountReady)}>
      <div className={classnames(css.checkIcon)}>
        <CheckCircleOutlineRoundedIcon sx={{ width: '60px', height: '60px' }} />
      </div>
      <Typography
        variant="h4"
        sx={{
          fontWeight: 'bold',
          mb: 2,
          mt: 2,
        }}
      >
        Safe Account is ready!
      </Typography>
      <Typography>Continue to improve your account security and unlock more features</Typography>
    </Card>
  )
}

const FirstSteps = () => {
  const { balances } = useBalances()
  const { safe, safeAddress } = useSafeInfo()
  const outgoingTransactions = useAppSelector(selectOutgoingTransactions)
  const chain = useCurrentChain()
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, safe.chainId, safeAddress))

  const isMultiSig = safe.threshold > 1
  const isReplayedSafe = undeployedSafe && isReplayedSafeProps(undeployedSafe?.props)

  const hasNonZeroBalance = balances && (balances.items.length > 1 || BigInt(balances.items[0]?.balance || 0) > 0)
  const hasOutgoingTransactions = !!outgoingTransactions && outgoingTransactions.length > 0
  const completedItems = [hasNonZeroBalance, hasOutgoingTransactions]

  const progress = calculateProgress(completedItems)
  const stepsCompleted = completedItems.filter((item) => item).length

  if (safe.deployed) return null

  const isActivating = undeployedSafe?.status.status !== 'AWAITING_EXECUTION'

  return (
    <WidgetContainer>
      <WidgetBody data-testid="activation-section">
        <Grid
          container
          sx={{
            gap: 3,
            mb: 2,
            flexWrap: 'nowrap',
            alignItems: 'center',
          }}
        >
          <Grid
            item
            sx={{
              position: 'relative',
              display: 'inline-flex',
            }}
          >
            <svg className={css.gradient}>
              <defs>
                <linearGradient
                  id="progress_gradient"
                  x1="21.1648"
                  y1="8.21591"
                  x2="-9.95028"
                  y2="22.621"
                  gradientUnits="userSpaceOnUse"
                >
                  <stop stopColor="#5FDDFF" />
                  <stop offset="1" stopColor="#12FF80" />
                </linearGradient>
              </defs>
            </svg>
            <CircularProgress variant="determinate" value={100} className={css.circleBg} size={60} thickness={5} />
            <CircularProgress
              variant={isActivating ? 'indeterminate' : 'determinate'}
              value={progress === 0 ? 3 : progress} // Just to give an indication of the progress even at 0%
              className={css.circleProgress}
              size={60}
              thickness={5}
              sx={{ 'svg circle': { stroke: 'url(#progress_gradient)', strokeLinecap: 'round' } }}
            />
          </Grid>
          <Grid item>
            <Typography
              component="div"
              variant="h2"
              sx={{
                fontWeight: 700,
                mb: 1,
              }}
            >
              {isActivating ? 'Account is being activated...' : 'Activate your Safe Account'}
            </Typography>

            {isActivating ? (
              <Typography variant="body2">
                <strong>This may take a few minutes.</strong> Once activated, your account will be up and running.
              </Typography>
            ) : (
              <Typography variant="body2">
                <strong>
                  {stepsCompleted} of {completedItems.length} steps completed.
                </strong>{' '}
                Finish the next steps to start using all Safe Account features:
              </Typography>
            )}
          </Grid>
        </Grid>
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            {isActivating && chain ? (
              <ActivationStatusWidget
                explorerLink={
                  undeployedSafe?.status.txHash
                    ? getExplorerLink(undeployedSafe.status.txHash, chain.blockExplorerUriTemplate).href
                    : undefined
                }
              />
            ) : (
              <AddFundsWidget completed={hasNonZeroBalance} />
            )}
          </Grid>

          <Grid item xs={12} md={4}>
            {isActivating ? (
              <UsefulHintsWidget />
            ) : isMultiSig || isReplayedSafe ? (
              <ActivateSafeWidget chain={chain} />
            ) : (
              <FirstTransactionWidget completed={hasOutgoingTransactions} />
            )}
          </Grid>

          <Grid item xs={12} md={4}>
            <AccountReadyWidget />
          </Grid>
        </Grid>
      </WidgetBody>
    </WidgetContainer>
  )
}

export default FirstSteps
</file>

<file path="src/components/dashboard/FirstSteps/styles.module.css">
.circleProgress {
  color: var(--color-secondary-main);
}

.circleBg {
  color: var(--color-border-light);
  position: absolute;
}

.card {
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  align-items: flex-start;
  min-height: 260px;
}

.topBadge {
  position: absolute;
  top: 0;
  right: 24px;
  border-radius: 0 0 4px 4px;
}

.badgeText {
  background-color: var(--color-secondary-light);
  color: var(--color-static-main);
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
  display: flex;
  align-items: center;
}

.badgeTextInfo {
  background-color: var(--color-info-main);
}

.status {
  align-self: flex-start;
  margin-bottom: auto;
  color: var(--color-border-light);
}

.gradient {
  position: absolute;
  width: 0;
  height: 0;
  opacity: 0;
  visibility: hidden;
}

.accountReady {
  text-align: center;
  align-items: center;
  justify-content: center;
  padding: var(--space-4);
  color: var(--color-text-secondary);
}

.accountReady.completed {
  color: var(--color-text-primary);
}

.checkIcon {
  color: var(--color-border-light);
}

.checkIcon.completed {
  color: var(--color-success-main);
}

.orDivider {
  display: inline-block;
  padding: 0 var(--space-3);
  background: var(--color-background-paper);
  bottom: -11px;
  position: relative;
}
</file>

<file path="src/components/dashboard/GovernanceSection/GovernanceSection.tsx">
import { useCallback, useEffect, useRef, useState } from 'react'
import { Typography, Card, Box, Link, SvgIcon } from '@mui/material'
import { WidgetBody } from '@/components/dashboard/styled'
import css from './styles.module.css'
import { useBrowserPermissions } from '@/hooks/safe-apps/permissions'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'
import { DISCORD_URL, SafeAppsTag } from '@/config/constants'
import { useDarkMode } from '@/hooks/useDarkMode'
import { OpenInNew } from '@mui/icons-material'
import NetworkError from '@/public/images/common/network-error.svg'
import useChainId from '@/hooks/useChainId'
import { getSafeTokenAddress } from '@/components/common/SafeTokenWidget'
import SafeAppIframe from '@/components/safe-apps/AppFrame/SafeAppIframe'
import type { UseAppCommunicatorHandlers } from '@/components/safe-apps/AppFrame/useAppCommunicator'
import useAppCommunicator from '@/components/safe-apps/AppFrame/useAppCommunicator'
import { useCurrentChain } from '@/hooks/useChains'
import useGetSafeInfo from '@/components/safe-apps/AppFrame/useGetSafeInfo'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import useSafeInfo from '@/hooks/useSafeInfo'
import { fetchSafeAppFromManifest } from '@/services/safe-apps/manifest'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { getOrigin } from '@/components/safe-apps/utils'
import InfiniteScroll from '@/components/common/InfiniteScroll'

// A fallback component when the Safe App fails to load
const WidgetLoadErrorFallback = () => (
  <Box
    sx={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      height: '100%',
    }}
  >
    <Card className={css.loadErrorCard}>
      <Box className={css.loadErrorMsgContainer}>
        <Typography
          variant="h4"
          sx={{
            color: 'text.primary',
            fontWeight: 'bold',
          }}
        >
          Couldn&apos;t load governance widgets
        </Typography>
        <SvgIcon component={NetworkError} inheritViewBox className={css.loadErroricon} />
        <Typography
          variant="body1"
          sx={{
            color: 'text.primary',
          }}
        >
          You can try to reload the page and in case the problem persists, please reach out to us via{' '}
          <Link
            target="_blank"
            href={DISCORD_URL}
            sx={{
              fontSize: 'medium',
            }}
          >
            Discord
            <OpenInNew fontSize="small" color="primary" className={css.loadErroricon} />
          </Link>
        </Typography>
      </Box>
    </Card>
  </Box>
)

// A mini Safe App frame with a minimal set of communication handlers
const MiniAppFrame = ({ app, title }: { app: SafeAppData; title: string }) => {
  const chain = useCurrentChain()
  const isDarkMode = useDarkMode()
  const theme = isDarkMode ? 'dark' : 'light'
  const { getAllowedFeaturesList } = useBrowserPermissions()
  const iframeRef = useRef<HTMLIFrameElement>(null)

  const [, error] = useAsync(() => {
    if (!chain?.chainId) return
    return fetchSafeAppFromManifest(app.url, chain.chainId)
  }, [app.url, chain?.chainId])

  // Initialize the app communicator
  useAppCommunicator(iframeRef, app, chain, {
    onGetSafeInfo: useGetSafeInfo(),
  } as Partial<UseAppCommunicatorHandlers> as UseAppCommunicatorHandlers)

  return error ? (
    <WidgetLoadErrorFallback />
  ) : (
    <SafeAppIframe
      key={theme}
      appUrl={`${app.url}/widgets?theme=${theme}`}
      allowedFeaturesList={getAllowedFeaturesList(getOrigin(app.url))}
      title={title}
      iframeRef={iframeRef}
    />
  )
}

// Entire section for the governance widgets
const GovernanceSection = () => {
  const [matchingApps, errorFetchingGovernanceSafeApp] = useRemoteSafeApps({ tag: SafeAppsTag.SAFE_GOVERNANCE_APP })
  const governanceApp = matchingApps?.[0]
  const fetchingSafeGovernanceApp = !governanceApp && !errorFetchingGovernanceSafeApp
  const { safeLoading } = useSafeInfo()

  return (
    <>
      {governanceApp || fetchingSafeGovernanceApp ? (
        <WidgetBody>
          <Card className={css.widgetWrapper}>
            {governanceApp && !safeLoading ? (
              <MiniAppFrame app={governanceApp} title="Safe Governance" />
            ) : (
              <Box
                className={css.widgetWrapper}
                sx={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  textAlign: 'center',
                }}
              >
                <Typography
                  variant="h1"
                  sx={{
                    color: 'text.secondary',
                  }}
                >
                  Loading section...
                </Typography>
              </Box>
            )}
          </Card>
        </WidgetBody>
      ) : (
        <WidgetLoadErrorFallback />
      )}
    </>
  )
}

const LazyGovernanceSection = () => {
  const [isVisible, setIsVisible] = useState(false)
  const [hasScrolled, setHasScrolled] = useState(false)

  const onVisible = useCallback(() => {
    setIsVisible(true)
  }, [])

  useEffect(() => {
    const handleScroll = () => {
      if (window.scrollY > 0) {
        setHasScrolled(true)
        window.removeEventListener('scroll', handleScroll)
      }
    }
    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [])

  return (
    <>
      {hasScrolled && <InfiniteScroll onLoadMore={onVisible} />}
      <Typography
        component="h2"
        variant="subtitle1"
        sx={{
          fontWeight: 700,
        }}
      >
        Governance
      </Typography>
      <Typography
        variant="body2"
        sx={{
          mb: 2,
          color: 'text.secondary',
        }}
      >
        Use your SAFE tokens to vote on important proposals or participate in forum discussions.
      </Typography>
      <div className={css.lazyWrapper}>{isVisible && <GovernanceSection />}</div>
    </>
  )
}

// Prevent `GovernanceSection` hooks from needlessly being called
const GovernanceSectionWrapper = () => {
  const chainId = useChainId()
  if (!getSafeTokenAddress(chainId)) {
    return null
  }
  return <LazyGovernanceSection />
}

export default GovernanceSectionWrapper
</file>

<file path="src/components/dashboard/GovernanceSection/styles.module.css">
.lazyWrapper {
  height: 300px;
  overflow: hidden;
}

.widgetWrapper {
  height: 300px;
  border: none;
}

/* iframe sm breakpoint + paddings */
@media (max-width: 662px) {
  .widgetWrapper {
    height: 624px;
  }
}

.loadErrorCard {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: var(--space-2);
  text-align: center;
  flex-grow: 1;
}

.loadErrorCard:last-of-type {
  min-width: 300px;
}

.loadErrorMsgContainer {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  max-width: 80%;
}

.loadErroricon {
  font-size: 54px;
  position: relative;
  left: 3px;
  top: 3px;
}
</file>

<file path="src/components/dashboard/Overview/Overview.tsx">
import BuyCryptoButton from '@/components/common/BuyCryptoButton'
import TokenAmount from '@/components/common/TokenAmount'
import Track from '@/components/common/Track'
import QrCodeButton from '@/components/sidebar/QrCodeButton'
import { TxModalContext } from '@/components/tx-flow'
import { NewTxFlow } from '@/components/tx-flow/flows'
import SwapIcon from '@/public/images/common/swap.svg'
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import Link from 'next/link'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useVisibleBalances } from '@/hooks/useVisibleBalances'
import ArrowIconNW from '@/public/images/common/arrow-top-right.svg'
import ArrowIconSE from '@/public/images/common/arrow-se.svg'
import FiatValue from '@/components/common/FiatValue'
import { AppRoutes } from '@/config/routes'
import { Button, Grid, Skeleton, Typography, useMediaQuery } from '@mui/material'
import { useRouter } from 'next/router'
import { type ReactElement, useContext } from 'react'
import { WidgetBody, WidgetContainer } from '../styled'
import { useTheme } from '@mui/material/styles'
import { SWAP_EVENTS, SWAP_LABELS } from '@/services/analytics/events/swaps'
import useIsSwapFeatureEnabled from '@/features/swap/hooks/useIsSwapFeatureEnabled'

const SkeletonOverview = (
  <>
    <Grid
      container
      sx={{
        pb: 2,
        mt: 3,
        gap: 2,
        alignItems: 'flex-end',
        justifyContent: 'space-between',
      }}
    >
      <Grid item>
        <Skeleton variant="text" width={100} height={30} />
        <Skeleton variant="rounded" width={160} height={40} />
      </Grid>

      <Grid item>
        <Grid
          container
          sx={{
            gap: 1,
            flexWrap: 'wrap',
          }}
        >
          <Skeleton variant="rounded" width="115px" height="40px" />
          <Skeleton variant="rounded" width="115px" height="40px" />
        </Grid>
      </Grid>
    </Grid>
  </>
)

const Overview = (): ReactElement => {
  const { safe, safeLoading, safeLoaded } = useSafeInfo()
  const { balances, loading: balancesLoading } = useVisibleBalances()
  const { setTxFlow } = useContext(TxModalContext)
  const router = useRouter()
  const theme = useTheme()
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'))
  const isSwapFeatureEnabled = useIsSwapFeatureEnabled()

  const isInitialState = !safeLoaded && !safeLoading
  const isLoading = safeLoading || balancesLoading || isInitialState

  const handleOnSend = () => {
    setTxFlow(<NewTxFlow />, undefined, false)
    trackEvent(OVERVIEW_EVENTS.NEW_TRANSACTION)
  }

  const buttonWidth = isSwapFeatureEnabled ? 4 : 6

  return (
    <WidgetContainer>
      <WidgetBody>
        {isLoading ? (
          SkeletonOverview
        ) : (
          <>
            <Grid
              container
              sx={{
                pb: 2,
                mt: 3,
                gap: 2,
                alignItems: 'flex-end',
                justifyContent: 'space-between',
              }}
            >
              <Grid item>
                <Typography
                  sx={{
                    color: 'primary.light',
                    fontWeight: 'bold',
                    mb: 1,
                  }}
                >
                  Total asset value
                </Typography>
                <Typography
                  component="div"
                  variant="h1"
                  sx={{
                    fontSize: 44,
                    lineHeight: '40px',
                  }}
                >
                  {safe.deployed ? (
                    <FiatValue value={balances.fiatTotal} maxLength={20} precise />
                  ) : (
                    <TokenAmount
                      value={balances.items[0]?.balance}
                      decimals={balances.items[0]?.tokenInfo.decimals}
                      tokenSymbol={balances.items[0]?.tokenInfo.symbol}
                    />
                  )}
                </Typography>
              </Grid>

              {safe.deployed && (
                <Grid
                  item
                  container
                  spacing={1}
                  xs={12}
                  sm
                  sx={{
                    justifyContent: 'flex-end',
                    flexWrap: { xs: 'wrap', sm: 'nowrap' },
                  }}
                >
                  <Grid item xs={12} sm="auto">
                    <BuyCryptoButton />
                  </Grid>

                  <Grid item xs={buttonWidth} sm="auto">
                    <Button
                      onClick={handleOnSend}
                      size={isSmallScreen ? 'medium' : 'small'}
                      variant="outlined"
                      color="primary"
                      startIcon={<ArrowIconNW />}
                      fullWidth
                    >
                      Send
                    </Button>
                  </Grid>
                  <Grid item xs={buttonWidth} sm="auto">
                    <Track {...OVERVIEW_EVENTS.SHOW_QR} label="dashboard">
                      <QrCodeButton>
                        <Button
                          size={isSmallScreen ? 'medium' : 'small'}
                          variant="outlined"
                          color="primary"
                          startIcon={<ArrowIconSE />}
                          fullWidth
                        >
                          Receive
                        </Button>
                      </QrCodeButton>
                    </Track>
                  </Grid>

                  {isSwapFeatureEnabled && (
                    <Grid item xs={buttonWidth} sm="auto">
                      <Track {...SWAP_EVENTS.OPEN_SWAPS} label={SWAP_LABELS.dashboard}>
                        <Link href={{ pathname: AppRoutes.swap, query: router.query }} passHref type="button">
                          <Button
                            data-testid="overview-swap-btn"
                            size={isSmallScreen ? 'medium' : 'small'}
                            variant="outlined"
                            color="primary"
                            startIcon={<SwapIcon />}
                            fullWidth
                          >
                            Swap
                          </Button>
                        </Link>
                      </Track>
                    </Grid>
                  )}
                </Grid>
              )}
            </Grid>
          </>
        )}
      </WidgetBody>
    </WidgetContainer>
  )
}

export default Overview
</file>

<file path="src/components/dashboard/PendingTxs/PendingRecoveryListItem.tsx">
import Link from 'next/link'
import { useMemo } from 'react'
import { useRouter } from 'next/router'
import { ChevronRight } from '@mui/icons-material'
import { Box } from '@mui/material'
import type { ReactElement } from 'react'

import { RecoveryInfo } from '@/features/recovery/components/RecoveryInfo'
import { RecoveryStatus } from '@/features/recovery/components/RecoveryStatus'
import { RecoveryType } from '@/features/recovery/components/RecoveryType'
import { AppRoutes } from '@/config/routes'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

import css from './styles.module.css'

function PendingRecoveryListItem({ transaction }: { transaction: RecoveryQueueItem }): ReactElement {
  const router = useRouter()
  const { isMalicious } = transaction

  const url = useMemo(
    () => ({
      pathname: AppRoutes.transactions.queue,
      query: router.query,
    }),
    [router.query],
  )

  return (
    <Link href={url} passHref>
      <Box className={css.container} sx={{ minHeight: 50 }}>
        <Box flex={1}>
          <RecoveryType isMalicious={isMalicious} />
        </Box>

        <RecoveryInfo isMalicious={isMalicious} />

        <RecoveryStatus recovery={transaction} />

        <ChevronRight color="border" />
      </Box>
    </Link>
  )
}

export default PendingRecoveryListItem
</file>

<file path="src/components/dashboard/PendingTxs/PendingTxListItem.tsx">
import NextLink from 'next/link'
import { useRouter } from 'next/router'
import type { ReactElement } from 'react'
import { useMemo } from 'react'
import ChevronRight from '@mui/icons-material/ChevronRight'
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Box } from '@mui/material'
import { isMultisigExecutionInfo } from '@/utils/transaction-guards'
import TxInfo from '@/components/transactions/TxInfo'
import TxType from '@/components/transactions/TxType'
import css from './styles.module.css'
import { AppRoutes } from '@/config/routes'
import TxConfirmations from '@/components/transactions/TxConfirmations'

type PendingTxType = {
  transaction: TransactionSummary
}

const PendingTx = ({ transaction }: PendingTxType): ReactElement => {
  const router = useRouter()
  const { id } = transaction

  const url = useMemo(
    () => ({
      pathname: AppRoutes.transactions.tx,
      query: {
        id,
        safe: router.query.safe,
      },
    }),
    [router, id],
  )

  return (
    <NextLink data-testid="tx-pending-item" href={url} passHref>
      <Box className={css.container}>
        <Box className={css.innerContainer}>
          <Box sx={{ minWidth: 30 }}>
            {isMultisigExecutionInfo(transaction.executionInfo) && transaction.executionInfo.nonce}
          </Box>

          <Box sx={{ minWidth: 62 }}>
            <TxType tx={transaction} />
          </Box>

          <Box sx={{ minWidth: 0, flexGrow: 1 }}>
            <TxInfo info={transaction.txInfo} />
          </Box>
        </Box>

        <Box alignSelf="flex-start" display="flex" flexWrap="nowrap" alignItems="center" gap={1.5}>
          {isMultisigExecutionInfo(transaction.executionInfo) && (
            <TxConfirmations
              submittedConfirmations={transaction.executionInfo.confirmationsSubmitted}
              requiredConfirmations={transaction.executionInfo.confirmationsRequired}
            />
          )}

          <ChevronRight color="border" />
        </Box>
      </Box>
    </NextLink>
  )
}

export default PendingTx
</file>

<file path="src/components/dashboard/PendingTxs/PendingTxsList.tsx">
import type { ReactElement } from 'react'
import { useMemo } from 'react'
import { useRouter } from 'next/router'
import dynamic from 'next/dynamic'
import { getLatestTransactions } from '@/utils/tx-list'
import { Box, Skeleton, Typography } from '@mui/material'
import { Card, ViewAllLink, WidgetBody, WidgetContainer } from '../styled'
import PendingTxListItem from './PendingTxListItem'
import useTxQueue from '@/hooks/useTxQueue'
import { AppRoutes } from '@/config/routes'
import NoTransactionsIcon from '@/public/images/transactions/no-transactions.svg'
import css from './styles.module.css'
import { isSignableBy, isExecutable } from '@/utils/transaction-guards'
import useWallet from '@/hooks/wallets/useWallet'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useRecoveryQueue } from '@/features/recovery/hooks/useRecoveryQueue'
import type { Transaction } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

const PendingRecoveryListItem = dynamic(() => import('./PendingRecoveryListItem'))

const MAX_TXS = 4

const EmptyState = () => {
  return (
    <Card>
      <Box display="flex" flexDirection="column" alignItems="center" justifyContent="center" height="100%" gap={2}>
        <NoTransactionsIcon data-testid="no-tx-icon" />

        <Typography data-testid="no-tx-text" variant="body1" color="primary.light">
          This Safe Account has no queued transactions
        </Typography>
      </Box>
    </Card>
  )
}

const LoadingState = () => (
  <div className={css.list}>
    {Array.from(Array(MAX_TXS).keys()).map((key) => (
      <Skeleton key={key} variant="rectangular" height={52} />
    ))}
  </div>
)

function getActionableTransactions(txs: Transaction[], safe: SafeState, walletAddress?: string): Transaction[] {
  if (!walletAddress) {
    return txs
  }

  return txs.filter((tx) => {
    return isSignableBy(tx.transaction, walletAddress) || isExecutable(tx.transaction, walletAddress, safe)
  })
}

export function _getTransactionsToDisplay({
  recoveryQueue,
  queue,
  walletAddress,
  safe,
}: {
  recoveryQueue: RecoveryQueueItem[]
  queue: Transaction[]
  walletAddress?: string
  safe: SafeState
}): [RecoveryQueueItem[], Transaction[]] {
  if (recoveryQueue.length >= MAX_TXS) {
    return [recoveryQueue.slice(0, MAX_TXS), []]
  }

  const actionableQueue = getActionableTransactions(queue, safe, walletAddress)
  const _queue = actionableQueue.length > 0 ? actionableQueue : queue
  const queueToDisplay = _queue.slice(0, MAX_TXS - recoveryQueue.length)

  return [recoveryQueue, queueToDisplay]
}

const PendingTxsList = (): ReactElement | null => {
  const router = useRouter()
  const { page, loading } = useTxQueue()
  const { safe } = useSafeInfo()
  const wallet = useWallet()
  const queuedTxns = useMemo(() => getLatestTransactions(page?.results), [page?.results])
  const recoveryQueue = useRecoveryQueue()

  const [recoveryTxs, queuedTxs] = useMemo(() => {
    return _getTransactionsToDisplay({
      recoveryQueue,
      queue: queuedTxns,
      walletAddress: wallet?.address,
      safe,
    })
  }, [recoveryQueue, queuedTxns, wallet?.address, safe])

  const totalTxs = recoveryTxs.length + queuedTxs.length

  const queueUrl = useMemo(
    () => ({
      pathname: AppRoutes.transactions.queue,
      query: { safe: router.query.safe },
    }),
    [router.query.safe],
  )

  return (
    <WidgetContainer data-testid="pending-tx-widget">
      <div className={css.title}>
        <Typography component="h2" variant="subtitle1" fontWeight={700} mb={2}>
          Pending transactions
        </Typography>

        {totalTxs > 0 && <ViewAllLink url={queueUrl} />}
      </div>

      <WidgetBody>
        {loading ? (
          <LoadingState />
        ) : totalTxs > 0 ? (
          <div className={css.list}>
            {recoveryTxs.map((tx) => (
              <PendingRecoveryListItem transaction={tx} key={tx.transactionHash} />
            ))}

            {queuedTxs.map((tx) => (
              <PendingTxListItem transaction={tx.transaction} key={tx.transaction.id} />
            ))}
          </div>
        ) : (
          <EmptyState />
        )}
      </WidgetBody>
    </WidgetContainer>
  )
}

export default PendingTxsList
</file>

<file path="src/components/dashboard/PendingTxs/styles.module.css">
.container {
  width: 100%;
  padding: 11px 16px;
  background-color: var(--color-background-paper);
  border: 1px solid var(--color-background-paper);
  border-radius: 8px;
  flex-wrap: nowrap;
  display: flex;
  align-items: center;
  gap: var(--space-2);
  min-height: 50px;
}
.innerContainer {
  min-width: 0;
  flex-grow: 1;
  width: 100%;
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  gap: var(--space-2);
}
.container:hover {
  background-color: var(--color-background-light);
  border-color: var(--color-secondary-light);
}

.list {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
  width: 100%;
}

.skeleton {
  border-radius: 8px;
  overflow: hidden;
}

.title {
  display: flex;
  justify-content: space-between;
}

@media (max-width: 600px) {
  .container {
    flex-direction: column;
    align-items: start;
    flex-wrap: wrap;
  }
}
</file>

<file path="src/components/dashboard/SafeAppsDashboardSection/SafeAppsDashboardSection.tsx">
import { useRouter } from 'next/router'
import Typography from '@mui/material/Typography'
import Grid from '@mui/material/Grid'
import Button from '@mui/material/Button'

import { WidgetContainer } from '../styled'
import { useSafeApps } from '@/hooks/safe-apps/useSafeApps'
import useSafeAppPreviewDrawer from '@/hooks/safe-apps/useSafeAppPreviewDrawer'
import SafeAppPreviewDrawer from '@/components/safe-apps/SafeAppPreviewDrawer'
import SafeAppCard, { SafeAppCardContainer } from '@/components/safe-apps/SafeAppCard'
import { AppRoutes } from '@/config/routes'
import ExploreSafeAppsIcon from '@/public/images/apps/explore.svg'
import { SAFE_APPS_LABELS } from '@/services/analytics'

import css from './styles.module.css'

const SafeAppsDashboardSection = () => {
  const { rankedSafeApps, togglePin, pinnedSafeAppIds } = useSafeApps()
  const { isPreviewDrawerOpen, previewDrawerApp, openPreviewDrawer, closePreviewDrawer } = useSafeAppPreviewDrawer()

  return (
    <WidgetContainer>
      <Typography component="h2" variant="subtitle1" fontWeight={700} mb={2}>
        Safe Apps
      </Typography>

      <Grid container spacing={3}>
        {rankedSafeApps.map((rankedSafeApp) => (
          <Grid key={rankedSafeApp.id} item xs={12} sm={6} md={4} xl={4}>
            <SafeAppCard
              safeApp={rankedSafeApp}
              onBookmarkSafeApp={(appId) => togglePin(appId, SAFE_APPS_LABELS.dashboard)}
              isBookmarked={pinnedSafeAppIds.has(rankedSafeApp.id)}
              onClickSafeApp={(e) => {
                // Don't open link
                e.preventDefault()
                openPreviewDrawer(rankedSafeApp)
              }}
              openPreviewDrawer={openPreviewDrawer}
            />
          </Grid>
        ))}

        <Grid item xs={12} sm={6} md={4} xl={4}>
          <ExploreSafeAppsCard />
        </Grid>
      </Grid>

      <SafeAppPreviewDrawer
        isOpen={isPreviewDrawerOpen}
        safeApp={previewDrawerApp}
        isBookmarked={previewDrawerApp && pinnedSafeAppIds.has(previewDrawerApp.id)}
        onClose={closePreviewDrawer}
        onBookmark={(appId) => togglePin(appId, SAFE_APPS_LABELS.apps_sidebar)}
      />
    </WidgetContainer>
  )
}

export default SafeAppsDashboardSection

const ExploreSafeAppsCard = () => {
  const router = useRouter()
  const safeAppsLink = `${AppRoutes.apps.index}?safe=${router.query.safe}`

  return (
    <SafeAppCardContainer safeAppUrl={safeAppsLink} className={css.container}>
      <ExploreSafeAppsIcon alt="Explore Safe Apps icon" />

      <Button data-testid="explore-apps-btn" variant="contained" size="small">
        Explore Safe Apps
      </Button>
    </SafeAppCardContainer>
  )
}
</file>

<file path="src/components/dashboard/SafeAppsDashboardSection/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: var(--space-1);
  padding: var(--space-2);
}
</file>

<file path="src/components/dashboard/StakingBanner/index.tsx">
import { useMemo } from 'react'
import { Typography, Card, SvgIcon, Grid, Button, Box, Stack, Link } from '@mui/material'
import css from './styles.module.css'
import Kiln from '@/public/images/common/kiln.svg'
import StakeIllustrationLight from '@/public/images/common/stake-illustration-light.svg'
import StakeIllustrationDark from '@/public/images/common/stake-illustration-dark.svg'
import StakeIcon from '@/public/images/common/stake.svg'
import classNames from 'classnames'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useRouter } from 'next/router'
import NextLink from 'next/link'
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import ExternalLink from '@/components/common/ExternalLink'
import { useSanctionedAddress } from '@/hooks/useSanctionedAddress'
import { AppRoutes } from '@/config/routes'
import useBalances from '@/hooks/useBalances'
import { formatUnits } from 'ethers'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import useIsStakingBannerEnabled from '@/features/stake/hooks/useIsStakingBannerEnabled'

const LEARN_MORE_LINK = 'https://help.safe.global/en/articles/222615-safe-staking'
const MIN_NATIVE_TOKEN_BALANCE = 32

const StakingBanner = ({
  large = false,
  hideLocalStorageKey = 'hideStakingBanner',
}: { large?: boolean; hideLocalStorageKey?: string } = {}) => {
  const isDarkMode = useDarkMode()
  const router = useRouter()
  const { balances } = useBalances()

  const nativeTokenBalance = useMemo(
    () => balances.items.find((balance) => balance.tokenInfo.type === TokenType.NATIVE_TOKEN),
    [balances.items],
  )

  const hasSufficientFunds =
    nativeTokenBalance != null &&
    Number(formatUnits(nativeTokenBalance.balance, nativeTokenBalance.tokenInfo.decimals ?? 0)) >=
      MIN_NATIVE_TOKEN_BALANCE

  const [widgetHidden = false, setWidgetHidden] = useLocalStorage<boolean>(hideLocalStorageKey)

  const isStakingBannerEnabled = useIsStakingBannerEnabled()

  const sanctionedAddress = useSanctionedAddress(isStakingBannerEnabled && !widgetHidden)

  if (!isStakingBannerEnabled || widgetHidden || Boolean(sanctionedAddress) || !hasSufficientFunds) return null

  const onClick = () => {
    trackEvent(OVERVIEW_EVENTS.OPEN_STAKING_WIDGET)
  }

  const onHide = () => {
    setWidgetHidden(true)
    trackEvent(OVERVIEW_EVENTS.HIDE_STAKING_BANNER)
  }

  const onLearnMore = () => {
    trackEvent(OVERVIEW_EVENTS.OPEN_LEARN_MORE_STAKING_BANNER)
  }

  if (large) {
    return (
      <>
        <Card className={`${css.bannerWrapper} ${css.bannerWrapperLarge}`}>
          <Box
            sx={{
              mr: { sm: -8, md: -4, lg: 0 },
              display: { xs: 'none', sm: 'block' },
              position: 'relative',
            }}
          >
            <Box className={classNames(css.gradientShadow, { [css.gradientShadowDarkMode]: isDarkMode })} />
            <SvgIcon
              component={isDarkMode ? StakeIllustrationLight : StakeIllustrationDark}
              inheritViewBox
              className={classNames(css.stakeIllustration)}
            />
          </Box>

          <Grid container rowSpacing={2}>
            <Grid
              item
              xs={12}
              sx={{
                zIndex: 2,
                mb: 1,
              }}
            >
              <Stack spacing={0.5} direction="row">
                <Typography
                  variant="overline"
                  sx={{
                    color: 'primary.light',
                  }}
                >
                  Powered by
                </Typography>
                <SvgIcon
                  component={Kiln}
                  inheritViewBox
                  color="border"
                  className={classNames(css.kilnIcon, { [css.kilnIconDarkMode]: isDarkMode })}
                />
              </Stack>
            </Grid>

            <Grid
              item
              xs={12}
              sx={{
                zIndex: 2,
              }}
            >
              <Typography
                variant="h2"
                className={classNames(css.header, { [css.gradientText]: isDarkMode })}
                sx={{
                  fontWeight: 700,
                }}
              >
                Stake your ETH and earn rewards
              </Typography>
            </Grid>

            <Grid
              item
              xs={12}
              sm={6}
              sx={{
                zIndex: 2,
                mb: 1,
              }}
            >
              <Typography variant="body1">
                Lock 32 ETH and become a validator easily with the Kiln widget — faster and more cost-effective. You can
                also explore Safe Apps or home staking for other options. Staking involves risks like slashing.
              </Typography>
              {LEARN_MORE_LINK && (
                <ExternalLink onClick={onLearnMore} href={LEARN_MORE_LINK}>
                  Learn more
                </ExternalLink>
              )}
            </Grid>

            <Grid
              item
              container
              xs={12}
              spacing={2}
              sx={{
                textAlign: 'center',
              }}
            >
              <Grid item xs={12} md="auto">
                <NextLink
                  href={AppRoutes.stake && { pathname: AppRoutes.stake, query: { safe: router.query.safe } }}
                  passHref
                  rel="noreferrer"
                  onClick={onClick}
                >
                  <Button fullWidth variant="contained">
                    Stake ETH
                  </Button>
                </NextLink>
              </Grid>
              <Grid item xs={12} md="auto">
                <Button variant="text" onClick={onHide}>
                  Don&apos;t show again
                </Button>
              </Grid>
            </Grid>
          </Grid>
        </Card>
      </>
    )
  }

  return (
    <>
      <Card className={css.bannerWrapper}>
        {!isDarkMode && <Box className={classNames(css.gradientBackground)} />}

        <Stack
          direction={{ xs: 'column', md: 'row' }}
          spacing={2}
          sx={{
            alignItems: { xs: 'initial', md: 'center' },
            justifyContent: 'space-between',
          }}
        >
          <Stack
            direction="row"
            spacing={2}
            sx={{
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1,
            }}
          >
            <SvgIcon component={StakeIcon} sx={{ width: '16px', height: '16px' }} inheritViewBox />

            <Typography variant="body2">
              <strong>Stake ETH and earn rewards up to 5% APY.</strong> Lock 32 ETH to become a validator via the Kiln
              widget. You can also{' '}
              <NextLink
                href={{ pathname: AppRoutes.apps.index, query: { ...router.query, categories: ['Staking'] } }}
                passHref
                type="link"
              >
                <Link>explore Safe Apps</Link>
              </NextLink>{' '}
              and home staking for other options. Staking involves risks like slashing.
              {LEARN_MORE_LINK && (
                <>
                  {' '}
                  <ExternalLink onClick={onLearnMore} href={LEARN_MORE_LINK}>
                    Learn more
                  </ExternalLink>
                </>
              )}
            </Typography>
          </Stack>

          <Stack
            direction={{ xs: 'column', md: 'row' }}
            spacing={2}
            sx={{
              alignItems: { xs: 'center', md: 'flex-end' },
            }}
          >
            <Box>
              <Button variant="text" onClick={onHide} size="small" sx={{ whiteSpace: 'nowrap' }}>
                Don&apos;t show again
              </Button>
            </Box>
            <NextLink
              href={AppRoutes.stake && { pathname: AppRoutes.stake, query: { safe: router.query.safe } }}
              passHref
              rel="noreferrer"
              onClick={onClick}
              className={classNames(css.stakeButton)}
            >
              <Button fullWidth size="small" variant="contained">
                Stake
              </Button>
            </NextLink>
          </Stack>
        </Stack>
      </Card>
    </>
  )
}

export default StakingBanner
</file>

<file path="src/components/dashboard/StakingBanner/styles.module.css">
.bannerWrapper {
  position: relative;
  border: none;
  margin: 0;
  padding: var(--space-2);
}

.bannerWrapperLarge {
  padding: var(--space-4);
}

.stakeIllustration {
  position: absolute;
  width: 400px;
  height: inherit;
  right: 0;
}

.gradientShadow {
  width: 400px;
  height: 243px;
  background: linear-gradient(#b0ffc9, #5fddff);
  filter: blur(40px);
  position: absolute;
  right: 0;
  top: var(--space-8);
  border-radius: 50%;
}

.gradientShadowDarkMode {
  background: linear-gradient(#04491a, #087796);
}

.gradientBackground {
  width: 100%;
  height: 100%;
  background: linear-gradient(225deg, #d7f6ff, #b0ffc9);
  position: absolute;
  top: 0;
  left: 0;
}

.kilnIcon {
  height: 14px;
  width: inherit;
  margin-top: -1px;
}

.kilnIconDarkMode path {
  fill: var(--color-primary-light);
}

.gradientText {
  background: linear-gradient(225deg, #5fddff 12.5%, #12ff80 88.07%);
  background-clip: text;
  color: transparent;
}

.header {
  padding-right: var(--space-8);
}

.stakeButton {
  width: 100%;
}

@media (max-width: 899.99px) {
  .header {
    padding: 0;
  }

  .widgetWrapper {
    padding: var(--space-4);
  }
}
</file>

<file path="src/components/dashboard/index.tsx">
import FirstSteps from '@/components/dashboard/FirstSteps'
import useSafeInfo from '@/hooks/useSafeInfo'
import { type ReactElement } from 'react'
import dynamic from 'next/dynamic'
import { Grid } from '@mui/material'
import PendingTxsList from '@/components/dashboard/PendingTxs/PendingTxsList'
import AssetsWidget from '@/components/dashboard/Assets'
import Overview from '@/components/dashboard/Overview/Overview'
import SafeAppsDashboardSection from '@/components/dashboard/SafeAppsDashboardSection/SafeAppsDashboardSection'
import GovernanceSection from '@/components/dashboard/GovernanceSection/GovernanceSection'
import { useIsRecoverySupported } from '@/features/recovery/hooks/useIsRecoverySupported'
import StakingBanner from '@/components/dashboard/StakingBanner'
import { useHasFeature } from '@/hooks/useChains'
import css from './styles.module.css'
import { InconsistentSignerSetupWarning } from '@/features/multichain/components/SignerSetupWarning/InconsistentSignerSetupWarning'
import useIsStakingBannerEnabled from '@/features/stake/hooks/useIsStakingBannerEnabled'
import { UnsupportedMastercopyWarning } from '@/features/multichain/components/UnsupportedMastercopyWarning/UnsupportedMasterCopyWarning'
import SpacesDashboardWidget from 'src/features/spaces/components/SpacesDashboardWidget'
import { FEATURES } from '@safe-global/utils/utils/chains'

const RecoveryHeader = dynamic(() => import('@/features/recovery/components/RecoveryHeader'))

const Dashboard = (): ReactElement => {
  const { safe } = useSafeInfo()
  const showSafeApps = useHasFeature(FEATURES.SAFE_APPS)
  const isSpacesFeatureEnabled = useHasFeature(FEATURES.SPACES)
  const isStakingBannerEnabled = useIsStakingBannerEnabled()
  const supportsRecovery = useIsRecoverySupported()

  return (
    <>
      <Grid container spacing={3}>
        {supportsRecovery && <RecoveryHeader />}

        <Grid item xs={12} className={css.hideIfEmpty}>
          <InconsistentSignerSetupWarning />
        </Grid>

        {isSpacesFeatureEnabled && (
          <Grid item xs={12} className={css.hideIfEmpty}>
            <SpacesDashboardWidget />
          </Grid>
        )}

        <Grid item xs={12} className={css.hideIfEmpty}>
          <UnsupportedMastercopyWarning />
        </Grid>

        <Grid item xs={12}>
          <Overview />
        </Grid>

        <Grid item xs={12} className={css.hideIfEmpty}>
          <FirstSteps />
        </Grid>

        {safe.deployed && (
          <>
            {isStakingBannerEnabled && (
              <Grid item xs={12} className={css.hideIfEmpty}>
                <StakingBanner hideLocalStorageKey="hideStakingBannerDashboard" large />
              </Grid>
            )}

            <Grid item xs={12} />

            <Grid item xs={12} lg={6}>
              <AssetsWidget />
            </Grid>

            <Grid item xs={12} lg={6}>
              <PendingTxsList />
            </Grid>

            {showSafeApps && (
              <Grid item xs={12}>
                <SafeAppsDashboardSection />
              </Grid>
            )}

            <Grid item xs={12} className={css.hideIfEmpty}>
              <GovernanceSection />
            </Grid>
          </>
        )}
      </Grid>
    </>
  )
}

export default Dashboard
</file>

<file path="src/components/dashboard/styled.tsx">
import type { ReactElement } from 'react'
import styled from '@emotion/styled'
import NextLink from 'next/link'
import type { LinkProps } from 'next/link'
import { Link } from '@mui/material'
import ChevronRightIcon from '@mui/icons-material/ChevronRight'

export const WidgetContainer = styled.section`
  display: flex;
  flex-direction: column;
  height: 100%;
`

export const WidgetTitle = styled.h2`
  margin-top: 0;
`

export const WidgetBody = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  height: 100%;
`

export const Card = styled.div`
  background: var(--color-background-paper);
  padding: var(--space-3);
  border-radius: 6px;
  flex-grow: 1;
  position: relative;
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;

  & h2 {
    margin-top: 0;
  }
`

const StyledLink = styled(Link)`
  text-decoration: none;
  font-weight: bold;
  display: flex;
  align-items: center;
  gap: var(--space-1);
  margin-bottom: 10px;
  padding-right: 17px;
`

export const ViewAllLink = ({ url, text }: { url: LinkProps['href']; text?: string }): ReactElement => (
  <NextLink href={url} passHref legacyBehavior>
    <StyledLink data-testid="view-all-link">
      {text || 'View all'} <ChevronRightIcon />
    </StyledLink>
  </NextLink>
)
</file>

<file path="src/components/dashboard/styles.module.css">
.hideIfEmpty:empty {
  display: none;
}
</file>

<file path="src/components/new-safe/CardStepper/index.tsx">
import { useState } from 'react'
import { Box } from '@mui/system'
import lightPalette from '@/components/theme/lightPalette'
import css from './styles.module.css'
import { Card, LinearProgress, CardHeader, Avatar, Typography, CardContent } from '@mui/material'
import type { TxStepperProps } from './useCardStepper'
import { useCardStepper } from './useCardStepper'

export function CardStepper<StepperData>(props: TxStepperProps<StepperData>) {
  const [progressColor, setProgressColor] = useState(lightPalette.secondary.main)
  const { activeStep, onSubmit, onBack, stepData, setStep, setStepData } = useCardStepper<StepperData>(props)
  const { steps } = props
  const currentStep = steps[activeStep]
  const progress = ((activeStep + 1) / steps.length) * 100

  return (
    <Card className={css.card}>
      <Box className={css.progress} color={progressColor}>
        <LinearProgress color="inherit" variant="determinate" value={Math.min(progress, 100)} />
      </Box>
      {currentStep.title && (
        <CardHeader
          title={currentStep.title}
          subheader={currentStep.subtitle}
          titleTypographyProps={{ variant: 'h4' }}
          subheaderTypographyProps={{ variant: 'body2' }}
          avatar={
            <Avatar className={css.step}>
              <Typography variant="body2">{activeStep + 1}</Typography>
            </Avatar>
          }
          className={css.header}
        />
      )}
      <CardContent className={css.content}>
        {currentStep.render(stepData, onSubmit, onBack, setStep, setProgressColor, setStepData)}
      </CardContent>
    </Card>
  )
}
</file>

<file path="src/components/new-safe/CardStepper/styles.module.css">
.card {
  border: none;
}

.header {
  padding: var(--space-3) var(--space-2);
  border-bottom: 1px solid var(--color-border-light);
}

.header :global .MuiCardHeader-title {
  font-weight: 700;
}

.header :global .MuiCardHeader-subheader {
  color: var(--color-text-primary);
}

.step {
  background-color: var(--color-primary-main);
  height: 20px;
  width: 20px;
}

.content {
  padding: 0 !important;
}

.actions {
  padding: var(--space-3) 52px;
}

.progress :global .MuiLinearProgress-root::before {
  display: none;
}

@media (max-width: 599.95px) {
  .header {
    padding: var(--space-2);
    flex-direction: column;
    align-items: flex-start;
    gap: var(--space-1);
  }
}
</file>

<file path="src/components/new-safe/CardStepper/useCardStepper.ts">
import type { Dispatch, ReactElement, SetStateAction } from 'react'
import { useState } from 'react'
import { trackEvent, MODALS_CATEGORY } from '@/services/analytics'

export type StepRenderProps<TData> = {
  data: TData
  onSubmit: (data: Partial<TData>) => void
  onBack: (data?: Partial<TData>) => void
  setStep: (step: number) => void
  setProgressColor?: Dispatch<SetStateAction<string>>
  setStepData?: Dispatch<SetStateAction<TData>>
}

type Step<TData> = {
  title: string
  subtitle: string
  render: (
    data: StepRenderProps<TData>['data'],
    onSubmit: StepRenderProps<TData>['onSubmit'],
    onBack: StepRenderProps<TData>['onBack'],
    setStep: StepRenderProps<TData>['setStep'],
    setProgressColor: StepRenderProps<TData>['setProgressColor'],
    setStepData: StepRenderProps<TData>['setStepData'],
  ) => ReactElement
}

export type TxStepperProps<TData> = {
  steps: Array<Step<TData>>
  initialData: TData
  initialStep?: number
  eventCategory?: string
  setWidgetStep?: (step: number | SetStateAction<number>) => void
  onClose: () => void
}

export const useCardStepper = <TData>({
  steps,
  initialData,
  initialStep,
  eventCategory = MODALS_CATEGORY,
  onClose,
  setWidgetStep,
}: TxStepperProps<TData>) => {
  const [activeStep, setActiveStep] = useState<number>(initialStep || 0)
  const [stepData, setStepData] = useState(initialData)

  const handleNext = () => {
    setActiveStep((prevActiveStep) => prevActiveStep + 1)
    setWidgetStep && setWidgetStep((prevActiveStep) => prevActiveStep + 1)
    trackEvent({ category: eventCategory, action: lastStep ? 'Submit' : 'Next', label: activeStep })
  }

  const handleBack = (data?: Partial<TData>) => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1)
    setWidgetStep && setWidgetStep((prevActiveStep) => prevActiveStep - 1)
    trackEvent({ category: eventCategory, action: firstStep ? 'Cancel' : 'Back', label: activeStep })

    if (data) {
      setStepData((previous) => ({ ...previous, ...data }))
    }
  }

  const setStep = (step: number) => {
    setActiveStep(step)
    setWidgetStep && setWidgetStep(step)
  }

  const firstStep = activeStep === 0
  const lastStep = activeStep === steps.length - 1

  const onBack = firstStep ? onClose : handleBack

  const onSubmit = (data: Partial<TData>) => {
    if (lastStep) {
      onClose()
      return
    }
    setStepData((previous) => ({ ...previous, ...data }))
    handleNext()
  }

  return {
    onBack,
    onSubmit,
    setStep,
    activeStep,
    stepData,
    firstStep,
    setStepData,
  }
}
</file>

<file path="src/components/new-safe/create/CreateSafeInfos/index.tsx">
import InfoWidget from '@/components/new-safe/create/InfoWidget'
import { Grid } from '@mui/material'
import type { AlertColor } from '@mui/material'
import { type ReactElement } from 'react'

export type CreateSafeInfoItem = {
  title: string
  variant: AlertColor
  steps: { title: string; text: string | ReactElement }[]
}

const CreateSafeInfos = ({
  staticHint,
  dynamicHint,
}: {
  staticHint?: CreateSafeInfoItem
  dynamicHint?: CreateSafeInfoItem
}) => {
  if (!staticHint && !dynamicHint) {
    return null
  }

  return (
    <Grid item xs={12}>
      <Grid
        container
        direction="column"
        sx={{
          gap: 3,
        }}
      >
        {staticHint && (
          <Grid item>
            <InfoWidget title={staticHint.title} variant={staticHint.variant} steps={staticHint.steps} />
          </Grid>
        )}
        {dynamicHint && (
          <Grid item>
            <InfoWidget
              title={dynamicHint.title}
              variant={dynamicHint.variant}
              steps={dynamicHint.steps}
              startExpanded
            />
          </Grid>
        )}
      </Grid>
    </Grid>
  )
}

export default CreateSafeInfos
</file>

<file path="src/components/new-safe/create/InfoWidget/index.tsx">
import {
  Accordion,
  AccordionDetails,
  AccordionSummary,
  Box,
  Card,
  CardContent,
  CardHeader,
  IconButton,
  SvgIcon,
  Typography,
} from '@mui/material'
import type { AlertColor } from '@mui/material'
import type { ReactElement } from 'react'
import LightbulbIcon from '@/public/images/common/lightbulb.svg'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import css from 'src/components/new-safe/create/InfoWidget/styles.module.css'
import { CREATE_SAFE_EVENTS, trackEvent } from '@/services/analytics'

type InfoWidgetProps = {
  title: string
  steps: { title: string; text: string | ReactElement }[]
  variant: AlertColor
  startExpanded?: boolean
}

const InfoWidget = ({ title, steps, variant, startExpanded = false }: InfoWidgetProps): ReactElement | null => {
  if (steps.length === 0) {
    return null
  }

  return (
    <Card
      sx={{
        backgroundColor: ({ palette }) => palette[variant]?.background,
        borderColor: ({ palette }) => palette[variant]?.main,
        borderWidth: 1,
      }}
    >
      <CardHeader
        className={css.cardHeader}
        title={
          <Box className={css.title} sx={{ backgroundColor: ({ palette }) => palette[variant]?.main }}>
            <SvgIcon component={LightbulbIcon} inheritViewBox className={css.titleIcon} />
            <Typography variant="caption">
              <b>{title}</b>
            </Typography>
          </Box>
        }
      />
      <Box className={css.tipsList}>
        <CardContent>
          {steps.map(({ title, text }) => {
            return (
              <Accordion
                key={title}
                className={css.tipAccordion}
                defaultExpanded={startExpanded}
                onChange={(e, expanded) => expanded && trackEvent({ ...CREATE_SAFE_EVENTS.OPEN_HINT, label: title })}
              >
                <AccordionSummary
                  expandIcon={
                    <IconButton sx={{ '&:hover': { background: ({ palette }) => palette[variant]?.light } }}>
                      <ExpandMoreIcon sx={{ color: ({ palette }) => palette[variant]?.main }} />
                    </IconButton>
                  }
                >
                  {title}
                </AccordionSummary>
                <AccordionDetails>
                  <Typography variant="body2">{text}</Typography>
                </AccordionDetails>
              </Accordion>
            )
          })}
        </CardContent>
      </Box>
    </Card>
  )
}

export default InfoWidget
</file>

<file path="src/components/new-safe/create/InfoWidget/styles.module.css">
.cardHeader {
  padding-bottom: 0px;
}

.title {
  width: fit-content;
  padding: 4px var(--space-1);
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.titleIcon {
  font-size: 12px;
}

.tipsList :global .MuiCardContent-root {
  padding: 0;
}

.tipAccordion {
  background-color: inherit;
  border: none;
}

.tipAccordion :global .MuiAccordionSummary-root:hover {
  background: inherit;
}

.tipAccordion :global .Mui-expanded.MuiAccordionSummary-root {
  background: inherit;
  font-weight: bold;
}

.tipAccordion :global .MuiAccordionDetails-root {
  padding-top: 0;
}
</file>

<file path="src/components/new-safe/create/logic/address-book.ts">
import type { AppThunk } from '@/store'
import { addOrUpdateSafe } from '@/store/addedSafesSlice'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'
import { defaultSafeInfo } from '@safe-global/store/slices/SafeInfo/utils'
import type { NamedAddress } from '@/components/new-safe/create/types'

export const updateAddressBook = (
  chainIds: string[],
  address: string,
  name: string,
  owners: NamedAddress[],
  threshold: number,
): AppThunk => {
  return (dispatch) => {
    dispatch(
      upsertAddressBookEntries({
        chainIds,
        address,
        name,
      }),
    )

    owners.forEach((owner) => {
      const entryName = owner.name || owner.ens
      if (entryName) {
        dispatch(upsertAddressBookEntries({ chainIds, address: owner.address, name: entryName }))
      }
    })

    chainIds.forEach((chainId) => {
      dispatch(
        addOrUpdateSafe({
          safe: {
            ...defaultSafeInfo,
            address: { value: address, name },
            threshold,
            owners: owners.map((owner) => ({
              value: owner.address,
              name: owner.name || owner.ens,
            })),
            chainId,
            nonce: 0,
          },
        }),
      )
    })
  }
}
</file>

<file path="src/components/new-safe/create/logic/index.ts">
import type { SafeVersion } from '@safe-global/safe-core-sdk-types'
import { type Eip1193Provider, type Provider } from 'ethers'
import semverSatisfies from 'semver/functions/satisfies'

import { getSafeInfo, type SafeInfo, type ChainInfo, relayTransaction } from '@safe-global/safe-gateway-typescript-sdk'
import { getReadOnlyProxyFactoryContract } from '@/services/contracts/safeContracts'
import type { UrlObject } from 'url'
import { AppRoutes } from '@/config/routes'
import { SAFE_APPS_EVENTS, trackEvent } from '@/services/analytics'
import { predictSafeAddress, SafeFactory, SafeProvider } from '@safe-global/protocol-kit'
import type { DeploySafeProps, PredictedSafeProps } from '@safe-global/protocol-kit'

import { backOff } from 'exponential-backoff'
import { EMPTY_DATA, ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import {
  getCompatibilityFallbackHandlerDeployment,
  getProxyFactoryDeployment,
  getSafeL2SingletonDeployment,
  getSafeSingletonDeployment,
  getSafeToL2SetupDeployment,
} from '@safe-global/safe-deployments'
import { ECOSYSTEM_ID_ADDRESS } from '@/config/constants'
import type { ReplayedSafeProps, UndeployedSafeProps } from '@safe-global/utils/features/counterfactual/store/types'
import { activateReplayedSafe, isPredictedSafeProps } from '@/features/counterfactual/utils'
import { getSafeContractDeployment } from '@safe-global/utils/services/contracts/deployments'
import {
  Safe__factory,
  Safe_proxy_factory__factory,
  Safe_to_l2_setup__factory,
} from '@safe-global/utils/types/contracts'
import { createWeb3 } from '@/hooks/wallets/web3'
import { hasMultiChainCreationFeatures } from '@/features/multichain/utils/utils'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'
import { isValidSafeVersion } from '@safe-global/utils/services/contracts/utils'

export type SafeCreationProps = {
  owners: string[]
  threshold: number
  saltNonce: number
}

const getSafeFactory = async (
  provider: Eip1193Provider,
  safeVersion: SafeVersion,
  isL1SafeSingleton?: boolean,
): Promise<SafeFactory> => {
  if (!isValidSafeVersion(safeVersion)) {
    throw new Error('Invalid Safe version')
  }
  return SafeFactory.init({ provider, safeVersion, isL1SafeSingleton })
}

/**
 * Create a Safe creation transaction via Core SDK and submits it to the wallet
 */
export const createNewSafe = async (
  provider: Eip1193Provider,
  undeployedSafeProps: UndeployedSafeProps,
  safeVersion: SafeVersion,
  chain: ChainInfo,
  options: DeploySafeProps['options'],
  callback: (txHash: string) => void,
  isL1SafeSingleton?: boolean,
): Promise<void> => {
  const safeFactory = await getSafeFactory(provider, safeVersion, isL1SafeSingleton)

  if (isPredictedSafeProps(undeployedSafeProps)) {
    await safeFactory.deploySafe({ ...undeployedSafeProps, options, callback })
  } else {
    const txResponse = await activateReplayedSafe(chain, undeployedSafeProps, createWeb3(provider), options)
    callback(txResponse.hash)
  }
}

/**
 * Compute the new counterfactual Safe address before it is actually created
 */
export const computeNewSafeAddress = async (
  provider: Eip1193Provider | string,
  props: DeploySafeProps,
  chain: ChainInfo,
  safeVersion?: SafeVersion,
): Promise<string> => {
  const safeProvider = new SafeProvider({ provider })

  return predictSafeAddress({
    safeProvider,
    chainId: BigInt(chain.chainId),
    safeAccountConfig: props.safeAccountConfig,
    safeDeploymentConfig: {
      saltNonce: props.saltNonce,
      safeVersion: safeVersion ?? getLatestSafeVersion(chain),
    },
  })
}

export const encodeSafeSetupCall = (safeAccountConfig: ReplayedSafeProps['safeAccountConfig']) => {
  return Safe__factory.createInterface().encodeFunctionData('setup', [
    safeAccountConfig.owners,
    safeAccountConfig.threshold,
    safeAccountConfig.to,
    safeAccountConfig.data,
    safeAccountConfig.fallbackHandler,
    ZERO_ADDRESS,
    0,
    safeAccountConfig.paymentReceiver,
  ])
}

/**
 * Encode a Safe creation transaction NOT using the Core SDK because it doesn't support that
 * This is used for gas estimation.
 */
export const encodeSafeCreationTx = (undeployedSafe: UndeployedSafeProps, chain: ChainInfo) => {
  const replayedSafeProps = assertNewUndeployedSafeProps(undeployedSafe, chain)

  return Safe_proxy_factory__factory.createInterface().encodeFunctionData('createProxyWithNonce', [
    replayedSafeProps.masterCopy,
    encodeSafeSetupCall(replayedSafeProps.safeAccountConfig),
    BigInt(replayedSafeProps.saltNonce),
  ])
}

export const estimateSafeCreationGas = async (
  chain: ChainInfo,
  provider: Provider,
  from: string,
  undeployedSafe: UndeployedSafeProps,
  safeVersion?: SafeVersion,
): Promise<bigint> => {
  const readOnlyProxyFactoryContract = await getReadOnlyProxyFactoryContract(safeVersion ?? getLatestSafeVersion(chain))
  const encodedSafeCreationTx = encodeSafeCreationTx(undeployedSafe, chain)

  const gas = await provider.estimateGas({
    from,
    to: await readOnlyProxyFactoryContract.getAddress(),
    data: encodedSafeCreationTx,
  })

  return gas
}

export const pollSafeInfo = async (chainId: string, safeAddress: string): Promise<SafeInfo> => {
  // exponential delay between attempts for around 4 min
  return backOff(() => getSafeInfo(chainId, safeAddress), {
    startingDelay: 750,
    maxDelay: 20000,
    numOfAttempts: 19,
    retry: (e) => {
      console.info('waiting for client-gateway to provide safe information', e)
      return true
    },
  })
}

export const getRedirect = (
  chainPrefix: string,
  safeAddress: string,
  redirectQuery?: string | string[],
): UrlObject | string => {
  const redirectUrl = Array.isArray(redirectQuery) ? redirectQuery[0] : redirectQuery
  const address = `${chainPrefix}:${safeAddress}`

  // Should never happen in practice
  if (!chainPrefix) return AppRoutes.index

  // Go to the dashboard if no specific redirect is provided
  if (!redirectUrl || !redirectUrl.startsWith(AppRoutes.apps.index)) {
    return { pathname: AppRoutes.home, query: { safe: address } }
  }

  // Otherwise, redirect to the provided URL (e.g. from a Safe App)

  // Track the redirect to Safe App
  trackEvent(SAFE_APPS_EVENTS.SHARED_APP_OPEN_AFTER_SAFE_CREATION)

  // We're prepending the safe address directly here because the `router.push` doesn't parse
  // The URL for already existing query params
  // TODO: Check if we can accomplish this with URLSearchParams or URL instead
  const hasQueryParams = redirectUrl.includes('?')
  const appendChar = hasQueryParams ? '&' : '?'
  return redirectUrl + `${appendChar}safe=${address}`
}

export const relaySafeCreation = async (chain: ChainInfo, undeployedSafeProps: UndeployedSafeProps) => {
  const replayedSafeProps = assertNewUndeployedSafeProps(undeployedSafeProps, chain)
  const encodedSafeCreationTx = encodeSafeCreationTx(replayedSafeProps, chain)

  const relayResponse = await relayTransaction(chain.chainId, {
    to: replayedSafeProps.factoryAddress,
    data: encodedSafeCreationTx,
    version: replayedSafeProps.safeVersion,
  })

  return relayResponse.taskId
}

export type UndeployedSafeWithoutSalt = Omit<ReplayedSafeProps, 'saltNonce'>

/**
 * Creates a new undeployed Safe without default config:
 *
 * Always use the L1 MasterCopy and add a migration to L2 in to the setup.
 * Use our ecosystem ID as paymentReceiver.
 *
 */
export const createNewUndeployedSafeWithoutSalt = (
  safeVersion: SafeVersion,
  safeAccountConfig: Pick<ReplayedSafeProps['safeAccountConfig'], 'owners' | 'threshold'> & {
    paymentReceiver?: string
  },
  chain: ChainInfo,
): UndeployedSafeWithoutSalt => {
  // Create universal deployment Data across chains:
  const fallbackHandlerDeployment = getCompatibilityFallbackHandlerDeployment({
    version: safeVersion,
    network: chain.chainId,
  })
  const fallbackHandlerAddress = fallbackHandlerDeployment?.networkAddresses[chain.chainId]
  const safeL2Deployment = getSafeL2SingletonDeployment({ version: safeVersion, network: chain.chainId })
  const safeL2Address = safeL2Deployment?.networkAddresses[chain.chainId]

  const safeL1Deployment = getSafeSingletonDeployment({ version: safeVersion, network: chain.chainId })
  const safeL1Address = safeL1Deployment?.networkAddresses[chain.chainId]

  const safeFactoryDeployment = getProxyFactoryDeployment({ version: safeVersion, network: chain.chainId })
  const safeFactoryAddress = safeFactoryDeployment?.networkAddresses[chain.chainId]

  if (!safeL2Address || !safeL1Address || !safeFactoryAddress || !fallbackHandlerAddress) {
    throw new Error('No Safe deployment found')
  }

  const safeToL2SetupDeployment = getSafeToL2SetupDeployment({ version: '1.4.1', network: chain.chainId })
  const safeToL2SetupAddress = safeToL2SetupDeployment?.networkAddresses[chain.chainId]
  const safeToL2SetupInterface = Safe_to_l2_setup__factory.createInterface()

  // Only do migration if the chain supports multiChain deployments and has a SafeToL2Setup deployment
  const includeMigration =
    hasMultiChainCreationFeatures(chain) && semverSatisfies(safeVersion, '>=1.4.1') && Boolean(safeToL2SetupAddress)

  const masterCopy = includeMigration ? safeL1Address : chain.l2 ? safeL2Address : safeL1Address

  const replayedSafe: Omit<ReplayedSafeProps, 'saltNonce'> = {
    factoryAddress: safeFactoryAddress,
    masterCopy,
    safeAccountConfig: {
      threshold: safeAccountConfig.threshold,
      owners: safeAccountConfig.owners,
      fallbackHandler: fallbackHandlerAddress,
      to: includeMigration && safeToL2SetupAddress ? safeToL2SetupAddress : ZERO_ADDRESS,
      data: includeMigration ? safeToL2SetupInterface.encodeFunctionData('setupToL2', [safeL2Address]) : EMPTY_DATA,
      paymentReceiver: safeAccountConfig.paymentReceiver ?? ECOSYSTEM_ID_ADDRESS,
    },
    safeVersion,
  }

  return replayedSafe
}

/**
 * Migrates a counterfactual Safe from the pre multichain era to the new predicted Safe data
 * @param predictedSafeProps
 * @param chain
 * @returns
 */
export const migrateLegacySafeProps = (predictedSafeProps: PredictedSafeProps, chain: ChainInfo): ReplayedSafeProps => {
  const safeVersion = predictedSafeProps.safeDeploymentConfig?.safeVersion
  const saltNonce = predictedSafeProps.safeDeploymentConfig?.saltNonce
  const { chainId } = chain
  if (!safeVersion || !saltNonce) {
    throw new Error('Undeployed Safe with incomplete data.')
  }

  const fallbackHandlerDeployment = getCompatibilityFallbackHandlerDeployment({
    version: safeVersion,
    network: chainId,
  })
  const fallbackHandlerAddress = fallbackHandlerDeployment?.defaultAddress

  const masterCopyDeployment = getSafeContractDeployment(chain, safeVersion)
  const masterCopyAddress = masterCopyDeployment?.defaultAddress

  const safeFactoryDeployment = getProxyFactoryDeployment({ version: safeVersion, network: chainId })
  const safeFactoryAddress = safeFactoryDeployment?.defaultAddress

  if (!masterCopyAddress || !safeFactoryAddress || !fallbackHandlerAddress) {
    throw new Error('No Safe deployment found')
  }

  return {
    factoryAddress: safeFactoryAddress,
    masterCopy: masterCopyAddress,
    safeAccountConfig: {
      threshold: predictedSafeProps.safeAccountConfig.threshold,
      owners: predictedSafeProps.safeAccountConfig.owners,
      fallbackHandler: predictedSafeProps.safeAccountConfig.fallbackHandler ?? fallbackHandlerAddress,
      to: predictedSafeProps.safeAccountConfig.to ?? ZERO_ADDRESS,
      data: predictedSafeProps.safeAccountConfig.data ?? EMPTY_DATA,
      paymentReceiver: predictedSafeProps.safeAccountConfig.paymentReceiver ?? ZERO_ADDRESS,
    },
    safeVersion,
    saltNonce,
  }
}

export const assertNewUndeployedSafeProps = (props: UndeployedSafeProps, chain: ChainInfo): ReplayedSafeProps => {
  if (isPredictedSafeProps(props)) {
    return migrateLegacySafeProps(props, chain)
  }

  return props
}
</file>

<file path="src/components/new-safe/create/logic/utils.ts">
import { isSmartContract } from '@/utils/wallets'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { createWeb3ReadOnly, getRpcServiceUrl } from '@/hooks/wallets/web3'
import { type ReplayedSafeProps } from '@safe-global/utils/features/counterfactual/store/types'
import { predictAddressBasedOnReplayData } from '@/features/multichain/utils/utils'
import chains from '@/config/chains'
import { computeNewSafeAddress } from '.'

export const getAvailableSaltNonce = async (
  customRpcs: {
    [chainId: string]: string
  },
  replayedSafe: ReplayedSafeProps,
  chainInfos: ChainInfo[],
  // All addresses from the sidebar disregarding the chain. This is an optimization to reduce RPC calls
  knownSafeAddresses: string[],
): Promise<string> => {
  let isAvailableOnAllChains = true
  const allRPCs = chainInfos.map((chain) => {
    const rpcUrl = customRpcs?.[chain.chainId] || getRpcServiceUrl(chain.rpcUri)
    // Turn into Eip1993Provider
    return {
      rpcUrl,
      chainId: chain.chainId,
    }
  })

  for (const chain of chainInfos) {
    const rpcUrl = allRPCs.find((rpc) => chain.chainId === rpc.chainId)?.rpcUrl
    if (!rpcUrl) {
      throw new Error(`No RPC available for  ${chain.chainName}`)
    }
    const web3ReadOnly = createWeb3ReadOnly(chain, rpcUrl)
    if (!web3ReadOnly) {
      throw new Error('Could not initiate RPC')
    }
    let safeAddress: string
    // FIXME a new check to indicate ZKsync chain will be added to the config service and available under ChainInfo
    if (chain.chainId === chains['zksync'] || chain.chainId === chains['lens']) {
      // ZK-sync is using a different create2 method which is supported by the SDK
      safeAddress = await computeNewSafeAddress(
        rpcUrl,
        {
          safeAccountConfig: replayedSafe.safeAccountConfig,
          saltNonce: replayedSafe.saltNonce,
        },
        chain,
        replayedSafe.safeVersion,
      )
    } else {
      safeAddress = await predictAddressBasedOnReplayData(replayedSafe, web3ReadOnly)
    }
    const isKnown = knownSafeAddresses.some((knownAddress) => sameAddress(knownAddress, safeAddress))
    if (isKnown || (await isSmartContract(safeAddress, web3ReadOnly))) {
      // We found a chain where the nonce is used up
      isAvailableOnAllChains = false
      break
    }
  }

  // Safe is already deployed so we try the next saltNonce
  if (!isAvailableOnAllChains) {
    return getAvailableSaltNonce(
      customRpcs,
      { ...replayedSafe, saltNonce: (Number(replayedSafe.saltNonce) + 1).toString() },
      chainInfos,
      knownSafeAddresses,
    )
  }

  return replayedSafe.saltNonce
}
</file>

<file path="src/components/new-safe/create/NetworkWarning/index.tsx">
import { Alert, AlertTitle, Box } from '@mui/material'
import { useCurrentChain } from '@/hooks/useChains'
import ChainSwitcher from '@/components/common/ChainSwitcher'
import useIsWrongChain from '@/hooks/useIsWrongChain'

const NetworkWarning = ({ action }: { action?: string }) => {
  const chain = useCurrentChain()
  const isWrongChain = useIsWrongChain()

  if (!chain || !isWrongChain) return null

  return (
    <Alert severity="warning">
      <AlertTitle sx={{ fontWeight: 700 }}>Change your wallet network</AlertTitle>You are trying to{' '}
      {action || 'sign or execute a transaction'} on {chain.chainName}. Make sure that your wallet is set to the same
      network.
      <Box
        sx={{
          mt: 2,
        }}
      >
        <ChainSwitcher />
      </Box>
    </Alert>
  )
}

export default NetworkWarning
</file>

<file path="src/components/new-safe/create/NoWalletConnectedWarning/index.tsx">
import { Alert, AlertTitle, Box } from '@mui/material'
import useWallet from '@/hooks/wallets/useWallet'
import ConnectWalletButton from '@/components/common/ConnectWallet/ConnectWalletButton'

const NoWalletConnectedWarning = () => {
  const wallet = useWallet()

  if (wallet) {
    return null
  }

  return (
    <Alert severity="warning" sx={{ mt: 3 }}>
      <AlertTitle sx={{ fontWeight: 700 }}>No wallet connected</AlertTitle>You need to connect a wallet to create a Safe
      account.
      <Box
        sx={{
          mt: 2,
        }}
      >
        <ConnectWalletButton />
      </Box>
    </Alert>
  )
}

export default NoWalletConnectedWarning
</file>

<file path="src/components/new-safe/create/OverviewWidget/index.tsx">
import WalletOverview from 'src/components/common/WalletOverview'
import useWallet from '@/hooks/wallets/useWallet'
import { Box, Card, Grid, Typography } from '@mui/material'
import type { ReactElement } from 'react'
import SafeLogo from '@/public/images/logo-no-text.svg'

import css from '@/components/new-safe/create/OverviewWidget/styles.module.css'
import ConnectWalletButton from '@/components/common/ConnectWallet/ConnectWalletButton'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import NetworkLogosList from '@/features/multichain/components/NetworkLogosList'

const LOGO_DIMENSIONS = '22px'

const OverviewWidget = ({ safeName, networks }: { safeName: string; networks: ChainInfo[] }): ReactElement | null => {
  const wallet = useWallet()
  const rows = [
    ...(wallet ? [{ title: 'Wallet', component: <WalletOverview wallet={wallet} /> }] : []),
    ...(safeName !== '' ? [{ title: 'Name', component: <Typography>{safeName}</Typography> }] : []),
    ...(networks.length
      ? [
          {
            title: 'Network(s)',
            component: <NetworkLogosList networks={networks} />,
          },
        ]
      : []),
  ]

  return (
    <Grid item xs={12}>
      <Card className={css.card}>
        <div className={css.header}>
          <SafeLogo alt="Safe logo" width={LOGO_DIMENSIONS} height={LOGO_DIMENSIONS} />
          <Typography variant="h4">Your Safe Account preview</Typography>
        </div>
        {wallet ? (
          rows.map((row) => (
            <div key={row.title} className={css.row}>
              <Typography variant="body2">{row.title}</Typography>
              {row.component}
            </div>
          ))
        ) : (
          <Box p={2}>
            <Typography variant="body2" color="border.main" textAlign="center" width={1} mb={1}>
              Connect your wallet to continue
            </Typography>
            <ConnectWalletButton />
          </Box>
        )}
      </Card>
    </Grid>
  )
}

export default OverviewWidget
</file>

<file path="src/components/new-safe/create/OverviewWidget/styles.module.css">
.card {
  border: 1px solid var(--color-border-light);
  width: 100%;
}

.header {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-2);
}

.row {
  padding: var(--space-2);
  display: flex;
  flex-grow: 1;
  justify-content: space-between;
  align-items: center;
  border-top: 1px solid var(--color-border-light);
  gap: var(--space-1);
}
</file>

<file path="src/components/new-safe/create/steps/AdvancedOptionsStep/index.tsx">
import { predictAddressBasedOnReplayData } from '@/features/multichain/utils/utils'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { Button, MenuItem, Divider, Box, TextField, Stack, Skeleton, SvgIcon, Tooltip, Typography } from '@mui/material'
import { Controller, FormProvider, useForm } from 'react-hook-form'
import { type ReactElement, useMemo } from 'react'

import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NewSafeFormData } from '@/components/new-safe/create'
import useSyncSafeCreationStep from '@/components/new-safe/create/useSyncSafeCreationStep'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import layoutCss from '@/components/new-safe/create/styles.module.css'
import { type SafeVersion } from '@safe-global/safe-core-sdk-types'
import NumberField from '@/components/common/NumberField'
import { useCurrentChain } from '@/hooks/useChains'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { createNewUndeployedSafeWithoutSalt } from '../../logic'
import EthHashInfo from '@/components/common/EthHashInfo'
import InfoIcon from '@/public/images/notifications/info.svg'
import { isSmartContract } from '@/utils/wallets'

enum AdvancedOptionsFields {
  safeVersion = 'safeVersion',
  saltNonce = 'saltNonce',
  paymentReceiver = 'paymentReceiver',
}

export type AdvancedOptionsStepForm = {
  [AdvancedOptionsFields.safeVersion]: SafeVersion
  [AdvancedOptionsFields.saltNonce]: number
  [AdvancedOptionsFields.paymentReceiver]: string
}

const ADVANCED_OPTIONS_STEP_FORM_ID = 'create-safe-advanced-options-step-form'

const AdvancedOptionsStep = ({ onSubmit, onBack, data, setStep }: StepRenderProps<NewSafeFormData>): ReactElement => {
  useSyncSafeCreationStep(setStep, data.networks)
  const chain = useCurrentChain()
  const provider = useWeb3ReadOnly()

  const formMethods = useForm<AdvancedOptionsStepForm>({
    mode: 'onChange',
    defaultValues: data,
  })

  const { handleSubmit, control, watch, formState, getValues, register } = formMethods

  const selectedSafeVersion = watch(AdvancedOptionsFields.safeVersion)
  const selectedSaltNonce = watch(AdvancedOptionsFields.saltNonce)
  const selectedPaymentReceiver = watch(AdvancedOptionsFields.paymentReceiver)

  const newSafeProps = useMemo(
    () =>
      chain
        ? createNewUndeployedSafeWithoutSalt(
            selectedSafeVersion,
            {
              owners: data.owners.map((owner) => owner.address),
              threshold: data.threshold,
              paymentReceiver: selectedPaymentReceiver,
            },
            chain,
          )
        : undefined,
    [chain, data.owners, data.threshold, selectedSafeVersion, selectedPaymentReceiver],
  )

  const [predictedSafeAddress] = useAsync(async () => {
    if (!provider || !newSafeProps) return

    const replayedSafeWithNonce = { ...newSafeProps, saltNonce: selectedSaltNonce.toString() }

    return predictAddressBasedOnReplayData(replayedSafeWithNonce, provider)
  }, [provider, newSafeProps, selectedSaltNonce])

  const [isDeployed] = useAsync(
    async () => (predictedSafeAddress ? await isSmartContract(predictedSafeAddress) : false),
    [predictedSafeAddress],
  )

  const isDisabled = !formState.isValid || Boolean(isDeployed)

  const handleBack = () => {
    const formData = getValues()
    onBack(formData)
  }

  const onFormSubmit = handleSubmit((data) => {
    onSubmit(data)

    // TODO: Tracking of advanced setup
  })

  return (
    <form data-testid="advanced-options-step-form" onSubmit={onFormSubmit} id={ADVANCED_OPTIONS_STEP_FORM_ID}>
      <FormProvider {...formMethods}>
        <Stack spacing={2}>
          <Box className={layoutCss.row}>
            <Typography
              variant="h5"
              sx={{
                fontWeight: 700,
                display: 'inline-flex',
                alignItems: 'center',
                gap: 1,
              }}
            >
              Safe version
              <Tooltip
                title="The threshold of a Safe Account specifies how many signers need to confirm a Safe Account transaction before it can be executed."
                arrow
                placement="top"
              >
                <span style={{ display: 'flex' }}>
                  <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
                </span>
              </Tooltip>
            </Typography>
            <Typography variant="body2" mb={2}>
              Changes the used master copy and fallback handler of the Safe.
            </Typography>
            <Controller
              control={control}
              name="safeVersion"
              render={({ field }) => (
                <TextField select {...field} label="Safe version">
                  <MenuItem value="1.4.1">1.4.1 (latest)</MenuItem>
                  <MenuItem value="1.3.0">1.3.0</MenuItem>
                </TextField>
              )}
            />

            <Typography
              variant="h5"
              sx={{
                fontWeight: 700,
                display: 'inline-flex',
                alignItems: 'center',
                gap: 1,
                mt: 4,
                width: 1,
              }}
            >
              Salt nonce
              <Tooltip
                title="The salt nonce changes the predicted Safe address. It can be used to re-create a Safe from another chain or to create a specific Safe address"
                arrow
                placement="top"
              >
                <span style={{ display: 'flex' }}>
                  <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
                </span>
              </Tooltip>
            </Typography>
            <Typography variant="body2" mb={2}>
              Impacts the derived Safe address
            </Typography>
            <NumberField
              {...register(AdvancedOptionsFields.saltNonce, {
                validate: async (value) => {
                  if (isNaN(value)) {
                    return 'Salt nonce must be a number'
                  }
                  if (value < 0) {
                    return 'Salt nonce must be positive'
                  }
                },
                required: true,
              })}
              fullWidth
              label="Salt nonce"
              error={Boolean(formState.errors[AdvancedOptionsFields.saltNonce]) || Boolean(isDeployed)}
              helperText={
                formState.errors[AdvancedOptionsFields.saltNonce]?.message ??
                (Boolean(isDeployed) ? 'The Safe is already deployed. Use a different salt nonce.' : undefined)
              }
            />

            <Typography
              variant="h5"
              sx={{
                fontWeight: 700,
                display: 'inline-flex',
                alignItems: 'center',
                gap: 1,
                mt: 4,
                width: 1,
              }}
            >
              Payment receiver
              <Tooltip title="The payment receiver changes the predicted Safe address." arrow placement="top">
                <span style={{ display: 'flex' }}>
                  <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
                </span>
              </Tooltip>
            </Typography>
            <Typography
              variant="body2"
              sx={{
                mb: 2,
              }}
            >
              Impacts the derived Safe address
            </Typography>
            <TextField
              {...register(AdvancedOptionsFields.paymentReceiver, {
                required: true,
              })}
              label="Payment receiver"
              error={Boolean(formState.errors[AdvancedOptionsFields.paymentReceiver]) || Boolean(isDeployed)}
              helperText={
                formState.errors[AdvancedOptionsFields.paymentReceiver]?.message ??
                (Boolean(isDeployed) ? 'The Safe is already deployed. Use a different payment receiver.' : undefined)
              }
              fullWidth
            />
          </Box>

          <Divider />

          <Box className={layoutCss.row}>
            <Typography
              variant="h4"
              sx={{
                fontWeight: 700,
                mb: 1,
              }}
            >
              New Safe address
            </Typography>
            {predictedSafeAddress ? (
              <EthHashInfo address={predictedSafeAddress} hasExplorer showCopyButton />
            ) : (
              <Skeleton />
            )}
          </Box>

          <Divider />

          <Box className={layoutCss.row}>
            <Box
              sx={{
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                gap: 3,
              }}
            >
              <Button
                data-testid="back-btn"
                variant="outlined"
                size="small"
                onClick={handleBack}
                startIcon={<ArrowBackIcon fontSize="small" />}
              >
                Back
              </Button>
              <Button data-testid="next-btn" type="submit" variant="contained" size="stretched" disabled={isDisabled}>
                Next
              </Button>
            </Box>
          </Box>
        </Stack>
      </FormProvider>
    </form>
  )
}

export default AdvancedOptionsStep
</file>

<file path="src/components/new-safe/create/steps/OwnerPolicyStep/index.tsx">
import useAddressBook from '@/hooks/useAddressBook'
import useWallet from '@/hooks/wallets/useWallet'
import { Button, SvgIcon, MenuItem, Tooltip, Typography, Divider, Box, Grid, TextField } from '@mui/material'
import { Controller, FormProvider, useFieldArray, useForm } from 'react-hook-form'
import type { ReactElement } from 'react'

import AddIcon from '@/public/images/common/add.svg'
import InfoIcon from '@/public/images/notifications/info.svg'
import type { NamedAddress } from '@/components/new-safe/create/types'
import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NewSafeFormData } from '@/components/new-safe/create'
import type { CreateSafeInfoItem } from '@/components/new-safe/create/CreateSafeInfos'
import { useSafeSetupHints } from '@/components/new-safe/create/steps/OwnerPolicyStep/useSafeSetupHints'
import useSyncSafeCreationStep from '@/components/new-safe/create/useSyncSafeCreationStep'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import layoutCss from '@/components/new-safe/create/styles.module.css'
import { CREATE_SAFE_EVENTS, trackEvent } from '@/services/analytics'
import OwnerRow from '@/components/new-safe/OwnerRow'
import { maybePlural } from '@safe-global/utils/utils/formatters'

enum OwnerPolicyStepFields {
  owners = 'owners',
  threshold = 'threshold',
}

export type OwnerPolicyStepForm = {
  [OwnerPolicyStepFields.owners]: NamedAddress[]
  [OwnerPolicyStepFields.threshold]: number
}

const OWNER_POLICY_STEP_FORM_ID = 'create-safe-owner-policy-step-form'

const OwnerPolicyStep = ({
  onSubmit,
  onBack,
  data,
  setStep,
  setDynamicHint,
}: StepRenderProps<NewSafeFormData> & {
  setDynamicHint: (hints: CreateSafeInfoItem | undefined) => void
}): ReactElement => {
  const wallet = useWallet()
  const addressBook = useAddressBook()
  const defaultOwnerAddressBookName = wallet?.address ? addressBook[wallet.address] : undefined
  const defaultOwner: NamedAddress = {
    name: defaultOwnerAddressBookName || wallet?.ens || '',
    address: wallet?.address || '',
  }
  useSyncSafeCreationStep(setStep, data.networks)

  const formMethods = useForm<OwnerPolicyStepForm>({
    mode: 'onChange',
    defaultValues: {
      [OwnerPolicyStepFields.owners]: data.owners.length > 0 ? data.owners : [defaultOwner],
      [OwnerPolicyStepFields.threshold]: data.threshold,
    },
  })

  const { handleSubmit, control, watch, formState, getValues, setValue, trigger } = formMethods

  const threshold = watch(OwnerPolicyStepFields.threshold)

  const {
    fields: ownerFields,
    append: appendOwner,
    remove,
  } = useFieldArray({ control, name: OwnerPolicyStepFields.owners })

  const removeOwner = (index: number): void => {
    // Set threshold if it's greater than the number of owners
    setValue(OwnerPolicyStepFields.threshold, Math.min(threshold, ownerFields.length - 1))
    remove(index)
    trigger(OwnerPolicyStepFields.owners)
  }

  const isDisabled = !formState.isValid

  useSafeSetupHints(setDynamicHint, threshold, ownerFields.length)

  const handleBack = () => {
    const formData = getValues()
    onBack({ ...data, ...formData })
  }

  const onFormSubmit = handleSubmit((data) => {
    onSubmit(data)

    trackEvent({
      ...CREATE_SAFE_EVENTS.OWNERS,
      label: data.owners.length,
    })

    trackEvent({
      ...CREATE_SAFE_EVENTS.THRESHOLD,
      label: data.threshold,
    })
  })

  return (
    <form data-testid="owner-policy-step-form" onSubmit={onFormSubmit} id={OWNER_POLICY_STEP_FORM_ID}>
      <FormProvider {...formMethods}>
        <Box className={layoutCss.row}>
          {ownerFields.map((field, i) => (
            <OwnerRow
              key={field.id}
              index={i}
              removable={i > 0}
              groupName={OwnerPolicyStepFields.owners}
              remove={removeOwner}
            />
          ))}
          <Button
            data-testid="add-owner-btn"
            variant="text"
            onClick={() => appendOwner({ name: '', address: '' }, { shouldFocus: true })}
            startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
            size="large"
          >
            Add new signer
          </Button>
        </Box>

        <Divider />
        <Box className={layoutCss.row}>
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
              display: 'inline-flex',
              alignItems: 'center',
              gap: 1,
            }}
          >
            Threshold
            <Tooltip
              title="The threshold of a Safe Account specifies how many signers need to confirm a Safe Account transaction before it can be executed."
              arrow
              placement="top"
            >
              <span style={{ display: 'flex' }}>
                <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
              </span>
            </Tooltip>
          </Typography>
          <Typography
            variant="body2"
            sx={{
              mb: 2,
            }}
          >
            Any transaction requires the confirmation of:
          </Typography>
          <Grid
            container
            direction="row"
            sx={{
              alignItems: 'center',
              gap: 2,
              pt: 1,
            }}
          >
            <Grid item>
              <Controller
                control={control}
                name="threshold"
                render={({ field }) => (
                  <TextField data-testid="threshold-selector" select {...field}>
                    {ownerFields.map((_, idx) => (
                      <MenuItem data-testid="threshold-item" key={idx + 1} value={idx + 1}>
                        {idx + 1}
                      </MenuItem>
                    ))}
                  </TextField>
                )}
              />
            </Grid>
            <Grid item>
              <Typography>
                out of {ownerFields.length} signer{maybePlural(ownerFields)}
              </Typography>
            </Grid>
          </Grid>
        </Box>
        <Divider />
        <Box className={layoutCss.row}>
          <Box
            sx={{
              display: 'flex',
              flexDirection: 'row',
              justifyContent: 'space-between',
              gap: 3,
            }}
          >
            <Button
              data-testid="back-btn"
              variant="outlined"
              size="small"
              onClick={handleBack}
              startIcon={<ArrowBackIcon fontSize="small" />}
            >
              Back
            </Button>
            <Button data-testid="next-btn" type="submit" variant="contained" size="stretched" disabled={isDisabled}>
              Next
            </Button>
          </Box>
        </Box>
      </FormProvider>
    </form>
  )
}

export default OwnerPolicyStep
</file>

<file path="src/components/new-safe/create/steps/OwnerPolicyStep/useSafeSetupHints.ts">
import { useEffect } from 'react'
import type { CreateSafeInfoItem } from '@/components/new-safe/create/CreateSafeInfos'

export const useSafeSetupHints = (
  setHint: (hint: CreateSafeInfoItem | undefined) => void,
  threshold?: number,
  numberOfOwners?: number,
  multiChain?: boolean,
) => {
  useEffect(() => {
    const safeSetupWarningSteps: { title: string; text: string }[] = []

    // 1/n warning
    if (numberOfOwners && threshold === 1) {
      safeSetupWarningSteps.push({
        title: `1/${numberOfOwners} policy`,
        text: 'Use a threshold higher than one to prevent losing access to your Safe Account in case a signer key is lost or compromised.',
      })
    }

    // n/n warning
    if (threshold === numberOfOwners && numberOfOwners && numberOfOwners > 1) {
      safeSetupWarningSteps.push({
        title: `${numberOfOwners}/${numberOfOwners} policy`,
        text: 'Use a threshold which is lower than the total number of signers of your Safe Account in case a signer loses access to their account and needs to be replaced.',
      })
    }

    // n/n warning
    if (multiChain) {
      safeSetupWarningSteps.push({
        title: `Same address. Many networks.`,
        text: 'You can choose which networks to deploy your account on and will need to deploy them one by one after creation.',
      })
    }

    setHint({ title: 'Safe Account setup', variant: 'info', steps: safeSetupWarningSteps })

    // Clear dynamic hints when the step / hook unmounts
    return () => {
      setHint(undefined)
    }
  }, [threshold, numberOfOwners, setHint, multiChain])
}
</file>

<file path="src/components/new-safe/create/steps/ReviewStep/index.tsx">
import type { NamedAddress } from '@/components/new-safe/create/types'
import EthHashInfo from '@/components/common/EthHashInfo'
import { safeCreationDispatch, SafeCreationEvent } from '@/features/counterfactual/services/safeCreationEvents'
import NetworkLogosList from '@/features/multichain/components/NetworkLogosList'
import { getTotalFeeFormatted } from '@/hooks/useGasPrice'
import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NewSafeFormData } from '@/components/new-safe/create'
import {
  computeNewSafeAddress,
  createNewSafe,
  createNewUndeployedSafeWithoutSalt,
  relaySafeCreation,
} from '@/components/new-safe/create/logic'
import { getAvailableSaltNonce } from '@/components/new-safe/create/logic/utils'
import css from '@/components/new-safe/create/steps/ReviewStep/styles.module.css'
import layoutCss from '@/components/new-safe/create/styles.module.css'
import { useEstimateSafeCreationGas } from '@/components/new-safe/create/useEstimateSafeCreationGas'
import useSyncSafeCreationStep from '@/components/new-safe/create/useSyncSafeCreationStep'
import ReviewRow from '@/components/new-safe/ReviewRow'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { ExecutionMethod, ExecutionMethodSelector } from '@/components/tx/ExecutionMethodSelector'
import PayNowPayLater from '@/features/counterfactual/PayNowPayLater'
import { CF_TX_GROUP_KEY, replayCounterfactualSafeDeployment } from '@/features/counterfactual/utils'
import { useCurrentChain, useHasFeature } from '@/hooks/useChains'
import useGasPrice from '@/hooks/useGasPrice'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import { useLeastRemainingRelays } from '@/hooks/useRemainingRelays'
import useWalletCanPay from '@/hooks/useWalletCanPay'
import useWallet from '@/hooks/wallets/useWallet'
import { CREATE_SAFE_CATEGORY, CREATE_SAFE_EVENTS, OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import { gtmSetChainId, gtmSetSafeAddress } from '@/services/analytics/gtm'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { useAppDispatch, useAppSelector } from '@/store'
import { hasRemainingRelays } from '@/utils/relaying'
import { isWalletRejection } from '@/utils/wallets'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import { Box, Button, CircularProgress, Divider, Grid, Tooltip, Typography } from '@mui/material'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import classnames from 'classnames'
import { useRouter } from 'next/router'
import { useMemo, useState } from 'react'
import ChainIndicator from '@/components/common/ChainIndicator'
import NetworkWarning from '../../NetworkWarning'
import useAllSafes from '@/features/myAccounts/hooks/useAllSafes'
import uniq from 'lodash/uniq'
import { selectRpc } from '@/store/settingsSlice'
import { AppRoutes } from '@/config/routes'
import { type ReplayedSafeProps } from '@safe-global/utils/features/counterfactual/store/types'
import { predictAddressBasedOnReplayData } from '@/features/multichain/utils/utils'
import { createWeb3ReadOnly, getRpcServiceUrl } from '@/hooks/wallets/web3'
import { type DeploySafeProps } from '@safe-global/protocol-kit'
import { updateAddressBook } from '../../logic/address-book'
import chains from '@/config/chains'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'
import { PayMethod } from '@safe-global/utils/features/counterfactual/types'

export const NetworkFee = ({
  totalFee,
  chain,
  isWaived,
  inline = false,
}: {
  totalFee: string
  chain: ChainInfo | undefined
  isWaived: boolean
  inline?: boolean
}) => {
  return (
    <Box className={classnames(css.networkFee, { [css.networkFeeInline]: inline })}>
      <Typography className={classnames({ [css.strikethrough]: isWaived })}>
        <b>
          &asymp; {totalFee} {chain?.nativeCurrency.symbol}
        </b>
      </Typography>
    </Box>
  )
}

export const SafeSetupOverview = ({
  name,
  owners,
  threshold,
  networks,
}: {
  name?: string
  owners: NamedAddress[]
  threshold: number
  networks: ChainInfo[]
}) => {
  return (
    <Grid container spacing={3}>
      <ReviewRow
        name={networks.length > 1 ? 'Networks' : 'Network'}
        value={
          <Tooltip
            title={
              <Box>
                {networks.map((safeItem) => (
                  <Box
                    key={safeItem.chainId}
                    sx={{
                      p: '4px 0px',
                    }}
                  >
                    <ChainIndicator chainId={safeItem.chainId} />
                  </Box>
                ))}
              </Box>
            }
            arrow
          >
            <Box
              data-testid="network-list"
              sx={{
                display: 'inline-block',
              }}
            >
              <NetworkLogosList networks={networks} />
            </Box>
          </Tooltip>
        }
      />
      {name && <ReviewRow name="Name" value={<Typography data-testid="review-step-safe-name">{name}</Typography>} />}
      <ReviewRow
        name="Signers"
        value={
          <Box data-testid="review-step-owner-info" className={css.ownersArray}>
            {owners.map((owner, index) => (
              <EthHashInfo
                address={owner.address}
                name={owner.name || owner.ens}
                shortAddress={false}
                showPrefix={false}
                showName
                hasExplorer
                showCopyButton
                key={index}
              />
            ))}
          </Box>
        }
      />
      <ReviewRow
        name="Threshold"
        value={
          <Typography data-testid="review-step-threshold">
            {threshold} out of {owners.length} {owners.length > 1 ? 'signers' : 'signer'}
          </Typography>
        }
      />
    </Grid>
  )
}

const ReviewStep = ({ data, onSubmit, onBack, setStep }: StepRenderProps<NewSafeFormData>) => {
  const isWrongChain = useIsWrongChain()
  useSyncSafeCreationStep(setStep, data.networks)
  const chain = useCurrentChain()
  const wallet = useWallet()
  const dispatch = useAppDispatch()
  const router = useRouter()
  const [gasPrice] = useGasPrice()
  const customRpc = useAppSelector(selectRpc)
  const [payMethod, setPayMethod] = useState(PayMethod.PayLater)
  const [executionMethod, setExecutionMethod] = useState(ExecutionMethod.RELAY)
  const [isCreating, setIsCreating] = useState<boolean>(false)
  const [submitError, setSubmitError] = useState<string>()
  const isCounterfactualEnabled = useHasFeature(FEATURES.COUNTERFACTUAL)
  const isEIP1559 = chain && hasFeature(chain, FEATURES.EIP1559)

  const ownerAddresses = useMemo(() => data.owners.map((owner) => owner.address), [data.owners])
  const [minRelays] = useLeastRemainingRelays(ownerAddresses)

  const isMultiChainDeployment = data.networks.length > 1

  // Every owner has remaining relays and relay method is selected
  const canRelay = hasRemainingRelays(minRelays)
  const willRelay = canRelay && executionMethod === ExecutionMethod.RELAY

  const newSafeProps = useMemo(
    () =>
      chain
        ? createNewUndeployedSafeWithoutSalt(
            data.safeVersion,
            {
              owners: data.owners.map((owner) => owner.address),
              threshold: data.threshold,
              paymentReceiver: data.paymentReceiver,
            },
            chain,
          )
        : undefined,
    [chain, data.owners, data.safeVersion, data.threshold, data.paymentReceiver],
  )

  const safePropsForGasEstimation = useMemo(() => {
    return newSafeProps
      ? {
          ...newSafeProps,
          saltNonce: Date.now().toString(),
        }
      : undefined
  }, [newSafeProps])

  // We estimate with a random nonce as we'll just slightly overestimates like this
  const { gasLimit } = useEstimateSafeCreationGas(safePropsForGasEstimation, data.safeVersion)

  const maxFeePerGas = gasPrice?.maxFeePerGas
  const maxPriorityFeePerGas = gasPrice?.maxPriorityFeePerGas

  const walletCanPay = useWalletCanPay({ gasLimit, maxFeePerGas })

  const totalFee = getTotalFeeFormatted(maxFeePerGas, gasLimit, chain)

  const allSafes = useAllSafes()
  const knownAddresses = useMemo(() => uniq(allSafes?.map((safe) => safe.address)), [allSafes])

  const customRPCs = useAppSelector(selectRpc)

  const handleBack = () => {
    onBack(data)
  }

  const handleCreateSafeClick = async () => {
    try {
      if (!wallet || !chain || !newSafeProps) return

      setIsCreating(true)

      // Figure out the shared available nonce across chains
      const nextAvailableNonce =
        data.saltNonce !== undefined
          ? data.saltNonce.toString()
          : await getAvailableSaltNonce(customRPCs, { ...newSafeProps, saltNonce: '0' }, data.networks, knownAddresses)

      const replayedSafeWithNonce = { ...newSafeProps, saltNonce: nextAvailableNonce }

      const customRpcUrl = customRpc[chain.chainId]
      const provider = createWeb3ReadOnly(chain, customRpcUrl)
      if (!provider) return

      let safeAddress: string

      // FIXME a new check to indicate ZKsync chain will be added to the config service and available under ChainInfo
      if (chain.chainId === chains['zksync'] || chain.chainId === chains['lens']) {
        safeAddress = await computeNewSafeAddress(
          customRpcUrl || getRpcServiceUrl(chain.rpcUri),
          {
            safeAccountConfig: replayedSafeWithNonce.safeAccountConfig,
            saltNonce: nextAvailableNonce,
          },
          chain,
          replayedSafeWithNonce.safeVersion,
        )
      } else {
        safeAddress = await predictAddressBasedOnReplayData(replayedSafeWithNonce, provider)
      }

      for (const network of data.networks) {
        await createSafe(network, replayedSafeWithNonce, safeAddress)
      }

      // Update addressbook with owners and Safe on all chosen networks
      dispatch(
        updateAddressBook(
          data.networks.map((network) => network.chainId),
          safeAddress,
          data.name,
          data.owners,
          data.threshold,
        ),
      )

      gtmSetChainId(chain.chainId)

      if (isCounterfactualEnabled && payMethod === PayMethod.PayLater) {
        await router?.push({
          pathname: AppRoutes.home,
          query: { safe: `${data.networks[0].shortName}:${safeAddress}` },
        })
        safeCreationDispatch(SafeCreationEvent.AWAITING_EXECUTION, {
          groupKey: CF_TX_GROUP_KEY,
          safeAddress,
          networks: data.networks,
        })
      }
    } catch (err) {
      console.error(err)
      setSubmitError('Error creating the Safe Account. Please try again later.')
    } finally {
      setIsCreating(false)
    }
  }

  const createSafe = async (chain: ChainInfo, props: ReplayedSafeProps, safeAddress: string) => {
    if (!wallet) return

    gtmSetChainId(chain.chainId)

    try {
      if (isCounterfactualEnabled && payMethod === PayMethod.PayLater) {
        gtmSetSafeAddress(safeAddress)

        trackEvent({ ...OVERVIEW_EVENTS.PROCEED_WITH_TX, label: 'counterfactual', category: CREATE_SAFE_CATEGORY })
        replayCounterfactualSafeDeployment(chain.chainId, safeAddress, props, data.name, dispatch, payMethod)
        trackEvent({ ...CREATE_SAFE_EVENTS.CREATED_SAFE, label: 'counterfactual' })
        return
      }

      const options: DeploySafeProps['options'] = isEIP1559
        ? {
            maxFeePerGas: maxFeePerGas?.toString(),
            maxPriorityFeePerGas: maxPriorityFeePerGas?.toString(),
            gasLimit: gasLimit?.toString(),
          }
        : { gasPrice: maxFeePerGas?.toString(), gasLimit: gasLimit?.toString() }

      const onSubmitCallback = async (taskId?: string, txHash?: string) => {
        // Create a counterfactual Safe
        replayCounterfactualSafeDeployment(chain.chainId, safeAddress, props, data.name, dispatch, payMethod)

        if (taskId) {
          safeCreationDispatch(SafeCreationEvent.RELAYING, { groupKey: CF_TX_GROUP_KEY, taskId, safeAddress })
        }

        if (txHash) {
          safeCreationDispatch(SafeCreationEvent.PROCESSING, {
            groupKey: CF_TX_GROUP_KEY,
            txHash,
            safeAddress,
          })
        }

        trackEvent(CREATE_SAFE_EVENTS.SUBMIT_CREATE_SAFE)
        trackEvent({ ...OVERVIEW_EVENTS.PROCEED_WITH_TX, label: 'deployment', category: CREATE_SAFE_CATEGORY })

        onSubmit(data)
      }

      if (willRelay) {
        const taskId = await relaySafeCreation(chain, props)
        onSubmitCallback(taskId)
      } else {
        await createNewSafe(
          wallet.provider,
          props,
          data.safeVersion,
          chain,
          options,
          (txHash) => {
            onSubmitCallback(undefined, txHash)
          },
          true,
        )
      }
    } catch (_err) {
      const error = asError(_err)
      const submitError = isWalletRejection(error)
        ? 'User rejected signing.'
        : 'Error creating the Safe Account. Please try again later.'
      setSubmitError(submitError)

      if (isWalletRejection(error)) {
        trackEvent(CREATE_SAFE_EVENTS.REJECT_CREATE_SAFE)
      }
    }

    setIsCreating(false)
  }

  const showNetworkWarning =
    (isWrongChain && payMethod === PayMethod.PayNow && !willRelay && !isMultiChainDeployment) ||
    (isWrongChain && !isCounterfactualEnabled && !isMultiChainDeployment)

  const isDisabled = showNetworkWarning || isCreating

  return (
    <>
      <Box data-testid="safe-setup-overview" className={layoutCss.row}>
        <SafeSetupOverview name={data.name} owners={data.owners} threshold={data.threshold} networks={data.networks} />
      </Box>
      {isCounterfactualEnabled && (
        <>
          <Divider />
          <Box data-testid="pay-now-later-message-box" className={layoutCss.row}>
            <PayNowPayLater
              totalFee={totalFee}
              isMultiChain={isMultiChainDeployment}
              canRelay={canRelay}
              payMethod={payMethod}
              setPayMethod={setPayMethod}
            />

            {canRelay && payMethod === PayMethod.PayNow && (
              <>
                <Grid
                  container
                  spacing={3}
                  sx={{
                    pt: 2,
                  }}
                >
                  <ReviewRow
                    value={
                      <ExecutionMethodSelector
                        executionMethod={executionMethod}
                        setExecutionMethod={setExecutionMethod}
                        relays={minRelays}
                      />
                    }
                  />
                </Grid>
              </>
            )}

            {showNetworkWarning && (
              <Box sx={{ '&:not(:empty)': { mt: 3 } }}>
                <NetworkWarning action="create a Safe Account" />
              </Box>
            )}

            {payMethod === PayMethod.PayNow && (
              <Grid item>
                <Typography
                  component="div"
                  sx={{
                    mt: 2,
                  }}
                >
                  You will have to confirm a transaction and pay an estimated fee of{' '}
                  <NetworkFee totalFee={totalFee} isWaived={willRelay} chain={chain} inline /> with your connected
                  wallet
                </Typography>
              </Grid>
            )}
          </Box>
        </>
      )}
      {!isCounterfactualEnabled && (
        <>
          <Divider />
          <Box
            className={layoutCss.row}
            sx={{
              display: 'flex',
              flexDirection: 'column',
              gap: 3,
            }}
          >
            {canRelay && (
              <Grid container spacing={3}>
                <ReviewRow
                  name="Execution method"
                  value={
                    <ExecutionMethodSelector
                      executionMethod={executionMethod}
                      setExecutionMethod={setExecutionMethod}
                      relays={minRelays}
                    />
                  }
                />
              </Grid>
            )}

            <Grid data-testid="network-fee-section" container spacing={3}>
              <ReviewRow
                name="Est. network fee"
                value={
                  <>
                    <NetworkFee totalFee={totalFee} isWaived={willRelay} chain={chain} />

                    {!willRelay && (
                      <Typography
                        variant="body2"
                        sx={{
                          color: 'text.secondary',
                          mt: 1,
                        }}
                      >
                        You will have to confirm a transaction with your connected wallet.
                      </Typography>
                    )}
                  </>
                }
              />
            </Grid>

            {showNetworkWarning && <NetworkWarning action="create a Safe Account" />}

            {!walletCanPay && !willRelay && (
              <ErrorMessage>
                Your connected wallet doesn&apos;t have enough funds to execute this transaction
              </ErrorMessage>
            )}
          </Box>
        </>
      )}
      <Divider />
      <Box className={layoutCss.row}>
        {submitError && <ErrorMessage className={css.errorMessage}>{submitError}</ErrorMessage>}
        <Box
          sx={{
            display: 'flex',
            flexDirection: 'row',
            justifyContent: 'space-between',
            gap: 3,
          }}
        >
          <Button
            data-testid="back-btn"
            variant="outlined"
            size="small"
            onClick={handleBack}
            startIcon={<ArrowBackIcon fontSize="small" />}
          >
            Back
          </Button>
          <Button
            data-testid="review-step-next-btn"
            onClick={handleCreateSafeClick}
            variant="contained"
            size="stretched"
            disabled={isDisabled}
          >
            {isCreating ? <CircularProgress size={18} /> : 'Create account'}
          </Button>
        </Box>
      </Box>
    </>
  )
}

export default ReviewStep
</file>

<file path="src/components/new-safe/create/steps/ReviewStep/styles.module.css">
.ownersArray {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  font-size: 14px;
}

.strikethrough {
  text-decoration: line-through;
  color: var(--color-text-secondary);
}

.errorMessage {
  margin-top: 0;
}

.networkFee {
  padding: var(--space-1);
  background-color: var(--color-secondary-background);
  color: var(--color-text-primary);
  width: fit-content;
  border-radius: 6px;
}

.networkFeeInline {
  padding: 2px 4px;
  display: inline-flex;
}
</file>

<file path="src/components/new-safe/create/steps/SetNameStep/index.tsx">
import { InputAdornment, Tooltip, SvgIcon, Typography, Box, Divider, Button, Grid } from '@mui/material'
import { FormProvider, useForm, useWatch } from 'react-hook-form'
import { useMnemonicSafeName } from '@/hooks/useMnemonicName'
import InfoIcon from '@/public/images/notifications/info.svg'
import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NewSafeFormData } from '@/components/new-safe/create'

import layoutCss from '@/components/new-safe/create/styles.module.css'
import NameInput from '@/components/common/NameInput'
import { CREATE_SAFE_EVENTS, trackEvent } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import MUILink from '@mui/material/Link'
import Link from 'next/link'
import { useRouter } from 'next/router'
import NoWalletConnectedWarning from '../../NoWalletConnectedWarning'
import { type SafeVersion } from '@safe-global/safe-core-sdk-types'
import { useCurrentChain } from '@/hooks/useChains'
import { useEffect } from 'react'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useSafeSetupHints } from '../OwnerPolicyStep/useSafeSetupHints'
import type { CreateSafeInfoItem } from '../../CreateSafeInfos'
import NetworkMultiSelector from '@/components/common/NetworkSelector/NetworkMultiSelector'
import { useAppSelector } from '@/store'
import { selectChainById } from '@/store/chainsSlice'
import useWallet from '@/hooks/wallets/useWallet'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

type SetNameStepForm = {
  name: string
  networks: ChainInfo[]
  safeVersion: SafeVersion
}

export enum SetNameStepFields {
  name = 'name',
  networks = 'networks',
  safeVersion = 'safeVersion',
}

const SET_NAME_STEP_FORM_ID = 'create-safe-set-name-step-form'

function SetNameStep({
  data,
  onSubmit,
  setSafeName,
  setOverviewNetworks,
  setDynamicHint,
  isAdvancedFlow = false,
}: StepRenderProps<NewSafeFormData> & {
  setSafeName: (name: string) => void
  setOverviewNetworks: (networks: ChainInfo[]) => void
  setDynamicHint: (hints: CreateSafeInfoItem | undefined) => void
  isAdvancedFlow?: boolean
}) {
  const router = useRouter()
  const currentChain = useCurrentChain()
  const wallet = useWallet()
  const walletChain = useAppSelector((state) => selectChainById(state, wallet?.chainId || ''))

  const initialState = data.networks.length ? data.networks : walletChain ? [walletChain] : []
  const formMethods = useForm<SetNameStepForm>({
    mode: 'all',
    defaultValues: {
      ...data,
      networks: initialState,
    },
  })

  const {
    handleSubmit,
    setValue,
    control,
    formState: { errors, isValid },
  } = formMethods

  const networks: ChainInfo[] = useWatch({ control, name: SetNameStepFields.networks })
  const isMultiChain = networks.length > 1
  const fallbackName = useMnemonicSafeName(isMultiChain)
  useSafeSetupHints(setDynamicHint, undefined, undefined, isMultiChain)

  const onFormSubmit = (data: Pick<NewSafeFormData, 'name' | 'networks'>) => {
    const name = data.name || fallbackName
    setSafeName(name)
    setOverviewNetworks(data.networks)

    onSubmit({ ...data, name })

    if (data.name) {
      trackEvent(CREATE_SAFE_EVENTS.NAME_SAFE)
    }
  }

  const onCancel = () => {
    trackEvent(CREATE_SAFE_EVENTS.CANCEL_CREATE_SAFE_FORM)
    router.push(AppRoutes.welcome.index)
  }

  // whenever the chain switches we need to update the latest Safe version and selected chain
  useEffect(() => {
    setValue(SetNameStepFields.safeVersion, getLatestSafeVersion(currentChain))
  }, [currentChain, setValue])

  const isDisabled = !isValid

  return (
    <FormProvider {...formMethods}>
      <form onSubmit={handleSubmit(onFormSubmit)} id={SET_NAME_STEP_FORM_ID}>
        <Box className={layoutCss.row}>
          <Grid container spacing={1}>
            <Grid item xs={12} md={12}>
              <NameInput
                name={SetNameStepFields.name}
                label={errors?.[SetNameStepFields.name]?.message || 'Name'}
                placeholder={fallbackName}
                InputLabelProps={{ shrink: true }}
                InputProps={{
                  endAdornment: (
                    <Tooltip
                      title="This name is stored locally and will never be shared with us or any third parties."
                      arrow
                      placement="top"
                    >
                      <InputAdornment position="end">
                        <SvgIcon component={InfoIcon} inheritViewBox />
                      </InputAdornment>
                    </Tooltip>
                  ),
                }}
              />
            </Grid>

            <Grid xs={12} item>
              <Typography variant="h5" fontWeight={700} display="inline-flex" alignItems="center" gap={1} mt={2}>
                Select Networks
              </Typography>
              <Typography variant="body2" mb={2}>
                Choose which networks you want your account to be active on. You can add more networks later.{' '}
              </Typography>
              <NetworkMultiSelector isAdvancedFlow={isAdvancedFlow} name={SetNameStepFields.networks} />
            </Grid>
          </Grid>
          <Typography variant="body2" mt={2}>
            By continuing, you agree to our{' '}
            <Link href={AppRoutes.terms} passHref legacyBehavior>
              <MUILink>terms of use</MUILink>
            </Link>{' '}
            and{' '}
            <Link href={AppRoutes.privacy} passHref legacyBehavior>
              <MUILink>privacy policy</MUILink>
            </Link>
            .
          </Typography>

          <NoWalletConnectedWarning />
        </Box>
        <Divider />
        <Box className={layoutCss.row}>
          <Box display="flex" flexDirection="row" justifyContent="space-between" gap={3}>
            <Button data-testid="cancel-btn" variant="outlined" onClick={onCancel} size="small">
              Cancel
            </Button>
            <Button data-testid="next-btn" type="submit" variant="contained" size="stretched" disabled={isDisabled}>
              Next
            </Button>
          </Box>
        </Box>
      </form>
    </FormProvider>
  )
}

export default SetNameStep
</file>

<file path="src/components/new-safe/create/steps/SetNameStep/styles.module.css">
.card {
  border: none;
}

.select {
  display: flex;
  align-items: center;
  border-radius: 8px;
  border: 1px solid var(--color-border-light);
  height: 66px;
}

.select:hover,
.select:hover .networkSelect {
  border-color: var(--color-primary-main);
}

.networkSelect {
  border-left: 1px solid var(--color-border-light);
  padding: var(--space-2);
  margin-left: var(--space-2);
}
</file>

<file path="src/components/new-safe/create/steps/StatusStep/LoadingSpinner/index.tsx">
import { Box } from '@mui/material'
import css from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner/styles.module.css'
import classnames from 'classnames'
import { useCallback, useEffect, useRef } from 'react'

const rectTlEndTransform = 'translateX(0) translateY(20px) scaleY(1.1)'
const rectTrEndTransform = 'translateX(30px) scaleX(2.3)'
const rectBlEndTransform = 'translateX(30px) translateY(60px) scaleX(2.3)'
const rectBrEndTransform = 'translateY(40px) translateX(60px) scaleY(1.1)'

const moveToEnd = (transformEnd: string, element: HTMLDivElement | null) => {
  if (element) {
    element.getAnimations().forEach((animation) => {
      if ((animation as CSSAnimation).animationName) {
        animation.pause()
      }
    })
    const transformStart = window.getComputedStyle(element).transform
    element.getAnimations().forEach((animation) => {
      if ((animation as CSSAnimation).animationName) {
        animation.cancel()
      }
    })
    element.animate([{ transform: transformStart }, { transform: transformEnd }], {
      duration: 1000,
      easing: 'ease-out',
      fill: 'forwards',
    })
  }
}

export enum SpinnerStatus {
  ERROR = 'isError',
  SUCCESS = 'isSuccess',
  PROCESSING = 'isProcessing',
}

const LoadingSpinner = ({ status }: { status: SpinnerStatus }) => {
  // TODO: only monitoring the PendingTxs we can't determine the transaction's result
  const isError = status === SpinnerStatus.ERROR
  const isSuccess = status === SpinnerStatus.SUCCESS

  const rectTl = useRef<HTMLDivElement>(null)
  const rectTr = useRef<HTMLDivElement>(null)
  const rectBl = useRef<HTMLDivElement>(null)
  const rectBr = useRef<HTMLDivElement>(null)
  const rectCenter = useRef<HTMLDivElement>(null)

  const onFinish = useCallback(() => {
    moveToEnd(rectTlEndTransform, rectTl.current)
    moveToEnd(rectTrEndTransform, rectTr.current)
    moveToEnd(rectBlEndTransform, rectBl.current)
    moveToEnd(rectBrEndTransform, rectBr.current)
  }, [rectBl, rectBr, rectTl, rectTr])

  useEffect(() => {
    if (isSuccess) {
      onFinish()
    }
  }, [isSuccess, onFinish])

  return (
    <Box className={classnames(css.box, { [css.rectError]: isError }, { [css.rectSuccess]: isSuccess })}>
      <div className={classnames(css.rect, css.rectTl)} ref={rectTl} />
      <div className={classnames(css.rect, css.rectTr)} ref={rectTr} />
      <div className={classnames(css.rect, css.rectBl)} ref={rectBl} />
      <div className={classnames(css.rect, css.rectBr)} ref={rectBr} />
      <div className={classnames(css.rect, css.rectCenter)} ref={rectCenter} />

      <svg xmlns="http://www.w3.org/2000/svg" version="1.1">
        <defs>
          <filter id="gooey">
            <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
            <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />
            <feComposite in="SourceGraphic" in2="goo" operator="atop" />
          </filter>
        </defs>
      </svg>
    </Box>
  )
}

export default LoadingSpinner
</file>

<file path="src/components/new-safe/create/steps/StatusStep/LoadingSpinner/styles.module.css">
.box {
  width: 80px;
  height: 80px;
  margin: auto;
  position: relative;
  filter: url('#gooey');
}

.rectError .rect {
  background-color: #ff5f72;
  animation-play-state: paused;
}

.rectSuccess .rectCenter,
.rectError .rectCenter {
  visibility: visible;
  transform: translateY(30px) translateX(30px) scale(1);
}

.rect {
  position: absolute;
  left: 0;
  top: 0;
  width: 20px;
  height: 20px;
  background-color: #12ff80;
  transition: background-color 0.1s;
}

.rectTl {
  animation: rect-anim-tl ease-in-out 4s infinite;
  animation-delay: 0.1s;
}

.rectTr {
  animation: rect-anim-tr ease-in-out 4s infinite;
}

.rectBl {
  animation: rect-anim-bl ease-in-out 4s infinite;
}

.rectCenter {
  visibility: hidden;
  animation: none;
  transition: transform 1s ease-out;
  transform: translateY(30px) translateX(30px) scale(0);
}

.rectBr {
  animation: rect-anim-br ease-in-out 4s infinite;
}

@keyframes rect-anim-tl {
  0% {
    transform: translateX(0) translateY(0) scale(2);
  }
  25% {
    transform: translateX(50px) translateY(0) scale(1);
  }
  50% {
    transform: translateX(50px) translateY(50px) scale(2);
  }
  75% {
    transform: translateX(0) translateY(50px) scale(1);
  }
  100% {
    transform: translateX(0) translateY(0) scale(2);
  }
}

@keyframes rect-anim-tr {
  0% {
    transform: translateX(50px) translateY(0) scale(1);
  }
  25% {
    transform: translateX(50px) translateY(50px) scale(2);
  }
  50% {
    transform: translateX(0) translateY(50px) scale(1);
  }
  75% {
    transform: translateX(0) translateY(0) scale(2);
  }
  100% {
    transform: translateX(50px) translateY(0) scale(1);
  }
}

@keyframes rect-anim-br {
  0% {
    transform: translateX(50px) translateY(50px) scale(2);
  }
  25% {
    transform: translateX(0) translateY(50px) scale(1);
  }
  50% {
    transform: translateX(0) translateY(0) scale(2);
  }
  75% {
    transform: translateX(50px) translateY(0) scale(1);
  }
  100% {
    transform: translateX(50px) translateY(50px) scale(2);
  }
}

@keyframes rect-anim-bl {
  0% {
    transform: translateX(0) translateY(50px) scale(1);
  }
  25% {
    transform: translateX(0) translateY(0) scale(2);
  }
  50% {
    transform: translateX(50px) translateY(0) scale(1);
  }
  75% {
    transform: translateX(50px) translateY(50px) scale(2);
  }
  100% {
    transform: translateX(0) translateY(50px) scale(1);
  }
}
</file>

<file path="src/components/new-safe/create/steps/StatusStep/index.tsx">
import { useCounter } from '@/components/common/Notifications/useCounter'
import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NewSafeFormData } from '@/components/new-safe/create'
import { getRedirect } from '@/components/new-safe/create/logic'
import StatusMessage from '@/components/new-safe/create/steps/StatusStep/StatusMessage'
import useUndeployedSafe from '@/components/new-safe/create/steps/StatusStep/useUndeployedSafe'
import lightPalette from '@/components/theme/lightPalette'
import { AppRoutes } from '@/config/routes'
import { safeCreationPendingStatuses } from '@/features/counterfactual/hooks/usePendingSafeStatuses'
import { SafeCreationEvent, safeCreationSubscribe } from '@/features/counterfactual/services/safeCreationEvents'
import { useCurrentChain } from '@/hooks/useChains'
import Rocket from '@/public/images/common/rocket.svg'
import { CREATE_SAFE_EVENTS, trackEvent } from '@/services/analytics'
import { useAppDispatch } from '@/store'
import { Alert, AlertTitle, Box, Button, Paper, Stack, SvgIcon, Typography } from '@mui/material'
import Link from 'next/link'
import { useRouter } from 'next/router'
import { useEffect, useState } from 'react'
import { isPredictedSafeProps } from '@/features/counterfactual/utils'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

const SPEED_UP_THRESHOLD_IN_SECONDS = 15

export const CreateSafeStatus = ({
  data,
  setProgressColor,
  setStep,
  setStepData,
}: StepRenderProps<NewSafeFormData>) => {
  const [status, setStatus] = useState<SafeCreationEvent>(SafeCreationEvent.PROCESSING)
  const [safeAddress, pendingSafe] = useUndeployedSafe()
  const router = useRouter()
  const chain = useCurrentChain()
  const dispatch = useAppDispatch()

  const counter = useCounter(pendingSafe?.status.submittedAt)

  const isError = status === SafeCreationEvent.FAILED || status === SafeCreationEvent.REVERTED

  useEffect(() => {
    const unsubFns = Object.entries(safeCreationPendingStatuses).map(([event]) =>
      safeCreationSubscribe(event as SafeCreationEvent, async () => {
        setStatus(event as SafeCreationEvent)
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [])

  useEffect(() => {
    if (!chain || !safeAddress) return

    if (status === SafeCreationEvent.SUCCESS) {
      const redirect = getRedirect(chain.shortName, safeAddress, router.query?.safeViewRedirectURL)
      if (typeof redirect !== 'string' || redirect.startsWith('/')) {
        router.push(redirect)
      }
    }
  }, [dispatch, chain, data.name, data.owners, data.threshold, router, safeAddress, status])

  useEffect(() => {
    if (!setProgressColor) return

    if (isError) {
      setProgressColor(lightPalette.error.main)
    } else {
      setProgressColor(lightPalette.secondary.main)
    }
  }, [isError, setProgressColor])

  const tryAgain = () => {
    trackEvent(CREATE_SAFE_EVENTS.RETRY_CREATE_SAFE)

    if (!pendingSafe || !isPredictedSafeProps(pendingSafe.props)) {
      setStep(0)
      return
    }

    setProgressColor?.(lightPalette.secondary.main)
    setStep(2)
    setStepData?.({
      owners: pendingSafe.props.safeAccountConfig.owners.map((owner) => ({ name: '', address: owner })),
      name: '',
      networks: [],
      threshold: pendingSafe.props.safeAccountConfig.threshold,
      saltNonce: Number(pendingSafe.props.safeDeploymentConfig?.saltNonce),
      safeAddress,
      safeVersion: pendingSafe.props.safeDeploymentConfig?.safeVersion ?? getLatestSafeVersion(chain),
    })
  }

  const onCancel = () => {
    trackEvent(CREATE_SAFE_EVENTS.CANCEL_CREATE_SAFE)
  }

  return (
    <Paper
      sx={{
        textAlign: 'center',
      }}
    >
      <Box
        sx={{
          p: { xs: 2, sm: 8 },
        }}
      >
        <StatusMessage status={status} isError={isError} pendingSafe={pendingSafe} />

        {counter && counter > SPEED_UP_THRESHOLD_IN_SECONDS && !isError && (
          <Alert severity="warning" icon={<SvgIcon component={Rocket} />} sx={{ mt: 5 }}>
            <AlertTitle>
              <Typography
                variant="body2"
                sx={{
                  textAlign: 'left',
                  fontWeight: 'bold',
                }}
              >
                Transaction is taking too long
              </Typography>
            </AlertTitle>
            <Typography
              variant="body2"
              sx={{
                textAlign: 'left',
              }}
            >
              Try to speed it up with better gas parameters in your wallet.
            </Typography>
          </Alert>
        )}

        {isError && (
          <Stack
            direction="row"
            sx={{
              justifyContent: 'center',
              gap: 2,
            }}
          >
            <Link href={AppRoutes.welcome.index} passHref>
              <Button variant="outlined" onClick={onCancel}>
                Go to homepage
              </Button>
            </Link>
            <Button variant="contained" onClick={tryAgain}>
              Try again
            </Button>
          </Stack>
        )}
      </Box>
    </Paper>
  )
}
</file>

<file path="src/components/new-safe/create/steps/StatusStep/StatusMessage.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import LoadingSpinner, { SpinnerStatus } from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner'
import { SafeCreationEvent } from '@/features/counterfactual/services/safeCreationEvents'
import { useCurrentChain } from '@/hooks/useChains'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import { Box, Typography } from '@mui/material'
import FailedIcon from '@/public/images/common/tx-failed.svg'
import type { UndeployedSafe } from '@safe-global/utils/features/counterfactual/store/types'

const getStep = (status: SafeCreationEvent) => {
  switch (status) {
    case SafeCreationEvent.AWAITING_EXECUTION:
      return {
        description: 'Your account is awaiting activation',
        instruction: 'Activate the account to unlock all features of your smart wallet',
      }
    case SafeCreationEvent.PROCESSING:
    case SafeCreationEvent.RELAYING:
      return {
        description: 'We are activating your account',
        instruction: 'It can take some minutes to create your account, but you can check the progress below.',
      }
    case SafeCreationEvent.FAILED:
      return {
        description: "Your account couldn't be created",
        instruction:
          'The creation transaction was rejected by the connected wallet. You can retry or create an account from scratch.',
      }
    case SafeCreationEvent.REVERTED:
      return {
        description: "Your account couldn't be created",
        instruction: 'The creation transaction reverted. You can retry or create an account from scratch.',
      }
    case SafeCreationEvent.SUCCESS:
      return {
        description: 'Your Safe Account is being indexed..',
        instruction: 'The account will be ready for use shortly. Please do not leave this page.',
      }
    case SafeCreationEvent.INDEXED:
      return {
        description: 'Your Safe Account was successfully created!',
        instruction: '',
      }
  }
}

const StatusMessage = ({
  status,
  isError,
  pendingSafe,
}: {
  status: SafeCreationEvent
  isError: boolean
  pendingSafe: UndeployedSafe | undefined
}) => {
  const stepInfo = getStep(status)
  const chain = useCurrentChain()

  const isSuccess = status === SafeCreationEvent.SUCCESS
  const spinnerStatus = isSuccess ? SpinnerStatus.SUCCESS : SpinnerStatus.PROCESSING
  const explorerLink =
    chain && pendingSafe?.status.txHash ? getBlockExplorerLink(chain, pendingSafe.status.txHash) : undefined

  return (
    <>
      <Box data-testid="safe-status-info" px={3} mt={3}>
        <Box width="160px" height="160px" display="flex" m="auto">
          {isError ? <FailedIcon /> : <LoadingSpinner status={spinnerStatus} />}
        </Box>
        <Typography variant="h3" mt={2} fontWeight={700}>
          {stepInfo.description}
        </Typography>
      </Box>
      <Box sx={{ maxWidth: 390, m: 'auto' }}>
        {stepInfo.instruction && (
          <Typography variant="body2" my={2}>
            {stepInfo.instruction}
          </Typography>
        )}
        {!isError && explorerLink && (
          <ExternalLink href={explorerLink.href}>Check status on block explorer</ExternalLink>
        )}
      </Box>
    </>
  )
}

export default StatusMessage
</file>

<file path="src/components/new-safe/create/steps/StatusStep/StatusStep.tsx">
import type { ReactNode } from 'react'
import { Box, Skeleton, StepLabel, SvgIcon } from '@mui/material'
import css from '@/components/new-safe/create/steps/StatusStep/styles.module.css'
import CircleIcon from '@mui/icons-material/Circle'
import CircleOutlinedIcon from '@mui/icons-material/CircleOutlined'
import Identicon from '@/components/common/Identicon'

const StatusStep = ({
  isLoading,
  safeAddress,
  children,
}: {
  isLoading: boolean
  safeAddress?: string
  children: ReactNode
}) => {
  const Icon = isLoading ? CircleOutlinedIcon : CircleIcon
  const color = isLoading ? 'border' : 'primary'

  return (
    <StepLabel
      className={css.label}
      icon={<SvgIcon component={Icon} className={css.icon} color={color} fontSize="small" />}
    >
      <Box display="flex" alignItems="center" gap={2} color={color}>
        <Box flexShrink={0}>
          {safeAddress && !isLoading ? (
            <Identicon address={safeAddress} size={32} />
          ) : (
            <Skeleton variant="circular" width="2.3em" height="2.3em" />
          )}
        </Box>
        {children}
      </Box>
    </StepLabel>
  )
}

export default StatusStep
</file>

<file path="src/components/new-safe/create/steps/StatusStep/styles.module.css">
.icon {
  width: 12px;
  height: 12px;
}

.connector {
  margin-left: 6px;
  padding: 0;
}

.connector :global .MuiStepConnector-line {
  border-color: var(--color-border-light);
}

.label {
  padding: 0;
  gap: var(--space-2);
}
</file>

<file path="src/components/new-safe/create/steps/StatusStep/useUndeployedSafe.ts">
import { selectUndeployedSafes } from '@/features/counterfactual/store/undeployedSafesSlice'
import useChainId from '@/hooks/useChainId'
import { useAppSelector } from '@/store'
import { PayMethod } from '@safe-global/utils/features/counterfactual/types'

// Returns the undeployed safe for the current network
const useUndeployedSafe = () => {
  const chainId = useChainId()
  const undeployedSafes = useAppSelector(selectUndeployedSafes)
  const undeployedSafe =
    undeployedSafes[chainId] &&
    Object.entries(undeployedSafes[chainId]).find((undeployedSafe) => {
      return undeployedSafe[1].status.type === PayMethod.PayNow
    })

  return undeployedSafe || []
}

export default useUndeployedSafe
</file>

<file path="src/components/new-safe/create/AdvancedCreateSafe.tsx">
import { ECOSYSTEM_ID_ADDRESS } from '@/config/constants'
import { Container, Typography, Grid } from '@mui/material'
import { useRouter } from 'next/router'

import useWallet from '@/hooks/wallets/useWallet'
import OverviewWidget from '@/components/new-safe/create/OverviewWidget'
import type { TxStepperProps } from '@/components/new-safe/CardStepper/useCardStepper'
import SetNameStep from '@/components/new-safe/create/steps/SetNameStep'
import OwnerPolicyStep from '@/components/new-safe/create/steps/OwnerPolicyStep'
import ReviewStep from '@/components/new-safe/create/steps/ReviewStep'
import { CreateSafeStatus } from '@/components/new-safe/create/steps/StatusStep'
import { CardStepper } from '@/components/new-safe/CardStepper'
import { AppRoutes } from '@/config/routes'
import { CREATE_SAFE_CATEGORY } from '@/services/analytics'
import type { CreateSafeInfoItem } from '@/components/new-safe/create/CreateSafeInfos'
import CreateSafeInfos from '@/components/new-safe/create/CreateSafeInfos'
import { useState } from 'react'
import { type NewSafeFormData } from '.'
import AdvancedOptionsStep from './steps/AdvancedOptionsStep'
import { useCurrentChain } from '@/hooks/useChains'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

const AdvancedCreateSafe = () => {
  const router = useRouter()
  const wallet = useWallet()
  const chain = useCurrentChain()

  const [safeName, setSafeName] = useState('')
  const [dynamicHint, setDynamicHint] = useState<CreateSafeInfoItem>()
  const [activeStep, setActiveStep] = useState(0)

  const CreateSafeSteps: TxStepperProps<NewSafeFormData>['steps'] = [
    {
      title: 'Select network and name of your Safe Account',
      subtitle: 'Select the network on which to create your Safe Account',
      render: (data, onSubmit, onBack, setStep) => (
        <SetNameStep
          isAdvancedFlow
          setSafeName={setSafeName}
          data={data}
          onSubmit={onSubmit}
          onBack={onBack}
          setStep={setStep}
          setOverviewNetworks={() => {}}
          setDynamicHint={() => {}}
        />
      ),
    },
    {
      title: 'Signers and confirmations',
      subtitle:
        'Set the signer wallets of your Safe Account and how many need to confirm to execute a valid transaction.',
      render: (data, onSubmit, onBack, setStep) => (
        <OwnerPolicyStep
          setDynamicHint={setDynamicHint}
          data={data}
          onSubmit={onSubmit}
          onBack={onBack}
          setStep={setStep}
        />
      ),
    },
    {
      title: 'Advanced settings',
      subtitle: 'Choose the Safe version and optionally a specific salt nonce',
      render: (data, onSubmit, onBack, setStep) => (
        <AdvancedOptionsStep data={data} onSubmit={onSubmit} onBack={onBack} setStep={setStep} />
      ),
    },
    {
      title: 'Review',
      subtitle:
        "You're about to create a new Safe Account and will have to confirm the transaction with your connected wallet.",
      render: (data, onSubmit, onBack, setStep) => (
        <ReviewStep data={data} onSubmit={onSubmit} onBack={onBack} setStep={setStep} />
      ),
    },
    {
      title: '',
      subtitle: '',
      render: (data, onSubmit, onBack, setStep, setProgressColor, setStepData) => (
        <CreateSafeStatus
          data={data}
          onSubmit={onSubmit}
          onBack={onBack}
          setStep={setStep}
          setProgressColor={setProgressColor}
          setStepData={setStepData}
        />
      ),
    },
  ]

  const initialStep = 0
  const initialData: NewSafeFormData = {
    name: '',
    networks: [],
    owners: [],
    threshold: 1,
    saltNonce: 0,
    safeVersion: getLatestSafeVersion(chain),
    paymentReceiver: ECOSYSTEM_ID_ADDRESS,
  }

  const onClose = () => {
    router.push(AppRoutes.welcome.index)
  }

  return (
    <Container>
      <Grid
        container
        columnSpacing={3}
        sx={{
          justifyContent: 'center',
          mt: [2, null, 7],
        }}
      >
        <Grid item xs={12}>
          <Typography
            variant="h2"
            sx={{
              pb: 2,
            }}
          >
            Create new Safe Account
          </Typography>
        </Grid>
        <Grid
          item
          xs={12}
          md={8}
          sx={{
            order: [1, null, 0],
          }}
        >
          <CardStepper
            initialData={initialData}
            initialStep={initialStep}
            onClose={onClose}
            steps={CreateSafeSteps}
            eventCategory={CREATE_SAFE_CATEGORY}
            setWidgetStep={setActiveStep}
          />
        </Grid>

        <Grid
          item
          xs={12}
          md={4}
          sx={{
            mb: [3, null, 0],
            order: [0, null, 1],
          }}
        >
          <Grid container spacing={3}>
            {activeStep < 2 && <OverviewWidget safeName={safeName} networks={[]} />}
            {wallet?.address && <CreateSafeInfos dynamicHint={dynamicHint} />}
          </Grid>
        </Grid>
      </Grid>
    </Container>
  )
}

export default AdvancedCreateSafe
</file>

<file path="src/components/new-safe/create/index.tsx">
import { Container, Typography, Grid } from '@mui/material'
import { useRouter } from 'next/router'

import useWallet from '@/hooks/wallets/useWallet'
import OverviewWidget from '@/components/new-safe/create/OverviewWidget'
import type { NamedAddress } from '@/components/new-safe/create/types'
import type { TxStepperProps } from '@/components/new-safe/CardStepper/useCardStepper'
import SetNameStep from '@/components/new-safe/create/steps/SetNameStep'
import OwnerPolicyStep from '@/components/new-safe/create/steps/OwnerPolicyStep'
import ReviewStep from '@/components/new-safe/create/steps/ReviewStep'
import { CreateSafeStatus } from '@/components/new-safe/create/steps/StatusStep'
import { CardStepper } from '@/components/new-safe/CardStepper'
import { AppRoutes } from '@/config/routes'
import { CREATE_SAFE_CATEGORY } from '@/services/analytics'
import type { AlertColor } from '@mui/material'
import type { CreateSafeInfoItem } from '@/components/new-safe/create/CreateSafeInfos'
import CreateSafeInfos from '@/components/new-safe/create/CreateSafeInfos'
import { type ReactElement, useMemo, useState } from 'react'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'
import { type SafeVersion } from '@safe-global/safe-core-sdk-types'
import { useCurrentChain } from '@/hooks/useChains'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

export type NewSafeFormData = {
  name: string
  networks: ChainInfo[]
  threshold: number
  owners: NamedAddress[]
  saltNonce?: number
  safeVersion: SafeVersion
  safeAddress?: string
  willRelay?: boolean
  paymentReceiver?: string
}

const staticHints: Record<
  number,
  { title: string; variant: AlertColor; steps: { title: string; text: string | ReactElement }[] }
> = {
  1: {
    title: 'Safe Account creation',
    variant: 'info',
    steps: [
      {
        title: 'Network fee',
        text: 'Deploying your Safe Account requires the payment of the associated network fee with your connected wallet. An estimation will be provided in the last step.',
      },
      {
        title: 'Address book privacy',
        text: 'The name of your Safe Account will be stored in a local address book on your device and can be changed at a later stage. It will not be shared with us or any third party.',
      },
    ],
  },
  2: {
    title: 'Safe Account creation',
    variant: 'info',
    steps: [
      {
        title: 'Flat hierarchy',
        text: 'Every signer has the same rights within the Safe Account and can propose, sign and execute transactions that have the required confirmations.',
      },
      {
        title: 'Managing Signers',
        text: 'You can always change the number of signers and required confirmations in your Safe Account after creation.',
      },
      {
        title: 'Safe Account setup',
        text: (
          <>
            Not sure how many signers and confirmations you need for your Safe Account?
            <br />
            <ExternalLink href={HelpCenterArticle.SAFE_SETUP} fontWeight="bold">
              Learn more about setting up your Safe Account.
            </ExternalLink>
          </>
        ),
      },
    ],
  },
  3: {
    title: 'Safe Account creation',
    variant: 'info',
    steps: [
      {
        title: 'Wait for the creation',
        text: 'Depending on network usage, it can take some time until the transaction is successfully added to the blockchain and picked up by our services.',
      },
    ],
  },
  4: {
    title: 'Safe Account usage',
    variant: 'success',
    steps: [
      {
        title: 'Connect your Safe Account',
        text: 'In our Safe Apps section you can connect your Safe Account to over 70 dApps directly or via Wallet Connect to interact with any application.',
      },
    ],
  },
}

const CreateSafe = () => {
  const router = useRouter()
  const wallet = useWallet()
  const chain = useCurrentChain()

  const [safeName, setSafeName] = useState('')
  const [overviewNetworks, setOverviewNetworks] = useState<ChainInfo[]>()

  const [dynamicHint, setDynamicHint] = useState<CreateSafeInfoItem>()
  const [activeStep, setActiveStep] = useState(0)

  const CreateSafeSteps: TxStepperProps<NewSafeFormData>['steps'] = [
    {
      title: 'Set up the basics',
      subtitle: 'Give a name to your account and select which networks to deploy it on.',
      render: (data, onSubmit, onBack, setStep) => (
        <SetNameStep
          setOverviewNetworks={setOverviewNetworks}
          setDynamicHint={setDynamicHint}
          setSafeName={setSafeName}
          data={data}
          onSubmit={onSubmit}
          onBack={onBack}
          setStep={setStep}
        />
      ),
    },
    {
      title: 'Signers and confirmations',
      subtitle:
        'Set the signer wallets of your Safe Account and how many need to confirm to execute a valid transaction.',
      render: (data, onSubmit, onBack, setStep) => (
        <OwnerPolicyStep
          setDynamicHint={setDynamicHint}
          data={data}
          onSubmit={onSubmit}
          onBack={onBack}
          setStep={setStep}
        />
      ),
    },
    {
      title: 'Review',
      subtitle:
        "You're about to create a new Safe Account and will have to confirm the transaction with your connected wallet.",
      render: (data, onSubmit, onBack, setStep) => (
        <ReviewStep data={data} onSubmit={onSubmit} onBack={onBack} setStep={setStep} />
      ),
    },
    {
      title: '',
      subtitle: '',
      render: (data, onSubmit, onBack, setStep, setProgressColor, setStepData) => (
        <CreateSafeStatus
          data={data}
          onSubmit={onSubmit}
          onBack={onBack}
          setStep={setStep}
          setProgressColor={setProgressColor}
          setStepData={setStepData}
        />
      ),
    },
  ]

  const staticHint = useMemo(() => staticHints[activeStep], [activeStep])

  const initialStep = 0
  const initialData: NewSafeFormData = {
    name: '',
    networks: [],
    owners: [],
    threshold: 1,
    safeVersion: getLatestSafeVersion(chain) as SafeVersion,
  }

  const onClose = () => {
    router.push(AppRoutes.welcome.index)
  }

  return (
    <Container>
      <Grid
        container
        columnSpacing={3}
        sx={{
          justifyContent: 'center',
          mt: [2, null, 7],
        }}
      >
        <Grid item xs={12}>
          <Typography
            variant="h2"
            sx={{
              pb: 2,
            }}
          >
            Create new Safe Account
          </Typography>
        </Grid>
        <Grid
          item
          xs={12}
          md={8}
          sx={{
            order: [1, null, 0],
          }}
        >
          <CardStepper
            initialData={initialData}
            initialStep={initialStep}
            onClose={onClose}
            steps={CreateSafeSteps}
            eventCategory={CREATE_SAFE_CATEGORY}
            setWidgetStep={setActiveStep}
          />
        </Grid>

        <Grid
          item
          xs={12}
          md={4}
          sx={{
            mb: [3, null, 0],
            order: [0, null, 1],
          }}
        >
          <Grid container spacing={3}>
            {activeStep < 2 && <OverviewWidget safeName={safeName} networks={overviewNetworks || []} />}
            {wallet?.address && <CreateSafeInfos staticHint={staticHint} dynamicHint={dynamicHint} />}
          </Grid>
        </Grid>
      </Grid>
    </Container>
  )
}

export default CreateSafe
</file>

<file path="src/components/new-safe/create/styles.module.css">
.row {
  width: 100%;
  padding: var(--space-4) var(--space-7);
}

@media (max-width: 599.95px) {
  .row {
    padding: var(--space-2);
  }
}
</file>

<file path="src/components/new-safe/create/types.d.ts">
import type { NewSafeFormData } from '@/components/new-safe/create'

export type NamedAddress = {
  name: string
  address: string
  ens?: string
}

export type PendingSafeTx = {
  data: string
  from: string
  nonce: number
  to: string
  value: bigint
  startBlock: number
}

export type PendingSafeData = NewSafeFormData & {
  txHash?: string
  tx?: PendingSafeTx
  taskId?: string
}

export type PendingSafeByChain = Record<string, PendingSafeData | undefined>
</file>

<file path="src/components/new-safe/create/useEstimateSafeCreationGas.ts">
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import useWallet from '@/hooks/wallets/useWallet'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { useCurrentChain } from '@/hooks/useChains'
import { estimateSafeCreationGas } from '@/components/new-safe/create/logic'
import { type SafeVersion } from '@safe-global/safe-core-sdk-types'
import { type UndeployedSafeProps } from '@safe-global/utils/features/counterfactual/store/types'

export const useEstimateSafeCreationGas = (
  undeployedSafe: UndeployedSafeProps | undefined,
  safeVersion?: SafeVersion,
): {
  gasLimit?: bigint
  gasLimitError?: Error
  gasLimitLoading: boolean
} => {
  const web3ReadOnly = useWeb3ReadOnly()
  const chain = useCurrentChain()
  const wallet = useWallet()

  const [gasLimit, gasLimitError, gasLimitLoading] = useAsync<bigint>(() => {
    if (!wallet?.address || !chain || !web3ReadOnly || !undeployedSafe) return

    return estimateSafeCreationGas(chain, web3ReadOnly, wallet.address, undeployedSafe, safeVersion)
  }, [wallet?.address, chain, web3ReadOnly, undeployedSafe, safeVersion])

  return { gasLimit, gasLimitError, gasLimitLoading }
}
</file>

<file path="src/components/new-safe/create/useSyncSafeCreationStep.ts">
import { useEffect } from 'react'
import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NewSafeFormData } from '@/components/new-safe/create/index'
import useWallet from '@/hooks/wallets/useWallet'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useCurrentChain } from '@/hooks/useChains'

const useSyncSafeCreationStep = (setStep: StepRenderProps<NewSafeFormData>['setStep'], networks: ChainInfo[]) => {
  const wallet = useWallet()
  const currentChain = useCurrentChain()

  useEffect(() => {
    // Jump to choose name and network step if there is no pending Safe or if the selected network does not match the connected network
    if (!wallet || (networks.length === 1 && currentChain?.chainId !== networks[0].chainId)) {
      setStep(0)
      return
    }
  }, [currentChain?.chainId, networks, setStep, wallet])
}

export default useSyncSafeCreationStep
</file>

<file path="src/components/new-safe/load/steps/SafeOwnerStep/index.tsx">
import React, { useEffect } from 'react'
import { getSafeInfo, type SafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { FormProvider, useFieldArray, useForm } from 'react-hook-form'
import { Box, Button, Divider } from '@mui/material'

import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { LoadSafeFormData } from '@/components/new-safe/load'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import type { NamedAddress } from '@/components/new-safe/create/types'
import layoutCss from '@/components/new-safe/create/styles.module.css'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import { OwnerRow } from '@/components/new-safe/OwnerRow'

enum Field {
  owners = 'owners',
  threshold = 'threshold',
}

type FormData = {
  [Field.owners]: NamedAddress[]
  [Field.threshold]: number
}

const SafeOwnerStep = ({ data, onSubmit, onBack }: StepRenderProps<LoadSafeFormData>) => {
  const chainId = useChainId()
  const formMethods = useForm<FormData>({
    defaultValues: data,
    mode: 'onChange',
  })
  const {
    handleSubmit,
    setValue,
    control,
    formState: { isValid },
    getValues,
  } = formMethods

  const { fields } = useFieldArray({
    control,
    name: Field.owners,
  })

  const [safeInfo] = useAsync<SafeInfo>(() => {
    if (data.address) {
      return getSafeInfo(chainId, data.address)
    }
  }, [chainId, data.address])

  useEffect(() => {
    if (!safeInfo) return

    setValue(Field.threshold, safeInfo.threshold)

    const owners = safeInfo.owners.map((owner, i) => ({
      address: owner.value,
      name: getValues(`owners.${i}.name`) || '',
    }))

    setValue(Field.owners, owners)
  }, [getValues, safeInfo, setValue])

  const handleBack = () => {
    onBack(getValues())
  }

  return (
    <FormProvider {...formMethods}>
      <form onSubmit={handleSubmit(onSubmit)}>
        <Box className={layoutCss.row}>
          {fields.map((field, index) => (
            <OwnerRow key={field.id} index={index} groupName="owners" readOnly />
          ))}
        </Box>
        <Divider />
        <Box className={layoutCss.row}>
          <Box display="flex" flexDirection="row" justifyContent="space-between" gap={3}>
            <Button variant="outlined" size="small" onClick={handleBack} startIcon={<ArrowBackIcon fontSize="small" />}>
              Back
            </Button>
            <Button type="submit" variant="contained" size="stretched" disabled={!isValid}>
              Next
            </Button>
          </Box>
        </Box>
      </form>
    </FormProvider>
  )
}

export default SafeOwnerStep
</file>

<file path="src/components/new-safe/load/steps/SafeReviewStep/index.tsx">
import React from 'react'
import { Box, Button, Divider, Grid, Typography } from '@mui/material'

import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { LoadSafeFormData } from '@/components/new-safe/load'
import layoutCss from '@/components/new-safe/create/styles.module.css'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import ChainIndicator from '@/components/common/ChainIndicator'
import css from '@/components/new-safe/create/steps/ReviewStep/styles.module.css'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useCurrentChain } from '@/hooks/useChains'
import { useAppDispatch } from '@/store'
import { useRouter } from 'next/router'
import { addOrUpdateSafe } from '@/store/addedSafesSlice'
import { defaultSafeInfo } from '@safe-global/store/slices/SafeInfo/utils'
import { LOAD_SAFE_EVENTS, OPEN_SAFE_LABELS, OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import ReviewRow from '@/components/new-safe/ReviewRow'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'
import { maybePlural } from '@safe-global/utils/utils/formatters'

const SafeReviewStep = ({ data, onBack }: StepRenderProps<LoadSafeFormData>) => {
  const chain = useCurrentChain()
  const dispatch = useAppDispatch()
  const router = useRouter()
  const chainId = chain?.chainId || ''

  const addSafe = () => {
    const safeName = data.name
    const safeAddress = data.address

    dispatch(
      addOrUpdateSafe({
        safe: {
          ...defaultSafeInfo,
          address: { value: safeAddress, name: safeName },
          threshold: data.threshold,
          owners: data.owners.map((owner) => ({
            value: owner.address,
            name: owner.name || owner.ens,
          })),
          chainId,
        },
      }),
    )

    dispatch(
      upsertAddressBookEntries({
        chainIds: [chainId],
        address: safeAddress,
        name: safeName,
      }),
    )

    for (const { address, name, ens } of data.owners) {
      const entryName = name || ens

      if (!entryName) {
        continue
      }

      dispatch(
        upsertAddressBookEntries({
          chainIds: [chainId],
          address,
          name: entryName,
        }),
      )
    }

    trackEvent({
      ...LOAD_SAFE_EVENTS.OWNERS,
      label: data.owners.length,
    })

    trackEvent({
      ...LOAD_SAFE_EVENTS.THRESHOLD,
      label: data.threshold,
    })

    trackEvent({ ...OVERVIEW_EVENTS.OPEN_SAFE, label: OPEN_SAFE_LABELS.after_add })

    router.push({
      pathname: AppRoutes.home,
      query: { safe: `${chain?.shortName}:${safeAddress}` },
    })
  }

  const handleBack = () => {
    onBack(data)
  }

  return (
    <>
      <Box className={layoutCss.row}>
        <Grid container spacing={3}>
          <ReviewRow name="Network" value={<ChainIndicator chainId={chain?.chainId} inline />} />
          <ReviewRow name="Name" value={<Typography>{data.name}</Typography>} />
          <ReviewRow
            name="Signers"
            value={
              <Box className={css.ownersArray}>
                {data.owners.map((owner, index) => (
                  <EthHashInfo
                    address={owner.address}
                    name={owner.name || owner.ens}
                    shortAddress={false}
                    showPrefix={false}
                    showName
                    hasExplorer
                    showCopyButton
                    key={index}
                  />
                ))}
              </Box>
            }
          />
          <ReviewRow
            name="Threshold"
            value={
              <Typography>
                {data.threshold} out of {data.owners.length} signer{maybePlural(data.owners)}
              </Typography>
            }
          />
        </Grid>
      </Box>
      <Divider />
      <Box className={layoutCss.row}>
        <Box display="flex" flexDirection="row" justifyContent="space-between" gap={3}>
          <Button variant="outlined" size="small" onClick={handleBack} startIcon={<ArrowBackIcon fontSize="small" />}>
            Back
          </Button>
          <Button onClick={addSafe} variant="contained" size="stretched">
            Add
          </Button>
        </Box>
      </Box>
    </>
  )
}

export default SafeReviewStep
</file>

<file path="src/components/new-safe/load/steps/SetAddressStep/index.tsx">
import type { StepRenderProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { LoadSafeFormData } from '@/components/new-safe/load'
import { FormProvider, useForm } from 'react-hook-form'
import {
  Box,
  Button,
  CircularProgress,
  Divider,
  Grid,
  InputAdornment,
  SvgIcon,
  Tooltip,
  Typography,
} from '@mui/material'
import layoutCss from '@/components/new-safe/create/styles.module.css'
import NameInput from '@/components/common/NameInput'
import InfoIcon from '@/public/images/notifications/info.svg'
import css from '@/components/new-safe/create/steps/SetNameStep/styles.module.css'
import NetworkSelector from '@/components/common/NetworkSelector'
import { useMnemonicSafeName } from '@/hooks/useMnemonicName'
import { useAddressResolver } from '@/hooks/useAddressResolver'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import AddressInput from '@/components/common/AddressInput'
import React from 'react'
import { getSafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import useChainId from '@/hooks/useChainId'
import { useAppSelector } from '@/store'
import { selectAddedSafes } from '@/store/addedSafesSlice'
import { LOAD_SAFE_EVENTS, trackEvent } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import MUILink from '@mui/material/Link'
import Link from 'next/link'

enum Field {
  name = 'name',
  address = 'address',
}

type FormData = {
  [Field.name]: string
  [Field.address]: string
}

const SetAddressStep = ({ data, onSubmit, onBack }: StepRenderProps<LoadSafeFormData>) => {
  const currentChainId = useChainId()
  const addedSafes = useAppSelector((state) => selectAddedSafes(state, currentChainId))
  const formMethods = useForm<FormData>({
    mode: 'all',
    defaultValues: {
      [Field.name]: data.name,
      [Field.address]: data.address,
    },
  })

  const {
    handleSubmit,
    formState: { errors, isValid },
    watch,
    getValues,
  } = formMethods

  const safeAddress = watch(Field.address)
  const randomName = useMnemonicSafeName()
  const { ens, name, resolving } = useAddressResolver(safeAddress)

  // Address book, ENS, mnemonic
  const fallbackName = name || ens || randomName

  const validateSafeAddress = async (address: string) => {
    if (addedSafes && Object.keys(addedSafes).includes(address)) {
      return 'Safe Account is already added'
    }

    try {
      await getSafeInfo(currentChainId, address)
    } catch (error) {
      return 'Address given is not a valid Safe Account address'
    }
  }

  const onFormSubmit = handleSubmit((data: FormData) => {
    onSubmit({
      ...data,
      [Field.name]: data[Field.name] || fallbackName,
    })

    if (data[Field.name]) {
      trackEvent(LOAD_SAFE_EVENTS.NAME_SAFE)
    }
  })

  const handleBack = () => {
    const formData = getValues()
    onBack({
      ...formData,
      [Field.name]: formData.name || fallbackName,
    })
  }

  return (
    <FormProvider {...formMethods}>
      <form onSubmit={onFormSubmit}>
        <Box className={layoutCss.row}>
          <Grid
            container
            spacing={[3, 1]}
            sx={{
              mb: 3,
              pr: '40px',
            }}
          >
            <Grid item xs={12} md>
              <NameInput
                name={Field.name}
                label={errors?.[Field.name]?.message || 'Name'}
                placeholder={fallbackName}
                InputLabelProps={{ shrink: true }}
                InputProps={{
                  endAdornment: resolving ? (
                    <InputAdornment position="end">
                      <CircularProgress size={20} />
                    </InputAdornment>
                  ) : (
                    <Tooltip
                      title="This name is stored locally and will never be shared with us or any third parties."
                      arrow
                      placement="top"
                    >
                      <InputAdornment position="end">
                        <SvgIcon component={InfoIcon} inheritViewBox />
                      </InputAdornment>
                    </Tooltip>
                  ),
                }}
              />
            </Grid>
            <Grid
              item
              sx={{
                order: [-1, 1],
              }}
            >
              <Box className={css.select}>
                <NetworkSelector />
              </Box>
            </Grid>
          </Grid>

          <AddressInput
            data-testid="address-section"
            label="Safe Account"
            validate={validateSafeAddress}
            name={Field.address}
          />

          <Typography
            sx={{
              mt: 4,
            }}
          >
            By continuing you consent to the{' '}
            <Link href={AppRoutes.terms} passHref legacyBehavior>
              <MUILink>terms of use</MUILink>
            </Link>{' '}
            and{' '}
            <Link href={AppRoutes.privacy} passHref legacyBehavior>
              <MUILink>privacy policy</MUILink>
            </Link>
            .
          </Typography>
        </Box>

        <Divider />

        <Box className={layoutCss.row}>
          <Box
            sx={{
              display: 'flex',
              flexDirection: 'row',
              justifyContent: 'space-between',
              gap: 3,
            }}
          >
            <Button variant="outlined" size="small" onClick={handleBack} startIcon={<ArrowBackIcon fontSize="small" />}>
              Back
            </Button>
            <Button
              data-testid="load-safe-next-btn"
              type="submit"
              variant="contained"
              size="stretched"
              disabled={!isValid}
            >
              Next
            </Button>
          </Box>
        </Box>
      </form>
    </FormProvider>
  )
}

export default SetAddressStep
</file>

<file path="src/components/new-safe/load/index.tsx">
import React from 'react'
import { useRouter } from 'next/router'

import { LOAD_SAFE_CATEGORY } from '@/services/analytics'
import { Container, Grid, Typography } from '@mui/material'
import { CardStepper } from '@/components/new-safe/CardStepper'
import type { TxStepperProps } from '@/components/new-safe/CardStepper/useCardStepper'
import type { NamedAddress } from '@/components/new-safe/create/types'
import SetAddressStep from '@/components/new-safe/load/steps/SetAddressStep'
import { AppRoutes } from '@/config/routes'
import SafeOwnerStep from '@/components/new-safe/load/steps/SafeOwnerStep'
import SafeReviewStep from '@/components/new-safe/load/steps/SafeReviewStep'

export type LoadSafeFormData = NamedAddress & {
  threshold: number
  owners: NamedAddress[]
}

export const LoadSafeSteps: TxStepperProps<LoadSafeFormData>['steps'] = [
  {
    title: 'Choose address, network and a name',
    subtitle: 'Paste the address of the Safe Account you want to add, select the network and choose a name.',
    render: (data, onSubmit, onBack, setStep) => (
      <SetAddressStep onSubmit={onSubmit} onBack={onBack} data={data} setStep={setStep} />
    ),
  },
  {
    title: 'Signers and confirmations',
    subtitle: 'Optional: Provide a name for each signer.',
    render: (data, onSubmit, onBack, setStep) => (
      <SafeOwnerStep onSubmit={onSubmit} onBack={onBack} data={data} setStep={setStep} />
    ),
  },
  {
    title: 'Review',
    subtitle: 'Confirm adding Safe Account to your Watchlist',
    render: (data, onSubmit, onBack, setStep) => (
      <SafeReviewStep onSubmit={onSubmit} onBack={onBack} data={data} setStep={setStep} />
    ),
  },
]

export const loadSafeDefaultData = { threshold: -1, owners: [], address: '', name: '' }

const LoadSafe = ({ initialData }: { initialData?: TxStepperProps<LoadSafeFormData>['initialData'] }) => {
  const router = useRouter()

  const onClose = () => {
    router.push(AppRoutes.welcome.index)
  }

  const initialSafe = initialData ?? loadSafeDefaultData

  return (
    <Container data-testid="load-safe-form">
      <Grid
        container
        columnSpacing={3}
        sx={{
          mt: [2, null, 7],
          justifyContent: 'center',
        }}
      >
        <Grid item xs={12} md={10} lg={8}>
          <Typography
            variant="h2"
            sx={{
              pb: 2,
            }}
          >
            Add existing Safe Account
          </Typography>
        </Grid>
        <Grid
          item
          xs={12}
          md={10}
          lg={8}
          sx={{
            order: [1, null, 0],
          }}
        >
          <CardStepper
            // Populate initial data
            key={initialSafe.address}
            initialData={initialSafe}
            onClose={onClose}
            steps={LoadSafeSteps}
            eventCategory={LOAD_SAFE_CATEGORY}
          />
        </Grid>
      </Grid>
    </Container>
  )
}

export default LoadSafe
</file>

<file path="src/components/new-safe/OwnerRow/index.tsx">
import { useCallback, useEffect, useMemo } from 'react'
import { CircularProgress, FormControl, Grid, IconButton, SvgIcon, Typography } from '@mui/material'
import NameInput from '@/components/common/NameInput'
import InputAdornment from '@mui/material/InputAdornment'
import AddressBookInput from '@/components/common/AddressBookInput'
import DeleteIcon from '@/public/images/common/delete.svg'
import { useFormContext, useWatch } from 'react-hook-form'
import { useAddressResolver } from '@/hooks/useAddressResolver'
import EthHashInfo from '@/components/common/EthHashInfo'
import type { NamedAddress } from '@/components/new-safe/create/types'
import useWallet from '@/hooks/wallets/useWallet'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import css from './styles.module.css'
import classNames from 'classnames'

export const OwnerRow = ({
  index,
  groupName,
  removable = true,
  remove,
  readOnly = false,
}: {
  index: number
  removable?: boolean
  groupName: string
  remove?: (index: number) => void
  readOnly?: boolean
}) => {
  const wallet = useWallet()
  const fieldName = `${groupName}.${index}`
  const { control, getValues, setValue } = useFormContext()
  const owners = useWatch({
    control,
    name: groupName,
  })
  const owner = useWatch({
    control,
    name: fieldName,
  })

  const deps = useMemo(() => {
    return Array.from({ length: owners.length }, (_, i) => `${groupName}.${i}`)
  }, [owners, groupName])

  const validateSafeAddress = useCallback(
    async (address: string) => {
      const owners = getValues('owners')
      if (owners.filter((owner: NamedAddress) => sameAddress(owner.address, address)).length > 1) {
        return 'Signer is already added'
      }
    },
    [getValues],
  )

  const { name, ens, resolving } = useAddressResolver(owner.address)

  useEffect(() => {
    if (name && !getValues(`${fieldName}.name`)) {
      setValue(`${fieldName}.name`, name)
    }
  }, [setValue, getValues, name, fieldName])

  useEffect(() => {
    if (ens) {
      setValue(`${fieldName}.ens`, ens)
    }
  }, [ens, setValue, fieldName])

  const walletIsOwner = owner.address === wallet?.address

  return (
    <Grid
      container
      spacing={3}
      className={classNames({ [css.helper]: walletIsOwner })}
      sx={{
        alignItems: 'center',
        marginBottom: 3,
        flexWrap: ['wrap', undefined, 'nowrap'],
      }}
    >
      <Grid item xs={12} md={readOnly ? 5 : 4}>
        <FormControl fullWidth>
          <NameInput
            data-testid="owner-name"
            name={`${fieldName}.name`}
            label="Signer name"
            InputLabelProps={{ shrink: true }}
            placeholder={ens || `Signer ${index + 1}`}
            helperText={walletIsOwner && 'Your connected wallet'}
            InputProps={{
              endAdornment: resolving ? (
                <InputAdornment position="end">
                  <CircularProgress size={20} />
                </InputAdornment>
              ) : null,
            }}
          />
        </FormControl>
      </Grid>
      <Grid item xs={11} md={7}>
        {readOnly ? (
          <Typography variant="body2" component="div">
            <EthHashInfo address={owner.address} shortAddress hasExplorer showCopyButton />
          </Typography>
        ) : (
          <FormControl fullWidth>
            <AddressBookInput name={`${fieldName}.address`} label="Signer" validate={validateSafeAddress} deps={deps} />
          </FormControl>
        )}
      </Grid>
      {!readOnly && (
        <Grid
          item
          xs={1}
          sx={{
            ml: -2,
            alignSelf: 'stretch',
            display: 'flex',
            alignItems: 'center',
            flexShrink: 0,
          }}
        >
          {removable && (
            <>
              <IconButton data-testid="remove-owner-btn" onClick={() => remove?.(index)} aria-label="Remove signer">
                <SvgIcon component={DeleteIcon} inheritViewBox />
              </IconButton>
            </>
          )}
        </Grid>
      )}
    </Grid>
  )
}

export default OwnerRow
</file>

<file path="src/components/new-safe/OwnerRow/styles.module.css">
@media (min-width: 900px) {
  .helper {
    margin-bottom: var(--space-5);
  }
}
</file>

<file path="src/components/new-safe/ReviewRow/index.tsx">
import React, { type ReactElement } from 'react'
import { Grid, Typography } from '@mui/material'

const ReviewRow = ({ name, value }: { name?: string; value: ReactElement }) => {
  return (
    <>
      {name && (
        <Grid item xs={3}>
          <Typography variant="body2">{name}</Typography>
        </Grid>
      )}
      <Grid item xs={name ? 9 : 12}>
        {value}
      </Grid>
    </>
  )
}

export default ReviewRow
</file>

<file path="src/components/nfts/NftCollections/index.tsx">
import { type SyntheticEvent, type ReactElement, useCallback, useEffect, useState, useContext } from 'react'
import { type SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'
import ErrorMessage from '@/components/tx/ErrorMessage'
import PagePlaceholder from '@/components/common/PagePlaceholder'
import NftIcon from '@/public/images/common/nft.svg'
import useCollectibles from '@/hooks/useCollectibles'
import InfiniteScroll from '@/components/common/InfiniteScroll'
import { NFT_EVENTS } from '@/services/analytics/events/nfts'
import { trackEvent } from '@/services/analytics'
import NftGrid from '../NftGrid'
import NftSendForm from '../NftSendForm'
import NftPreviewModal from '../NftPreviewModal'
import { TxModalContext } from '@/components/tx-flow'
import { NftTransferFlow } from '@/components/tx-flow/flows'

const NftCollections = (): ReactElement => {
  // Track the current NFT page url
  const [pageUrl, setPageUrl] = useState<string>()
  // Load NFTs from the backend
  const [nftPage, error, loading] = useCollectibles(pageUrl)
  // Keep all loaded NFTs in one big array
  const [allNfts, setAllNfts] = useState<SafeCollectibleResponse[]>([])
  // Selected NFTs
  const [selectedNfts, setSelectedNfts] = useState<SafeCollectibleResponse[]>([])
  // Preview
  const [previewNft, setPreviewNft] = useState<SafeCollectibleResponse>()
  // Tx modal
  const { setTxFlow } = useContext(TxModalContext)

  // On NFT preview click
  const onPreview = useCallback((token: SafeCollectibleResponse) => {
    setPreviewNft(token)
    trackEvent(NFT_EVENTS.PREVIEW)
  }, [])

  const onSendSubmit = useCallback(
    (e: SyntheticEvent) => {
      e.preventDefault()

      if (selectedNfts.length) {
        // Show the NFT transfer modal
        setTxFlow(<NftTransferFlow tokens={selectedNfts} />)

        // Track how many NFTs are being sent
        trackEvent({ ...NFT_EVENTS.SEND, label: selectedNfts.length })
      }
    },
    [selectedNfts, setTxFlow],
  )

  // Add new NFTs to the accumulated list
  useEffect(() => {
    if (nftPage) {
      setAllNfts((prev) => prev.concat(nftPage.results))
    }
  }, [nftPage])

  // No NFTs to display
  if (nftPage && !nftPage.results.length) {
    return <PagePlaceholder img={<NftIcon />} text="No NFTs available or none detected" />
  }

  return (
    <>
      {error ? (
        /* Loading error */
        <ErrorMessage error={error}>Failed to load NFTs</ErrorMessage>
      ) : (
        /* NFTs */
        <form onSubmit={onSendSubmit}>
          {/* Batch send form */}
          <NftSendForm selectedNfts={selectedNfts} />

          {/* NFTs table */}
          <NftGrid
            nfts={allNfts}
            selectedNfts={selectedNfts}
            setSelectedNfts={setSelectedNfts}
            onPreview={onPreview}
            isLoading={loading || !nftPage || !!nftPage?.next}
          >
            {/* Infinite scroll at the bottom of the table */}
            {nftPage?.next ? <InfiniteScroll onLoadMore={() => setPageUrl(nftPage.next)} /> : null}
          </NftGrid>
        </form>
      )}

      {/* NFT preview */}
      <NftPreviewModal onClose={() => setPreviewNft(undefined)} nft={previewNft} />
    </>
  )
}

export default NftCollections
</file>

<file path="src/components/nfts/NftGrid/index.tsx">
import type { Dispatch, ReactNode, SetStateAction, SyntheticEvent } from 'react'
import { useMemo, useState } from 'react'
import { useCallback } from 'react'
import { type ReactElement } from 'react'
import {
  Box,
  Checkbox,
  InputAdornment,
  Paper,
  Skeleton,
  SvgIcon,
  type SvgIconProps,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TextField,
  Typography,
  Tooltip,
} from '@mui/material'
import FilterAltIcon from '@mui/icons-material/FilterAlt'
import NftIcon from '@/public/images/common/nft.svg'
import type { SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'
import ExternalLink from '@/components/common/ExternalLink'
import useChainId from '@/hooks/useChainId'
import { nftPlatforms } from '../config'
import EthHashInfo from '@/components/common/EthHashInfo'

interface NftsTableProps {
  nfts: SafeCollectibleResponse[]
  selectedNfts: SafeCollectibleResponse[]
  setSelectedNfts: Dispatch<SetStateAction<SafeCollectibleResponse[]>>
  isLoading: boolean
  children?: ReactNode
  onPreview: (item: SafeCollectibleResponse) => void
}

const PAGE_SIZE = 10
const INITIAL_SKELETON_SIZE = 3

const headCells = [
  {
    id: 'collection',
    label: 'Collection',
    width: '35%',
  },
  {
    id: 'id',
    label: 'Token ID',
    width: '35%',
  },
  {
    id: 'links',
    label: 'Links',
    width: '23%',
    xsHidden: true,
  },
  {
    id: 'checkbox',
    label: '',
    width: '7%',
    textAlign: 'right',
  },
]

const stopPropagation = (e: SyntheticEvent) => e.stopPropagation()

const NftIndicator = ({ color }: { color: SvgIconProps['color'] }) => (
  <SvgIcon
    data-testid={`nft-icon-${color}`}
    component={NftIcon}
    inheritViewBox
    width={20}
    height={20}
    color={color}
    sx={{ ml: 0.25 }}
  />
)

const activeNftIcon = <NftIndicator color="primary" />

const inactiveNftIcon = (
  <Tooltip title="There's no preview for this NFT" placement="top" arrow>
    <span>
      <NftIndicator color="border" />
    </span>
  </Tooltip>
)

const NftGrid = ({
  nfts,
  selectedNfts,
  setSelectedNfts,
  isLoading,
  children,
  onPreview,
}: NftsTableProps): ReactElement => {
  const chainId = useChainId()
  const linkTemplates = nftPlatforms[chainId] || []
  // Filter string
  const [filter, setFilter] = useState<string>('')

  const onFilterChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      setFilter(e.target.value.toLowerCase())
    },
    [setFilter],
  )

  const onCheckboxClick = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>, item: SafeCollectibleResponse) => {
      e.stopPropagation()
      const { checked } = e.target
      setSelectedNfts((prev) => (checked ? prev.concat(item) : prev.filter((el) => el !== item)))
    },
    [setSelectedNfts],
  )

  // Filter by collection name or token address
  const filteredNfts = useMemo(() => {
    return filter
      ? nfts.filter((nft) => nft.tokenName.toLowerCase().includes(filter) || nft.address.toLowerCase().includes(filter))
      : nfts
  }, [nfts, filter])

  const onSelectAll = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      setSelectedNfts(e.target.checked ? filteredNfts : [])
    },
    [filteredNfts, setSelectedNfts],
  )

  const minRows = Math.min(nfts.length, PAGE_SIZE)

  return (
    <>
      <TableContainer component={Paper}>
        <Table aria-labelledby="tableTitle">
          <TableHead>
            <TableRow>
              {headCells.map((headCell) => (
                <TableCell
                  key={headCell.id}
                  align="left"
                  padding="normal"
                  sx={{
                    display: headCell.xsHidden ? { xs: 'none', sm: 'table-cell' } : undefined,
                    width: headCell.width,
                    'text-align': headCell.textAlign,
                  }}
                >
                  {headCell.id === 'collection' ? (
                    <Box display="flex" alignItems="center" alignContent="center" gap={1}>
                      <TextField
                        placeholder="Collection"
                        hiddenLabel
                        variant="standard"
                        size="small"
                        margin="none"
                        onChange={onFilterChange}
                        InputProps={{
                          startAdornment: (
                            <InputAdornment position="start">
                              <SvgIcon
                                component={FilterAltIcon}
                                inheritViewBox
                                color="border"
                                sx={{ marginTop: -0.5 }}
                              />
                            </InputAdornment>
                          ),
                          disableUnderline: true,
                        }}
                      />
                    </Box>
                  ) : headCell.id === 'links' ? (
                    linkTemplates ? (
                      <>Links</>
                    ) : null
                  ) : headCell.id === 'checkbox' ? (
                    <Checkbox
                      checked={filteredNfts.length > 0 && filteredNfts.length === selectedNfts.length}
                      onChange={onSelectAll}
                      title="Select all"
                    />
                  ) : (
                    headCell.label
                  )}
                </TableCell>
              ))}
            </TableRow>
          </TableHead>

          <TableBody>
            {filteredNfts.map((item, index) => {
              const onClick = () => onPreview(item)
              const sx = item.imageUri ? { cursor: 'pointer' } : undefined

              return (
                <TableRow data-testid={`nfts-table-row-${index + 1}`} tabIndex={-1} key={`${item.address}-${item.id}`}>
                  {/* Collection name */}
                  <TableCell onClick={onClick} sx={sx}>
                    <Box display="flex" alignItems="center" gap={2}>
                      {item.imageUri ? activeNftIcon : inactiveNftIcon}

                      <div>
                        <Typography>{item.tokenName || item.tokenSymbol}</Typography>

                        <Typography fontSize="small" color="text.secondary" component="div">
                          <EthHashInfo
                            address={item.address}
                            showAvatar={false}
                            showName={false}
                            showCopyButton
                            hasExplorer
                          />
                        </Typography>
                      </div>
                    </Box>
                  </TableCell>

                  {/* Token ID */}
                  <TableCell onClick={onClick} sx={sx}>
                    <Typography sx={item.name ? undefined : { wordBreak: 'break-all' }}>
                      {item.name || `${item.tokenSymbol} #${item.id.slice(0, 20)}`}
                    </Typography>
                  </TableCell>

                  {/* Links */}
                  <TableCell sx={{ display: { xs: 'none', sm: 'table-cell' } }}>
                    <Box display="flex" alignItems="center" alignContent="center" gap={2.5}>
                      {linkTemplates?.map(({ title, logo, getUrl }) => (
                        <ExternalLink href={getUrl(item)} key={title} onClick={stopPropagation} noIcon>
                          <img src={logo} width={24} height={24} alt={title} />
                        </ExternalLink>
                      ))}
                    </Box>
                  </TableCell>

                  {/* Checkbox */}
                  <TableCell align="right">
                    <Checkbox
                      data-testid={`nft-checkbox-${index + 1}`}
                      checked={selectedNfts.includes(item)}
                      onChange={(e) => onCheckboxClick(e, item)}
                    />

                    {/* Insert the children at the end of the table */}
                    {index === filteredNfts.length - 1 && children}
                  </TableCell>
                </TableRow>
              )
            })}

            {/* Fill up the table up to min rows when filtering */}
            {filter &&
              Array.from({ length: minRows - filteredNfts.length }).map((_, index) => (
                <TableRow tabIndex={-1} key={index} sx={{ pointerEvents: 'none' }}>
                  {headCells.map((headCell) => (
                    <TableCell
                      key={headCell.id}
                      sx={headCell.xsHidden ? { display: { xs: 'none', sm: 'table-cell' } } : undefined}
                    >
                      <Box height="42px" width="42px" />
                    </TableCell>
                  ))}
                </TableRow>
              ))}

            {/* Show placeholders when loading */}
            {isLoading &&
              Array.from({ length: nfts.length ? PAGE_SIZE : INITIAL_SKELETON_SIZE }).map((_, index) => (
                <TableRow tabIndex={-1} key={index} sx={{ pointerEvents: 'none' }}>
                  {headCells.map((headCell) => (
                    <TableCell
                      key={headCell.id}
                      sx={headCell.xsHidden ? { display: { xs: 'none', sm: 'table-cell' } } : undefined}
                    >
                      <Skeleton variant="rounded" height="30px" sx={{ my: '6px' }} width="100%" />
                    </TableCell>
                  ))}
                </TableRow>
              ))}
          </TableBody>
        </Table>
      </TableContainer>
    </>
  )
}

export default NftGrid
</file>

<file path="src/components/nfts/NftPreviewModal/index.tsx">
import type { SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'
import ModalDialog from '@/components/common/ModalDialog'
import css from './styles.module.css'
import ExternalLink from '@/components/common/ExternalLink'
import { nftPlatforms } from '../config'
import useChainId from '@/hooks/useChainId'
import { CircularProgress } from '@mui/material'

const NftPreviewModal = ({ nft, onClose }: { nft?: SafeCollectibleResponse; onClose: () => void }) => {
  const chainId = useChainId()
  const linkTemplate = nftPlatforms[chainId]?.[0]
  const title = nft ? nft.name || `${nft.tokenSymbol} #${nft.id.slice(0, 20)}` : ''

  return (
    <ModalDialog
      open={!!nft?.imageUri}
      onClose={onClose}
      dialogTitle={title}
      fullScreen
      sx={{ margin: [0, 2], '.MuiPaper-root': { borderRadius: [0, '6px'] } }}
    >
      {nft && (
        <div className={css.wrapper}>
          <div className={css.imageWrapper} onClick={onClose}>
            <img src={nft.imageUri} alt={nft.name} />

            <CircularProgress className={css.loader} />
          </div>

          {linkTemplate && <ExternalLink href={linkTemplate.getUrl(nft)}>View on {linkTemplate.title}</ExternalLink>}
        </div>
      )}
    </ModalDialog>
  )
}

export default NftPreviewModal
</file>

<file path="src/components/nfts/NftPreviewModal/styles.module.css">
.wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  overflow: auto;
  padding: var(--space-3);
}

.imageWrapper {
  flex: 1;
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  overflow: auto;
  position: relative;
}

.imageWrapper img {
  display: block;
  object-fit: cover;
  max-height: 100%;
  max-width: 100%;
  border-radius: 16px;
  position: relative;
  z-index: 2;
}

.imageWrapper img[src$='/ENS.png'] {
  height: 100px;
  width: 100px;
  background-color: var(--color-background-paper);
}

.loader {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1;
}

.wrapper a:last-child {
  margin-top: var(--space-3);
  line-height: 2;
}
</file>

<file path="src/components/nfts/NftSendForm/index.tsx">
import type { ReactElement } from 'react'
import { Box, Button, Grid, SvgIcon, Typography } from '@mui/material'
import ArrowIcon from '@/public/images/common/arrow-nw.svg'
import type { SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { Sticky } from '@/components/common/Sticky'
import CheckWallet from '@/components/common/CheckWallet'
import { maybePlural } from '@safe-global/utils/utils/formatters'

type NftSendFormProps = {
  selectedNfts: SafeCollectibleResponse[]
}

const NftSendForm = ({ selectedNfts }: NftSendFormProps): ReactElement => {
  const nftsText = `NFT${maybePlural(selectedNfts)}`
  const noSelected = selectedNfts.length === 0

  return (
    <Sticky>
      <Grid
        container
        spacing={1}
        sx={{
          justifyContent: 'flex-end',
          alignItems: 'center',
        }}
      >
        <Grid
          item
          sx={{
            display: ['none', 'block'],
            flex: '1',
          }}
        >
          <Box
            sx={{
              bgcolor: 'secondary.background',
              py: 0.75,
              px: 2,
              flex: 1,
              borderRadius: 1,
              mr: 1,
            }}
          >
            <Box
              sx={{
                display: 'flex',
                alignItems: 'center',
                gap: 1.5,
              }}
            >
              <SvgIcon component={ArrowIcon} inheritViewBox color="border" sx={{ width: 12, height: 12 }} />

              <Typography
                variant="body2"
                sx={{
                  lineHeight: 'inherit',
                }}
              >
                {`${selectedNfts.length} ${nftsText} selected`}
              </Typography>
            </Box>
          </Box>
        </Grid>

        <Grid item>
          <CheckWallet>
            {(isOk) => (
              <Button
                data-testid={`nft-send-btn-${!isOk || noSelected}`}
                type="submit"
                variant="contained"
                size="small"
                disabled={!isOk || noSelected}
                sx={{
                  minWidth: '10em',
                }}
              >
                {noSelected ? 'Send' : `Send ${selectedNfts.length} ${nftsText}`}
              </Button>
            )}
          </CheckWallet>
        </Grid>
      </Grid>
    </Sticky>
  )
}

export default NftSendForm
</file>

<file path="src/components/nfts/config.ts">
import chains from '@/config/chains'
import type { SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'

type NftPlatform = {
  title: string
  logo: string
  getUrl: (nft: SafeCollectibleResponse) => string
}

export const nftPlatforms: Record<keyof typeof chains, Array<NftPlatform>> = {
  [chains.eth]: [
    {
      title: 'Etherscan',
      logo: '/images/common/nft-etherscan.svg',
      getUrl: (item) => `https://etherscan.io/nft/${item.address}/${item.id}`,
    },
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://opensea.io/assets/ethereum/${item.address}/${item.id}`,
    },
    {
      title: 'Blur',
      logo: '/images/common/nft-blur.svg',
      getUrl: (item) => `https://blur.io/asset/${item.address.toLowerCase()}/${item.id}`,
    },
    {
      title: 'Zerion',
      logo: '/images/common/nft-zerion.svg',
      getUrl: (item) => `https://app.zerion.io/nfts/ethereum/${item.address.toLowerCase()}:${item.id}`,
    },
  ],

  [chains.matic]: [
    {
      title: 'PolygonScan',
      logo: '/images/common/nft-polygonscan.svg',
      getUrl: (item) => `https://polygonscan.com/token/${item.address}?a=${item.id}`,
    },
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://opensea.io/assets/matic/${item.address}/${item.id}`,
    },
    {
      title: 'Zerion',
      logo: '/images/common/nft-zerion.svg',
      getUrl: (item) => `https://app.zerion.io/nfts/polygon/${item.address.toLowerCase()}:${item.id}`,
    },
  ],

  [chains.gno]: [
    {
      title: 'GnosisScan',
      logo: '/images/common/nft-gnosisscan.svg',
      getUrl: (item) => `https://gnosisscan.io/nft/${item.address}/${item.id}`,
    },
    {
      title: 'Zerion',
      logo: '/images/common/nft-zerion.svg',
      getUrl: (item) => `https://app.zerion.io/nfts/xdai/${item.address.toLowerCase()}:${item.id}`,
    },
  ],

  [chains.gor]: [
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://testnets.opensea.io/assets/goerli/${item.address}/${item.id}`,
    },
  ],

  [chains.sep]: [
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://testnets.opensea.io/assets/sepolia/${item.address}/${item.id}`,
    },
  ],

  [chains.oeth]: [
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://opensea.io/assets/optimism/${item.address}/${item.id}`,
    },
    {
      title: 'Zerion',
      logo: '/images/common/nft-zerion.svg',
      getUrl: (item) => `https://app.zerion.io/nfts/optimism/${item.address.toLowerCase()}:${item.id}`,
    },
  ],

  [chains.arb1]: [
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://opensea.io/assets/arbitrum/${item.address}/${item.id}`,
    },
    {
      title: 'Zerion',
      logo: '/images/common/nft-zerion.svg',
      getUrl: (item) => `https://app.zerion.io/nfts/arbitrum/${item.address.toLowerCase()}:${item.id}`,
    },
  ],

  [chains.avax]: [
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://opensea.io/assets/avalanche/${item.address}/${item.id}`,
    },
  ],

  [chains.bnb]: [
    {
      title: 'OpenSea',
      logo: '/images/common/nft-opensea.svg',
      getUrl: (item) => `https://opensea.io/assets/bsc/${item.address}/${item.id}`,
    },
  ],
}
</file>

<file path="src/components/notification-center/NotificationCenter/index.tsx">
import { useState, useMemo, type ReactElement, type MouseEvent } from 'react'
import ButtonBase from '@mui/material/ButtonBase'
import Popover from '@mui/material/Popover'
import Paper from '@mui/material/Paper'
import Typography from '@mui/material/Typography'
import IconButton from '@mui/material/IconButton'
import MuiLink from '@mui/material/Link'
import BellIcon from '@/public/images/common/notifications.svg'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import ExpandLessIcon from '@mui/icons-material/ExpandLess'
import { useAppDispatch, useAppSelector } from '@/store'
import {
  selectNotifications,
  readNotification,
  closeNotification,
  deleteAllNotifications,
} from '@/store/notificationsSlice'
import NotificationCenterList from '@/components/notification-center/NotificationCenterList'
import UnreadBadge from '@/components/common/UnreadBadge'
import Link from 'next/link'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import SettingsIcon from '@/public/images/sidebar/settings.svg'

import css from './styles.module.css'
import { trackEvent, OVERVIEW_EVENTS } from '@/services/analytics'
import SvgIcon from '@mui/icons-material/ExpandLess'
import { useHasFeature } from '@/hooks/useChains'
import { useShowNotificationsRenewalMessage } from '@/components/settings/PushNotifications/hooks/useShowNotificationsRenewalMessage'
import { FEATURES } from '@safe-global/utils/utils/chains'

const NOTIFICATION_CENTER_LIMIT = 4

const NotificationCenter = (): ReactElement => {
  const router = useRouter()
  const [showAll, setShowAll] = useState<boolean>(false)
  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null)
  const open = Boolean(anchorEl)
  const hasPushNotifications = useHasFeature(FEATURES.PUSH_NOTIFICATIONS)
  const dispatch = useAppDispatch()

  // This hook is used to show the notification renewal message when the app is opened
  useShowNotificationsRenewalMessage()

  const notifications = useAppSelector(selectNotifications)
  const chronologicalNotifications = useMemo(() => {
    // Clone as Redux returns read-only array
    return notifications.slice().sort((a, b) => b.timestamp - a.timestamp)
  }, [notifications])

  const canExpand = notifications.length > NOTIFICATION_CENTER_LIMIT + 1

  const notificationsToShow =
    showAll || !canExpand ? chronologicalNotifications : chronologicalNotifications.slice(0, NOTIFICATION_CENTER_LIMIT)

  const unreadCount = useMemo(() => notifications.filter(({ isRead }) => !isRead).length, [notifications])
  const hasUnread = unreadCount > 0

  const handleRead = () => {
    notificationsToShow.forEach(({ isRead, id }) => {
      if (!isRead) {
        dispatch(readNotification({ id }))
      }
    })
    setShowAll(false)
  }

  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    if (!open) {
      trackEvent(OVERVIEW_EVENTS.NOTIFICATION_CENTER)

      notifications.forEach(({ isDismissed, id }) => {
        if (!isDismissed) {
          dispatch(closeNotification({ id }))
        }
      })
    } else {
      handleRead()
    }
    setAnchorEl(event.currentTarget)
  }

  const handleClose = () => {
    if (open) {
      handleRead()
      setShowAll(false)
    }
    setAnchorEl(null)
  }

  const handleClear = () => {
    dispatch(deleteAllNotifications())
  }

  const onSettingsClick = () => {
    setTimeout(handleClose, 300)
  }

  const ExpandIcon = showAll ? ExpandLessIcon : ExpandMoreIcon

  return (
    <>
      <ButtonBase className={css.bell} onClick={handleClick}>
        <UnreadBadge
          invisible={!hasUnread}
          count={unreadCount}
          anchorOrigin={{
            vertical: 'bottom',
            horizontal: 'right',
          }}
        >
          <SvgIcon component={BellIcon} inheritViewBox fontSize="medium" />
        </UnreadBadge>
      </ButtonBase>

      <Popover
        // Clicking the "view transaction" link doesn't remove the popover even though
        // handleClose is called which results in the UI not being clickable anymore
        // so by adding a key we force a re-render
        key={Number(open)}
        open={open}
        anchorEl={anchorEl}
        onClose={handleClose}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'left',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
        sx={{
          '& > .MuiPaper-root': {
            top: 'var(--header-height) !important',
          },
        }}
        transitionDuration={0}
      >
        <Paper className={css.popoverContainer}>
          <div className={css.popoverHeader}>
            <div>
              <Typography data-testid="notifications-title" variant="h4" component="span" fontWeight={700}>
                Notifications
              </Typography>
              {hasUnread && (
                <Typography variant="caption" className={css.unreadCount}>
                  {unreadCount}
                </Typography>
              )}
            </div>
            {notifications.length > 0 && (
              <MuiLink onClick={handleClear} variant="body2" component="button" sx={{ textDecoration: 'unset' }}>
                Clear all
              </MuiLink>
            )}
          </div>

          <div>
            <NotificationCenterList notifications={notificationsToShow} handleClose={handleClose} />
          </div>

          <div className={css.popoverFooter}>
            {canExpand && (
              <>
                <IconButton onClick={() => setShowAll((prev) => !prev)} disableRipple className={css.expandButton}>
                  <UnreadBadge
                    invisible={showAll || unreadCount <= NOTIFICATION_CENTER_LIMIT}
                    anchorOrigin={{
                      vertical: 'top',
                      horizontal: 'left',
                    }}
                  >
                    <ExpandIcon color="border" />
                  </UnreadBadge>
                </IconButton>
                <Typography sx={{ color: ({ palette }) => palette.border.main }}>
                  {showAll ? 'Hide' : `${notifications.length - NOTIFICATION_CENTER_LIMIT} other notifications`}
                </Typography>
              </>
            )}

            {hasPushNotifications && (
              <Link
                href={{
                  pathname: AppRoutes.settings.notifications,
                  query: router.query,
                }}
                passHref
                legacyBehavior
              >
                <MuiLink
                  data-testid="notifications-button"
                  className={css.settingsLink}
                  variant="body2"
                  onClick={onSettingsClick}
                >
                  <SvgIcon component={SettingsIcon} inheritViewBox fontSize="small" /> Push notifications settings
                </MuiLink>
              </Link>
            )}
          </div>
        </Paper>
      </Popover>
    </>
  )
}

export default NotificationCenter
</file>

<file path="src/components/notification-center/NotificationCenter/styles.module.css">
.bell {
  display: flex;
  justify-content: center;
  padding: var(--space-2) var(--space-2);
}

.bell svg path {
  stroke: var(--color-text-primary);
}

.popoverContainer {
  width: 446px;
  border: 1px solid var(--color-border-light);
}

@media (max-width: 599.95px) {
  .popoverContainer {
    width: calc(100vw - 30px);
  }
}

.popoverHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-3);
  border-bottom: 2px solid var(--color-background-main);
}

.popoverFooter {
  padding: var(--space-2) var(--space-3);
  display: flex;
  align-items: center;
}

.expandButton {
  box-sizing: border-box;
  background-color: var(--color-border-light);
  width: 20px;
  height: 20px;
  margin-left: 10px;
  margin-right: 18px;
  padding: 0;
}

.expandButton > * {
  color: var(--color-border-main);
}

.unreadCount {
  display: inline-block;
  background: var(--color-secondary-light);
  border-radius: 6px;
  margin-left: 9px;
  color: var(--color-static-main);
  text-align: center;
  width: 18px;
  height: 18px;
}

.settingsLink {
  margin-left: auto;
  display: flex;
  align-items: center;
  text-decoration: unset;
  gap: var(--space-1);
}
</file>

<file path="src/components/notification-center/NotificationCenterItem/index.tsx">
import ListItem from '@mui/material/ListItem'
import ListItemAvatar from '@mui/material/ListItemAvatar'
import ListItemText from '@mui/material/ListItemText'
import InfoIcon from '@/public/images/notifications/info.svg'
import WarningIcon from '@/public/images/notifications/warning.svg'
import ErrorIcon from '@/public/images/notifications/error.svg'
import SuccessIcon from '@/public/images/notifications/success.svg'
import { NotificationLink } from '@/components/common/Notifications'
import type { AlertColor } from '@mui/material/Alert'
import type { ReactElement } from 'react'

import type { Notification } from '@/store/notificationsSlice'
import UnreadBadge from '@/components/common/UnreadBadge'
import { formatTimeInWords } from '@safe-global/utils/utils/date'

import css from './styles.module.css'
import classnames from 'classnames'
import SvgIcon from '@mui/material/SvgIcon'
import { Typography } from '@mui/material'

const VARIANT_ICONS = {
  error: ErrorIcon,
  info: InfoIcon,
  success: SuccessIcon,
  warning: WarningIcon,
}

const getNotificationIcon = (variant: AlertColor): ReactElement => {
  return <SvgIcon component={VARIANT_ICONS[variant]} inheritViewBox color={variant} />
}

const NotificationCenterItem = ({
  isRead,
  variant,
  message,
  timestamp,
  link,
  handleClose,
  title,
}: Notification & { handleClose: () => void }): ReactElement => {
  const requiresAction = !isRead && !!link

  const secondaryText = (
    <span className={css.secondaryText}>
      <span>{formatTimeInWords(timestamp)}</span>
      <NotificationLink link={link} onClick={handleClose} />
    </span>
  )

  const primaryText = (
    <>
      {title && (
        <Typography
          sx={{
            fontWeight: '700',
          }}
        >
          {title}
        </Typography>
      )}
      <Typography>{message}</Typography>
    </>
  )

  return (
    <ListItem className={classnames(css.item, { [css.requiresAction]: requiresAction })}>
      <ListItemAvatar className={css.avatar}>
        <UnreadBadge
          invisible={isRead}
          anchorOrigin={{
            vertical: 'top',
            horizontal: 'left',
          }}
        >
          {getNotificationIcon(variant)}
        </UnreadBadge>
      </ListItemAvatar>
      <ListItemText primary={primaryText} secondary={secondaryText} />
    </ListItem>
  )
}

export default NotificationCenterItem
</file>

<file path="src/components/notification-center/NotificationCenterItem/styles.module.css">
.item {
  position: relative;
  padding: 8px 24px;
}

.item:not(:last-of-type):after {
  content: '';
  background: var(--color-border-background);
  position: absolute;
  bottom: 0;
  left: 24px;
  height: 2px;
  width: calc(100% - 48px);
}

.requiresAction {
  background-color: var(--color-primary-background);
}

.avatar {
  min-width: 42px;
}

.secondaryText {
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--color-border-main);
}
</file>

<file path="src/components/notification-center/NotificationCenterList/index.tsx">
import type { ReactElement } from 'react'
import Typography from '@mui/material/Typography'
import List from '@mui/material/List'
import Box from '@mui/material/Box'

import type { NotificationState } from '@/store/notificationsSlice'
import NotificationCenterItem from '@/components/notification-center/NotificationCenterItem'
import NoNotificationsIcon from '@/public/images/notifications/no-notifications.svg'

import css from './styles.module.css'

type NotificationCenterListProps = {
  notifications: NotificationState
  handleClose: () => void
}

const NotificationCenterList = ({ notifications, handleClose }: NotificationCenterListProps): ReactElement => {
  if (!notifications.length) {
    return (
      <div className={css.wrapper}>
        <NoNotificationsIcon data-testid="notifications-icon" alt="No notifications" />
        <Typography
          sx={{
            paddingTop: '8px',
          }}
        >
          No notifications
        </Typography>
      </div>
    )
  }

  return (
    <Box className={css.scrollContainer}>
      <List sx={{ p: 0 }}>
        {notifications.map((notification) => (
          <NotificationCenterItem key={notification.id} {...notification} handleClose={handleClose} />
        ))}
      </List>
    </Box>
  )
}

export default NotificationCenterList
</file>

<file path="src/components/notification-center/NotificationCenterList/styles.module.css">
.wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 156px;
  color: var(--color-border-main);
}

.scrollContainer {
  overflow-x: hidden;
  overflow-y: auto;
  max-height: 500px;
}
</file>

<file path="src/components/notification-center/NotificationRenewal/index.tsx">
import { useState, type ReactElement } from 'react'
import { Alert, Box, Button, Typography } from '@mui/material'
import useSafeInfo from '@/hooks/useSafeInfo'
import CheckWalletWithPermission from '@/components/common/CheckWalletWithPermission'
import { useNotificationsRenewal } from '@/components/settings/PushNotifications/hooks/useNotificationsRenewal'
import { useIsNotificationsRenewalEnabled } from '@/components/settings/PushNotifications/hooks/useNotificationsTokenVersion'
import { RENEWAL_MESSAGE } from '@/components/settings/PushNotifications/constants'
import { Permission } from '@/permissions/config'

const NotificationRenewal = (): ReactElement => {
  const { safe } = useSafeInfo()
  const [isRegistering, setIsRegistering] = useState(false)
  const { renewNotifications, needsRenewal } = useNotificationsRenewal()
  const isNotificationsRenewalEnabled = useIsNotificationsRenewalEnabled()

  if (!needsRenewal || !isNotificationsRenewalEnabled) {
    // No need to renew any Safe's notifications
    return <></>
  }

  const handeSignClick = async () => {
    setIsRegistering(true)
    await renewNotifications()
    setIsRegistering(false)
  }

  return (
    <>
      <Alert severity="warning">
        <Typography variant="body2" fontWeight={700} mb={1}>
          Signature needed
        </Typography>
        <Typography variant="body2">{RENEWAL_MESSAGE}</Typography>
      </Alert>
      <Box>
        <CheckWalletWithPermission
          permission={Permission.EnablePushNotifications}
          checkNetwork={!isRegistering && safe.deployed}
        >
          {(isOk) => (
            <Button
              variant="contained"
              size="small"
              sx={{ width: '200px' }}
              onClick={handeSignClick}
              disabled={!isOk || isRegistering || !safe.deployed}
            >
              Sign now
            </Button>
          )}
        </CheckWalletWithPermission>
      </Box>
    </>
  )
}

export default NotificationRenewal
</file>

<file path="src/components/safe-apps/AddCustomAppModal/CustomApp.tsx">
import { useCallback } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { Typography, SvgIcon } from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'

import { SAFE_APPS_EVENTS, trackSafeAppEvent } from '@/services/analytics'
import CopyButton from '@/components/common/CopyButton'
import ShareIcon from '@/public/images/common/share.svg'
import css from './styles.module.css'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'

type CustomAppProps = {
  safeApp: SafeAppData
  shareUrl: string
}

const CustomApp = ({ safeApp, shareUrl }: CustomAppProps) => {
  const handleCopy = useCallback(() => {
    trackSafeAppEvent(SAFE_APPS_EVENTS.COPY_SHARE_URL, safeApp.name)
  }, [safeApp])

  return (
    <div className={css.customAppContainer}>
      <SafeAppIconCard src={safeApp.iconUrl} alt={safeApp.name} width={48} height={48} />

      <Typography component="h2" mt={2} color="text.primary" fontWeight={700}>
        {safeApp.name}
      </Typography>

      <Typography variant="body2" mt={1} color="text.secondary">
        {safeApp.description}
      </Typography>

      {shareUrl ? (
        <CopyButton
          className={css.customAppCheckIcon}
          text={shareUrl}
          initialToolTipText={`Copy share URL for ${safeApp.name}`}
          onCopy={handleCopy}
        >
          <SvgIcon component={ShareIcon} inheritViewBox color="border" fontSize="small" />
        </CopyButton>
      ) : (
        <CheckIcon color="success" className={css.customAppCheckIcon} />
      )}
    </div>
  )
}

export default CustomApp
</file>

<file path="src/components/safe-apps/AddCustomAppModal/CustomAppPlaceholder.tsx">
import { SvgIcon, Typography } from '@mui/material'
import classNames from 'classnames'

import SafeAppIcon from '@/public/images/apps/apps-icon.svg'

import css from './styles.module.css'

type CustomAppPlaceholderProps = {
  error?: string
}

const CustomAppPlaceholder = ({ error = '' }: CustomAppPlaceholderProps) => {
  return (
    <div className={css.customAppPlaceholderContainer}>
      <SvgIcon
        className={classNames({
          [css.customAppPlaceholderIconError]: error,
          [css.customAppPlaceholderIconDefault]: !error,
        })}
        component={SafeAppIcon}
        inheritViewBox
      />
      <Typography ml={2} color={error ? 'error' : 'text.secondary'}>
        {error || 'Safe App card'}
      </Typography>
    </div>
  )
}

export default CustomAppPlaceholder
</file>

<file path="src/components/safe-apps/AddCustomAppModal/index.tsx">
import { useCallback } from 'react'
import type { SubmitHandler } from 'react-hook-form'
import { useForm } from 'react-hook-form'
import {
  DialogActions,
  DialogContent,
  Typography,
  Button,
  TextField,
  FormControlLabel,
  Checkbox,
  Box,
  FormHelperText,
} from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined'
import ModalDialog from '@/components/common/ModalDialog'
import { isValidURL } from '@safe-global/utils/utils/validation'
import { useCurrentChain } from '@/hooks/useChains'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useDebounce from '@/hooks/useDebounce'
import { fetchSafeAppFromManifest } from '@/services/safe-apps/manifest'
import { SAFE_APPS_EVENTS, trackSafeAppEvent } from '@/services/analytics'
import { isSameUrl, trimTrailingSlash } from '@/utils/url'
import CustomAppPlaceholder from './CustomAppPlaceholder'
import CustomApp from './CustomApp'
import { useShareSafeAppUrl } from '@/components/safe-apps/hooks/useShareSafeAppUrl'

import css from './styles.module.css'
import ExternalLink from '@/components/common/ExternalLink'
import { BRAND_NAME } from '@/config/constants'

type Props = {
  open: boolean
  onClose: () => void
  onSave: (data: SafeAppData) => void
  // A list of safe apps to check if the app is already there
  safeAppsList: SafeAppData[]
}

type CustomAppFormData = {
  appUrl: string
  riskAcknowledgement: boolean
  safeApp: SafeAppData
}

const HELP_LINK = 'https://docs.safe.global/apps-sdk-overview'
const APP_ALREADY_IN_THE_LIST_ERROR = 'This Safe App is already in the list'
const MANIFEST_ERROR = "The app doesn't support Safe App functionality"
const INVALID_URL_ERROR = 'The url is invalid'

export const AddCustomAppModal = ({ open, onClose, onSave, safeAppsList }: Props) => {
  const currentChain = useCurrentChain()

  const {
    register,
    handleSubmit,
    formState: { errors, isValid },
    watch,
    reset,
  } = useForm<CustomAppFormData>({ defaultValues: { riskAcknowledgement: false }, mode: 'onChange' })

  const onSubmit: SubmitHandler<CustomAppFormData> = () => {
    if (safeApp) {
      onSave(safeApp)
      trackSafeAppEvent(SAFE_APPS_EVENTS.ADD_CUSTOM_APP, safeApp.url)
      reset()
      onClose()
    }
  }

  const appUrl = watch('appUrl')
  const debouncedUrl = useDebounce(trimTrailingSlash(appUrl || ''), 300)

  const [safeApp, manifestError] = useAsync<SafeAppData | undefined>(() => {
    if (!isValidURL(debouncedUrl)) return

    return fetchSafeAppFromManifest(debouncedUrl, currentChain?.chainId || '')
  }, [currentChain, debouncedUrl])

  const handleClose = () => {
    reset()
    onClose()
  }

  const isAppAlreadyInTheList = useCallback(
    (appUrl: string) => safeAppsList.some((app) => isSameUrl(app.url, appUrl)),
    [safeAppsList],
  )

  const shareSafeAppUrl = useShareSafeAppUrl(safeApp?.url || '')
  const isSafeAppValid = isValid && safeApp
  const isCustomAppInTheDefaultList = errors?.appUrl?.type === 'alreadyExists'

  return (
    <ModalDialog open={open} onClose={handleClose} dialogTitle="Add custom Safe App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <DialogContent className={css.addCustomAppContainer}>
          <div className={css.addCustomAppFields}>
            <TextField
              required
              label="Safe App URL"
              error={errors?.appUrl?.type === 'validUrl'}
              helperText={errors?.appUrl?.type === 'validUrl' && errors?.appUrl?.message}
              autoComplete="off"
              {...register('appUrl', {
                required: true,
                validate: {
                  validUrl: (val: string) => (isValidURL(val) ? undefined : INVALID_URL_ERROR),
                  alreadyExists: (val: string) =>
                    isAppAlreadyInTheList(val) ? APP_ALREADY_IN_THE_LIST_ERROR : undefined,
                },
              })}
            />
            <Box
              sx={{
                mt: 2,
              }}
            >
              {safeApp ? (
                <>
                  <CustomApp safeApp={safeApp} shareUrl={isCustomAppInTheDefaultList ? shareSafeAppUrl : ''} />
                  {isCustomAppInTheDefaultList ? (
                    <Box
                      sx={{
                        display: 'flex',
                        mt: 2,
                        alignItems: 'center',
                      }}
                    >
                      <CheckIcon color="success" />
                      <Typography
                        sx={{
                          ml: 1,
                        }}
                      >
                        This Safe App is already registered
                      </Typography>
                    </Box>
                  ) : (
                    <>
                      <FormControlLabel
                        aria-required
                        control={
                          <Checkbox
                            {...register('riskAcknowledgement', {
                              required: true,
                            })}
                          />
                        }
                        label={`This Safe App is not part of ${BRAND_NAME} and I agree to use it at my own risk.`}
                        sx={{ mt: 2 }}
                      />

                      {errors.riskAcknowledgement && (
                        <FormHelperText error>Accepting the disclaimer is mandatory</FormHelperText>
                      )}
                    </>
                  )}
                </>
              ) : (
                <CustomAppPlaceholder error={isValidURL(debouncedUrl) && manifestError ? MANIFEST_ERROR : ''} />
              )}
            </Box>
          </div>

          <div className={css.addCustomAppHelp}>
            <InfoOutlinedIcon className={css.addCustomAppHelpIcon} />
            <Typography
              sx={{
                ml: 0.5,
              }}
            >
              Learn more about building
            </Typography>
            <ExternalLink className={css.addCustomAppHelpLink} href={HELP_LINK} fontWeight={700}>
              Safe Apps
            </ExternalLink>
            .
          </div>
        </DialogContent>

        <DialogActions disableSpacing>
          <Button onClick={handleClose}>Cancel</Button>
          <Button type="submit" variant="contained" disabled={!isSafeAppValid}>
            Add
          </Button>
        </DialogActions>
      </form>
    </ModalDialog>
  )
}
</file>

<file path="src/components/safe-apps/AddCustomAppModal/styles.module.css">
.addCustomAppContainer {
  padding: 0;
}

.addCustomAppFields {
  display: flex;
  flex-direction: column;
  padding: var(--space-3);
}

.addCustomAppHelp {
  display: flex;
  align-items: center;
  border-top: 2px solid var(--color-border-light);
  padding: var(--space-3);
}

.addCustomAppHelpLink {
  text-decoration: none;
  margin-left: calc(var(--space-1) / 2);
}

.addCustomAppHelpIcon {
  font-size: 16px;
  color: var(--color-text-secondary);
}

.customAppContainer {
  width: 100%;
  display: flex;
  flex-direction: column;
  position: relative;
  border: 1px solid var(--color-text-primary);
  border-radius: 6px;
  padding: var(--space-3);
}

.customAppCheckIcon {
  position: absolute;
  top: 27px;
  right: 25px;
}

.customAppPlaceholderContainer {
  width: 100%;
  display: flex;
  align-items: center;
  border: 1px solid var(--color-border-main);
  border-radius: 6px;
  padding: 16px 12px;
}

.customAppPlaceholderIconDefault > path {
  fill: var(--color-text-secondary);
}

.customAppPlaceholderIconError > path {
  fill: var(--color-error-main);
}
</file>

<file path="src/components/safe-apps/AddCustomSafeAppCard/index.tsx">
import { useState } from 'react'
import Card from '@mui/material/Card'
import Box from '@mui/material/Box'
import Button from '@mui/material/Button'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import AddCustomAppIcon from '@/public/images/apps/add-custom-app.svg'
import { AddCustomAppModal } from '@/components/safe-apps/AddCustomAppModal'

type Props = { onSave: (data: SafeAppData) => void; safeAppList: SafeAppData[] }

const AddCustomSafeAppCard = ({ onSave, safeAppList }: Props) => {
  const [addCustomAppModalOpen, setAddCustomAppModalOpen] = useState<boolean>(false)

  return (
    <>
      <Card>
        <Box p="48px 12px" display="flex" flexDirection="column" alignItems="center">
          {/* Add Custom Safe App Icon */}
          <AddCustomAppIcon alt="Add Custom Safe App card" />

          {/*  Add Custom Safe App Button */}
          <Button
            variant="contained"
            size="small"
            onClick={() => setAddCustomAppModalOpen(true)}
            sx={{
              mt: 3,
            }}
          >
            Add custom Safe App
          </Button>
        </Box>
      </Card>

      {/*  Add Custom Safe App Modal */}
      <AddCustomAppModal
        open={addCustomAppModalOpen}
        onClose={() => setAddCustomAppModalOpen(false)}
        onSave={onSave}
        safeAppsList={safeAppList}
      />
    </>
  )
}

export default AddCustomSafeAppCard
</file>

<file path="src/components/safe-apps/AppFrame/TransactionQueueBar/index.tsx">
import type { Dispatch, ReactElement, SetStateAction } from 'react'
import { Backdrop, Typography, Box, IconButton, Accordion, AccordionDetails, AccordionSummary } from '@mui/material'
import { ClickAwayListener } from '@mui/material'
import CloseIcon from '@mui/icons-material/Close'
import ExpandLessIcon from '@mui/icons-material/ExpandLess'

import useTxQueue from '@/hooks/useTxQueue'
import PaginatedTxns from '@/components/common/PaginatedTxns'
import styles from './styles.module.css'
import { getQueuedTransactionCount } from '@/utils/transactions'
import { BatchExecuteHoverProvider } from '@/components/transactions/BatchExecuteButton/BatchExecuteHoverProvider'
import BatchExecuteButton from '@/components/transactions/BatchExecuteButton'
import type { TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'

type Props = {
  expanded: boolean
  visible: boolean
  setExpanded: Dispatch<SetStateAction<boolean>>
  onDismiss: () => void
  transactions: TransactionListPage
}

const TransactionQueueBar = ({
  expanded,
  visible,
  setExpanded,
  onDismiss,
  transactions,
}: Props): ReactElement | null => {
  if (!visible || transactions.results.length === 0) {
    return null
  }

  const queuedTxCount = getQueuedTransactionCount(transactions)

  // if you inline the expression, it will split put the `queuedTxCount` on a new line
  // and make it harder to find this text for matchers in tests
  const barTitle = `(${queuedTxCount}) Transaction queue`
  return (
    <>
      <Box className={styles.barWrapper}>
        <ClickAwayListener onClickAway={() => setExpanded(false)} mouseEvent="onMouseDown" touchEvent="onTouchStart">
          <Accordion
            expanded={expanded}
            onChange={() => setExpanded((prev) => !prev)}
            TransitionProps={{
              timeout: {
                appear: 400,
                enter: 0,
                exit: 500,
              },
              unmountOnExit: false,
              mountOnEnter: true,
            }}
            sx={{
              // there are very specific rules for the border radius that we have to override
              borderBottomLeftRadius: '0 !important',
              borderBottomRightRadius: '0 !important',
            }}
          >
            <AccordionSummary
              sx={{ '.MuiAccordionSummary-content': { alignItems: 'center' }, height: TRANSACTION_BAR_HEIGHT }}
            >
              <Typography variant="body1" color="primary.main" fontWeight={700} sx={{ mr: 'auto' }}>
                {barTitle}
              </Typography>

              <IconButton
                onClick={(event) => {
                  event.stopPropagation()
                  setExpanded((prev) => !prev)
                }}
                aria-label={`${expanded ? 'close' : 'expand'} transaction queue bar`}
                sx={{ transform: expanded ? 'rotate(180deg)' : undefined }}
              >
                <ExpandLessIcon />
              </IconButton>
              <IconButton onClick={onDismiss} aria-label="dismiss transaction queue bar">
                <CloseIcon />
              </IconButton>
            </AccordionSummary>
            <AccordionDetails>
              <BatchExecuteHoverProvider>
                <Box display="flex" flexDirection="column" alignItems="flex-end">
                  <BatchExecuteButton />
                </Box>
                <PaginatedTxns useTxns={useTxQueue} />
              </BatchExecuteHoverProvider>
            </AccordionDetails>
          </Accordion>
        </ClickAwayListener>
      </Box>
      <Backdrop open={expanded} />
    </>
  )
}

export const TRANSACTION_BAR_HEIGHT = '64px'

export default TransactionQueueBar
</file>

<file path="src/components/safe-apps/AppFrame/TransactionQueueBar/styles.module.css">
.barWrapper {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 100%;

  /* MUI Drawer z-index default value see: https://mui.com/material-ui/customization/default-theme/?expand-path=$.zIndex */
  z-index: 1200;

  /*this rule is needed to prevent the bar from being expanded outside the screen without scrolling on mobile devices*/
  max-height: 90vh;
}
</file>

<file path="src/components/safe-apps/AppFrame/index.tsx">
import useAddressBook from '@/hooks/useAddressBook'
import useChainId from '@/hooks/useChainId'
import { type AddressBookItem, Methods } from '@safe-global/safe-apps-sdk'
import type { ReactElement } from 'react'
import { useCallback, useEffect } from 'react'
import { Box, CircularProgress, Typography } from '@mui/material'
import { useRouter } from 'next/router'
import Head from 'next/head'
import type { RequestId } from '@safe-global/safe-apps-sdk'
import { trackSafeAppOpenCount } from '@/services/safe-apps/track-app-usage-count'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useSafeAppFromBackend } from '@/hooks/safe-apps/useSafeAppFromBackend'
import { useSafePermissions } from '@/hooks/safe-apps/permissions'
import { useCurrentChain } from '@/hooks/useChains'
import { isSameUrl } from '@/utils/url'
import useTransactionQueueBarState from '@/components/safe-apps/AppFrame/useTransactionQueueBarState'
import { gtmTrackPageview } from '@/services/analytics/gtm'
import useThirdPartyCookies from './useThirdPartyCookies'
import useAnalyticsFromSafeApp from './useFromAppAnalytics'
import useAppIsLoading from './useAppIsLoading'
import { ThirdPartyCookiesWarning } from './ThirdPartyCookiesWarning'
import TransactionQueueBar, { TRANSACTION_BAR_HEIGHT } from './TransactionQueueBar'
import PermissionsPrompt from '@/components/safe-apps/PermissionsPrompt'
import { PermissionStatus, type SafeAppDataWithPermissions } from '@/components/safe-apps/types'

import css from './styles.module.css'
import SafeAppIframe from './SafeAppIframe'
import { useCustomAppCommunicator } from '@/hooks/safe-apps/useCustomAppCommunicator'
import { useSanctionedAddress } from '@/hooks/useSanctionedAddress'
import BlockedAddress from '@/components/common/BlockedAddress'
import { isSafePassApp } from '@/features/walletconnect/services/utils'
import { BRAND_NAME } from '@/config/constants'

const UNKNOWN_APP_NAME = 'Unknown Safe App'

type AppFrameProps = {
  appUrl: string
  allowedFeaturesList: string
  safeAppFromManifest: SafeAppDataWithPermissions
  isNativeEmbed?: boolean
}

const AppFrame = ({ appUrl, allowedFeaturesList, safeAppFromManifest, isNativeEmbed }: AppFrameProps): ReactElement => {
  const { safe, safeLoaded } = useSafeInfo()
  const addressBook = useAddressBook()
  const chainId = useChainId()
  const chain = useCurrentChain()
  const router = useRouter()
  const isSafePass = isSafePassApp(appUrl)
  const sanctionedAddress = useSanctionedAddress(isSafePass)
  const {
    expanded: queueBarExpanded,
    dismissedByUser: queueBarDismissed,
    setExpanded,
    dismissQueueBar,
    transactions,
  } = useTransactionQueueBarState()
  const queueBarVisible = transactions.results.length > 0 && !queueBarDismissed
  const [remoteApp] = useSafeAppFromBackend(appUrl, safe.chainId)
  const { thirdPartyCookiesDisabled, setThirdPartyCookiesDisabled } = useThirdPartyCookies()
  const { iframeRef, appIsLoading, isLoadingSlow, setAppIsLoading } = useAppIsLoading()
  useAnalyticsFromSafeApp(iframeRef)
  const { permissionsRequest, setPermissionsRequest, confirmPermissionRequest, getPermissions, hasPermission } =
    useSafePermissions()

  const communicator = useCustomAppCommunicator(iframeRef, remoteApp || safeAppFromManifest, chain, {
    onGetPermissions: getPermissions,
    onRequestAddressBook: (origin: string): AddressBookItem[] => {
      if (hasPermission(origin, Methods.requestAddressBook)) {
        return Object.entries(addressBook).map(([address, name]) => ({ address, name, chainId }))
      }

      return []
    },
    onSetPermissions: setPermissionsRequest,
  })

  const onAcceptPermissionRequest = (_origin: string, requestId: RequestId) => {
    const permissions = confirmPermissionRequest(PermissionStatus.GRANTED)
    communicator?.send(permissions, requestId as string)
  }

  const onRejectPermissionRequest = (requestId?: RequestId) => {
    if (requestId) {
      confirmPermissionRequest(PermissionStatus.DENIED)
      communicator?.send('Permissions were rejected', requestId as string, true)
    } else {
      setPermissionsRequest(undefined)
    }
  }

  useEffect(() => {
    if (!remoteApp) return

    trackSafeAppOpenCount(remoteApp.id)
  }, [remoteApp])

  const onIframeLoad = useCallback(() => {
    const iframe = iframeRef.current
    if (!iframe || !isSameUrl(iframe.src, appUrl)) {
      return
    }

    setAppIsLoading(false)

    if (!isNativeEmbed) {
      gtmTrackPageview(`${router.pathname}?appUrl=${router.query.appUrl}`, router.asPath)
    }
  }, [appUrl, iframeRef, setAppIsLoading, router, isNativeEmbed])

  if (!safeLoaded) {
    return <div />
  }

  if (sanctionedAddress && isSafePass) {
    return (
      <>
        <Head>
          <title>{`Safe Apps - Viewer - ${remoteApp ? remoteApp.name : UNKNOWN_APP_NAME}`}</title>
        </Head>
        <Box p={2}>
          <BlockedAddress address={sanctionedAddress} featureTitle="Safe{Pass} Safe app" />
        </Box>
      </>
    )
  }

  return (
    <>
      {!isNativeEmbed && (
        <Head>
          <title>{`${BRAND_NAME} - Safe Apps${remoteApp ? ' - ' + remoteApp.name : ''}`}</title>
        </Head>
      )}

      <div className={css.wrapper}>
        {thirdPartyCookiesDisabled && <ThirdPartyCookiesWarning onClose={() => setThirdPartyCookiesDisabled(false)} />}

        {appIsLoading && (
          <div className={css.loadingContainer}>
            {isLoadingSlow && (
              <Typography variant="h4" gutterBottom>
                The Safe App is taking too long to load, consider refreshing.
              </Typography>
            )}
            <CircularProgress size={48} color="primary" />
          </div>
        )}

        <div
          style={{
            height: '100%',
            display: appIsLoading ? 'none' : 'block',
            paddingBottom: queueBarVisible ? TRANSACTION_BAR_HEIGHT : 0,
          }}
        >
          <SafeAppIframe
            appUrl={appUrl}
            allowedFeaturesList={allowedFeaturesList}
            iframeRef={iframeRef}
            onLoad={onIframeLoad}
            title={safeAppFromManifest?.name}
          />
        </div>

        <TransactionQueueBar
          expanded={queueBarExpanded}
          visible={queueBarVisible && !queueBarDismissed}
          setExpanded={setExpanded}
          onDismiss={dismissQueueBar}
          transactions={transactions}
        />

        {!isNativeEmbed && permissionsRequest && (
          <PermissionsPrompt
            isOpen
            origin={permissionsRequest.origin}
            requestId={permissionsRequest.requestId}
            onAccept={onAcceptPermissionRequest}
            onReject={onRejectPermissionRequest}
            permissions={permissionsRequest.request}
          />
        )}
      </div>
    </>
  )
}

export default AppFrame
</file>

<file path="src/components/safe-apps/AppFrame/SafeAppIframe.tsx">
import type { MutableRefObject, ReactElement } from 'react'
import css from './styles.module.css'

type SafeAppIFrameProps = {
  appUrl: string
  allowedFeaturesList: string
  title?: string
  iframeRef?: MutableRefObject<HTMLIFrameElement | null>
  onLoad?: () => void
}

// see sandbox mdn docs for more details https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox
const IFRAME_SANDBOX_ALLOWED_FEATURES =
  'allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-forms allow-downloads allow-orientation-lock'

const SafeAppIframe = ({ appUrl, allowedFeaturesList, iframeRef, onLoad, title }: SafeAppIFrameProps): ReactElement => {
  return (
    <iframe
      className={css.iframe}
      id={`iframe-${appUrl}`}
      ref={iframeRef}
      src={appUrl}
      title={title}
      onLoad={onLoad}
      sandbox={IFRAME_SANDBOX_ALLOWED_FEATURES}
      allow={allowedFeaturesList}
    />
  )
}

export default SafeAppIframe
</file>

<file path="src/components/safe-apps/AppFrame/styles.module.css">
.wrapper {
  width: 100%;
  height: calc(100vh - var(--header-height));
}

.iframe {
  display: block;
  height: 100%;
  width: 100%;
  overflow: auto;
  box-sizing: border-box;
  border: none;
}

.loadingContainer {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}
</file>

<file path="src/components/safe-apps/AppFrame/ThirdPartyCookiesWarning.tsx">
import React from 'react'
import { Alert, AlertTitle } from '@mui/material'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'

type ThirdPartyCookiesWarningProps = {
  onClose: () => void
}

export const ThirdPartyCookiesWarning = ({ onClose }: ThirdPartyCookiesWarningProps): React.ReactElement => {
  return (
    <Alert
      severity="warning"
      onClose={onClose}
      sx={({ palette }) => ({
        background: palette.warning.light,
        border: 0,
        borderBottom: `1px solid ${palette.warning.main}`,
        borderRadius: '0px !important',
      })}
    >
      <AlertTitle>
        Third party cookies are disabled. Safe Apps may therefore not work properly. You can find out more information
        about this{' '}
        <ExternalLink href={HelpCenterArticle.COOKIES} fontSize="inherit">
          here
        </ExternalLink>
      </AlertTitle>
    </Alert>
  )
}
</file>

<file path="src/components/safe-apps/AppFrame/useAppCommunicator.ts">
import type { MutableRefObject } from 'react'
import { useEffect, useMemo, useState } from 'react'
import { getAddress } from 'ethers'
import type {
  SafeAppData,
  ChainInfo as WebCoreChainInfo,
  TransactionDetails,
} from '@safe-global/safe-gateway-typescript-sdk'
import type {
  AddressBookItem,
  BaseTransaction,
  EIP712TypedData,
  EnvironmentInfo,
  GetBalanceParams,
  GetTxBySafeTxHashParams,
  RequestId,
  RPCPayload,
  SendTransactionRequestParams,
  SendTransactionsParams,
  SignMessageParams,
  SignTypedMessageParams,
  ChainInfo,
  SafeInfoExtended,
} from '@safe-global/safe-apps-sdk'
import { Methods, RPC_CALLS } from '@safe-global/safe-apps-sdk'
import type { Permission, PermissionRequest } from '@safe-global/safe-apps-sdk/dist/types/types/permissions'
import type { SafeSettings } from '@safe-global/safe-apps-sdk'
import AppCommunicator from '@/services/safe-apps/AppCommunicator'
import { Errors, logError } from '@/services/exceptions'
import type { SafePermissionsRequest } from '@/hooks/safe-apps/permissions'
import { SAFE_APPS_EVENTS, trackSafeAppEvent } from '@/services/analytics'
import { useAppSelector } from '@/store'
import { selectRpc } from '@/store/settingsSlice'
import { createSafeAppsWeb3Provider } from '@/hooks/wallets/web3'
import { useDarkMode } from '@/hooks/useDarkMode'
import type { Balances } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

export enum CommunicatorMessages {
  REJECT_TRANSACTION_MESSAGE = 'Transaction was rejected',
}

type JsonRpcResponse = {
  jsonrpc: string
  id: number
  result?: any
  error?: string
}

export type UseAppCommunicatorHandlers = {
  onConfirmTransactions: (txs: BaseTransaction[], requestId: RequestId, params?: SendTransactionRequestParams) => void
  onSignMessage: (
    message: string | EIP712TypedData,
    requestId: string,
    method: Methods.signMessage | Methods.signTypedMessage,
    sdkVersion: string,
  ) => void
  onGetTxBySafeTxHash: (transactionId: string) => Promise<TransactionDetails>
  onGetEnvironmentInfo: () => EnvironmentInfo
  onGetSafeBalances: (currency: string) => Promise<Balances>
  onGetSafeInfo: () => SafeInfoExtended
  onGetChainInfo: () => ChainInfo | undefined
  onGetPermissions: (origin: string) => Permission[]
  onSetPermissions: (permissionsRequest?: SafePermissionsRequest) => void
  onRequestAddressBook: (origin: string) => AddressBookItem[]
  onSetSafeSettings: (settings: SafeSettings) => SafeSettings
  onGetOffChainSignature: (messageHash: string) => Promise<string | undefined>
}

const useAppCommunicator = (
  iframeRef: MutableRefObject<HTMLIFrameElement | null>,
  app: SafeAppData | undefined,
  chain: WebCoreChainInfo | undefined,
  handlers: UseAppCommunicatorHandlers,
): AppCommunicator | undefined => {
  const [communicator, setCommunicator] = useState<AppCommunicator | undefined>(undefined)
  const customRpc = useAppSelector(selectRpc)
  const isDarkMode = useDarkMode()

  const safeAppWeb3Provider = useMemo(() => {
    if (!chain) {
      return
    }

    return createSafeAppsWeb3Provider(chain, customRpc?.[chain.chainId])
  }, [chain, customRpc])

  useEffect(() => {
    let communicatorInstance: AppCommunicator

    const initCommunicator = (iframeRef: MutableRefObject<HTMLIFrameElement | null>, app?: SafeAppData) => {
      communicatorInstance = new AppCommunicator(iframeRef, {
        onMessage: (msg) => {
          if (!msg.data) return

          const isCustomApp = app && app.id < 1

          trackSafeAppEvent(
            { ...SAFE_APPS_EVENTS.SAFE_APP_SDK_METHOD_CALL },
            isCustomApp ? app?.url : app?.name || '',
            {
              method: msg.data.method,
              ethMethod: (msg.data.params as any)?.call,
              version: msg.data.env.sdkVersion,
            },
          )
        },
        onError: (error) => {
          logError(Errors._901, error.message)
        },
      })

      setCommunicator(communicatorInstance)
    }

    if (app) {
      initCommunicator(iframeRef, app)
    }

    return () => {
      communicatorInstance?.clear()
    }
  }, [app, iframeRef])

  useEffect(() => {
    const id = Math.random().toString(36).slice(2)

    communicator?.send(
      {
        darkMode: isDarkMode,
      },
      id,
    )
  }, [communicator, isDarkMode])

  // Adding communicator logic for the required SDK Methods
  // We don't need to unsubscribe from the events because there can be just one subscription
  // per event type and the next effect run will simply replace the handlers
  useEffect(() => {
    communicator?.on(Methods.getTxBySafeTxHash, (msg) => {
      const { safeTxHash } = msg.data.params as GetTxBySafeTxHashParams

      return handlers.onGetTxBySafeTxHash(safeTxHash)
    })

    communicator?.on(Methods.getEnvironmentInfo, handlers.onGetEnvironmentInfo)

    communicator?.on(Methods.getSafeInfo, handlers.onGetSafeInfo)

    communicator?.on(Methods.getSafeBalances, (msg) => {
      const { currency = 'usd' } = msg.data.params as GetBalanceParams

      return handlers.onGetSafeBalances(currency)
    })

    communicator?.on(Methods.rpcCall, async (msg) => {
      const params = msg.data.params as RPCPayload

      if (params.call === RPC_CALLS.safe_setSettings) {
        const settings = params.params[0] as SafeSettings
        return handlers.onSetSafeSettings(settings)
      }

      if (!safeAppWeb3Provider) {
        throw new Error('SafeAppWeb3Provider is not initialized')
      }

      try {
        return await safeAppWeb3Provider.send(params.call, params.params)
      } catch (err) {
        throw new Error((err as JsonRpcResponse).error)
      }
    })

    communicator?.on(Methods.sendTransactions, (msg) => {
      const { txs, params } = msg.data.params as SendTransactionsParams

      const transactions = txs.map(({ to, value, data }) => {
        return {
          to: getAddress(to),
          value: value ? BigInt(value).toString() : '0',
          data: data || '0x',
        }
      })

      handlers.onConfirmTransactions(transactions, msg.data.id, params)
    })

    communicator?.on(Methods.signMessage, (msg) => {
      const { message } = msg.data.params as SignMessageParams
      const sdkVersion = msg.data.env.sdkVersion
      handlers.onSignMessage(message, msg.data.id, Methods.signMessage, sdkVersion)
    })

    communicator?.on(Methods.getOffChainSignature, (msg) => {
      return handlers.onGetOffChainSignature(msg.data.params as string)
    })

    communicator?.on(Methods.signTypedMessage, (msg) => {
      const { typedData } = msg.data.params as SignTypedMessageParams
      const sdkVersion = msg.data.env.sdkVersion
      handlers.onSignMessage(typedData, msg.data.id, Methods.signTypedMessage, sdkVersion)
    })

    communicator?.on(Methods.getChainInfo, handlers.onGetChainInfo)

    communicator?.on(Methods.wallet_getPermissions, (msg) => {
      return handlers.onGetPermissions(msg.origin)
    })

    communicator?.on(Methods.wallet_requestPermissions, (msg) => {
      handlers.onSetPermissions({
        origin: msg.origin,
        request: msg.data.params as PermissionRequest[],
        requestId: msg.data.id,
      })
    })

    communicator?.on(Methods.requestAddressBook, (msg) => {
      return handlers.onRequestAddressBook(msg.origin)
    })

    // TODO: it will be moved to safe-apps-sdk soon
    communicator?.on('getCurrentTheme' as Methods, (msg) => {
      communicator.send(
        {
          darkMode: isDarkMode,
        },
        msg.data.id,
      )
    })
  }, [safeAppWeb3Provider, handlers, chain, communicator, isDarkMode])

  return communicator
}

export default useAppCommunicator
</file>

<file path="src/components/safe-apps/AppFrame/useAppIsLoading.ts">
import { useEffect, useRef, useState } from 'react'

const APP_LOAD_ERROR_TIMEOUT = 30000
const APP_SLOW_LOADING_WARNING_TIMEOUT = 15_000
const APP_LOAD_ERROR = 'There was an error loading the Safe App. There might be a problem with the Safe App provider.'

type UseAppIsLoadingReturnType = {
  iframeRef: React.RefObject<HTMLIFrameElement | null>
  appIsLoading: boolean
  setAppIsLoading: (appIsLoading: boolean) => void
  isLoadingSlow: boolean
}

const useAppIsLoading = (): UseAppIsLoadingReturnType => {
  const [appIsLoading, setAppIsLoading] = useState<boolean>(true)
  const [isLoadingSlow, setIsLoadingSlow] = useState<boolean>(false)
  const [, setAppLoadError] = useState<boolean>(false)

  const iframeRef = useRef<HTMLIFrameElement | null>(null)
  const timer = useRef<number>(0)
  const errorTimer = useRef<number>(0)

  useEffect(() => {
    const clearTimeouts = () => {
      clearTimeout(timer.current)
      clearTimeout(errorTimer.current)
    }

    if (appIsLoading) {
      timer.current = window.setTimeout(() => {
        setIsLoadingSlow(true)
      }, APP_SLOW_LOADING_WARNING_TIMEOUT)
      errorTimer.current = window.setTimeout(() => {
        setAppLoadError(() => {
          throw Error(APP_LOAD_ERROR)
        })
      }, APP_LOAD_ERROR_TIMEOUT)
    } else {
      clearTimeouts()
      setIsLoadingSlow(false)
    }

    return () => {
      clearTimeouts()
    }
  }, [appIsLoading])

  return {
    iframeRef,
    appIsLoading,
    setAppIsLoading,
    isLoadingSlow,
  }
}

export default useAppIsLoading
</file>

<file path="src/components/safe-apps/AppFrame/useFromAppAnalytics.ts">
import type { RefObject } from 'react'
import { useCallback, useEffect } from 'react'

import type { AnalyticsEvent } from '@/services/analytics'
import { EventType, trackSafeAppEvent } from '@/services/analytics'
import { SAFE_APPS_ANALYTICS_CATEGORY } from '@/services/analytics/events/safeApps'

//TODO: Remove Safe Apps old domain when all migrated to the new one
const ALLOWED_DOMAINS: RegExp[] = [
  /^http:\/\/localhost:[0-9]{4}$/,
  /^https:\/\/safe-apps\.dev\.5afe\.dev$/,
  /^https:\/\/apps\.gnosis-safe\.io$/,
  /^https:\/\/apps-portal\.safe\.global$/,
  /^https:\/\/community\.safe\.global$/,
  /^https:\/\/safe-dao-governance\.staging\.5afe\.dev$/,
  /^https:\/\/safe-dao-governance\.dev\.5afe\.dev$/,
]

const useAnalyticsFromSafeApp = (iframeRef: RefObject<HTMLIFrameElement | null>): void => {
  const isValidMessage = useCallback(
    (msg: MessageEvent<AnalyticsEvent>) => {
      if (!msg.data) return false
      const isFromIframe = iframeRef.current?.contentWindow === msg.source
      const isCategoryAllowed = msg.data.category === SAFE_APPS_ANALYTICS_CATEGORY
      const isDomainAllowed = ALLOWED_DOMAINS.find((regExp) => regExp.test(msg.origin)) !== undefined

      return isFromIframe && isCategoryAllowed && isDomainAllowed
    },
    [iframeRef],
  )

  const handleIncomingMessage = useCallback(
    (msg: MessageEvent<AnalyticsEvent & { safeAppName: string }>) => {
      if (!isValidMessage(msg)) {
        return
      }

      const { action, label, safeAppName } = msg.data

      trackSafeAppEvent(
        { event: EventType.SAFE_APP, category: SAFE_APPS_ANALYTICS_CATEGORY, action, label },
        safeAppName,
      )
    },
    [isValidMessage],
  )

  useEffect(() => {
    window.addEventListener('message', handleIncomingMessage)

    return () => {
      window.removeEventListener('message', handleIncomingMessage)
    }
  }, [handleIncomingMessage])
}

export default useAnalyticsFromSafeApp
</file>

<file path="src/components/safe-apps/AppFrame/useGetSafeInfo.ts">
import { useCallback } from 'react'
import useChainId from '@/hooks/useChainId'
import { useCurrentChain } from '@/hooks/useChains'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import useSafeInfo from '@/hooks/useSafeInfo'
import { getLegacyChainName } from '../utils'
import { useNestedSafeOwners } from '@/hooks/useNestedSafeOwners'

const useGetSafeInfo = () => {
  const { safe, safeAddress } = useSafeInfo()
  const isOwner = useIsSafeOwner()
  const nestedSafeOwners = useNestedSafeOwners()
  const chainId = useChainId()
  const chain = useCurrentChain()
  const chainName = chain?.chainName || ''

  return useCallback(() => {
    return {
      safeAddress,
      chainId: parseInt(chainId, 10),
      owners: safe.owners.map((owner) => owner.value),
      threshold: safe.threshold,
      isReadOnly: !isOwner && (nestedSafeOwners == null || nestedSafeOwners.length === 0),
      nonce: safe.nonce,
      implementation: safe.implementation.value,
      modules: safe.modules ? safe.modules.map((module) => module.value) : null,
      fallbackHandler: safe.fallbackHandler ? safe.fallbackHandler?.value : null,
      guard: safe.guard?.value || null,
      version: safe.version || null,
      network: getLegacyChainName(chainName || '', chainId).toUpperCase(),
    }
  }, [
    safeAddress,
    chainId,
    safe.owners,
    safe.threshold,
    safe.nonce,
    safe.implementation.value,
    safe.modules,
    safe.fallbackHandler,
    safe.guard?.value,
    safe.version,
    isOwner,
    nestedSafeOwners,
    chainName,
  ])
}

export default useGetSafeInfo
</file>

<file path="src/components/safe-apps/AppFrame/useThirdPartyCookies.ts">
import { useState, useEffect, useRef, useCallback } from 'react'
import { SAFE_APPS_THIRD_PARTY_COOKIES_CHECK_URL } from '@/config/constants'
import { Errors, logError } from '@/services/exceptions'

const SHOW_ALERT_TIMEOUT = 10000

const isSafari = (): boolean => {
  return navigator.userAgent.indexOf('Safari') > -1 && navigator.userAgent.indexOf('Chrome') <= -1
}

const createIframe = (uri: string, onload: () => void): HTMLIFrameElement => {
  const iframeElement: HTMLIFrameElement = document.createElement('iframe')

  iframeElement.src = uri
  iframeElement.setAttribute('style', 'display:none')
  iframeElement.onload = onload

  return iframeElement
}

type ThirdPartyCookiesType = {
  thirdPartyCookiesDisabled: boolean
  setThirdPartyCookiesDisabled: (value: boolean) => void
}

const useThirdPartyCookies = (): ThirdPartyCookiesType => {
  const iframeRef = useRef<HTMLIFrameElement>(null)
  const [thirdPartyCookiesDisabled, setThirdPartyCookiesDisabled] = useState<boolean>(false)

  const messageHandler = useCallback((event: MessageEvent) => {
    const data = event.data

    try {
      if (data.hasOwnProperty('isCookieEnabled')) {
        setThirdPartyCookiesDisabled(!data.isCookieEnabled)
        window.removeEventListener('message', messageHandler)
        document.body.removeChild(iframeRef.current as Node)
      }
    } catch (error) {
      logError(Errors._905, error)
    }
  }, [])

  useEffect(() => {
    if (isSafari()) {
      return
    }

    window.addEventListener('message', messageHandler)

    const iframeElement: HTMLIFrameElement = createIframe(SAFE_APPS_THIRD_PARTY_COOKIES_CHECK_URL, () =>
      iframeElement?.contentWindow?.postMessage({ test: 'cookie' }, '*'),
    )

    iframeRef.current = iframeElement
    document.body.appendChild(iframeElement)
  }, [messageHandler])

  useEffect(() => {
    let id: ReturnType<typeof setTimeout>

    if (thirdPartyCookiesDisabled) {
      id = setTimeout(() => setThirdPartyCookiesDisabled(false), SHOW_ALERT_TIMEOUT)
    }

    return () => clearTimeout(id)
  }, [thirdPartyCookiesDisabled])

  return { thirdPartyCookiesDisabled, setThirdPartyCookiesDisabled }
}

export default useThirdPartyCookies
</file>

<file path="src/components/safe-apps/AppFrame/useTransactionQueueBarState.ts">
import { useCallback, useContext, useEffect, useState } from 'react'
import useTxQueue from '@/hooks/useTxQueue'
import { TxModalContext } from '@/components/tx-flow'

const useTransactionQueueBarState = () => {
  const [expanded, setExpanded] = useState(false)
  const [dismissedByUser, setDismissedByUser] = useState(false)
  const { page = { results: [] } } = useTxQueue()
  const { txFlow } = useContext(TxModalContext)

  const dismissQueueBar = useCallback((): void => {
    setDismissedByUser(true)
  }, [])

  useEffect(() => {
    if (txFlow) setExpanded(false)
  }, [txFlow])

  return {
    expanded,
    dismissedByUser,
    setExpanded,
    dismissQueueBar,
    transactions: page,
  }
}

export default useTransactionQueueBarState
</file>

<file path="src/components/safe-apps/hooks/useShareSafeAppUrl.ts">
import { useRouter } from 'next/router'
import { resolveHref } from 'next/dist/client/resolve-href'
import { useEffect, useState } from 'react'
import type { UrlObject } from 'url'

import { AppRoutes } from '@/config/routes'
import { useCurrentChain } from '@/hooks/useChains'

export const useShareSafeAppUrl = (appUrl: string): string => {
  const router = useRouter()
  const chain = useCurrentChain()
  const [shareSafeAppUrl, setShareSafeAppUrl] = useState('')

  useEffect(() => {
    if (typeof window === 'undefined') {
      return
    }

    const shareUrlObj: UrlObject = {
      protocol: window.location.protocol,
      host: window.location.host,
      pathname: AppRoutes.share.safeApp,
      query: { appUrl, chain: chain?.shortName },
    }

    setShareSafeAppUrl(resolveHref(router, shareUrlObj))
  }, [appUrl, chain?.shortName, router])

  return shareSafeAppUrl
}
</file>

<file path="src/components/safe-apps/NativeSwapsCard/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import NativeSwapsCard from './index'
import { Box } from '@mui/material'
import { StoreDecorator } from '@/stories/storeDecorator'

const meta = {
  component: NativeSwapsCard,
  parameters: {
    componentSubtitle: 'Renders a promo card for native swaps',
  },

  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{ chains: { data: [{ chainId: '11155111', features: ['NATIVE_SWAPS'] }] } }}>
          <Box sx={{ maxWidth: '500px' }}>
            <Story />
          </Box>
        </StoreDecorator>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof NativeSwapsCard>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {},
}
</file>

<file path="src/components/safe-apps/NativeSwapsCard/index.tsx">
import CardHeader from '@mui/material/CardHeader'
import CardContent from '@mui/material/CardContent'
import Typography from '@mui/material/Typography'
import { Button, Paper, Stack } from '@mui/material'
import SafeAppIconCard from '../SafeAppIconCard'
import css from './styles.module.css'
import { SWAP_EVENTS, SWAP_LABELS } from '@/services/analytics/events/swaps'
import Track from '@/components/common/Track'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import useIsSwapFeatureEnabled from '@/features/swap/hooks/useIsSwapFeatureEnabled'

const SWAPS_APP_CARD_STORAGE_KEY = 'showSwapsAppCard'

const NativeSwapsCard = () => {
  const router = useRouter()
  const isSwapFeatureEnabled = useIsSwapFeatureEnabled()
  const [isSwapsCardVisible = true, setIsSwapsCardVisible] = useLocalStorage<boolean>(SWAPS_APP_CARD_STORAGE_KEY)
  if (!isSwapFeatureEnabled || !isSwapsCardVisible) return null

  return (
    <Paper className={css.container}>
      <CardHeader
        className={css.header}
        avatar={
          <div className={css.iconContainer}>
            <SafeAppIconCard src="/images/common/swap.svg" alt="Swap Icon" width={24} height={24} />
          </div>
        }
      />
      <CardContent className={css.content}>
        <Typography className={css.title} variant="h5">
          Native swaps are here!
        </Typography>

        <Typography
          className={css.description}
          variant="body2"
          sx={{
            color: 'text.secondary',
          }}
        >
          Experience seamless trading with better decoding and security in native swaps.
        </Typography>

        <Stack
          direction="row"
          className={css.buttons}
          sx={{
            gap: 2,
          }}
        >
          <Track {...SWAP_EVENTS.OPEN_SWAPS} label={SWAP_LABELS.safeAppsPromoWidget}>
            <Link href={{ pathname: AppRoutes.swap, query: { safe: router.query.safe } }} passHref legacyBehavior>
              <Button variant="contained" size="small">
                Try now
              </Button>
            </Link>
          </Track>
          <Button onClick={() => setIsSwapsCardVisible(false)} size="small" variant="text" sx={{ px: '16px' }}>
            Don&apos;t show
          </Button>
        </Stack>
      </CardContent>
    </Paper>
  )
}

export default NativeSwapsCard
</file>

<file path="src/components/safe-apps/NativeSwapsCard/styles.module.css">
.container {
  transition:
    background-color 0.3s ease-in-out,
    border 0.3s ease-in-out;
  border: 1px solid transparent;
  height: 100%;
}

.container:hover {
  background-color: var(--color-background-light);
  border: 1px solid var(--color-secondary-light);
}

.header {
  padding: var(--space-3) var(--space-2) var(--space-1) var(--space-2);
}

.content {
  padding: var(--space-2);
}

.iconContainer {
  position: relative;
  background: var(--color-secondary-light);
  border-radius: 50%;
  display: flex;
  padding: var(--space-1);
}

.title {
  line-height: 175%;
  margin: 0;

  flex-grow: 1;

  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.description {
  /* Truncate Safe App Description (3 lines) */
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.buttons {
  padding-top: var(--space-2);
  white-space: nowrap;
}
</file>

<file path="src/components/safe-apps/SafeAppActionButtons/index.tsx">
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import Box from '@mui/material/Box'
import IconButton from '@mui/material/IconButton'
import Tooltip from '@mui/material/Tooltip'
import SvgIcon from '@mui/material/SvgIcon'

import { useShareSafeAppUrl } from '@/components/safe-apps/hooks/useShareSafeAppUrl'
import { SAFE_APPS_EVENTS, trackSafeAppEvent } from '@/services/analytics'
import CopyButton from '@/components/common/CopyButton'
import ShareIcon from '@/public/images/common/share.svg'
import BookmarkIcon from '@/public/images/apps/bookmark.svg'
import BookmarkedIcon from '@/public/images/apps/bookmarked.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import InfoIcon from '@/public/images/notifications/info.svg'

type SafeAppActionButtonsProps = {
  safeApp: SafeAppData
  isBookmarked?: boolean
  onBookmarkSafeApp?: (safeAppId: number) => void
  removeCustomApp?: (safeApp: SafeAppData) => void
  openPreviewDrawer?: (safeApp: SafeAppData) => void
}

const SafeAppActionButtons = ({
  safeApp,
  isBookmarked,
  onBookmarkSafeApp,
  removeCustomApp,
  openPreviewDrawer,
}: SafeAppActionButtonsProps) => {
  const isCustomApp = safeApp.id < 1
  const shareSafeAppUrl = useShareSafeAppUrl(safeApp.url)

  const handleCopyShareSafeAppUrl = () => {
    const appName = isCustomApp ? safeApp.url : safeApp.name
    trackSafeAppEvent(SAFE_APPS_EVENTS.COPY_SHARE_URL, appName)
  }

  return (
    <Box display="flex" gap={1} alignItems="center">
      {/* Open the preview drawer */}
      {openPreviewDrawer && (
        <IconButton
          size="small"
          onClick={(event) => {
            event.preventDefault()
            event.stopPropagation()
            openPreviewDrawer(safeApp)
          }}
        >
          <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
        </IconButton>
      )}

      {/* Copy share Safe App url button */}
      <CopyButton
        initialToolTipText={`Copy share URL for ${safeApp.name}`}
        onCopy={handleCopyShareSafeAppUrl}
        text={shareSafeAppUrl}
      >
        <IconButton data-testid="copy-btn-icon" size="small">
          <SvgIcon component={ShareIcon} inheritViewBox color="border" fontSize="small" />
        </IconButton>
      </CopyButton>

      {/* Bookmark Safe App button */}
      {onBookmarkSafeApp && (
        <Tooltip title={`${isBookmarked ? 'Unpin' : 'Pin'} ${safeApp.name}`} placement="top">
          <IconButton
            size="small"
            onClick={(event) => {
              event.preventDefault()
              event.stopPropagation()
              onBookmarkSafeApp(safeApp.id)
            }}
          >
            <SvgIcon
              component={isBookmarked ? BookmarkedIcon : BookmarkIcon}
              inheritViewBox
              color={isBookmarked ? 'primary' : undefined}
              fontSize="small"
            />
          </IconButton>
        </Tooltip>
      )}

      {/* Remove Custom Safe App button */}
      {removeCustomApp && (
        <Tooltip title={`Delete ${safeApp.name}`} placement="top">
          <IconButton
            size="small"
            onClick={(event) => {
              event.preventDefault()
              event.stopPropagation()
              removeCustomApp(safeApp)
            }}
          >
            <SvgIcon component={DeleteIcon} inheritViewBox fontSize="small" color="border" />
          </IconButton>
        </Tooltip>
      )}
    </Box>
  )
}

export default SafeAppActionButtons
</file>

<file path="src/components/safe-apps/SafeAppCard/index.tsx">
import Link from 'next/link'
import { useRouter } from 'next/router'
import Card from '@mui/material/Card'
import CardHeader from '@mui/material/CardHeader'
import CardContent from '@mui/material/CardContent'
import Typography from '@mui/material/Typography'
import { resolveHref } from 'next/dist/client/resolve-href'
import classNames from 'classnames'
import type { ReactNode, SyntheticEvent } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import type { NextRouter } from 'next/router'

import type { UrlObject } from 'url'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import SafeAppActionButtons from '@/components/safe-apps/SafeAppActionButtons'
import SafeAppTags from '@/components/safe-apps/SafeAppTags'
import { isOptimizedForBatchTransactions } from '@/components/safe-apps/utils'
import { AppRoutes } from '@/config/routes'
import BatchIcon from '@/public/images/apps/batch-icon.svg'
import css from './styles.module.css'

type SafeAppCardProps = {
  safeApp: SafeAppData
  onClickSafeApp?: (e: SyntheticEvent) => void
  isBookmarked?: boolean
  onBookmarkSafeApp?: (safeAppId: number) => void
  removeCustomApp?: (safeApp: SafeAppData) => void
  openPreviewDrawer?: (safeApp: SafeAppData) => void
}

const SafeAppCard = ({
  safeApp,
  onClickSafeApp,
  isBookmarked,
  onBookmarkSafeApp,
  removeCustomApp,
  openPreviewDrawer,
}: SafeAppCardProps) => {
  const router = useRouter()

  const safeAppUrl = getSafeAppUrl(router, safeApp.url)

  return (
    <SafeAppCardGridView
      safeApp={safeApp}
      safeAppUrl={safeAppUrl}
      isBookmarked={isBookmarked}
      onBookmarkSafeApp={onBookmarkSafeApp}
      removeCustomApp={removeCustomApp}
      onClickSafeApp={onClickSafeApp}
      openPreviewDrawer={openPreviewDrawer}
    />
  )
}

export default SafeAppCard

export const getSafeAppUrl = (router: NextRouter, safeAppUrl: string) => {
  const shareUrlObj: UrlObject = {
    pathname: AppRoutes.apps.open,
    query: { safe: router.query.safe, appUrl: safeAppUrl },
  }

  return resolveHref(router, shareUrlObj)
}

type SafeAppCardViewProps = {
  safeApp: SafeAppData
  onClickSafeApp?: (e: SyntheticEvent) => void
  safeAppUrl: string
  isBookmarked?: boolean
  onBookmarkSafeApp?: (safeAppId: number) => void
  removeCustomApp?: (safeApp: SafeAppData) => void
  openPreviewDrawer?: (safeApp: SafeAppData) => void
}

const SafeAppCardGridView = ({
  safeApp,
  onClickSafeApp,
  safeAppUrl,
  isBookmarked,
  onBookmarkSafeApp,
  removeCustomApp,
  openPreviewDrawer,
}: SafeAppCardViewProps) => {
  return (
    <SafeAppCardContainer safeAppUrl={safeAppUrl} onClickSafeApp={onClickSafeApp} height="100%">
      {/* Safe App Header */}
      <CardHeader
        className={css.safeAppHeader}
        avatar={
          <div className={css.safeAppIconContainer}>
            {/* Batch transactions Icon */}
            {isOptimizedForBatchTransactions(safeApp) && (
              <BatchIcon className={css.safeAppBatchIcon} alt="batch transactions icon" />
            )}

            {/* Safe App Icon */}
            <SafeAppIconCard src={safeApp.iconUrl} alt={`${safeApp.name} logo`} />
          </div>
        }
        action={
          <>
            {/* Safe App Action Buttons */}
            <SafeAppActionButtons
              safeApp={safeApp}
              isBookmarked={isBookmarked}
              onBookmarkSafeApp={onBookmarkSafeApp}
              removeCustomApp={removeCustomApp}
              openPreviewDrawer={openPreviewDrawer}
            />
          </>
        }
      />

      <CardContent className={css.safeAppContent}>
        {/* Safe App Title */}
        <Typography className={css.safeAppTitle} gutterBottom variant="h5">
          {safeApp.name}
        </Typography>

        {/* Safe App Description */}
        <Typography className={css.safeAppDescription} variant="body2" color="text.secondary">
          {safeApp.description}
        </Typography>

        {/* Safe App Tags */}
        <SafeAppTags tags={safeApp.tags} />
      </CardContent>
    </SafeAppCardContainer>
  )
}

type SafeAppCardContainerProps = {
  onClickSafeApp?: (e: SyntheticEvent) => void
  safeAppUrl: string
  children: ReactNode
  height?: string
  className?: string
}

export const SafeAppCardContainer = ({
  children,
  safeAppUrl,
  onClickSafeApp,
  height,
  className,
}: SafeAppCardContainerProps) => {
  const handleClickSafeApp = (event: SyntheticEvent) => {
    if (onClickSafeApp) {
      onClickSafeApp(event)
    }
  }

  return (
    <Link href={safeAppUrl} passHref rel="noreferrer" onClick={handleClickSafeApp}>
      <Card className={classNames(css.safeAppContainer, className)} sx={{ height }}>
        {children}
      </Card>
    </Link>
  )
}
</file>

<file path="src/components/safe-apps/SafeAppCard/styles.module.css">
.safeAppContainer {
  transition:
    background-color 0.3s ease-in-out,
    border 0.3s ease-in-out;
  border: 1px solid transparent;
}

.safeAppContainer:hover {
  background-color: var(--color-background-light);
  border: 1px solid var(--color-secondary-light);
}

.safeAppHeader {
  padding: var(--space-3) var(--space-2) 0 var(--space-2);
}

.safeAppContent {
  padding: var(--space-2);
}

.safeAppIconContainer {
  position: relative;
}

.safeAppIconContainer iframe {
  display: block;
}

.safeAppBatchIcon {
  position: absolute;
  top: -6px;
  right: -8px;
}

.safeAppTitle {
  line-height: 175%;
  margin: 0;

  flex-grow: 1;

  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.safeAppDescription {
  /* Truncate Safe App Description (3 lines) */
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.safeAppTagContainer {
  padding-top: var(--space-2);
}

.safeAppTagLabel {
  border-radius: 4px;
  height: 24px;
}

.safeAppTagLabel > * {
  padding: var(--space-1);
}
</file>

<file path="src/components/safe-apps/SafeAppIconCard/index.tsx">
import ImageFallback from '@/components/common/ImageFallback'

const APP_LOGO_FALLBACK_IMAGE = `/images/apps/app-placeholder.svg`

const SafeAppIconCard = ({
  src,
  alt,
  width = 48,
  height = 48,
  fallback = APP_LOGO_FALLBACK_IMAGE,
}: {
  src: string
  alt: string
  width?: number
  height?: number
  fallback?: string
}) => <ImageFallback src={src} alt={alt} width={width} height={height} fallbackSrc={fallback} />

export default SafeAppIconCard
</file>

<file path="src/components/safe-apps/SafeAppLandingPage/AppActions.tsx">
import { Box, Button, MenuItem, Select, Typography, Grid, FormControl, InputLabel } from '@mui/material'
import type { ChainInfo, SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { useEffect, useMemo, useState } from 'react'
import Link from 'next/link'
import type { UrlObject } from 'url'
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { useAppSelector } from '@/store'
import { selectAllAddressBooks } from '@/store/addressBookSlice'
import { selectChains } from '@/store/chainsSlice'
import useLastSafe from '@/hooks/useLastSafe'
import { parsePrefixedAddress } from '@safe-global/utils/utils/addresses'
import SafeIcon from '@/components/common/SafeIcon'
import EthHashInfo from '@/components/common/EthHashInfo'
import { AppRoutes } from '@/config/routes'
import useOwnedSafes from '@/hooks/useOwnedSafes'
import { CTA_BUTTON_WIDTH, CTA_HEIGHT } from '@/components/safe-apps/SafeAppLandingPage/constants'
import CreateNewSafeSVG from '@/public/images/open/safe-creation.svg'

type Props = {
  appUrl: string
  wallet: ConnectedWallet | null
  onConnectWallet: () => Promise<void>
  chain: ChainInfo
  app: SafeAppData
}

type CompatibleSafesType = { address: string; chainId: string; shortName?: string }

const AppActions = ({ wallet, onConnectWallet, chain, appUrl, app }: Props): React.ReactElement => {
  const lastUsedSafe = useLastSafe()
  const ownedSafes = useOwnedSafes()
  const addressBook = useAppSelector(selectAllAddressBooks)
  const chains = useAppSelector(selectChains)
  const compatibleChains = app.chainIds

  const compatibleSafes = useMemo(
    () => getCompatibleSafes(ownedSafes, compatibleChains, chains.data),
    [ownedSafes, compatibleChains, chains.data],
  )

  const [safeToUse, setSafeToUse] = useState<CompatibleSafesType>()

  useEffect(() => {
    const defaultSafe = getDefaultSafe(compatibleSafes, chain.chainId, lastUsedSafe)
    if (defaultSafe) {
      setSafeToUse(defaultSafe)
    }
  }, [compatibleSafes, chain.chainId, lastUsedSafe])

  const hasWallet = !!wallet
  const hasSafes = compatibleSafes.length > 0
  const shouldCreateSafe = hasWallet && !hasSafes

  let button: React.ReactNode
  switch (true) {
    case hasWallet && hasSafes && !!safeToUse:
      const safe = `${safeToUse?.shortName}:${safeToUse?.address}`
      const href: UrlObject = {
        pathname: AppRoutes.apps.open,
        query: { safe, appUrl },
      }

      button = (
        <Link href={href} passHref legacyBehavior>
          <Button variant="contained" sx={{ width: CTA_BUTTON_WIDTH }} disabled={!safeToUse}>
            Use app
          </Button>
        </Link>
      )
      break
    case shouldCreateSafe:
      const redirect = `${AppRoutes.apps.index}?appUrl=${appUrl}`
      const createSafeHrefWithRedirect: UrlObject = {
        pathname: AppRoutes.newSafe.create,
        query: { safeViewRedirectURL: redirect, chain: chain.shortName },
      }
      button = (
        <Link href={createSafeHrefWithRedirect} passHref legacyBehavior>
          <Button variant="contained" sx={{ width: CTA_BUTTON_WIDTH }}>
            Create new Safe Account
          </Button>
        </Link>
      )
      break
    default:
      button = (
        <Button onClick={onConnectWallet} variant="contained" sx={{ width: CTA_BUTTON_WIDTH }}>
          Connect wallet
        </Button>
      )
  }
  let body: React.ReactNode
  if (hasWallet && hasSafes) {
    body = (
      <FormControl>
        <InputLabel id="safe-select-label">Select a Safe Account</InputLabel>
        <Select
          labelId="safe-select-label"
          value={safeToUse?.address || ''}
          onChange={(e) => {
            const safeToUse = compatibleSafes.find(({ address }) => address === e.target.value)
            setSafeToUse(safeToUse)
          }}
          autoWidth
          label="Select a Safe Account"
          sx={({ spacing }) => ({
            width: '311px',
            minHeight: '56px',
            '.MuiSelect-select': { padding: `${spacing(1)} ${spacing(2)}` },
          })}
        >
          {compatibleSafes.map(({ address, chainId, shortName }) => (
            <MenuItem key={`${chainId}:${address}`} value={address}>
              <Grid
                container
                sx={{
                  alignItems: 'center',
                  gap: 1,
                }}
              >
                <SafeIcon address={address} />

                <Grid item xs>
                  <Typography variant="body2">{addressBook?.[chainId]?.[address]}</Typography>

                  <EthHashInfo address={address} showAvatar={false} showName={false} prefix={shortName} />
                </Grid>
              </Grid>
            </MenuItem>
          ))}
        </Select>
      </FormControl>
    )
  } else {
    body = <CreateNewSafeSVG alt="An icon of a physical safe with a plus sign" />
  }

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'space-between',
        fontWeight: 700,
        height: CTA_HEIGHT,
      }}
    >
      <Typography
        variant="h5"
        sx={{
          fontWeight: 700,
        }}
      >
        Use the App with your Safe Account
      </Typography>
      {body}
      {button}
    </Box>
  )
}

export { AppActions }

const getCompatibleSafes = (
  ownedSafes: { [chainId: string]: string[] },
  compatibleChains: string[],
  chainsData: ChainInfo[],
): CompatibleSafesType[] => {
  return compatibleChains.reduce<CompatibleSafesType[]>((safes, chainId) => {
    const chainData = chainsData.find((chain: ChainInfo) => chain.chainId === chainId)

    return [
      ...safes,
      ...(ownedSafes[chainId] || []).map((address) => ({
        address,
        chainId,
        shortName: chainData?.shortName,
      })),
    ]
  }, [])
}

const getDefaultSafe = (
  compatibleSafes: CompatibleSafesType[],
  chainId: string,
  lastUsedSafe = '',
): CompatibleSafesType => {
  // as a first option, we use the last used Safe in the provided chain
  const lastViewedSafe = compatibleSafes.find((safe) => safe.address === parsePrefixedAddress(lastUsedSafe).address)

  if (lastViewedSafe) {
    return lastViewedSafe
  }

  // as a second option, we use any user Safe in the provided chain
  const safeInTheSameChain = compatibleSafes.find((safe) => safe.chainId === chainId)

  if (safeInTheSameChain) {
    return safeInTheSameChain
  }

  // as a fallback we salect a random compatible user Safe
  return compatibleSafes[0]
}
</file>

<file path="src/components/safe-apps/SafeAppLandingPage/constants.ts">
const CTA_HEIGHT = '218px'
const CTA_BUTTON_WIDTH = '186px'

export { CTA_HEIGHT, CTA_BUTTON_WIDTH }
</file>

<file path="src/components/safe-apps/SafeAppLandingPage/index.tsx">
import { useEffect } from 'react'
import { Box, CircularProgress, Paper, Grid2 as Grid } from '@mui/material'
import { OVERVIEW_EVENTS, SAFE_APPS_EVENTS, trackEvent, trackSafeAppEvent } from '@/services/analytics'
import { useSafeAppFromBackend } from '@/hooks/safe-apps/useSafeAppFromBackend'
import { useSafeAppFromManifest } from '@/hooks/safe-apps/useSafeAppFromManifest'
import { SafeAppDetails } from '@/components/safe-apps/SafeAppLandingPage/SafeAppDetails'
import { TryDemo } from '@/components/safe-apps/SafeAppLandingPage/TryDemo'
import { AppActions } from '@/components/safe-apps/SafeAppLandingPage/AppActions'
import useWallet from '@/hooks/wallets/useWallet'
import { AppRoutes } from '@/config/routes'
import { SAFE_APPS_DEMO_SAFE_MAINNET } from '@/config/constants'
import useOnboard from '@/hooks/wallets/useOnboard'
import { Errors, logError } from '@/services/exceptions'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'

type Props = {
  appUrl: string
  chain: ChainInfo
}

const CHAIN_ID_WITH_A_DEMO = '1'

const SafeAppLanding = ({ appUrl, chain }: Props) => {
  const [backendApp, , backendAppLoading] = useSafeAppFromBackend(appUrl, chain.chainId)
  const { safeApp, isLoading } = useSafeAppFromManifest(appUrl, chain.chainId, backendApp)
  const wallet = useWallet()
  const onboard = useOnboard()
  // show demo if the app was shared for mainnet or we can find the mainnet chain id on the backend
  const showDemo = chain.chainId === CHAIN_ID_WITH_A_DEMO || !!backendApp?.chainIds.includes(CHAIN_ID_WITH_A_DEMO)

  useEffect(() => {
    if (!isLoading && !backendAppLoading && safeApp.chainIds.length) {
      const appName = backendApp ? backendApp.name : safeApp.url

      trackSafeAppEvent({ ...SAFE_APPS_EVENTS.SHARED_APP_LANDING, label: chain.chainId }, appName)
    }
  }, [isLoading, backendApp, safeApp, backendAppLoading, chain])

  const handleConnectWallet = async () => {
    if (!onboard) return

    trackEvent(OVERVIEW_EVENTS.OPEN_ONBOARD)

    onboard.connectWallet().catch((e) => logError(Errors._107, e))
  }

  const handleDemoClick = () => {
    trackSafeAppEvent(SAFE_APPS_EVENTS.SHARED_APP_OPEN_DEMO, backendApp ? backendApp.name : appUrl)
  }

  if (isLoading || backendAppLoading) {
    return (
      <Box
        sx={{
          py: 4,
          textAlign: 'center',
        }}
      >
        <CircularProgress size={40} />
      </Box>
    )
  }

  return (
    <Grid container>
      <Grid size={{ sm: 12, md: 12, lg: 8, xl: 6 }} offset={{ lg: 2, xl: 3 }}>
        <Paper sx={{ p: 6 }}>
          <SafeAppDetails app={backendApp || safeApp} showDefaultListWarning={!backendApp} />
          <Grid container sx={{ mt: 4 }} rowSpacing={{ xs: 2, sm: 2 }}>
            <Grid size={{ xs: 12, sm: 12, md: showDemo ? 6 : 12 }}>
              <AppActions
                appUrl={appUrl}
                wallet={wallet}
                onConnectWallet={handleConnectWallet}
                chain={chain}
                app={backendApp || safeApp}
              />
            </Grid>
            {showDemo && (
              <Grid size={{ xs: 12, sm: 12, md: 6 }}>
                <TryDemo
                  demoUrl={{
                    pathname: AppRoutes.apps.open,
                    query: { safe: SAFE_APPS_DEMO_SAFE_MAINNET, appUrl },
                  }}
                  onClick={handleDemoClick}
                />
              </Grid>
            )}
          </Grid>
        </Paper>
      </Grid>
    </Grid>
  )
}

export { SafeAppLanding }
</file>

<file path="src/components/safe-apps/SafeAppLandingPage/SafeAppDetails.tsx">
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { Box } from '@mui/system'
import Typography from '@mui/material/Typography'
import Divider from '@mui/material/Divider'
import ChainIndicator from '@/components/common/ChainIndicator'
import WarningIcon from '@/public/images/notifications/warning.svg'
import SvgIcon from '@mui/material/SvgIcon'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'

type DetailsProps = {
  app: SafeAppData
  showDefaultListWarning: boolean
}

const SafeAppDetails = ({ app, showDefaultListWarning }: DetailsProps) => (
  <Box sx={{ display: 'flex', flexDirection: 'column' }}>
    <Box sx={{ display: 'flex', mb: 4 }}>
      <SafeAppIconCard src={app.iconUrl} alt={app.name} width={90} height={90} />

      <Box sx={{ ml: 8 }}>
        <Typography variant="h3" fontWeight={700}>
          {app.name}
        </Typography>
        <Typography variant="body2" mt={1}>
          {app.description}
        </Typography>
      </Box>
    </Box>
    <Divider />
    <Box sx={{ mt: 4 }}>
      <Typography variant="body1">Safe App URL</Typography>
      <Typography
        variant="body2"
        sx={({ palette, shape }) => ({
          mt: 1,
          p: 1,
          backgroundColor: palette.primary.background,
          display: 'inline-block',
          borderRadius: shape.borderRadius,
          fontWeight: 700,
        })}
      >
        {app.url}
      </Typography>
    </Box>
    <Box sx={{ mt: 2 }}>
      <Typography variant="body1">Available networks</Typography>
      <Box sx={{ display: 'flex', gap: 2, mt: 1, flexWrap: 'wrap' }}>
        {app.chainIds.map((chainId) => (
          <ChainIndicator key={chainId} chainId={chainId} inline showUnknown={false} />
        ))}
      </Box>
    </Box>
    <Divider sx={{ mt: 4 }} />
    {showDefaultListWarning && (
      <Box sx={{ display: 'flex', flexDirection: 'column', mt: 4 }}>
        <Box sx={{ mb: 4 }}>
          <Box sx={{ display: 'flex' }}>
            {/* 
            //@ts-ignore - "warning.dark" is a present in the palette */}
            <SvgIcon component={WarningIcon} inheritViewBox color="warning.dark" />
            <Typography variant="h5" sx={({ palette }) => ({ color: palette.warning.dark })}>
              Warning
            </Typography>
          </Box>
          <Typography variant="body1" mt={1} sx={({ palette }) => ({ color: palette.warning.dark })}>
            The application is not in the default Safe App list
          </Typography>
          <Typography variant="body2" mt={2}>
            Check the app link and ensure it comes from a trusted source
          </Typography>
        </Box>
        <Divider />
      </Box>
    )}
  </Box>
)

export { SafeAppDetails }
</file>

<file path="src/components/safe-apps/SafeAppLandingPage/TryDemo.tsx">
import { Box, Button, Typography } from '@mui/material'
import { CTA_HEIGHT, CTA_BUTTON_WIDTH } from '@/components/safe-apps/SafeAppLandingPage/constants'
import Link from 'next/link'
import type { LinkProps } from 'next/link'
import DemoAppSVG from '@/public/images/apps/apps-demo.svg'

type Props = {
  demoUrl: LinkProps['href']
  onClick(): void
}

const TryDemo = ({ demoUrl, onClick }: Props) => (
  <Box display="flex" flexDirection="column" alignItems="center" justifyContent="space-between" height={CTA_HEIGHT}>
    <Typography variant="h5" fontWeight={700}>
      Try the Safe App before using it
    </Typography>
    <DemoAppSVG alt="An icon of a internet browser" />
    <Link href={demoUrl} passHref legacyBehavior>
      <Button variant="outlined" sx={{ width: CTA_BUTTON_WIDTH }} onClick={onClick}>
        Try demo
      </Button>
    </Link>
  </Box>
)

export { TryDemo }
</file>

<file path="src/components/safe-apps/SafeAppList/index.tsx">
import { type SyntheticEvent, useCallback } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import SafeAppCard from '@/components/safe-apps/SafeAppCard'
import AddCustomSafeAppCard from '@/components/safe-apps/AddCustomSafeAppCard'
import SafeAppPreviewDrawer from '@/components/safe-apps/SafeAppPreviewDrawer'
import SafeAppsListHeader from '@/components/safe-apps/SafeAppsListHeader'
import SafeAppsZeroResultsPlaceholder from '@/components/safe-apps/SafeAppsZeroResultsPlaceholder'
import useSafeAppPreviewDrawer from '@/hooks/safe-apps/useSafeAppPreviewDrawer'
import css from './styles.module.css'
import { Skeleton } from '@mui/material'
import { useOpenedSafeApps } from '@/hooks/safe-apps/useOpenedSafeApps'
import NativeSwapsCard from '@/components/safe-apps/NativeSwapsCard'
import { SAFE_APPS_EVENTS, SAFE_APPS_LABELS, trackSafeAppEvent } from '@/services/analytics'
import { useSafeApps } from '@/hooks/safe-apps/useSafeApps'

type SafeAppListProps = {
  safeAppsList: SafeAppData[]
  safeAppsListLoading?: boolean
  bookmarkedSafeAppsId?: Set<number>
  eventLabel: SAFE_APPS_LABELS
  addCustomApp?: (safeApp: SafeAppData) => void
  removeCustomApp?: (safeApp: SafeAppData) => void
  title: string
  query?: string
  isFiltered?: boolean
  showNativeSwapsCard?: boolean
}

const SafeAppList = ({
  safeAppsList,
  safeAppsListLoading,
  bookmarkedSafeAppsId,
  eventLabel,
  addCustomApp,
  removeCustomApp,
  title,
  query,
  isFiltered = false,
  showNativeSwapsCard = false,
}: SafeAppListProps) => {
  const { togglePin } = useSafeApps()
  const { isPreviewDrawerOpen, previewDrawerApp, openPreviewDrawer, closePreviewDrawer } = useSafeAppPreviewDrawer()
  const { openedSafeAppIds } = useOpenedSafeApps()

  const showZeroResultsPlaceholder = query && safeAppsList.length === 0

  const handleSafeAppClick = useCallback(
    (e: SyntheticEvent, safeApp: SafeAppData) => {
      const isCustomApp = safeApp.id < 1
      if (!openedSafeAppIds.includes(safeApp.id) && !isCustomApp) {
        // Don't open link
        e.preventDefault()
        openPreviewDrawer(safeApp)
      } else {
        // We only track if not previously opened as it is then tracked in preview drawer
        trackSafeAppEvent({ ...SAFE_APPS_EVENTS.OPEN_APP, label: eventLabel }, safeApp.name)
      }
    },
    [eventLabel, openPreviewDrawer, openedSafeAppIds],
  )

  return (
    <>
      {/* Safe Apps List Header */}
      <SafeAppsListHeader title={title} amount={safeAppsList.length} />

      {/* Safe Apps List */}
      <ul data-testid="apps-list" className={css.safeAppsContainer}>
        {/* Add Custom Safe App Card */}
        {addCustomApp && (
          <li>
            <AddCustomSafeAppCard safeAppList={safeAppsList} onSave={addCustomApp} />
          </li>
        )}

        {safeAppsListLoading &&
          Array.from({ length: 8 }, (_, index) => (
            <li key={index}>
              <Skeleton variant="rounded" height="271px" />
            </li>
          ))}

        {!isFiltered && showNativeSwapsCard && <NativeSwapsCard />}

        {/* Flat list filtered by search query */}
        {safeAppsList.map((safeApp) => (
          <li key={safeApp.id}>
            <SafeAppCard
              safeApp={safeApp}
              isBookmarked={bookmarkedSafeAppsId?.has(safeApp.id)}
              onBookmarkSafeApp={() => togglePin(safeApp.id, eventLabel)}
              removeCustomApp={removeCustomApp}
              onClickSafeApp={(e) => handleSafeAppClick(e, safeApp)}
              openPreviewDrawer={openPreviewDrawer}
            />
          </li>
        ))}
      </ul>

      {/* Zero results placeholder */}
      {showZeroResultsPlaceholder && <SafeAppsZeroResultsPlaceholder searchQuery={query} />}

      {/* Safe App Preview Drawer */}
      <SafeAppPreviewDrawer
        isOpen={isPreviewDrawerOpen}
        safeApp={previewDrawerApp}
        isBookmarked={previewDrawerApp && bookmarkedSafeAppsId?.has(previewDrawerApp.id)}
        onClose={closePreviewDrawer}
        onBookmark={(appId) => togglePin(appId, SAFE_APPS_LABELS.apps_sidebar)}
      />
    </>
  )
}

export default SafeAppList
</file>

<file path="src/components/safe-apps/SafeAppList/styles.module.css">
.safeAppsContainer {
  display: grid;
  grid-gap: var(--space-3);
  list-style-type: none;
  padding: 0 0 var(--space-1);
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
}
</file>

<file path="src/components/safe-apps/SafeAppPreviewDrawer/index.tsx">
import Link from 'next/link'
import { useRouter } from 'next/router'
import Drawer from '@mui/material/Drawer'
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import Button from '@mui/material/Button'
import SvgIcon from '@mui/material/SvgIcon'
import IconButton from '@mui/material/IconButton'
import Tooltip from '@mui/material/Tooltip'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import { getSafeAppUrl } from '@/components/safe-apps/SafeAppCard'
import ChainIndicator from '@/components/common/ChainIndicator'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import SafeAppActionButtons from '@/components/safe-apps/SafeAppActionButtons'
import SafeAppTags from '@/components/safe-apps/SafeAppTags'
import SafeAppSocialLinksCard from '@/components/safe-apps/SafeAppSocialLinksCard'
import CloseIcon from '@/public/images/common/close.svg'
import { useOpenedSafeApps } from '@/hooks/safe-apps/useOpenedSafeApps'
import css from './styles.module.css'
import { SAFE_APPS_EVENTS, SAFE_APPS_LABELS, trackSafeAppEvent } from '@/services/analytics'

type SafeAppPreviewDrawerProps = {
  safeApp?: SafeAppData
  isOpen: boolean
  isBookmarked?: boolean
  onClose: () => void
  onBookmark?: (safeAppId: number) => void
}

const SafeAppPreviewDrawer = ({ isOpen, safeApp, isBookmarked, onClose, onBookmark }: SafeAppPreviewDrawerProps) => {
  const { markSafeAppOpened } = useOpenedSafeApps()
  const router = useRouter()
  const safeAppUrl = getSafeAppUrl(router, safeApp?.url || '')

  const onOpenSafe = () => {
    if (safeApp) {
      markSafeAppOpened(safeApp.id)
      trackSafeAppEvent({ ...SAFE_APPS_EVENTS.OPEN_APP, label: SAFE_APPS_LABELS.apps_sidebar }, safeApp.name)
    }
  }

  return (
    <Drawer anchor="right" open={isOpen} onClose={onClose}>
      <Box className={css.drawerContainer}>
        {/* Toolbar */}

        {safeApp && (
          <Box display="flex" justifyContent="right">
            <SafeAppActionButtons safeApp={safeApp} isBookmarked={isBookmarked} onBookmarkSafeApp={onBookmark} />
            <Tooltip title={`Close ${safeApp.name} preview`} placement="top">
              <IconButton
                onClick={onClose}
                size="small"
                sx={{
                  color: 'border.main',
                  ml: 1,
                }}
              >
                <SvgIcon component={CloseIcon} inheritViewBox color="border" fontSize="small" />
              </IconButton>
            </Tooltip>
          </Box>
        )}

        {/* Safe App Info */}
        <Box sx={{ px: 1 }}>
          <SafeAppIconCard src={safeApp?.iconUrl || ''} alt={`${safeApp?.name} logo`} width={90} height={90} />
        </Box>

        <Typography variant="h4" fontWeight={700} sx={{ mt: 2 }}>
          {safeApp?.name}
        </Typography>

        <Typography variant="body2" color="primary.light" sx={{ mt: 2 }}>
          {safeApp?.description}
        </Typography>

        {/* Tags */}
        <SafeAppTags tags={safeApp?.tags || []} />

        {/* Networks */}
        <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
          Available networks
        </Typography>

        <Box sx={{ display: 'flex', gap: 2, mt: 2, flexWrap: 'wrap' }}>
          {safeApp?.chainIds.map((chainId) => (
            <ChainIndicator key={chainId} chainId={chainId} inline showUnknown={false} />
          ))}
        </Box>

        {/* Open Safe App button */}
        <Link href={safeAppUrl} passHref legacyBehavior>
          <Button
            data-testid="open-safe-app-btn"
            fullWidth
            variant="contained"
            color="primary"
            component="a"
            href={safeApp?.url}
            sx={{ mt: 3 }}
            onClick={onOpenSafe}
          >
            Open Safe App
          </Button>
        </Link>

        {/* Safe App Social Links */}
        {safeApp && <SafeAppSocialLinksCard safeApp={safeApp} />}
      </Box>
    </Drawer>
  )
}

export default SafeAppPreviewDrawer
</file>

<file path="src/components/safe-apps/SafeAppPreviewDrawer/styles.module.css">
.drawerContainer {
  padding: calc(var(--header-height) + var(--space-3)) var(--space-3) 0 var(--space-3);
  width: 100vw;
}

@media (min-width: 600px) {
  .drawerContainer {
    width: 450px;
  }
}
</file>

<file path="src/components/safe-apps/SafeAppsErrorBoundary/index.tsx">
import type { ReactNode, ErrorInfo } from 'react'
import React from 'react'

type SafeAppsErrorBoundaryProps = {
  children?: ReactNode
  render: () => ReactNode
}

type SafeAppsErrorBoundaryState = {
  hasError: boolean
  error?: Error
}

class SafeAppsErrorBoundary extends React.Component<SafeAppsErrorBoundaryProps, SafeAppsErrorBoundaryState> {
  public state: SafeAppsErrorBoundaryState = {
    hasError: false,
  }

  constructor(props: SafeAppsErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('Uncaught error:', error, errorInfo)
  }

  public static getDerivedStateFromError(error: Error): SafeAppsErrorBoundaryState {
    return { hasError: true, error }
  }

  public render(): React.ReactNode {
    if (this.state.hasError) {
      return this.props.render()
    }

    return this.props.children
  }
}

export default SafeAppsErrorBoundary
</file>

<file path="src/components/safe-apps/SafeAppsErrorBoundary/SafeAppsLoadError.tsx">
import Typography from '@mui/material/Typography'
import Button from '@mui/material/Button'
import SvgIcon from '@mui/material/SvgIcon'
import { DISCORD_URL } from '@/config/constants'
import NetworkError from '@/public/images/apps/network-error.svg'

import css from './styles.module.css'
import ExternalLink from '@/components/common/ExternalLink'

type SafeAppsLoadErrorProps = {
  onBackToApps: () => void
}

const SafeAppsLoadError = ({ onBackToApps }: SafeAppsLoadErrorProps): React.ReactElement => {
  return (
    <div className={css.wrapper}>
      <div className={css.content}>
        <Typography variant="h1">Safe App could not be loaded</Typography>

        <SvgIcon component={NetworkError} inheritViewBox className={css.image} />

        <div>
          <Typography component="span">In case the problem persists, please reach out to us via </Typography>
          <ExternalLink href={DISCORD_URL} fontSize="medium">
            Discord
          </ExternalLink>
        </div>

        <Button href="#back" color="primary" onClick={onBackToApps}>
          Go back to the Safe Apps list
        </Button>
      </div>
    </div>
  )
}

export default SafeAppsLoadError
</file>

<file path="src/components/safe-apps/SafeAppsErrorBoundary/styles.module.css">
.wrapper {
  width: 100%;
  height: calc(100vh - var(--header-height));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.content {
  width: 400px;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.content > * {
  margin-top: 10px;
}

.linkWrapper {
  display: inline-flex;
  margin-bottom: 10px;
  align-items: center;
}

.linkWrapper > :first-of-type {
  margin-right: 5px;
}

.icon {
  position: relative;
  left: 3px;
  top: 3px;
}

.image {
  margin-top: 15px;
  margin-bottom: 15px;
  width: 64px;
  height: 64px;
}
</file>

<file path="src/components/safe-apps/SafeAppsFilters/index.tsx">
import Grid from '@mui/material/Grid'
import TextField from '@mui/material/TextField'
import InputAdornment from '@mui/material/InputAdornment'
import SvgIcon from '@mui/material/SvgIcon'
import InputLabel from '@mui/material/InputLabel'
import MenuItem from '@mui/material/MenuItem'
import OutlinedInput from '@mui/material/OutlinedInput'
import ListItemText from '@mui/material/ListItemText'
import Select from '@mui/material/Select'
import IconButton from '@mui/material/IconButton'
import Box from '@mui/material/Box'
import Checkbox from '@mui/material/Checkbox'
import FormLabel from '@mui/material/FormLabel'
import FormControl from '@mui/material/FormControl'
import FormControlLabel from '@mui/material/FormControlLabel'
import Tooltip from '@mui/material/Tooltip'
import CloseIcon from '@mui/icons-material/Close'
import type { SelectChangeEvent } from '@mui/material/Select'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import { getUniqueTags } from '@/components/safe-apps/utils'
import SearchIcon from '@/public/images/common/search.svg'
import BatchIcon from '@/public/images/apps/batch-icon.svg'
import css from './styles.module.css'

export type safeAppCatogoryOptionType = {
  label: string
  value: string
}

type SafeAppsFiltersProps = {
  onChangeQuery: (newQuery: string) => void
  onChangeFilterCategory: (category: string[]) => void
  onChangeOptimizedWithBatch: (optimizedWithBatch: boolean) => void
  selectedCategories: string[]
  safeAppsList: SafeAppData[]
}

const SafeAppsFilters = ({
  onChangeQuery,
  onChangeFilterCategory,
  onChangeOptimizedWithBatch,
  selectedCategories,
  safeAppsList,
}: SafeAppsFiltersProps) => {
  const categoryOptions = getCategoryOptions(safeAppsList)

  return (
    <Grid container spacing={2} className={css.filterContainer}>
      <Grid item xs={12} sm={12} md={6} lg={6}>
        {/* Search by name */}
        <TextField
          id="search-by-name"
          placeholder="Search by name or category"
          aria-label="Search Safe App by name"
          variant="filled"
          hiddenLabel
          onChange={(e) => {
            onChangeQuery(e.target.value)
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SvgIcon component={SearchIcon} inheritViewBox color="border" />
              </InputAdornment>
            ),
            disableUnderline: true,
          }}
          fullWidth
          size="small"
          sx={{
            '& > .MuiInputBase-root': { padding: '8px 16px' },
          }}
        />
      </Grid>

      {/* Select Category */}
      <Grid item xs={12} sm={6} md={3} lg={3}>
        <FormControl fullWidth>
          <InputLabel id="select-safe-app-category-label" shrink>
            Category
          </InputLabel>
          <Select
            labelId="select-safe-app-category-label"
            id="safe-app-category-selector"
            displayEmpty
            multiple
            value={selectedCategories}
            onChange={(event: SelectChangeEvent<string[]>) => {
              onChangeFilterCategory(event.target.value as string[])
            }}
            input={<OutlinedInput label="Category" fullWidth notched sx={{ paddingRight: '18px' }} />}
            renderValue={(selected) =>
              selected.length === 0 ? 'Select category' : `${selected.length} categories selected`
            }
            fullWidth
            MenuProps={categoryMenuProps}
          >
            {categoryOptions.length > 0 ? (
              categoryOptions.map((category) => (
                <MenuItem
                  sx={{ padding: '0 6px 2px 6px', height: CATEGORY_OPTION_HEIGHT }}
                  key={category.value}
                  value={category.value}
                  disableGutters
                >
                  <Checkbox
                    disableRipple
                    sx={{ '& .MuiSvgIcon-root': { fontSize: 24 }, padding: '3px' }}
                    checked={selectedCategories.includes(category.value)}
                  />
                  <ListItemText
                    primary={category.label}
                    primaryTypographyProps={{ fontSize: 14, paddingLeft: '5px' }}
                  />
                </MenuItem>
              ))
            ) : (
              <MenuItem disabled sx={{ padding: '0 6px 2px 6px', height: CATEGORY_OPTION_HEIGHT }} disableGutters>
                <ListItemText
                  primary="No categories defined"
                  primaryTypographyProps={{ fontSize: 14, paddingLeft: '5px' }}
                />
              </MenuItem>
            )}
          </Select>

          {/* clear selected categories button */}
          {selectedCategories.length > 0 && (
            <Tooltip title="clear selected categories" placement="top">
              <IconButton
                onClick={() => {
                  onChangeFilterCategory([])
                }}
                sx={{ position: 'absolute', top: '16px', right: '28px' }}
                color="default"
                component="label"
                size="small"
              >
                <CloseIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          )}
        </FormControl>
      </Grid>

      {/* Optimized with Batch Transaction */}
      <Grid item xs={12} sm={6} md={3} lg={3}>
        <Tooltip
          title={
            <div style={{ textAlign: 'center' }}>
              Merge multiple transactions into one to save time and gas fees inside apps offering this feature
            </div>
          }
        >
          <FormControl variant="standard">
            <FormLabel className={css.optimizedWithBatchLabel}>Optimized with</FormLabel>
            <FormControlLabel
              control={<Checkbox />}
              onChange={(_, value) => {
                onChangeOptimizedWithBatch(value)
              }}
              label={
                <Box display="flex" alignItems="center" gap={1}>
                  <span>Batch transactions</span> <BatchIcon />
                </Box>
              }
            />
          </FormControl>
        </Tooltip>
      </Grid>
    </Grid>
  )
}

export default SafeAppsFilters

const CATEGORY_OPTION_HEIGHT = 34
const CATEGORY_OPTION_PADDING_TOP = 8
const ITEMS_SHOWED = 11.5
const categoryMenuProps = {
  sx: {
    '& .MuiList-root': { padding: '9px 0' },
  },
  PaperProps: {
    style: {
      maxHeight: CATEGORY_OPTION_HEIGHT * ITEMS_SHOWED + CATEGORY_OPTION_PADDING_TOP,
      overflow: 'scroll',
    },
  },
}

export const getCategoryOptions = (safeAppList: SafeAppData[]): safeAppCatogoryOptionType[] => {
  return getUniqueTags(safeAppList).map((category) => ({
    label: category,
    value: category,
  }))
}
</file>

<file path="src/components/safe-apps/SafeAppsFilters/styles.module.css">
.filterContainer {
  background-color: var(--color-background-main);
  z-index: 2;
  position: sticky !important;
  top: calc(var(--header-height) + 49px);

  padding: var(--space-1) 0 var(--space-1) 0;
}

.optimizedWithBatchLabel {
  font-size: 12px;
  color: var(--color-text-primary);
}
</file>

<file path="src/components/safe-apps/SafeAppsHeader/index.tsx">
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import type { ReactElement } from 'react'
import { useCurrentChain } from '@/hooks/useChains'

import NavTabs from '@/components/common/NavTabs'
import { safeAppsNavItems } from '@/components/sidebar/SidebarNavigation/config'
import css from './styles.module.css'

const SafeAppsHeader = (): ReactElement => {
  const chain = useCurrentChain()
  return (
    <>
      <Box className={css.container}>
        {/* Safe Apps Title */}
        <Typography className={css.title} variant="h3">
          Explore the {chain?.chainName} ecosystem
        </Typography>

        {/* Safe Apps Subtitle */}
        <Typography className={css.subtitle}>
          Connect to your favourite web3 applications with your Safe Account, securely and efficiently.
        </Typography>
      </Box>

      {/* Safe Apps Tabs */}
      <Box className={css.tabs}>
        <NavTabs tabs={safeAppsNavItems} />
      </Box>
    </>
  )
}

export default SafeAppsHeader
</file>

<file path="src/components/safe-apps/SafeAppsHeader/styles.module.css">
.container {
  padding: var(--space-12) var(--space-3) 0;
  margin-bottom: var(--space-5);
  background-color: var(--color-background-main);
}

.title {
  font-weight: 700;
  font-size: 44px;
  line-height: 150%;
}

.subtitle {
  max-width: 700px;
  letter-spacing: 0.15px;
}

.tabs {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  background-color: var(--color-background-main);
  z-index: 2;
  width: 100%;
  position: sticky !important;
  top: var(--header-height);
  border-bottom: 1px solid var(--color-border-light);
}

@media (max-width: 599.95px) {
  .tabs {
    padding: 0 24px;
  }
}
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/AllowedFeaturesList.tsx">
import { Box, Typography, SvgIcon } from '@mui/material'
import ShieldIcon from '@/public/images/settings/permissions/shield.svg'

import { getBrowserPermissionDisplayValues } from '@/hooks/safe-apps/permissions'
import PermissionsCheckbox from '../PermissionCheckbox'

import type { AllowedFeatures, AllowedFeatureSelection } from '../types'
import { isBrowserFeature } from '../types'

type SafeAppsInfoAllowedFeaturesProps = {
  features: AllowedFeatureSelection[]
  onFeatureSelectionChange: (feature: AllowedFeatures, checked: boolean) => void
}

const AllowedFeaturesList: React.FC<SafeAppsInfoAllowedFeaturesProps> = ({
  features,
  onFeatureSelectionChange,
}): React.ReactElement => {
  return (
    <>
      <SvgIcon component={ShieldIcon} inheritViewBox color="primary" />

      <Typography
        variant="body2"
        color="text.secondary"
        sx={{
          textAlign: 'center',
          margin: '0 75px',
        }}
      >
        Manage the features Safe Apps can use
      </Typography>

      <Box mx={1} my={3} textAlign="left">
        <Typography>This Safe App is requesting permission to use:</Typography>

        <Box display="flex" flexDirection="column" ml={2} mt={1}>
          {features
            .filter(({ feature }) => isBrowserFeature(feature))
            .map(({ feature, checked }, index) => (
              <PermissionsCheckbox
                key={index}
                name="checkbox"
                checked={checked}
                onChange={(_, checked) => onFeatureSelectionChange(feature, checked)}
                label={getBrowserPermissionDisplayValues(feature).displayName}
              />
            ))}
        </Box>
      </Box>
    </>
  )
}

export default AllowedFeaturesList
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/constants.ts">
export const SECURITY_PRACTICES = [
  {
    id: '1',
    title: 'Always load a Safe App from trusted sources.',
    imageSrc: './safe-apps-security-practices/1.png',
  },
  {
    id: '2',
    title: 'Check the Safe App link you are trying to use.',
    subtitle: 'Do you know the domain and trust it?',
  },
  {
    id: '3',
    title: 'Always check transaction information while creating it, before proposing it to the Safe Account.',
    imageSrc: './safe-apps-security-practices/2.png',
  },
  {
    id: '4',
    title: 'Do a second check on transaction data before signing in the queue.',
    imageSrc: './safe-apps-security-practices/3.png',
  },
]
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/Domain.tsx">
import React from 'react'
import { Typography } from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'

import styles from './styles.module.css'

type DomainProps = {
  url: string
  showInOneLine?: boolean
}

const Domain: React.FC<DomainProps> = ({ url, showInOneLine }): React.ReactElement => {
  return (
    <Typography className={styles.domainText} sx={showInOneLine ? { overflowY: 'hidden', whiteSpace: 'nowrap' } : {}}>
      <CheckIcon color="success" className={styles.domainIcon} /> {url}
    </Typography>
  )
}

export default Domain
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/index.tsx">
import { memo, type ReactElement, useMemo, useState } from 'react'
import { alpha, Box } from '@mui/system'
import { Grid, LinearProgress } from '@mui/material'

import type { BrowserPermission } from '@/hooks/safe-apps/permissions'
import Slider from './Slider'
import AllowedFeaturesList from './AllowedFeaturesList'
import type { AllowedFeatures, AllowedFeatureSelection } from '../types'
import { PermissionStatus } from '../types'
import UnknownAppWarning from './UnknownAppWarning'
import { getOrigin } from '../utils'
import LegalDisclaimerContent from '@/components/common/LegalDisclaimerContent'

type SafeAppsInfoModalProps = {
  onCancel: () => void
  onConfirm: (shouldHide: boolean, browserPermissions: BrowserPermission[]) => void
  features: AllowedFeatures[]
  appUrl: string
  isConsentAccepted?: boolean
  isPermissionsReviewCompleted: boolean
  isSafeAppInDefaultList: boolean
  isFirstTimeAccessingApp: boolean
}

const SafeAppsInfoModal = ({
  onCancel,
  onConfirm,
  features,
  appUrl,
  isConsentAccepted,
  isPermissionsReviewCompleted,
  isSafeAppInDefaultList,
  isFirstTimeAccessingApp,
}: SafeAppsInfoModalProps): ReactElement => {
  const [hideWarning, setHideWarning] = useState(false)
  const [selectedFeatures, setSelectedFeatures] = useState<AllowedFeatureSelection[]>(
    features.map((feature) => {
      return {
        feature,
        checked: true,
      }
    }),
  )
  const [currentSlide, setCurrentSlide] = useState(0)

  const totalSlides = useMemo(() => {
    let totalSlides = 0

    if (!isConsentAccepted) {
      totalSlides += 1
    }

    if (!isPermissionsReviewCompleted) {
      totalSlides += 1
    }

    if (!isSafeAppInDefaultList && isFirstTimeAccessingApp) {
      totalSlides += 1
    }

    return totalSlides
  }, [isConsentAccepted, isFirstTimeAccessingApp, isPermissionsReviewCompleted, isSafeAppInDefaultList])

  const handleSlideChange = (newStep: number) => {
    const isFirstStep = newStep === -1
    const isLastStep = newStep === totalSlides

    if (isFirstStep) {
      onCancel()
    }

    if (isLastStep) {
      onConfirm(
        hideWarning,
        selectedFeatures.map(({ feature, checked }) => {
          return {
            feature,
            status: checked ? PermissionStatus.GRANTED : PermissionStatus.DENIED,
          }
        }),
      )
    }

    setCurrentSlide(newStep)
  }

  const progressValue = useMemo(() => {
    return ((currentSlide + 1) * 100) / totalSlides
  }, [currentSlide, totalSlides])

  const shouldShowUnknownAppWarning = useMemo(
    () => !isSafeAppInDefaultList && isFirstTimeAccessingApp,
    [isFirstTimeAccessingApp, isSafeAppInDefaultList],
  )

  const handleFeatureSelectionChange = (feature: AllowedFeatures, checked: boolean) => {
    setSelectedFeatures(
      selectedFeatures.map((feat) => {
        if (feat.feature === feature) {
          return {
            feature,
            checked,
          }
        }
        return feat
      }),
    )
  }

  const origin = useMemo(() => getOrigin(appUrl), [appUrl])

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        flexDirection: 'column',
        height: 'calc(100vh - 52px)',
      }}
    >
      <Box
        data-testid="app-info-modal"
        sx={({ palette }) => ({
          width: '450px',
          backgroundColor: palette.background.paper,
          boxShadow: `1px 2px 10px 0 ${alpha(palette.text.primary, 0.18)}`,
        })}
      >
        <LinearProgress
          variant="determinate"
          value={progressValue}
          sx={({ palette }) => ({
            height: '6px',
            backgroundColor: palette.background.paper,
            borderRadius: '8px 8px 0 0',
            '> .MuiLinearProgress-bar': {
              backgroundColor:
                progressValue === 100 && shouldShowUnknownAppWarning ? palette.warning.main : palette.primary.main,
              borderRadius: '8px',
            },
          })}
        />
        <Grid
          container
          direction="column"
          sx={{
            justifyContent: 'center',
            alignItems: 'center',
            textAlign: 'center',
            p: 3,
          }}
        >
          <Slider onSlideChange={handleSlideChange}>
            {!isConsentAccepted && <LegalDisclaimerContent />}

            {!isPermissionsReviewCompleted && (
              <AllowedFeaturesList
                features={selectedFeatures}
                onFeatureSelectionChange={handleFeatureSelectionChange}
              />
            )}

            {shouldShowUnknownAppWarning && <UnknownAppWarning url={origin} onHideWarning={setHideWarning} />}
          </Slider>
        </Grid>
      </Box>
    </Box>
  )
}

export default memo(SafeAppsInfoModal)
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/Slider.tsx">
import { Box, Button } from '@mui/material'
import React, { useState, useEffect, useMemo } from 'react'
import css from './styles.module.css'

type SliderProps = {
  onSlideChange: (slideIndex: number) => void
  initialStep?: number
  children: React.ReactNode
}

const SLIDER_TIMEOUT = 500

const Slider: React.FC<SliderProps> = ({ onSlideChange, children, initialStep }) => {
  const allSlides = useMemo(() => React.Children.toArray(children).filter(Boolean) as React.ReactElement[], [children])

  const [activeStep, setActiveStep] = useState(initialStep || 0)
  const [disabledBtn, setDisabledBtn] = useState(false)

  useEffect(() => {
    let id: ReturnType<typeof setTimeout> | undefined

    if (disabledBtn) {
      id = setTimeout(() => {
        setDisabledBtn(false)
      }, SLIDER_TIMEOUT)
    }

    return () => {
      if (id) clearTimeout(id)
    }
  }, [disabledBtn])

  const nextSlide = () => {
    if (disabledBtn) return

    const nextStep = activeStep + 1

    onSlideChange(nextStep)
    setActiveStep(nextStep)
    setDisabledBtn(true)
  }

  const prevSlide = () => {
    if (disabledBtn) return

    const prevStep = activeStep - 1

    onSlideChange(prevStep)
    setActiveStep(prevStep)
    setDisabledBtn(true)
  }

  const isFirstStep = activeStep === 0

  return (
    <>
      <div className={css.sliderContainer}>
        <div
          className={css.sliderInner}
          style={{
            transform: `translateX(-${activeStep * 100}%)`,
          }}
        >
          {allSlides.map((slide, index) => (
            <div className={css.sliderItem} key={index}>
              {slide}
            </div>
          ))}
        </div>
      </div>
      <Box display="flex" justifyContent="center" width="100%">
        <Button color="primary" variant="outlined" size="small" fullWidth onClick={prevSlide}>
          {isFirstStep ? 'Cancel' : 'Back'}
        </Button>

        <Button
          color="primary"
          variant="contained"
          size="small"
          fullWidth
          onClick={nextSlide}
          style={{
            marginLeft: 10,
          }}
        >
          Continue
        </Button>
      </Box>
    </>
  )
}

export default Slider
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/styles.module.css">
.sliderContainer {
  position: relative;
  margin: 0 auto;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.sliderInner {
  position: relative;
  display: flex;
  min-width: 100%;
  min-height: 100%;
  transform: translateX(0);
  height: 426px;
  transition: transform 0.5s ease;
}

.sliderItem {
  min-width: 100%;
  min-height: 100%;
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}

.domainIcon {
  position: relative;
  top: 6px;
  padding-right: 4px;
}

.domainText {
  display: block;
  font-size: 12px;
  font-weight: bold;
  overflow-wrap: anywhere;
  background-color: var(--color-background-light);
  padding: 0 15px 10px 10px;
  border-radius: 8px;
  max-width: 75%;
}
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/UnknownAppWarning.tsx">
import { useState } from 'react'
import { Box, Checkbox, FormControlLabel, Typography } from '@mui/material'
import WarningAmberOutlinedIcon from '@mui/icons-material/WarningAmberOutlined'
import lightPalette from '@/components/theme/lightPalette'
import Domain from './Domain'

type UnknownAppWarningProps = {
  url?: string
  onHideWarning?: (hideWarning: boolean) => void
}

const UnknownAppWarning = ({ url, onHideWarning }: UnknownAppWarningProps): React.ReactElement => {
  const [toggleHideWarning, setToggleHideWarning] = useState(false)

  const handleToggleWarningPreference = (): void => {
    onHideWarning?.(!toggleHideWarning)
    setToggleHideWarning(!toggleHideWarning)
  }

  return (
    <Box display="flex" flexDirection="column" height="100%" alignItems="center">
      <Box display="block" alignItems="center" mt={6}>
        <WarningAmberOutlinedIcon fontSize="large" color="warning" />
        <Typography variant="h3" fontWeight={700} mt={2} color={lightPalette.warning.main}>
          Warning
        </Typography>
      </Box>
      <Typography my={2} fontWeight={700} color={lightPalette.warning.main}>
        The application you are trying to access is not in the default Safe Apps list
      </Typography>

      <Typography my={2} textAlign="center">
        Check the link you are using and ensure that it comes from a source you trust
      </Typography>

      {url && <Domain url={url} showInOneLine />}

      {onHideWarning && (
        <Box mt={2}>
          <FormControlLabel
            control={
              <Checkbox
                checked={toggleHideWarning}
                onChange={handleToggleWarningPreference}
                name="Warning message preference"
              />
            }
            label="Don't show this warning again"
          />
        </Box>
      )}
    </Box>
  )
}

export default UnknownAppWarning
</file>

<file path="src/components/safe-apps/SafeAppsInfoModal/useSafeAppsInfoModal.ts">
import { useState, useEffect, useCallback, useMemo, useRef } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import type { BrowserPermission } from '@/hooks/safe-apps/permissions'
import useChainId from '@/hooks/useChainId'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import type { AllowedFeatures } from '../types'
import { PermissionStatus } from '../types'
import { getOrigin } from '../utils'

const SAFE_APPS_INFO_MODAL = 'SafeApps__infoModal'

type useSafeAppsInfoModal = {
  url: string
  safeApp?: SafeAppData
  permissions: AllowedFeatures[]
  addPermissions: (origin: string, permissions: BrowserPermission[]) => void
  getPermissions: (origin: string) => BrowserPermission[]
  remoteSafeAppsLoading: boolean
}

type ModalInfoProps = {
  [chainId: string]: {
    consentsAccepted: boolean
    warningCheckedCustomApps: string[]
  }
}

const useSafeAppsInfoModal = ({
  url,
  safeApp,
  permissions,
  addPermissions,
  getPermissions,
  remoteSafeAppsLoading,
}: useSafeAppsInfoModal): {
  isModalVisible: boolean
  isFirstTimeAccessingApp: boolean
  isSafeAppInDefaultList: boolean
  isConsentAccepted: boolean
  isPermissionsReviewCompleted: boolean
  onComplete: (shouldHide: boolean, permissions: BrowserPermission[]) => void
} => {
  const didMount = useRef(false)
  const chainId = useChainId()
  const [modalInfo = {}, setModalInfo] = useLocalStorage<ModalInfoProps>(SAFE_APPS_INFO_MODAL)
  const [isDisclaimerReadingCompleted, setIsDisclaimerReadingCompleted] = useState(false)

  useEffect(() => {
    if (!url) {
      setIsDisclaimerReadingCompleted(false)
    }
  }, [url])

  useEffect(() => {
    if (!didMount.current) {
      didMount.current = true
      return
    }
  }, [])

  const isPermissionsReviewCompleted = useMemo(() => {
    if (!url) return false

    const safeAppRequiredFeatures = permissions || []
    const featureHasBeenGrantedOrDenied = (feature: AllowedFeatures) =>
      getPermissions(url).some((permission: BrowserPermission) => {
        return permission.feature === feature && permission.status !== PermissionStatus.PROMPT
      })

    // If the app add a new feature in the manifest we need to detect it and show the modal again
    return !!safeAppRequiredFeatures.every(featureHasBeenGrantedOrDenied)
  }, [getPermissions, url, permissions])

  const isSafeAppInDefaultList = useMemo(() => {
    if (!url) return false

    return !!safeApp
  }, [safeApp, url])

  const isFirstTimeAccessingApp = useMemo(() => {
    if (!url) return true

    if (!modalInfo[chainId]) {
      return true
    }

    return !modalInfo[chainId]?.warningCheckedCustomApps?.includes(url)
  }, [chainId, modalInfo, url])

  const isModalVisible = useMemo(() => {
    const isComponentReady = didMount.current
    const shouldShowLegalDisclaimer = !modalInfo[chainId] || modalInfo[chainId].consentsAccepted === false
    const shouldShowAllowedFeatures = !isPermissionsReviewCompleted
    const shouldShowUnknownAppWarning =
      !remoteSafeAppsLoading && !isSafeAppInDefaultList && isFirstTimeAccessingApp && !isDisclaimerReadingCompleted

    return isComponentReady && (shouldShowLegalDisclaimer || shouldShowUnknownAppWarning || shouldShowAllowedFeatures)
  }, [
    chainId,
    isPermissionsReviewCompleted,
    isFirstTimeAccessingApp,
    isSafeAppInDefaultList,
    isDisclaimerReadingCompleted,
    remoteSafeAppsLoading,
    modalInfo,
  ])

  const onComplete = useCallback(
    (shouldHide: boolean, browserPermissions: BrowserPermission[]) => {
      const info = {
        consentsAccepted: true,
        warningCheckedCustomApps: [...(modalInfo[chainId]?.warningCheckedCustomApps || [])],
      }

      const origin = getOrigin(url)

      if (shouldHide && !modalInfo[chainId]?.warningCheckedCustomApps?.includes(origin)) {
        info.warningCheckedCustomApps.push(origin)
      }

      setModalInfo({
        ...modalInfo,
        [chainId]: info,
      })

      if (!isPermissionsReviewCompleted) {
        addPermissions(url, browserPermissions)
      }

      setIsDisclaimerReadingCompleted(true)
    },
    [addPermissions, chainId, isPermissionsReviewCompleted, modalInfo, setModalInfo, url],
  )

  return {
    isModalVisible,
    isSafeAppInDefaultList,
    isFirstTimeAccessingApp,
    isPermissionsReviewCompleted,
    isConsentAccepted: !!modalInfo?.[chainId]?.consentsAccepted,
    onComplete,
  }
}

export default useSafeAppsInfoModal
</file>

<file path="src/components/safe-apps/SafeAppsListHeader/index.tsx">
import Typography from '@mui/material/Typography'

type SafeAppsListHeaderProps = {
  title: string
  amount?: number
}

const SafeAppsListHeader = ({ title, amount }: SafeAppsListHeaderProps) => {
  return (
    <Typography
      variant="body2"
      sx={{
        color: 'primary.light',
        fontWeight: 'bold',
        mt: 3,
      }}
    >
      {title} ({amount || 0})
    </Typography>
  )
}

export default SafeAppsListHeader
</file>

<file path="src/components/safe-apps/SafeAppsListHeader/styles.module.css">
.gridView > rect {
  fill: currentColor;
}

.listView > path {
  fill: currentColor;
}
</file>

<file path="src/components/safe-apps/SafeAppSocialLinksCard/index.tsx">
import Link from 'next/link'
import Card from '@mui/material/Card'
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import IconButton from '@mui/material/IconButton'
import Divider from '@mui/material/Divider'
import { default as MuiLink } from '@mui/material/Link'
import HelpOutlineRoundedIcon from '@mui/icons-material/HelpOutlineRounded'
import GitHubIcon from '@mui/icons-material/GitHub'
import TelegramIcon from '@mui/icons-material/Telegram'
import TwitterIcon from '@mui/icons-material/Twitter'
import { SafeAppSocialPlatforms } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeAppData, SafeAppSocialProfile } from '@safe-global/safe-gateway-typescript-sdk'

import DiscordIcon from '@/public/images/common/discord-icon.svg'
import css from './styles.module.css'

type SafeAppSocialLinksCardProps = {
  safeApp: SafeAppData
}

const SafeAppSocialLinksCard = ({ safeApp }: SafeAppSocialLinksCardProps) => {
  const { socialProfiles, developerWebsite } = safeApp

  const hasSocialLinks = socialProfiles?.length > 0

  if (!hasSocialLinks && !developerWebsite) {
    return null
  }

  const discordSocialLink = getSocialProfile(socialProfiles, SafeAppSocialPlatforms.DISCORD)
  const twitterSocialLink = getSocialProfile(socialProfiles, SafeAppSocialPlatforms.TWITTER)
  const githubSocialLink = getSocialProfile(socialProfiles, SafeAppSocialPlatforms.GITHUB)
  const telegramSocialLink = getSocialProfile(socialProfiles, SafeAppSocialPlatforms.TELEGRAM)

  return (
    <Card className={css.container}>
      <Box display="flex" alignItems="center" gap={1} component="a">
        {/* Team Link section */}
        <div className={css.questionMarkIcon}>
          <HelpOutlineRoundedIcon color="info" />
        </div>
        <div>
          <Typography fontWeight="bold" variant="subtitle1">
            Something wrong with the Safe App?
          </Typography>
          <Typography color="primary.light" variant="body2">
            Get in touch with the team
          </Typography>
        </div>
      </Box>

      <Box className={css.socialLinksSectionContainer} display="flex" gap={4}>
        {/* Social links section */}
        {hasSocialLinks && (
          <div>
            <Typography color="border.main" variant="body2" pl={1}>
              Social Media
            </Typography>

            <Box display="flex" mt={0.2} minHeight="40px">
              {discordSocialLink && (
                <IconButton
                  aria-label="Discord link"
                  component="a"
                  target="_blank"
                  rel="noopener noreferrer"
                  href={discordSocialLink.url}
                >
                  <DiscordIcon />
                </IconButton>
              )}

              {twitterSocialLink && (
                <IconButton
                  aria-label="Twitter link"
                  component="a"
                  target="_blank"
                  rel="noopener noreferrer"
                  href={twitterSocialLink.url}
                >
                  <TwitterIcon color="border" />
                </IconButton>
              )}

              {githubSocialLink && (
                <IconButton
                  aria-label="Github link"
                  component="a"
                  href={githubSocialLink.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  style={{ height: '40px', width: '40px' }}
                >
                  <GitHubIcon color="border" />
                </IconButton>
              )}

              {telegramSocialLink && (
                <IconButton
                  aria-label="Telegram link"
                  component="a"
                  href={telegramSocialLink.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  style={{ height: '40px', width: '40px' }}
                >
                  <TelegramIcon color="border" />
                </IconButton>
              )}
            </Box>
          </div>
        )}

        {hasSocialLinks && developerWebsite && (
          <Divider sx={{ height: '40px' }} orientation="vertical" component="div" />
        )}

        {/* Developer website section */}
        {developerWebsite && (
          <Box display="flex" flexDirection="column">
            <Typography color="border.main" variant="body2">
              Website
            </Typography>

            <Link
              href={developerWebsite}
              passHref
              target="_blank"
              rel="noopener noreferrer"
              color="primary"
              legacyBehavior
            >
              <MuiLink target="_blank" className={css.websiteLink} underline="hover" fontWeight="bold" mt={1.2}>
                {developerWebsite}
              </MuiLink>
            </Link>
          </Box>
        )}
      </Box>
    </Card>
  )
}

export default SafeAppSocialLinksCard

const getSocialProfile = (socialProfiles: SafeAppSocialProfile[], platform: SafeAppSocialPlatforms) => {
  const socialLink = socialProfiles.find((socialProfile) => socialProfile.platform === platform)

  return socialLink
}
</file>

<file path="src/components/safe-apps/SafeAppSocialLinksCard/styles.module.css">
.container {
  margin-top: var(--space-4);
  background-color: var(--color-info-background);
  padding: var(--space-3);
}

.questionMarkIcon {
  width: 40px;
  height: 40px;
  padding: var(--space-1);
  font-size: 1.5rem;
  border-radius: 50%;
  background-color: #d7f6ff;
}

.socialLinksSectionContainer {
  margin-top: var(--space-2);
}

.websiteLink {
  /* Truncate Safe App link (2 lines) */
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
</file>

<file path="src/components/safe-apps/SafeAppsSDKLink/index.tsx">
import { useEffect, useState } from 'react'
import { Fab, Typography } from '@mui/material'
import KeyboardDoubleArrowUpRoundedIcon from '@mui/icons-material/KeyboardDoubleArrowUpRounded'
import classnames from 'classnames'
import CodeIcon from '@/public/images/apps/code-icon.svg'
import { SAFE_APPS_SDK_DOCS_URL } from '@/config/constants'
import css from './styles.module.css'
import ExternalLink from '@/components/common/ExternalLink'

const SafeAppsSDKLink = () => {
  const [isMini, setMini] = useState(false)

  // Minimize the widget when the user scrolls down
  useEffect(() => {
    const MAX_SCROLL = 130

    const onScroll = () => {
      const isScrolled = document.documentElement.scrollTop > MAX_SCROLL
      setMini(isScrolled)
    }

    document.addEventListener('scroll', onScroll)

    return () => document.removeEventListener('scroll', onScroll)
  }, [])

  return (
    <div className={classnames(css.container, { [css.mini]: isMini })} tabIndex={0}>
      <CodeIcon />

      <Typography variant="h6" className={css.title}>
        How to build on <i>Safe</i>?
      </Typography>

      <ExternalLink href={SAFE_APPS_SDK_DOCS_URL} className={css.link} noIcon variant="body2">
        <span>Learn more about Safe Apps SDK</span>
      </ExternalLink>

      <Fab className={css.openButton} variant="extended" size="small" color="secondary" tabIndex={-1}>
        <KeyboardDoubleArrowUpRoundedIcon fontSize="small" />
      </Fab>
    </div>
  )
}

export default SafeAppsSDKLink
</file>

<file path="src/components/safe-apps/SafeAppsSDKLink/styles.module.css">
.container {
  width: 200px;
  padding: var(--space-3);
  padding-top: var(--space-6);
  background-color: var(--color-background-main);
  border: 1px solid #12ff80;
  border-radius: 0 0 12px 12px;
  border-top: 0;
  position: fixed;
  z-index: 3;
  right: 64px;
  top: var(--header-height);
  transition: transform 0.3s ease-in-out;
  transform: translateY(-24px);
}

.container:focus-visible {
  outline: 5px auto Highlight;
  outline: 5px auto -webkit-focus-ring-color;
}

@media (max-width: 1400px) {
  .container {
    right: var(--space-3);
  }
}

@media (max-width: 1210px) {
  .container {
    transform: translateY(-80px);
  }
}

.container.mini {
  transform: translateY(-100%);
  transition-duration: 0.4s;
}

.container:focus,
.container:hover {
  z-index: 1200;
  transform: translateY(0);
}

.openButton {
  width: 50px;
  height: 20px;
  border-radius: 0 0 8px 8px;
  position: absolute;
  z-index: 1;
  left: 50%;
  bottom: -20px;
  margin-left: -25px;
  background-color: var(--color-secondary-main);
}

[data-theme='dark'] .openButton {
  background-color: var(--color-secondary-light);
}

[data-theme='dark'] .openButton:hover {
  background-color: var(--color-primary-dark);
}

.openButton svg {
  transform: rotate(180deg);
  transition: transform 0.3s ease-in-out;
}

.container:focus .openButton svg,
.container:hover .openButton svg {
  transform: rotate(0deg);
}

.title {
  font-weight: 700;
  font-size: 20px;
  line-height: 130%;
  letter-spacing: 0.15px;
  margin-top: var(--space-2);
}

.link {
  font-weight: 400;
  display: block;
  overflow: hidden;
  max-height: 0;
  opacity: 0;
  transition: all 0.3s ease-in-out;
}

.link span {
  display: block;
  margin-top: var(--space-1);
}

.mini .link,
.container:focus .link,
.container:hover .link {
  opacity: 1;
  max-height: 10ex;
}
</file>

<file path="src/components/safe-apps/SafeAppsZeroResultsPlaceholder/index.tsx">
import Typography from '@mui/material/Typography'
import PagePlaceholder from '@/components/common/PagePlaceholder'
import AddCustomAppIcon from '@/public/images/apps/add-custom-app.svg'
import { BRAND_NAME } from '@/config/constants'

const SafeAppsZeroResultsPlaceholder = ({ searchQuery }: { searchQuery: string }) => {
  return (
    <PagePlaceholder
      img={<AddCustomAppIcon />}
      text={
        <Typography variant="body1" color="primary.light" m={2} maxWidth="600px">
          No Safe Apps found matching <strong>{searchQuery}</strong>. Connect to dApps that haven&apos;t yet been
          integrated with the {BRAND_NAME} using WalletConnect.
        </Typography>
      }
    />
  )
}

export default SafeAppsZeroResultsPlaceholder
</file>

<file path="src/components/safe-apps/SafeAppTags/index.tsx">
import Stack from '@mui/material/Stack'
import Chip from '@mui/material/Chip'

import { filterInternalCategories } from '@/components/safe-apps/utils'
import css from './styles.module.css'

type SafeAppTagsProps = {
  tags: string[]
}

const SafeAppTags = ({ tags = [] }: SafeAppTagsProps) => {
  const displayedTags = filterInternalCategories(tags)

  return (
    <Stack
      className={css.safeAppTagContainer}
      sx={{
        flexDirection: 'row',
        gap: 1,
        flexWrap: 'wrap',
      }}
    >
      {displayedTags.map((tag) => (
        <Chip className={css.safeAppTagLabel} key={tag} label={tag} />
      ))}
    </Stack>
  )
}

export default SafeAppTags
</file>

<file path="src/components/safe-apps/SafeAppTags/styles.module.css">
.safeAppTagContainer {
  padding-top: var(--space-2);
}

.safeAppTagLabel {
  border-radius: 4px;
  height: 24px;
}
</file>

<file path="src/components/safe-apps/PermissionCheckbox.tsx">
import { Checkbox, FormControlLabel } from '@mui/material'

type PermissionsCheckboxProps = {
  label: string
  name: string
  checked: boolean
  onChange: (event: React.ChangeEvent<HTMLInputElement>, checked: boolean) => void
}

const PermissionsCheckbox = ({ label, checked, onChange, name }: PermissionsCheckboxProps): React.ReactElement => (
  <FormControlLabel
    sx={({ palette }) => ({
      flex: 1,
      '.MuiIconButton-root:not(.Mui-checked)': {
        color: palette.text.disabled,
      },
    })}
    control={<Checkbox checked={checked} onChange={onChange} name={name} />}
    label={label}
  />
)

export default PermissionsCheckbox
</file>

<file path="src/components/safe-apps/PermissionsPrompt.tsx">
import type { ReactElement } from 'react'
import type { PermissionRequest } from '@safe-global/safe-apps-sdk/dist/types/types/permissions'
import { Button, Dialog, DialogActions, DialogContent, Divider, Typography } from '@mui/material'

import { ModalDialogTitle } from '@/components/common/ModalDialog'
import { getSafePermissionDisplayValues } from '@/hooks/safe-apps/permissions'

interface PermissionsPromptProps {
  origin: string
  isOpen: boolean
  requestId: string
  permissions: PermissionRequest[]
  onReject: (requestId?: string) => void
  onAccept: (origin: string, requestId: string) => void
}

const PermissionsPrompt = ({
  origin,
  isOpen,
  requestId,
  permissions,
  onReject,
  onAccept,
}: PermissionsPromptProps): ReactElement => {
  return (
    <Dialog open={isOpen}>
      <ModalDialogTitle onClose={() => onReject()}>
        <Typography variant="body1" fontWeight={700}>
          Permissions Request
        </Typography>
      </ModalDialogTitle>
      <Divider />
      <DialogContent>
        <Typography>
          <b>{origin}</b> is requesting permissions for:
        </Typography>
        <ul>
          {permissions.map((permission, index) => (
            <li key={index}>
              <Typography>{getSafePermissionDisplayValues(Object.keys(permission)[0]).description}</Typography>
            </li>
          ))}
        </ul>
      </DialogContent>
      <DialogActions sx={{ justifyContent: 'center', my: 3 }}>
        <Button
          variant="contained"
          color="error"
          size="small"
          onClick={() => onReject(requestId)}
          sx={{ minWidth: '130px' }}
        >
          Reject
        </Button>
        <Button variant="contained" size="small" onClick={() => onAccept(origin, requestId)} sx={{ minWidth: '130px' }}>
          Accept
        </Button>
      </DialogActions>
    </Dialog>
  )
}

export default PermissionsPrompt
</file>

<file path="src/components/safe-apps/RemoveCustomAppModal.tsx">
import * as React from 'react'
import { DialogActions, DialogContent, Typography, Button } from '@mui/material'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import ModalDialog from '@/components/common/ModalDialog'

type Props = {
  open: boolean
  app: SafeAppData
  onClose: () => void
  onConfirm: (appId: number) => void
}

const RemoveCustomAppModal = ({ open, onClose, onConfirm, app }: Props) => (
  <ModalDialog open={open} onClose={onClose} dialogTitle="Confirm Safe App removal">
    <DialogContent>
      <Typography variant="h6" pt={3}>
        Are you sure you want to remove the <b>{app.name}</b> app?
      </Typography>
    </DialogContent>
    <DialogActions disableSpacing>
      <Button onClick={onClose}>Cancel</Button>
      <Button variant="danger" onClick={() => onConfirm(app.id)}>
        Remove
      </Button>
    </DialogActions>
  </ModalDialog>
)

export { RemoveCustomAppModal }
</file>

<file path="src/components/safe-apps/types.ts">
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

export enum PermissionStatus {
  GRANTED = 'granted',
  PROMPT = 'prompt',
  DENIED = 'denied',
}

const FEATURES = [
  'accelerometer',
  'ambient-light-sensor',
  'autoplay',
  'battery',
  'camera',
  'cross-origin-isolated',
  'display-capture',
  'document-domain',
  'encrypted-media',
  'execution-while-not-rendered',
  'execution-while-out-of-viewport',
  'fullscreen',
  'geolocation',
  'gyroscope',
  'keyboard-map',
  'magnetometer',
  'microphone',
  'midi',
  'navigation-override',
  'payment',
  'picture-in-picture',
  'publickey-credentials-get',
  'screen-wake-lock',
  'sync-xhr',
  'usb',
  'web-share',
  'xr-spatial-tracking',
  'clipboard-read',
  'clipboard-write',
  'gamepad',
  'speaker-selection',
]

type FeaturesType = typeof FEATURES

export type AllowedFeatures = FeaturesType[number]

export const isBrowserFeature = (featureKey: string): featureKey is AllowedFeatures => {
  return FEATURES.includes(featureKey as AllowedFeatures)
}

export type AllowedFeatureSelection = { feature: AllowedFeatures; checked: boolean }

export type SafeAppDataWithPermissions = SafeAppData & { safeAppsPermissions: AllowedFeatures[] }
</file>

<file path="src/components/safe-apps/utils.ts">
import { isHexString, toUtf8String } from 'ethers'
import { SafeAppAccessPolicyTypes } from '@safe-global/safe-gateway-typescript-sdk'
import { SafeAppFeatures } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import type { BaseTransaction, ChainInfo } from '@safe-global/safe-apps-sdk'

import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { validateAddress } from '@safe-global/utils/utils/validation'
import type { SafeAppDataWithPermissions } from './types'
import { SafeAppsTag } from '@/config/constants'

const validateTransaction = (t: BaseTransaction): boolean => {
  if (!['string', 'number'].includes(typeof t.value)) {
    return false
  }

  if (typeof t.value === 'string' && !/^(0x)?[0-9a-f]+$/i.test(t.value)) {
    return false
  }

  const isAddressValid = validateAddress(t.to) === undefined
  return isAddressValid && !!t.data && typeof t.data === 'string'
}

export const isTxValid = (txs: BaseTransaction[]): boolean => txs.length > 0 && txs.every((t) => validateTransaction(t))

export const getInteractionTitle = (value?: string, chain?: ChainInfo) => {
  const { decimals, symbol } = chain!.nativeCurrency
  return `Interact with${
    Number(value) !== 0 ? ` (and send ${formatVisualAmount(value || 0, decimals)} ${symbol} to)` : ''
  }:`
}

/**
 * If message is a hex value and is Utf8 encoded string we decode it, else we return the raw message
 * @param {string} message raw input message
 * @returns {string}
 */
export const getDecodedMessage = (message: string): string => {
  if (isHexString(message)) {
    // If is a hex string we try to extract a message
    try {
      return toUtf8String(message)
    } catch (e) {
      // the hex string is not UTF8 encoding so we will return the raw message.
    }
  }

  return message
}

export const getLegacyChainName = (chainName: string, chainId: string): string => {
  let network = chainName

  switch (chainId) {
    case '1':
      network = 'MAINNET'
      break
    case '100':
      network = 'XDAI'
  }

  return network
}

export const getEmptySafeApp = (url = '', appData?: SafeAppData): SafeAppDataWithPermissions => {
  return {
    id: Math.round(Math.random() * 1e9 + 1e6),
    url,
    name: 'unknown',
    iconUrl: '/images/apps/apps-icon.svg',
    description: '',
    chainIds: [],
    accessControl: {
      type: SafeAppAccessPolicyTypes.NoRestrictions,
    },
    tags: [],
    features: [],
    developerWebsite: '',
    socialProfiles: [],
    ...appData,
    safeAppsPermissions: [],
  }
}

export const getOrigin = (url?: string): string => {
  if (!url) return ''

  const { origin } = new URL(url)

  return origin
}

export const isOptimizedForBatchTransactions = (safeApp: SafeAppData) =>
  safeApp.features?.includes(SafeAppFeatures.BATCHED_TRANSACTIONS)

// some categories are used internally and we dont want to display them in the UI
export const filterInternalCategories = (categories: string[]): string[] => {
  const internalCategories = Object.values(SafeAppsTag)
  return categories.filter((tag) => !internalCategories.some((internalCategory) => tag === internalCategory))
}

// Get unique tags from all apps
export const getUniqueTags = (apps: SafeAppData[]): string[] => {
  // Get the list of categories from the safeAppsList
  const tags = apps.reduce<Set<string>>((result, app) => {
    app.tags.forEach((tag) => result.add(tag))
    return result
  }, new Set())

  // Filter out internal tags
  const filteredTags = filterInternalCategories(Array.from(tags))

  // Sort alphabetically
  return filteredTags.sort()
}
</file>

<file path="src/components/safe-messages/DecodedMsg/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { generateDataRowValue, TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { Value } from '@/components/transactions/TxDetails/TxData/DecodedData/ValueArray'
import { isByte } from '@/utils/transaction-guards'
import { normalizeTypedData } from '@safe-global/utils/utils/web3'
import { type TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { Box, Typography } from '@mui/material'
import { ErrorBoundary } from '@sentry/react'
import classNames from 'classnames'
import { isAddress } from 'ethers'
import type { ReactElement } from 'react'
import Msg from '../Msg'
import css from './styles.module.css'
import { logError, Errors } from '@/services/exceptions'

const EIP712_DOMAIN_TYPE = 'EIP712Domain'

const DecodedTypedObject = ({ displayedType, eip712Msg }: { displayedType: string; eip712Msg: TypedData }) => {
  const { types, message: msg, domain } = eip712Msg
  const findType = (paramName: string) => types[displayedType].find((paramType) => paramType.name === paramName)?.type
  return (
    <Box>
      <Typography
        textTransform="uppercase"
        fontWeight={700}
        variant="caption"
        sx={({ palette }) => ({ color: `${palette.border.main}` })}
      >
        {displayedType}
      </Typography>

      {Object.entries(displayedType === EIP712_DOMAIN_TYPE ? domain : msg).map((param, index) => {
        const [paramName, paramValue] = param
        const type = findType(paramName) || 'string'

        const isArrayValueParam = Array.isArray(paramValue)
        const isNested = Object.keys(types).some((typeName) => typeName === type || `${typeName}[]` === type)
        const inlineType = isAddress(paramValue as string) ? 'address' : isByte(type) ? 'bytes' : undefined
        const paramValueAsString = typeof paramValue === 'string' ? paramValue : JSON.stringify(paramValue, null, 2)
        return (
          <TxDataRow key={`${displayedType}_param-${index}`} title={`${param[0]}(${type})`}>
            {isNested ? (
              <Box
                className={css.nestedMsg}
                sx={{
                  borderRadius: (theme) => `${theme.shape.borderRadius}px`,
                }}
              >
                {paramValueAsString}
              </Box>
            ) : isArrayValueParam ? (
              <Value method={displayedType} type={type} value={paramValueAsString} />
            ) : (
              generateDataRowValue(paramValueAsString, inlineType, true)
            )}
          </TxDataRow>
        )
      })}
    </Box>
  )
}

export const DecodedMsg = ({
  message,
  isInModal = false,
}: {
  message: MessageItem['message'] | undefined
  isInModal?: boolean
}): ReactElement | null => {
  const isTextMessage = typeof message === 'string'

  if (!message) {
    return null
  }
  if (isTextMessage) {
    return <Msg message={message} />
  }

  // Normalize message such that we know the primaryType
  let normalizedMsg: TypedData
  try {
    normalizedMsg = normalizeTypedData(message)
  } catch (error) {
    logError(Errors._809, error)
    normalizedMsg = message
  }

  return (
    <Box
      className={classNames(css.container, { [css.scrollable]: isInModal })}
      sx={{
        borderRadius: (theme) => `${theme.shape.borderRadius}px`,
      }}
    >
      <ErrorBoundary fallback={<div>Error decoding message</div>}>
        <DecodedTypedObject eip712Msg={normalizedMsg} displayedType={EIP712_DOMAIN_TYPE} />
        <DecodedTypedObject eip712Msg={normalizedMsg} displayedType={normalizedMsg.primaryType} />
      </ErrorBoundary>
    </Box>
  )
}
</file>

<file path="src/components/safe-messages/DecodedMsg/styles.module.css">
.nestedMsg {
  border: 1px var(--color-border-light) solid;
  white-space: pre;
  font-family: monospace;
  font-size: 0.85rem;
  overflow: auto;
  padding: var(--space-1);
}

.container {
  padding: var(--space-1);
  border: 1px var(--color-border-light) solid;
}

.scrollable {
  max-height: 300px;
  overflow: auto;
}
</file>

<file path="src/components/safe-messages/InfoBox/index.tsx">
import type { ComponentType } from 'react'
import { type ReactElement, type ReactNode } from 'react'
import { Typography, SvgIcon, Divider } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import css from './styles.module.css'

const InfoBox = ({
  title,
  message,
  children,
  icon = InfoIcon,
}: {
  title: string
  message: ReactNode
  children?: ReactNode
  icon?: ComponentType
}): ReactElement => {
  return (
    <div data-testid="message-infobox" className={css.container}>
      <div className={css.message}>
        <SvgIcon component={icon} color="info" inheritViewBox fontSize="medium" />
        <div>
          <Typography variant="subtitle1" fontWeight="bold">
            {title}
          </Typography>
          <Typography variant="body2">{message}</Typography>
        </div>
      </div>
      {children && (
        <>
          <Divider className={css.divider} />
          <div>{children}</div>
        </>
      )}
    </div>
  )
}

export default InfoBox
</file>

<file path="src/components/safe-messages/InfoBox/styles.module.css">
.container {
  background-color: var(--color-info-background);
  padding: var(--space-2);
  border-radius: 4px;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.message {
  display: flex;
  align-items: flex-start;
  gap: var(--space-1);
}

.details {
  margin-top: var(--space-1);
  color: var(--color-primary-light);
  word-break: break-word;
}

.divider {
  margin-right: calc(-1 * var(--space-2));
  margin-left: calc(-1 * var(--space-2));
  border-color: var(--color-info-light);
}
</file>

<file path="src/components/safe-messages/Msg/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { TextField } from '@mui/material'
import { useMemo } from 'react'
import type { ReactElement } from 'react'

import css from './styles.module.css'

const MAX_ROWS = 10

const Msg = ({ message }: { message: MessageItem['message'] }): ReactElement => {
  const isTextMessage = typeof message === 'string'

  const readableData = useMemo(() => {
    return isTextMessage ? message : JSON.stringify(message, null, 2)
  }, [isTextMessage, message])

  return (
    <TextField
      maxRows={MAX_ROWS}
      multiline
      disabled
      fullWidth
      className={css.msg}
      inputProps={{
        value: readableData,
      }}
    />
  )
}

export default Msg
</file>

<file path="src/components/safe-messages/Msg/styles.module.css">
.msg :global .MuiInputBase-input {
  font-family: Menlo, 'Cascadia Code', monospace;
  font-size: 0.85rem;
  -webkit-text-fill-color: var(--color-text-primary);
  overflow: auto !important;
  white-space: pre-line;
}
</file>

<file path="src/components/safe-messages/MsgDetails/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { useMemo, type ReactElement } from 'react'
import { Accordion, AccordionSummary, Typography, AccordionDetails, Box } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import CodeIcon from '@mui/icons-material/Code'
import classNames from 'classnames'
import { ErrorBoundary } from '@sentry/react'

import { formatDateTime } from '@safe-global/utils/utils/date'
import EthHashInfo from '@/components/common/EthHashInfo'
import { InfoDetails } from '@/components/transactions/InfoDetails'
import { generateDataRowValue, TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import MsgSigners from '@/components/safe-messages/MsgSigners'
import useWallet from '@/hooks/wallets/useWallet'
import SignMsgButton from '@/components/safe-messages/SignMsgButton'
import { generateSafeMessageMessage, isEIP712TypedData } from '@safe-global/utils/utils/safe-messages'

import txDetailsCss from '@/components/transactions/TxDetails/styles.module.css'
import singleTxDecodedCss from '@/components/transactions/TxDetails/TxData/DecodedData/SingleTxDecoded/styles.module.css'
import infoDetailsCss from '@/components/transactions/InfoDetails/styles.module.css'
import { DecodedMsg } from '../DecodedMsg'
import CopyButton from '@/components/common/CopyButton'
import NamedAddressInfo from '@/components/common/NamedAddressInfo'
import MsgShareLink from '../MsgShareLink'

const MsgDetails = ({ msg }: { msg: MessageItem }): ReactElement => {
  const wallet = useWallet()
  const isConfirmed = msg.status === 'CONFIRMED'
  const safeMessage = useMemo(() => {
    try {
      return generateSafeMessageMessage(msg.message)
    } catch (e) {
      return ''
    }
  }, [msg.message])
  const verifyingContract = isEIP712TypedData(msg.message) ? msg.message.domain.verifyingContract : undefined

  return (
    <div className={txDetailsCss.container}>
      <div className={txDetailsCss.details}>
        <div className={txDetailsCss.shareLink}>
          <MsgShareLink safeMessageHash={msg.messageHash} />
        </div>
        <div className={txDetailsCss.txData}>
          <InfoDetails title="Created by:">
            <EthHashInfo
              address={msg.proposedBy.value || ''}
              name={msg.proposedBy.name}
              customAvatar={msg.proposedBy.logoUri || undefined}
              shortAddress={false}
              showCopyButton
              hasExplorer
            />
          </InfoDetails>
        </div>

        {verifyingContract && (
          <div className={txDetailsCss.txData}>
            <InfoDetails title="Verifying contract:">
              <NamedAddressInfo address={verifyingContract} shortAddress={false} showCopyButton hasExplorer />
            </InfoDetails>
          </div>
        )}

        <div className={txDetailsCss.txData}>
          <InfoDetails
            title={
              <>
                Message <CopyButton text={JSON.stringify(msg.message, null, 2)} />
              </>
            }
          >
            <ErrorBoundary fallback={<div>Error decoding message</div>}>
              <DecodedMsg message={msg.message} />
            </ErrorBoundary>
          </InfoDetails>
        </div>

        <div className={txDetailsCss.txSummary}>
          <TxDataRow title="Created">{formatDateTime(msg.creationTimestamp)}</TxDataRow>
          <TxDataRow title="Last modified">{formatDateTime(msg.modifiedTimestamp)}</TxDataRow>
          <TxDataRow title="Message hash">{generateDataRowValue(msg.messageHash, 'hash')}</TxDataRow>
          {safeMessage && <TxDataRow title="SafeMessage">{generateDataRowValue(safeMessage, 'hash')}</TxDataRow>}
        </div>

        {msg.preparedSignature && (
          <div className={classNames(txDetailsCss.txSummary, txDetailsCss.multiSend)}>
            <TxDataRow title="Prepared signature:">{generateDataRowValue(msg.preparedSignature, 'hash')}</TxDataRow>
          </div>
        )}

        <div className={txDetailsCss.multiSend}>
          {msg.confirmations.map((confirmation, i) => (
            <Accordion
              variant="elevation"
              key={confirmation.signature}
              defaultExpanded={confirmation.owner.value === wallet?.address}
            >
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <div className={singleTxDecodedCss.summary}>
                  <CodeIcon />
                  <Typography>{`Confirmation ${i + 1}`}</Typography>
                </div>
              </AccordionSummary>

              <AccordionDetails>
                <div className={infoDetailsCss.container}>
                  <EthHashInfo
                    address={confirmation.owner.value || ''}
                    name={confirmation.owner.name}
                    customAvatar={confirmation.owner.logoUri || undefined}
                    shortAddress={false}
                    showCopyButton
                    hasExplorer
                  />
                </div>
                <TxDataRow title="Signature:">
                  <EthHashInfo address={confirmation.signature} showAvatar={false} showCopyButton />
                </TxDataRow>
              </AccordionDetails>
            </Accordion>
          ))}
        </div>
      </div>
      <div className={txDetailsCss.txSigners}>
        <MsgSigners msg={msg} />
        {wallet && !isConfirmed && (
          <Box display="flex" alignItems="center" justifyContent="center" gap={1} mt={2}>
            <SignMsgButton msg={msg} />
          </Box>
        )}
      </div>
    </div>
  )
}

export default MsgDetails
</file>

<file path="src/components/safe-messages/MsgList/index.tsx">
import type { MessagePage } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import type { ReactElement } from 'react'

import { TxListGrid } from '@/components/transactions/TxList'
import MsgListItem from '@/components/safe-messages/MsgListItem'

const MsgList = ({ items }: { items: MessagePage['results'] }): ReactElement => {
  return (
    <TxListGrid>
      {items.map((item, i) => (
        <MsgListItem item={item} key={i} />
      ))}
    </TxListGrid>
  )
}

export default MsgList
</file>

<file path="src/components/safe-messages/MsgListItem/ExpandableMsgItem.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { Accordion, AccordionDetails, AccordionSummary, Box } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import type { ReactElement } from 'react'
import { ErrorBoundary } from '@sentry/react'

import MsgDetails from '@/components/safe-messages/MsgDetails'
import MsgSummary from '@/components/safe-messages/MsgSummary'

import txListItemCss from '@/components/transactions/TxListItem/styles.module.css'

const ExpandableMsgItem = ({ msg, expanded = false }: { msg: MessageItem; expanded?: boolean }): ReactElement => {
  return (
    <Accordion
      defaultExpanded={expanded}
      disableGutters
      elevation={0}
      className={txListItemCss.accordion}
      sx={{ border: 'none', '&:before': { display: 'none' } }}
    >
      <AccordionSummary
        data-testid="message-item"
        expandIcon={<ExpandMoreIcon />}
        sx={{ justifyContent: 'flex-start', overflowX: 'auto' }}
      >
        <MsgSummary msg={msg} />
      </AccordionSummary>

      <AccordionDetails sx={{ padding: 0 }}>
        <ErrorBoundary fallback={<Box sx={{ p: 2 }}>Failed to render message details</Box>}>
          <MsgDetails msg={msg} />
        </ErrorBoundary>
      </AccordionDetails>
    </Accordion>
  )
}

export default ExpandableMsgItem
</file>

<file path="src/components/safe-messages/MsgListItem/index.tsx">
import type { SafeMessageListItem } from '@safe-global/store/gateway/types'
import type { ReactElement } from 'react'

import { isSafeMessageListDateLabel, isSafeMessageListItem } from '@/utils/safe-message-guards'
import TxDateLabel from '@/components/transactions/TxDateLabel'
import ExpandableMsgItem from '@/components/safe-messages/MsgListItem/ExpandableMsgItem'

const MsgListItem = ({ item }: { item: SafeMessageListItem }): ReactElement | null => {
  if (isSafeMessageListDateLabel(item)) {
    return <TxDateLabel item={item} />
  }
  if (isSafeMessageListItem(item)) {
    return <ExpandableMsgItem msg={item} />
  }
  return null
}

export default MsgListItem
</file>

<file path="src/components/safe-messages/MsgShareLink/index.tsx">
import type { ReactElement } from 'react'
import { Button, IconButton, Link, SvgIcon } from '@mui/material'
import ShareIcon from '@/public/images/common/share.svg'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'
import Track from '@/components/common/Track'
import { MESSAGE_EVENTS } from '@/services/analytics/events/txList'
import React from 'react'
import CopyTooltip from '@/components/common/CopyTooltip'
import useOrigin from '@/hooks/useOrigin'

const MsgShareLink = ({ safeMessageHash, button }: { safeMessageHash: string; button?: boolean }): ReactElement => {
  const router = useRouter()
  const { safe = '' } = router.query
  const href = `${AppRoutes.transactions.msg}?safe=${safe}&messageHash=${safeMessageHash}`
  const txUrl = useOrigin() + href

  return (
    <Track {...MESSAGE_EVENTS.COPY_DEEPLINK}>
      <CopyTooltip text={txUrl} initialToolTipText="Copy the message URL">
        {button ? (
          <Button data-testid="share-btn" aria-label="Share" variant="contained" size="small" onClick={() => {}}>
            Copy link
          </Button>
        ) : (
          <IconButton data-testid="share-btn" component={Link} aria-label="Share">
            <SvgIcon component={ShareIcon} inheritViewBox fontSize="small" color="border" />
          </IconButton>
        )}
      </CopyTooltip>
    </Track>
  )
}

export default MsgShareLink
</file>

<file path="src/components/safe-messages/MsgSigners/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { useState, type ReactElement } from 'react'
import { Box, Link, List, ListItem, ListItemIcon, ListItemText, Skeleton, SvgIcon, Typography } from '@mui/material'
import CircleOutlinedIcon from '@mui/icons-material/CircleOutlined'

import CreatedIcon from '@/public/images/messages/created.svg'
import SignedIcon from '@/public/images/messages/signed.svg'
import DotIcon from '@/public/images/messages/dot.svg'
import EthHashInfo from '@/components/common/EthHashInfo'

import css from '@/components/safe-messages/MsgSigners/styles.module.css'
import txSignersCss from '@/components/transactions/TxSigners/styles.module.css'

// Icons

const Created = () => (
  <SvgIcon
    component={CreatedIcon}
    inheritViewBox
    className={css.icon}
    sx={{
      '& path:last-of-type': { fill: ({ palette }) => palette.background.paper },
    }}
  />
)

const Signed = () => (
  <SvgIcon
    component={SignedIcon}
    inheritViewBox
    className={css.icon}
    sx={{
      '& path:last-of-type': { fill: ({ palette }) => palette.background.paper },
    }}
  />
)

const Dot = () => <SvgIcon component={DotIcon} inheritViewBox className={css.dot} />

const shouldHideConfirmations = (msg: MessageItem): boolean => {
  const isConfirmed = msg.status === 'CONFIRMED'

  // Threshold reached or more than 3 confirmations
  return isConfirmed || msg.confirmations.length > 3
}

export const MsgSigners = ({
  msg,
  showOnlyConfirmations = false,
  showMissingSignatures = false,
  backgroundColor,
}: {
  msg: MessageItem
  showOnlyConfirmations?: boolean
  showMissingSignatures?: boolean
  backgroundColor?: string
}): ReactElement => {
  const [hideConfirmations, setHideConfirmations] = useState<boolean>(shouldHideConfirmations(msg))

  const toggleHide = () => {
    setHideConfirmations((prev) => !prev)
  }

  const { confirmations, confirmationsRequired, confirmationsSubmitted } = msg

  const missingConfirmations = [...new Array(Math.max(0, confirmationsRequired - confirmationsSubmitted))]

  const isConfirmed = msg.status === 'CONFIRMED'

  return (
    <List className={css.signers}>
      {!showOnlyConfirmations && (
        <ListItem>
          <ListItemIcon>
            <Created />
          </ListItemIcon>
          <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>Created</ListItemText>
        </ListItem>
      )}
      <ListItem>
        <ListItemIcon sx={{ backgroundColor }}>
          <Signed />
        </ListItemIcon>
        <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>
          Confirmations{' '}
          <Box component="span" className={txSignersCss.confirmationsTotal}>
            ({`${confirmationsSubmitted} of ${confirmationsRequired}`})
          </Box>
        </ListItemText>
      </ListItem>
      {!hideConfirmations &&
        confirmations.map(({ owner }) => (
          <ListItem key={owner.value} sx={{ py: 0 }}>
            <ListItemIcon sx={{ backgroundColor }}>
              <Dot />
            </ListItemIcon>
            <ListItemText>
              <EthHashInfo address={owner.value} name={owner.name} hasExplorer showCopyButton />
            </ListItemText>
          </ListItem>
        ))}
      {!showOnlyConfirmations && confirmations.length > 0 && (
        <ListItem>
          <ListItemIcon sx={{ backgroundColor }}>
            <Dot />
          </ListItemIcon>
          <ListItemText>
            <Link
              component="button"
              onClick={toggleHide}
              sx={{
                fontSize: 'medium',
              }}
            >
              {hideConfirmations ? 'Show all' : 'Hide all'}
            </Link>
          </ListItemText>
        </ListItem>
      )}
      {showMissingSignatures &&
        missingConfirmations.map((_, idx) => (
          <ListItem key={`skeleton${idx}`} sx={{ py: 0 }}>
            <ListItemIcon sx={{ backgroundColor }}>
              <SvgIcon component={CircleOutlinedIcon} className={css.dot} color="border" fontSize="small" />
            </ListItemIcon>
            <ListItemText>
              <Box
                sx={{
                  display: 'flex',
                  flexDirection: 'row',
                  alignItems: 'center',
                  gap: 1,
                }}
              >
                <Skeleton variant="circular" width={36} height={36} />
                <Typography
                  variant="body2"
                  sx={{
                    color: 'text.secondary',
                  }}
                >
                  Confirmation #{idx + 1 + confirmationsSubmitted}
                </Typography>
              </Box>
            </ListItemText>
          </ListItem>
        ))}
      {isConfirmed && (
        <ListItem>
          <ListItemIcon sx={{ backgroundColor }}>
            <Dot />
          </ListItemIcon>
          <ListItemText>Confirmed</ListItemText>
        </ListItem>
      )}
    </List>
  )
}

export default MsgSigners
</file>

<file path="src/components/safe-messages/MsgSigners/styles.module.css">
.icon {
  height: 16px;
  width: 16px;
}

.dot {
  height: 10px;
  width: 10px;
}

.signers {
  padding: 0;
}

.signers::before {
  content: '';
  position: absolute;
  border-left: 2px solid var(--color-border-light);
  left: 15px;
  top: 20px;
  height: calc(100% - 40px);
}

.signers :global .MuiListItem-root:first-of-type {
  padding-top: 0;
}

.signers :global .MuiListItem-root {
  padding-left: 0;
  padding-right: 0;
}

.signers :global .MuiListItemText-root {
  margin-top: var(--space-1);
  margin-bottom: var(--space-1);
}

.signers :global .MuiListItemIcon-root {
  color: var(--color-primary-main);
  justify-content: center;
  min-width: 32px;
  padding: var(--space-1) 0;
}
</file>

<file path="src/components/safe-messages/MsgSummary/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import type { SafeMessageStatus } from '@safe-global/store/gateway/types'
import { Box, CircularProgress, type Palette, Typography } from '@mui/material'
import type { ReactElement } from 'react'

import DateTime from '@/components/common/DateTime'
import MsgType from '@/components/safe-messages/MsgType'
import SignMsgButton from '@/components/safe-messages/SignMsgButton'
import useSafeMessageStatus from '@/hooks/messages/useSafeMessageStatus'
import TxConfirmations from '@/components/transactions/TxConfirmations'

import css from '@/components/transactions/TxSummary/styles.module.css'
import useIsSafeMessagePending from '@/hooks/messages/useIsSafeMessagePending'
import { isEIP712TypedData } from '@safe-global/utils/utils/safe-messages'

const getStatusColor = (value: SafeMessageStatus, palette: Palette): string => {
  switch (value) {
    case 'CONFIRMED':
      return palette.success.main
    case 'NEEDS_CONFIRMATION':
      return palette.warning.main
    default:
      return palette.text.primary
  }
}

const MsgSummary = ({ msg }: { msg: MessageItem }): ReactElement => {
  const { confirmationsSubmitted, confirmationsRequired } = msg
  const txStatusLabel = useSafeMessageStatus(msg)
  const isConfirmed = msg.status === 'CONFIRMED'
  const isPending = useIsSafeMessagePending(msg.messageHash)
  let type = ''
  if (isEIP712TypedData(msg.message)) {
    type = (msg.message as unknown as { primaryType: string }).primaryType
  }

  return (
    <Box className={[css.gridContainer, css.message].join(' ')}>
      <Box gridArea="type">
        <MsgType msg={msg} />
      </Box>

      <Box gridArea="info">{type || 'Signature'}</Box>

      <Box gridArea="date" className={css.date}>
        <DateTime value={msg.modifiedTimestamp} />
      </Box>

      <Box gridArea="confirmations">
        {confirmationsRequired > 0 && (
          <TxConfirmations
            submittedConfirmations={confirmationsSubmitted}
            requiredConfirmations={confirmationsRequired}
          />
        )}
      </Box>

      <Box gridArea="status">
        {isConfirmed || isPending ? (
          <Typography
            variant="caption"
            fontWeight="bold"
            display="flex"
            alignItems="center"
            gap={1}
            sx={{ color: ({ palette }) => getStatusColor(msg.status, palette) }}
          >
            {isPending && <CircularProgress size={14} color="inherit" />}

            {txStatusLabel}
          </Typography>
        ) : (
          <SignMsgButton msg={msg} compact />
        )}
      </Box>
    </Box>
  )
}

export default MsgSummary
</file>

<file path="src/components/safe-messages/MsgType/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { Box, SvgIcon } from '@mui/material'
import RequiredIcon from '@/public/images/messages/required.svg'
import ImageFallback from '@/components/common/ImageFallback'
import txTypeCss from '@/components/transactions/TxType/styles.module.css'
import { isEIP712TypedData } from '@safe-global/utils/utils/safe-messages'

const FALLBACK_LOGO_URI = '/images/transactions/custom.svg'
const MAX_TRIMMED_LENGTH = 20

const getMessageName = (msg: MessageItem) => {
  if (msg.name != null) return msg.name

  if (isEIP712TypedData(msg.message)) {
    return msg.message.domain?.name || ''
  }

  const firstLine = msg.message.split('\n')[0]
  let trimmed = firstLine.slice(0, MAX_TRIMMED_LENGTH)
  if (trimmed.length < firstLine.length) {
    trimmed += '…'
  }
  return trimmed
}

const MsgType = ({ msg }: { msg: MessageItem }) => {
  return (
    <Box className={txTypeCss.txType}>
      {msg.logoUri ? (
        <ImageFallback
          src={msg.logoUri || FALLBACK_LOGO_URI}
          fallbackSrc={FALLBACK_LOGO_URI}
          alt="Message type"
          width={16}
          height={16}
        />
      ) : (
        <SvgIcon component={RequiredIcon} viewBox="0 0 32 32" fontSize="small" />
      )}
      {getMessageName(msg)}
    </Box>
  )
}

export default MsgType
</file>

<file path="src/components/safe-messages/PaginatedMsgs/index.tsx">
import { Box } from '@mui/material'
import { Typography, Link, SvgIcon } from '@mui/material'
import { useEffect, useState } from 'react'
import type { ReactElement } from 'react'

import ErrorMessage from '@/components/tx/ErrorMessage'
import useSafeMessages from '@/hooks/messages/useSafeMessages'
import LinkIcon from '@/public/images/common/link.svg'
import NoMessagesIcon from '@/public/images/messages/no-messages.svg'
import InfiniteScroll from '@/components/common/InfiniteScroll'
import PagePlaceholder from '@/components/common/PagePlaceholder'
import MsgList from '@/components/safe-messages/MsgList'
import SkeletonTxList from '@/components/common/PaginatedTxns/SkeletonTxList'
import { HelpCenterArticle } from '@/config/constants'
import useSafeInfo from '@/hooks/useSafeInfo'

const NoMessages = (): ReactElement => {
  return (
    <PagePlaceholder
      img={<NoMessagesIcon />}
      text={
        <Typography
          variant="body1"
          sx={{
            color: 'primary.light',
            m: 2,
            maxWidth: '600px',
          }}
        >
          Some applications allow you to interact with them via off-chain contract signatures (&ldquo;messages&ldquo;)
          that you can generate with your Safe Account.
        </Typography>
      }
    >
      <Link
        rel="noopener noreferrer"
        target="_blank"
        href={HelpCenterArticle.SIGNED_MESSAGES}
        sx={{
          fontWeight: 700,
        }}
      >
        Learn more about off-chain messages{' '}
        <SvgIcon component={LinkIcon} inheritViewBox fontSize="small" sx={{ verticalAlign: 'middle', ml: 0.5 }} />
      </Link>
    </PagePlaceholder>
  )
}

const MsgPage = ({
  pageUrl,
  onNextPage,
}: {
  pageUrl: string
  onNextPage?: (pageUrl: string) => void
}): ReactElement => {
  const { page, error, loading } = useSafeMessages(pageUrl)

  return (
    <>
      {page && page.results.length > 0 && <MsgList items={page.results} />}
      {page?.results.length === 0 && <NoMessages />}
      {error && <ErrorMessage>Error loading messages</ErrorMessage>}
      {loading && <SkeletonTxList />}
      {page?.next && onNextPage && (
        <Box
          sx={{
            my: 4,
            textAlign: 'center',
          }}
        >
          <InfiniteScroll onLoadMore={() => onNextPage(page.next!)} />
        </Box>
      )}
    </>
  )
}

const PaginatedMsgs = (): ReactElement => {
  const [pages, setPages] = useState<string[]>([''])
  const { safeAddress, safe } = useSafeInfo()

  // Trigger the next page load
  const onNextPage = (pageUrl: string) => {
    setPages((prev) => prev.concat(pageUrl))
  }

  // Reset the pages when the Safe Account changes
  useEffect(() => {
    setPages([''])
  }, [safe.chainId, safeAddress])

  return (
    <Box
      sx={{
        mb: 4,
        position: 'relative',
      }}
    >
      {pages.map((pageUrl, index) => (
        <MsgPage key={pageUrl} pageUrl={pageUrl} onNextPage={index === pages.length - 1 ? onNextPage : undefined} />
      ))}
    </Box>
  )
}

export default PaginatedMsgs
</file>

<file path="src/components/safe-messages/SignMsgButton/index.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { Button, Tooltip } from '@mui/material'
import { useContext } from 'react'
import type { SyntheticEvent, ReactElement } from 'react'

import useWallet from '@/hooks/wallets/useWallet'
import Track from '@/components/common/Track'
import { MESSAGE_EVENTS } from '@/services/analytics/events/txList'
import useIsSafeMessageSignableBy from '@/hooks/messages/useIsSafeMessageSignableBy'
import { TxModalContext } from '@/components/tx-flow'
import { SignMessageFlow } from '@/components/tx-flow/flows'
import CheckWallet from '@/components/common/CheckWallet'

const SignMsgButton = ({ msg, compact = false }: { msg: MessageItem; compact?: boolean }): ReactElement => {
  const wallet = useWallet()
  const isSignable = useIsSafeMessageSignableBy(msg, wallet?.address || '')
  const { setTxFlow } = useContext(TxModalContext)

  const onClick = (e: SyntheticEvent) => {
    e.stopPropagation()
    setTxFlow(<SignMessageFlow {...msg} origin={msg.origin || undefined} />)
  }

  return (
    <CheckWallet>
      {(isOk) => (
        <Tooltip title={isOk && !isSignable ? "You've already signed this message" : ''}>
          <span>
            <Track {...MESSAGE_EVENTS.SIGN}>
              <Button
                onClick={onClick}
                variant={isSignable ? 'contained' : 'outlined'}
                disabled={!isOk || !isSignable}
                size={compact ? 'small' : 'stretched'}
                sx={compact ? { py: 0.8 } : undefined}
              >
                Sign
              </Button>
            </Track>
          </span>
        </Tooltip>
      )}
    </CheckWallet>
  )
}

export default SignMsgButton
</file>

<file path="src/components/safe-messages/SingleMsg/index.tsx">
import { useRouter } from 'next/router'
import { TxListGrid } from '@/components/transactions/TxList'
import { TransactionSkeleton } from '@/components/transactions/TxListItem/ExpandableTransactionItem'
import ExpandableMsgItem from '../MsgListItem/ExpandableMsgItem'
import useSafeMessage from '@/hooks/messages/useSafeMessage'
import ErrorMessage from '@/components/tx/ErrorMessage'

const SingleMsg = () => {
  const router = useRouter()
  const { messageHash } = router.query
  const safeMessageHash = Array.isArray(messageHash) ? messageHash[0] : messageHash
  const [safeMessage, , messageError] = useSafeMessage(safeMessageHash)

  if (safeMessage) {
    return (
      <TxListGrid>
        <ExpandableMsgItem msg={safeMessage} expanded />
      </TxListGrid>
    )
  }

  if (messageError) {
    return <ErrorMessage error={messageError}>Failed to load message</ErrorMessage>
  }

  // Loading skeleton
  return <TransactionSkeleton />
}

export default SingleMsg
</file>

<file path="src/components/settings/ClearPendingTxs/index.tsx">
import { usePendingTxIds } from '@/hooks/usePendingTxs'
import { SETTINGS_EVENTS, trackEvent } from '@/services/analytics'
import { useAppDispatch } from '@/store'
import { clearPendingTx } from '@/store/pendingTxsSlice'
import { Stack, Typography, Box, Button, Alert } from '@mui/material'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { useCallback } from 'react'

export const ClearPendingTxs = () => {
  const pendingTxIds = usePendingTxIds()
  const pendingTxCount = pendingTxIds.length
  const dispatch = useAppDispatch()

  const clearPendingTxs = useCallback(() => {
    pendingTxIds.forEach((txId) => {
      dispatch(clearPendingTx({ txId }))
    })
    trackEvent({ ...SETTINGS_EVENTS.DATA.CLEAR_PENDING_TXS, label: pendingTxCount })
  }, [dispatch, pendingTxCount, pendingTxIds])
  return (
    <Stack spacing={2}>
      <Typography>Clear this Safe Account&apos;s pending transactions.</Typography>
      <Alert severity="warning">
        <Typography>
          This action does not delete any transactions but only resets their local state. It does not stop any pending
          transactions from executing. If you want to cancel an execution, you have to do so in your connected wallet.
        </Typography>
      </Alert>
      <Box>
        {pendingTxCount > 0 ? (
          <Button
            variant="text"
            color="error"
            onClick={clearPendingTxs}
            sx={{ backgroundColor: ({ palette }) => palette.error.background }}
          >
            Clear {pendingTxCount} transaction{maybePlural(pendingTxCount)}
          </Button>
        ) : (
          <Typography variant="body2">No pending transactions</Typography>
        )}
      </Box>
    </Stack>
  )
}
</file>

<file path="src/components/settings/ContractVersion/index.tsx">
import { useContext, useMemo } from 'react'
import { SvgIcon, Typography, Alert, AlertTitle, Skeleton, Button } from '@mui/material'
import { ImplementationVersionState } from '@safe-global/safe-gateway-typescript-sdk'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { MasterCopy } from '@/hooks/useMasterCopies'
import { MasterCopyDeployer, useMasterCopies } from '@/hooks/useMasterCopies'
import useSafeInfo from '@/hooks/useSafeInfo'
import CheckCircleIcon from '@mui/icons-material/CheckCircle'
import InfoIcon from '@/public/images/notifications/info.svg'
import { TxModalContext } from '@/components/tx-flow'
import { UpdateSafeFlow } from '@/components/tx-flow/flows'
import ExternalLink from '@/components/common/ExternalLink'
import CheckWallet from '@/components/common/CheckWallet'
import { useCurrentChain } from '@/hooks/useChains'
import { UnsupportedMastercopyWarning } from '@/features/multichain/components/UnsupportedMastercopyWarning/UnsupportedMasterCopyWarning'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

export const ContractVersion = () => {
  const { setTxFlow } = useContext(TxModalContext)
  const [masterCopies] = useMasterCopies()
  const { safe, safeLoaded } = useSafeInfo()
  const currentChain = useCurrentChain()
  const masterCopyAddress = safe.implementation.value

  const safeMasterCopy: MasterCopy | undefined = useMemo(() => {
    return masterCopies?.find((mc) => sameAddress(mc.address, masterCopyAddress))
  }, [masterCopies, masterCopyAddress])

  const needsUpdate = safe.implementationVersionState === ImplementationVersionState.OUTDATED
  const showUpdateDialog = safeMasterCopy?.deployer === MasterCopyDeployer.GNOSIS && needsUpdate
  const isLatestVersion = safe.version && !showUpdateDialog

  const latestSafeVersion = getLatestSafeVersion(currentChain, true)

  return (
    <>
      <Typography variant="h4" fontWeight={700} marginBottom={1}>
        Contract version
      </Typography>

      <Typography variant="body1" fontWeight={400} display="flex" alignItems="center">
        {safeLoaded ? (
          <>
            {safe.version ?? 'Unsupported contract'}
            {isLatestVersion && (
              <>
                <CheckCircleIcon color="primary" sx={{ ml: 1, mr: 0.5 }} /> Latest version
              </>
            )}
          </>
        ) : (
          <Skeleton width="60px" />
        )}
      </Typography>

      {safeLoaded && safe.version && showUpdateDialog ? (
        <Alert
          sx={{ mt: 2, borderRadius: '2px', borderColor: '#B0FFC9' }}
          icon={<SvgIcon component={InfoIcon} inheritViewBox color="secondary" />}
        >
          <AlertTitle sx={{ fontWeight: 700 }}>
            New version is available: {latestSafeVersion} (
            <ExternalLink href={safeMasterCopy?.deployerRepoUrl}>changelog</ExternalLink>)
          </AlertTitle>

          <Typography mb={2}>
            Update now to take advantage of new features and the highest security standards available. You will need to
            confirm this update just like any other transaction.
          </Typography>

          <CheckWallet>
            {(isOk) => (
              <Button onClick={() => setTxFlow(<UpdateSafeFlow />)} variant="contained" disabled={!isOk}>
                Update
              </Button>
            )}
          </CheckWallet>
        </Alert>
      ) : (
        <UnsupportedMastercopyWarning />
      )}
    </>
  )
}
</file>

<file path="src/components/settings/DataManagement/FileListCard.tsx">
import { Box, Card, CardContent, CardHeader, List, ListItem, ListItemIcon, ListItemText, SvgIcon } from '@mui/material'
import type { ListItemTextProps } from '@mui/material'
import type { CardHeaderProps } from '@mui/material'
import type { ReactElement } from 'react'
import FileIcon from '@/public/images/settings/data/file.svg'

import useChains from '@/hooks/useChains'
import { ImportErrors } from '@/components/settings/DataManagement/useGlobalImportFileParser'
import type { AddedSafesState } from '@/store/addedSafesSlice'
import type { AddressBookState } from '@/store/addressBookSlice'
import type { SafeAppsState } from '@/store/safeAppsSlice'
import type { SettingsState } from '@/store/settingsSlice'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'

import css from './styles.module.css'
import type { VisitedSafesState } from '@/store/visitedSafesSlice'
import type { UndeployedSafesState } from '@safe-global/utils/features/counterfactual/store/types'

const getItemSecondaryText = (
  chains: ChainInfo[],
  data: AddedSafesState | AddressBookState = {},
  singular: string,
  plural: string,
): ReactElement => {
  return (
    <List sx={{ p: 0 }}>
      {Object.keys(data).map((chainId) => {
        const count = Object.keys(data[chainId] ?? {}).length

        if (count === 0) {
          return null
        }

        const chain = chains.find((chain) => chain.chainId === chainId)

        return (
          <ListItem key={chainId} sx={{ p: 0, m: 0.5 }}>
            <Box
              className={css.networkIcon}
              sx={{ backgroundColor: chain?.theme.backgroundColor ?? '#D9D9D9' }}
              component="span"
            />
            {chain?.chainName}: {count} {count === 1 ? singular : plural}
          </ListItem>
        )
      })}
    </List>
  )
}

type Data = {
  addedSafes?: AddedSafesState
  addressBook?: AddressBookState
  settings?: SettingsState
  safeApps?: SafeAppsState
  undeployedSafes?: UndeployedSafesState
  visitedSafes?: VisitedSafesState
  error?: string
}

type ListProps = Data & {
  showPreview?: boolean
}

type ItemProps = ListProps & { chains: ChainInfo[] }

const getItems = ({
  addedSafes,
  addressBook,
  settings,
  safeApps,
  undeployedSafes,
  visitedSafes,
  error,
  chains,
  showPreview = false,
}: ItemProps): Array<ListItemTextProps> => {
  if (error) {
    return [{ primary: <>{error}</> }]
  }

  const addedSafeChainAmount = Object.keys(addedSafes || {}).length
  const addressBookChainAmount = Object.keys(addressBook || {}).length
  const undeployedSafesCount = Object.values(undeployedSafes || {}).flatMap((items) => Object.keys(items)).length

  const items: Array<ListItemTextProps> = []

  if (addedSafeChainAmount > 0) {
    const addedSafesPreview: ListItemTextProps = {
      primary: (
        <>
          <b>Added Safe Accounts</b> on {addedSafeChainAmount} {addedSafeChainAmount === 1 ? 'chain' : 'chains'}
        </>
      ),
      secondary: showPreview ? getItemSecondaryText(chains, addedSafes, 'Safe', 'Safes') : undefined,
    }

    items.push(addedSafesPreview)
  }

  if (addressBookChainAmount > 0) {
    const addressBookPreview: ListItemTextProps = {
      primary: (
        <>
          <b>Address book</b> for {addressBookChainAmount} {addressBookChainAmount === 1 ? 'chain' : 'chains'}
        </>
      ),
      secondary: showPreview ? getItemSecondaryText(chains, addressBook, 'contact', 'contacts') : undefined,
    }

    items.push(addressBookPreview)
  }

  if (settings) {
    const settingsPreview: ListItemTextProps = {
      primary: (
        <>
          <b>Settings</b> (appearance, currency, hidden tokens and custom environment variables)
        </>
      ),
    }

    items.push(settingsPreview)
  }

  if (visitedSafes) {
    const visitedSafesPreview: ListItemTextProps = {
      primary: (
        <>
          <b>Visited Safe Accounts history</b>
        </>
      ),
    }

    items.push(visitedSafesPreview)
  }

  const hasBookmarkedSafeApps = Object.values(safeApps || {}).some((chainId) => chainId.pinned?.length > 0)
  if (hasBookmarkedSafeApps) {
    const safeAppsPreview: ListItemTextProps = {
      primary: (
        <>
          Bookmarked <b>Safe Apps</b>
        </>
      ),
    }

    items.push(safeAppsPreview)
  }

  if (undeployedSafes) {
    const undeployedSafesPreview: ListItemTextProps = {
      primary: (
        <>
          <b>Not activated Safe Accounts</b> {undeployedSafesCount}
        </>
      ),
    }

    items.push(undeployedSafesPreview)
  }

  if (items.length === 0) {
    return [{ primary: <>{ImportErrors.NO_IMPORT_DATA_FOUND}</> }]
  }

  return items
}

type Props = ListProps & CardHeaderProps

export const FileListCard = ({
  addedSafes,
  addressBook,
  settings,
  safeApps,
  undeployedSafes,
  visitedSafes,
  error,
  showPreview = false,
  ...cardHeaderProps
}: Props): ReactElement => {
  const chains = useChains()
  const items = getItems({
    addedSafes,
    addressBook,
    settings,
    safeApps,
    visitedSafes,
    undeployedSafes,
    error,
    chains: chains.configs,
    showPreview,
  })

  return (
    <Card className={css.card}>
      <CardHeader {...cardHeaderProps} className={css.header} />
      <CardContent className={css.content}>
        <List sx={{ p: 0 }}>
          {items.map((item, i) => (
            <ListItem key={i} sx={{ p: 0 }}>
              <ListItemIcon className={css.listIcon}>
                <SvgIcon component={FileIcon} inheritViewBox fontSize="small" sx={{ fill: 'none' }} />
              </ListItemIcon>
              <ListItemText
                {...item}
                // <ul> cannot appear as a descendant of <p>
                secondaryTypographyProps={{ component: 'div' }}
              />
            </ListItem>
          ))}
        </List>
      </CardContent>
    </Card>
  )
}
</file>

<file path="src/components/settings/DataManagement/ImportDialog.tsx">
import { undeployedSafesSlice } from '@/features/counterfactual/store/undeployedSafesSlice'
import { DialogContent, Alert, AlertTitle, DialogActions, Button, Box, SvgIcon } from '@mui/material'
import type { ReactElement, Dispatch, SetStateAction } from 'react'

import ModalDialog from '@/components/common/ModalDialog'
import { useAppDispatch } from '@/store'
import { trackEvent, SETTINGS_EVENTS, OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { addedSafesSlice } from '@/store/addedSafesSlice'
import { addressBookSlice } from '@/store/addressBookSlice'
import { safeAppsSlice } from '@/store/safeAppsSlice'
import { settingsSlice } from '@/store/settingsSlice'
import { FileListCard } from '@/components/settings/DataManagement/FileListCard'
import { useGlobalImportJsonParser } from '@/components/settings/DataManagement/useGlobalImportFileParser'
import FileIcon from '@/public/images/settings/data/file.svg'
import { ImportFileUpload } from '@/components/settings/DataManagement/ImportFileUpload'
import { showNotification } from '@/store/notificationsSlice'
import { visitedSafesSlice } from '@/store/visitedSafesSlice'

import css from './styles.module.css'

export const ImportDialog = ({
  onClose,
  fileName = '',
  setFileName,
  jsonData = '',
  setJsonData,
}: {
  onClose?: () => void
  fileName: string | undefined
  setFileName: Dispatch<SetStateAction<string | undefined>>
  jsonData: string | undefined
  setJsonData: Dispatch<SetStateAction<string | undefined>>
}): ReactElement => {
  const dispatch = useAppDispatch()
  const { addedSafes, addressBook, addressBookEntriesCount, settings, safeApps, undeployedSafes, visitedSafes, error } =
    useGlobalImportJsonParser(jsonData)

  const isDisabled =
    (!addedSafes && !addressBook && !settings && !safeApps && !undeployedSafes && !visitedSafes) || !!error

  const handleClose = () => {
    setFileName(undefined)
    setJsonData(undefined)
    onClose?.()
  }

  const handleImport = () => {
    if (addressBook) {
      dispatch(addressBookSlice.actions.setAddressBook(addressBook))
      trackEvent({
        ...SETTINGS_EVENTS.DATA.IMPORT_ADDRESS_BOOK,
        label: addressBookEntriesCount,
      })
    }
    if (addedSafes) {
      dispatch(addedSafesSlice.actions.setAddedSafes(addedSafes))
      trackEvent({
        ...OVERVIEW_EVENTS.IMPORT_DATA,
        label: OVERVIEW_LABELS.settings,
      })
    }

    if (settings) {
      dispatch(settingsSlice.actions.setSettings(settings))
      trackEvent(SETTINGS_EVENTS.DATA.IMPORT_SETTINGS)
    }

    if (safeApps) {
      dispatch(safeAppsSlice.actions.setSafeApps(safeApps))
      trackEvent(SETTINGS_EVENTS.DATA.IMPORT_SAFE_APPS)
    }

    if (undeployedSafes) {
      dispatch(undeployedSafesSlice.actions.addUndeployedSafes(undeployedSafes))
      trackEvent(SETTINGS_EVENTS.DATA.IMPORT_UNDEPLOYED_SAFES)
    }

    if (visitedSafes) {
      dispatch(visitedSafesSlice.actions.setVisitedSafes(visitedSafes))
      trackEvent(SETTINGS_EVENTS.DATA.IMPORT_VISITED_SAFES)
    }

    dispatch(
      showNotification({
        variant: 'success',
        groupKey: 'global-import-success',
        message: 'Successfully imported data',
      }),
    )

    handleClose()
  }

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Data import" hideChainIndicator>
      <DialogContent>
        {!jsonData || !fileName ? (
          <Box mt={2}>
            <ImportFileUpload setFileName={setFileName} setJsonData={setJsonData} />
          </Box>
        ) : (
          <>
            <FileListCard
              avatar={
                <Box sx={{ borderRadius: ({ shape }) => `${shape.borderRadius}px` }}>
                  <SvgIcon
                    component={FileIcon}
                    inheritViewBox
                    fontSize="small"
                    sx={{ fill: 'none', display: 'block' }}
                  />
                </Box>
              }
              title={<b>{fileName}</b>}
              className={css.header}
              addedSafes={addedSafes}
              addressBook={addressBook}
              settings={settings}
              safeApps={safeApps}
              visitedSafes={visitedSafes}
              undeployedSafes={undeployedSafes}
              error={error}
              showPreview
            />
            {!isDisabled && (
              <Alert severity="warning">
                <AlertTitle sx={{ fontWeight: 700 }}>Overwrite your current data?</AlertTitle>
                This action will overwrite your currently added Safe Accounts, address book and settings with those from
                the imported file.
              </Alert>
            )}
          </>
        )}
      </DialogContent>
      <DialogActions>
        <Button data-testid="dialog-cancel-btn" onClick={handleClose}>
          Cancel
        </Button>
        <Button
          data-testid="dialog-import-btn"
          onClick={handleImport}
          variant="contained"
          disableElevation
          disabled={isDisabled}
        >
          Import
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}
</file>

<file path="src/components/settings/DataManagement/ImportFileUpload.tsx">
import { useDropzone } from 'react-dropzone'
import { Typography, SvgIcon } from '@mui/material'
import { useCallback } from 'react'
import type { Dispatch, SetStateAction } from 'react'

import FileUpload, { FileTypes } from '@/components/common/FileUpload'
import InfoIcon from '@/public/images/notifications/info.svg'
import { BRAND_NAME } from '@/config/constants'

const AcceptedMimeTypes = {
  'application/json': ['.json'],
}

export const ImportFileUpload = ({
  setFileName,
  setJsonData,
}: {
  setFileName: Dispatch<SetStateAction<string | undefined>>
  setJsonData: Dispatch<SetStateAction<string | undefined>>
}) => {
  const onDrop = useCallback(
    (acceptedFiles: File[]) => {
      if (acceptedFiles.length === 0) {
        return
      }
      const file = acceptedFiles[0]
      const reader = new FileReader()
      reader.onload = (event) => {
        if (!event.target) {
          return
        }
        if (typeof event.target.result !== 'string') {
          return
        }
        setFileName(file.name)
        setJsonData(event.target.result)
      }
      reader.readAsText(file)
    },
    [setFileName, setJsonData],
  )

  const { getRootProps, getInputProps, isDragActive, isDragReject } = useDropzone({
    maxFiles: 1,
    onDrop,
    accept: AcceptedMimeTypes,
  })

  const onRemove = () => {
    setFileName(undefined)
    setJsonData(undefined)
  }

  return (
    <>
      <Typography>Import {BRAND_NAME} data by uploading a file in the area below.</Typography>

      <FileUpload
        fileType={FileTypes.JSON}
        getRootProps={() => ({ ...getRootProps(), height: '228px' })}
        getInputProps={getInputProps}
        isDragActive={isDragActive}
        isDragReject={isDragReject}
        onRemove={onRemove}
      />

      <Typography>
        <SvgIcon
          component={InfoIcon}
          inheritViewBox
          fontSize="small"
          color="border"
          sx={{
            verticalAlign: 'middle',
            mr: 0.5,
          }}
        />
        Only JSON files exported from the {BRAND_NAME} can be imported.
      </Typography>
    </>
  )
}
</file>

<file path="src/components/settings/DataManagement/index.tsx">
import { useEffect, useState } from 'react'
import { Paper, Grid, Typography, Button, SvgIcon, Box } from '@mui/material'

import FileIcon from '@/public/images/settings/data/file.svg'
import ExportIcon from '@/public/images/common/export.svg'
import { getPersistedState, useAppSelector } from '@/store'
import { addressBookSlice, selectAllAddressBooks } from '@/store/addressBookSlice'
import { addedSafesSlice, selectAllAddedSafes } from '@/store/addedSafesSlice'
import { safeAppsSlice, selectSafeApps } from '@/store/safeAppsSlice'
import { selectSettings, settingsSlice } from '@/store/settingsSlice'
import { selectUndeployedSafes, undeployedSafesSlice } from '@/features/counterfactual/store/undeployedSafesSlice'
import { ImportFileUpload } from '@/components/settings/DataManagement/ImportFileUpload'
import { ImportDialog } from '@/components/settings/DataManagement/ImportDialog'
import { SAFE_EXPORT_VERSION } from '@/components/settings/DataManagement/useGlobalImportFileParser'
import { FileListCard } from '@/components/settings/DataManagement/FileListCard'
import { selectAllVisitedSafes, visitedSafesSlice } from '@/store/visitedSafesSlice'

import css from './styles.module.css'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { ClearPendingTxs } from '../ClearPendingTxs'

const getExportFileName = () => {
  const today = new Date().toISOString().slice(0, 10)
  return `safe-${today}.json`
}

export const exportAppData = () => {
  // Extract the slices we want to export
  const {
    [addressBookSlice.name]: addressBook,
    [addedSafesSlice.name]: addedSafes,
    [settingsSlice.name]: setting,
    [safeAppsSlice.name]: safeApps,
    [undeployedSafesSlice.name]: undeployedSafes,
    [visitedSafesSlice.name]: visitedSafes,
  } = getPersistedState()

  // Ensure they are under the same name as the slice
  const exportData = {
    [addressBookSlice.name]: addressBook,
    [addedSafesSlice.name]: addedSafes,
    [settingsSlice.name]: setting,
    [safeAppsSlice.name]: safeApps,
    [undeployedSafesSlice.name]: undeployedSafes,
    [visitedSafesSlice.name]: visitedSafes,
  }

  const data = JSON.stringify({ version: SAFE_EXPORT_VERSION.V3, data: exportData })

  const blob = new Blob([data], { type: 'text/json' })
  const link = document.createElement('a')

  link.download = getExportFileName()
  link.href = window.URL.createObjectURL(blob)
  link.dataset.downloadurl = ['text/json', link.download, link.href].join(':')
  link.dispatchEvent(new MouseEvent('click'))
}

const DataManagement = () => {
  const [exportFileName, setExportFileName] = useState('')
  const [importFileName, setImportFileName] = useState<string>()
  const [jsonData, setJsonData] = useState<string>()

  const addedSafes = useAppSelector(selectAllAddedSafes)
  const addressBook = useAppSelector(selectAllAddressBooks)
  const settings = useAppSelector(selectSettings)
  const visitedSafes = useAppSelector(selectAllVisitedSafes)
  const safeApps = useAppSelector(selectSafeApps)
  const undeployedSafes = useAppSelector(selectUndeployedSafes)

  useEffect(() => {
    // Prevent hydration errors
    setExportFileName(getExportFileName())
  }, [])

  return (
    <>
      <Paper sx={{ p: 4, mb: 2 }}>
        <Grid container spacing={3}>
          <Grid item sm={4} xs={12}>
            <Typography variant="h4" fontWeight={700}>
              Data export
            </Typography>
          </Grid>

          <Grid data-testid="export-file-section" item container xs>
            <Typography>Download your local data with your added Safe Accounts, address book and settings.</Typography>

            <FileListCard
              avatar={
                <Box className={css.fileIcon} sx={{ borderRadius: ({ shape }) => `${shape.borderRadius}px` }}>
                  <SvgIcon component={FileIcon} inheritViewBox fontSize="small" sx={{ fill: 'none' }} />
                </Box>
              }
              title={<b>{exportFileName}</b>}
              action={
                <Track {...OVERVIEW_EVENTS.EXPORT_DATA} label={OVERVIEW_LABELS.settings}>
                  <Button variant="contained" className={css.exportIcon} onClick={exportAppData}>
                    <SvgIcon component={ExportIcon} inheritViewBox fontSize="small" />
                  </Button>
                </Track>
              }
              addedSafes={addedSafes}
              addressBook={addressBook}
              settings={settings}
              visitedSafes={visitedSafes}
              safeApps={safeApps}
              undeployedSafes={undeployedSafes}
            />
          </Grid>
        </Grid>
      </Paper>

      <Paper sx={{ p: 4, mb: 2 }}>
        <Grid container spacing={3}>
          <Grid item sm={4} xs={12}>
            <Typography variant="h4" fontWeight={700}>
              Data import
            </Typography>
          </Grid>

          <Grid item xs>
            <ImportFileUpload setFileName={setImportFileName} setJsonData={setJsonData} />
          </Grid>

          {jsonData && (
            <ImportDialog
              jsonData={jsonData}
              fileName={importFileName}
              setJsonData={setJsonData}
              setFileName={setImportFileName}
            />
          )}
        </Grid>
      </Paper>

      <Paper sx={{ p: 4 }}>
        <Grid container spacing={3}>
          <Grid item sm={4} xs={12}>
            <Typography variant="h4" fontWeight={700}>
              Pending transactions
            </Typography>
          </Grid>

          <Grid data-testid="clear-pending-tx-section" item container xs>
            <ClearPendingTxs />
          </Grid>
        </Grid>
      </Paper>
    </>
  )
}

export default DataManagement
</file>

<file path="src/components/settings/DataManagement/styles.module.css">
.card {
  width: 100%;
  border: 1px solid var(--color-border-light);
  margin: var(--space-2) 0;
}

.fileIcon {
  display: flex;
  align-items: center;
  padding: var(--space-1);
  border: 1px solid var(--color-text-primary);
}

.exportIcon {
  min-width: unset;
  padding: var(--space-1);
}

.header {
  border-bottom: 1px solid var(--color-border-light);
}

.header :global .MuiCardHeader-avatar {
  margin-right: var(--space-2);
}

.header :global .MuiCardHeader-action {
  align-self: center;
  margin: 0;
}

.content {
  padding: var(--space-3);
}

.listIcon {
  min-width: unset;
  margin-right: var(--space-3);
  padding-top: var(--space-1);
  align-self: flex-start;
}

.networkIcon {
  width: 10px;
  height: 10px;
  border-radius: 2px;
  margin-right: calc(var(--space-1) / 2);
}
</file>

<file path="src/components/settings/DataManagement/useGlobalImportFileParser.ts">
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { migrateAddedSafes } from '@/services/ls-migration/addedSafes'
import { migrateAddressBook } from '@/services/ls-migration/addressBook'
import { isChecksummedAddress } from '@safe-global/utils/utils/addresses'
import type { AddressBook, AddressBookState } from '@/store/addressBookSlice'
import type { AddedSafesState } from '@/store/addedSafesSlice'
import type { SafeAppsState } from '@/store/safeAppsSlice'
import type { SettingsState } from '@/store/settingsSlice'

import { useMemo } from 'react'
import type { VisitedSafesState } from '@/store/visitedSafesSlice'
import type { UndeployedSafesState } from '@safe-global/utils/features/counterfactual/store/types'

export const enum SAFE_EXPORT_VERSION {
  V1 = '1.0',
  V2 = '2.0',
  V3 = '3.0',
}

export enum ImportErrors {
  INVALID_VERSION = 'The file is not a valid export.',
  INVALID_JSON_FORMAT = 'The JSON format is invalid.',
  NO_IMPORT_DATA_FOUND = 'This file contains no importable data.',
}

const countEntries = (data: { [chainId: string]: { [address: string]: unknown } }) =>
  Object.values(data).reduce<number>((count, entry) => count + Object.keys(entry).length, 0)

export const _filterValidAbEntries = (ab?: AddressBookState): AddressBookState | undefined => {
  if (!ab) {
    return undefined
  }

  return Object.entries(ab).reduce<AddressBookState>((acc, [chainId, chainAb]) => {
    const sanitizedChainAb = Object.entries(chainAb).reduce<AddressBook>((acc, [address, name]) => {
      // Legacy imported address books could have undefined name or address entries
      if (name?.trim() && address && isChecksummedAddress(address)) {
        acc[address] = name
      }
      return acc
    }, {})

    if (Object.keys(sanitizedChainAb).length > 0) {
      acc[chainId] = sanitizedChainAb
    }

    return acc
  }, {})
}

/**
 * The global import currently imports:
 * 1.0:
 *  - address book
 *  - added Safes
 *
 * 2.0:
 *  - address book
 *  - added Safes
 *  - safeApps
 *  - settings
 *
 * 3.0:
 *  - address book
 *  - added Safes
 *  - safeApps
 *  - settings
 *  - visited Safes
 *
 * @param jsonData
 * @returns data to import and some insights about it
 */

type Data = {
  addedSafes?: AddedSafesState
  addressBook?: AddressBookState
  settings?: SettingsState
  safeApps?: SafeAppsState
  undeployedSafes?: UndeployedSafesState
  visitedSafes?: VisitedSafesState
  error?: ImportErrors
  addressBookEntriesCount: number
  addedSafesCount: number
}

export const useGlobalImportJsonParser = (jsonData: string | undefined): Data => {
  return useMemo(() => {
    const data: Data = {
      addressBookEntriesCount: 0,
      addedSafesCount: 0,
      addressBook: undefined,
      addedSafes: undefined,
      settings: undefined,
      safeApps: undefined,
      undeployedSafes: undefined,
      visitedSafes: undefined,
    }

    if (!jsonData) {
      return data
    }

    let parsedFile

    try {
      parsedFile = JSON.parse(jsonData)
    } catch (err) {
      logError(ErrorCodes._704, err)

      data.error = ImportErrors.INVALID_JSON_FORMAT
      return data
    }

    if (!parsedFile.data || Object.keys(parsedFile.data).length === 0) {
      data.error = ImportErrors.NO_IMPORT_DATA_FOUND
      return data
    }

    switch (parsedFile.version) {
      case SAFE_EXPORT_VERSION.V1: {
        data.addressBook = migrateAddressBook(parsedFile.data) ?? undefined
        data.addedSafes = migrateAddedSafes(parsedFile.data) ?? undefined

        break
      }

      case SAFE_EXPORT_VERSION.V2: {
        data.addressBook = _filterValidAbEntries(parsedFile.data.addressBook)
        data.addedSafes = parsedFile.data.addedSafes
        data.settings = parsedFile.data.settings
        data.safeApps = parsedFile.data.safeApps
        data.undeployedSafes = parsedFile.data.undeployedSafes

        break
      }

      case SAFE_EXPORT_VERSION.V3: {
        data.addressBook = _filterValidAbEntries(parsedFile.data.addressBook)
        data.addedSafes = parsedFile.data.addedSafes
        data.settings = parsedFile.data.settings
        data.safeApps = parsedFile.data.safeApps
        data.undeployedSafes = parsedFile.data.undeployedSafes
        data.visitedSafes = parsedFile.data.visitedSafes

        break
      }

      default: {
        data.error = ImportErrors.INVALID_VERSION
      }
    }

    data.addressBookEntriesCount = data.addressBook ? countEntries(data.addressBook) : 0
    data.addedSafesCount = data.addedSafes ? countEntries(data.addedSafes) : 0

    return data
  }, [jsonData])
}
</file>

<file path="src/components/settings/EnvironmentVariables/EnvHintButton/index.tsx">
import Link from 'next/link'
import { useRouter } from 'next/router'
import { SvgIcon, IconButton, Tooltip } from '@mui/material'
import { AppRoutes } from '@/config/routes'
import { useAppSelector } from '@/store'
import { isEnvInitialState } from '@/store/settingsSlice'
import css from './styles.module.css'
import AlertIcon from '@/public/images/common/alert.svg'
import useChainId from '@/hooks/useChainId'

const EnvHintButton = () => {
  const router = useRouter()
  const chainId = useChainId()
  const isInitialState = useAppSelector((state) => isEnvInitialState(state, chainId))

  if (isInitialState) {
    return null
  }

  return (
    <Link href={{ pathname: AppRoutes.settings.environmentVariables, query: router.query }} passHref legacyBehavior>
      <Tooltip title="Default environment has been changed" placement="top" arrow>
        <IconButton
          className={css.button}
          size="small"
          color="warning"
          sx={{ justifySelf: 'flex-end', marginLeft: { sm: '0', md: 'auto' } }}
          disableRipple
        >
          <SvgIcon component={AlertIcon} inheritViewBox fontSize="small" />
        </IconButton>
      </Tooltip>
    </Link>
  )
}

export default EnvHintButton
</file>

<file path="src/components/settings/EnvironmentVariables/EnvHintButton/styles.module.css">
.button {
  border-radius: 4px;
  padding: 6px;
  width: 32px;
  height: 32px;
  background: var(--color-warning-background);
}
</file>

<file path="src/components/settings/EnvironmentVariables/index.tsx">
import { useForm, FormProvider } from 'react-hook-form'
import { Paper, Grid, Typography, TextField, Button, Tooltip, IconButton, SvgIcon } from '@mui/material'
import InputAdornment from '@mui/material/InputAdornment'
import RotateLeftIcon from '@mui/icons-material/RotateLeft'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setRpc, setTenderly } from '@/store/settingsSlice'
import useChainId from '@/hooks/useChainId'
import { useCurrentChain } from '@/hooks/useChains'
import { SETTINGS_EVENTS, trackEvent } from '@/services/analytics'
import InfoIcon from '@/public/images/notifications/info.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { TENDERLY_SIMULATE_ENDPOINT_URL } from '@safe-global/utils/config/constants'

export enum EnvVariablesField {
  rpc = 'rpc',
  tenderlyURL = 'tenderlyURL',
  tenderlyToken = 'tenderlyToken',
}

export type EnvVariablesFormData = {
  [EnvVariablesField.rpc]: string
  [EnvVariablesField.tenderlyURL]: string
  [EnvVariablesField.tenderlyToken]: string
}

const EnvironmentVariables = () => {
  const chainId = useChainId()
  const chain = useCurrentChain()
  const settings = useAppSelector(selectSettings)
  const dispatch = useAppDispatch()

  const formMethods = useForm<EnvVariablesFormData>({
    mode: 'onChange',
    values: {
      [EnvVariablesField.rpc]: settings.env?.rpc[chainId] ?? '',
      [EnvVariablesField.tenderlyURL]: settings.env?.tenderly.url ?? '',
      [EnvVariablesField.tenderlyToken]: settings.env?.tenderly.accessToken ?? '',
    },
  })

  const { register, handleSubmit, setValue, watch } = formMethods

  const rpc = watch(EnvVariablesField.rpc)
  const tenderlyURL = watch(EnvVariablesField.tenderlyURL)
  const tenderlyToken = watch(EnvVariablesField.tenderlyToken)

  const onSubmit = handleSubmit((data) => {
    trackEvent({ ...SETTINGS_EVENTS.ENV_VARIABLES.SAVE })

    dispatch(
      setRpc({
        chainId,
        rpc: data[EnvVariablesField.rpc],
      }),
    )

    dispatch(
      setTenderly({
        url: data[EnvVariablesField.tenderlyURL],
        accessToken: data[EnvVariablesField.tenderlyToken],
      }),
    )

    location.reload()
  })

  const onReset = (name: EnvVariablesField) => {
    setValue(name, '')
  }

  return (
    <Paper sx={{ padding: 4 }}>
      <Grid
        container
        direction="row"
        spacing={3}
        sx={{
          justifyContent: 'space-between',
          mb: 2,
        }}
      >
        <Grid item lg={4} xs={12}>
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
            }}
          >
            Environment variables
          </Typography>
        </Grid>

        <Grid item xs>
          <Typography
            sx={{
              mb: 3,
            }}
          >
            You can override some of our default APIs here in case you need to. Proceed at your own risk.
          </Typography>

          <FormProvider {...formMethods}>
            <form onSubmit={onSubmit}>
              <Typography
                sx={{
                  fontWeight: 700,
                  mb: 2,
                  mt: 3,
                }}
              >
                RPC provider
                <Tooltip
                  placement="top"
                  arrow
                  title="Any provider that implements the Ethereum JSON-RPC standard can be used."
                >
                  <span>
                    <SvgIcon
                      component={InfoIcon}
                      inheritViewBox
                      fontSize="small"
                      color="border"
                      sx={{ verticalAlign: 'middle', ml: 0.5 }}
                    />
                  </span>
                </Tooltip>
              </Typography>

              <TextField
                {...register(EnvVariablesField.rpc)}
                variant="outlined"
                type="url"
                placeholder={chain?.rpcUri.value}
                InputProps={{
                  endAdornment: rpc ? (
                    <InputAdornment position="end">
                      <Tooltip title="Reset to default value">
                        <IconButton onClick={() => onReset(EnvVariablesField.rpc)} size="small" color="primary">
                          <RotateLeftIcon />
                        </IconButton>
                      </Tooltip>
                    </InputAdornment>
                  ) : null,
                }}
                fullWidth
              />

              <Typography
                sx={{
                  fontWeight: 700,
                  mb: 2,
                  mt: 3,
                }}
              >
                Tenderly
                <Tooltip
                  placement="top"
                  arrow
                  title={
                    <>
                      You can use your own Tenderly project to keep track of all your transaction simulations.{' '}
                      <ExternalLink
                        color="secondary"
                        href="https://docs.tenderly.co/simulations-and-forks/simulation-api/configuration-of-api-access"
                      >
                        Read more
                      </ExternalLink>
                    </>
                  }
                >
                  <span>
                    <SvgIcon
                      component={InfoIcon}
                      inheritViewBox
                      fontSize="small"
                      color="border"
                      sx={{ verticalAlign: 'middle', ml: 0.5 }}
                    />
                  </span>
                </Tooltip>
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <TextField
                    {...register(EnvVariablesField.tenderlyURL)}
                    type="url"
                    variant="outlined"
                    label="Tenderly API URL"
                    placeholder={TENDERLY_SIMULATE_ENDPOINT_URL}
                    InputLabelProps={{
                      shrink: true,
                    }}
                    InputProps={{
                      endAdornment: tenderlyURL ? (
                        <InputAdornment position="end">
                          <Tooltip title="Reset to default value">
                            <IconButton
                              onClick={() => onReset(EnvVariablesField.tenderlyURL)}
                              size="small"
                              color="primary"
                            >
                              <RotateLeftIcon />
                            </IconButton>
                          </Tooltip>
                        </InputAdornment>
                      ) : null,
                    }}
                    fullWidth
                  />
                </Grid>

                <Grid item xs={12} md={6}>
                  <TextField
                    {...register(EnvVariablesField.tenderlyToken)}
                    variant="outlined"
                    label="Tenderly access token"
                    InputLabelProps={{
                      shrink: true,
                    }}
                    InputProps={{
                      endAdornment: tenderlyToken ? (
                        <InputAdornment position="end">
                          <Tooltip title="Reset to default value">
                            <IconButton
                              onClick={() => onReset(EnvVariablesField.tenderlyToken)}
                              size="small"
                              color="primary"
                            >
                              <RotateLeftIcon />
                            </IconButton>
                          </Tooltip>
                        </InputAdornment>
                      ) : null,
                    }}
                    fullWidth
                  />
                </Grid>
              </Grid>

              <Button type="submit" variant="contained" color="primary" sx={{ mt: 2 }}>
                Save
              </Button>
            </form>
          </FormProvider>
        </Grid>
      </Grid>
    </Paper>
  )
}

export default EnvironmentVariables
</file>

<file path="src/components/settings/FallbackHandler/index.tsx">
import NextLink from 'next/link'
import { Typography, Box, Grid, Paper, Link } from '@mui/material'
import semverSatisfies from 'semver/functions/satisfies'
import type { ReactElement } from 'react'
import classnames from 'classnames'

import EthHashInfo from '@/components/common/EthHashInfo'
import useSafeInfo from '@/hooks/useSafeInfo'
import { BRAND_NAME, HelpCenterArticle } from '@/config/constants'
import ExternalLink from '@/components/common/ExternalLink'
import { useTxBuilderApp } from '@/hooks/safe-apps/useTxBuilderApp'
import { useCompatibilityFallbackHandlerDeployments } from '@/hooks/useCompatibilityFallbackHandlerDeployments'
import { useIsOfficialFallbackHandler } from '@/hooks/useIsOfficialFallbackHandler'
import { useIsTWAPFallbackHandler } from '@/features/swap/hooks/useIsTWAPFallbackHandler'
import css from '../TransactionGuards/styles.module.css'

const FALLBACK_HANDLER_VERSION = '>=1.1.1'

export const FallbackHandlerWarning = ({
  message,
  txBuilderLinkPrefix = 'It can be altered via the',
}: {
  message: ReactElement | string
  txBuilderLinkPrefix?: string
}) => {
  const txBuilder = useTxBuilderApp()
  return (
    <>
      {message}
      {!!txBuilder && !!txBuilderLinkPrefix && (
        <>
          {` ${txBuilderLinkPrefix} `}
          <NextLink href={txBuilder.link} passHref legacyBehavior>
            <Link>Transaction Builder</Link>
          </NextLink>
          .
        </>
      )}
    </>
  )
}

export const FallbackHandler = (): ReactElement | null => {
  const { safe } = useSafeInfo()
  const fallbackHandlerDeployments = useCompatibilityFallbackHandlerDeployments()
  const isOfficial = useIsOfficialFallbackHandler()
  const isTWAPFallbackHandler = useIsTWAPFallbackHandler()

  const supportsFallbackHandler = !!safe.version && semverSatisfies(safe.version, FALLBACK_HANDLER_VERSION)

  if (!supportsFallbackHandler) {
    return null
  }

  const hasFallbackHandler = !!safe.fallbackHandler

  const warning = !hasFallbackHandler ? (
    <FallbackHandlerWarning
      message={`The ${BRAND_NAME} may not work correctly as no fallback handler is currently set.`}
      txBuilderLinkPrefix="It can be set via the"
    />
  ) : isTWAPFallbackHandler ? (
    <>This is CoW&apos;s fallback handler. It is needed for this Safe to be able to use the TWAP feature for Swaps.</>
  ) : !isOfficial ? (
    <FallbackHandlerWarning
      message={
        <>
          An <b>unofficial</b> fallback handler is currently set.
        </>
      }
    />
  ) : undefined

  return (
    <Paper sx={{ padding: 4 }}>
      <Grid
        container
        direction="row"
        spacing={3}
        sx={{
          justifyContent: 'space-between',
        }}
      >
        <Grid item lg={4} xs={12}>
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
            }}
          >
            Fallback handler
          </Typography>
        </Grid>

        <Grid item xs>
          <Box>
            <Typography>
              The fallback handler adds fallback logic for funtionality that may not be present in the Safe Account
              contract. Learn more about the fallback handler{' '}
              <ExternalLink href={HelpCenterArticle.FALLBACK_HANDLER}>here</ExternalLink>
            </Typography>

            <Box
              className={classnames(css.guardDisplay, {
                [css.warning]: !hasFallbackHandler,
                [css.info]: hasFallbackHandler && !isOfficial,
              })}
              sx={{ display: 'block !important' }}
            >
              {warning && (
                <Typography variant="body2" width="100%" mb={hasFallbackHandler ? 1 : 0}>
                  {warning}
                </Typography>
              )}

              {safe.fallbackHandler && (
                <EthHashInfo
                  shortAddress={false}
                  name={safe.fallbackHandler.name || fallbackHandlerDeployments?.contractName}
                  address={safe.fallbackHandler.value}
                  customAvatar={safe.fallbackHandler.logoUri || undefined}
                  showCopyButton
                  hasExplorer
                />
              )}
            </Box>
          </Box>
        </Grid>
      </Grid>
    </Paper>
  )
}
</file>

<file path="src/components/settings/NestedSafesList/index.tsx">
import { Paper, Grid2, Typography, Button, SvgIcon, Tooltip, IconButton } from '@mui/material'
import { skipToken } from '@reduxjs/toolkit/query'
import { useContext, useMemo, useState } from 'react'
import type { ReactElement } from 'react'

import AddIcon from '@/public/images/common/add.svg'
import EditIcon from '@/public/images/common/edit.svg'
import CheckWallet from '@/components/common/CheckWallet'
import EthHashInfo from '@/components/common/EthHashInfo'
import { CreateNestedSafe } from '@/components/tx-flow/flows/CreateNestedSafe'
import EntryDialog from '@/components/address-book/EntryDialog'
import { TxModalContext } from '@/components/tx-flow'
import EnhancedTable from '@/components/common/EnhancedTable'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useGetOwnedSafesQuery } from '@/store/slices'
import { NESTED_SAFE_EVENTS } from '@/services/analytics/events/nested-safes'
import Track from '@/components/common/Track'
import { useHasFeature } from '@/hooks/useChains'

import tableCss from '@/components/common/EnhancedTable/styles.module.css'
import { FEATURES } from '@safe-global/utils/utils/chains'

export function NestedSafesList(): ReactElement | null {
  const isEnabled = useHasFeature(FEATURES.NESTED_SAFES)
  const { setTxFlow } = useContext(TxModalContext)
  const [addressToRename, setAddressToRename] = useState<string | null>(null)

  const { safe, safeLoaded, safeAddress } = useSafeInfo()
  const { data: nestedSafes } = useGetOwnedSafesQuery(
    isEnabled && safeLoaded ? { chainId: safe.chainId, ownerAddress: safeAddress } : skipToken,
  )

  const rows = useMemo(() => {
    return nestedSafes?.safes.map((nestedSafe) => {
      return {
        cells: {
          owner: {
            rawValue: nestedSafe,
            content: (
              <EthHashInfo address={nestedSafe} showCopyButton shortAddress={false} showName={true} hasExplorer />
            ),
          },
          actions: {
            rawValue: '',
            sticky: true,
            content: (
              <div className={tableCss.actions}>
                <CheckWallet>
                  {(isOk) => (
                    <Track {...NESTED_SAFE_EVENTS.RENAME}>
                      <Tooltip title={isOk ? 'Rename nested Safe' : undefined}>
                        <span>
                          <IconButton onClick={() => setAddressToRename(nestedSafe)} size="small" disabled={!isOk}>
                            <SvgIcon component={EditIcon} inheritViewBox fontSize="small" color="border" />
                          </IconButton>
                        </span>
                      </Tooltip>
                    </Track>
                  )}
                </CheckWallet>
              </div>
            ),
          },
        },
      }
    })
  }, [nestedSafes?.safes])

  if (!isEnabled) {
    return null
  }

  return (
    <>
      <Paper sx={{ padding: 4, mt: 2 }}>
        <Grid2 container direction="row" justifyContent="space-between" spacing={3} mb={2}>
          <Grid2 size={{ lg: 4, xs: 12 }}>
            <Typography variant="h4" fontWeight={700}>
              Nested Safes
            </Typography>
          </Grid2>

          <Grid2 size="grow">
            <Typography mb={3}>
              Nested Safes are separate wallets owned by your main Account, perfect for organizing different funds and
              projects.
            </Typography>

            {nestedSafes?.safes.length === 0 && (
              <Typography mb={3}>
                You don&apos;t have any Nested Safes yet. Set one up now to better organize your assets
              </Typography>
            )}

            {safe.deployed && (
              <CheckWallet>
                {(isOk) => (
                  <Button
                    onClick={() => setTxFlow(<CreateNestedSafe />)}
                    variant="text"
                    startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
                    disabled={!isOk}
                    sx={{ mb: 3 }}
                  >
                    Add nested Safe
                  </Button>
                )}
              </CheckWallet>
            )}

            {rows && rows.length > 0 && <EnhancedTable rows={rows} headCells={[]} />}
          </Grid2>
        </Grid2>
      </Paper>

      {addressToRename && (
        <EntryDialog
          handleClose={() => setAddressToRename(null)}
          defaultValues={{ name: '', address: addressToRename }}
          chainIds={[safe.chainId]}
          disableAddressInput
        />
      )}
    </>
  )
}
</file>

<file path="src/components/settings/owner/EditOwnerDialog/index.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import ModalDialog from '@/components/common/ModalDialog'
import NameInput from '@/components/common/NameInput'
import Track from '@/components/common/Track'
import { SETTINGS_EVENTS } from '@/services/analytics/events/settings'
import { useAppDispatch } from '@/store'
import EditIcon from '@/public/images/common/edit.svg'
import { Box, Button, DialogActions, DialogContent, IconButton, Tooltip, SvgIcon } from '@mui/material'
import { useState } from 'react'
import { FormProvider, useForm } from 'react-hook-form'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'

type EditOwnerValues = {
  name: string
}

export const EditOwnerDialog = ({ chainId, address, name }: { chainId: string; address: string; name?: string }) => {
  const [open, setOpen] = useState(false)

  const dispatch = useAppDispatch()

  const handleClose = () => setOpen(false)

  const onSubmit = (data: EditOwnerValues) => {
    if (data.name !== name) {
      dispatch(
        upsertAddressBookEntries({
          chainIds: [chainId],
          address,
          name: data.name,
        }),
      )
      handleClose()
    }
  }

  const formMethods = useForm<EditOwnerValues>({
    defaultValues: {
      name: name || '',
    },
    mode: 'onChange',
  })

  const { handleSubmit, formState, watch } = formMethods

  const nameValue = watch('name')

  const buttonDisabled = !formState.isValid || nameValue === name || nameValue === ''

  return (
    <>
      <Track {...SETTINGS_EVENTS.SETUP.EDIT_OWNER}>
        <Tooltip title="Edit signer">
          <span>
            <IconButton onClick={() => setOpen(true)} size="small">
              <SvgIcon component={EditIcon} inheritViewBox color="border" fontSize="small" />
            </IconButton>
          </span>
        </Tooltip>
      </Track>

      <ModalDialog open={open} onClose={handleClose} dialogTitle="Edit signer name">
        <FormProvider {...formMethods}>
          <form onSubmit={handleSubmit(onSubmit)}>
            <DialogContent>
              <Box py={2}>
                <NameInput label="Signer name" name="name" required />
              </Box>

              <Box py={2}>
                <EthHashInfo address={address} showCopyButton shortAddress={false} />
              </Box>
            </DialogContent>

            <DialogActions>
              <Button onClick={handleClose}>Cancel</Button>
              <Button type="submit" variant="contained" disabled={buttonDisabled}>
                Save
              </Button>
            </DialogActions>
          </form>
        </FormProvider>
      </ModalDialog>
    </>
  )
}
</file>

<file path="src/components/settings/owner/OwnerList/index.tsx">
import { jsonToCSV } from 'react-papaparse'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import EthHashInfo from '@/components/common/EthHashInfo'
import { AddOwnerFlow, ReplaceOwnerFlow, RemoveOwnerFlow } from '@/components/tx-flow/flows'
import useAddressBook from '@/hooks/useAddressBook'
import useSafeInfo from '@/hooks/useSafeInfo'
import { Box, Grid, Typography, Button, SvgIcon, Tooltip, IconButton } from '@mui/material'
import { useContext, useMemo } from 'react'
import { EditOwnerDialog } from '../EditOwnerDialog'
import EnhancedTable from '@/components/common/EnhancedTable'
import AddIcon from '@/public/images/common/add.svg'
import Track from '@/components/common/Track'
import { SETTINGS_EVENTS } from '@/services/analytics/events/settings'
import CheckWallet from '@/components/common/CheckWallet'
import { TxModalContext } from '@/components/tx-flow'
import ReplaceOwnerIcon from '@/public/images/settings/setup/replace-owner.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import type { AddressBook } from '@/store/addressBookSlice'

import tableCss from '@/components/common/EnhancedTable/styles.module.css'

export const OwnerList = () => {
  const addressBook = useAddressBook()
  const { safe } = useSafeInfo()
  const { setTxFlow } = useContext(TxModalContext)

  const rows = useMemo(() => {
    const showRemoveOwnerButton = safe.owners.length > 1

    return safe.owners.map((owner) => {
      const address = owner.value
      const name = addressBook[address]

      return {
        cells: {
          owner: {
            rawValue: address,
            content: <EthHashInfo address={address} showCopyButton shortAddress={false} showName={true} hasExplorer />,
          },
          actions: {
            rawValue: '',
            sticky: true,
            content: (
              <div className={tableCss.actions}>
                <CheckWallet>
                  {(isOk) => (
                    <Track {...SETTINGS_EVENTS.SETUP.REPLACE_OWNER}>
                      <Tooltip title={isOk ? 'Replace signer' : undefined}>
                        <span>
                          <IconButton
                            onClick={() => setTxFlow(<ReplaceOwnerFlow address={address} />)}
                            size="small"
                            disabled={!isOk}
                          >
                            <SvgIcon component={ReplaceOwnerIcon} inheritViewBox color="border" fontSize="small" />
                          </IconButton>
                        </span>
                      </Tooltip>
                    </Track>
                  )}
                </CheckWallet>

                <EditOwnerDialog address={address} name={name} chainId={safe.chainId} />

                {showRemoveOwnerButton && (
                  <CheckWallet>
                    {(isOk) => (
                      <Track {...SETTINGS_EVENTS.SETUP.REMOVE_OWNER}>
                        <Tooltip title={isOk ? 'Remove signer' : undefined}>
                          <span>
                            <IconButton
                              onClick={() => setTxFlow(<RemoveOwnerFlow name={name} address={address} />)}
                              size="small"
                              disabled={!isOk}
                            >
                              <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
                            </IconButton>
                          </span>
                        </Tooltip>
                      </Track>
                    )}
                  </CheckWallet>
                )}
              </div>
            ),
          },
        },
      }
    })
  }, [safe.owners, safe.chainId, addressBook, setTxFlow])

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
      }}
    >
      <Grid container spacing={3}>
        <Grid data-testid="signer-list" item xs>
          <Typography
            fontWeight="bold"
            sx={{
              mb: 2,
            }}
          >
            Signers
          </Typography>
          <Typography mb={2}>
            Signers have full control over the account, they can propose, sign and execute transactions, as well as
            reject them.
          </Typography>

          <Box
            sx={{
              pt: 2,
              display: 'flex',
              justifyContent: 'space-between',
            }}
          >
            <CheckWallet>
              {(isOk) => (
                <Track {...SETTINGS_EVENTS.SETUP.ADD_OWNER}>
                  <Button
                    data-testid="add-owner-btn"
                    onClick={() => setTxFlow(<AddOwnerFlow />)}
                    variant="text"
                    startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
                    disabled={!isOk}
                    size="compact"
                  >
                    Add signer
                  </Button>
                </Track>
              )}
            </CheckWallet>

            <Button variant="text" onClick={() => exportOwners(safe, addressBook)} size="compact">
              Export as CSV
            </Button>
          </Box>

          <EnhancedTable rows={rows} headCells={[]} />
        </Grid>
      </Grid>
    </Box>
  )
}

function exportOwners(
  { chainId, address, owners }: Pick<SafeState, 'chainId' | 'address' | 'owners'>,
  addressBook: AddressBook,
) {
  const json = owners.map((owner) => {
    const address = owner.value
    const name = addressBook[address] || owner.name
    return [address, name]
  })

  const csv = jsonToCSV(json)
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' })
  const link = document.createElement('a')

  Object.assign(link, {
    download: `${chainId}-${address.value}-signers.csv`,
    href: window.URL.createObjectURL(blob),
  })

  link.click()
}
</file>

<file path="src/components/settings/ProposersList/index.tsx">
import { Chip } from '@/components/common/Chip'
import EnhancedTable from '@/components/common/EnhancedTable'
import tableCss from '@/components/common/EnhancedTable/styles.module.css'
import OnlyOwner from '@/components/common/OnlyOwner'
import Track from '@/components/common/Track'
import UpsertProposer from '@/features/proposers/components/UpsertProposer'
import DeleteProposerDialog from '@/features/proposers/components/DeleteProposerDialog'
import EditProposerDialog from '@/features/proposers/components/EditProposerDialog'
import { useHasFeature } from '@/hooks/useChains'
import useProposers from '@/hooks/useProposers'
import AddIcon from '@/public/images/common/add.svg'
import { SETTINGS_EVENTS } from '@/services/analytics'
import { Box, Button, Grid, Paper, SvgIcon, Typography } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'
import React, { useMemo, useState } from 'react'
import { FEATURES } from '@safe-global/utils/utils/chains'

const headCells = [
  {
    id: 'proposer',
    label: 'Proposer',
  },
  {
    id: 'creator',
    label: 'Creator',
  },
  {
    id: 'Actions',
    label: '',
  },
]

const ProposersList = () => {
  const [isAddDialogOpen, setIsAddDialogOpen] = useState<boolean>()
  const proposers = useProposers()
  const isEnabled = useHasFeature(FEATURES.PROPOSERS)

  const rows = useMemo(() => {
    if (!proposers.data) return []

    return proposers.data.results.map((proposer) => {
      return {
        cells: {
          proposer: {
            rawValue: proposer.delegate,
            content: (
              <EthHashInfo
                address={proposer.delegate}
                showCopyButton
                hasExplorer
                name={proposer.label || undefined}
                shortAddress
              />
            ),
          },

          creator: {
            rawValue: proposer.delegator,
            content: <EthHashInfo address={proposer.delegator} showCopyButton hasExplorer shortAddress />,
          },
          actions: {
            rawValue: '',
            sticky: true,
            content: isEnabled && (
              <div className={tableCss.actions}>
                <EditProposerDialog proposer={proposer} />
                <DeleteProposerDialog proposer={proposer} />
              </div>
            ),
          },
        },
      }
    })
  }, [isEnabled, proposers.data])

  if (!proposers.data?.results) return null

  const onAdd = () => {
    setIsAddDialogOpen(true)
  }

  return (
    <Paper sx={{ mt: 2 }}>
      <Box data-testid="proposer-section" display="flex" flexDirection="column" gap={2}>
        <Grid container spacing={3}>
          <Grid item xs>
            <Typography fontWeight="bold" mb={2}>
              Proposers <Chip label="New" sx={{ backgroundColor: 'secondary.light', color: 'static.main' }} />
            </Typography>
            <Typography mb={2}>
              Proposers can suggest transactions but cannot approve or execute them. Signers should review and approve
              transactions first. <ExternalLink href={HelpCenterArticle.PROPOSERS}>Learn more</ExternalLink>
            </Typography>

            {isEnabled && (
              <Box mb={2}>
                <OnlyOwner>
                  {(isOk) => (
                    <Track {...SETTINGS_EVENTS.PROPOSERS.ADD_PROPOSER}>
                      <Button
                        data-testid="add-proposer-btn"
                        onClick={onAdd}
                        variant="text"
                        startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
                        disabled={!isOk}
                        size="compact"
                      >
                        Add proposer
                      </Button>
                    </Track>
                  )}
                </OnlyOwner>
              </Box>
            )}

            {rows.length > 0 && <EnhancedTable rows={rows} headCells={headCells} />}
          </Grid>

          {isAddDialogOpen && (
            <UpsertProposer onClose={() => setIsAddDialogOpen(false)} onSuccess={() => setIsAddDialogOpen(false)} />
          )}
        </Grid>
      </Box>
    </Paper>
  )
}

export default ProposersList
</file>

<file path="src/components/settings/PushNotifications/hooks/useNotificationPreferences.ts">
import {
  set as setIndexedDb,
  entries as getEntriesFromIndexedDb,
  delMany as deleteManyFromIndexedDb,
  setMany as setManyIndexedDb,
  update as updateIndexedDb,
} from 'idb-keyval'
import { useCallback, useEffect, useMemo } from 'react'

import { WebhookType } from '@/service-workers/firebase-messaging/webhook-types'
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import {
  createPushNotificationPrefsIndexedDb,
  createPushNotificationUuidIndexedDb,
  getPushNotificationPrefsKey,
} from '@/services/push-notifications/preferences'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import type { PushNotificationPreferences, PushNotificationPrefsKey } from '@/services/push-notifications/preferences'
import type { NotifiableSafes } from '../logic'

export const DEFAULT_NOTIFICATION_PREFERENCES: PushNotificationPreferences[PushNotificationPrefsKey]['preferences'] = {
  [WebhookType.EXECUTED_MULTISIG_TRANSACTION]: true,
  [WebhookType.INCOMING_ETHER]: true,
  [WebhookType.INCOMING_TOKEN]: true,
  [WebhookType.MODULE_TRANSACTION]: true,
  [WebhookType.CONFIRMATION_REQUEST]: true, // Requires signature
  [WebhookType.SAFE_CREATED]: false, // We do not preemptively subscribe to Safes before they are created
  // Disabled on the Transaction Service but kept here for completeness
  [WebhookType._PENDING_MULTISIG_TRANSACTION]: true,
  [WebhookType._NEW_CONFIRMATION]: true,
  [WebhookType._OUTGOING_ETHER]: true,
  [WebhookType._OUTGOING_TOKEN]: true,
}

// ExternalStores are used to keep indexedDB state synced across hook instances
const { useStore: useUuid, setStore: setUuid } = new ExternalStore<string>()
const { useStore: usePreferences, setStore: setPreferences } = new ExternalStore<PushNotificationPreferences>()

// Used for testing
export const _setUuid = setUuid
export const _setPreferences = setPreferences

export const useNotificationPreferences = (): {
  uuid: string | undefined
  getAllPreferences: () => PushNotificationPreferences | undefined
  getPreferences: (chainId: string, safeAddress: string) => typeof DEFAULT_NOTIFICATION_PREFERENCES | undefined
  updatePreferences: (
    chainId: string,
    safeAddress: string,
    preferences: PushNotificationPreferences[PushNotificationPrefsKey]['preferences'],
  ) => void
  createPreferences: (safesToRegister: NotifiableSafes) => void
  deletePreferences: (safesToUnregister: NotifiableSafes) => void
  deleteAllChainPreferences: (chainId: string) => void
  _getAllPreferenceEntries: () => Promise<
    [PushNotificationPrefsKey, PushNotificationPreferences[PushNotificationPrefsKey]][]
  >
  _deleteManyPreferenceKeys: (keysToDelete: PushNotificationPrefsKey[]) => void
  getChainPreferences: (chainId: string) => PushNotificationPreferences[PushNotificationPrefsKey][]
} => {
  // State
  const uuid = useUuid()
  const preferences = usePreferences()

  // Getters
  const getPreferences = (chainId: string, safeAddress: string) => {
    const key = getPushNotificationPrefsKey(chainId, safeAddress)
    return preferences?.[key]?.preferences
  }

  const getAllPreferences = useCallback(() => {
    return preferences
  }, [preferences])

  // Get list of preferences for specified chain
  const getChainPreferences = useCallback(
    (chainId: string) => {
      return Object.values(preferences || {}).filter((pref) => chainId === pref.chainId)
    },
    [preferences],
  )

  // idb-keyval stores
  const uuidStore = useMemo(() => {
    if (typeof indexedDB !== 'undefined') {
      return createPushNotificationUuidIndexedDb()
    }
  }, [])

  const preferencesStore = useMemo(() => {
    if (typeof indexedDB !== 'undefined') {
      return createPushNotificationPrefsIndexedDb()
    }
  }, [])

  // UUID state hydrator
  const hydrateUuidStore = useCallback(() => {
    if (!uuidStore) {
      return
    }

    const UUID_KEY = 'uuid'

    let _uuid: string

    updateIndexedDb<string>(
      UUID_KEY,
      (storedUuid) => {
        // Initialise UUID if it doesn't exist
        _uuid = storedUuid || self.crypto.randomUUID()
        return _uuid
      },
      uuidStore,
    )
      .then(() => {
        setUuid(_uuid)
      })
      .catch((e) => {
        logError(ErrorCodes._705, e)
      })
  }, [uuidStore])

  // Hydrate UUID state
  useEffect(() => {
    hydrateUuidStore()
  }, [hydrateUuidStore, uuidStore])

  const _getAllPreferenceEntries = useCallback(() => {
    return getEntriesFromIndexedDb<PushNotificationPrefsKey, PushNotificationPreferences[PushNotificationPrefsKey]>(
      preferencesStore,
    )
  }, [preferencesStore])

  // Preferences state hydrator
  const hydratePreferences = useCallback(() => {
    if (!preferencesStore) {
      return
    }

    _getAllPreferenceEntries()
      .then((preferencesEntries) => {
        setPreferences(Object.fromEntries(preferencesEntries))
      })
      .catch((e) => {
        logError(ErrorCodes._705, e)
      })
  }, [_getAllPreferenceEntries, preferencesStore])

  // Delete array of preferences store keys
  const _deleteManyPreferenceKeys = useCallback(
    (keysToDelete: PushNotificationPrefsKey[]) => {
      deleteManyFromIndexedDb(keysToDelete, preferencesStore)
        .then(hydratePreferences)
        .catch((e) => {
          logError(ErrorCodes._706, e)
        })
    },
    [hydratePreferences, preferencesStore],
  )

  // Hydrate preferences state
  useEffect(() => {
    hydratePreferences()
  }, [hydratePreferences])

  // Add store entry with default preferences for specified Safe(s)
  const createPreferences = (safesToRegister: NotifiableSafes) => {
    if (!preferencesStore) {
      return
    }

    const defaultPreferencesEntries = Object.entries(safesToRegister).flatMap(([chainId, safeAddresses]) => {
      return safeAddresses.map(
        (safeAddress): [PushNotificationPrefsKey, PushNotificationPreferences[PushNotificationPrefsKey]] => {
          const key = getPushNotificationPrefsKey(chainId, safeAddress)

          const defaultPreferences: PushNotificationPreferences[PushNotificationPrefsKey] = {
            chainId,
            safeAddress,
            preferences: DEFAULT_NOTIFICATION_PREFERENCES,
          }

          return [key, defaultPreferences]
        },
      )
    })

    setManyIndexedDb(defaultPreferencesEntries, preferencesStore)
      .then(hydratePreferences)
      .catch((e) => {
        logError(ErrorCodes._706, e)
      })
  }

  // Update preferences for specified Safe
  const updatePreferences = (
    chainId: string,
    safeAddress: string,
    preferences: PushNotificationPreferences[PushNotificationPrefsKey]['preferences'],
  ) => {
    if (!preferencesStore) {
      return
    }

    const key = getPushNotificationPrefsKey(chainId, safeAddress)

    const newPreferences: PushNotificationPreferences[PushNotificationPrefsKey] = {
      safeAddress,
      chainId,
      preferences,
    }

    setIndexedDb(key, newPreferences, preferencesStore)
      .then(hydratePreferences)
      .catch((e) => {
        logError(ErrorCodes._706, e)
      })
  }

  // Delete preferences store entry for specified Safe(s)
  const deletePreferences = (safesToUnregister: NotifiableSafes) => {
    if (!preferencesStore) {
      return
    }

    const keysToDelete = Object.entries(safesToUnregister).flatMap(([chainId, safeAddresses]) => {
      return safeAddresses.map((safeAddress) => getPushNotificationPrefsKey(chainId, safeAddress))
    })

    _deleteManyPreferenceKeys(keysToDelete)
  }

  // Delete all preferences store entries
  const deleteAllChainPreferences = (chainId: string) => {
    if (!preferencesStore) {
      return
    }

    _getAllPreferenceEntries()
      .then((preferencesEntries) => {
        const keysToDelete = preferencesEntries
          .filter(([, prefs]) => {
            return prefs.chainId === chainId
          })
          .map(([key]) => key)

        _deleteManyPreferenceKeys(keysToDelete)
      })
      .catch((e) => {
        logError(ErrorCodes._705, e)
      })
  }

  return {
    uuid,
    getAllPreferences,
    getPreferences,
    updatePreferences,
    createPreferences,
    deletePreferences,
    deleteAllChainPreferences,
    _getAllPreferenceEntries,
    _deleteManyPreferenceKeys,
    getChainPreferences,
  }
}
</file>

<file path="src/components/settings/PushNotifications/hooks/useNotificationRegistrations.ts">
import { registerDevice, unregisterDevice, unregisterSafe } from '@safe-global/safe-gateway-typescript-sdk'
import isEmpty from 'lodash/isEmpty'

import { useAppDispatch } from '@/store'
import { showNotification } from '@/store/notificationsSlice'
import { useNotificationPreferences } from './useNotificationPreferences'
import { trackEvent } from '@/services/analytics'
import { PUSH_NOTIFICATION_EVENTS } from '@/services/analytics/events/push-notifications'
import { getRegisterDevicePayload } from '../logic'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import useWallet from '@/hooks/wallets/useWallet'
import type { NotifiableSafes } from '../logic'
import { NotificationsTokenVersion } from '@/services/push-notifications/preferences'
import { useNotificationsTokenVersion } from './useNotificationsTokenVersion'

const registrationFlow = async (registrationFn: Promise<unknown>, callback: () => void): Promise<boolean> => {
  let success = false

  try {
    const response = await registrationFn

    // Gateway will return 200 with an empty payload if the device was (un-)registered successfully
    // @see https://github.com/safe-global/safe-client-gateway-nest/blob/27b6b3846b4ecbf938cdf5d0595ca464c10e556b/src/routes/notifications/notifications.service.ts#L29
    success = isEmpty(response)
  } catch (e) {
    logError(ErrorCodes._633, e)
  }

  if (success) {
    callback()
  }

  return success
}

export const useNotificationRegistrations = (): {
  registerNotifications: (safesToRegister: NotifiableSafes, withSignature?: boolean) => Promise<boolean | undefined>
  unregisterSafeNotifications: (chainId: string, safeAddress: string) => Promise<boolean | undefined>
  unregisterDeviceNotifications: (chainId: string) => Promise<boolean | undefined>
} => {
  const dispatch = useAppDispatch()
  const wallet = useWallet()

  const { setTokenVersion } = useNotificationsTokenVersion()
  const { uuid, createPreferences, deletePreferences, deleteAllChainPreferences } = useNotificationPreferences()

  const registerNotifications = async (safesToRegister: NotifiableSafes) => {
    if (!uuid || !wallet) {
      return
    }

    const register = async () => {
      const payload = await getRegisterDevicePayload({
        uuid,
        safesToRegister,
        wallet,
      })

      return registerDevice(payload)
    }

    return registrationFlow(register(), () => {
      createPreferences(safesToRegister)

      const totalRegistered = Object.values(safesToRegister).reduce(
        (acc, safeAddresses) => acc + safeAddresses.length,
        0,
      )

      // Set the token version to V2 to indicate that the user has registered their token for the new notification service
      setTokenVersion(NotificationsTokenVersion.V2, safesToRegister)

      trackEvent({
        ...PUSH_NOTIFICATION_EVENTS.REGISTER_SAFES,
        label: totalRegistered,
      })

      dispatch(
        showNotification({
          message: `You will now receive notifications for ${
            totalRegistered > 1 ? 'these Safe Accounts' : 'this Safe Account'
          } in your browser.`,
          variant: 'success',
          groupKey: 'notifications',
        }),
      )
    })
  }

  const unregisterSafeNotifications = async (chainId: string, safeAddress: string) => {
    if (uuid) {
      return registrationFlow(unregisterSafe(chainId, safeAddress, uuid), () => {
        deletePreferences({ [chainId]: [safeAddress] })
        trackEvent(PUSH_NOTIFICATION_EVENTS.UNREGISTER_SAFE)
      })
    }
  }

  const unregisterDeviceNotifications = async (chainId: string) => {
    if (uuid) {
      return registrationFlow(unregisterDevice(chainId, uuid), () => {
        deleteAllChainPreferences(chainId)
        trackEvent(PUSH_NOTIFICATION_EVENTS.UNREGISTER_DEVICE)
      })
    }
  }

  return {
    registerNotifications,
    unregisterSafeNotifications,
    unregisterDeviceNotifications,
  }
}
</file>

<file path="src/components/settings/PushNotifications/hooks/useNotificationsRenewal.ts">
import useSafeInfo from '@/hooks/useSafeInfo'
import { useNotificationPreferences } from './useNotificationPreferences'
import { useNotificationRegistrations } from './useNotificationRegistrations'
import { useCallback, useMemo } from 'react'
import { NotificationsTokenVersion } from '@/services/push-notifications/preferences'
import { useIsNotificationsRenewalEnabled, useNotificationsTokenVersion } from './useNotificationsTokenVersion'
import type { NotifiableSafes } from '../logic'
import { flatten, isEmpty } from 'lodash'
import { useAppDispatch } from '@/store'
import { showNotification } from '@/store/notificationsSlice'
import { RENEWAL_NOTIFICATION_KEY } from '../constants'

/**
 * Hook to manage the renewal of notifications
 * @param shouldShowRenewalNotification a boolean to determine if the renewal notification should be shown
 * @returns an object containing the safes for renewal, the number of chains for renewal, the number of safes for renewal,
 * the renewNotifications function and a boolean indicating if a renewal is needed
 */
export const useNotificationsRenewal = () => {
  const { safe, safeLoaded } = useSafeInfo()
  const { registerNotifications } = useNotificationRegistrations()
  const { getAllPreferences, getChainPreferences } = useNotificationPreferences()
  const { allTokenVersions } = useNotificationsTokenVersion()
  const isNotificationsRenewalEnabled = useIsNotificationsRenewalEnabled()
  const dispatch = useAppDispatch()

  /**
   * Function to check if a renewal is needed for a specific Safe based on the locally stored token version
   * @param chainId the chainId of the Safe
   * @param safeAddress the address of the Safe
   * @returns a boolean indicating if a renewal is needed
   */
  const checkIsRenewalNeeded = useCallback(
    (chainId: string, safeAddress: string) =>
      allTokenVersions?.[chainId]?.[safeAddress] !== NotificationsTokenVersion.V2,
    [allTokenVersions],
  )

  // Safes that need to be renewed based on the locally stored token version. If a Safe is loaded, only the relevant
  // Safes for the corresponding chain are returned. Otherwise, all Safes that need to be renewed are returned.
  const safesForRenewal = useMemo<NotifiableSafes | undefined>(() => {
    if (!isNotificationsRenewalEnabled) {
      // Notifications renewal feature flag is not enabled
      return undefined
    }

    if (safeLoaded) {
      // If the Safe is loaded, only the Safes for the corresponding chain are checked
      const chainPreferences = getChainPreferences(safe.chainId)

      // Determine the Safes that need to be renewed for the loaded Safe's chain
      const safeAddressesForRenewal = chainPreferences
        .map((pref) => pref.safeAddress)
        .filter((address) => checkIsRenewalNeeded(safe.chainId, address))

      if (safeAddressesForRenewal.length === 0) {
        return undefined
      }

      return { [safe.chainId]: safeAddressesForRenewal }
    }

    const allPreferences = getAllPreferences()

    if (!allPreferences) {
      return undefined
    }

    // Determine the Safes that need to be renewed for all chains
    const safesForRenewal = Object.values(allPreferences).reduce<NotifiableSafes>(
      (acc, { chainId, safeAddress }) =>
        checkIsRenewalNeeded(chainId, safeAddress)
          ? { ...acc, [chainId]: [...(acc[chainId] || []), safeAddress] }
          : acc,
      {},
    )

    return isEmpty(safesForRenewal) ? undefined : safesForRenewal
  }, [
    safeLoaded,
    safe.chainId,
    getAllPreferences,
    getChainPreferences,
    checkIsRenewalNeeded,
    isNotificationsRenewalEnabled,
  ])

  // Number of Safes that need to be renewed for notifications
  const numberSafesForRenewal = useMemo(() => {
    return safesForRenewal ? flatten(Object.values(safesForRenewal)).length : 0
  }, [safesForRenewal])

  // Number of chains with Safes that need to be renewed for notifications
  const numberChainsForRenewal = useMemo(() => {
    return safesForRenewal ? Object.values(safesForRenewal).filter((addresses) => addresses.length > 0).length : 0
  }, [safesForRenewal])

  // Boolean indicating if a notifications renewal is needed for any Safe
  const needsRenewal = useMemo(() => {
    if (safeLoaded) {
      return safesForRenewal?.[safe.chainId]?.includes(safe.address.value) || false
    }
    return numberSafesForRenewal > 0
  }, [numberSafesForRenewal, safe.address.value, safe.chainId, safeLoaded, safesForRenewal])

  /**
   * Function to renew the notifications for the Safes that need it
   * @returns a Promise that resolves when the notifications have been renewed
   */
  const renewNotifications = useCallback(async () => {
    if (safesForRenewal) {
      return registerNotifications(safesForRenewal).catch((err) => {
        dispatch(
          showNotification({
            message: 'Failed to renew notifications',
            variant: 'error',
            detailedMessage: err.message,
            groupKey: RENEWAL_NOTIFICATION_KEY,
          }),
        )
      })
    }
  }, [safesForRenewal, dispatch, registerNotifications])

  return { safesForRenewal, numberChainsForRenewal, numberSafesForRenewal, renewNotifications, needsRenewal }
}
</file>

<file path="src/components/settings/PushNotifications/hooks/useNotificationsTokenVersion.ts">
import useSafeInfo from '@/hooks/useSafeInfo'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import type { NotificationsTokenVersion } from '@/services/push-notifications/preferences'
import type { NotifiableSafes } from '../logic'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

export const NOTIFICATIONS_TOKEN_VERSION_KEY = 'notificationsTokenVersion'

type TokenVersionStore = {
  [chainId: string]: {
    [safeAddress: string]: NotificationsTokenVersion | undefined
  }
}

export const useIsNotificationsRenewalEnabled = () => {
  return useHasFeature(FEATURES.RENEW_NOTIFICATIONS_TOKEN)
}

/**
 * Hook to get and update the token versions for the notifications in the local storage.
 * @returns an object with the token version for the current loaded Safe, all token versions stored in the local storage,
 * and a function to update the token version.
 */
export const useNotificationsTokenVersion = () => {
  const isNotificationsRenewalEnabled = useIsNotificationsRenewalEnabled()
  const { safe, safeLoaded } = useSafeInfo()
  const safeAddress = safe.address.value

  // Token versions are stored in local storage
  const [allTokenVersions, setAllTokenVersionsStore] = useLocalStorage<TokenVersionStore>(
    NOTIFICATIONS_TOKEN_VERSION_KEY,
  )

  /**
   * Updates the token version for the specified Safes in the local storage.
   * @param tokenVersion new token version
   * @param safes object with Safes to update the token version. If not provided, the token version will be
   * updated for the current loaded Safe only.
   */
  const setTokenVersion = (
    tokenVersion: NotificationsTokenVersion | undefined,
    safes: NotifiableSafes | undefined = safeLoaded ? { [safe.chainId]: [safeAddress] } : undefined,
  ) => {
    const currentTokenVersionStore = allTokenVersions || {}

    if (!isNotificationsRenewalEnabled) {
      // Notifications renewal is not enabled, nothing to update
      return
    }

    if (!safes) {
      // No Safes provided and no Safe loaded, nothing to update
      return
    }

    // Update the token version for the provided Safes
    const newTokenVersionStore = Object.keys(safes).reduce(
      (acc, chainId) => ({
        ...acc,
        [chainId]: {
          ...(acc[chainId] || {}),
          ...Object.fromEntries(safes[chainId].map((safeAddress) => [safeAddress, tokenVersion])),
        },
      }),
      currentTokenVersionStore,
    )

    setAllTokenVersionsStore(newTokenVersionStore)
  }

  if (!isNotificationsRenewalEnabled) {
    // Notifications renewal is not enabled, no token versions stored
    return { safeTokenVersion: undefined, allTokenVersions: undefined, setTokenVersion }
  }

  if (!allTokenVersions) {
    // No token versions stored
    return { safeTokenVersion: undefined, allTokenVersions, setTokenVersion }
  }

  // Get the stored token version for the current loaded Safe
  const safeTokenVersion = safeLoaded ? allTokenVersions[safe.chainId]?.[safeAddress] : undefined

  return { safeTokenVersion, allTokenVersions, setTokenVersion }
}
</file>

<file path="src/components/settings/PushNotifications/hooks/useNotificationTracking.ts">
import { keys as keysFromIndexedDb, update as updateIndexedDb } from 'idb-keyval'
import { useEffect } from 'react'

import {
  DEFAULT_WEBHOOK_TRACKING,
  createNotificationTrackingIndexedDb,
  parseNotificationTrackingKey,
} from '@/services/push-notifications/tracking'
import { trackEvent } from '@/services/analytics'
import { PUSH_NOTIFICATION_EVENTS } from '@/services/analytics/events/push-notifications'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { logError } from '@/services/exceptions'
import type { NotificationTracking, NotificationTrackingKey } from '@/services/push-notifications/tracking'
import type { WebhookType } from '@/service-workers/firebase-messaging/webhook-types'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

const trackNotificationEvents = (
  chainId: string,
  type: WebhookType,
  notificationCount: NotificationTracking[NotificationTrackingKey],
) => {
  // Shown notifications
  for (let i = 0; i < notificationCount.shown; i++) {
    trackEvent({
      ...PUSH_NOTIFICATION_EVENTS.SHOW_NOTIFICATION,
      label: type,
      chainId,
    })
  }

  // Opened notifications
  for (let i = 0; i < notificationCount.opened; i++) {
    trackEvent({
      ...PUSH_NOTIFICATION_EVENTS.OPEN_NOTIFICATION,
      label: type,
      chainId,
    })
  }
}

const handleTrackCachedNotificationEvents = async (
  trackingStore: ReturnType<typeof createNotificationTrackingIndexedDb>,
) => {
  try {
    // Get all tracked webhook events by chainId, e.g. "1:NEW_CONFIRMATION"
    const trackedNotificationKeys = await keysFromIndexedDb<NotificationTrackingKey>(trackingStore)

    // Get the number of notifications shown/opened and track then clear the cache
    const promises = trackedNotificationKeys.map((key) => {
      return updateIndexedDb<NotificationTracking[NotificationTrackingKey]>(
        key,
        (notificationCount) => {
          if (notificationCount) {
            const { chainId, type } = parseNotificationTrackingKey(key)
            trackNotificationEvents(chainId, type, notificationCount)
          }

          // Return the default cache with 0 shown/opened events
          return DEFAULT_WEBHOOK_TRACKING
        },
        trackingStore,
      )
    })

    await Promise.all(promises)
  } catch (e) {
    logError(ErrorCodes._401, e)
  }
}

export const useNotificationTracking = (): void => {
  const isNotificationFeatureEnabled = useHasFeature(FEATURES.PUSH_NOTIFICATIONS)

  useEffect(() => {
    if (typeof indexedDB !== 'undefined' && isNotificationFeatureEnabled) {
      handleTrackCachedNotificationEvents(createNotificationTrackingIndexedDb())
    }
  }, [isNotificationFeatureEnabled])
}
</file>

<file path="src/components/settings/PushNotifications/hooks/useShowNotificationsRenewalMessage.ts">
import useSafeInfo from '@/hooks/useSafeInfo'
import { selectNotifications, showNotification } from '@/store/notificationsSlice'
import { useEffect, useMemo } from 'react'
import { useNotificationPreferences } from './useNotificationPreferences'
import useWallet from '@/hooks/wallets/useWallet'
import { useAppDispatch, useAppSelector } from '@/store'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import { useIsNotificationsRenewalEnabled, useNotificationsTokenVersion } from './useNotificationsTokenVersion'
import { useNotificationsRenewal } from './useNotificationsRenewal'
import { NotificationsTokenVersion } from '@/services/push-notifications/preferences'
import { RENEWAL_MESSAGE, RENEWAL_NOTIFICATION_KEY } from '../constants'

/**
 * Hook to show a notification to renew the notifications token if needed.
 */
export const useShowNotificationsRenewalMessage = () => {
  const { safe, safeLoaded } = useSafeInfo()
  const { getPreferences } = useNotificationPreferences()
  const preferences = getPreferences(safe.chainId, safe.address.value)
  const wallet = useWallet()
  const dispatch = useAppDispatch()
  const isWrongChain = useIsWrongChain()
  const { safeTokenVersion, setTokenVersion } = useNotificationsTokenVersion()
  const isNotificationsRenewalEnabled = useIsNotificationsRenewalEnabled()
  const notifications = useAppSelector(selectNotifications)
  const { renewNotifications } = useNotificationsRenewal()

  const notificationGroupKey = useMemo(
    () => `${RENEWAL_NOTIFICATION_KEY}-${safe.chainId}-${safe.address.value}`,
    [safe.chainId, safe.address.value],
  )

  // Check if a renewal notification is already present
  const hasNotificationMessage = useMemo(
    () => notifications.some((notification) => notification.groupKey === notificationGroupKey),
    [notifications, notificationGroupKey],
  )

  useEffect(() => {
    if (
      !!wallet &&
      !!preferences &&
      safeLoaded &&
      !isWrongChain &&
      !safeTokenVersion &&
      !hasNotificationMessage &&
      isNotificationsRenewalEnabled
    ) {
      dispatch(
        showNotification({
          message: RENEWAL_MESSAGE,
          variant: 'warning',
          groupKey: notificationGroupKey,
          link: {
            onClick: renewNotifications,
            title: 'Sign',
          },
        }),
      )

      // Set the token version to V1 to avoid showing the notification again
      setTokenVersion(NotificationsTokenVersion.V1)
    }
  }, [
    dispatch,
    renewNotifications,
    preferences,
    safeLoaded,
    notificationGroupKey,
    safeTokenVersion,
    isWrongChain,
    hasNotificationMessage,
    wallet,
    setTokenVersion,
    isNotificationsRenewalEnabled,
  ])
}
</file>

<file path="src/components/settings/PushNotifications/constants.ts">
export const RENEWAL_NOTIFICATION_KEY = 'renewal'
export const RENEWAL_MESSAGE =
  'We’ve upgraded your notification experience! To continue receiving important updates seamlessly, you’ll need to sign this message on every chain you use.'
</file>

<file path="src/components/settings/PushNotifications/GlobalPushNotifications.tsx">
import { selectUndeployedSafes } from '@/features/counterfactual/store/undeployedSafesSlice'
import {
  Box,
  Grid,
  Paper,
  Typography,
  Checkbox,
  Button,
  Divider,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  CircularProgress,
} from '@mui/material'
import mapValues from 'lodash/mapValues'
import difference from 'lodash/difference'
import pickBy from 'lodash/pickBy'
import { Fragment, useEffect, useMemo, useState } from 'react'
import type { ReactElement } from 'react'
import type { AllOwnedSafes } from '@safe-global/safe-gateway-typescript-sdk'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'

import EthHashInfo from '@/components/common/EthHashInfo'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import useChains from '@/hooks/useChains'
import { useAppSelector } from '@/store'
import { useNotificationPreferences } from './hooks/useNotificationPreferences'
import { useNotificationRegistrations } from './hooks/useNotificationRegistrations'
import { trackEvent } from '@/services/analytics'
import { PUSH_NOTIFICATION_EVENTS } from '@/services/analytics/events/push-notifications'
import { requestNotificationPermission } from './logic'
import type { NotifiableSafes } from './logic'
import type { PushNotificationPreferences } from '@/services/push-notifications/preferences'
import CheckWalletWithPermission from '@/components/common/CheckWalletWithPermission'
import { Permission } from '@/permissions/config'

import css from './styles.module.css'
import useAllOwnedSafes from '@/features/myAccounts/hooks/useAllOwnedSafes'
import useWallet from '@/hooks/wallets/useWallet'
import { selectAllAddedSafes, type AddedSafesState } from '@/store/addedSafesSlice'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { useNotificationsRenewal } from './hooks/useNotificationsRenewal'
import type { UndeployedSafesState } from '@safe-global/utils/features/counterfactual/store/types'

// UI logic

export const _filterUndeployedSafes = (safes: NotifiableSafes | undefined, undeployedSafes: UndeployedSafesState) => {
  return pickBy(
    mapValues(safes, (safeAddresses, chainId) => {
      const undeployedAddresses = undeployedSafes[chainId] ? Object.keys(undeployedSafes[chainId]) : []
      return difference(safeAddresses, undeployedAddresses)
    }),
    (safeAddresses) => safeAddresses.length > 0,
  )
}

export const _transformAddedSafes = (addedSafes: AddedSafesState): NotifiableSafes => {
  return Object.entries(addedSafes).reduce<NotifiableSafes>((acc, [chainId, addedSafesOnChain]) => {
    acc[chainId] = Object.keys(addedSafesOnChain)
    return acc
  }, {})
}

// Convert data structure of currently notified Safes
export const _transformCurrentSubscribedSafes = (
  allPreferences?: PushNotificationPreferences,
): NotifiableSafes | undefined => {
  if (!allPreferences) {
    return
  }

  return Object.values(allPreferences).reduce<NotifiableSafes>((acc, { chainId, safeAddress }) => {
    if (!acc[chainId]) {
      acc[chainId] = []
    }

    acc[chainId].push(safeAddress)
    return acc
  }, {})
}

// Remove Safes that are not on a supported chain
export const _sanitizeNotifiableSafes = (
  chains: Array<ChainInfo>,
  notifiableSafes: NotifiableSafes,
): NotifiableSafes => {
  return Object.entries(notifiableSafes).reduce<NotifiableSafes>((acc, [chainId, safeAddresses]) => {
    const chain = chains.find((chain) => chain.chainId === chainId)

    if (chain) {
      acc[chainId] = safeAddresses
    }

    return acc
  }, {})
}

// Merges added Safes, currently notified Safes, and owned safes into a single data structure without duplicates
export const _mergeNotifiableSafes = (
  ownedSafes: AllOwnedSafes | undefined,
  addedSafes: AddedSafesState,
  currentSubscriptions?: NotifiableSafes,
): NotifiableSafes | undefined => {
  const added = _transformAddedSafes(addedSafes)

  const chains = Array.from(
    new Set([
      ...Object.keys(addedSafes || {}),
      ...Object.keys(currentSubscriptions || {}),
      ...Object.keys(ownedSafes || {}),
    ]),
  )

  let notifiableSafes: NotifiableSafes = {}
  for (const chainId of chains) {
    const ownedSafesOnChain = ownedSafes?.[chainId] ?? []
    const addedSafesOnChain = added[chainId]?.filter((addedAddress) => ownedSafesOnChain.includes(addedAddress)) || []
    const currentSubscriptionsOnChain = currentSubscriptions?.[chainId] || []
    // The display order of safes will be subscribed, added & owned, owned
    const uniqueSafeAddresses = Array.from(
      new Set([...currentSubscriptionsOnChain, ...addedSafesOnChain, ...ownedSafesOnChain]),
    )
    notifiableSafes[chainId] = uniqueSafeAddresses
  }

  return notifiableSafes
}

export const _getTotalNotifiableSafes = (notifiableSafes: NotifiableSafes): number => {
  return Object.values(notifiableSafes).reduce((acc, safeAddresses) => {
    return (acc += safeAddresses.length)
  }, 0)
}

export const _areAllSafesSelected = (notifiableSafes: NotifiableSafes, selectedSafes: NotifiableSafes): boolean => {
  const entries = Object.entries(notifiableSafes)

  if (entries.length === 0) {
    return false
  }

  return Object.entries(notifiableSafes).every(([chainId, safeAddresses]) => {
    const hasChain = Object.keys(selectedSafes).includes(chainId)
    const hasEverySafe = safeAddresses?.every((safeAddress) => selectedSafes[chainId]?.includes(safeAddress))
    return hasChain && hasEverySafe
  })
}

// Total number of signatures required to register selected Safes
export const _getTotalSignaturesRequired = (
  selectedSafes: NotifiableSafes,
  currentNotifiedSafes?: NotifiableSafes,
): number => {
  return Object.entries(selectedSafes)
    .filter(([, safeAddresses]) => safeAddresses.length > 0)
    .reduce((acc, [chainId, safeAddresses]) => {
      const isNewChain = !currentNotifiedSafes?.[chainId]
      const isNewSafe = safeAddresses.some((safeAddress) => !currentNotifiedSafes?.[chainId]?.includes(safeAddress))

      if (isNewChain || isNewSafe) {
        acc += 1
      }
      return acc
    }, 0)
}

export const _shouldRegisterSelectedSafes = (
  selectedSafes: NotifiableSafes,
  currentNotifiedSafes?: NotifiableSafes,
): boolean => {
  return Object.entries(selectedSafes).some(([chainId, safeAddresses]) => {
    return safeAddresses.some((safeAddress) => !currentNotifiedSafes?.[chainId]?.includes(safeAddress))
  })
}

export const _shouldUnregsiterSelectedSafes = (
  selectedSafes: NotifiableSafes,
  currentNotifiedSafes?: NotifiableSafes,
) => {
  return Object.entries(currentNotifiedSafes || {}).some(([chainId, safeAddresses]) => {
    return safeAddresses.some((safeAddress) => !selectedSafes[chainId]?.includes(safeAddress))
  })
}

// onSave logic

// Safes that need to be registered with the service
export const _getSafesToRegister = (
  selectedSafes: NotifiableSafes,
  currentNotifiedSafes?: NotifiableSafes,
): NotifiableSafes | undefined => {
  const safesToRegister = Object.entries(selectedSafes).reduce<NotifiableSafes>((acc, [chainId, safeAddresses]) => {
    const safesToRegisterOnChain = safeAddresses.filter(
      (safeAddress) => !currentNotifiedSafes?.[chainId]?.includes(safeAddress),
    )

    if (safesToRegisterOnChain.length > 0) {
      acc[chainId] = safesToRegisterOnChain
    }

    return acc
  }, {})

  const shouldRegister = Object.values(safesToRegister).some((safeAddresses) => safeAddresses.length > 0)

  if (shouldRegister) {
    return safesToRegister
  }
}

// Safes that need to be unregistered with the service
export const _getSafesToUnregister = (
  selectedSafes: NotifiableSafes,
  currentNotifiedSafes?: NotifiableSafes,
): NotifiableSafes | undefined => {
  if (!currentNotifiedSafes) {
    return
  }

  const safesToUnregister = Object.entries(currentNotifiedSafes).reduce<NotifiableSafes>(
    (acc, [chainId, safeAddresses]) => {
      const safesToUnregisterOnChain = safeAddresses.filter(
        (safeAddress) => !selectedSafes[chainId]?.includes(safeAddress),
      )

      if (safesToUnregisterOnChain.length > 0) {
        acc[chainId] = safesToUnregisterOnChain
      }
      return acc
    },
    {},
  )

  const shouldUnregister = Object.values(safesToUnregister).some((safeAddresses) => safeAddresses.length > 0)

  if (shouldUnregister) {
    return safesToUnregister
  }
}

// Whether the device needs to be unregistered from the service
export const _shouldUnregisterDevice = (
  chainId: string,
  safeAddresses: Array<string>,
  currentNotifiedSafes?: NotifiableSafes,
): boolean => {
  if (!currentNotifiedSafes) {
    return false
  }

  if (safeAddresses.length !== currentNotifiedSafes[chainId].length) {
    return false
  }

  return safeAddresses.every((safeAddress) => {
    return currentNotifiedSafes[chainId]?.includes(safeAddress)
  })
}

export const GlobalPushNotifications = (): ReactElement | null => {
  const chains = useChains()
  const undeployedSafes = useAppSelector(selectUndeployedSafes)
  const [isLoading, setIsLoading] = useState(false)
  const { address = '' } = useWallet() || {}
  const [ownedSafes] = useAllOwnedSafes(address)
  const addedSafes = useAppSelector(selectAllAddedSafes)

  const { getAllPreferences } = useNotificationPreferences()
  const { unregisterDeviceNotifications, unregisterSafeNotifications, registerNotifications } =
    useNotificationRegistrations()

  const { safesForRenewal } = useNotificationsRenewal()

  // Safes selected in the UI
  const [selectedSafes, setSelectedSafes] = useState<NotifiableSafes>({})

  // Current Safes registered for notifications in indexedDB
  const currentNotifiedSafes = useMemo(() => {
    const allPreferences = getAllPreferences()
    return _transformCurrentSubscribedSafes(allPreferences)
  }, [getAllPreferences])

  // `currentNotifiedSafes` is initially undefined until indexedDB resolves
  useEffect(() => {
    let isMounted = true

    if (currentNotifiedSafes && isMounted) {
      setSelectedSafes(currentNotifiedSafes)
    }

    return () => {
      isMounted = false
    }
  }, [currentNotifiedSafes])

  // Merged added Safes and `currentNotifiedSafes` (in case subscriptions aren't added)
  const notifiableSafes = useMemo(() => {
    const safes = _mergeNotifiableSafes(ownedSafes, addedSafes, currentNotifiedSafes)
    const deployedSafes = _filterUndeployedSafes(safes, undeployedSafes)
    return _sanitizeNotifiableSafes(chains.configs, deployedSafes)
  }, [ownedSafes, addedSafes, currentNotifiedSafes, undeployedSafes, chains.configs])

  const totalNotifiableSafes = useMemo(() => {
    return _getTotalNotifiableSafes(notifiableSafes)
  }, [notifiableSafes])

  const isAllSelected = useMemo(() => {
    return _areAllSafesSelected(notifiableSafes, selectedSafes)
  }, [notifiableSafes, selectedSafes])

  const onSelectAll = () => {
    setSelectedSafes(() => {
      if (isAllSelected) {
        return []
      }

      return Object.entries(notifiableSafes).reduce((acc, [chainId, safeAddresses]) => {
        return {
          ...acc,
          [chainId]: safeAddresses,
        }
      }, {})
    })
  }

  const totalSignaturesRequired = useMemo(() => {
    return _getTotalSignaturesRequired(selectedSafes, currentNotifiedSafes)
  }, [currentNotifiedSafes, selectedSafes])

  const canSave = useMemo(() => {
    return (
      _shouldRegisterSelectedSafes(selectedSafes, currentNotifiedSafes) ||
      _shouldUnregsiterSelectedSafes(selectedSafes, currentNotifiedSafes)
    )
  }, [selectedSafes, currentNotifiedSafes])

  const onSave = async () => {
    if (!canSave) {
      return
    }

    setIsLoading(true)

    // Although the (un-)registration functions will request permission in getToken we manually
    // check beforehand to prevent multiple promises in registrationPromises from throwing
    const isGranted = await requestNotificationPermission()

    if (!isGranted) {
      setIsLoading(false)
      return
    }

    const registrationPromises: Array<Promise<unknown>> = []

    const newlySelectedSafes = _getSafesToRegister(selectedSafes, currentNotifiedSafes)

    // Merge Safes that need to be registered with the ones for which notifications need to be renewed
    const safesToRegister = _mergeNotifiableSafes(newlySelectedSafes, {}, safesForRenewal)

    if (safesToRegister) {
      registrationPromises.push(registerNotifications(safesToRegister))
    }

    const safesToUnregister = _getSafesToUnregister(selectedSafes, currentNotifiedSafes)
    if (safesToUnregister) {
      const unregistrationPromises = Object.entries(safesToUnregister).flatMap(([chainId, safeAddresses]) => {
        if (_shouldUnregisterDevice(chainId, safeAddresses, currentNotifiedSafes)) {
          return unregisterDeviceNotifications(chainId)
        }
        return safeAddresses.map((safeAddress) => unregisterSafeNotifications(chainId, safeAddress))
      })

      registrationPromises.push(...unregistrationPromises)
    }

    await Promise.all(registrationPromises)

    trackEvent(PUSH_NOTIFICATION_EVENTS.SAVE_SETTINGS)

    setIsLoading(false)
  }

  if (totalNotifiableSafes === 0) {
    return (
      <Typography sx={{ color: ({ palette }) => palette.primary.light }}>
        {address ? 'No owned Safes' : 'No wallet connected'}
      </Typography>
    )
  }

  return (
    <Grid container>
      <Grid item xs={12} display="flex" alignItems="center" justifyContent="space-between" mb={1}>
        <Typography variant="h4" fontWeight={700} display="inline">
          My Safes Accounts ({totalNotifiableSafes})
        </Typography>

        <Box display="flex" alignItems="center">
          {totalSignaturesRequired > 0 && (
            <Typography display="inline" mr={2} textAlign="right">
              We&apos;ll ask you to verify ownership of each Safe Account with your signature per chain{' '}
              {totalSignaturesRequired} time{maybePlural(totalSignaturesRequired)}
            </Typography>
          )}

          <CheckWalletWithPermission permission={Permission.EnablePushNotifications}>
            {(isOk) => (
              <Button variant="contained" disabled={!canSave || !isOk || isLoading} onClick={onSave}>
                {isLoading ? <CircularProgress size={20} /> : 'Save'}
              </Button>
            )}
          </CheckWalletWithPermission>
        </Box>
      </Grid>

      <Grid item xs={12}>
        <Paper sx={{ border: ({ palette }) => `1px solid ${palette.border.light}` }}>
          <List>
            <ListItem disablePadding className={css.item}>
              <ListItemButton onClick={onSelectAll} dense>
                <ListItemIcon className={css.icon}>
                  <Checkbox edge="start" checked={isAllSelected} disableRipple />
                </ListItemIcon>
                <ListItemText primary="Select all" primaryTypographyProps={{ variant: 'h5' }} />
              </ListItemButton>
            </ListItem>
          </List>

          <Divider />

          {Object.entries(notifiableSafes).map(([chainId, safeAddresses], i, arr) => {
            if (safeAddresses.length === 0) return
            const chain = chains.configs?.find((chain) => chain.chainId === chainId)

            const isChainSelected = safeAddresses.every((address) => {
              return selectedSafes[chainId]?.includes(address)
            })

            const onSelectChain = () => {
              setSelectedSafes((prev) => {
                return {
                  ...prev,
                  [chainId]: isChainSelected ? [] : safeAddresses,
                }
              })
            }

            return (
              <Fragment key={chainId}>
                <List>
                  <ListItem disablePadding className={css.item}>
                    <ListItemButton onClick={onSelectChain} dense>
                      <ListItemIcon className={css.icon}>
                        <Checkbox edge="start" checked={isChainSelected} disableRipple />
                      </ListItemIcon>
                      <ListItemText
                        primary={`${chain?.chainName} Safe Accounts`}
                        primaryTypographyProps={{ variant: 'h5' }}
                      />
                    </ListItemButton>
                  </ListItem>

                  <List disablePadding className={css.item}>
                    {safeAddresses.map((safeAddress) => {
                      const isSafeSelected = selectedSafes[chainId]?.includes(safeAddress) ?? false

                      const onSelectSafe = () => {
                        setSelectedSafes((prev) => {
                          return {
                            ...prev,
                            [chainId]: isSafeSelected
                              ? prev[chainId]?.filter((addr) => !sameAddress(addr, safeAddress))
                              : [...(prev[chainId] ?? []), safeAddress],
                          }
                        })
                      }

                      return (
                        <ListItem disablePadding key={safeAddress}>
                          <ListItemButton sx={{ pl: 7, py: 0.5 }} onClick={onSelectSafe} dense>
                            <ListItemIcon className={css.icon}>
                              <Checkbox edge="start" checked={isSafeSelected} disableRipple />
                            </ListItemIcon>
                            <EthHashInfo
                              avatarSize={36}
                              prefix={chain?.shortName}
                              key={safeAddress}
                              address={safeAddress || ''}
                              shortAddress={false}
                              showName={true}
                              chainId={chainId}
                            />
                          </ListItemButton>
                        </ListItem>
                      )
                    })}
                  </List>
                </List>

                {i !== arr.length - 1 ? <Divider /> : null}
              </Fragment>
            )
          })}
        </Paper>
      </Grid>
    </Grid>
  )
}
</file>

<file path="src/components/settings/PushNotifications/index.tsx">
import {
  Grid,
  Paper,
  Typography,
  Checkbox,
  FormControlLabel,
  FormGroup,
  Alert,
  Switch,
  Divider,
  Link as MuiLink,
  useMediaQuery,
  useTheme,
} from '@mui/material'
import Link from 'next/link'
import { useState } from 'react'
import type { ReactElement } from 'react'

import useSafeInfo from '@/hooks/useSafeInfo'
import EthHashInfo from '@/components/common/EthHashInfo'
import { WebhookType } from '@/service-workers/firebase-messaging/webhook-types'
import { useNotificationRegistrations } from './hooks/useNotificationRegistrations'
import { useNotificationPreferences } from './hooks/useNotificationPreferences'
import { GlobalPushNotifications } from './GlobalPushNotifications'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { HelpCenterArticle, IS_DEV } from '@/config/constants'
import { trackEvent } from '@/services/analytics'
import { PUSH_NOTIFICATION_EVENTS } from '@/services/analytics/events/push-notifications'
import { AppRoutes } from '@/config/routes'
import CheckWalletWithPermission from '@/components/common/CheckWalletWithPermission'
import { useIsMac } from '@/hooks/useIsMac'
import ExternalLink from '@/components/common/ExternalLink'
import { Permission } from '@/permissions/config'

import css from './styles.module.css'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import NotificationRenewal from '@/components/notification-center/NotificationRenewal'

export const PushNotifications = (): ReactElement => {
  const { safe, safeLoaded } = useSafeInfo()
  const isOwner = useIsSafeOwner()
  const isMac = useIsMac()
  const [isRegistering, setIsRegistering] = useState(false)
  const [isUpdatingIndexedDb, setIsUpdatingIndexedDb] = useState(false)
  const theme = useTheme()
  const isLargeScreen = useMediaQuery(theme.breakpoints.up('lg'))

  const { updatePreferences, getPreferences, getAllPreferences } = useNotificationPreferences()
  const { unregisterSafeNotifications, unregisterDeviceNotifications, registerNotifications } =
    useNotificationRegistrations()

  const preferences = getPreferences(safe.chainId, safe.address.value)

  const setPreferences = (newPreferences: NonNullable<ReturnType<typeof getPreferences>>) => {
    setIsUpdatingIndexedDb(true)

    updatePreferences(safe.chainId, safe.address.value, newPreferences)

    setIsUpdatingIndexedDb(false)
  }

  const shouldShowMacHelper = isMac || IS_DEV

  const handleOnChange = async () => {
    setIsRegistering(true)

    if (!preferences) {
      await registerNotifications({ [safe.chainId]: [safe.address.value] })
      trackEvent(PUSH_NOTIFICATION_EVENTS.ENABLE_SAFE)
      setIsRegistering(false)
      return
    }

    const allPreferences = getAllPreferences()
    const totalRegisteredSafesOnChain = allPreferences
      ? Object.values(allPreferences).filter(({ chainId }) => chainId === safe.chainId).length
      : 0
    const shouldUnregisterDevice = totalRegisteredSafesOnChain === 1

    if (shouldUnregisterDevice) {
      await unregisterDeviceNotifications(safe.chainId)
    } else {
      await unregisterSafeNotifications(safe.chainId, safe.address.value)
    }

    trackEvent(PUSH_NOTIFICATION_EVENTS.DISABLE_SAFE)
    setIsRegistering(false)
  }

  return (
    <>
      <Paper sx={{ p: 4, mb: 2 }}>
        <Grid container spacing={3}>
          <Grid item sm={4} xs={12}>
            <Typography
              variant="h4"
              sx={{
                fontWeight: 700,
              }}
            >
              Push notifications
            </Typography>
          </Grid>

          <Grid item xs>
            <Grid
              container
              sx={{
                gap: 2.5,
                flexDirection: 'column',
              }}
            >
              <NotificationRenewal />

              <Typography>
                Enable push notifications for {safeLoaded ? 'this Safe Account' : 'your Safe Accounts'} in your browser
                with your signature. You will need to enable them again if you clear your browser cache. Learn more
                about push notifications <ExternalLink href={HelpCenterArticle.PUSH_NOTIFICATIONS}>here</ExternalLink>
              </Typography>

              {shouldShowMacHelper && (
                <Alert severity="info" className={css.macOsInfo}>
                  <Typography
                    variant="body2"
                    sx={{
                      fontWeight: 700,
                      mb: 1,
                    }}
                  >
                    For macOS users
                  </Typography>
                  <Typography variant="body2">
                    Double-check that you have enabled your browser notifications under <b>System Settings</b> &gt;{' '}
                    <b>Notifications</b> &gt; <b>Application Notifications</b> (path may vary depending on OS version).
                  </Typography>
                </Alert>
              )}

              {safeLoaded ? (
                <>
                  <Divider />
                  <NetworkWarning action="change your notification settings" />

                  <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                    <EthHashInfo
                      address={safe.address.value}
                      showCopyButton
                      shortAddress={!isLargeScreen}
                      showName={true}
                      hasExplorer
                    />
                    <CheckWalletWithPermission
                      permission={Permission.EnablePushNotifications}
                      checkNetwork={!isRegistering && safe.deployed}
                    >
                      {(isOk) => (
                        <FormControlLabel
                          data-testid="notifications-switch"
                          control={<Switch checked={!!preferences} onChange={handleOnChange} />}
                          label={preferences ? 'On' : 'Off'}
                          disabled={!isOk || isRegistering || !safe.deployed}
                        />
                      )}
                    </CheckWalletWithPermission>
                  </div>

                  <Paper className={css.globalInfo} variant="outlined">
                    <Typography variant="body2">
                      Want to setup notifications for different or all Safe Accounts? You can do so in your{' '}
                      <Link href={AppRoutes.settings.notifications} passHref legacyBehavior>
                        <MuiLink>global preferences</MuiLink>
                      </Link>
                      .
                    </Typography>
                  </Paper>
                </>
              ) : (
                <GlobalPushNotifications />
              )}
            </Grid>
          </Grid>
        </Grid>
      </Paper>
      {preferences && (
        <Paper sx={{ p: 4 }}>
          <Grid container spacing={3}>
            <Grid item sm={4} xs={12}>
              <Typography
                variant="h4"
                sx={{
                  fontWeight: 700,
                }}
              >
                Notification
              </Typography>
            </Grid>

            <Grid item xs>
              <FormGroup>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={preferences[WebhookType.INCOMING_ETHER] && preferences[WebhookType.INCOMING_TOKEN]}
                      disabled={isUpdatingIndexedDb}
                      onChange={(_, checked) => {
                        setPreferences({
                          ...preferences,
                          [WebhookType.INCOMING_ETHER]: checked,
                          [WebhookType.INCOMING_TOKEN]: checked,
                        })

                        trackEvent({ ...PUSH_NOTIFICATION_EVENTS.TOGGLE_INCOMING_TXS, label: checked })
                      }}
                    />
                  }
                  label="Incoming transactions"
                />

                <FormControlLabel
                  control={
                    <Checkbox
                      checked={
                        preferences[WebhookType.MODULE_TRANSACTION] &&
                        preferences[WebhookType.EXECUTED_MULTISIG_TRANSACTION]
                      }
                      disabled={isUpdatingIndexedDb}
                      onChange={(_, checked) => {
                        setPreferences({
                          ...preferences,
                          [WebhookType.MODULE_TRANSACTION]: checked,
                          [WebhookType.EXECUTED_MULTISIG_TRANSACTION]: checked,
                        })

                        trackEvent({ ...PUSH_NOTIFICATION_EVENTS.TOGGLE_OUTGOING_TXS, label: checked })
                      }}
                    />
                  }
                  label="Outgoing transactions"
                />

                <FormControlLabel
                  control={
                    <Checkbox
                      checked={preferences[WebhookType.CONFIRMATION_REQUEST]}
                      disabled={isUpdatingIndexedDb}
                      onChange={(_, checked) => {
                        const updateConfirmationRequestPreferences = () => {
                          setPreferences({
                            ...preferences,
                            [WebhookType.CONFIRMATION_REQUEST]: checked,
                          })

                          trackEvent({ ...PUSH_NOTIFICATION_EVENTS.TOGGLE_CONFIRMATION_REQUEST, label: checked })
                        }

                        if (checked) {
                          registerNotifications({
                            [safe.chainId]: [safe.address.value],
                          })
                            .then((registered) => {
                              if (registered) {
                                updateConfirmationRequestPreferences()
                              }
                            })
                            .catch(() => null)
                        } else {
                          updateConfirmationRequestPreferences()
                        }
                      }}
                    />
                  }
                  label={
                    <>
                      <Typography>Confirmation requests</Typography>
                      {!preferences[WebhookType.CONFIRMATION_REQUEST] && (
                        <Typography
                          variant="body2"
                          sx={{
                            color: 'text.secondary',
                          }}
                        >
                          {isOwner ? 'Requires your signature' : 'Only signers'}
                        </Typography>
                      )}
                    </>
                  }
                  disabled={!isOwner || !preferences}
                />
              </FormGroup>
            </Grid>
          </Grid>
        </Paper>
      )}
    </>
  )
}
</file>

<file path="src/components/settings/PushNotifications/logic.ts">
import { getBytes, keccak256, toUtf8Bytes, type BrowserProvider } from 'ethers'
import { getToken, getMessaging } from 'firebase/messaging'
import { DeviceType } from '@safe-global/safe-gateway-typescript-sdk'
import type { RegisterNotificationsRequest } from '@safe-global/safe-gateway-typescript-sdk'

import { FIREBASE_VAPID_KEY, initializeFirebaseApp } from '@/services/push-notifications/firebase'
import packageJson from '../../../../package.json'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { checksumAddress } from '@safe-global/utils/utils/addresses'
import { createWeb3 } from '@/hooks/wallets/web3'
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'

type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] }

// We store UUID locally to track device registration
export type NotificationRegistration = WithRequired<RegisterNotificationsRequest, 'uuid'>

export const requestNotificationPermission = async (): Promise<boolean> => {
  if (Notification.permission === 'granted') {
    return true
  }

  let permission: NotificationPermission | undefined

  try {
    permission = await Notification.requestPermission()
  } catch (e) {
    logError(ErrorCodes._400, e)
  }

  return permission === 'granted'
}

const getSafeRegistrationSignature = async ({
  safeAddresses,
  web3,
  timestamp,
  uuid,
  token,
}: {
  safeAddresses: Array<string>
  web3: BrowserProvider
  timestamp: string
  uuid: string
  token: string
}) => {
  const MESSAGE_PREFIX = 'gnosis-safe'

  // Signature must sign `keccack256('gnosis-safe{timestamp-epoch}{uuid}{cloud_messaging_token}{safes_sorted}':
  //   - `{timestamp-epoch}` must be an integer (no milliseconds)
  //   - `{safes_sorted}` must be checksummed safe addresses sorted and joined with no spaces

  // @see https://github.com/safe-global/safe-transaction-service/blob/3644c08ac4b01b6a1c862567bc1d1c81b1a8c21f/safe_transaction_service/notifications/views.py#L19-L24

  const message = MESSAGE_PREFIX + timestamp + uuid + token + safeAddresses.sort().join('')
  const hashedMessage = keccak256(toUtf8Bytes(message))

  const signer = await web3.getSigner()
  return await signer.signMessage(getBytes(hashedMessage))
}

export type NotifiableSafes = { [chainId: string]: Array<string> }

export const getRegisterDevicePayload = async ({
  safesToRegister,
  uuid,
  wallet,
}: {
  safesToRegister: NotifiableSafes
  uuid: string
  wallet: ConnectedWallet
}): Promise<RegisterNotificationsRequest> => {
  const BUILD_NUMBER = '0' // Required value, but does not exist on web
  const BUNDLE = 'safe'

  const [serviceWorkerRegistration] = await navigator.serviceWorker.getRegistrations()

  // Get Firebase token
  const app = initializeFirebaseApp()
  const messaging = getMessaging(app)

  const token = await getToken(messaging, {
    vapidKey: FIREBASE_VAPID_KEY,
    serviceWorkerRegistration,
  })

  const web3 = createWeb3(wallet.provider)

  // If uuid is not provided a new device will be created.
  // If a uuid for an existing Safe is provided the FirebaseDevice will be updated with all the new data provided.
  // Safes provided on the request are always added and never removed/replaced

  // @see https://github.com/safe-global/safe-transaction-service/blob/3644c08ac4b01b6a1c862567bc1d1c81b1a8c21f/safe_transaction_service/notifications/views.py#L19-L24

  const timestamp = Math.floor(new Date().getTime() / 1000).toString()

  let safeRegistrations: RegisterNotificationsRequest['safeRegistrations'] = []

  // We cannot `Promise.all` here as Ledger/Trezor return a "busy" error when signing multiple messages at once
  for await (const [chainId, safeAddresses] of Object.entries(safesToRegister)) {
    const checksummedSafeAddresses = safeAddresses.map((address) => checksumAddress(address))

    // We require a signature for confirmation request notifications
    const signature = await getSafeRegistrationSignature({
      safeAddresses: checksummedSafeAddresses,
      web3,
      uuid,
      timestamp,
      token,
    })

    safeRegistrations.push({
      chainId,
      safes: checksummedSafeAddresses,
      signatures: [signature],
    })
  }

  return {
    uuid,
    cloudMessagingToken: token,
    buildNumber: BUILD_NUMBER,
    bundle: BUNDLE,
    deviceType: DeviceType.WEB,
    version: packageJson.version,
    timestamp,
    safeRegistrations,
  }
}
</file>

<file path="src/components/settings/PushNotifications/styles.module.css">
.macOsInfo {
  border-color: var(--color-info-main);
  background-color: var(--color-background-main);
  padding: var(--space-2);
}

.macOsInfo :global .MuiAlert-icon {
  color: var(--color-text-main);
  padding: 0;
}

.macOsInfo :global .MuiAlert-message {
  padding: 0;
}

.item {
  padding-left: var(--space-1);
}

.icon {
  min-width: 38px;
}

.globalInfo {
  border-radius: 6px;
  border: 1px solid var(--color-secondary-light);
  background-color: var(--color-secondary-background);
  padding: var(--space-2);
}
</file>

<file path="src/components/settings/RequiredConfirmations/index.tsx">
import { Box, Button, Grid, Typography } from '@mui/material'
import Track from '@/components/common/Track'
import { SETTINGS_EVENTS } from '@/services/analytics'
import { ChangeThresholdFlow } from '@/components/tx-flow/flows'
import CheckWallet from '@/components/common/CheckWallet'
import { useContext } from 'react'
import { TxModalContext } from '@/components/tx-flow'
import { maybePlural } from '@safe-global/utils/utils/formatters'

export const RequiredConfirmation = ({ threshold, owners }: { threshold: number; owners: number }) => {
  const { setTxFlow } = useContext(TxModalContext)

  return (
    <Box
      sx={{
        marginTop: 6,
      }}
    >
      <Grid container spacing={3}>
        <Grid item lg={4} xs={12}>
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
            }}
          >
            Required confirmations
          </Typography>
        </Grid>

        <Grid item xs>
          <Typography
            sx={{
              pb: 2,
            }}
          >
            Any transaction requires the confirmation of:
          </Typography>

          <Typography
            component="span"
            sx={{
              pt: 3,
              pr: 2,
            }}
          >
            <b>{threshold}</b> out of <b>{owners}</b> signer{maybePlural(owners)}.
          </Typography>

          {owners > 1 && (
            <CheckWallet>
              {(isOk) => (
                <Track {...SETTINGS_EVENTS.SETUP.CHANGE_THRESHOLD} as="span">
                  <Button
                    onClick={() => setTxFlow(<ChangeThresholdFlow />)}
                    variant="contained"
                    disabled={!isOk}
                    size="small"
                  >
                    Change
                  </Button>
                </Track>
              )}
            </CheckWallet>
          )}
        </Grid>
      </Grid>
    </Box>
  )
}
</file>

<file path="src/components/settings/SafeAppsPermissions/index.tsx">
import { useSafeApps } from '@/hooks/safe-apps/useSafeApps'
import {
  getBrowserPermissionDisplayValues,
  getSafePermissionDisplayValues,
  useBrowserPermissions,
  useSafePermissions,
} from '@/hooks/safe-apps/permissions'
import type { ReactElement } from 'react'
import { useCallback, useMemo } from 'react'
import type { AllowedFeatures } from '@/components/safe-apps/types'
import { PermissionStatus } from '@/components/safe-apps/types'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { Grid, Link, Paper, SvgIcon, Typography } from '@mui/material'
import PermissionsCheckbox from '@/components/safe-apps/PermissionCheckbox'
import DeleteIcon from '@/public/images/common/delete.svg'

const SafeAppsPermissions = (): ReactElement => {
  const { allSafeApps } = useSafeApps()
  const {
    permissions: safePermissions,
    updatePermission: updateSafePermission,
    removePermissions: removeSafePermissions,
    isUserRestricted,
  } = useSafePermissions()
  const {
    permissions: browserPermissions,
    updatePermission: updateBrowserPermission,
    removePermissions: removeBrowserPermissions,
  } = useBrowserPermissions()
  const domains = useMemo(() => {
    const mergedPermissionsSet = new Set(Object.keys(browserPermissions).concat(Object.keys(safePermissions)))

    return Array.from(mergedPermissionsSet)
  }, [safePermissions, browserPermissions])

  const handleSafePermissionsChange = (origin: string, capability: string, checked: boolean) =>
    updateSafePermission(origin, [{ capability, selected: checked }])

  const handleBrowserPermissionsChange = (origin: string, feature: AllowedFeatures, checked: boolean) =>
    updateBrowserPermission(origin, [{ feature, selected: checked }])

  const updateAllPermissions = useCallback(
    (origin: string, selected: boolean) => {
      if (safePermissions[origin]?.length)
        updateSafePermission(
          origin,
          safePermissions[origin].map(({ parentCapability }) => ({ capability: parentCapability, selected })),
        )

      if (browserPermissions[origin]?.length)
        updateBrowserPermission(
          origin,
          browserPermissions[origin].map(({ feature }) => ({ feature, selected })),
        )
    },
    [browserPermissions, safePermissions, updateBrowserPermission, updateSafePermission],
  )

  const handleAllowAll = useCallback(
    (event: React.MouseEvent, origin: string) => {
      event.preventDefault()
      updateAllPermissions(origin, true)
    },
    [updateAllPermissions],
  )

  const handleClearAll = useCallback(
    (event: React.MouseEvent, origin: string) => {
      event.preventDefault()
      updateAllPermissions(origin, false)
    },
    [updateAllPermissions],
  )

  const handleRemoveApp = useCallback(
    (event: React.MouseEvent, origin: string) => {
      event.preventDefault()
      removeSafePermissions(origin)
      removeBrowserPermissions(origin)
    },
    [removeBrowserPermissions, removeSafePermissions],
  )

  const appNames = useMemo(() => {
    const appNames = allSafeApps.reduce((acc: Record<string, string>, app: SafeAppData) => {
      acc[app.url] = app.name
      return acc
    }, {})

    return appNames
  }, [allSafeApps])

  if (!allSafeApps.length) {
    return <div />
  }

  return (
    <Paper sx={{ padding: 4 }}>
      <Typography variant="h4" fontWeight={700}>
        Safe Apps permissions
      </Typography>
      <br />
      {!domains.length && (
        <Typography variant="body1" sx={{ color: ({ palette }) => palette.primary.light }}>
          There are no Safe Apps using permissions.
        </Typography>
      )}
      {domains.map((domain) => (
        <Grid
          item
          key={domain}
          sx={({ palette, shape }) => ({
            border: `1px solid ${palette.border.light}`,
            borderRadius: shape.borderRadius,
            marginBottom: '16px',
          })}
        >
          <Grid
            container
            sx={({ palette }) => ({
              padding: '15px 24px',
              borderBottom: `1px solid ${palette.border.light}`,
            })}
          >
            <Grid
              item
              xs={12}
              sm={5}
              sx={{
                padding: '9px 0',
              }}
            >
              <Typography variant="h5" fontWeight={700}>
                {appNames[domain]}
              </Typography>
              <Typography variant="body2">{domain}</Typography>
            </Grid>
            <Grid container item xs={12} sm={7}>
              {safePermissions[domain]?.map(({ parentCapability, caveats }) => {
                return (
                  <Grid key={parentCapability} item xs={12} sm={6} lg={4} xl={3}>
                    <PermissionsCheckbox
                      name={parentCapability}
                      label={getSafePermissionDisplayValues(parentCapability).displayName}
                      onChange={(_, checked: boolean) => handleSafePermissionsChange(domain, parentCapability, checked)}
                      checked={!isUserRestricted(caveats)}
                    />
                  </Grid>
                )
              })}
              {browserPermissions[domain]?.map(({ feature, status }) => {
                return (
                  <Grid key={feature} item xs={12} sm={6} lg={4} xl={3}>
                    <PermissionsCheckbox
                      name={feature.toString()}
                      label={getBrowserPermissionDisplayValues(feature).displayName}
                      onChange={(_, checked: boolean) => handleBrowserPermissionsChange(domain, feature, checked)}
                      checked={status === PermissionStatus.GRANTED ? true : false}
                    />
                  </Grid>
                )
              })}
            </Grid>
          </Grid>
          <Grid
            container
            item
            justifyContent="flex-end"
            sx={{
              padding: '12px 24px',
            }}
          >
            <Link href="#" onClick={(event) => handleAllowAll(event, domain)} sx={{ textDecoration: 'none' }}>
              Allow all
            </Link>
            <Link
              href="#"
              color="error"
              onClick={(event) => handleClearAll(event, domain)}
              sx={{ textDecoration: 'none' }}
              ml={2}
            >
              Clear all
            </Link>
            <Link href="#" color="error" onClick={(event) => handleRemoveApp(event, domain)} ml={2}>
              <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
            </Link>
          </Grid>
        </Grid>
      ))}
    </Paper>
  )
}

export default SafeAppsPermissions
</file>

<file path="src/components/settings/SafeAppsSigningMethod/index.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import { SETTINGS_EVENTS, trackEvent } from '@/services/analytics'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectOnChainSigning, setOnChainSigning } from '@/store/settingsSlice'
import { FormControlLabel, Checkbox, Paper, Typography, FormGroup, Grid } from '@mui/material'
import { BRAND_NAME, HelpCenterArticle } from '@/config/constants'

export const SafeAppsSigningMethod = () => {
  const onChainSigning = useAppSelector(selectOnChainSigning)

  const dispatch = useAppDispatch()

  const onChange = () => {
    trackEvent(SETTINGS_EVENTS.SAFE_APPS.CHANGE_SIGNING_METHOD)
    dispatch(setOnChainSigning(!onChainSigning))
  }

  return (
    <Paper sx={{ padding: 4, mt: 2 }}>
      <Grid container spacing={3}>
        <Grid item lg={4} xs={12}>
          <Typography variant="h4" fontWeight="bold" mb={1}>
            Signing method
          </Typography>
        </Grid>

        <Grid item xs>
          <Typography mb={2}>
            This setting determines how the {BRAND_NAME} will sign message requests from Safe Apps. Gasless, off-chain
            signing is used by default. Learn more about message signing{' '}
            <ExternalLink href={HelpCenterArticle.SIGNED_MESSAGES}>here</ExternalLink>.
          </Typography>
          <FormGroup>
            <FormControlLabel
              sx={({ palette }) => ({
                flex: 1,
                '.MuiIconButton-root:not(.Mui-checked)': {
                  color: palette.text.disabled,
                },
              })}
              control={<Checkbox checked={onChainSigning} onChange={onChange} name="use-on-chain-signing" />}
              label="Always use on-chain signatures"
            />
          </FormGroup>
        </Grid>
      </Grid>
    </Paper>
  )
}
</file>

<file path="src/components/settings/SafeModules/index.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import useSafeInfo from '@/hooks/useSafeInfo'
import { Paper, Grid, Typography, Box, IconButton, SvgIcon } from '@mui/material'

import ExternalLink from '@/components/common/ExternalLink'
import { RemoveModuleFlow } from '@/components/tx-flow/flows'
import DeleteIcon from '@/public/images/common/delete.svg'
import CheckWallet from '@/components/common/CheckWallet'
import { useContext } from 'react'
import { TxModalContext } from '@/components/tx-flow'
import { selectDelayModifierByAddress } from '@/features/recovery/services/selectors'
import { RemoveRecoveryFlow } from '@/components/tx-flow/flows'
import useRecovery from '@/features/recovery/hooks/useRecovery'

import css from '../TransactionGuards/styles.module.css'

const NoModules = () => {
  return (
    <Typography mt={2} sx={{ color: ({ palette }) => palette.primary.light }}>
      No modules enabled
    </Typography>
  )
}

const ModuleDisplay = ({ moduleAddress, chainId, name }: { moduleAddress: string; chainId: string; name?: string }) => {
  const { setTxFlow } = useContext(TxModalContext)
  const [recovery] = useRecovery()
  const delayModifier = recovery && selectDelayModifierByAddress(recovery, moduleAddress)

  const onRemove = () => {
    if (delayModifier) {
      setTxFlow(<RemoveRecoveryFlow delayModifier={delayModifier} />)
    } else {
      setTxFlow(<RemoveModuleFlow address={moduleAddress} />)
    }
  }

  return (
    <Box className={css.guardDisplay}>
      <EthHashInfo
        name={name}
        shortAddress={false}
        address={moduleAddress}
        showCopyButton
        chainId={chainId}
        hasExplorer
      />
      <CheckWallet>
        {(isOk) => (
          <IconButton
            data-testid="module-remove-btn"
            onClick={onRemove}
            color="error"
            size="small"
            disabled={!isOk}
            title="Remove module"
          >
            <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
          </IconButton>
        )}
      </CheckWallet>
    </Box>
  )
}

const SafeModules = () => {
  const { safe } = useSafeInfo()
  const safeModules = safe.modules || []

  return (
    <Paper sx={{ padding: 4 }}>
      <Grid container direction="row" justifyContent="space-between" spacing={3}>
        <Grid item lg={4} xs={12}>
          <Typography variant="h4" fontWeight={700}>
            Safe modules
          </Typography>
        </Grid>

        <Grid item xs>
          <Box>
            <Typography>
              Modules allow you to customize the access-control logic of your Safe Account. Modules are potentially
              risky, so make sure to only use modules from trusted sources. Learn more about modules{' '}
              <ExternalLink href="https://help.safe.global/en/articles/40827-what-is-a-module">here</ExternalLink>
            </Typography>
            {safeModules.length === 0 ? (
              <NoModules />
            ) : (
              safeModules.map((module) => (
                <ModuleDisplay
                  key={module.value}
                  chainId={safe.chainId}
                  moduleAddress={module.value}
                  name={module.name || undefined}
                />
              ))
            )}
          </Box>
        </Grid>
      </Grid>
    </Paper>
  )
}

export default SafeModules
</file>

<file path="src/components/settings/SecurityLogin/index.tsx">
import { Box } from '@mui/material'
import dynamic from 'next/dynamic'
import { useIsRecoverySupported } from '@/features/recovery/hooks/useIsRecoverySupported'
import SecuritySettings from '../SecuritySettings'
import { useRouter } from 'next/router'

const RecoverySettings = dynamic(() => import('@/features/recovery/components/RecoverySettings'))

const SecurityLogin = () => {
  const isRecoverySupported = useIsRecoverySupported()
  const router = useRouter()

  return (
    <Box display="flex" flexDirection="column" gap={2}>
      {isRecoverySupported && router.query.safe ? <RecoverySettings /> : null}

      <SecuritySettings />
    </Box>
  )
}

export default SecurityLogin
</file>

<file path="src/components/settings/SecuritySettings/index.tsx">
import { useAppDispatch, useAppSelector } from '@/store'
import { selectBlindSigning, setBlindSigning } from '@/store/settingsSlice'
import { Paper, Grid, Typography, FormGroup, FormControlLabel, Checkbox } from '@mui/material'

const SecuritySettings = () => {
  const isBlindSigningEnabled = useAppSelector(selectBlindSigning)
  const dispatch = useAppDispatch()

  return (
    <Paper sx={{ padding: 4 }}>
      <Grid container spacing={3}>
        <Grid item lg={4} xs={12}>
          <Typography variant="h4" fontWeight="bold" mb={1}>
            Security
          </Typography>
        </Grid>

        <Grid item xs>
          <Typography mb={2}>
            Enabling this setting allows the signing of unreadable signature requests. Signing these messages can lead
            to unpredictable consequences, including the potential loss of funds or control over your account.
          </Typography>
          <FormGroup>
            <FormControlLabel
              control={
                <Checkbox
                  checked={isBlindSigningEnabled}
                  onChange={() => dispatch(setBlindSigning(!isBlindSigningEnabled))}
                />
              }
              label="Enable blind signing"
            />
          </FormGroup>
        </Grid>
      </Grid>
    </Paper>
  )
}

export default SecuritySettings
</file>

<file path="src/components/settings/SettingsHeader/index.tsx">
import type { ReactElement } from 'react'

import NavTabs from '@/components/common/NavTabs'
import PageHeader from '@/components/common/PageHeader'
import { generalSettingsNavItems, settingsNavItems } from '@/components/sidebar/SidebarNavigation/config'
import css from '@/components/common/PageHeader/styles.module.css'
import useSafeAddress from '@/hooks/useSafeAddress'
import { useCurrentChain } from '@/hooks/useChains'
import { isRouteEnabled } from '@/utils/chains'
import madProps from '@/utils/mad-props'

export const SettingsHeader = ({
  safeAddress,
  chain,
}: {
  safeAddress: ReturnType<typeof useSafeAddress>
  chain: ReturnType<typeof useCurrentChain>
}): ReactElement => {
  const navItems = safeAddress
    ? settingsNavItems.filter((route) => isRouteEnabled(route.href, chain))
    : generalSettingsNavItems

  return (
    <PageHeader
      title={safeAddress ? 'Settings' : 'Preferences'}
      action={
        <div className={css.navWrapper}>
          <NavTabs tabs={navItems} />
        </div>
      }
    />
  )
}

export default madProps(SettingsHeader, {
  safeAddress: useSafeAddress,
  chain: useCurrentChain,
})
</file>

<file path="src/components/settings/SpendingLimits/index.tsx">
import { useContext } from 'react'
import { Paper, Grid, Typography, Box, Button } from '@mui/material'
import { NoSpendingLimits } from '@/components/settings/SpendingLimits/NoSpendingLimits'
import { SpendingLimitsTable } from '@/components/settings/SpendingLimits/SpendingLimitsTable'
import { useSelector } from 'react-redux'
import { selectSpendingLimits, selectSpendingLimitsLoading } from '@/store/spendingLimitsSlice'
import { useHasFeature } from '@/hooks/useChains'
import { NewSpendingLimitFlow } from '@/components/tx-flow/flows'
import { SETTINGS_EVENTS } from '@/services/analytics'
import CheckWallet from '@/components/common/CheckWallet'
import Track from '@/components/common/Track'
import { TxModalContext } from '@/components/tx-flow'
import { FEATURES } from '@safe-global/utils/utils/chains'

const SpendingLimits = () => {
  const { setTxFlow } = useContext(TxModalContext)
  const spendingLimits = useSelector(selectSpendingLimits)
  const spendingLimitsLoading = useSelector(selectSpendingLimitsLoading)
  const isEnabled = useHasFeature(FEATURES.SPENDING_LIMIT)

  return (
    <Paper data-testid="spending-limit-section" sx={{ padding: 4 }}>
      <Grid
        container
        direction="row"
        spacing={3}
        sx={{
          justifyContent: 'space-between',
        }}
      >
        <Grid item lg={4} xs={12}>
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
            }}
          >
            Spending limits
          </Typography>
        </Grid>

        <Grid item xs>
          {isEnabled ? (
            <Box>
              <Typography>
                You can set rules for specific beneficiaries to access funds from this Safe Account without having to
                collect all signatures.
              </Typography>

              <CheckWallet>
                {(isOk) => (
                  <Track {...SETTINGS_EVENTS.SPENDING_LIMIT.NEW_LIMIT}>
                    <Button
                      data-testid="new-spending-limit"
                      onClick={() => setTxFlow(<NewSpendingLimitFlow />)}
                      sx={{ mt: 2, mb: 2 }}
                      variant="contained"
                      disabled={!isOk}
                      size="small"
                    >
                      New spending limit
                    </Button>
                  </Track>
                )}
              </CheckWallet>

              {!spendingLimits.length && !spendingLimitsLoading && <NoSpendingLimits />}
              {spendingLimits.length > 0 && (
                <SpendingLimitsTable isLoading={spendingLimitsLoading} spendingLimits={spendingLimits} />
              )}
            </Box>
          ) : (
            <Typography>The spending limit feature is not yet available on this chain.</Typography>
          )}
        </Grid>
      </Grid>
    </Paper>
  )
}

export default SpendingLimits
</file>

<file path="src/components/settings/SpendingLimits/NoSpendingLimits.tsx">
import { Grid, Typography } from '@mui/material'

import BeneficiaryIcon from '@/public/images/settings/spending-limit/beneficiary.svg'
import AssetAmountIcon from '@/public/images/settings/spending-limit/asset-amount.svg'
import TimeIcon from '@/public/images/settings/spending-limit/time.svg'

export const NoSpendingLimits = () => {
  return (
    <Grid
      container
      direction="row"
      spacing={2}
      sx={{
        mt: 2,
        justifyContent: 'space-between',
      }}
    >
      <Grid item sm={2}>
        <BeneficiaryIcon data-testid="beneficiary-icon" />
      </Grid>
      <Grid item sm={10}>
        <Typography>
          <b>Select beneficiary</b>
        </Typography>
        <Typography>
          Choose an account that will benefit from this allowance. The beneficiary does not have to be a signer of this
          Safe Account
        </Typography>
      </Grid>
      <Grid item sm={2}>
        <AssetAmountIcon data-testid="asset-icon" />
      </Grid>
      <Grid item sm={10}>
        <Typography>
          <b>Select asset and amount</b>
        </Typography>
        <Typography>You can set allowances for any asset stored in your Safe Account</Typography>
      </Grid>
      <Grid item sm={2}>
        <TimeIcon data-testid="time-icon" />
      </Grid>
      <Grid item sm={10}>
        <Typography>
          <b>Select time</b>
        </Typography>
        <Typography>
          You can choose to set a one-time allowance or to have it automatically refill after a defined time-period
        </Typography>
      </Grid>
    </Grid>
  )
}
</file>

<file path="src/components/settings/SpendingLimits/SpendingLimitsTable.tsx">
import EnhancedTable from '@/components/common/EnhancedTable'
import DeleteIcon from '@/public/images/common/delete.svg'
import { safeFormatUnits } from '@safe-global/utils/utils/formatters'
import { Box, IconButton, Skeleton, SvgIcon, Typography } from '@mui/material'
import { relativeTime } from '@safe-global/utils/utils/date'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useContext, useMemo } from 'react'
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import { RemoveSpendingLimitFlow } from '@/components/tx-flow/flows'
import { TxModalContext } from '@/components/tx-flow'
import Track from '@/components/common/Track'
import { SETTINGS_EVENTS } from '@/services/analytics/events/settings'
import TokenIcon from '@/components/common/TokenIcon'
import SpendingLimitLabel from '@/components/common/SpendingLimitLabel'
import CheckWallet from '@/components/common/CheckWallet'

const SKELETON_ROWS = new Array(3).fill('').map(() => {
  return {
    cells: {
      beneficiary: {
        rawValue: '0x',
        content: (
          <Box display="flex" flexDirection="row" gap={1} alignItems="center">
            <Skeleton variant="circular" width={26} height={26} />
            <div>
              <Typography>
                <Skeleton width={75} />
              </Typography>
              <Typography>
                <Skeleton width={300} />
              </Typography>
            </div>
          </Box>
        ),
      },
      spent: {
        rawValue: '0',
        content: (
          <Box display="flex" flexDirection="row" gap={1} alignItems="center">
            <Skeleton variant="circular" width={26} height={26} />
            <Typography>
              <Skeleton width={100} />
            </Typography>
          </Box>
        ),
      },
      resetTime: {
        rawValue: '0',
        content: (
          <Typography>
            <Skeleton />
          </Typography>
        ),
      },
    },
  }
})

export const SpendingLimitsTable = ({
  spendingLimits,
  isLoading,
}: {
  spendingLimits: SpendingLimitState[]
  isLoading: boolean
}) => {
  const { setTxFlow } = useContext(TxModalContext)

  const headCells = useMemo(
    () => [
      { id: 'beneficiary', label: 'Beneficiary' },
      { id: 'spent', label: 'Spent' },
      { id: 'resetTime', label: 'Reset time' },
      { id: 'actions', label: 'Actions', sticky: true },
    ],
    [],
  )

  const rows = useMemo(
    () =>
      isLoading
        ? SKELETON_ROWS
        : spendingLimits.map((spendingLimit) => {
            const amount = BigInt(spendingLimit.amount)
            const formattedAmount = safeFormatUnits(amount, spendingLimit.token.decimals)

            const spent = BigInt(spendingLimit.spent)
            const formattedSpent = safeFormatUnits(spent, spendingLimit.token.decimals)

            return {
              cells: {
                beneficiary: {
                  rawValue: spendingLimit.beneficiary,
                  content: (
                    <EthHashInfo address={spendingLimit.beneficiary} shortAddress={false} hasExplorer showCopyButton />
                  ),
                },
                spent: {
                  rawValue: spendingLimit.spent,
                  content: (
                    <Box data-testid="spent-amount" display="flex" alignItems="center" gap={1}>
                      <TokenIcon logoUri={spendingLimit.token.logoUri} tokenSymbol={spendingLimit.token.symbol} />
                      {`${formattedSpent} of ${formattedAmount} ${spendingLimit.token.symbol}`}
                    </Box>
                  ),
                },
                resetTime: {
                  rawValue: spendingLimit.resetTimeMin,
                  content: (
                    <SpendingLimitLabel
                      data-testid="reset-time"
                      label={relativeTime(spendingLimit.lastResetMin, spendingLimit.resetTimeMin)}
                      isOneTime={spendingLimit.resetTimeMin === '0'}
                    />
                  ),
                },
                actions: {
                  rawValue: '',
                  sticky: true,
                  content: (
                    <CheckWallet>
                      {(isOk) => (
                        <Track {...SETTINGS_EVENTS.SPENDING_LIMIT.REMOVE_LIMIT}>
                          <IconButton
                            data-testid="delete-btn"
                            onClick={() => setTxFlow(<RemoveSpendingLimitFlow spendingLimit={spendingLimit} />)}
                            color="error"
                            size="small"
                            disabled={!isOk}
                          >
                            <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
                          </IconButton>
                        </Track>
                      )}
                    </CheckWallet>
                  ),
                },
              },
            }
          }),
    [isLoading, setTxFlow, spendingLimits],
  )
  return spendingLimits.length > 0 ? <EnhancedTable rows={rows} headCells={headCells} /> : null
}
</file>

<file path="src/components/settings/TransactionGuards/index.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import useSafeInfo from '@/hooks/useSafeInfo'
import { Paper, Grid, Typography, Box, IconButton, SvgIcon } from '@mui/material'

import css from './styles.module.css'
import ExternalLink from '@/components/common/ExternalLink'
import { SAFE_FEATURES } from '@safe-global/protocol-kit/dist/src/utils/safeVersions'
import { hasSafeFeature } from '@/utils/safe-versions'
import { HelpCenterArticle } from '@/config/constants'
import DeleteIcon from '@/public/images/common/delete.svg'
import CheckWallet from '@/components/common/CheckWallet'
import { useContext } from 'react'
import { TxModalContext } from '@/components/tx-flow'
import { RemoveGuardFlow } from '@/components/tx-flow/flows'

const NoTransactionGuard = () => {
  return (
    <Typography mt={2} sx={{ color: ({ palette }) => palette.primary.light }}>
      No transaction guard set
    </Typography>
  )
}

const GuardDisplay = ({ guardAddress, chainId }: { guardAddress: string; chainId: string }) => {
  const { setTxFlow } = useContext(TxModalContext)

  return (
    <Box className={css.guardDisplay}>
      <EthHashInfo shortAddress={false} address={guardAddress} showCopyButton hasExplorer chainId={chainId} />
      <CheckWallet>
        {(isOk) => (
          <IconButton
            onClick={() => setTxFlow(<RemoveGuardFlow address={guardAddress} />)}
            color="error"
            size="small"
            disabled={!isOk}
          >
            <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
          </IconButton>
        )}
      </CheckWallet>
    </Box>
  )
}

const TransactionGuards = () => {
  const { safe, safeLoaded } = useSafeInfo()

  const isVersionWithGuards = safeLoaded && hasSafeFeature(SAFE_FEATURES.SAFE_TX_GUARDS, safe.version)

  if (!isVersionWithGuards) {
    return null
  }

  return (
    <Paper sx={{ padding: 4 }}>
      <Grid container direction="row" justifyContent="space-between" spacing={3}>
        <Grid item lg={4} xs={12}>
          <Typography variant="h4" fontWeight={700}>
            Transaction guards
          </Typography>
        </Grid>

        <Grid item xs>
          <Box>
            <Typography>
              Transaction guards impose additional constraints that are checked prior to executing a Safe transaction.
              Transaction guards are potentially risky, so make sure to only use transaction guards from trusted
              sources. Learn more about transaction guards{' '}
              <ExternalLink href={HelpCenterArticle.TRANSACTION_GUARD}>here</ExternalLink>.
            </Typography>
            {safe.guard ? (
              <GuardDisplay guardAddress={safe.guard.value} chainId={safe.chainId} />
            ) : (
              <NoTransactionGuard />
            )}
          </Box>
        </Grid>
      </Grid>
    </Paper>
  )
}

export default TransactionGuards
</file>

<file path="src/components/settings/TransactionGuards/styles.module.css">
.guardDisplay {
  background-color: var(--color-secondary-background);
  border: 1px solid var(--color-success-dark);
  padding: 8px;
  border-radius: 4px;
  margin-top: 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.guardDisplay.warning {
  background-color: var(--color-warning-background);
  border-color: var(--color-warning-dark);
}

.guardDisplay.info {
  background-color: var(--color-info-background);
  border-color: var(--color-info-dark);
}
</file>

<file path="src/components/sidebar/DebugToggle/index.tsx">
import { type ChangeEvent, type ReactElement } from 'react'
import { Box, FormControlLabel, Switch } from '@mui/material'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { setDarkMode } from '@/store/settingsSlice'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useAppDispatch } from '@/store'
import { LS_KEY } from '@/config/gateway'

const DebugToggle = (): ReactElement => {
  const dispatch = useAppDispatch()
  const isDarkMode = useDarkMode()

  const [isProdGateway = false, setIsProdGateway] = useLocalStorage<boolean>(LS_KEY)

  const onToggleGateway = (event: ChangeEvent<HTMLInputElement>) => {
    setIsProdGateway(event.target.checked)

    setTimeout(() => {
      location.reload()
    }, 300)
  }

  return (
    <Box py={2} ml={2}>
      <FormControlLabel
        control={<Switch checked={isDarkMode} onChange={(_, checked) => dispatch(setDarkMode(checked))} />}
        label="Dark mode"
      />
      <FormControlLabel control={<Switch checked={isProdGateway} onChange={onToggleGateway} />} label="Use prod CGW" />
    </Box>
  )
}

export default DebugToggle
</file>

<file path="src/components/sidebar/IndexingStatus/index.tsx">
import { Stack, Box, Typography, Tooltip } from '@mui/material'
import { formatDistanceToNow } from 'date-fns'
import { getIndexingStatus } from '@safe-global/safe-gateway-typescript-sdk'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import ExternalLink from '@/components/common/ExternalLink'
import useIntervalCounter from '@/hooks/useIntervalCounter'

const STATUS_PAGE = 'https://status.safe.global'
const MAX_SYNC_DELAY = 1000 * 60 * 5 // 5 minutes
const POLL_INTERVAL = 1000 * 60 // 1 minute

const useIndexingStatus = () => {
  const chainId = useChainId()
  const [count] = useIntervalCounter(POLL_INTERVAL)

  return useAsync(
    () => {
      if (count === undefined) return
      return getIndexingStatus(chainId)
    },
    [chainId, count],
    false,
  )
}

const STATUSES = {
  synced: {
    color: 'success',
    text: 'Synced',
  },
  slow: {
    color: 'warning',
    text: 'Slow network',
  },
  outOfSync: {
    color: 'error',
    text: 'Out of sync',
  },
}

const getStatus = (synced: boolean, lastSync: number) => {
  let status = STATUSES.outOfSync

  if (synced) {
    status = STATUSES.synced
  } else if (Date.now() - lastSync > MAX_SYNC_DELAY) {
    status = STATUSES.slow
  }

  return status
}

const IndexingStatus = () => {
  const [data] = useIndexingStatus()

  if (!data) {
    return null
  }

  const status = getStatus(data.synced, data.lastSync)

  const time = formatDistanceToNow(data.lastSync, { addSuffix: true })

  return (
    <Tooltip title={`Last synced with the blockchain ${time}`} placement="right" arrow>
      <Stack data-testid="index-status" direction="row" spacing={2} alignItems="center" px={3} py={1.5}>
        <Box width={10} height={10} borderRadius="50%" border={`2px solid var(--color-${status.color}-main)`} />

        <ExternalLink href={STATUS_PAGE} noIcon flex={1}>
          <Typography variant="body2">{status.text}</Typography>
        </ExternalLink>

        <ExternalLink href={STATUS_PAGE} sx={{ color: 'text.secondary', transform: 'translateY(3px)' }}>
          {' '}
        </ExternalLink>
      </Stack>
    </Tooltip>
  )
}

export default IndexingStatus
</file>

<file path="src/components/sidebar/NestedSafeInfo/index.tsx">
import { Tooltip, SvgIcon, Typography, List, ListItem, Box, ListItemAvatar, Avatar, ListItemText } from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'
import type { ReactElement } from 'react'

import NestedSafesIcon from '@/public/images/sidebar/nested-safes-icon.svg'
import NestedSafes from '@/public/images/sidebar/nested-safes.svg'
import InfoIcon from '@/public/images/notifications/info.svg'

export function NestedSafeInfo(): ReactElement {
  return (
    <Box display="flex" flexDirection="column" alignItems="center" pt={1}>
      <NestedSafes />
      <Box display="flex" gap={1} py={2}>
        <Typography fontWeight={700}>No Nested Safes yet</Typography>
        <Tooltip
          title="Nested Safes are separate wallets owned by your main Account, perfect for organizing different funds and projects."
          placement="top"
          arrow
          sx={{ ml: 1 }}
        >
          <span>
            <SvgIcon
              component={InfoIcon}
              inheritViewBox
              fontSize="small"
              color="border"
              sx={{ verticalAlign: 'middle' }}
            />
          </span>
        </Tooltip>
      </Box>
      <Box display="flex" gap={2} alignItems="center" pt={1} pb={4}>
        <Avatar sx={{ padding: '20px', backgroundColor: 'success.background' }}>
          <SvgIcon component={NestedSafesIcon} inheritViewBox color="primary" sx={{ fontSize: 20 }} />
        </Avatar>
        <Typography variant="body2" fontWeight={700}>
          Nested Safes allow you to:
        </Typography>
      </Box>
      <List sx={{ p: 0, display: 'flex', flexDirection: 'column', gap: 2 }}>
        {[
          'rebuild your organizational structure onchain',
          'explore new DeFi opportunities without exposing your main Account',
          'deploy specialized modules and extend Safe functionality',
        ].map((item) => {
          return (
            <ListItem key={item} sx={{ p: 0, pl: 1.5, alignItems: 'unset' }}>
              <ListItemAvatar sx={{ minWidth: 'unset', mr: 3 }}>
                <Avatar sx={{ width: 25, height: 25, backgroundColor: 'success.background' }}>
                  <CheckIcon fontSize="small" color="success" />
                </Avatar>
              </ListItemAvatar>
              <ListItemText sx={{ m: 0 }} primaryTypographyProps={{ variant: 'body2' }}>
                {item}
              </ListItemText>
            </ListItem>
          )
        })}
      </List>
    </Box>
  )
}
</file>

<file path="src/components/sidebar/NestedSafesButton/index.tsx">
import { Tooltip, IconButton, SvgIcon, Badge, Typography } from '@mui/material'
import { skipToken } from '@reduxjs/toolkit/query'
import { useState } from 'react'
import type { ReactElement } from 'react'

import NestedSafesIcon from '@/public/images/sidebar/nested-safes-icon.svg'
import { NestedSafesPopover } from '@/components/sidebar/NestedSafesPopover'
import { useGetOwnedSafesQuery } from '@/store/slices'
import { useHasFeature } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'

import headerCss from '@/components/sidebar/SidebarHeader/styles.module.css'
import css from './styles.module.css'
import { FEATURES } from '@safe-global/utils/utils/chains'

export function NestedSafesButton({
  chainId,
  safeAddress,
}: {
  chainId: string
  safeAddress: string
}): ReactElement | null {
  const isEnabled = useHasFeature(FEATURES.NESTED_SAFES)
  const { safe } = useSafeInfo()
  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null)
  const { data } = useGetOwnedSafesQuery(isEnabled && safeAddress ? { chainId, ownerAddress: safeAddress } : skipToken)
  const nestedSafes = data?.safes ?? []

  if (!isEnabled || !safe.deployed) {
    return null
  }

  const onClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget)
  }
  const onClose = () => {
    setAnchorEl(null)
  }

  return (
    <>
      <Tooltip title="Nested Safes" placement="top">
        <Badge invisible={nestedSafes.length > 0} variant="dot" className={css.badge}>
          <IconButton
            className={headerCss.iconButton}
            sx={{
              width: 'auto !important',
              minWidth: '32px !important',
              backgroundColor: anchorEl ? '#f2fecd !important' : undefined,
            }}
            onClick={onClick}
          >
            <SvgIcon component={NestedSafesIcon} inheritViewBox color="primary" fontSize="small" />
            {nestedSafes.length > 0 && (
              <Typography component="span" variant="caption" className={css.count}>
                {nestedSafes.length}
              </Typography>
            )}
          </IconButton>
        </Badge>
      </Tooltip>
      <NestedSafesPopover anchorEl={anchorEl} onClose={onClose} nestedSafes={nestedSafes} />
    </>
  )
}
</file>

<file path="src/components/sidebar/NestedSafesButton/styles.module.css">
.badge :global .MuiBadge-badge {
  border: 1px solid var(--color-background-main);
  border-radius: 50%;
  box-sizing: content-box;
  right: 12px;
  top: 8px;
  background-color: var(--color-secondary-main);
  height: 6px;
  min-width: 6px;
}

.count {
  margin-left: calc(var(--space-1) / 2);
  background-color: var(--color-success-light);
  border-radius: 100%;
  width: 18px;
  height: 18px;
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--color-static-main);
}
</file>

<file path="src/components/sidebar/NestedSafesList/index.tsx">
import Link from 'next/link'
import { ChevronRight } from '@mui/icons-material'
import { List, ListItem, ListItemAvatar, ListItemButton, ListItemText, Typography } from '@mui/material'

import Track from '@/components/common/Track'
import { NESTED_SAFE_EVENTS, NESTED_SAFE_LABELS } from '@/services/analytics/events/nested-safes'
import { useState, type ReactElement } from 'react'
import Identicon from '@/components/common/Identicon'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import useAddressBook from '@/hooks/useAddressBook'
import { trackEvent } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import { useCurrentChain } from '@/hooks/useChains'

const MAX_NESTED_SAFES = 5

export function NestedSafesList({
  onClose,
  nestedSafes,
}: {
  onClose: () => void
  nestedSafes: Array<string>
}): ReactElement {
  const [showAll, setShowAll] = useState(false)
  const nestedSafesToShow = showAll ? nestedSafes : nestedSafes.slice(0, MAX_NESTED_SAFES)

  const onShowAll = () => {
    setShowAll(true)
  }

  return (
    <List sx={{ gap: 1, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
      {nestedSafesToShow.map((nestedSafe) => {
        return <NestedSafeListItem onClose={onClose} nestedSafe={nestedSafe} key={nestedSafe} />
      })}
      {nestedSafes.length > MAX_NESTED_SAFES && !showAll && (
        <Track {...NESTED_SAFE_EVENTS.SHOW_ALL}>
          <Typography
            variant="caption"
            color="text.secondary"
            textTransform="uppercase"
            fontWeight={700}
            sx={{ cursor: 'pointer' }}
            onClick={onShowAll}
          >
            Show all Nested Safes
            <ChevronRight color="border" sx={{ transform: 'rotate(90deg)', ml: 1 }} fontSize="inherit" />
          </Typography>
        </Track>
      )}
    </List>
  )
}

function NestedSafeListItem({ onClose, nestedSafe }: { onClose: () => void; nestedSafe: string }): ReactElement {
  const chain = useCurrentChain()
  const addressBook = useAddressBook()
  const name = addressBook[nestedSafe]

  const onClick = () => {
    // Note: using the Track element breaks accessibility/styles
    trackEvent({ ...NESTED_SAFE_EVENTS.OPEN_NESTED_SAFE, label: NESTED_SAFE_LABELS.list })

    onClose()
  }

  return (
    <ListItem
      sx={{
        border: ({ palette }) => `1px solid ${palette.border.light}`,
        borderRadius: ({ shape }) => `${shape.borderRadius}px`,
        p: 0,
      }}
    >
      <Link
        href={{
          pathname: AppRoutes.home,
          query: {
            safe: `${chain?.shortName}:${nestedSafe}`,
          },
        }}
        passHref
        legacyBehavior
      >
        <ListItemButton sx={{ p: '11px 12px' }} onClick={onClick}>
          <ListItemAvatar sx={{ minWidth: 'unset', pr: 1 }}>
            <Identicon address={nestedSafe} size={32} />
          </ListItemAvatar>
          <ListItemText
            primary={name}
            primaryTypographyProps={{
              fontWeight: 700,
              sx: {
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
              },
            }}
            secondary={shortenAddress(nestedSafe)}
            secondaryTypographyProps={{ color: 'primary.light' }}
            sx={{ my: 0 }}
          />
          <ChevronRight color="border" />
        </ListItemButton>
      </Link>
    </ListItem>
  )
}
</file>

<file path="src/components/sidebar/NestedSafesPopover/index.tsx">
import { SvgIcon, Popover, Button, Box, Stack } from '@mui/material'
import { useContext } from 'react'
import type { ReactElement } from 'react'

import AddIcon from '@/public/images/common/add.svg'
import { ModalDialogTitle } from '@/components/common/ModalDialog'
import { CreateNestedSafe } from '@/components/tx-flow/flows/CreateNestedSafe'
import { TxModalContext } from '@/components/tx-flow'
import { NestedSafesList } from '@/components/sidebar/NestedSafesList'
import { NestedSafeInfo } from '@/components/sidebar/NestedSafeInfo'
import Track from '@/components/common/Track'
import { NESTED_SAFE_EVENTS } from '@/services/analytics/events/nested-safes'

export function NestedSafesPopover({
  anchorEl,
  onClose,
  nestedSafes,
  hideCreationButton = false,
}: {
  anchorEl: HTMLElement | null
  onClose: () => void
  nestedSafes: Array<string>
  hideCreationButton?: boolean
}): ReactElement {
  const { setTxFlow } = useContext(TxModalContext)

  const onAdd = () => {
    setTxFlow(<CreateNestedSafe />)
    onClose()
  }

  return (
    <Popover
      open={!!anchorEl}
      anchorEl={anchorEl}
      onClose={onClose}
      anchorOrigin={{
        vertical: 'bottom',
        horizontal: 'left',
      }}
      transformOrigin={{
        vertical: 'top',
        horizontal: 'left',
      }}
      slotProps={{
        paper: {
          sx: {
            width: '300px',
            maxHeight: '590px',
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
          },
        },
      }}
    >
      <ModalDialogTitle
        hideChainIndicator
        onClose={onClose}
        sx={{ borderBottom: ({ palette }) => `1px solid ${palette.border.light}` }}
      >
        Nested Safes
      </ModalDialogTitle>
      <Stack
        data-testid="nested-safe-list"
        p={3}
        pt={2}
        display="flex"
        flexDirection="column"
        flex={1}
        overflow="hidden"
      >
        {nestedSafes.length === 0 ? (
          <NestedSafeInfo />
        ) : (
          <Box
            sx={{
              overflowX: 'hidden',
              overflowY: 'auto',
              flex: 1,
            }}
          >
            <NestedSafesList onClose={onClose} nestedSafes={nestedSafes} />
          </Box>
        )}
        {!hideCreationButton && (
          <Track {...NESTED_SAFE_EVENTS.ADD}>
            <Button
              data-testid="add-nested-safe-button"
              variant="contained"
              sx={{ width: '100%', mt: 3 }}
              onClick={onAdd}
            >
              <SvgIcon component={AddIcon} inheritViewBox fontSize="small" />
              Add Nested Safe
            </Button>
          </Track>
        )}
      </Stack>
    </Popover>
  )
}
</file>

<file path="src/components/sidebar/NewTxButton/index.tsx">
import ActivateAccountButton from '@/features/counterfactual/ActivateAccountButton'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { type ReactElement, useContext } from 'react'
import Button from '@mui/material/Button'
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import CheckWallet from '@/components/common/CheckWallet'
import { TxModalContext } from '@/components/tx-flow'
import { NewTxFlow } from '@/components/tx-flow/flows'

const NewTxButton = (): ReactElement => {
  const { setTxFlow } = useContext(TxModalContext)
  const isCounterfactualSafe = useIsCounterfactualSafe()

  const onClick = () => {
    setTxFlow(<NewTxFlow />, undefined, false)
    trackEvent({ ...OVERVIEW_EVENTS.NEW_TRANSACTION, label: 'sidebar' })
  }

  if (isCounterfactualSafe) {
    return <ActivateAccountButton />
  }

  return (
    <CheckWallet allowSpendingLimit>
      {(isOk) => (
        <Button
          data-testid="new-tx-btn"
          onClick={onClick}
          variant="contained"
          size="small"
          disabled={!isOk}
          fullWidth
          disableElevation
          sx={{ py: 1.3 }}
        >
          New transaction
        </Button>
      )}
    </CheckWallet>
  )
}

export default NewTxButton
</file>

<file path="src/components/sidebar/QrCodeButton/index.tsx">
import { type ReactElement, type ReactNode, useState, Suspense } from 'react'
import dynamic from 'next/dynamic'

const QrModal = dynamic(() => import('./QrModal'))

const QrCodeButton = ({ children }: { children: ReactNode }): ReactElement => {
  const [modalOpen, setModalOpen] = useState<boolean>(false)

  return (
    <>
      <div data-testid="qr-modal-btn" onClick={() => setModalOpen(true)}>
        {children}
      </div>

      {modalOpen && (
        <Suspense>
          <QrModal onClose={() => setModalOpen(false)} />
        </Suspense>
      )}
    </>
  )
}

export default QrCodeButton
</file>

<file path="src/components/sidebar/QrCodeButton/QrModal.tsx">
import { type ReactElement } from 'react'
import { Box, Switch, DialogContent, FormControlLabel, Typography } from '@mui/material'
import ModalDialog from '@/components/common/ModalDialog'
import useSafeAddress from '@/hooks/useSafeAddress'
import { useCurrentChain } from '@/hooks/useChains'
import QRCode from '@/components/common/QRCode'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setQrShortName } from '@/store/settingsSlice'

const QrModal = ({ onClose }: { onClose: () => void }): ReactElement => {
  const safeAddress = useSafeAddress()
  const chain = useCurrentChain()
  const settings = useAppSelector(selectSettings)
  const dispatch = useAppDispatch()
  const qrPrefix = settings.shortName.qr ? `${chain?.shortName}:` : ''
  const qrCode = `${qrPrefix}${safeAddress}`
  const chainName = chain?.chainName || ''
  const nativeToken = chain?.nativeCurrency.symbol || ''

  return (
    <ModalDialog open dialogTitle="Receive assets" onClose={onClose} hideChainIndicator>
      <DialogContent>
        <Box bgcolor={chain?.theme.backgroundColor} color={chain?.theme.textColor} px={3} py={2} mx={-3}>
          {chainName} network &mdash; only send {chainName} assets to this Safe Account.
        </Box>

        <Typography my={2}>
          This is the address of your Safe Account. Deposit funds by scanning the QR code or copying the address below.
          Only send {nativeToken} and tokens (e.g. ERC20, ERC721) to this address.
        </Typography>

        <Box display="flex" flexDirection="column" flexWrap="wrap" justifyContent="center" alignItems="center" my={2}>
          <Box mt={1} mb={1} p={1} border="1px solid" borderColor="border.main" borderRadius={1}>
            <QRCode value={qrCode} size={164} />
          </Box>

          <FormControlLabel
            control={
              <Switch checked={settings.shortName.qr} onChange={(e) => dispatch(setQrShortName(e.target.checked))} />
            }
            label={
              <>
                QR code with chain prefix (<b>{chain?.shortName}:</b>)
              </>
            }
          />

          <Box mt={2}>
            <EthHashInfo
              address={safeAddress}
              shortAddress={false}
              showPrefix={qrPrefix.length > 0}
              hasExplorer
              showCopyButton
            />
          </Box>
        </Box>
      </DialogContent>
    </ModalDialog>
  )
}

export default QrModal
</file>

<file path="src/components/sidebar/SafeListContextMenu/index.tsx">
import type { MouseEvent } from 'react'
import { useState, type ReactElement } from 'react'
import ListItemIcon from '@mui/material/ListItemIcon'
import IconButton from '@mui/material/IconButton'
import MoreVertIcon from '@mui/icons-material/MoreVert'
import MenuItem from '@mui/material/MenuItem'
import ListItemText from '@mui/material/ListItemText'
import { skipToken } from '@reduxjs/toolkit/query'

import EntryDialog from '@/components/address-book/EntryDialog'
import SafeListRemoveDialog from '@/components/sidebar/SafeListRemoveDialog'
import NestedSafesIcon from '@/public/images/sidebar/nested-safes-icon.svg'
import EditIcon from '@/public/images/common/edit.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import PlusIcon from '@/public/images/common/plus.svg'
import ContextMenu from '@/components/common/ContextMenu'
import { trackEvent, OVERVIEW_EVENTS, OVERVIEW_LABELS, type AnalyticsEvent } from '@/services/analytics'
import { SvgIcon } from '@mui/material'
import useAddressBook from '@/hooks/useAddressBook'
import { AppRoutes } from '@/config/routes'
import router from 'next/router'
import { CreateSafeOnNewChain } from '@/features/multichain/components/CreateSafeOnNewChain'
import { useGetOwnedSafesQuery } from '@/store/slices'
import { NestedSafesPopover } from '../NestedSafesPopover'
import { NESTED_SAFE_EVENTS, NESTED_SAFE_LABELS } from '@/services/analytics/events/nested-safes'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

enum ModalType {
  NESTED_SAFES = 'nested_safes',
  RENAME = 'rename',
  REMOVE = 'remove',
  ADD_CHAIN = 'add_chain',
}

const defaultOpen = {
  [ModalType.NESTED_SAFES]: false,
  [ModalType.RENAME]: false,
  [ModalType.REMOVE]: false,
  [ModalType.ADD_CHAIN]: false,
}

const SafeListContextMenu = ({
  name,
  address,
  chainId,
  addNetwork,
  rename,
  undeployedSafe,
  onClose,
}: {
  name: string
  address: string
  chainId: string
  addNetwork: boolean
  rename: boolean
  undeployedSafe: boolean
  onClose?: () => void
}): ReactElement => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null)
  const isNestedSafesEnabled = useHasFeature(FEATURES.NESTED_SAFES)
  const { data: nestedSafes } = useGetOwnedSafesQuery(
    isNestedSafesEnabled && address && anchorEl ? { chainId, ownerAddress: address } : skipToken,
  )
  const addressBook = useAddressBook()
  const hasName = address in addressBook
  const [open, setOpen] = useState<typeof defaultOpen>(defaultOpen)

  const trackingLabel =
    router.pathname === AppRoutes.welcome.accounts ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar

  const handleOpenContextMenu = (e: MouseEvent<HTMLButtonElement, globalThis.MouseEvent>) => {
    setAnchorEl(e.currentTarget)
  }

  const handleCloseContextMenu = () => {
    setAnchorEl(null)
  }

  const handleOpenModal = (type: keyof typeof open, event: AnalyticsEvent) => () => {
    if (type !== ModalType.NESTED_SAFES) {
      handleCloseContextMenu()
    }
    setOpen((prev) => ({ ...prev, [type]: true }))

    trackEvent({ ...event, label: trackingLabel })
  }

  const handleCloseModal = () => {
    setOpen(defaultOpen)
  }

  return (
    <>
      <IconButton data-testid="safe-options-btn" edge="end" size="small" onClick={handleOpenContextMenu}>
        <MoreVertIcon sx={({ palette }) => ({ color: palette.border.main })} />
      </IconButton>
      <ContextMenu anchorEl={anchorEl} open={!!anchorEl} onClose={handleCloseContextMenu}>
        {isNestedSafesEnabled && !undeployedSafe && nestedSafes?.safes && nestedSafes.safes.length > 0 && (
          <MenuItem
            onClick={handleOpenModal(ModalType.NESTED_SAFES, {
              ...NESTED_SAFE_EVENTS.OPEN_LIST,
              label: NESTED_SAFE_LABELS.sidebar,
            })}
          >
            <ListItemIcon>
              <SvgIcon component={NestedSafesIcon} inheritViewBox fontSize="small" color="success" />
            </ListItemIcon>
            <ListItemText data-testid="nested-safes-btn">Nested Safes</ListItemText>
          </MenuItem>
        )}

        {rename && (
          <MenuItem onClick={handleOpenModal(ModalType.RENAME, OVERVIEW_EVENTS.SIDEBAR_RENAME)}>
            <ListItemIcon>
              <SvgIcon component={EditIcon} inheritViewBox fontSize="small" color="success" />
            </ListItemIcon>
            <ListItemText data-testid="rename-btn">{hasName ? 'Rename' : 'Give name'}</ListItemText>
          </MenuItem>
        )}

        {undeployedSafe && (
          <MenuItem onClick={handleOpenModal(ModalType.REMOVE, OVERVIEW_EVENTS.REMOVE_FROM_WATCHLIST)}>
            <ListItemIcon>
              <SvgIcon component={DeleteIcon} inheritViewBox fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText data-testid="remove-btn">Remove</ListItemText>
          </MenuItem>
        )}

        {addNetwork && (
          <MenuItem onClick={handleOpenModal(ModalType.ADD_CHAIN, OVERVIEW_EVENTS.ADD_NEW_NETWORK)}>
            <ListItemIcon>
              <SvgIcon component={PlusIcon} inheritViewBox fontSize="small" color="primary" />
            </ListItemIcon>
            <ListItemText data-testid="add-chain-btn">Add another network</ListItemText>
          </MenuItem>
        )}
      </ContextMenu>

      {open[ModalType.NESTED_SAFES] && (
        <NestedSafesPopover
          anchorEl={anchorEl}
          onClose={() => {
            handleCloseModal()
            onClose?.()
          }}
          nestedSafes={nestedSafes?.safes ?? []}
          hideCreationButton
        />
      )}

      {open[ModalType.RENAME] && (
        <EntryDialog
          handleClose={handleCloseModal}
          defaultValues={{ name, address }}
          chainIds={[chainId]}
          disableAddressInput
        />
      )}

      {open[ModalType.REMOVE] && (
        <SafeListRemoveDialog handleClose={handleCloseModal} address={address} chainId={chainId} />
      )}

      {open[ModalType.ADD_CHAIN] && (
        <CreateSafeOnNewChain
          onClose={handleCloseModal}
          currentName={name}
          deployedChainIds={[chainId]}
          open
          safeAddress={address}
        />
      )}
    </>
  )
}

export default SafeListContextMenu
</file>

<file path="src/components/sidebar/SafeListContextMenu/MultiAccountContextMenu.tsx">
import type { MouseEvent } from 'react'
import { useState, type ReactElement } from 'react'
import ListItemIcon from '@mui/material/ListItemIcon'
import IconButton from '@mui/material/IconButton'
import MoreVertIcon from '@mui/icons-material/MoreVert'
import MenuItem from '@mui/material/MenuItem'
import ListItemText from '@mui/material/ListItemText'

import EntryDialog from '@/components/address-book/EntryDialog'
import EditIcon from '@/public/images/common/edit.svg'
import PlusIcon from '@/public/images/common/plus.svg'
import ContextMenu from '@/components/common/ContextMenu'
import { trackEvent, OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { SvgIcon } from '@mui/material'
import { AppRoutes } from '@/config/routes'
import router from 'next/router'
import { CreateSafeOnNewChain } from '@/features/multichain/components/CreateSafeOnNewChain'

enum ModalType {
  RENAME = 'rename',
  ADD_CHAIN = 'add_chain',
}

const defaultOpen = { [ModalType.RENAME]: false, [ModalType.ADD_CHAIN]: false }

const MultiAccountContextMenu = ({
  name,
  address,
  chainIds,
  addNetwork,
}: {
  name: string
  address: string
  chainIds: string[]
  addNetwork: boolean
}): ReactElement => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | undefined>()
  const [open, setOpen] = useState<typeof defaultOpen>(defaultOpen)

  const handleOpenContextMenu = (e: MouseEvent<HTMLButtonElement, globalThis.MouseEvent>) => {
    e.stopPropagation()
    setAnchorEl(e.currentTarget)
  }

  const handleCloseContextMenu = (event: MouseEvent) => {
    event.stopPropagation()
    setAnchorEl(undefined)
  }

  const handleOpenModal =
    (type: ModalType, event: typeof OVERVIEW_EVENTS.SIDEBAR_RENAME | typeof OVERVIEW_EVENTS.ADD_NEW_NETWORK) =>
    (e: MouseEvent) => {
      const trackingLabel =
        router.pathname === AppRoutes.welcome.accounts ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar
      handleCloseContextMenu(e)
      setOpen((prev) => ({ ...prev, [type]: true }))

      trackEvent({ ...event, label: trackingLabel })
    }

  const handleCloseModal = () => {
    setOpen(defaultOpen)
  }

  return (
    <>
      <IconButton data-testid="safe-options-btn" edge="end" size="small" onClick={handleOpenContextMenu}>
        <MoreVertIcon sx={({ palette }) => ({ color: palette.border.main })} />
      </IconButton>
      <ContextMenu anchorEl={anchorEl} open={!!anchorEl} onClose={handleCloseContextMenu}>
        <MenuItem onClick={handleOpenModal(ModalType.RENAME, OVERVIEW_EVENTS.SIDEBAR_RENAME)}>
          <ListItemIcon>
            <SvgIcon component={EditIcon} inheritViewBox fontSize="small" color="success" />
          </ListItemIcon>
          <ListItemText data-testid="rename-btn">Rename</ListItemText>
        </MenuItem>
        {addNetwork && (
          <MenuItem onClick={handleOpenModal(ModalType.ADD_CHAIN, OVERVIEW_EVENTS.ADD_NEW_NETWORK)}>
            <ListItemIcon>
              <SvgIcon component={PlusIcon} inheritViewBox fontSize="small" color="primary" />
            </ListItemIcon>
            <ListItemText data-testid="add-chain-btn">Add another network</ListItemText>
          </MenuItem>
        )}
      </ContextMenu>

      {open[ModalType.RENAME] && (
        <EntryDialog
          handleClose={handleCloseModal}
          defaultValues={{ name, address }}
          chainIds={chainIds}
          disableAddressInput
        />
      )}

      {open[ModalType.ADD_CHAIN] && (
        <CreateSafeOnNewChain
          onClose={handleCloseModal}
          currentName={name}
          deployedChainIds={chainIds}
          open
          safeAddress={address}
        />
      )}
    </>
  )
}

export default MultiAccountContextMenu
</file>

<file path="src/components/sidebar/SafeListRemoveDialog/index.tsx">
import DialogContent from '@mui/material/DialogContent'
import DialogActions from '@mui/material/DialogActions'
import Typography from '@mui/material/Typography'
import Button from '@mui/material/Button'
import type { ReactElement } from 'react'

import ModalDialog from '@/components/common/ModalDialog'
import { useAppDispatch } from '@/store'
import useAddressBook from '@/hooks/useAddressBook'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import router from 'next/router'
import { removeAddressBookEntry } from '@/store/addressBookSlice'
import { removeSafe, removeUndeployedSafe } from '@/store/slices'
import useSafeAddress from '@/hooks/useSafeAddress'
import useChainId from '@/hooks/useChainId'

const SafeListRemoveDialog = ({
  handleClose,
  address,
  chainId,
}: {
  handleClose: () => void
  address: string
  chainId: string
}): ReactElement => {
  const dispatch = useAppDispatch()
  const safeAddress = useSafeAddress()
  const safeChainId = useChainId()
  const addressBook = useAddressBook()
  const trackingLabel =
    router.pathname === AppRoutes.welcome.accounts ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar

  const safe = addressBook?.[address] || address

  const handleConfirm = async () => {
    // When removing the current counterfactual safe, redirect to the accounts page
    if (safeAddress === address && safeChainId === chainId) {
      await router.push(AppRoutes.welcome.accounts)
    }
    dispatch(removeUndeployedSafe({ chainId, address }))
    dispatch(removeSafe({ chainId, address }))
    dispatch(removeAddressBookEntry({ chainId, address }))
    handleClose()
  }

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Delete entry" chainId={chainId}>
      <DialogContent sx={{ p: '24px !important' }}>
        <Typography>
          Are you sure you want to remove the <b>{safe}</b> account?
        </Typography>
      </DialogContent>

      <DialogActions>
        <Button data-testid="cancel-btn" onClick={handleClose}>
          Cancel
        </Button>
        <Track {...OVERVIEW_EVENTS.DELETED_FROM_WATCHLIST} label={trackingLabel}>
          <Button data-testid="delete-btn" onClick={handleConfirm} variant="danger" disableElevation>
            Delete
          </Button>
        </Track>
      </DialogActions>
    </ModalDialog>
  )
}

export default SafeListRemoveDialog
</file>

<file path="src/components/sidebar/Sidebar/index.tsx">
import { useCallback, useState, type ReactElement } from 'react'
import { Box, Divider, Drawer } from '@mui/material'
import ChevronRight from '@mui/icons-material/ChevronRight'

import ChainIndicator from '@/components/common/ChainIndicator'
import SidebarHeader from '@/components/sidebar/SidebarHeader'
import SidebarNavigation from '@/components/sidebar/SidebarNavigation'
import SidebarFooter from '@/components/sidebar/SidebarFooter'
import IndexingStatus from '@/components/sidebar/IndexingStatus'

import css from './styles.module.css'
import { trackEvent, OVERVIEW_EVENTS } from '@/services/analytics'
import MyAccounts from '@/features/myAccounts'

const Sidebar = (): ReactElement => {
  const [isDrawerOpen, setIsDrawerOpen] = useState<boolean>(false)

  const onDrawerToggle = useCallback(() => {
    setIsDrawerOpen((isOpen) => {
      trackEvent({ ...OVERVIEW_EVENTS.SIDEBAR, label: isOpen ? 'Close' : 'Open' })

      return !isOpen
    })
  }, [])

  const closeDrawer = useCallback(() => setIsDrawerOpen(false), [])

  return (
    <div data-testid="sidebar-container" className={css.container}>
      <div className={css.scroll}>
        <ChainIndicator showLogo={false} />

        {/* Open the safes list */}
        <button data-testid="open-safes-icon" className={css.drawerButton} onClick={onDrawerToggle}>
          <ChevronRight />
        </button>

        {/* Address, balance, copy button, etc */}
        <SidebarHeader />

        <Divider />

        {/* Nav menu */}
        <SidebarNavigation />

        <Box
          sx={{
            flex: 1,
          }}
        />

        <Divider flexItem />

        {/* What's new + Need help? */}
        <SidebarFooter />

        <Divider flexItem />

        <IndexingStatus />
      </div>
      <Drawer variant="temporary" anchor="left" open={isDrawerOpen} onClose={onDrawerToggle}>
        <div className={css.drawer}>
          <MyAccounts onLinkClick={closeDrawer} isSidebar></MyAccounts>
        </div>
      </Drawer>
    </div>
  )
}

export default Sidebar
</file>

<file path="src/components/sidebar/Sidebar/styles.module.css">
.container {
  height: 100vh;
  padding-top: var(--header-height);
  display: flex;
  overflow: hidden;
  flex-direction: column;
  background-color: var(--color-background-paper);
  width: 230px;
}

.scroll {
  display: flex;
  flex-direction: column;
  height: 100%;
  position: relative;
  overflow-y: auto;
  overflow-x: hidden;
}

.drawer {
  width: 550px;
  max-width: 90vw;
  padding-top: var(--header-height);
  border-right: 1px solid var(--color-border-light);
  overflow-y: auto;
  height: 100%;
}

.dataWidget {
  margin-top: var(--space-4);
  border-top: 1px solid var(--color-border-light);
}

.noSafeHeader {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 10px;
  min-height: 100px;
}

.drawerButton {
  position: absolute !important;
  z-index: 2;
  color: var(--color-text-primary);
  padding: 8px 0;
  right: 0;
  transform: translateX(50%);
  margin-top: 54px;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  border: 0;
  cursor: pointer;
  background-color: var(--color-background-main);
}

.drawerButton:hover {
  background-color: var(--color-secondary-background);
}

.drawerButton svg {
  transform: translateX(-25%);
}

@media (max-width: 899.95px) {
  .container {
    padding-top: var(--header-height);
    border-right: 1px solid var(--color-border-light);
  }

  .drawer {
    max-width: 90vw;
  }

  .drawerButton {
    width: 60px;
    height: 60px;
    margin-top: 44px;
  }
}
</file>

<file path="src/components/sidebar/SidebarFooter/index.tsx">
import type { ReactElement } from 'react'
import { useEffect } from 'react'

import {
  SidebarList,
  SidebarListItemButton,
  SidebarListItemIcon,
  SidebarListItemText,
} from '@/components/sidebar/SidebarList'
import { BEAMER_SELECTOR, loadBeamer } from '@/services/beamer'
import { useAppDispatch, useAppSelector } from '@/store'
import { CookieAndTermType, hasConsentFor } from '@/store/cookiesAndTermsSlice'
import { openCookieBanner } from '@/store/popupSlice'
import BeamerIcon from '@/public/images/sidebar/whats-new.svg'
import HelpCenterIcon from '@/public/images/sidebar/help-center.svg'
import { ListItem } from '@mui/material'
import DebugToggle from '../DebugToggle'
import { HELP_CENTER_URL, IS_PRODUCTION } from '@/config/constants'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS } from '@/services/analytics/events/overview'
import { useCurrentChain } from '@/hooks/useChains'

const SidebarFooter = (): ReactElement => {
  const dispatch = useAppDispatch()
  const chain = useCurrentChain()
  const hasBeamerConsent = useAppSelector((state) => hasConsentFor(state, CookieAndTermType.UPDATES))

  useEffect(() => {
    // Initialise Beamer when consent was previously given
    if (hasBeamerConsent && chain?.shortName) {
      loadBeamer(chain.shortName)
    }
  }, [hasBeamerConsent, chain?.shortName])

  const handleBeamer = () => {
    if (!hasBeamerConsent) {
      dispatch(openCookieBanner({ warningKey: CookieAndTermType.UPDATES }))
    }
  }

  return (
    <SidebarList>
      {!IS_PRODUCTION && (
        <ListItem disablePadding>
          <DebugToggle />
        </ListItem>
      )}

      <Track {...OVERVIEW_EVENTS.WHATS_NEW}>
        <ListItem disablePadding>
          <SidebarListItemButton id={BEAMER_SELECTOR} onClick={handleBeamer}>
            <SidebarListItemIcon color="primary">
              <BeamerIcon />
            </SidebarListItemIcon>
            <SidebarListItemText data-testid="list-item-whats-new" bold>
              What&apos;s new
            </SidebarListItemText>
          </SidebarListItemButton>
        </ListItem>
      </Track>

      <Track {...OVERVIEW_EVENTS.HELP_CENTER}>
        <ListItem data-testid="need-help-btn" disablePadding>
          <a target="_blank" rel="noopener noreferrer" href={HELP_CENTER_URL} style={{ width: '100%' }}>
            <SidebarListItemButton>
              <SidebarListItemIcon color="primary">
                <HelpCenterIcon />
              </SidebarListItemIcon>
              <SidebarListItemText data-testid="list-item-need-help" bold>
                Need help?
              </SidebarListItemText>
            </SidebarListItemButton>
          </a>
        </ListItem>
      </Track>
    </SidebarList>
  )
}

export default SidebarFooter
</file>

<file path="src/components/sidebar/SidebarHeader/index.tsx">
import TokenAmount from '@/components/common/TokenAmount'
import CounterfactualStatusButton from '@/features/counterfactual/CounterfactualStatusButton'
import { type ReactElement } from 'react'
import Typography from '@mui/material/Typography'
import IconButton from '@mui/material/IconButton'
import Skeleton from '@mui/material/Skeleton'
import Tooltip from '@mui/material/Tooltip'

import useSafeInfo from '@/hooks/useSafeInfo'
import SafeIcon from '@/components/common/SafeIcon'
import NewTxButton from '@/components/sidebar/NewTxButton'
import { useAppSelector } from '@/store'

import css from './styles.module.css'
import QrIconBold from '@/public/images/sidebar/qr-bold.svg'
import CopyIconBold from '@/public/images/sidebar/copy-bold.svg'
import LinkIconBold from '@/public/images/sidebar/link-bold.svg'

import { selectSettings } from '@/store/settingsSlice'
import { useCurrentChain } from '@/hooks/useChains'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import EthHashInfo from '@/components/common/EthHashInfo'
import QrCodeButton from '../QrCodeButton'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS } from '@/services/analytics/events/overview'
import { SvgIcon } from '@mui/material'
import { useVisibleBalances } from '@/hooks/useVisibleBalances'
import EnvHintButton from '@/components/settings/EnvironmentVariables/EnvHintButton'
import useSafeAddress from '@/hooks/useSafeAddress'
import ExplorerButton from '@/components/common/ExplorerButton'
import CopyTooltip from '@/components/common/CopyTooltip'
import FiatValue from '@/components/common/FiatValue'
import { useAddressResolver } from '@/hooks/useAddressResolver'
import { NestedSafesButton } from '@/components/sidebar/NestedSafesButton'
import { NESTED_SAFE_EVENTS, NESTED_SAFE_LABELS } from '@/services/analytics/events/nested-safes'

const SafeHeader = (): ReactElement => {
  const { balances } = useVisibleBalances()
  const safeAddress = useSafeAddress()
  const { safe } = useSafeInfo()
  const { threshold, owners } = safe
  const chain = useCurrentChain()
  const settings = useAppSelector(selectSettings)
  const { ens } = useAddressResolver(safeAddress)

  const addressCopyText = settings.shortName.copy && chain ? `${chain.shortName}:${safeAddress}` : safeAddress

  const blockExplorerLink = chain ? getBlockExplorerLink(chain, safeAddress) : undefined

  return (
    <div className={css.container}>
      <div className={css.info}>
        <div data-testid="safe-header-info" className={css.safe}>
          <div data-testid="safe-icon">
            {safeAddress ? (
              <SafeIcon address={safeAddress} threshold={threshold} owners={owners?.length} />
            ) : (
              <Skeleton variant="circular" width={40} height={40} />
            )}
          </div>

          <div className={css.address}>
            {safeAddress ? (
              <EthHashInfo address={safeAddress} shortAddress showAvatar={false} name={ens} />
            ) : (
              <Typography variant="body2">
                <Skeleton variant="text" width={86} />
                <Skeleton variant="text" width={120} />
              </Typography>
            )}

            <Typography data-testid="currency-section" variant="body2" fontWeight={700}>
              {safe.deployed ? (
                balances.fiatTotal ? (
                  <FiatValue value={balances.fiatTotal} />
                ) : (
                  <Skeleton variant="text" width={60} />
                )
              ) : (
                <TokenAmount
                  value={balances.items[0]?.balance}
                  decimals={balances.items[0]?.tokenInfo.decimals}
                  tokenSymbol={balances.items[0]?.tokenInfo.symbol}
                />
              )}
            </Typography>
          </div>
        </div>

        <div className={css.iconButtons}>
          <Track {...OVERVIEW_EVENTS.SHOW_QR} label="sidebar">
            <QrCodeButton>
              <Tooltip title="Open QR code" placement="top">
                <IconButton className={css.iconButton}>
                  <SvgIcon component={QrIconBold} inheritViewBox color="primary" fontSize="small" />
                </IconButton>
              </Tooltip>
            </QrCodeButton>
          </Track>

          <Track {...OVERVIEW_EVENTS.COPY_ADDRESS}>
            <CopyTooltip text={addressCopyText}>
              <IconButton data-testid="copy-address-btn" className={css.iconButton}>
                <SvgIcon component={CopyIconBold} inheritViewBox color="primary" fontSize="small" />
              </IconButton>
            </CopyTooltip>
          </Track>

          <Track {...OVERVIEW_EVENTS.OPEN_EXPLORER}>
            <ExplorerButton {...blockExplorerLink} className={css.iconButton} icon={LinkIconBold} />
          </Track>

          <Track {...NESTED_SAFE_EVENTS.OPEN_LIST} label={NESTED_SAFE_LABELS.header}>
            <NestedSafesButton chainId={safe.chainId} safeAddress={safe.address.value} />
          </Track>

          <CounterfactualStatusButton />

          <EnvHintButton />
        </div>
      </div>

      <NewTxButton />
    </div>
  )
}

export default SafeHeader
</file>

<file path="src/components/sidebar/SidebarHeader/styles.module.css">
.container {
  padding: var(--space-2) var(--space-1);
}

.info {
  padding: 0 var(--space-1);
}

.safe {
  display: flex;
  gap: 12px;
  text-align: left;
  align-items: center;
}

.iconButtons {
  margin-top: 10px;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.iconButton {
  border-radius: 4px;
  padding: 6px;
  color: var(--color-primary-main);
  background-color: var(--color-background-main);
  width: 32px;
  height: 32px;
}

.iconButton:hover {
  background-color: var(--color-secondary-background);
}

.address {
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  font-size: 14px;
}
</file>

<file path="src/components/sidebar/SidebarList/index.tsx">
import type { ReactElement } from 'react'
import List, { type ListProps } from '@mui/material/List'
import ListItemButton, { type ListItemButtonProps } from '@mui/material/ListItemButton'
import ListItemIcon, { type ListItemIconProps } from '@mui/material/ListItemIcon'
import ListItemText, { type ListItemTextProps } from '@mui/material/ListItemText'
import Link from 'next/link'
import type { LinkProps } from 'next/link'
import Badge from '@mui/material/Badge'

import css from './styles.module.css'

export const SidebarList = ({ children, ...rest }: Omit<ListProps, 'className'>): ReactElement => (
  <List className={css.list} {...rest}>
    {children}
  </List>
)

export const SidebarListItemButton = ({
  href,
  children,
  disabled,
  ...rest
}: Omit<ListItemButtonProps, 'sx'> & { href?: LinkProps['href'] }): ReactElement => {
  const button = (
    <ListItemButton className={css.listItemButton} {...rest} sx={disabled ? { pointerEvents: 'none' } : undefined}>
      {children}
    </ListItemButton>
  )

  return href ? (
    <Link href={href} passHref legacyBehavior>
      {button}
    </Link>
  ) : (
    button
  )
}

export const SidebarListItemIcon = ({
  children,
  badge = false,
  ...rest
}: Omit<ListItemIconProps, 'className'> & { badge?: boolean }): ReactElement => (
  <ListItemIcon
    className={css.icon}
    sx={{
      '& svg': {
        width: '16px',
        height: '16px',
        '& path': ({ palette }) => ({
          fill: palette.logo.main,
        }),
      },
    }}
    {...rest}
  >
    <Badge color="error" variant="dot" invisible={!badge} anchorOrigin={{ vertical: 'top', horizontal: 'right' }}>
      {children}
    </Badge>
  </ListItemIcon>
)

export const SidebarListItemText = ({
  children,
  bold = false,
  ...rest
}: ListItemTextProps & { bold?: boolean }): ReactElement => (
  <ListItemText
    primaryTypographyProps={{
      variant: 'body2',
      fontWeight: bold ? 700 : undefined,
      display: 'flex',
      justifyContent: 'space-between',
    }}
    {...rest}
  >
    {children}
  </ListItemText>
)

export const SidebarListItemCounter = ({ count }: { count?: string }): ReactElement | null =>
  count ? (
    <Badge
      sx={{
        '& .MuiBadge-badge': {
          color: 'static.main',
          backgroundColor: 'warning.light',
          transform: 'none',
          fontWeight: 'bold',
          padding: '0 var(--space-1)',
          fontSize: '11px',
        },
        ml: 3,
      }}
      variant="standard"
      badgeContent={count}
    />
  ) : null
</file>

<file path="src/components/sidebar/SidebarList/styles.module.css">
.list {
  display: grid;
  gap: 4px;
  padding-left: 8px;
  padding-right: 8px;
}

.icon {
  min-width: 0;
  margin-right: var(--space-2);
}

.listItemButton {
  border-radius: 6px;
  padding-top: 6px;
  padding-bottom: 6px;
}

.list :global .MuiListItemButton-root {
  color: var(--color-text-primary);
}

[data-theme='dark'] .list :global .Mui-selected {
  background-color: var(--color-border-light);
}

.list :global .MuiListItemButton-root:hover {
  border-radius: 6px;
  background-color: var(--color-background-light);
}

.list :global .Mui-selected {
  border-radius: 6px;
  background-color: var(--color-background-main);
}

.listItemButton :global .beamer_icon.active {
  top: auto;
  left: 28px;
  bottom: 10px;
  width: 6px;
  height: 6px;
  color: transparent;
}
</file>

<file path="src/components/sidebar/SidebarNavigation/config.tsx">
import type { ReactElement } from 'react'
import React from 'react'
import { AppRoutes } from '@/config/routes'
import HomeIcon from '@/public/images/sidebar/home.svg'
import AssetsIcon from '@/public/images/sidebar/assets.svg'
import TransactionIcon from '@/public/images/sidebar/transactions.svg'
import ABIcon from '@/public/images/sidebar/address-book.svg'
import AppsIcon from '@/public/images/apps/apps-icon.svg'
import SettingsIcon from '@/public/images/sidebar/settings.svg'
import BridgeIcon from '@/public/images/common/bridge.svg'
import SwapIcon from '@/public/images/common/swap.svg'
import StakeIcon from '@/public/images/common/stake.svg'
import { SvgIcon } from '@mui/material'
import { Chip } from '@/components/common/Chip'

export type NavItem = {
  label: string
  icon?: ReactElement
  href: string
  tag?: ReactElement
  disabled?: boolean
}

export const navItems: NavItem[] = [
  {
    label: 'Home',
    icon: <SvgIcon component={HomeIcon} inheritViewBox />,
    href: AppRoutes.home,
  },
  {
    label: 'Assets',
    icon: <SvgIcon component={AssetsIcon} inheritViewBox />,
    href: AppRoutes.balances.index,
  },
  {
    label: 'Bridge',
    icon: <SvgIcon component={BridgeIcon} inheritViewBox />,
    href: AppRoutes.bridge,
    tag: <Chip label="New" sx={{ backgroundColor: 'secondary.light', color: 'static.main' }} />,
  },
  {
    label: 'Swap',
    icon: <SvgIcon component={SwapIcon} inheritViewBox />,
    href: AppRoutes.swap,
  },
  {
    label: 'Stake',
    icon: <SvgIcon component={StakeIcon} inheritViewBox />,
    href: AppRoutes.stake,
  },
  {
    label: 'Transactions',
    icon: <SvgIcon component={TransactionIcon} inheritViewBox />,
    href: AppRoutes.transactions.history,
  },
  {
    label: 'Address book',
    icon: <SvgIcon component={ABIcon} inheritViewBox />,
    href: AppRoutes.addressBook,
  },
  {
    label: 'Apps',
    icon: <SvgIcon component={AppsIcon} inheritViewBox />,
    href: AppRoutes.apps.index,
  },
  {
    label: 'Settings',
    icon: <SvgIcon data-testid="settings-nav-icon" component={SettingsIcon} inheritViewBox />,
    href: AppRoutes.settings.setup,
  },
]

export const transactionNavItems = [
  {
    label: 'Queue',
    href: AppRoutes.transactions.queue,
  },
  {
    label: 'History',
    href: AppRoutes.transactions.history,
  },
  {
    label: 'Messages',
    href: AppRoutes.transactions.messages,
  },
]

export const balancesNavItems = [
  {
    label: 'Tokens',
    href: AppRoutes.balances.index,
  },
  {
    label: 'NFTs',
    href: AppRoutes.balances.nfts,
  },
]

export const settingsNavItems = [
  {
    label: 'Setup',
    href: AppRoutes.settings.setup,
  },
  {
    label: 'Appearance',
    href: AppRoutes.settings.appearance,
  },
  {
    label: 'Security',
    href: AppRoutes.settings.security,
  },
  {
    label: 'Notifications',
    href: AppRoutes.settings.notifications,
  },
  {
    label: 'Modules',
    href: AppRoutes.settings.modules,
  },
  {
    label: 'Safe Apps',
    href: AppRoutes.settings.safeApps.index,
  },
  {
    label: 'Data',
    href: AppRoutes.settings.data,
  },
  {
    label: 'Environment variables',
    href: AppRoutes.settings.environmentVariables,
  },
]

export const generalSettingsNavItems = [
  {
    label: 'Cookies',
    href: AppRoutes.settings.cookies,
  },
  {
    label: 'Appearance',
    href: AppRoutes.settings.appearance,
  },
  {
    label: 'Notifications',
    href: AppRoutes.settings.notifications,
  },
  {
    label: 'Security',
    href: AppRoutes.settings.security,
  },
  {
    label: 'Data',
    href: AppRoutes.settings.data,
  },
  {
    label: 'Environment variables',
    href: AppRoutes.settings.environmentVariables,
  },
]

export const safeAppsNavItems = [
  {
    label: 'All apps',
    href: AppRoutes.apps.index,
  },
  {
    label: 'My custom apps',
    href: AppRoutes.apps.custom,
  },
]
</file>

<file path="src/components/sidebar/SidebarNavigation/index.tsx">
import React, { useContext, useMemo, type ReactElement } from 'react'
import { useRouter } from 'next/router'
import { ListItemButton } from '@mui/material'
import { ImplementationVersionState } from '@safe-global/safe-gateway-typescript-sdk'

import {
  SidebarList,
  SidebarListItemButton,
  SidebarListItemCounter,
  SidebarListItemIcon,
  SidebarListItemText,
} from '@/components/sidebar/SidebarList'
import { type NavItem, navItems } from './config'
import useSafeInfo from '@/hooks/useSafeInfo'
import { AppRoutes } from '@/config/routes'
import { useQueuedTxsLength } from '@/hooks/useTxQueue'
import { useCurrentChain } from '@/hooks/useChains'
import { isRouteEnabled } from '@/utils/chains'
import { trackEvent } from '@/services/analytics'
import { SWAP_EVENTS, SWAP_LABELS } from '@/services/analytics/events/swaps'
import { GeoblockingContext } from '@/components/common/GeoblockingProvider'
import { STAKE_EVENTS, STAKE_LABELS } from '@/services/analytics/events/stake'
import { Tooltip } from '@mui/material'
import { BRIDGE_EVENTS, BRIDGE_LABELS } from '@/services/analytics/events/bridge'

const getSubdirectory = (pathname: string): string => {
  return pathname.split('/')[1]
}

const geoBlockedRoutes = [AppRoutes.bridge, AppRoutes.swap, AppRoutes.stake]

const undeployedSafeBlockedRoutes = [AppRoutes.bridge, AppRoutes.swap, AppRoutes.stake, AppRoutes.apps.index]

const customSidebarEvents: { [key: string]: { event: any; label: string } } = {
  [AppRoutes.bridge]: { event: BRIDGE_EVENTS.OPEN_BRIDGE, label: BRIDGE_LABELS.sidebar },
  [AppRoutes.swap]: { event: SWAP_EVENTS.OPEN_SWAPS, label: SWAP_LABELS.sidebar },
  [AppRoutes.stake]: { event: STAKE_EVENTS.OPEN_STAKE, label: STAKE_LABELS.sidebar },
}

const Navigation = (): ReactElement => {
  const chain = useCurrentChain()
  const router = useRouter()
  const { safe } = useSafeInfo()
  const currentSubdirectory = getSubdirectory(router.pathname)
  const queueSize = useQueuedTxsLength()
  const isBlockedCountry = useContext(GeoblockingContext)

  const visibleNavItems = useMemo(() => {
    return navItems.filter((item) => {
      if (isBlockedCountry && geoBlockedRoutes.includes(item.href)) {
        return false
      }

      return isRouteEnabled(item.href, chain)
    })
  }, [chain, isBlockedCountry])

  const enabledNavItems = useMemo(() => {
    return safe.deployed
      ? visibleNavItems
      : visibleNavItems.filter((item) => !undeployedSafeBlockedRoutes.includes(item.href))
  }, [safe.deployed, visibleNavItems])

  const getBadge = (item: NavItem) => {
    // Indicate whether the current Safe needs an upgrade
    if (item.href === AppRoutes.settings.setup) {
      return safe.implementationVersionState === ImplementationVersionState.OUTDATED
    }
  }

  // Route Transactions to Queue if there are queued txs, otherwise to History
  const getRoute = (href: string) => {
    if (href === AppRoutes.transactions.history && queueSize) {
      return AppRoutes.transactions.queue
    }
    return href
  }

  const handleNavigationClick = (href: string) => {
    const eventInfo = customSidebarEvents[href]
    if (eventInfo) {
      trackEvent({ ...eventInfo.event, label: eventInfo.label })
    }
  }

  return (
    <SidebarList>
      {visibleNavItems.map((item) => {
        const isSelected = currentSubdirectory === getSubdirectory(item.href)
        const isDisabled = item.disabled || !enabledNavItems.includes(item)
        let ItemTag = item.tag ? item.tag : null
        const spaceId = router.query.spaceId
        const query = {
          safe: router.query.safe,
          ...(spaceId && { spaceId }),
        }

        if (item.href === AppRoutes.transactions.history) {
          ItemTag = queueSize ? <SidebarListItemCounter count={queueSize} /> : null
        }

        return (
          <Tooltip
            title={isDisabled ? 'You need to activate your Safe first.' : ''}
            placement="right"
            key={item.href}
            arrow
          >
            <div>
              <ListItemButton
                // disablePadding
                sx={{ padding: 0 }}
                disabled={isDisabled}
                selected={isSelected}
                onClick={isDisabled ? undefined : () => handleNavigationClick(item.href)}
                key={item.href}
              >
                <SidebarListItemButton
                  selected={isSelected}
                  href={
                    item.href && {
                      pathname: getRoute(item.href),
                      query,
                    }
                  }
                  disabled={isDisabled}
                >
                  {item.icon && <SidebarListItemIcon badge={getBadge(item)}>{item.icon}</SidebarListItemIcon>}

                  <SidebarListItemText data-testid="sidebar-list-item" bold>
                    {item.label}

                    {ItemTag}
                  </SidebarListItemText>
                </SidebarListItemButton>
              </ListItemButton>
            </div>
          </Tooltip>
        )
      })}
    </SidebarList>
  )
}

export default React.memo(Navigation)
</file>

<file path="src/components/theme/darkPalette.ts">
const darkPalette = {
  text: {
    primary: '#FFFFFF',
    secondary: '#636669',
    disabled: '#636669',
  },
  primary: {
    dark: '#0cb259',
    main: '#12FF80',
    light: '#A1A3A7',
  },
  secondary: {
    dark: '#636669',
    main: '#FFFFFF',
    light: '#B0FFC9',
    background: '#1B2A22',
  },
  border: {
    main: '#636669',
    light: '#303033',
    background: '#121312',
  },
  error: {
    dark: '#AC2C3B',
    main: '#FF5F72',
    light: '#FFB4BD',
    background: '#2F2527',
  },
  success: {
    dark: '#388E3C',
    main: '#00B460',
    light: '#81C784',
    background: '#1F2920',
  },
  info: {
    dark: '#52BFDC',
    main: '#5FDDFF',
    light: '#B7F0FF',
    background: '#19252C',
  },
  warning: {
    dark: '#C04C32',
    main: '#FF8061',
    light: '#FFBC9F',
    background: '#2F2318',
  },
  background: {
    default: '#121312',
    main: '#121312',
    paper: '#1C1C1C',
    light: '#1B2A22',
  },
  backdrop: {
    main: '#636669',
  },
  logo: {
    main: '#FFFFFF',
    background: '#303033',
  },
  static: {
    main: '#121312',
  },
}

export default darkPalette
</file>

<file path="src/components/theme/lightPalette.ts">
const lightPalette = {
  text: {
    primary: '#121312',
    secondary: '#A1A3A7',
    disabled: '#DDDEE0',
  },
  primary: {
    dark: '#3c3c3c',
    main: '#121312',
    light: '#636669',
  },
  secondary: {
    dark: '#0FDA6D',
    main: '#12FF80',
    light: '#B0FFC9',
    background: '#EFFFF4',
  },
  border: {
    main: '#A1A3A7',
    light: '#DCDEE0',
    background: '#F4F4F4',
  },
  error: {
    dark: '#AC2C3B',
    main: '#FF5F72',
    light: '#FFB4BD',
    background: '#FFE6EA',
  },
  success: {
    dark: '#028D4C',
    main: '#00B460',
    light: '#D3F2E4',
    background: '#EFFAF1',
  },
  info: {
    dark: '#52BFDC',
    main: '#5FDDFF',
    light: '#D7F6FF',
    background: '#EFFCFF',
  },
  warning: {
    dark: '#C04C32',
    main: '#FF8061',
    light: '#FFBC9F',
    background: '#FFF1E0',
  },
  background: {
    default: '#F4F4F4',
    main: '#F4F4F4',
    paper: '#FFFFFF',
    light: '#EFFFF4',
  },
  backdrop: {
    main: '#636669',
  },
  logo: {
    main: '#121312',
    background: '#EEEFF0',
  },
  static: {
    main: '#121312',
  },
}

export default lightPalette
</file>

<file path="src/components/theme/safeTheme.ts">
import type { Theme, PaletteMode } from '@mui/material'
import { alpha } from '@mui/material'
import type { Shadows } from '@mui/material/styles'
import { createTheme } from '@mui/material/styles'

import palette from './lightPalette'
import darkPalette from './darkPalette'
import typography from './typography'

export const base = 8

declare module '@mui/material/styles' {
  // Custom color palettes
  export interface Palette {
    border: Palette['primary']
    logo: Palette['primary']
    backdrop: Palette['primary']
    static: Palette['primary']
  }

  export interface PaletteOptions {
    border: PaletteOptions['primary']
    logo: PaletteOptions['primary']
    backdrop: PaletteOptions['primary']
    static: PaletteOptions['primary']
  }

  export interface TypeBackground {
    main: string
    light: string
  }

  // Custom color properties
  export interface PaletteColor {
    background?: string
  }

  export interface SimplePaletteColorOptions {
    background?: string
  }
}

declare module '@mui/material/SvgIcon' {
  export interface SvgIconPropsColorOverrides {
    border: unknown
  }
}

declare module '@mui/material/Button' {
  export interface ButtonPropsSizeOverrides {
    stretched: true
    compact: true
  }

  export interface ButtonPropsColorOverrides {
    background: true
  }

  export interface ButtonPropsVariantOverrides {
    danger: true
  }
}

declare module '@mui/material/IconButton' {
  export interface IconButtonPropsColorOverrides {
    border: true
  }
}

const createSafeTheme = (mode: PaletteMode): Theme => {
  const isDarkMode = mode === 'dark'
  const colors = isDarkMode ? darkPalette : palette
  const shadowColor = colors.primary.light

  return createTheme({
    palette: {
      mode: isDarkMode ? 'dark' : 'light',
      ...colors,
    },
    spacing: base,
    shape: {
      borderRadius: 6,
    },
    shadows: [
      'none',
      isDarkMode ? `0 0 2px ${shadowColor}` : `0 1px 4px ${shadowColor}0a, 0 4px 10px ${shadowColor}14`,
      isDarkMode ? `0 0 2px ${shadowColor}` : `0 1px 4px ${shadowColor}0a, 0 4px 10px ${shadowColor}14`,
      isDarkMode ? `0 0 2px ${shadowColor}` : `0 2px 20px ${shadowColor}0a, 0 8px 32px ${shadowColor}14`,
      isDarkMode ? `0 0 2px ${shadowColor}` : `0 8px 32px ${shadowColor}0a, 0 24px 60px ${shadowColor}14`,
      ...Array(20).fill('none'),
    ] as Shadows,
    typography,
    components: {
      MuiTableCell: {
        styleOverrides: {
          head: ({ theme }) => ({
            ...theme.typography.body1,
            color: theme.palette.primary.light,
          }),
        },
      },
      MuiButton: {
        variants: [
          {
            props: { size: 'compact' },
            style: {
              padding: '8px 12px',
            },
          },
          {
            props: { size: 'stretched' },
            style: {
              padding: '12px 48px',
            },
          },
          {
            props: { variant: 'danger' },
            style: ({ theme }) => ({
              backgroundColor: theme.palette.error.background,
              color: theme.palette.error.main,
              '&:hover': {
                color: theme.palette.error.dark,
                backgroundColor: theme.palette.error.light,
              },
            }),
          },
        ],
        styleOverrides: {
          sizeSmall: {
            fontSize: '14px',
            padding: '8px 24px',
          },
          sizeMedium: {
            fontSize: '16px',
            padding: '12px 24px',
          },
          root: ({ theme }) => ({
            borderRadius: theme.shape.borderRadius,
            fontWeight: 'bold',
            lineHeight: 1.25,
            borderColor: theme.palette.primary.main,
            textTransform: 'none',
            '&:hover': {
              boxShadow: 'none',
            },
          }),
          outlined: {
            border: '2px solid',
            '&:hover': {
              border: '2px solid',
            },
          },
          sizeLarge: { fontSize: '16px' },
        },
      },
      MuiAccordion: {
        variants: [
          {
            props: { variant: 'elevation' },
            style: ({ theme }) => ({
              border: 'none',
              boxShadow: '0',
              '&:not(:last-of-type)': {
                borderRadius: '0 !important',
                borderBottom: `1px solid ${theme.palette.border.light}`,
              },
              '&:last-of-type': {
                borderBottomLeftRadius: '8px',
              },
            }),
          },
        ],
        styleOverrides: {
          root: ({ theme }) => ({
            transition: 'background 0.2s, border 0.2s',
            borderRadius: theme.shape.borderRadius,
            border: `1px solid ${theme.palette.border.light}`,
            overflow: 'hidden',

            '&::before': {
              content: 'none',
            },

            '&:hover': {
              borderColor: theme.palette.secondary.light,
            },

            '&:hover > .MuiAccordionSummary-root': {
              background: theme.palette.background.light,
            },

            '&.Mui-expanded': {
              margin: 0,
              borderColor: theme.palette.secondary.light,
            },
          }),
        },
      },
      MuiAccordionSummary: {
        styleOverrides: {
          root: ({ theme }) => ({
            '&.Mui-expanded': {
              minHeight: '48px',
              background: theme.palette.background.light,
            },
          }),
          content: {
            '&.Mui-expanded': {
              margin: '12px 0',
            },
          },
        },
      },
      MuiAccordionDetails: {
        styleOverrides: {
          root: ({ theme }) => ({
            padding: theme.spacing(2),
          }),
        },
      },
      MuiCard: {
        styleOverrides: {
          root: ({ theme }) => ({
            borderRadius: theme.shape.borderRadius,
            boxSizing: 'border-box',
            border: '2px solid transparent',
            boxShadow: 'none',
          }),
        },
      },
      MuiDialog: {
        defaultProps: {
          fullWidth: true,
        },
      },
      MuiDialogContent: {
        styleOverrides: {
          root: ({ theme }) => ({
            padding: theme.spacing(3),
          }),
        },
      },
      MuiDivider: {
        styleOverrides: {
          root: ({ theme }) => ({
            borderColor: theme.palette.border.light,
          }),
        },
      },
      MuiPaper: {
        defaultProps: {
          elevation: 0,
        },
        styleOverrides: {
          outlined: ({ theme }) => ({
            borderWidth: 2,
            borderColor: theme.palette.border.light,
          }),
          root: ({ theme }) => ({
            borderRadius: theme.shape.borderRadius,
            backgroundImage: 'none',
          }),
        },
      },
      MuiPopover: {
        defaultProps: {
          elevation: 2,
        },
        styleOverrides: {
          paper: {
            overflow: 'visible',
          },
        },
      },
      MuiIconButton: {
        styleOverrides: {
          sizeSmall: {
            padding: '4px',
          },
        },
      },
      MuiToggleButton: {
        styleOverrides: {
          root: {
            textTransform: 'none',
          },
        },
      },
      MuiChip: {
        styleOverrides: {
          colorSuccess: ({ theme }) => ({
            backgroundColor: theme.palette.secondary.light,
            height: '24px',
          }),
        },
      },
      MuiAlert: {
        styleOverrides: {
          standardError: ({ theme }) => ({
            '& .MuiAlert-icon': {
              color: theme.palette.error.main,
            },
            '&.MuiPaper-root': {
              backgroundColor: theme.palette.error.background,
            },
          }),
          standardInfo: ({ theme }) => ({
            '& .MuiAlert-icon': {
              color: theme.palette.info.main,
            },
            '&.MuiPaper-root': {
              backgroundColor: theme.palette.info.background,
            },
          }),
          standardSuccess: ({ theme }) => ({
            '& .MuiAlert-icon': {
              color: theme.palette.success.main,
            },
            '&.MuiPaper-root': {
              backgroundColor: theme.palette.success.background,
            },
          }),
          standardWarning: ({ theme }) => ({
            '& .MuiAlert-icon': {
              color: theme.palette.warning.main,
            },
            '&.MuiPaper-root': {
              backgroundColor: theme.palette.warning.background,
            },
          }),
          root: ({ theme }) => ({
            color: theme.palette.text.primary,
            padding: '12px 16px',
          }),
        },
      },
      MuiTableHead: {
        styleOverrides: {
          root: ({ theme }) => ({
            '& .MuiTableCell-root': {
              borderBottom: `1px solid ${theme.palette.border.light}`,
            },

            [theme.breakpoints.down('sm')]: {
              '& .MuiTableCell-root:first-of-type': {
                paddingRight: theme.spacing(1),
              },

              '& .MuiTableCell-root:not(:first-of-type):not(:last-of-type)': {
                paddingLeft: theme.spacing(1),
                paddingRight: theme.spacing(1),
              },

              '& .MuiTableCell-root:last-of-type': {
                paddingLeft: theme.spacing(1),
              },
            },
          }),
        },
      },
      MuiTableBody: {
        styleOverrides: {
          root: ({ theme }) => ({
            '& .MuiTableCell-root': {
              paddingTop: theme.spacing(1),
              paddingBottom: theme.spacing(1),
              borderBottom: 'none',
            },

            [theme.breakpoints.down('sm')]: {
              '& .MuiTableCell-root:first-of-type': {
                paddingRight: theme.spacing(1),
              },

              '& .MuiTableCell-root:not(:first-of-type):not(:last-of-type)': {
                paddingLeft: theme.spacing(1),
                paddingRight: theme.spacing(1),
              },

              '& .MuiTableCell-root:last-of-type': {
                paddingLeft: theme.spacing(1),
              },
            },

            '& .MuiTableRow-root': {
              transition: 'background-color 0.2s',
              '&:not(:last-of-type)': {
                borderBottom: `1px solid ${theme.palette.border.light}`,
              },
            },

            '& .MuiTableRow-root:hover': {
              backgroundColor: theme.palette.background.light,
            },
            '& .MuiTableRow-root.Mui-selected': {
              backgroundColor: theme.palette.background.light,
            },
          }),
        },
      },
      MuiCheckbox: {
        styleOverrides: {
          root: ({ theme }) => ({
            color: theme.palette.primary.main,
          }),
        },
      },
      MuiOutlinedInput: {
        styleOverrides: {
          notchedOutline: ({ theme }) => ({
            borderColor: theme.palette.border.main,
          }),
          root: ({ theme }) => ({
            borderColor: theme.palette.border.main,
          }),
        },
      },
      MuiSvgIcon: {
        styleOverrides: {
          fontSizeSmall: {
            width: '1rem',
            height: '1rem',
          },
        },
      },
      MuiFilledInput: {
        styleOverrides: {
          root: ({ theme }) => ({
            borderRadius: 4,
            backgroundColor: theme.palette.background.paper,
            border: '1px solid transparent',
            transition: 'border-color 0.2s',

            '&:hover, &:focus, &.Mui-focused': {
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.primary.main,
            },
          }),
        },
      },
      MuiSelect: {
        defaultProps: {
          MenuProps: {
            sx: {
              '& .MuiPaper-root': {
                overflow: 'auto',
              },
            },
          },
        },
      },
      MuiTooltip: {
        styleOverrides: {
          tooltip: ({ theme }) => ({
            ...theme.typography.body2,
            color: theme.palette.background.main,
            backgroundColor: theme.palette.text.primary,
            '& .MuiLink-root': {
              color: isDarkMode ? theme.palette.background.main : theme.palette.secondary.main,
              textDecorationColor: isDarkMode ? theme.palette.background.main : theme.palette.secondary.main,
            },
            '& .MuiLink-root:hover': {
              color: isDarkMode ? theme.palette.text.secondary : theme.palette.secondary.light,
            },
          }),
          arrow: ({ theme }) => ({
            color: theme.palette.text.primary,
          }),
        },
      },
      MuiBackdrop: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: alpha(theme.palette.backdrop.main, 0.75),
          }),
        },
      },
      MuiSwitch: {
        defaultProps: {
          color: isDarkMode ? undefined : 'success',
        },
        styleOverrides: {
          thumb: () => ({
            boxShadow:
              '0px 2px 6px -1px rgba(0, 0, 0, 0.2), 0px 1px 4px rgba(0, 0, 0, 0.14), 0px 1px 4px rgba(0, 0, 0, 0.14)',
          }),
        },
      },
      MuiLink: {
        styleOverrides: {
          root: ({ theme }) => ({
            fontWeight: 700,
            '&:hover': {
              color: theme.palette.primary.light,
            },
          }),
        },
      },
      MuiLinearProgress: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.border.light,
          }),
        },
      },
    },
  })
}

export default createSafeTheme
</file>

<file path="src/components/theme/SafeThemeProvider.tsx">
import { useMemo, type FC } from 'react'
import { type PaletteMode, type Theme, ThemeProvider } from '@mui/material'
import createSafeTheme from './safeTheme'

// This component is necessary to make the theme available in the library components
// Is not enough wrapping the client app with the regular ThemeProvider as the library components
// are not aware of the theme context:
// https://github.com/mui/material-ui/issues/32806
// https://stackoverflow.com/questions/69072004/material-ui-theme-not-working-in-shared-component
type SafeThemeProviderProps = {
  children: (theme: Theme) => React.ReactNode
  mode: PaletteMode
}

const SafeThemeProvider: FC<SafeThemeProviderProps> = ({ children, mode }) => {
  const theme = useMemo(() => createSafeTheme(mode), [mode])

  return <ThemeProvider theme={theme}>{children(theme)}</ThemeProvider>
}

export default SafeThemeProvider
</file>

<file path="src/components/theme/typography.ts">
import type { TypographyOptions } from '@mui/material/styles/createTypography'

const safeFontFamily = 'DM Sans, sans-serif'

const typography: TypographyOptions = {
  fontFamily: safeFontFamily,
  h1: {
    fontSize: '32px',
    lineHeight: '36px',
    fontWeight: 700,
  },
  h2: {
    fontSize: '27px',
    lineHeight: '34px',
    fontWeight: 700,
  },
  h3: {
    fontSize: '24px',
    lineHeight: '30px',
  },
  h4: {
    fontSize: '20px',
    lineHeight: '26px',
  },
  h5: {
    fontSize: '16px',
    fontWeight: 700,
  },
  body1: {
    fontSize: '16px',
    lineHeight: '22px',
  },
  body2: {
    fontSize: '14px',
    lineHeight: '20px',
  },
  caption: {
    fontSize: '12px',
    lineHeight: '16px',
    letterSpacing: '0.4px',
  },
  overline: {
    fontSize: '11px',
    lineHeight: '14px',
    textTransform: 'uppercase',
    letterSpacing: '1px',
  },
}

export default typography
</file>

<file path="src/components/transactions/BatchExecuteButton/BatchExecuteHoverProvider.tsx">
import type { ReactElement, ReactNode } from 'react'
import { createContext, useState } from 'react'

export const BatchExecuteHoverContext = createContext<{
  activeHover: string[]
  setActiveHover: (activeHover: string[]) => void
}>({
  activeHover: [],
  setActiveHover: () => {},
})

// Used for highlighting transactions that will be included when executing them as a batch
export const BatchExecuteHoverProvider = ({ children }: { children: ReactNode }): ReactElement => {
  const [activeHover, setActiveHover] = useState<string[]>([])

  return (
    <BatchExecuteHoverContext.Provider value={{ activeHover, setActiveHover }}>
      {children}
    </BatchExecuteHoverContext.Provider>
  )
}
</file>

<file path="src/components/transactions/BatchExecuteButton/index.tsx">
import { useCallback, useContext } from 'react'
import { Button, Tooltip } from '@mui/material'
import { BatchExecuteHoverContext } from '@/components/transactions/BatchExecuteButton/BatchExecuteHoverProvider'
import { useAppSelector } from '@/store'
import { selectPendingTxs } from '@/store/pendingTxsSlice'
import useBatchedTxs from '@/hooks/useBatchedTxs'
import { ExecuteBatchFlow } from '@/components/tx-flow/flows'
import { trackEvent } from '@/services/analytics'
import { TX_LIST_EVENTS } from '@/services/analytics/events/txList'
import useWallet from '@/hooks/wallets/useWallet'
import useTxQueue from '@/hooks/useTxQueue'
import { TxModalContext } from '@/components/tx-flow'

const BatchExecuteButton = () => {
  const { setTxFlow } = useContext(TxModalContext)
  const pendingTxs = useAppSelector(selectPendingTxs)
  const hoverContext = useContext(BatchExecuteHoverContext)
  const { page } = useTxQueue()
  const batchableTransactions = useBatchedTxs(page?.results || [])
  const wallet = useWallet()

  const isBatchable = batchableTransactions.length > 1
  const hasPendingTx = batchableTransactions.some((tx) => pendingTxs[tx.transaction.id])
  const isDisabled = !isBatchable || hasPendingTx || !wallet

  const handleOnMouseEnter = useCallback(() => {
    hoverContext.setActiveHover(batchableTransactions.map((tx) => tx.transaction.id))
  }, [batchableTransactions, hoverContext])

  const handleOnMouseLeave = useCallback(() => {
    hoverContext.setActiveHover([])
  }, [hoverContext])

  const handleOpenModal = () => {
    trackEvent({
      ...TX_LIST_EVENTS.BATCH_EXECUTE,
      label: batchableTransactions.length,
    })

    setTxFlow(<ExecuteBatchFlow txs={batchableTransactions} />, undefined, false)
  }

  return (
    <>
      <Tooltip
        placement="top-start"
        arrow
        title={
          isDisabled
            ? 'Batch execution is only available for transactions that have been fully signed and are strictly sequential in Safe Account nonce.'
            : 'All highlighted transactions will be included in the batch execution.'
        }
      >
        <span>
          <Button
            onMouseEnter={handleOnMouseEnter}
            onMouseLeave={handleOnMouseLeave}
            variant="contained"
            size="small"
            disabled={isDisabled}
            onClick={handleOpenModal}
          >
            Bulk execute{isBatchable && ` ${batchableTransactions.length} transactions`}
          </Button>
        </span>
      </Tooltip>
    </>
  )
}

export default BatchExecuteButton
</file>

<file path="src/components/transactions/BulkTxListGroup/index.tsx">
import type { ReactElement } from 'react'
import { Box, Paper, SvgIcon, Typography } from '@mui/material'
import type { Order, Transaction } from '@safe-global/safe-gateway-typescript-sdk'
import { isMultisigExecutionInfo, isSwapTransferOrderTxInfo } from '@/utils/transaction-guards'
import ExpandableTransactionItem from '@/components/transactions/TxListItem/ExpandableTransactionItem'
import BatchIcon from '@/public/images/common/batch.svg'
import css from './styles.module.css'
import ExplorerButton from '@/components/common/ExplorerButton'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import { useCurrentChain } from '@/hooks/useChains'
import { getOrderClass } from '@/features/swap/helpers/utils'

const orderClassTitles: Record<string, string> = {
  limit: 'Limit order settlement',
  twap: 'TWAP order settlement',
  liquidity: 'Liquidity order settlement',
  market: 'Swap order settlement',
}

const getSettlementOrderTitle = (order: Order): string => {
  const orderClass = getOrderClass(order)
  return orderClassTitles[orderClass] || orderClassTitles['market']
}

const GroupedTxListItems = ({
  groupedListItems,
  transactionHash,
}: {
  groupedListItems: Transaction[]
  transactionHash: string
}): ReactElement | null => {
  const chain = useCurrentChain()
  const explorerLink = chain && getBlockExplorerLink(chain, transactionHash)?.href
  if (groupedListItems.length === 0) return null
  let title = 'Bulk transactions'
  const isSwapTransfer = isSwapTransferOrderTxInfo(groupedListItems[0].transaction.txInfo)
  if (isSwapTransfer) {
    title = getSettlementOrderTitle(groupedListItems[0].transaction.txInfo as Order)
  }
  return (
    <Paper data-testid="grouped-items" className={css.container}>
      <Box gridArea="icon">
        <SvgIcon className={css.icon} component={BatchIcon} inheritViewBox fontSize="medium" />
      </Box>
      <Box gridArea="info">
        <Typography noWrap>{title}</Typography>
      </Box>
      <Box className={css.action}>{groupedListItems.length} transactions</Box>
      <Box className={css.hash}>
        <ExplorerButton href={explorerLink} isCompact={false} />
      </Box>

      <Box gridArea="items" className={css.txItems}>
        {groupedListItems.map((tx) => {
          const nonce = isMultisigExecutionInfo(tx.transaction.executionInfo) ? tx.transaction.executionInfo.nonce : ''
          return (
            <Box position="relative" key={tx.transaction.id}>
              <Box className={css.nonce}>
                <Typography className={css.nonce}>{nonce}</Typography>
              </Box>
              <ExpandableTransactionItem item={tx} isBulkGroup={true} />
            </Box>
          )
        })}
      </Box>
    </Paper>
  )
}

export default GroupedTxListItems
</file>

<file path="src/components/transactions/BulkTxListGroup/styles.module.css">
.container {
  position: relative;
  padding: var(--space-2);
  display: grid;
  align-items: center;
  grid-template-columns: minmax(50px, 0.25fr) minmax(240px, 2fr) minmax(150px, 4fr) minmax(170px, 1fr);
  grid-template-areas:
    'icon info action hash'
    'nonce items items items';
}

.action {
  margin-left: var(--space-2);
  grid-area: action;
  color: var(--color-text-secondary);
}

.hash {
  grid-area: hash;
  display: grid;
  justify-content: flex-end;
}

.nonce {
  position: absolute;
  left: -24px;
  top: var(--space-1);
}

.txItems {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
  margin-top: var(--space-2);
}

.txItems :global(.MuiAccordion-root) {
  border-color: var(--color-border-light);
}

@media (max-width: 699px) {
  .container {
    grid-template-columns: minmax(30px, 0.25fr) minmax(230px, 3fr);
    grid-template-areas:
      'icon info '
      'nonce action'
      'nonce hash '
      'nonce items';
  }

  .action {
    margin: 0;
  }
  .hash {
    justify-content: flex-start;
  }
  .nonce {
    left: -16px;
  }
}
</file>

<file path="src/components/transactions/ExecuteTxButton/index.tsx">
import useIsExpiredSwap from '@/features/swap/hooks/useIsExpiredSwap'
import useIsPending from '@/hooks/useIsPending'
import type { SyntheticEvent } from 'react'
import { type ReactElement, useContext } from 'react'
import { type TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Button, Tooltip } from '@mui/material'

import useSafeInfo from '@/hooks/useSafeInfo'
import { isMultisigExecutionInfo } from '@/utils/transaction-guards'
import Track from '@/components/common/Track'
import { TX_LIST_EVENTS } from '@/services/analytics/events/txList'
import { ReplaceTxHoverContext } from '../GroupedTxListItems/ReplaceTxHoverProvider'
import CheckWallet from '@/components/common/CheckWallet'
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { TxModalContext } from '@/components/tx-flow'
import { ConfirmTxFlow } from '@/components/tx-flow/flows'

const ExecuteTxButton = ({
  txSummary,
  compact = false,
}: {
  txSummary: TransactionSummary
  compact?: boolean
}): ReactElement => {
  const { setTxFlow } = useContext(TxModalContext)
  const { safe } = useSafeInfo()
  const txNonce = isMultisigExecutionInfo(txSummary.executionInfo) ? txSummary.executionInfo.nonce : undefined
  const isPending = useIsPending(txSummary.id)
  const { setSelectedTxId } = useContext(ReplaceTxHoverContext)
  const safeSDK = useSafeSDK()

  const expiredSwap = useIsExpiredSwap(txSummary.txInfo)

  const isNext = txNonce !== undefined && txNonce === safe.nonce
  const isDisabled = !isNext || !safeSDK || expiredSwap || isPending

  const onClick = (e: SyntheticEvent) => {
    e.stopPropagation()
    e.preventDefault()
    setTxFlow(<ConfirmTxFlow txSummary={txSummary} />, undefined, false)
  }

  const onMouseEnter = () => {
    setSelectedTxId(txSummary.id)
  }

  const onMouseLeave = () => {
    setSelectedTxId(undefined)
  }

  return (
    <>
      <CheckWallet allowNonOwner>
        {(isOk) => (
          <Tooltip title={isOk && !isNext ? 'You must execute the transaction with the lowest nonce first' : ''}>
            <span>
              <Track {...TX_LIST_EVENTS.EXECUTE}>
                <Button
                  onClick={onClick}
                  onMouseEnter={onMouseEnter}
                  onMouseLeave={onMouseLeave}
                  variant="contained"
                  disabled={!isOk || isDisabled}
                  size={compact ? 'small' : 'stretched'}
                  sx={{ minWidth: '106.5px', py: compact ? 0.8 : undefined }}
                >
                  Execute
                </Button>
              </Track>
            </span>
          </Tooltip>
        )}
      </CheckWallet>
    </>
  )
}

export default ExecuteTxButton
</file>

<file path="src/components/transactions/GroupedTxListItems/index.tsx">
import type { ReactElement } from 'react'
import { useContext } from 'react'
import { Box, Paper, Typography } from '@mui/material'
import type { Transaction } from '@safe-global/safe-gateway-typescript-sdk'
import { isMultisigExecutionInfo } from '@/utils/transaction-guards'
import ExpandableTransactionItem from '@/components/transactions/TxListItem/ExpandableTransactionItem'
import css from './styles.module.css'
import { ReplaceTxHoverContext, ReplaceTxHoverProvider } from './ReplaceTxHoverProvider'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'

const Disclaimer = () => (
  <Typography>
    <b>Conflicting transactions</b>. Executing one will automatically replace the others.{' '}
    <ExternalLink
      href={HelpCenterArticle.CONFLICTING_TRANSACTIONS}
      title="Why are transactions with the same nonce conflicting with each other?"
      noIcon
    >
      Why did this happen?
    </ExternalLink>
  </Typography>
)

const TxGroup = ({ groupedListItems }: { groupedListItems: Transaction[] }): ReactElement => {
  const nonce = isMultisigExecutionInfo(groupedListItems[0].transaction.executionInfo)
    ? groupedListItems[0].transaction.executionInfo.nonce
    : undefined

  const { replacedTxIds } = useContext(ReplaceTxHoverContext)

  return (
    <Paper className={css.container}>
      <Typography
        sx={{
          gridArea: 'nonce',
        }}
      >
        {nonce}
      </Typography>
      <Box
        className={css.disclaimerContainer}
        sx={{
          gridArea: 'warning',
        }}
      >
        <Disclaimer />
      </Box>
      <Box
        className={css.line}
        sx={{
          gridArea: 'line',
        }}
      />
      <Box
        className={css.txItems}
        sx={{
          gridArea: 'items',
        }}
      >
        {groupedListItems.map((tx) => (
          <div
            key={tx.transaction.id}
            className={replacedTxIds.includes(tx.transaction.id) ? css.willBeReplaced : undefined}
          >
            <ExpandableTransactionItem item={tx} isConflictGroup />
          </div>
        ))}
      </Box>
    </Paper>
  )
}

const GroupedTxListItems = ({ groupedListItems }: { groupedListItems: Transaction[] }): ReactElement | null => {
  if (groupedListItems.length === 0) return null

  return (
    <ReplaceTxHoverProvider groupedListItems={groupedListItems}>
      <TxGroup groupedListItems={groupedListItems} />
    </ReplaceTxHoverProvider>
  )
}

export default GroupedTxListItems
</file>

<file path="src/components/transactions/GroupedTxListItems/ReplaceTxHoverProvider.tsx">
import { createContext, useMemo, useState, type Dispatch, type ReactElement, type SetStateAction } from 'react'
import type { Transaction } from '@safe-global/safe-gateway-typescript-sdk'

import { useAppSelector } from '@/store'
import { selectPendingTxs } from '@/store/pendingTxsSlice'

export const ReplaceTxHoverContext = createContext<{
  replacedTxIds: string[]
  setSelectedTxId: Dispatch<SetStateAction<string | undefined>>
}>({
  replacedTxIds: [],
  setSelectedTxId: () => {},
})

// Used for striking through transactions that will be replaced
export const ReplaceTxHoverProvider = ({
  groupedListItems,
  children,
}: {
  groupedListItems: Transaction[]
  children: ReactElement
}): ReactElement => {
  const [selectedTxId, setSelectedTxId] = useState<string>()
  const pendingTxs = useAppSelector(selectPendingTxs)

  const replacedTxIds = useMemo(() => {
    const pendingTxInGroup = groupedListItems.find((item) => pendingTxs[item.transaction.id])

    const disabledItems = groupedListItems
      .filter((item) => {
        const { id } = item.transaction

        const willBeReplaced = selectedTxId && selectedTxId !== id
        const isReplacing = pendingTxInGroup && id !== pendingTxInGroup.transaction.id

        return willBeReplaced || isReplacing
      })
      .map((item) => item.transaction.id)

    return disabledItems
  }, [groupedListItems, pendingTxs, selectedTxId])

  return (
    <ReplaceTxHoverContext.Provider
      value={{
        replacedTxIds,
        setSelectedTxId,
      }}
    >
      {children}
    </ReplaceTxHoverContext.Provider>
  )
}
</file>

<file path="src/components/transactions/GroupedTxListItems/styles.module.css">
.container {
  position: relative;
  padding: var(--space-2);
  border: 1px solid var(--color-warning-light);
  display: grid;
  align-items: center;
  grid-template-columns: minmax(50px, 0.25fr) minmax(150px, 2fr) minmax(150px, 2fr) minmax(200px, 2fr) 1fr minmax(
      170px,
      1fr
    );
  grid-template-areas:
    'nonce warning warning warning warning warning'
    'line items items items items items';
}

.disclaimerContainer {
  background-color: var(--color-warning-background);
  padding: var(--space-1) var(--space-2);
  border-radius: var(--space-1);
  flex: 1;
}

.disclaimerContainer a {
  color: inherit;
}

.disclaimerContainer a > * {
  text-decoration: underline;
}

.line {
  border-left: 1px solid var(--color-border-light);
  border-bottom: 1px solid var(--color-border-light);
  border-radius: 0 0 0 4px;
  height: calc(100% - 29px);
  width: 100%;
  position: absolute;
  top: 0;
  margin-left: 9px;
}

.txItems {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
  margin-top: var(--space-2);
}

.txItems :global(.MuiAccordion-root) {
  border-color: var(--color-border-light);
}

.txItems > div {
  position: relative;
}

.txItems > div:not(:last-child)::before {
  content: '';
  position: absolute;
  border-top: 1px solid var(--color-border-light);
  width: 40px;
  left: -40px;
  top: 50%;
  transform: translateY(-50%);
}

.willBeReplaced {
  filter: grayscale(1);
  opacity: 0.6;
  pointer-events: none;
}

.willBeReplaced * {
  text-decoration: line-through;
}

@media (max-width: 1024px) {
  .line,
  .txItems > div::before {
    display: none;
  }
  .container {
    gap: var(--space-1);
    grid-template-columns: 1fr;
    grid-template-areas:
      'nonce warning warning'
      'items items items';
  }
}
</file>

<file path="src/components/transactions/GroupLabel/index.tsx">
import type { ReactElement } from 'react'
import type { Label } from '@safe-global/safe-gateway-typescript-sdk'
import { LabelValue } from '@safe-global/safe-gateway-typescript-sdk'
import css from './styles.module.css'
import useSafeInfo from '@/hooks/useSafeInfo'

const GroupLabel = ({ item }: { item: Label }): ReactElement => {
  const { safe } = useSafeInfo()

  const label =
    item.label === LabelValue.Queued
      ? `${item.label} - transaction with nonce ${safe.nonce} needs to be executed first`
      : item.label

  return <div className={css.container}>{label}</div>
}

export default GroupLabel
</file>

<file path="src/components/transactions/GroupLabel/styles.module.css">
.container {
  font-size: 0.76em;
  font-weight: 600;
  line-height: 1.5;
  letter-spacing: 1px;
  color: rgb(93, 109, 116);
  text-transform: uppercase;
  margin-top: 20px;
  margin-bottom: 4px;
}
</file>

<file path="src/components/transactions/HexEncodedData/index.tsx">
import { shortenText } from '@safe-global/utils/utils/formatters'
import { Box, Link, Tooltip } from '@mui/material'
import type { ReactElement, SyntheticEvent } from 'react'
import { Fragment, useState } from 'react'
import css from './styles.module.css'
import CopyButton from '@/components/common/CopyButton'
import FieldsGrid from '@/components/tx/FieldsGrid'

interface Props {
  hexData: string
  highlightFirstBytes?: boolean
  title?: string
  limit?: number
}

const FIRST_BYTES = 10

const SHOW_MORE = 'Show more'
const SHOW_LESS = 'Show less'

export const HexEncodedData = ({ hexData, title, highlightFirstBytes = true, limit = 20 }: Props): ReactElement => {
  const [showTxData, setShowTxData] = useState(false)
  // Check if
  const showExpandBtn = hexData.length > limit + SHOW_MORE.length + 2 // 2 for the space and the ellipsis

  const toggleExpanded = (e: SyntheticEvent) => {
    e.stopPropagation()
    e.preventDefault()
    setShowTxData((val) => !val)
  }

  const firstBytes = highlightFirstBytes ? (
    <Tooltip title="The first 4 bytes determine the contract method that is being called" arrow>
      <b>{hexData.slice(0, FIRST_BYTES)}</b>
    </Tooltip>
  ) : null
  const restBytes = highlightFirstBytes ? hexData.slice(FIRST_BYTES) : hexData

  const dimmedZeroes: ReactElement[] = []
  let index = 0
  restBytes.replace(/(.*?)(0{18,})(.*?)/g, (_, p1, p2, p3) => {
    dimmedZeroes.push(
      <Fragment key={index++}>{p1}</Fragment>,
      <span className={css.zeroes} key={index++}>
        {p2}
      </span>,
      <Fragment key={index++}>{p3}</Fragment>,
    )
    return ''
  })

  const fullData = dimmedZeroes.length ? dimmedZeroes : restBytes

  const content = (
    <Box data-testid="tx-hexData" className={css.encodedData}>
      <CopyButton text={hexData}>
        <span className={css.monospace}>
          {firstBytes}
          {showTxData || !showExpandBtn ? fullData : shortenText(restBytes, limit - FIRST_BYTES)}{' '}
        </span>
      </CopyButton>

      {showExpandBtn && (
        <Link
          component="button"
          data-testid="show-more"
          onClick={toggleExpanded}
          type="button"
          className={css.showMore}
        >
          {showTxData ? SHOW_LESS : SHOW_MORE}
        </Link>
      )}
    </Box>
  )

  return title ? <FieldsGrid title={title}>{content}</FieldsGrid> : content
}
</file>

<file path="src/components/transactions/HexEncodedData/styles.module.css">
.encodedData {
  line-break: anywhere;
  word-break: break-all;
  line-height: 1.1;
}

.showMore {
  white-space: nowrap;
}

.monospace {
  font-family: monospace;
}

.zeroes {
  opacity: 0.75;
}
</file>

<file path="src/components/transactions/ImitationTransactionWarning/index.tsx">
import type { ReactElement } from 'react'
import { Alert, SvgIcon } from '@mui/material'

import InfoOutlinedIcon from '@/public/images/notifications/info.svg'
import css from './styles.module.css'

export const ImitationTransactionWarning = (): ReactElement => {
  return (
    <Alert
      className={css.alert}
      sx={{ borderLeft: ({ palette }) => `3px solid ${palette['error'].main} !important` }}
      severity="error"
      icon={<SvgIcon component={InfoOutlinedIcon} inheritViewBox color="error" />}
    >
      <b>This may be a malicious transaction.</b> Check and confirm the address before interacting with it.{' '}
    </Alert>
  )
}
</file>

<file path="src/components/transactions/ImitationTransactionWarning/styles.module.css">
.alert {
  padding: 0px 10px;
}
</file>

<file path="src/components/transactions/InfoDetails/index.tsx">
import { Typography } from '@mui/material'
import type { ReactElement, ReactNode } from 'react'
import css from './styles.module.css'

type InfoDetailsProps = {
  datatestid?: String
  children?: ReactNode
  title: string | ReactElement
}

export const InfoDetails = ({ datatestid, children, title }: InfoDetailsProps): ReactElement => (
  <div data-testid={datatestid} className={css.container}>
    <Typography>
      <b>{title}</b>
    </Typography>
    {children}
  </div>
)
</file>

<file path="src/components/transactions/InfoDetails/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 16px;
}

.container:last-of-type {
  margin-bottom: 0;
}
</file>

<file path="src/components/transactions/MaliciousTxWarning/index.tsx">
import { Tooltip, SvgIcon, Box } from '@mui/material'
import WarningIcon from '@/public/images/notifications/warning.svg'

const MaliciousTxWarning = ({ withTooltip = true }: { withTooltip?: boolean }) => {
  return withTooltip ? (
    <Tooltip title="This token isn’t verified on major token lists and may pose risks when interacting with it or involved addresses">
      <Box lineHeight="16px">
        <SvgIcon component={WarningIcon} fontSize="small" inheritViewBox color="warning" />
      </Box>
    </Tooltip>
  ) : (
    <Box lineHeight="16px">
      <SvgIcon component={WarningIcon} fontSize="small" inheritViewBox color="warning" />
    </Box>
  )
}

export default MaliciousTxWarning
</file>

<file path="src/components/transactions/RejectTxButton/index.tsx">
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Button } from '@mui/material'

import type { ReactElement } from 'react'
import { useContext } from 'react'
import { isMultisigExecutionInfo } from '@/utils/transaction-guards'
import useIsPending from '@/hooks/useIsPending'
import Track from '@/components/common/Track'
import { TX_LIST_EVENTS } from '@/services/analytics/events/txList'
import CheckWallet from '@/components/common/CheckWallet'
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { TxModalContext } from '@/components/tx-flow'
import { ReplaceTxFlow } from '@/components/tx-flow/flows'

const RejectTxButton = ({
  txSummary,
  safeTxHash,
  proposer,
}: {
  txSummary: TransactionSummary
  safeTxHash?: string
  proposer?: string
}): ReactElement | null => {
  const { setTxFlow } = useContext(TxModalContext)
  const txNonce = isMultisigExecutionInfo(txSummary.executionInfo) ? txSummary.executionInfo.nonce : undefined
  const isPending = useIsPending(txSummary.id)
  const safeSDK = useSafeSDK()
  const isDisabled = isPending || !safeSDK

  const openReplacementModal = () => {
    if (txNonce === undefined) return
    setTxFlow(<ReplaceTxFlow txNonce={txNonce} safeTxHash={safeTxHash} proposer={proposer} />, undefined, false)
  }

  return (
    <CheckWallet>
      {(isOk) => (
        <Track {...TX_LIST_EVENTS.REJECT}>
          <Button
            data-testid="reject-btn"
            onClick={openReplacementModal}
            variant="danger"
            disabled={!isOk || isDisabled}
            size="stretched"
          >
            Reject
          </Button>
        </Track>
      )}
    </CheckWallet>
  )
}

export default RejectTxButton
</file>

<file path="src/components/transactions/SafeCreationTx/index.tsx">
import React from 'react'
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Box } from '@mui/system'
import css from './styles.module.css'
import { InfoDetails } from '@/components/transactions/InfoDetails'
import EthHashInfo from '@/components/common/EthHashInfo'
import { generateDataRowValue, TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { dateString } from '@safe-global/utils/utils/formatters'
import { isCreationTxInfo } from '@/utils/transaction-guards'
import { NOT_AVAILABLE } from '@/components/transactions/TxDetails'

type SafeCreationTxProps = {
  txSummary: TransactionSummary
}

const SafeCreationTx = ({ txSummary }: SafeCreationTxProps) => {
  if (!isCreationTxInfo(txSummary.txInfo)) return null

  const timestamp = txSummary.timestamp
  const { creator, factory, implementation, transactionHash } = txSummary.txInfo

  return (
    <>
      <Box className={css.txCreation}>
        <InfoDetails title="Creator:">
          <EthHashInfo address={creator.value} shortAddress={false} showCopyButton hasExplorer />
        </InfoDetails>
        <InfoDetails title="Factory:">
          {factory ? (
            <EthHashInfo name={factory.name} address={factory.value} shortAddress={false} showCopyButton hasExplorer />
          ) : (
            NOT_AVAILABLE
          )}
        </InfoDetails>
        <InfoDetails title="Mastercopy:">
          {implementation ? (
            <EthHashInfo
              name={implementation.name}
              address={implementation.value}
              shortAddress={false}
              showCopyButton
              hasExplorer
            />
          ) : (
            NOT_AVAILABLE
          )}
        </InfoDetails>
      </Box>
      <Box className={css.txSummary}>
        <TxDataRow title="Transaction hash:">{generateDataRowValue(transactionHash, 'hash', true)}</TxDataRow>
        <TxDataRow title="Created:">{timestamp ? dateString(timestamp) : null}</TxDataRow>
      </Box>
    </>
  )
}

export default SafeCreationTx
</file>

<file path="src/components/transactions/SafeCreationTx/styles.module.css">
.txCreation,
.txSummary {
  padding: 20px 24px;
  display: flex;
  flex-direction: column;
  padding-right: 60px; /* to not overlap with the share link */
}

.txSummary {
  border-top: 1px solid var(--color-border-light);
}
</file>

<file path="src/components/transactions/SignedMessagesHelpLink/index.tsx">
import { Box, SvgIcon, Typography } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { useAppSelector } from '@/store'
import { selectSafeMessages } from '@/store/safeMessagesSlice'
import { HelpCenterArticle } from '@/config/constants'

const SignedMessagesHelpLink = () => {
  const safeMessages = useAppSelector(selectSafeMessages)
  const safeMessagesCount = safeMessages.data?.results.length ?? 0

  if (safeMessagesCount === 0) {
    return null
  }

  return (
    <Box display="flex" alignItems="center" gap={1}>
      <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
      <ExternalLink noIcon href={HelpCenterArticle.SIGNED_MESSAGES}>
        <Typography variant="body2" fontWeight={700}>
          What are signed messages?
        </Typography>
      </ExternalLink>
    </Box>
  )
}

export default SignedMessagesHelpLink
</file>

<file path="src/components/transactions/SignTxButton/index.tsx">
import useIsExpiredSwap from '@/features/swap/hooks/useIsExpiredSwap'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import type { SyntheticEvent } from 'react'
import { useContext, type ReactElement } from 'react'
import { type TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Button, Tooltip } from '@mui/material'

import { isSignableBy } from '@/utils/transaction-guards'
import useWallet from '@/hooks/wallets/useWallet'
import Track from '@/components/common/Track'
import { TX_LIST_EVENTS } from '@/services/analytics/events/txList'
import CheckWallet from '@/components/common/CheckWallet'
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { TxModalContext } from '@/components/tx-flow'
import { ConfirmTxFlow } from '@/components/tx-flow/flows'
import { useNestedSafeOwners } from '@/hooks/useNestedSafeOwners'

const SignTxButton = ({
  txSummary,
  compact = false,
}: {
  txSummary: TransactionSummary
  compact?: boolean
}): ReactElement => {
  const { setTxFlow } = useContext(TxModalContext)
  const wallet = useWallet()
  const nestedOwners = useNestedSafeOwners()
  const isSafeOwner = useIsSafeOwner()
  const isSignable =
    isSignableBy(txSummary, wallet?.address || '') || nestedOwners?.some((owner) => isSignableBy(txSummary, owner))
  const safeSDK = useSafeSDK()
  const expiredSwap = useIsExpiredSwap(txSummary.txInfo)
  const isDisabled = !isSignable || !safeSDK || expiredSwap

  const onClick = (e: SyntheticEvent) => {
    e.stopPropagation()
    e.preventDefault()
    setTxFlow(<ConfirmTxFlow txSummary={txSummary} />, undefined, false)
  }

  return (
    <CheckWallet>
      {(isOk) => (
        <Tooltip title={isOk && !isSignable && isSafeOwner ? "You've already signed this transaction" : ''}>
          <span>
            <Track {...TX_LIST_EVENTS.CONFIRM}>
              <Button
                onClick={onClick}
                variant={compact ? 'outlined' : 'contained'}
                disabled={!isOk || isDisabled}
                size={compact ? 'small' : 'stretched'}
                sx={compact ? { py: 0.6 } : undefined}
              >
                Confirm
              </Button>
            </Track>
          </span>
        </Tooltip>
      )}
    </CheckWallet>
  )
}

export default SignTxButton
</file>

<file path="src/components/transactions/SignTxButton/styles.module.css">
.container {
}
</file>

<file path="src/components/transactions/SingleTx/index.tsx">
import ErrorMessage from '@/components/tx/ErrorMessage'
import { useRouter } from 'next/router'
import useSafeInfo from '@/hooks/useSafeInfo'
import type { Label, Transaction, TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { LabelValue } from '@safe-global/safe-gateway-typescript-sdk'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { ReactElement } from 'react'
import { useEffect } from 'react'
import { makeTxFromDetails } from '@/utils/transactions'
import { TxListGrid } from '@/components/transactions/TxList'
import ExpandableTransactionItem, {
  TransactionSkeleton,
} from '@/components/transactions/TxListItem/ExpandableTransactionItem'
import GroupLabel from '../GroupLabel'
import { isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'
import { useGetTransactionDetailsQuery } from '@/store/api/gateway'
import { skipToken } from '@reduxjs/toolkit/query/react'
import { asError } from '@safe-global/utils/services/exceptions/utils'

const SingleTxGrid = ({ txDetails }: { txDetails: TransactionDetails }): ReactElement => {
  const tx: Transaction = makeTxFromDetails(txDetails)

  // Show a label for the transaction if it's a queued transaction
  const { safe } = useSafeInfo()
  const nonce = isMultisigDetailedExecutionInfo(txDetails?.detailedExecutionInfo)
    ? txDetails?.detailedExecutionInfo.nonce
    : -1
  const label = nonce === safe.nonce ? LabelValue.Next : nonce > safe.nonce ? LabelValue.Queued : undefined

  return (
    <TxListGrid>
      {label ? <GroupLabel item={{ label } as Label} /> : null}

      <ExpandableTransactionItem item={tx} txDetails={txDetails} />
    </TxListGrid>
  )
}

const SingleTx = () => {
  const router = useRouter()
  const { id } = router.query
  const transactionId = Array.isArray(id) ? id[0] : id
  const { safe, safeAddress } = useSafeInfo()

  let {
    data: txDetails,
    error: txDetailsError,
    refetch,
    isUninitialized,
  } = useGetTransactionDetailsQuery(
    transactionId && safe.chainId
      ? {
          chainId: safe.chainId,
          txId: transactionId,
        }
      : skipToken,
  )

  useEffect(() => {
    !isUninitialized && refetch()
  }, [safe.txHistoryTag, safe.txQueuedTag, safeAddress, refetch, isUninitialized])

  if (txDetails && !sameAddress(txDetails.safeAddress, safeAddress)) {
    txDetailsError = new Error('Transaction with this id was not found in this Safe Account')
  }

  if (txDetailsError) {
    return <ErrorMessage error={asError(txDetailsError)}>Failed to load transaction</ErrorMessage>
  }

  if (txDetails) {
    return <SingleTxGrid txDetails={txDetails} />
  }

  // Loading skeleton
  return <TransactionSkeleton />
}

export default SingleTx
</file>

<file path="src/components/transactions/TrustedToggle/index.tsx">
import { useHasFeature } from '@/hooks/useChains'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, hideSuspiciousTransactions } from '@/store/settingsSlice'
import madProps from '@/utils/mad-props'
import _TrustedToggleButton from './TrustedToggleButton'
import { FEATURES } from '@safe-global/utils/utils/chains'

const useOnlyTrusted = () => {
  const userSettings = useAppSelector(selectSettings)
  return userSettings.hideSuspiciousTransactions || false
}

const useHasDefaultTokenList = () => {
  return useHasFeature(FEATURES.DEFAULT_TOKENLIST)
}

const useSetOnlyTrusted = () => {
  const dispatch = useAppDispatch()
  return (isOn: boolean) => {
    dispatch(hideSuspiciousTransactions(isOn))
  }
}

const TrustedToggle = madProps(_TrustedToggleButton, {
  onlyTrusted: useOnlyTrusted,
  setOnlyTrusted: useSetOnlyTrusted,
  hasDefaultTokenlist: useHasDefaultTokenList,
})

export default TrustedToggle
</file>

<file path="src/components/transactions/TrustedToggle/TrustedToggleButton.tsx">
import { type ReactElement } from 'react'
import { FormControlLabel, Switch } from '@mui/material'
import { TX_LIST_EVENTS } from '@/services/analytics'
import Track from '@/components/common/Track'

const _TrustedToggleButton = ({
  onlyTrusted,
  setOnlyTrusted,
  hasDefaultTokenlist,
}: {
  onlyTrusted: boolean
  setOnlyTrusted: (on: boolean) => void
  hasDefaultTokenlist?: boolean
}): ReactElement | null => {
  const onClick = () => {
    setOnlyTrusted(!onlyTrusted)
  }

  if (!hasDefaultTokenlist) {
    return null
  }

  return (
    <Track {...TX_LIST_EVENTS.TOGGLE_UNTRUSTED} label={onlyTrusted ? 'show' : 'hide'}>
      <FormControlLabel
        data-testid="toggle-untrusted"
        control={<Switch checked={onlyTrusted} onChange={onClick} />}
        label={<>Hide suspicious</>}
      />
    </Track>
  )
}

export default _TrustedToggleButton
</file>

<file path="src/components/transactions/TxConfirmations/index.tsx">
import { SvgIcon, Typography } from '@mui/material'
import type { ReactElement } from 'react'
import CheckIcon from '@mui/icons-material/Check'
import OwnersIcon from '@/public/images/common/owners.svg'
import TxStatusChip from '../TxStatusChip'

const TxConfirmations = ({
  requiredConfirmations,
  submittedConfirmations,
}: {
  requiredConfirmations: number
  submittedConfirmations: number
}): ReactElement => {
  const isConfirmed = submittedConfirmations >= requiredConfirmations
  const color = isConfirmed ? 'success' : 'warning'

  return (
    <TxStatusChip color={color}>
      <SvgIcon component={isConfirmed ? CheckIcon : OwnersIcon} inheritViewBox fontSize="small" />

      <Typography variant="caption" fontWeight="bold">
        {submittedConfirmations} out of {requiredConfirmations}
      </Typography>
    </TxStatusChip>
  )
}

export default TxConfirmations
</file>

<file path="src/components/transactions/TxDateLabel/index.tsx">
import type { DateLabel as SafeMessageDateLabel } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import type { DateLabel } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'

import { formatWithSchema } from '@safe-global/utils/utils/date'

import css from './styles.module.css'

const TxDateLabel = ({ item }: { item: DateLabel | SafeMessageDateLabel }): ReactElement => {
  return (
    <div className={css.container}>
      <span>{formatWithSchema(item.timestamp, 'MMM d, yyyy')}</span>
    </div>
  )
}

export default TxDateLabel
</file>

<file path="src/components/transactions/TxDateLabel/styles.module.css">
.container {
  font-size: 0.76em;
  font-weight: 600;
  line-height: 1.5;
  letter-spacing: 1px;
  color: rgb(93, 109, 116);
  text-transform: uppercase;
  margin-top: 20px;
  margin-bottom: 8px;
}
</file>

<file path="src/components/transactions/TxDetails/Summary/SafeTxHashDataRow/index.tsx">
import { useMemo } from 'react'
import { Stack } from '@mui/material'
import { TxDataRow, generateDataRowValue } from '../TxDataRow'
import { type SafeTransactionData, type SafeVersion } from '@safe-global/safe-core-sdk-types'
import { calculateSafeTransactionHash } from '@safe-global/protocol-kit/dist/src/utils'
import useSafeInfo from '@/hooks/useSafeInfo'
import { getDomainHash, getSafeTxMessageHash } from '@/utils/safe-hashes'

export const SafeTxHashDataRow = ({
  safeTxData,
  safeTxHash,
}: {
  safeTxData: SafeTransactionData
  safeTxHash?: string
}) => {
  const domainHash = useDomainHash()
  const messageHash = useMessageHash({ safeTxData })
  const computedSafeTxHash = useSafeTxHash({ safeTxData, safeTxHash })

  return (
    <Stack gap={1}>
      <TxDataRow datatestid="tx-domain-hash" title="Domain hash:">
        {generateDataRowValue(domainHash ?? '', 'rawData')}
      </TxDataRow>
      {messageHash && (
        <TxDataRow datatestid="tx-message-hash" title="Message hash:">
          {generateDataRowValue(messageHash, 'rawData')}
        </TxDataRow>
      )}
      <TxDataRow datatestid="tx-safe-hash" title="safeTxHash:">
        {generateDataRowValue(computedSafeTxHash ?? '', 'rawData')}
      </TxDataRow>
    </Stack>
  )
}

export function useDomainHash(): string | null {
  const { safe, safeAddress } = useSafeInfo()

  return useMemo(() => {
    if (!safe.version) {
      return null
    }
    try {
      return getDomainHash({ chainId: safe.chainId, safeAddress, safeVersion: safe.version as SafeVersion })
    } catch {
      return null
    }
  }, [safe.chainId, safe.version, safeAddress])
}

export function useMessageHash({ safeTxData }: { safeTxData: SafeTransactionData }): string | null {
  const { safe } = useSafeInfo()

  return useMemo(() => {
    if (!safe.version) {
      return null
    }
    try {
      return getSafeTxMessageHash({ safeVersion: safe.version as SafeVersion, safeTxData })
    } catch {
      return null
    }
  }, [safe.version, safeTxData])
}

export function useSafeTxHash({
  safeTxData,
  safeTxHash,
}: {
  safeTxData: SafeTransactionData
  safeTxHash?: string
}): string | null {
  const { safe, safeAddress } = useSafeInfo()

  return useMemo(() => {
    if (safeTxHash) {
      return safeTxHash
    }
    if (!safe.version) {
      return null
    }
    try {
      return calculateSafeTransactionHash(safeAddress, safeTxData, safe.version, BigInt(safe.chainId))
    } catch {
      return null
    }
  }, [safeTxData, safe.chainId, safe.version, safeAddress, safeTxHash])
}
</file>

<file path="src/components/transactions/TxDetails/Summary/TxDataRow/index.tsx">
import type { ReactElement } from 'react'
import type { AddressEx } from '@safe-global/safe-gateway-typescript-sdk'
import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import { Typography } from '@mui/material'
import { DataRow } from '@/components/common/Table/DataRow'
import NamedAddressInfo from '@/components/common/NamedAddressInfo'

export const TxDataRow = DataRow

export const generateDataRowValue = (
  value?: string,
  type?: 'hash' | 'rawData' | 'address' | 'bytes',
  hasExplorer?: boolean,
  addressInfo?: AddressEx,
): ReactElement | null => {
  if (value == undefined) return null

  switch (type) {
    case 'hash':
    case 'address':
      const customAvatar = addressInfo?.logoUri

      return (
        <NamedAddressInfo
          address={value}
          name={addressInfo?.name}
          customAvatar={customAvatar}
          showAvatar={type === 'address'}
          avatarSize={20}
          showPrefix={false}
          shortAddress={type !== 'address'}
          hasExplorer={hasExplorer}
          highlight4bytes
        />
      )
    case 'rawData':
    case 'bytes':
      return <HexEncodedData highlightFirstBytes={false} limit={66} hexData={value} />
    default:
      return (
        <Typography variant="body2" sx={{ wordBreak: 'break-all' }} component="span">
          {value}
        </Typography>
      )
  }
}
</file>

<file path="src/components/transactions/TxDetails/Summary/DecoderLinks.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import { Typography } from '@mui/material'

const TX_DECODER_URL = 'https://transaction-decoder.pages.dev'
const SAFE_UTILS_URL = 'https://safeutils.openzeppelin.com'

const DecoderLinks = () => (
  <Typography variant="body2" color="primary.light" mb={3}>
    Cross-verify your transaction data with external tools like{' '}
    <ExternalLink href={SAFE_UTILS_URL}>Safe Utils</ExternalLink> and{' '}
    <ExternalLink href={TX_DECODER_URL}>Transaction Decoder</ExternalLink>.
  </Typography>
)

export default DecoderLinks
</file>

<file path="src/components/transactions/TxDetails/Summary/index.tsx">
import { memo, type ReactElement } from 'react'
import { generateDataRowValue, TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeTransactionData } from '@safe-global/safe-core-sdk-types'
import { dateString } from '@safe-global/utils/utils/formatters'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { TxDetails } from '@/components/tx/ConfirmTxDetails/TxDetails'
import DecodedData from '../TxData/DecodedData'
import ColorCodedTxAccordion from '@/components/tx/ColorCodedTxAccordion'
import { Box, Divider, Typography } from '@mui/material'
import DecoderLinks from './DecoderLinks'
import isEqual from 'lodash/isEqual'

interface Props {
  safeTxData?: SafeTransactionData
  txData: TransactionDetails['txData']
  txInfo?: TransactionDetails['txInfo']
  txDetails?: TransactionDetails
}

const Summary = ({ safeTxData, txData, txInfo, txDetails }: Props): ReactElement => {
  const { txHash, executedAt } = txDetails ?? {}
  const toInfo = txData?.addressInfoIndex?.[txData?.to.value] || txData?.to
  const showDetails = Boolean(txInfo && txData)

  let baseGas, gasPrice, gasToken, safeTxGas, refundReceiver, submittedAt, nonce
  if (txDetails && isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo)) {
    ;({ baseGas, gasPrice, gasToken, safeTxGas, submittedAt, nonce } = txDetails.detailedExecutionInfo)
    refundReceiver = txDetails.detailedExecutionInfo.refundReceiver?.value
  }

  safeTxData = safeTxData ?? {
    to: txData?.to.value ?? ZERO_ADDRESS,
    data: txData?.hexData ?? '0x',
    value: txData?.value ?? BigInt(0).toString(),
    operation: (txData?.operation as number) ?? 0,
    baseGas: baseGas ?? BigInt(0).toString(),
    gasPrice: gasPrice ?? BigInt(0).toString(),
    gasToken: gasToken ?? ZERO_ADDRESS,
    nonce: nonce ?? 0,
    refundReceiver: refundReceiver ?? ZERO_ADDRESS,
    safeTxGas: safeTxGas ?? BigInt(0).toString(),
  }

  return (
    <>
      {txHash && (
        <TxDataRow datatestid="tx-hash" title="Transaction hash">
          {generateDataRowValue(txHash, 'hash', true)}{' '}
        </TxDataRow>
      )}

      {submittedAt && (
        <TxDataRow datatestid="tx-created-at" title="Created">
          <Typography variant="body2">{dateString(submittedAt)}</Typography>
        </TxDataRow>
      )}

      {executedAt && (
        <TxDataRow datatestid="tx-executed-at" title="Executed">
          <Typography variant="body2">{dateString(executedAt)}</Typography>
        </TxDataRow>
      )}

      {showDetails && (
        <Box mt={3}>
          <ColorCodedTxAccordion txInfo={txInfo} txData={txData}>
            <Box my={1}>
              <DecodedData txData={txData} toInfo={toInfo} />
            </Box>

            <Box>
              <Divider sx={{ mx: -2, mt: 2.5 }} />

              <Typography variant="h5" mt={2.5} mb={2}>
                Advanced details
              </Typography>

              <DecoderLinks />

              <TxDetails safeTxData={safeTxData} txData={txData} grid />
            </Box>
          </ColorCodedTxAccordion>
        </Box>
      )}
    </>
  )
}

export default memo(Summary, isEqual)
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/MethodDetails/index.tsx">
import type { ReactElement } from 'react'
import { generateDataRowValue, TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { isAddress, isArrayParameter, isByte } from '@/utils/transaction-guards'
import type { AddressEx, DataDecoded } from '@safe-global/safe-gateway-typescript-sdk'
import { Box, Stack, Typography } from '@mui/material'
import { Value } from '@/components/transactions/TxDetails/TxData/DecodedData/ValueArray'

type MethodDetailsProps = {
  data: DataDecoded
  hexData?: string
  addressInfoIndex?: {
    [key: string]: AddressEx
  }
}

export const MethodDetails = ({ data, addressInfoIndex }: MethodDetailsProps): ReactElement | null => {
  if (!data.parameters?.length) {
    return (
      <Typography color="text.secondary" variant="body2">
        No parameters
      </Typography>
    )
  }

  return (
    <Stack gap={0.75}>
      {data.parameters?.map((param, index) => {
        const isArrayValueParam = isArrayParameter(param.type) || Array.isArray(param.value)
        const inlineType = isAddress(param.type) ? 'address' : isByte(param.type) ? 'bytes' : undefined
        const addressEx = typeof param.value === 'string' ? addressInfoIndex?.[param.value] : undefined

        const title = (
          <Box mb={-0.75}>
            <Typography variant="body2" component="span">
              {param.name}
            </Typography>{' '}
            <Typography variant="body2" component="span" color="text.secondary">
              {param.type}
            </Typography>
          </Box>
        )

        return (
          <TxDataRow key={`${data.method}_param-${index}`} title={title}>
            {isArrayValueParam ? (
              <Value method={data.method} type={param.type} value={param.value as string} />
            ) : (
              generateDataRowValue(param.value as string, inlineType, true, addressEx)
            )}
          </TxDataRow>
        )
      })}
    </Stack>
  )
}
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/Multisend/index.tsx">
import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import { Operation } from '@safe-global/safe-gateway-typescript-sdk'
import type { TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import { useState, useEffect } from 'react'
import type { Dispatch, ReactElement, SetStateAction } from 'react'
import type { AccordionProps } from '@mui/material/Accordion/Accordion'
import SingleTxDecoded from '@/components/transactions/TxDetails/TxData/DecodedData/SingleTxDecoded'
import { Button, Divider, Stack } from '@mui/material'
import css from './styles.module.css'
import classnames from 'classnames'

type MultisendProps = {
  txData?: TransactionData
  compact?: boolean
}

export const MultisendActionsHeader = ({
  setOpen,
  amount,
  compact = false,
  title = 'All actions',
}: {
  setOpen: Dispatch<SetStateAction<Record<number, boolean> | undefined>>
  amount: number
  compact?: boolean
  title?: string
}) => {
  const onClickAll = (expanded: boolean) => () => {
    setOpen(Array(amount).fill(expanded))
  }

  return (
    <div data-testid="all-actions" className={classnames(css.actionsHeader, { [css.compactHeader]: compact })}>
      {title}
      <Stack direction="row" divider={<Divider className={css.divider} />}>
        <Button data-testid="expande-all-btn" onClick={onClickAll(true)} variant="text">
          Expand all
        </Button>
        <Button data-testid="collapse-all-btn" onClick={onClickAll(false)} variant="text">
          Collapse all
        </Button>
      </Stack>
    </div>
  )
}

export const Multisend = ({ txData, compact = false }: MultisendProps): ReactElement | null => {
  const [openMap, setOpenMap] = useState<Record<number, boolean>>()
  const isOpenMapUndefined = openMap == null

  // multiSend method receives one parameter `transactions`
  const multiSendTransactions = txData?.dataDecoded?.parameters?.[0].valueDecoded

  useEffect(() => {
    // Initialise whether each transaction should be expanded or not
    if (isOpenMapUndefined && multiSendTransactions) {
      setOpenMap(multiSendTransactions.map(({ operation }) => operation === Operation.DELEGATE))
    }
  }, [multiSendTransactions, isOpenMapUndefined])

  if (!txData) return null

  // ? when can a multiSend call take no parameters?
  if (!txData.dataDecoded?.parameters) {
    if (txData.hexData) {
      return <HexEncodedData title="Data (hex encoded)" hexData={txData.hexData} />
    }
    return null
  }

  if (!multiSendTransactions) {
    return null
  }
  return (
    <>
      <MultisendActionsHeader setOpen={setOpenMap} amount={multiSendTransactions.length} compact={compact} />

      <div className={compact ? css.compact : ''}>
        {multiSendTransactions.map(({ dataDecoded, data, value, to, operation }, index) => {
          const onChange: AccordionProps['onChange'] = (_, expanded) => {
            setOpenMap((prev) => ({
              ...prev,
              [index]: expanded,
            }))
          }

          return (
            <SingleTxDecoded
              key={`${data ?? to}-${index}`}
              tx={{
                dataDecoded,
                data,
                value,
                to,
                operation,
              }}
              txData={txData}
              actionTitle={`${index + 1}`}
              variant={compact ? 'outlined' : 'elevation'}
              expanded={openMap?.[index] ?? false}
              onChange={onChange}
            />
          )
        })}
      </div>
    </>
  )
}

export default Multisend
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/Multisend/styles.module.css">
.actionsHeader {
  border-bottom: 1px solid var(--color-border-light);
  cursor: auto !important;
  padding-left: var(--space-2);
  padding-right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.compactHeader {
  border: 0;
  padding-left: 0;
}

.actionsHeader button {
  padding-left: 18px;
  padding-right: 18px;
}

.divider {
  margin-top: 14px;
  margin-bottom: 14px;
  border: 1px solid var(--color-border-light);
}

.compact {
  display: flex;
  flex-direction: column;
}

.compact > div:first-child {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.compact > div ~ div {
  border-radius: 0;
  margin-top: -1px !important;
}

.compact > div:hover,
.compact > div:global(.Mui-expanded) {
  border-color: var(--color-border-light);
}
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/SingleTxDecoded/index.tsx">
import { isEmptyHexData } from '@/utils/hex'
import { type InternalTransaction, type TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import type { AccordionProps } from '@mui/material/Accordion/Accordion'
import { Accordion, AccordionDetails, AccordionSummary, Stack, Typography } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import css from './styles.module.css'
import accordionCss from '@/styles/accordion.module.css'
import CodeIcon from '@mui/icons-material/Code'
import DecodedData from '@/components/transactions/TxDetails/TxData/DecodedData'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { getSafeToL2MigrationDeployment } from '@safe-global/safe-deployments'
import { useCurrentChain } from '@/hooks/useChains'

type SingleTxDecodedProps = {
  tx: InternalTransaction
  txData: TransactionData
  actionTitle: string
  variant?: AccordionProps['variant']
  expanded?: boolean
  onChange?: AccordionProps['onChange']
}

export const SingleTxDecoded = ({ tx, txData, actionTitle, variant, expanded, onChange }: SingleTxDecodedProps) => {
  const chain = useCurrentChain()
  const isNativeTransfer = tx.value !== '0' && (!tx.data || isEmptyHexData(tx.data))
  const method = tx.dataDecoded?.method || (isNativeTransfer ? 'native transfer' : 'contract interaction')

  const addressInfo = txData.addressInfoIndex?.[tx.to]
  const name = addressInfo?.name

  const safeToL2MigrationDeployment = getSafeToL2MigrationDeployment()
  const safeToL2MigrationAddress = chain && safeToL2MigrationDeployment?.networkAddresses[chain.chainId]

  const singleTxData = {
    to: { value: tx.to },
    value: tx.value,
    operation: tx.operation,
    dataDecoded: tx.dataDecoded,
    hexData: tx.data ?? undefined,
    addressInfoIndex: txData.addressInfoIndex,
    trustedDelegateCallTarget: sameAddress(tx.to, safeToL2MigrationAddress), // We only trusted a nested Migration
  }

  return (
    <Accordion variant={variant} expanded={expanded} onChange={onChange}>
      <AccordionSummary data-testid="action-item" expandIcon={<ExpandMoreIcon />} className={accordionCss.accordion}>
        <div className={css.summary}>
          <CodeIcon color="border" fontSize="small" />
          <Typography>{actionTitle}</Typography>
          <Typography ml="8px">
            {name ? name + ': ' : ''}
            <b>{method}</b>
          </Typography>
        </div>
      </AccordionSummary>

      <AccordionDetails>
        <Stack spacing={1}>
          <DecodedData txData={singleTxData} toInfo={{ value: tx.to }} />
        </Stack>
      </AccordionDetails>
    </Accordion>
  )
}

export default SingleTxDecoded
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/SingleTxDecoded/styles.module.css">
.summary {
  display: flex;
  gap: 8px;
  align-items: center;
}
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/ValueArray/index.tsx">
import { useMemo } from 'react'
import type { ReactElement } from 'react'
import { Typography } from '@mui/material'
import { isAddress, isArrayParameter } from '@/utils/transaction-guards'
import EthHashInfo from '@/components/common/EthHashInfo'
import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import css from './styles.module.css'

type ValueArrayProps = {
  method: string
  type: string
  value: string | string[]
  key?: string
}

// Sometime DApps return stringified arrays, e.g. "["hello","world"]"
const parseValue = (value: ValueArrayProps['value']) => {
  if (Array.isArray(value)) {
    return value
  }

  try {
    return JSON.parse(value)
  } catch {
    return value
  }
}

export const Value = ({ type, value, ...props }: ValueArrayProps): ReactElement => {
  const parsedValue = useMemo(() => {
    return parseValue(value)
  }, [value])

  if (isArrayParameter(type) && isAddress(type) && Array.isArray(parsedValue)) {
    return (
      <Typography component="div" variant="body2">
        [
        {parsedValue.length > 0 && (
          <div className={css.nestedWrapper}>
            {parsedValue.map((address, index) => {
              const key = `${props.key || props.method}-${index}`
              if (Array.isArray(address)) {
                const newProps = {
                  type,
                  ...props,
                  value: address,
                }
                return <Value key={key} {...newProps} />
              }
              return (
                <div key={`${address}_${key}`}>
                  <EthHashInfo address={address} showAvatar={false} shortAddress={false} showCopyButton hasExplorer />
                </div>
              )
            })}
          </div>
        )}
        ]
      </Typography>
    )
  }

  return <GenericValue value={parsedValue} {...props} />
}

const getTextValue = (value: string, key?: string) => {
  return <HexEncodedData highlightFirstBytes={false} limit={60} hexData={value} key={key} />
}

const getArrayValue = (parentId: string, value: string[], separator?: boolean) => (
  <Typography component="div" variant="body2">
    [
    <div className={css.nestedWrapper}>
      {value.map((currentValue, index, values) => {
        const key = `${parentId}-value-${index}`
        const hasSeparator = index < values.length - 1

        return Array.isArray(currentValue) ? (
          <div key={key}>{getArrayValue(key, currentValue, hasSeparator)}</div>
        ) : (
          getTextValue(currentValue, key)
        )
      })}
    </div>
    ]{separator ? ',' : null}
  </Typography>
)

const GenericValue = ({ method, value }: Omit<ValueArrayProps, 'type'>): React.ReactElement => {
  if (Array.isArray(value)) {
    return getArrayValue(method, value)
  }

  return getTextValue(value)
}
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/ValueArray/styles.module.css">
.nestedWrapper {
  padding-left: 12px;
}
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/index.tsx">
import type { ReactElement } from 'react'
import { Stack } from '@mui/material'
import { type AddressEx, TokenType, type TransactionDetails, Operation } from '@safe-global/safe-gateway-typescript-sdk'

import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import { MethodDetails } from '@/components/transactions/TxDetails/TxData/DecodedData/MethodDetails'
import { useCurrentChain } from '@/hooks/useChains'
import SendAmountBlock from '@/components/tx-flow/flows/TokenTransfer/SendAmountBlock'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import SendToBlock from '@/components/tx/SendToBlock'
import MethodCall from './MethodCall'
import { DelegateCallWarning } from '@/components/transactions/Warning'

interface Props {
  txData: TransactionDetails['txData']
  toInfo?: AddressEx
}

export const DecodedData = ({ txData, toInfo }: Props): ReactElement | null => {
  const chainInfo = useCurrentChain()

  // nothing to render
  if (!txData) {
    if (!toInfo) return null

    return (
      <SendToBlock
        title="Interact with"
        address={toInfo.value}
        name={toInfo.name}
        customAvatar={toInfo.logoUri}
        avatarSize={26}
      />
    )
  }

  const amountInWei = txData.value ?? '0'
  const isDelegateCall = txData.operation === Operation.DELEGATE
  const toAddress = toInfo?.value || txData.to?.value
  const method = txData.dataDecoded?.method || ''
  const addressInfo = txData.addressInfoIndex?.[toAddress]
  const name = addressInfo?.name || toInfo?.name || txData.to?.name
  const avatar = addressInfo?.logoUri || toInfo?.logoUri || txData.to?.logoUri

  return (
    <Stack spacing={2}>
      {isDelegateCall && <DelegateCallWarning showWarning={!txData.trustedDelegateCallTarget} />}

      {method ? (
        <MethodCall contractAddress={toAddress} contractName={name} contractLogo={avatar} method={method} />
      ) : (
        <SendToBlock address={toAddress} name={name} title="Interacted with" avatarSize={20} customAvatar={avatar} />
      )}

      {amountInWei !== '0' && (
        <SendAmountBlock
          title="Value"
          amountInWei={amountInWei}
          tokenInfo={{
            type: TokenType.NATIVE_TOKEN,
            address: ZERO_ADDRESS,
            decimals: chainInfo?.nativeCurrency.decimals ?? 18,
            symbol: chainInfo?.nativeCurrency.symbol ?? 'ETH',
            logoUri: chainInfo?.nativeCurrency.logoUri,
          }}
        />
      )}

      {txData.dataDecoded ? (
        <MethodDetails data={txData.dataDecoded} hexData={txData.hexData} addressInfoIndex={txData.addressInfoIndex} />
      ) : txData.hexData ? (
        <HexEncodedData title="Data" hexData={txData.hexData} />
      ) : null}
    </Stack>
  )
}

export default DecodedData
</file>

<file path="src/components/transactions/TxDetails/TxData/DecodedData/MethodCall.tsx">
import NamedAddressInfo from '@/components/common/NamedAddressInfo'
import { Typography } from '@mui/material'

const MethodCall = ({
  method,
  contractAddress,
  contractName,
  contractLogo,
}: {
  method: string
  contractAddress: string
  contractName?: string
  contractLogo?: string
}) => {
  return (
    <>
      <Typography
        fontWeight="bold"
        display="flex"
        flexWrap={['wrap', 'wrap', 'nowrap']}
        alignItems="center"
        gap=".5em"
        component="div"
      >
        Call
        <Typography
          component="code"
          variant="body2"
          sx={{
            backgroundColor: 'background.main',
            px: 1,
            py: 0.5,
            borderRadius: 0.5,
            fontFamily: 'monospace',
            whiteSpace: 'nowrap',
          }}
        >
          {method}
        </Typography>{' '}
        on
        <NamedAddressInfo
          address={contractAddress}
          name={contractName}
          customAvatar={contractLogo}
          showAvatar
          onlyName
          hasExplorer
          showCopyButton
          avatarSize={24}
        />
      </Typography>
    </>
  )
}

export default MethodCall
</file>

<file path="src/components/transactions/TxDetails/TxData/MigrationToL2TxData/index.tsx">
import useAsync from '@safe-global/utils/hooks/useAsync'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { getMultiSendContractDeployment } from '@safe-global/utils/services/contracts/deployments'
import { createTx } from '@/services/tx/tx-sender/create'
import { Safe__factory } from '@safe-global/utils/types/contracts'
import { type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import DecodedData from '../DecodedData'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { MigrateToL2Information } from '@/components/tx/confirmation-views/MigrateToL2Information'
import { Box } from '@mui/material'
import { isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'
import useTxPreview from '@/components/tx/confirmation-views/useTxPreview'
import Summary from '../../Summary'

export const MigrationToL2TxData = ({ txDetails }: { txDetails: TransactionDetails }) => {
  const readOnlyProvider = useWeb3ReadOnly()
  const chain = useCurrentChain()
  const { safe } = useSafeInfo()
  const sdk = useSafeSDK()
  // Reconstruct real tx
  const [realSafeTx, realSafeTxError, realSafeTxLoading] = useAsync(async () => {
    // Fetch tx receipt from backend
    if (!txDetails.txHash || !chain || !sdk) {
      return undefined
    }
    const txResult = await readOnlyProvider?.getTransaction(txDetails.txHash)
    const txData = txResult?.data

    // Search for a Safe Tx to MultiSend contract
    const safeInterface = Safe__factory.createInterface()
    const execTransactionSelector = safeInterface.getFunction('execTransaction').selector.slice(2, 10)
    const multiSendDeployment = getMultiSendContractDeployment(chain, safe.version)
    const multiSendAddress = multiSendDeployment?.networkAddresses[chain.chainId]
    if (!multiSendAddress) {
      return undefined
    }
    const searchString = execTransactionSelector
    const indexOfTx = txData?.indexOf(searchString)
    if (indexOfTx && txData) {
      // Now we need to find the tx Data
      const parsedTx = safeInterface.parseTransaction({ data: `0x${txData.slice(indexOfTx)}` })

      const execTxArgs = parsedTx?.args
      if (!execTxArgs || execTxArgs.length < 10) {
        return undefined
      }
      return createTx(
        {
          to: execTxArgs[0],
          value: execTxArgs[1].toString(),
          data: execTxArgs[2],
          operation: Number(execTxArgs[3]),
          safeTxGas: execTxArgs[4].toString(),
          baseGas: execTxArgs[5].toString(),
          gasPrice: execTxArgs[6].toString(),
          gasToken: execTxArgs[7].toString(),
          refundReceiver: execTxArgs[8],
        },
        isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo)
          ? txDetails.detailedExecutionInfo.nonce
          : undefined,
      )
    }
  }, [txDetails.txHash, txDetails.detailedExecutionInfo, chain, sdk, readOnlyProvider, safe.version])

  const decodedDataUnavailable = !realSafeTx && !realSafeTxLoading
  const [txPreview, txPreviewError] = useTxPreview(realSafeTx?.data)

  return (
    <Box>
      <MigrateToL2Information variant="history" txData={txDetails.txData} />

      {realSafeTxError ? (
        <ErrorMessage>{realSafeTxError.message}</ErrorMessage>
      ) : txPreviewError ? (
        <ErrorMessage>{txPreviewError.message}</ErrorMessage>
      ) : decodedDataUnavailable ? (
        <DecodedData txData={txDetails.txData} />
      ) : (
        txPreview && <Summary {...txPreview} safeTxData={realSafeTx?.data} />
      )}
    </Box>
  )
}
</file>

<file path="src/components/transactions/TxDetails/TxData/NestedTransaction/ExecTransaction/index.tsx">
import { Safe__factory } from '@safe-global/utils/types/contracts'
import { Skeleton } from '@mui/material'
import { type TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import ErrorMessage from '@/components/tx/ErrorMessage'

import Link from 'next/link'
import { useCurrentChain } from '@/hooks/useChains'
import { AppRoutes } from '@/config/routes'
import { useMemo } from 'react'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import ExternalLink from '@/components/common/ExternalLink'
import { NestedTransaction } from '../NestedTransaction'
import useTxPreview from '@/components/tx/confirmation-views/useTxPreview'
import Summary from '../../../Summary'

const safeInterface = Safe__factory.createInterface()

const extractTransactionData = (data: string): SafeTransaction | undefined => {
  const params = data ? safeInterface.decodeFunctionData('execTransaction', data) : undefined
  if (!params || params.length !== 10) {
    return
  }

  return {
    addSignature: () => {},
    encodedSignatures: () => params[9],
    getSignature: () => undefined,
    data: {
      to: params[0],
      value: params[1],
      data: params[2],
      operation: params[3],
      safeTxGas: params[4],
      baseGas: params[5],
      gasPrice: params[6],
      gasToken: params[7],
      refundReceiver: params[8],
      nonce: -1,
    },
    signatures: new Map(),
  }
}

export const ExecTransaction = ({
  data,
  isConfirmationView = false,
}: {
  data?: TransactionData
  isConfirmationView?: boolean
}) => {
  const chain = useCurrentChain()

  const childSafeTx = useMemo<SafeTransaction | undefined>(
    () => (data?.hexData ? extractTransactionData(data.hexData) : undefined),
    [data?.hexData],
  )

  const [txPreview, error] = useTxPreview(
    childSafeTx
      ? {
          operation: Number(childSafeTx.data.operation),
          data: childSafeTx.data.data,
          to: childSafeTx.data.to,
          value: childSafeTx.data.value.toString(),
        }
      : undefined,
    data?.to.value,
  )

  const decodedNestedTxDataBlock = txPreview ? <Summary {...txPreview} safeTxData={childSafeTx?.data} /> : null

  return (
    <NestedTransaction txData={data} isConfirmationView={isConfirmationView}>
      {decodedNestedTxDataBlock ? (
        <>
          {decodedNestedTxDataBlock}

          {chain && data && (
            <Link
              href={{
                pathname: AppRoutes.transactions.history,
                query: { safe: `${chain.shortName}:${data.to.value}` },
              }}
              passHref
              legacyBehavior
            >
              <ExternalLink>Open Safe</ExternalLink>
            </Link>
          )}
        </>
      ) : error ? (
        <ErrorMessage>Could not load details on executed transaction.</ErrorMessage>
      ) : (
        <Skeleton />
      )}
    </NestedTransaction>
  )
}
</file>

<file path="src/components/transactions/TxDetails/TxData/NestedTransaction/OnChainConfirmation/index.tsx">
import useChainId from '@/hooks/useChainId'
import { Safe__factory } from '@safe-global/utils/types/contracts'
import { Skeleton } from '@mui/material'
import { type TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import ErrorMessage from '@/components/tx/ErrorMessage'

import Link from 'next/link'
import { useCurrentChain } from '@/hooks/useChains'
import { AppRoutes } from '@/config/routes'
import { useGetTransactionDetailsQuery } from '@/store/api/gateway'
import { useMemo } from 'react'
import { skipToken } from '@reduxjs/toolkit/query'
import ExternalLink from '@/components/common/ExternalLink'
import { NestedTransaction } from '../NestedTransaction'
import TxData from '../..'
import { isMultiSendTxInfo, isOrderTxInfo } from '@/utils/transaction-guards'
import { ErrorBoundary } from '@sentry/react'
import Multisend from '../../DecodedData/Multisend'
import { MODALS_EVENTS } from '@/services/analytics'
import Track from '@/components/common/Track'

const safeInterface = Safe__factory.createInterface()

export const OnChainConfirmation = ({
  data,
  isConfirmationView = false,
}: {
  data?: TransactionData
  isConfirmationView?: boolean
}) => {
  const chain = useCurrentChain()
  const chainId = useChainId()
  const signedHash = useMemo(() => {
    const params = data?.hexData ? safeInterface.decodeFunctionData('approveHash', data?.hexData) : undefined
    if (!params || params.length !== 1 || typeof params[0] !== 'string') {
      return
    }

    return params[0]
  }, [data?.hexData])

  const { data: nestedTxDetails, error: txDetailsError } = useGetTransactionDetailsQuery(
    signedHash
      ? {
          chainId,
          txId: signedHash,
        }
      : skipToken,
  )

  return (
    <NestedTransaction txData={data} isConfirmationView={isConfirmationView}>
      {nestedTxDetails ? (
        <>
          <TxData
            txData={nestedTxDetails.txData}
            txInfo={nestedTxDetails.txInfo}
            txDetails={nestedTxDetails}
            trusted
            imitation={false}
          />

          {(isMultiSendTxInfo(nestedTxDetails.txInfo) || isOrderTxInfo(nestedTxDetails.txInfo)) && (
            <ErrorBoundary fallback={<div>Error parsing data</div>}>
              <Multisend txData={nestedTxDetails.txData} />
            </ErrorBoundary>
          )}

          {chain && data && (
            <Track {...MODALS_EVENTS.OPEN_NESTED_TX}>
              <Link
                href={{
                  pathname: AppRoutes.transactions.tx,
                  query: {
                    safe: `${chain?.shortName}:${data?.to.value}`,
                    id: nestedTxDetails.txId,
                  },
                }}
                passHref
                legacyBehavior
              >
                <ExternalLink>Open nested transaction</ExternalLink>
              </Link>
            </Track>
          )}
        </>
      ) : txDetailsError ? (
        <ErrorMessage>Could not load details on hash to approve.</ErrorMessage>
      ) : (
        <Skeleton />
      )}
    </NestedTransaction>
  )
}
</file>

<file path="src/components/transactions/TxDetails/TxData/NestedTransaction/NestedTransaction.tsx">
import { Stack, SvgIcon, Typography } from '@mui/material'
import { type TransactionData } from '@safe-global/safe-gateway-typescript-sdk'

import { Divider } from '@/components/tx/ColorCodedTxAccordion'

import NestedTransactionIcon from '@/public/images/transactions/nestedTx.svg'
import { type ReactElement } from 'react'
import MethodCall from '../DecodedData/MethodCall'
import { MethodDetails } from '../DecodedData/MethodDetails'

export const NestedTransaction = ({
  txData,
  children,
  isConfirmationView = false,
}: {
  txData: TransactionData | undefined
  children: ReactElement
  isConfirmationView?: boolean
}) => {
  return (
    <Stack spacing={2}>
      {!isConfirmationView && txData?.dataDecoded && (
        <>
          <MethodCall contractAddress={txData.to.value} method={txData.dataDecoded.method} />
          <MethodDetails data={txData.dataDecoded} addressInfoIndex={txData.addressInfoIndex} />
          <Divider />
        </>
      )}

      <Stack spacing={2}>
        <Typography variant="h5" display="flex" alignItems="center" gap={1}>
          <SvgIcon component={NestedTransactionIcon} inheritViewBox fontSize="small" /> Nested transaction:
        </Typography>
        {children}
      </Stack>
    </Stack>
  )
}
</file>

<file path="src/components/transactions/TxDetails/TxData/Rejection/index.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import { NOT_AVAILABLE } from '@/components/transactions/TxDetails'
import type { MultisigExecutionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { Box, Typography } from '@mui/material'
import React from 'react'
import { HelpCenterArticle } from '@/config/constants'

interface Props {
  nonce?: MultisigExecutionDetails['nonce']
  isTxExecuted: boolean
}

const RejectionTxInfo = ({ nonce, isTxExecuted }: Props) => {
  const txNonce = nonce ?? NOT_AVAILABLE
  const message = `This is an on-chain rejection that ${isTxExecuted ? "didn't" : "won't"} send any funds. ${
    isTxExecuted
      ? `This on-chain rejection replaced all transactions with nonce ${txNonce}.`
      : `Executing this on-chain rejection will replace all currently awaiting transactions with nonce ${txNonce}.`
  }`

  const title = 'Why do I need to pay to reject a transaction?'

  return (
    <>
      <Typography data-testid="onchain-rejection" mr={2}>
        {message}
      </Typography>
      {!isTxExecuted && (
        <Box mt={2} sx={{ width: 'fit-content' }}>
          <ExternalLink href={HelpCenterArticle.CANCELLING_TRANSACTIONS} title={title}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
              <Typography sx={{ textDecoration: 'underline' }}>{title}</Typography>
            </Box>
          </ExternalLink>
        </Box>
      )}
    </>
  )
}

export default RejectionTxInfo
</file>

<file path="src/components/transactions/TxDetails/TxData/SafeUpdate/index.tsx">
import { Box, Stack } from '@mui/material'
import type { TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import DecodedData from '../DecodedData'

function SafeUpdate({ txData }: { txData?: TransactionData }) {
  return (
    <Stack mr={5} spacing={2}>
      <Box
        bgcolor="border.background"
        p={2}
        textAlign="center"
        fontWeight={700}
        fontSize={18}
        borderRadius={1}
        width="100%"
      >
        Safe version update
      </Box>

      <DecodedData txData={txData} toInfo={txData?.to} />
    </Stack>
  )
}

export default SafeUpdate
</file>

<file path="src/components/transactions/TxDetails/TxData/SettingsChange/index.tsx">
import type { ComponentProps, ReactElement } from 'react'
import type { SettingsChange } from '@safe-global/safe-gateway-typescript-sdk'
import { SettingsInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import EthHashInfo from '@/components/common/EthHashInfo'
import { InfoDetails } from '@/components/transactions/InfoDetails'
import { ThresholdWarning } from '@/components/transactions/Warning'
import { UntrustedFallbackHandlerWarning } from '@/components/transactions/Warning'

type SettingsChangeTxInfoProps = {
  settingsInfo: SettingsChange['settingsInfo']
  isTxExecuted?: boolean
}

const addressInfoProps: Pick<ComponentProps<typeof EthHashInfo>, 'shortAddress' | 'showCopyButton' | 'hasExplorer'> = {
  shortAddress: false,
  showCopyButton: true,
  hasExplorer: true,
}

export const SettingsChangeTxInfo = ({
  settingsInfo,
  isTxExecuted = false,
}: SettingsChangeTxInfoProps): ReactElement | null => {
  if (!settingsInfo) {
    return null
  }

  switch (settingsInfo.type) {
    case SettingsInfoType.SET_FALLBACK_HANDLER: {
      return (
        <>
          <InfoDetails title="Set fallback handler:">
            <EthHashInfo
              address={settingsInfo.handler.value}
              name={settingsInfo.handler?.name}
              customAvatar={settingsInfo.handler?.logoUri}
              {...addressInfoProps}
            />
          </InfoDetails>
          <UntrustedFallbackHandlerWarning fallbackHandler={settingsInfo.handler.value} isTxExecuted={isTxExecuted} />
        </>
      )
    }
    case SettingsInfoType.ADD_OWNER:
    case SettingsInfoType.REMOVE_OWNER: {
      const title = settingsInfo.type === SettingsInfoType.ADD_OWNER ? 'Add signer:' : 'Remove signer:'
      return (
        <>
          <ThresholdWarning />
          <InfoDetails datatestid="owner-action" title={title}>
            <EthHashInfo
              address={settingsInfo.owner.value}
              name={settingsInfo.owner?.name}
              customAvatar={settingsInfo.owner?.logoUri}
              {...addressInfoProps}
            />
            <InfoDetails datatestid="required-confirmations" title="Required confirmations for new transactions:">
              {settingsInfo.threshold}
            </InfoDetails>
          </InfoDetails>
        </>
      )
    }
    case SettingsInfoType.SWAP_OWNER: {
      return (
        <InfoDetails datatestid="swap-owner" title="Swap signer:">
          <InfoDetails datatestid="old-owner" title="Old signer">
            <EthHashInfo
              address={settingsInfo.oldOwner.value}
              name={settingsInfo.oldOwner?.name}
              customAvatar={settingsInfo.oldOwner?.logoUri}
              {...addressInfoProps}
            />
          </InfoDetails>
          <InfoDetails datatestid="new-owner" title="New signer">
            <EthHashInfo
              address={settingsInfo.newOwner.value}
              name={settingsInfo.newOwner?.name}
              customAvatar={settingsInfo.newOwner?.logoUri}
              {...addressInfoProps}
            />
          </InfoDetails>
        </InfoDetails>
      )
    }
    case SettingsInfoType.CHANGE_THRESHOLD: {
      return (
        <>
          <ThresholdWarning />
          <InfoDetails datatestid="required-confirmations" title="Required confirmations for new transactions:">
            {settingsInfo.threshold}
          </InfoDetails>
        </>
      )
    }
    case SettingsInfoType.CHANGE_IMPLEMENTATION: {
      return (
        <InfoDetails title="Change implementation:">
          <EthHashInfo
            address={settingsInfo.implementation.value}
            name={settingsInfo.implementation?.name}
            customAvatar={settingsInfo.implementation?.logoUri}
            {...addressInfoProps}
          />
        </InfoDetails>
      )
    }
    case SettingsInfoType.ENABLE_MODULE:
    case SettingsInfoType.DISABLE_MODULE: {
      const title = settingsInfo.type === SettingsInfoType.ENABLE_MODULE ? 'Enable module:' : 'Disable module:'
      return (
        <InfoDetails datatestid="module-action" title={title}>
          <EthHashInfo
            address={settingsInfo.module.value}
            name={settingsInfo.module?.name}
            customAvatar={settingsInfo.module?.logoUri}
            {...addressInfoProps}
          />
        </InfoDetails>
      )
    }
    case SettingsInfoType.SET_GUARD: {
      return (
        <InfoDetails title="Set guard:">
          <EthHashInfo
            address={settingsInfo.guard.value}
            name={settingsInfo.guard?.name}
            customAvatar={settingsInfo.guard?.logoUri}
            {...addressInfoProps}
          />
        </InfoDetails>
      )
    }
    case SettingsInfoType.DELETE_GUARD: {
      return <InfoDetails title="Delete guard" />
    }
    default:
      return <></>
  }
}

export default SettingsChangeTxInfo
</file>

<file path="src/components/transactions/TxDetails/TxData/SpendingLimits/index.tsx">
import type { ReactElement } from 'react'
import React, { useMemo } from 'react'
import type { Custom, TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import { Box, Typography } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import TokenIcon from '@/components/common/TokenIcon'
import SpendingLimitLabel from '@/components/common/SpendingLimitLabel'
import { useCurrentChain } from '@/hooks/useChains'
import { selectTokens } from '@/store/balancesSlice'
import { useAppSelector } from '@/store'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import type { SpendingLimitMethods } from '@/utils/transaction-guards'
import { isSetAllowance } from '@/utils/transaction-guards'
import css from './styles.module.css'
import chains from '@/config/chains'

type SpendingLimitsProps = {
  txData?: TransactionData
  txInfo: Custom
  type: SpendingLimitMethods
}

export const SpendingLimits = ({ txData, txInfo, type }: SpendingLimitsProps): ReactElement | null => {
  const chain = useCurrentChain()
  const tokens = useAppSelector(selectTokens)
  const isSetAllowanceMethod = useMemo(() => isSetAllowance(type), [type])

  const [beneficiary, tokenAddress, amount, resetTimeMin] =
    txData?.dataDecoded?.parameters?.map(({ value }) => value) || []

  const resetTimeLabel = useMemo(
    () => getResetTimeOptions(chain?.chainId).find(({ value }) => +value === +resetTimeMin)?.label,
    [chain?.chainId, resetTimeMin],
  )
  const tokenInfo = useMemo(
    () => tokens.find(({ address }) => sameAddress(address, tokenAddress as string)),
    [tokenAddress, tokens],
  )
  const txTo = txInfo.to

  if (!txData) return null

  return (
    <Box className={css.container}>
      <Typography>
        <b>{`${isSetAllowanceMethod ? 'Modify' : 'Delete'} spending limit:`}</b>
      </Typography>
      <Box className={css.group}>
        <Typography sx={({ palette }) => ({ color: palette.primary.light })}>Beneficiary</Typography>
        <EthHashInfo
          address={(beneficiary as string) || txTo?.value || '0x'}
          name={txTo.name}
          customAvatar={txTo.logoUri}
          shortAddress={false}
          showCopyButton
          hasExplorer
        />
      </Box>
      <Box className={css.group}>
        <Typography sx={({ palette }) => ({ color: palette.primary.light })}>
          {isSetAllowanceMethod ? (tokenInfo ? 'Amount' : 'Raw Amount (in decimals)') : 'Token'}
        </Typography>
        <Box className={css.inline}>
          {tokenInfo && (
            <>
              <TokenIcon logoUri={tokenInfo.logoUri} size={32} tokenSymbol={tokenInfo.symbol} />
              <Typography>{tokenInfo.symbol}</Typography>
            </>
          )}

          {isSetAllowanceMethod && (
            <>
              {tokenInfo ? (
                <Typography>
                  {formatVisualAmount(amount as string, tokenInfo.decimals)} {tokenInfo.symbol}
                </Typography>
              ) : (
                <Typography>{amount}</Typography>
              )}
            </>
          )}
        </Box>
      </Box>
      {isSetAllowanceMethod && (
        <Box className={css.group}>
          <Typography sx={({ palette }) => ({ color: palette.primary.light })}>Reset time</Typography>
          <SpendingLimitLabel label={resetTimeLabel || 'One-time spending limit'} isOneTime={!resetTimeLabel} />
        </Box>
      )}
    </Box>
  )
}

const RESET_TIME_OPTIONS = [
  { label: 'One time', value: '0' },
  { label: '1 day', value: '1440' },
  { label: '1 week', value: '10080' },
  { label: '1 month', value: '43200' },
]

const TEST_RESET_TIME_OPTIONS = [
  { label: 'One time', value: '0' },
  { label: '5 minutes', value: '5' },
  { label: '30 minutes', value: '30' },
  { label: '1 hour', value: '60' },
]

export const getResetTimeOptions = (chainId = ''): { label: string; value: string }[] => {
  return chainId === chains.gor || chainId === chains.sep ? TEST_RESET_TIME_OPTIONS : RESET_TIME_OPTIONS
}

export default SpendingLimits
</file>

<file path="src/components/transactions/TxDetails/TxData/SpendingLimits/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.inline {
  display: flex;
  align-items: center;
  gap: 8px;
}
</file>

<file path="src/components/transactions/TxDetails/TxData/Transfer/index.tsx">
import NamedAddressInfo from '@/components/common/NamedAddressInfo'
import { TransferTx } from '@/components/transactions/TxInfo'
import { isTxQueued } from '@/utils/transaction-guards'
import type { TransactionStatus, Transfer } from '@safe-global/safe-gateway-typescript-sdk'
import { TransferDirection } from '@safe-global/safe-gateway-typescript-sdk'
import { Box } from '@mui/material'
import React from 'react'

import TransferActions from '@/components/transactions/TxDetails/TxData/Transfer/TransferActions'
import MaliciousTxWarning from '@/components/transactions/MaliciousTxWarning'
import { ImitationTransactionWarning } from '@/components/transactions/ImitationTransactionWarning'

type TransferTxInfoProps = {
  txInfo: Transfer
  txStatus: TransactionStatus
  trusted: boolean
  imitation: boolean
}

const TransferTxInfoMain = ({ txInfo, txStatus, trusted, imitation }: TransferTxInfoProps) => {
  const { direction } = txInfo

  return (
    <Box display="flex" flexDirection="row" alignItems="center" gap={1}>
      {direction === TransferDirection.INCOMING ? 'Received' : isTxQueued(txStatus) ? 'Send' : 'Sent'}{' '}
      <b>
        <TransferTx info={txInfo} omitSign preciseAmount />
      </b>
      {direction === TransferDirection.INCOMING ? ' from' : ' to'}
      {!trusted && !imitation && <MaliciousTxWarning />}
    </Box>
  )
}

const TransferTxInfo = ({ txInfo, txStatus, trusted, imitation }: TransferTxInfoProps) => {
  const address = txInfo.direction.toUpperCase() === TransferDirection.INCOMING ? txInfo.sender : txInfo.recipient

  return (
    <Box display="flex" flexDirection="column" gap={1}>
      <TransferTxInfoMain txInfo={txInfo} txStatus={txStatus} trusted={trusted} imitation={imitation} />

      <Box display="flex" alignItems="center" width="100%">
        <NamedAddressInfo
          address={address.value}
          name={address.name}
          customAvatar={address.logoUri}
          shortAddress={false}
          hasExplorer
          showCopyButton
          trusted={trusted && !imitation}
        >
          <TransferActions address={address.value} txInfo={txInfo} trusted={trusted} />
        </NamedAddressInfo>
      </Box>
      {imitation && <ImitationTransactionWarning />}
    </Box>
  )
}

export default TransferTxInfo
</file>

<file path="src/components/transactions/TxDetails/TxData/Transfer/TransferActions.tsx">
import type { MouseEvent } from 'react'
import { type ReactElement, useContext, useState } from 'react'
import IconButton from '@mui/material/IconButton'
import MoreHorizIcon from '@mui/icons-material/MoreHoriz'
import MenuItem from '@mui/material/MenuItem'
import ListItemText from '@mui/material/ListItemText'

import useAddressBook from '@/hooks/useAddressBook'
import EntryDialog from '@/components/address-book/EntryDialog'
import ContextMenu from '@/components/common/ContextMenu'
import { TokenTransferFlow } from '@/components/tx-flow/flows'
import type { Transfer } from '@safe-global/safe-gateway-typescript-sdk'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { isERC20Transfer, isNativeTokenTransfer, isOutgoingTransfer } from '@/utils/transaction-guards'
import { trackEvent, TX_LIST_EVENTS } from '@/services/analytics'
import { safeFormatUnits } from '@safe-global/utils/utils/formatters'
import CheckWallet from '@/components/common/CheckWallet'
import { TxModalContext } from '@/components/tx-flow'

// TODO: No need for an enum anymore
enum ModalType {
  ADD_TO_AB = 'ADD_TO_AB',
}

const ETHER = 'ether'

const defaultOpen = { [ModalType.ADD_TO_AB]: false }

const TransferActions = ({
  address,
  txInfo,
  trusted,
}: {
  address: string
  txInfo: Transfer
  trusted: boolean
}): ReactElement => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | undefined>()
  const [open, setOpen] = useState<typeof defaultOpen>(defaultOpen)
  const addressBook = useAddressBook()
  const name = addressBook?.[address]
  const { setTxFlow } = useContext(TxModalContext)

  const handleOpenContextMenu = (e: MouseEvent<HTMLButtonElement, globalThis.MouseEvent>) => {
    setAnchorEl(e.currentTarget)
  }

  const handleCloseContextMenu = () => {
    setAnchorEl(undefined)
  }

  const handleOpenModal = (type: keyof typeof open, event?: typeof TX_LIST_EVENTS.ADDRESS_BOOK) => () => {
    handleCloseContextMenu()
    setOpen((prev) => ({ ...prev, [type]: true }))

    if (event) {
      trackEvent(event)
    }
  }

  const handleCloseModal = () => {
    setOpen(defaultOpen)
  }

  const recipient = txInfo.recipient.value
  const tokenAddress = isNativeTokenTransfer(txInfo.transferInfo) ? ZERO_ADDRESS : txInfo.transferInfo.tokenAddress

  const amount = isNativeTokenTransfer(txInfo.transferInfo)
    ? safeFormatUnits(txInfo.transferInfo.value, ETHER)
    : isERC20Transfer(txInfo.transferInfo)
      ? safeFormatUnits(txInfo.transferInfo.value, txInfo.transferInfo.decimals)
      : undefined

  const isOutgoingTx = isOutgoingTransfer(txInfo)
  const canSendAgain =
    trusted && isOutgoingTx && (isNativeTokenTransfer(txInfo.transferInfo) || isERC20Transfer(txInfo.transferInfo))

  return (
    <>
      <IconButton edge="end" size="small" onClick={handleOpenContextMenu} sx={{ ml: '4px' }}>
        <MoreHorizIcon sx={({ palette }) => ({ color: palette.border.main })} fontSize="small" />
      </IconButton>
      <ContextMenu anchorEl={anchorEl} open={!!anchorEl} onClose={handleCloseContextMenu}>
        {canSendAgain && (
          <CheckWallet>
            {(isOk) => (
              <MenuItem
                onClick={() => {
                  handleCloseContextMenu()
                  setTxFlow(<TokenTransferFlow recipients={[{ recipient, tokenAddress, amount }]} />)
                }}
                disabled={!isOk}
              >
                <ListItemText>Send again</ListItemText>
              </MenuItem>
            )}
          </CheckWallet>
        )}

        <MenuItem onClick={handleOpenModal(ModalType.ADD_TO_AB, TX_LIST_EVENTS.ADDRESS_BOOK)}>
          <ListItemText>Add to address book</ListItemText>
        </MenuItem>
      </ContextMenu>

      {open[ModalType.ADD_TO_AB] && (
        <EntryDialog handleClose={handleCloseModal} defaultValues={{ name, address }} disableAddressInput />
      )}
    </>
  )
}

export default TransferActions
</file>

<file path="src/components/transactions/TxDetails/TxData/index.tsx">
import SettingsChangeTxInfo from '@/components/transactions/TxDetails/TxData/SettingsChange'
import type { SpendingLimitMethods } from '@/utils/transaction-guards'
import {
  isExecTxData,
  isOnChainConfirmationTxData,
  isSafeUpdateTxData,
  isStakingTxWithdrawInfo,
} from '@/utils/transaction-guards'
import { isStakingTxExitInfo } from '@/utils/transaction-guards'
import {
  isCancellationTxInfo,
  isCustomTxInfo,
  isMigrateToL2TxData,
  isMultisigDetailedExecutionInfo,
  isOrderTxInfo,
  isSettingsChangeTxInfo,
  isSpendingLimitMethod,
  isStakingTxDepositInfo,
  isSupportedSpendingLimitAddress,
  isTransferTxInfo,
} from '@/utils/transaction-guards'
import { SpendingLimits } from '@/components/transactions/TxDetails/TxData/SpendingLimits'
import { TransactionStatus, type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { type ReactElement } from 'react'
import RejectionTxInfo from '@/components/transactions/TxDetails/TxData/Rejection'
import TransferTxInfo from '@/components/transactions/TxDetails/TxData/Transfer'
import useChainId from '@/hooks/useChainId'
import { MigrationToL2TxData } from './MigrationToL2TxData'
import SwapOrder from '@/features/swap/components/SwapOrder'
import StakingTxDepositDetails from '@/features/stake/components/StakingTxDepositDetails'
import StakingTxExitDetails from '@/features/stake/components/StakingTxExitDetails'
import StakingTxWithdrawDetails from '@/features/stake/components/StakingTxWithdrawDetails'
import { OnChainConfirmation } from './NestedTransaction/OnChainConfirmation'
import { ExecTransaction } from './NestedTransaction/ExecTransaction'
import SafeUpdate from './SafeUpdate'
import DecodedData from './DecodedData'

const TxData = ({
  txInfo,
  txData,
  txDetails,
  trusted,
  imitation,
}: {
  txInfo: TransactionDetails['txInfo']
  txData: TransactionDetails['txData']
  txDetails?: TransactionDetails
  trusted: boolean
  imitation: boolean
}): ReactElement => {
  const chainId = useChainId()

  if (isOrderTxInfo(txInfo)) {
    return <SwapOrder txData={txData} txInfo={txInfo} />
  }

  if (isStakingTxDepositInfo(txInfo)) {
    return <StakingTxDepositDetails txData={txData} info={txInfo} />
  }

  if (isStakingTxExitInfo(txInfo)) {
    return <StakingTxExitDetails info={txInfo} />
  }

  if (isStakingTxWithdrawInfo(txInfo)) {
    return <StakingTxWithdrawDetails info={txInfo} />
  }

  if (isTransferTxInfo(txInfo)) {
    return (
      <TransferTxInfo
        txInfo={txInfo}
        txStatus={txDetails?.txStatus ?? TransactionStatus.AWAITING_CONFIRMATIONS}
        trusted={trusted}
        imitation={imitation}
      />
    )
  }

  if (isSettingsChangeTxInfo(txInfo)) {
    return <SettingsChangeTxInfo settingsInfo={txInfo.settingsInfo} isTxExecuted={!!txDetails?.executedAt} />
  }

  if (txDetails && isCancellationTxInfo(txInfo) && isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo)) {
    return <RejectionTxInfo nonce={txDetails.detailedExecutionInfo?.nonce} isTxExecuted={!!txDetails.executedAt} />
  }

  if (
    isCustomTxInfo(txInfo) &&
    isSupportedSpendingLimitAddress(txInfo, chainId) &&
    isSpendingLimitMethod(txData?.dataDecoded?.method)
  ) {
    return <SpendingLimits txData={txData} txInfo={txInfo} type={txData?.dataDecoded?.method as SpendingLimitMethods} />
  }

  if (txDetails && isMigrateToL2TxData(txData, chainId)) {
    return <MigrationToL2TxData txDetails={txDetails} />
  }

  if (isOnChainConfirmationTxData(txData)) {
    return <OnChainConfirmation data={txData} />
  }

  if (isExecTxData(txData)) {
    return <ExecTransaction data={txData} />
  }

  if (isSafeUpdateTxData(txData)) {
    return <SafeUpdate txData={txData} />
  }

  return <DecodedData txData={txData} toInfo={txData?.to} />
}

export default TxData
</file>

<file path="src/components/transactions/TxDetails/index.tsx">
import useIsExpiredSwap from '@/features/swap/hooks/useIsExpiredSwap'
import React, { type ReactElement, useEffect } from 'react'
import type { TransactionDetails, TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Box, CircularProgress, Typography } from '@mui/material'

import TxSigners from '@/components/transactions/TxSigners'
import Summary from '@/components/transactions/TxDetails/Summary'
import TxData from '@/components/transactions/TxDetails/TxData'
import useChainId from '@/hooks/useChainId'
import {
  isAwaitingExecution,
  isOrderTxInfo,
  isModuleExecutionInfo,
  isMultiSendTxInfo,
  isMultisigDetailedExecutionInfo,
  isMultisigExecutionInfo,
  isOpenSwapOrder,
  isTxQueued,
} from '@/utils/transaction-guards'
import { InfoDetails } from '@/components/transactions/InfoDetails'
import NamedAddressInfo from '@/components/common/NamedAddressInfo'
import css from './styles.module.css'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { ErrorBoundary } from '@sentry/react'
import ExecuteTxButton from '@/components/transactions/ExecuteTxButton'
import SignTxButton from '@/components/transactions/SignTxButton'
import RejectTxButton from '@/components/transactions/RejectTxButton'
import { UnsignedWarning } from '@/components/transactions/Warning'
import Multisend from '@/components/transactions/TxDetails/TxData/DecodedData/Multisend'
import useSafeInfo from '@/hooks/useSafeInfo'
import useIsPending from '@/hooks/useIsPending'
import { isImitation, isTrustedTx } from '@/utils/transactions'
import { useHasFeature } from '@/hooks/useChains'
import { useGetTransactionDetailsQuery } from '@/store/api/gateway'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { POLLING_INTERVAL } from '@/config/constants'
import { TxNote } from '@/features/tx-notes'
import { TxShareBlock } from '../TxShareLink'
import { TxShareButton } from '../TxShareLink/TxShareButton'
import { FEATURES } from '@safe-global/utils/utils/chains'

export const NOT_AVAILABLE = 'n/a'

type TxDetailsProps = {
  txSummary: TransactionSummary
  txDetails: TransactionDetails
}

const TxDetailsBlock = ({ txSummary, txDetails }: TxDetailsProps): ReactElement => {
  const isPending = useIsPending(txSummary.id)
  const hasDefaultTokenlist = useHasFeature(FEATURES.DEFAULT_TOKENLIST)
  const isQueue = isTxQueued(txSummary.txStatus)
  const awaitingExecution = isAwaitingExecution(txSummary.txStatus)
  const isUnsigned =
    isMultisigExecutionInfo(txSummary.executionInfo) && txSummary.executionInfo.confirmationsSubmitted === 0

  const isTxFromProposer =
    isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo) &&
    txDetails.detailedExecutionInfo.trusted &&
    isUnsigned

  const isUntrusted =
    isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo) && !txDetails.detailedExecutionInfo.trusted

  // If we have no token list we always trust the transfer
  const isTrustedTransfer = !hasDefaultTokenlist || isTrustedTx(txSummary)
  const isImitationTransaction = isImitation(txSummary)

  let proposer, safeTxHash, proposedByDelegate
  if (isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo)) {
    safeTxHash = txDetails.detailedExecutionInfo.safeTxHash
    // @ts-expect-error TODO: Need to update the types from the new SDK
    proposedByDelegate = txDetails.detailedExecutionInfo.proposedByDelegate
    proposer = proposedByDelegate?.value ?? txDetails.detailedExecutionInfo.proposer?.value
  }

  const expiredSwap = useIsExpiredSwap(txSummary.txInfo)

  // Module address, name and logoUri
  const moduleAddress = isModuleExecutionInfo(txSummary.executionInfo) ? txSummary.executionInfo.address : undefined
  const moduleAddressInfo = moduleAddress ? txDetails.txData?.addressInfoIndex?.[moduleAddress.value] : undefined

  return (
    <>
      {/* /Details */}
      <div className={`${css.details} ${isUnsigned ? css.noSigners : ''}`}>
        <div className={css.txNote}>
          <TxNote txDetails={txDetails} />
        </div>

        <div className={css.shareLink}>
          <TxShareButton txId={txSummary.id} />
        </div>

        <div className={css.txData}>
          <ErrorBoundary fallback={<div>Error parsing data</div>}>
            <TxData
              txData={txDetails.txData}
              txInfo={txDetails.txInfo}
              txDetails={txDetails}
              trusted={isTrustedTransfer}
              imitation={isImitationTransaction}
            />
          </ErrorBoundary>
        </div>

        {/* Module information*/}
        {moduleAddress && (
          <div className={css.txModule}>
            <InfoDetails title="Executed via module:">
              <NamedAddressInfo
                address={moduleAddress.value}
                name={moduleAddressInfo?.name || moduleAddress.name}
                customAvatar={moduleAddressInfo?.logoUri || moduleAddress.logoUri}
                shortAddress={false}
                showCopyButton
                hasExplorer
              />
            </InfoDetails>
          </div>
        )}

        <div className={css.txSummary}>
          {isUntrusted && !isPending && <UnsignedWarning />}

          <Summary txDetails={txDetails} txData={txDetails.txData} txInfo={txDetails.txInfo} />
        </div>

        {(isMultiSendTxInfo(txDetails.txInfo) || isOrderTxInfo(txDetails.txInfo)) && (
          <div className={css.multiSend}>
            <ErrorBoundary fallback={<div>Error parsing data</div>}>
              <Multisend txData={txDetails.txData} />
            </ErrorBoundary>
          </div>
        )}
      </div>
      {/* Signers */}
      {(!isUnsigned || isTxFromProposer) && (
        <div className={css.txSigners}>
          <TxSigners
            txDetails={txDetails}
            txSummary={txSummary}
            isTxFromProposer={isTxFromProposer}
            proposer={proposedByDelegate}
          />

          <TxShareBlock txId={txDetails.txId} txHash={txDetails.txHash} />

          {isQueue && (
            <Box className={css.buttons}>
              {awaitingExecution ? <ExecuteTxButton txSummary={txSummary} /> : <SignTxButton txSummary={txSummary} />}
              <RejectTxButton txSummary={txSummary} safeTxHash={safeTxHash} proposer={proposer} />
            </Box>
          )}

          {isQueue && expiredSwap && (
            <Typography color="text.secondary" mt={2}>
              This order has expired. Reject this transaction and try again.
            </Typography>
          )}
        </div>
      )}
    </>
  )
}

const TxDetails = ({
  txSummary,
  txDetails,
}: {
  txSummary: TransactionSummary
  txDetails?: TransactionDetails // optional
}): ReactElement => {
  const chainId = useChainId()
  const { safe } = useSafeInfo()

  const {
    data: txDetailsData,
    error,
    isLoading: loading,
    refetch,
    isUninitialized,
  } = useGetTransactionDetailsQuery(
    { chainId, txId: txSummary.id },
    {
      pollingInterval: isOpenSwapOrder(txSummary.txInfo) ? POLLING_INTERVAL : undefined,
      skipPollingIfUnfocused: true,
    },
  )

  useEffect(() => {
    !isUninitialized && refetch()
  }, [safe.txQueuedTag, refetch, txDetails, isUninitialized])

  return (
    <div className={css.container}>
      {txDetailsData ? (
        <TxDetailsBlock txSummary={txSummary} txDetails={txDetailsData} />
      ) : loading ? (
        <div className={css.loading}>
          <CircularProgress />
        </div>
      ) : (
        error && (
          <div className={css.error}>
            <ErrorMessage error={asError(error)}>Couldn&apos;t load the transaction details</ErrorMessage>
          </div>
        )
      )}
    </div>
  )
}

export default TxDetails
</file>

<file path="src/components/transactions/TxDetails/SafeTxGasForm.tsx">
import { useContext, useState } from 'react'
import { Link, Box, Paper, Button } from '@mui/material'
import { useForm } from 'react-hook-form'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import NumberField from '@/components/common/NumberField'
import useSafeInfo from '@/hooks/useSafeInfo'

import { isLegacyVersion } from '@safe-global/utils/services/contracts/utils'

type FormFields = {
  safeTxGas: string
}

const Form = ({ onSubmit }: { onSubmit: () => void }) => {
  const { safeTxGas = '0', setSafeTxGas } = useContext(SafeTxContext)

  const formMethods = useForm<FormFields>({
    defaultValues: {
      safeTxGas,
    },
    mode: 'onChange',
  })

  const onFormSubmit = (values: FormFields) => {
    setSafeTxGas(values.safeTxGas || '0')
    onSubmit()
  }

  // Close the form w/o submitting if the user clicks outside of it
  const onBlur = () => {
    setTimeout(onSubmit, 100)
  }

  return (
    <Paper sx={{ position: 'absolute', zIndex: 2, p: 1, ml: '-22px' }} elevation={2}>
      <form onSubmit={formMethods.handleSubmit(onFormSubmit)} style={{ display: 'flex' }}>
        <NumberField
          size="small"
          autoFocus
          type="number"
          error={!!formMethods.formState.errors.safeTxGas}
          sx={{ width: '7em' }}
          {...formMethods.register('safeTxGas', {
            valueAsNumber: true,
            min: 0,
            setValueAs: Math.round,
            onBlur,
          })}
        />
        <Button type="submit" size="small" variant="contained" sx={{ ml: 1 }}>
          Save
        </Button>
      </form>
    </Paper>
  )
}

const SafeTxGasForm = () => {
  const { safeTx, safeTxGas = 0 } = useContext(SafeTxContext)
  const { safe } = useSafeInfo()
  const isOldSafe = safe.version && isLegacyVersion(safe.version)
  const isEditable = safeTx?.signatures.size === 0 && (Number(safeTxGas) > 0 || isOldSafe)
  const [editing, setEditing] = useState(false)

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        position: 'relative',
      }}
    >
      {safeTxGas}
      {isEditable && (
        <Link
          component="button"
          onClick={() => setEditing(true)}
          sx={{
            fontSize: 'small',
          }}
        >
          Edit
        </Link>
      )}
      {editing && <Form onSubmit={() => setEditing(false)} />}
    </Box>
  )
}

export default SafeTxGasForm
</file>

<file path="src/components/transactions/TxDetails/styles.module.css">
.container {
  display: flex;
  width: 100%;
  overflow-x: auto;
}

.details {
  width: 66.6%;
  display: flex;
  flex-direction: column;
  position: relative;
}

.shareLink {
  display: flex;
  justify-content: flex-end;
  margin: var(--space-1);
  margin-bottom: -40px;
}

.txNote {
  margin: var(--space-1) 0;
  padding: 0 var(--space-2) var(--space-2);
  border-bottom: 1px solid var(--color-border-light);
}

.txNote:empty {
  display: none;
}

.loading,
.error,
.txData,
.txSummary,
.advancedDetails,
.txModule {
  padding: var(--space-2);
}

.txData {
  border-bottom: 1px solid var(--color-border-light);
}

.txData:empty {
  display: none;
}

.txSummary,
.advancedDetails {
  height: 100%;
}

.txSigners {
  display: flex;
  width: 33.3%;
  flex-direction: column;
  padding: var(--space-3);
  border-left: 1px solid var(--color-border-light);
  gap: var(--space-2);
}

.delegateCall .alert {
  width: fit-content;
  padding: 0 var(--space-1);
}

.multiSend {
  border-bottom: 1px solid var(--color-border-light);
}

.buttons {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  gap: var(--space-1);
}

.buttons > * {
  flex: 1;
}

.buttons button {
  width: 100%;
}

@media (max-width: 599.95px) {
  .container {
    flex-direction: column;
  }

  .details {
    width: 100%;
  }

  .txSigners {
    width: 100%;
    border-left: 0;
    border-top: 1px solid var(--color-border-light);
  }
}
</file>

<file path="src/components/transactions/TxFilterForm/index.tsx">
import Paper from '@mui/material/Paper'
import Grid from '@mui/material/Grid'
import FormControl from '@mui/material/FormControl'
import RadioGroup from '@mui/material/RadioGroup'
import FormLabel from '@mui/material/FormLabel'
import FormControlLabel from '@mui/material/FormControlLabel'
import Radio from '@mui/material/Radio'
import Button from '@mui/material/Button'
import Divider from '@mui/material/Divider'
import { isBefore, isAfter, startOfDay } from 'date-fns'
import { Controller, FormProvider, useForm, useFormState, type DefaultValues } from 'react-hook-form'
import { useMemo, type ReactElement } from 'react'

import AddressBookInput from '@/components/common/AddressBookInput'
import DatePickerInput from '@/components/common/DatePickerInput'
import { validateAmount } from '@safe-global/utils/utils/validation'
import { trackEvent } from '@/services/analytics'
import { TX_LIST_EVENTS } from '@/services/analytics/events/txList'
import { txFilter, useTxFilter, TxFilterType, type TxFilter } from '@/utils/tx-history-filter'
import { useCurrentChain } from '@/hooks/useChains'
import NumberField from '@/components/common/NumberField'

import css from './styles.module.css'
import inputCss from '@/styles/inputs.module.css'
import AddressInput from '@/components/common/AddressInput'

enum TxFilterFormFieldNames {
  FILTER_TYPE = 'type',
  DATE_FROM = 'execution_date__gte',
  DATE_TO = 'execution_date__lte',
  RECIPIENT = 'to',
  AMOUNT = 'value',
  TOKEN_ADDRESS = 'token_address',
  MODULE = 'module',
  NONCE = 'nonce',
}

export type TxFilterFormState = {
  [TxFilterFormFieldNames.FILTER_TYPE]: TxFilterType
  [TxFilterFormFieldNames.DATE_FROM]: Date | null
  [TxFilterFormFieldNames.DATE_TO]: Date | null
  [TxFilterFormFieldNames.RECIPIENT]: string
  [TxFilterFormFieldNames.AMOUNT]: string
  [TxFilterFormFieldNames.TOKEN_ADDRESS]: string
  [TxFilterFormFieldNames.MODULE]: string
  [TxFilterFormFieldNames.NONCE]: string
}

const defaultValues: DefaultValues<TxFilterFormState> = {
  [TxFilterFormFieldNames.FILTER_TYPE]: TxFilterType.INCOMING,
  [TxFilterFormFieldNames.DATE_FROM]: null,
  [TxFilterFormFieldNames.DATE_TO]: null,
  [TxFilterFormFieldNames.RECIPIENT]: '',
  [TxFilterFormFieldNames.AMOUNT]: '',
  [TxFilterFormFieldNames.TOKEN_ADDRESS]: '',
  [TxFilterFormFieldNames.MODULE]: '',
  [TxFilterFormFieldNames.NONCE]: '',
}

const getInitialFormValues = (filter: TxFilter | null): DefaultValues<TxFilterFormState> => {
  return filter
    ? {
        ...defaultValues,
        ...txFilter.formatFormData(filter),
      }
    : defaultValues
}

const TxFilterForm = ({ toggleFilter }: { toggleFilter: () => void }): ReactElement => {
  const [filter, setFilter] = useTxFilter()
  const chain = useCurrentChain()

  const formMethods = useForm<TxFilterFormState>({
    mode: 'onChange',
    shouldUnregister: true,
    defaultValues: getInitialFormValues(filter),
  })

  const { control, watch, handleSubmit, reset, getValues } = formMethods

  const filterType = watch(TxFilterFormFieldNames.FILTER_TYPE)

  const isIncomingFilter = filterType === TxFilterType.INCOMING
  const isMultisigFilter = filterType === TxFilterType.MULTISIG
  const isModuleFilter = filterType === TxFilterType.MODULE

  // Only subscribe to relevant `formState`
  const { dirtyFields, isValid } = useFormState({ control })

  const dirtyFieldNames = Object.keys(dirtyFields)

  const canClear = useMemo(() => {
    const isFormDirty = dirtyFieldNames.some((name) => name !== TxFilterFormFieldNames.FILTER_TYPE)
    const hasFilterInQuery = !!filter?.type
    return !isValid || isFormDirty || hasFilterInQuery
  }, [dirtyFieldNames, filter?.type, isValid])

  const clearFilter = () => {
    setFilter(null)

    reset({
      ...defaultValues,
      // Persist the current type
      [TxFilterFormFieldNames.FILTER_TYPE]: getValues(TxFilterFormFieldNames.FILTER_TYPE),
    })
  }

  const onSubmit = (data: TxFilterFormState) => {
    for (const name of dirtyFieldNames) {
      trackEvent({ ...TX_LIST_EVENTS.FILTER, label: name })
    }

    const filterData = txFilter.parseFormData(data)

    setFilter(filterData)

    toggleFilter()
  }

  return (
    <Paper elevation={0} variant="outlined" className={css.filterWrapper}>
      <FormProvider {...formMethods}>
        <form onSubmit={handleSubmit(onSubmit)}>
          <Grid data-testid="filter-modal" container>
            <Grid item xs={12} md={3} sx={{ p: 4 }}>
              <FormControl>
                <FormLabel sx={{ mb: 2, color: ({ palette }) => palette.primary.light }}>Transaction type</FormLabel>
                <Controller
                  name={TxFilterFormFieldNames.FILTER_TYPE}
                  control={control}
                  render={({ field }) => (
                    <RadioGroup {...field}>
                      {Object.values(TxFilterType).map((value) => (
                        <FormControlLabel value={value} control={<Radio />} label={value} key={value} />
                      ))}
                    </RadioGroup>
                  )}
                />
              </FormControl>
            </Grid>

            <Divider orientation="vertical" flexItem />

            <Grid item xs={12} md={8} sx={{ p: 4 }}>
              <FormControl sx={{ width: '100%' }}>
                <FormLabel sx={{ mb: 3, color: ({ palette }) => palette.primary.light }}>Parameters</FormLabel>
                <Grid container item spacing={2} xs={12}>
                  {!isModuleFilter && (
                    <>
                      <Grid data-testid="start-date" item xs={12} md={6}>
                        <DatePickerInput
                          name={TxFilterFormFieldNames.DATE_FROM}
                          label="From"
                          deps={[TxFilterFormFieldNames.DATE_TO]}
                          validate={(val: TxFilterFormState[TxFilterFormFieldNames.DATE_FROM]) => {
                            const toDate = getValues(TxFilterFormFieldNames.DATE_TO)
                            if (val && toDate && isBefore(startOfDay(toDate), startOfDay(val))) {
                              return 'Must be before "To" date'
                            }
                          }}
                        />
                      </Grid>
                      <Grid data-testid="end-date" item xs={12} md={6}>
                        <DatePickerInput
                          name={TxFilterFormFieldNames.DATE_TO}
                          label="To"
                          deps={[TxFilterFormFieldNames.DATE_FROM]}
                          validate={(val: TxFilterFormState[TxFilterFormFieldNames.DATE_FROM]) => {
                            const fromDate = getValues(TxFilterFormFieldNames.DATE_FROM)
                            if (val && fromDate && isAfter(startOfDay(fromDate), startOfDay(val))) {
                              return 'Must be after "From" date'
                            }
                          }}
                        />
                      </Grid>

                      <Grid item xs={12} md={6}>
                        <Controller
                          name={TxFilterFormFieldNames.AMOUNT}
                          control={control}
                          rules={{
                            validate: (val: TxFilterFormState[TxFilterFormFieldNames.AMOUNT]) => {
                              if (val?.length > 0) {
                                return validateAmount(val)
                              }
                            },
                          }}
                          render={({ field, fieldState }) => (
                            <NumberField
                              data-testid="amount-input"
                              className={inputCss.input}
                              label={
                                fieldState.error?.message ||
                                (isIncomingFilter ? 'Amount' : `Amount (only ${chain?.nativeCurrency.symbol || 'ETH'})`)
                              }
                              error={!!fieldState.error}
                              {...field}
                              fullWidth
                            />
                          )}
                        />
                      </Grid>
                    </>
                  )}

                  {isIncomingFilter && (
                    <Grid item xs={12} md={6}>
                      <AddressInput
                        data-testid="token-input"
                        label="Token address"
                        name={TxFilterFormFieldNames.TOKEN_ADDRESS}
                        required={false}
                        fullWidth
                      />
                    </Grid>
                  )}

                  {isMultisigFilter && (
                    <>
                      <Grid item xs={12} md={6}>
                        <AddressBookInput
                          label="Recipient"
                          name={TxFilterFormFieldNames.RECIPIENT}
                          required={false}
                          fullWidth
                        />
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Controller
                          name={TxFilterFormFieldNames.NONCE}
                          control={control}
                          rules={{
                            validate: (val: TxFilterFormState[TxFilterFormFieldNames.NONCE]) => {
                              if (val?.length > 0) {
                                return validateAmount(val)
                              }
                            },
                          }}
                          render={({ field, fieldState }) => (
                            <NumberField
                              data-testid="nonce-input"
                              className={inputCss.input}
                              label={fieldState.error?.message || 'Nonce'}
                              error={!!fieldState.error}
                              {...field}
                              fullWidth
                            />
                          )}
                        />
                      </Grid>
                    </>
                  )}

                  {isModuleFilter && (
                    <Grid item xs={12} md={6}>
                      <AddressBookInput
                        label="Module"
                        name={TxFilterFormFieldNames.MODULE}
                        required={false}
                        fullWidth
                      />
                    </Grid>
                  )}
                </Grid>
              </FormControl>

              <Grid item container md={6} sx={{ gap: 2, mt: 3 }}>
                <Button data-testid="clear-btn" variant="contained" onClick={clearFilter} disabled={!canClear}>
                  Clear
                </Button>
                <Button data-testid="apply-btn" type="submit" variant="contained" color="primary" disabled={!isValid}>
                  Apply
                </Button>
              </Grid>
            </Grid>
          </Grid>
        </form>
      </FormProvider>
    </Paper>
  )
}

export default TxFilterForm
</file>

<file path="src/components/transactions/TxFilterForm/styles.module.css">
.filterWrapper {
  position: sticky;
  z-index: 2;
  top: 144px;
  border-width: 1px;
}

@media (max-width: 599.95px) {
  .filterWrapper {
    position: relative;
    z-index: 0;
    top: 0;
  }
}
</file>

<file path="src/components/transactions/TxHeader/index.tsx">
import type { ReactElement, ReactNode } from 'react'

import PageHeader from '@/components/common/PageHeader'
import css from '@/components/common/PageHeader/styles.module.css'
import TxNavigation from '@/components/transactions/TxNavigation'

const TxHeader = ({ children }: { children?: ReactNode }): ReactElement => {
  return (
    <PageHeader
      title="Transactions"
      action={
        <div className={css.pageHeader}>
          <div className={css.navWrapper}>
            <TxNavigation />
          </div>
          {children && <div className={css.actionsWrapper}>{children}</div>}
        </div>
      }
    />
  )
}

export default TxHeader
</file>

<file path="src/components/transactions/TxInfo/index.tsx">
import { type ReactElement } from 'react'
import type {
  Creation,
  Custom,
  MultiSend,
  SettingsChange,
  TransactionInfo,
  Transfer,
} from '@safe-global/safe-gateway-typescript-sdk'
import { SettingsInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import TokenAmount from '@/components/common/TokenAmount'
import {
  isOrderTxInfo,
  isCreationTxInfo,
  isCustomTxInfo,
  isERC20Transfer,
  isERC721Transfer,
  isMultiSendTxInfo,
  isNativeTokenTransfer,
  isSettingsChangeTxInfo,
  isTransferTxInfo,
  isMigrateToL2TxInfo,
  isStakingTxDepositInfo,
  isStakingTxExitInfo,
  isStakingTxWithdrawInfo,
} from '@/utils/transaction-guards'
import { ellipsis, maybePlural, shortenAddress } from '@safe-global/utils/utils/formatters'
import { useCurrentChain } from '@/hooks/useChains'
import { SwapTx } from '@/features/swap/components/SwapTxInfo/SwapTx'
import StakingTxExitInfo from '@/features/stake/components/StakingTxExitInfo'
import StakingTxWithdrawInfo from '@/features/stake/components/StakingTxWithdrawInfo'
import { Box } from '@mui/material'
import css from './styles.module.css'
import StakingTxDepositInfo from '@/features/stake/components/StakingTxDepositInfo'

export const TransferTx = ({
  info,
  omitSign = false,
  withLogo = true,
  preciseAmount = false,
}: {
  info: Transfer
  omitSign?: boolean
  withLogo?: boolean
  preciseAmount?: boolean
}): ReactElement => {
  const chainConfig = useCurrentChain()
  const { nativeCurrency } = chainConfig || {}
  const transfer = info.transferInfo
  const direction = omitSign ? undefined : info.direction

  if (isNativeTokenTransfer(transfer)) {
    return (
      <TokenAmount
        direction={direction}
        value={transfer.value}
        decimals={nativeCurrency?.decimals}
        tokenSymbol={nativeCurrency?.symbol}
        logoUri={withLogo ? nativeCurrency?.logoUri : undefined}
        preciseAmount={preciseAmount}
      />
    )
  }

  if (isERC20Transfer(transfer)) {
    return (
      <TokenAmount
        {...transfer}
        direction={direction}
        logoUri={withLogo ? transfer?.logoUri : undefined}
        preciseAmount={preciseAmount}
      />
    )
  }

  if (isERC721Transfer(transfer)) {
    return (
      <TokenAmount
        {...transfer}
        tokenSymbol={ellipsis(
          `${transfer.tokenSymbol ? transfer.tokenSymbol : 'Unknown NFT'} #${transfer.tokenId}`,
          withLogo ? 16 : 100,
        )}
        value="1"
        decimals={0}
        direction={undefined}
        logoUri={withLogo ? transfer?.logoUri : undefined}
        fallbackSrc="/images/common/nft-placeholder.png"
      />
    )
  }

  return <></>
}

const CustomTx = ({ info }: { info: Custom }): ReactElement => {
  return <Box className={css.txInfo}>{info.methodName}</Box>
}

const CreationTx = ({ info }: { info: Creation }): ReactElement => {
  return <Box className={css.txInfo}>Created by {shortenAddress(info.creator.value)}</Box>
}

const MultiSendTx = ({ info }: { info: MultiSend }): ReactElement => {
  return (
    <Box className={css.txInfo}>
      {info.actionCount} {`action${maybePlural(info.actionCount)}`}
    </Box>
  )
}

const SettingsChangeTx = ({ info }: { info: SettingsChange }): ReactElement => {
  if (
    info.settingsInfo?.type === SettingsInfoType.ENABLE_MODULE ||
    info.settingsInfo?.type === SettingsInfoType.DISABLE_MODULE
  ) {
    return <Box className={css.txInfo}>{info.settingsInfo.module.name}</Box>
  }
  return <></>
}

const MigrationToL2Tx = (): ReactElement => {
  return <>Migrate base contract</>
}

const TxInfo = ({ info, ...rest }: { info: TransactionInfo; omitSign?: boolean; withLogo?: boolean }): ReactElement => {
  if (isSettingsChangeTxInfo(info)) {
    return <SettingsChangeTx info={info} />
  }

  if (isMultiSendTxInfo(info)) {
    return <MultiSendTx info={info} />
  }

  if (isTransferTxInfo(info)) {
    return <TransferTx info={info} {...rest} />
  }

  if (isMigrateToL2TxInfo(info)) {
    return <MigrationToL2Tx />
  }

  if (isCreationTxInfo(info)) {
    return <CreationTx info={info} />
  }

  if (isOrderTxInfo(info)) {
    return <SwapTx info={info} />
  }

  if (isStakingTxDepositInfo(info)) {
    return <StakingTxDepositInfo info={info} />
  }

  if (isStakingTxExitInfo(info)) {
    return <StakingTxExitInfo info={info} />
  }

  if (isStakingTxWithdrawInfo(info)) {
    return <StakingTxWithdrawInfo info={info} />
  }

  if (isCustomTxInfo(info)) {
    return <CustomTx info={info} />
  }

  return <></>
}

export default TxInfo
</file>

<file path="src/components/transactions/TxInfo/styles.module.css">
.txInfo {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</file>

<file path="src/components/transactions/TxList/index.tsx">
import GroupedTxListItems from '@/components/transactions/GroupedTxListItems'
import { groupTxs } from '@/utils/tx-list'
import { Box } from '@mui/material'
import type { Transaction, TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement, ReactNode } from 'react'
import { useMemo } from 'react'
import TxListItem from '../TxListItem'
import css from './styles.module.css'
import uniq from 'lodash/uniq'
import BulkTxListGroup from '@/components/transactions/BulkTxListGroup'

type TxListProps = {
  items: TransactionListPage['results']
}

const getBulkGroupTxHash = (group: Transaction[]) => {
  const hashList = group.map((item) => item.transaction.txHash)
  return uniq(hashList).length === 1 ? hashList[0] : undefined
}

export const TxListGrid = ({ children }: { children: ReactNode }): ReactElement => {
  return <Box className={css.container}>{children}</Box>
}

const TxList = ({ items }: TxListProps): ReactElement => {
  const groupedTransactions = useMemo(() => groupTxs(items), [items])

  const transactions = groupedTransactions.map((item, index) => {
    if (!Array.isArray(item)) {
      return <TxListItem key={index} item={item} />
    }

    const bulkTransactionHash = getBulkGroupTxHash(item)
    if (bulkTransactionHash) {
      return <BulkTxListGroup key={index} groupedListItems={item} transactionHash={bulkTransactionHash} />
    }

    return <GroupedTxListItems key={index} groupedListItems={item} />
  })

  return <TxListGrid>{transactions}</TxListGrid>
}

export default TxList
</file>

<file path="src/components/transactions/TxList/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 6px;
}

.container:first-of-type {
  margin-top: 0;
}
</file>

<file path="src/components/transactions/TxListItem/ExpandableTransactionItem.tsx">
import { type Transaction, type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { Accordion, AccordionDetails, AccordionSummary, Box, Skeleton } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import TxSummary from '@/components/transactions/TxSummary'
import TxDetails from '@/components/transactions/TxDetails'
import CreateTxInfo from '@/components/transactions/SafeCreationTx'
import { isCreationTxInfo } from '@/utils/transaction-guards'
import { useContext } from 'react'
import { BatchExecuteHoverContext } from '@/components/transactions/BatchExecuteButton/BatchExecuteHoverProvider'
import css from './styles.module.css'
import classNames from 'classnames'
import { trackEvent, TX_LIST_EVENTS } from '@/services/analytics'

type ExpandableTransactionItemProps = {
  isConflictGroup?: boolean
  isBulkGroup?: boolean
  item: Transaction
  txDetails?: TransactionDetails
}

export const ExpandableTransactionItem = ({
  isConflictGroup = false,
  isBulkGroup = false,
  item,
  txDetails,
  testId,
}: ExpandableTransactionItemProps & { testId?: string }) => {
  const hoverContext = useContext(BatchExecuteHoverContext)

  const isBatched = hoverContext.activeHover.includes(item.transaction.id)

  return (
    <Accordion
      disableGutters
      TransitionProps={{
        mountOnEnter: true,
        unmountOnExit: false,
      }}
      elevation={0}
      defaultExpanded={!!txDetails}
      className={classNames(css.listItem, { [css.batched]: isBatched })}
      data-testid={testId}
      onChange={(_, expanded) => {
        if (expanded) {
          trackEvent(TX_LIST_EVENTS.EXPAND_TRANSACTION)
        }
      }}
    >
      <AccordionSummary
        expandIcon={<ExpandMoreIcon />}
        sx={{
          justifyContent: 'flex-start',
          overflowX: 'auto',
          ['.MuiAccordionSummary-content, .MuiAccordionSummary-content.Mui-expanded']: {
            overflow: 'hidden',
            margin: 0,
            padding: '12px 0',
          },
        }}
        component="div"
      >
        <TxSummary item={item} isConflictGroup={isConflictGroup} isBulkGroup={isBulkGroup} />
      </AccordionSummary>

      <AccordionDetails data-testid="accordion-details" sx={{ padding: 0 }}>
        {isCreationTxInfo(item.transaction.txInfo) ? (
          <CreateTxInfo txSummary={item.transaction} />
        ) : (
          <TxDetails txSummary={item.transaction} txDetails={txDetails} />
        )}
      </AccordionDetails>
    </Accordion>
  )
}

export const TransactionSkeleton = () => (
  <>
    <Box pt="20px" pb="4px">
      <Skeleton variant="text" width="35px" />
    </Box>

    <Accordion disableGutters elevation={0} defaultExpanded>
      <AccordionSummary expandIcon={<ExpandMoreIcon />} sx={{ justifyContent: 'flex-start', overflowX: 'auto' }}>
        <Skeleton width="100%" />
      </AccordionSummary>

      <AccordionDetails sx={{ padding: 0 }}>
        <Skeleton variant="rounded" width="100%" height="325px" />
      </AccordionDetails>
    </Accordion>
  </>
)

export default ExpandableTransactionItem
</file>

<file path="src/components/transactions/TxListItem/index.tsx">
import { type ReactElement } from 'react'
import type { TransactionListItem } from '@safe-global/safe-gateway-typescript-sdk'
import { isDateLabel, isLabelListItem, isTransactionListItem } from '@/utils/transaction-guards'
import GroupLabel from '@/components/transactions/GroupLabel'
import TxDateLabel from '@/components/transactions/TxDateLabel'
import ExpandableTransactionItem from './ExpandableTransactionItem'

type TxListItemProps = {
  item: TransactionListItem
}

const TxListItem = ({ item }: TxListItemProps): ReactElement | null => {
  if (isLabelListItem(item)) {
    return <GroupLabel item={item} />
  }
  if (isTransactionListItem(item)) {
    return <ExpandableTransactionItem item={item} />
  }
  if (isDateLabel(item)) {
    return <TxDateLabel item={item} />
  }
  return null
}

export default TxListItem
</file>

<file path="src/components/transactions/TxListItem/styles.module.css">
.listItem {
  border-color: transparent;
}

.closed:hover,
.batched {
  background-color: var(--color-secondary-background);
  border-color: var(--color-secondary-light);
}

.expanded {
  border-color: var(--color-secondary-light) !important;
}

.expanded :global .MuiAccordionSummary-root {
  background-color: var(--color-secondary-background);
}
</file>

<file path="src/components/transactions/TxNavigation/index.tsx">
import NavTabs from '@/components/common/NavTabs'
import { transactionNavItems } from '@/components/sidebar/SidebarNavigation/config'
import { AppRoutes } from '@/config/routes'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

const TxNavigation = () => {
  const isEIP1271 = useHasFeature(FEATURES.EIP1271)

  const navItems = isEIP1271
    ? transactionNavItems
    : transactionNavItems.filter((item) => item.href !== AppRoutes.transactions.messages)

  return <NavTabs tabs={navItems} />
}

export default TxNavigation
</file>

<file path="src/components/transactions/TxShareLink/index.tsx">
import { Accordion, AccordionDetails, AccordionSummary, Box, Button, Paper, SvgIcon, Typography } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'

import ShareIcon from '@/public/images/messages/link.svg'
import { CopyDeeplinkLabels, trackEvent, TX_LIST_EVENTS } from '@/services/analytics'
import TxShareLink from './TxShareLink'

import css from './styles.module.css'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import { useCurrentChain } from '@/hooks/useChains'
import ExplorerButton from '@/components/common/ExplorerButton'

function TxShareAccordion({ noExpand = false }: { noExpand: boolean }) {
  const onExpand = (_: React.SyntheticEvent, expanded: boolean) => {
    if (expanded) {
      trackEvent(TX_LIST_EVENTS.OPEN_SHARE_BLOCK)
    }
  }

  return (
    <Accordion className={css.accordion} onChange={onExpand} disabled={noExpand}>
      <AccordionSummary expandIcon={noExpand ? null : <ExpandMoreIcon />} className={css.summary}>
        <Typography className={css.header}>Share link{!noExpand && ' with other signers'}</Typography>
      </AccordionSummary>

      <AccordionDetails data-testid="share-block-details" className={css.details}>
        If signers have previously subscribed to notifications, they will be notified about signing this transaction.
        You can also share the link with them to speed up the process.
      </AccordionDetails>
    </Accordion>
  )
}

function ExplorerLink({ txHash }: { txHash: string }) {
  const chain = useCurrentChain()
  const explorerLiknk = chain ? getBlockExplorerLink(chain, txHash) : undefined

  return (
    <Button variant="text" size="compact" className={css.button}>
      <ExplorerButton {...explorerLiknk} isCompact={false} fontSize="14px" />
    </Button>
  )
}

export function TxShareBlock({ txId, txHash }: { txId: string; txHash?: string }) {
  return (
    <Paper data-testid="share-block" className={css.wrapper}>
      <TxShareAccordion noExpand={!!txHash} />

      <Box p={2} pt={0.5} display="flex" flexWrap="wrap" alignItems="center" gap={1}>
        <TxShareLink id={txId} eventLabel={CopyDeeplinkLabels.shareBlock}>
          <Button
            data-testid="copy-link-btn"
            variant="outlined"
            size="compact"
            startIcon={<SvgIcon component={ShareIcon} inheritViewBox fontSize="small" />}
            className={css.button}
          >
            Copy link
          </Button>
        </TxShareLink>

        {txHash && <ExplorerLink txHash={txHash} />}
      </Box>
    </Paper>
  )
}
</file>

<file path="src/components/transactions/TxShareLink/styles.module.css">
.wrapper {
  border: 1px solid var(--color-border-light);
}

.accordion {
  border: unset;
}

.accordion {
  background-color: unset !important;
}

.accordion button {
  opacity: 1 !important;
}

.summary {
  background-color: unset !important;
}

.header {
  font-weight: 700;
}

.details {
  padding-top: 0;
  padding-bottom: 12px;
}

.button {
  padding: var(--space-2);
  padding-top: 4px;
  padding-bottom: 4px;
  white-space: nowrap;
}
</file>

<file path="src/components/transactions/TxShareLink/TxShareButton.tsx">
import { IconButton, Link, SvgIcon } from '@mui/material'
import React from 'react'
import type { ReactElement } from 'react'

import ShareIcon from '@/public/images/common/share.svg'
import TxShareLink from './TxShareLink'
import { CopyDeeplinkLabels } from '@/services/analytics'

export function TxShareButton({ txId }: { txId: string }): ReactElement {
  return (
    <TxShareLink id={txId} eventLabel={CopyDeeplinkLabels.button}>
      <IconButton data-testid="share-btn" component={Link} aria-label="Share">
        <SvgIcon component={ShareIcon} inheritViewBox fontSize="small" color="border" />
      </IconButton>
    </TxShareLink>
  )
}
</file>

<file path="src/components/transactions/TxShareLink/TxShareLink.tsx">
import type { ReactElement } from 'react'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'
import Track from '@/components/common/Track'
import type { CopyDeeplinkLabels } from '@/services/analytics'
import { TX_LIST_EVENTS } from '@/services/analytics'
import React from 'react'
import CopyTooltip from '@/components/common/CopyTooltip'
import useOrigin from '@/hooks/useOrigin'

const TxShareLink = ({
  id,
  children,
  eventLabel,
}: {
  id: string
  children: ReactElement
  eventLabel: CopyDeeplinkLabels
}): ReactElement => {
  const router = useRouter()
  const { safe = '' } = router.query
  const href = `${AppRoutes.transactions.tx}?safe=${safe}&id=${id}`
  const txUrl = useOrigin() + href

  return (
    <Track {...TX_LIST_EVENTS.COPY_DEEPLINK} label={eventLabel}>
      <CopyTooltip text={txUrl} initialToolTipText="Copy the transaction URL">
        {children}
      </CopyTooltip>
    </Track>
  )
}

export default TxShareLink
</file>

<file path="src/components/transactions/TxSigners/index.tsx">
import { useState, type ReactElement } from 'react'
import {
  Box,
  Link,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  type Palette,
  SvgIcon,
  Typography,
  type ListItemIconProps,
} from '@mui/material'
import type {
  AddressEx,
  DetailedExecutionInfo,
  TransactionDetails,
  TransactionSummary,
} from '@safe-global/safe-gateway-typescript-sdk'

import useWallet from '@/hooks/wallets/useWallet'
import useIsPending from '@/hooks/useIsPending'
import { isCancellationTxInfo, isExecutable, isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'
import EthHashInfo from '@/components/common/EthHashInfo'

import css from './styles.module.css'
import useSafeInfo from '@/hooks/useSafeInfo'
import CreatedIcon from '@/public/images/common/created.svg'
import DotIcon from '@/public/images/common/dot.svg'
import CircleIcon from '@/public/images/common/circle.svg'
import CheckIcon from '@/public/images/common/circle-check.svg'
import CancelIcon from '@/public/images/common/cancel.svg'
import useTransactionStatus from '@/hooks/useTransactionStatus'

// Icons
const Created = () => (
  <SvgIcon
    component={CreatedIcon}
    inheritViewBox
    className={css.icon}
    sx={{
      '& path:last-of-type': { fill: ({ palette }) => palette.background.paper },
    }}
  />
)
const MissingConfirmation = () => <SvgIcon component={CircleIcon} inheritViewBox className={css.icon} />
const Check = () => (
  <SvgIcon
    component={CheckIcon}
    inheritViewBox
    className={css.icon}
    sx={{
      '& path:last-of-type': { fill: ({ palette }) => palette.background.paper },
    }}
  />
)
const Cancel = () => <SvgIcon component={CancelIcon} inheritViewBox className={css.icon} />
const Dot = () => <SvgIcon component={DotIcon} inheritViewBox className={css.dot} />

enum StepState {
  CONFIRMED = 'CONFIRMED',
  ACTIVE = 'ACTIVE',
  DISABLED = 'DISABLED',
  ERROR = 'ERROR',
}

const getStepColor = (state: StepState, palette: Palette): string => {
  const colors: { [_key in StepState]: string } = {
    [StepState.CONFIRMED]: palette.primary.main,
    [StepState.ACTIVE]: palette.warning.dark,
    [StepState.DISABLED]: palette.border.main,
    [StepState.ERROR]: palette.error.main,
  }
  return colors[state]
}

const StyledListItemIcon = ({
  $state,
  ...rest
}: {
  $state: StepState
} & ListItemIconProps) => (
  <ListItemIcon
    sx={({ palette }) => ({
      '.MuiSvgIcon-root': {
        color: getStepColor($state, palette),
        alignItems: 'center',
      },
    })}
    {...rest}
  />
)

const shouldHideConfirmations = (detailedExecutionInfo?: DetailedExecutionInfo): boolean => {
  if (!detailedExecutionInfo || !isMultisigDetailedExecutionInfo(detailedExecutionInfo)) {
    return true
  }

  const confirmationsNeeded = detailedExecutionInfo.confirmationsRequired - detailedExecutionInfo.confirmations.length
  const isConfirmed = confirmationsNeeded <= 0

  // Threshold reached or more than 3 confirmations
  return isConfirmed || detailedExecutionInfo.confirmations.length > 3
}

type TxSignersProps = {
  txDetails: TransactionDetails
  txSummary: TransactionSummary
  isTxFromProposer: boolean
  proposer?: AddressEx
}

export const TxSigners = ({
  txDetails,
  txSummary,
  isTxFromProposer,
  proposer,
}: TxSignersProps): ReactElement | null => {
  const { detailedExecutionInfo, txInfo, txId } = txDetails
  const [hideConfirmations, setHideConfirmations] = useState<boolean>(shouldHideConfirmations(detailedExecutionInfo))
  const isPending = useIsPending(txId)
  const txStatus = useTransactionStatus(txSummary)
  const wallet = useWallet()
  const { safe } = useSafeInfo()

  const toggleHide = () => {
    setHideConfirmations((prev) => !prev)
  }

  if (!detailedExecutionInfo || !isMultisigDetailedExecutionInfo(detailedExecutionInfo)) {
    return null
  }

  const { confirmations, confirmationsRequired, executor } = detailedExecutionInfo

  // TODO: Refactor to use `isConfirmableBy`
  const confirmationsCount = confirmations.length
  const canExecute = wallet?.address ? isExecutable(txSummary, wallet.address, safe) : false
  const confirmationsNeeded = confirmationsRequired - confirmations.length
  const isConfirmed = confirmationsNeeded <= 0 || canExecute

  return (
    <Box mb={2}>
      <List data-testid="transaction-actions-list" className={css.signers}>
        <ListItem>
          {isCancellationTxInfo(txInfo) ? (
            <>
              <StyledListItemIcon $state={StepState.ERROR}>
                <Cancel />
              </StyledListItemIcon>
              <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>On-chain rejection created</ListItemText>
            </>
          ) : (
            <>
              <StyledListItemIcon $state={StepState.CONFIRMED}>
                <Created />
              </StyledListItemIcon>
              <ListItemText data-testid="create-action" primaryTypographyProps={{ fontWeight: 700 }}>
                Created
              </ListItemText>
            </>
          )}
        </ListItem>

        {proposer && (
          <ListItem key={proposer.value} sx={{ py: 0 }}>
            <StyledListItemIcon $state={StepState.CONFIRMED}>
              <Dot />
            </StyledListItemIcon>
            <ListItemText data-testid="signer">
              <EthHashInfo address={proposer.value} hasExplorer showCopyButton />
            </ListItemText>
          </ListItem>
        )}

        {confirmations.length > 0 && (
          <ListItem>
            <StyledListItemIcon $state={isConfirmed ? StepState.CONFIRMED : StepState.ACTIVE}>
              {isConfirmed ? <Check /> : <MissingConfirmation />}
            </StyledListItemIcon>
            <ListItemText data-testid="confirmation-action" primaryTypographyProps={{ fontWeight: 700 }}>
              Confirmations{' '}
              <Box className={css.confirmationsTotal}>({`${confirmationsCount} of ${confirmationsRequired}`})</Box>
            </ListItemText>
          </ListItem>
        )}

        {!hideConfirmations &&
          confirmations.map(({ signer }) => (
            <ListItem key={signer.value} sx={{ py: 0 }}>
              <StyledListItemIcon $state={StepState.CONFIRMED}>
                <Dot />
              </StyledListItemIcon>
              <ListItemText data-testid="signer">
                <EthHashInfo address={signer.value} name={signer.name} hasExplorer showCopyButton />
              </ListItemText>
            </ListItem>
          ))}
        {confirmations.length > 0 && (
          <ListItem>
            <StyledListItemIcon $state={StepState.CONFIRMED}>
              <Dot />
            </StyledListItemIcon>
            <ListItemText>
              <Link
                data-testid="confirmation-visibility-btn"
                component="button"
                onClick={toggleHide}
                sx={{
                  fontSize: 'medium',
                }}
              >
                {hideConfirmations ? 'Show all' : 'Hide all'}
              </Link>
            </ListItemText>
          </ListItem>
        )}
        <ListItem sx={{ alignItems: 'flex-start' }}>
          <StyledListItemIcon $state={executor ? StepState.CONFIRMED : StepState.DISABLED}>
            {executor ? <Check /> : <MissingConfirmation />}
          </StyledListItemIcon>
          <ListItemText
            primary={
              executor ? 'Executed' : isPending ? txStatus : isTxFromProposer ? 'Signer review' : 'Can be executed'
            }
            secondary={
              isTxFromProposer
                ? 'This transaction was created by a Proposer. Please review and either confirm or reject it. Once confirmed, it can be finalized and executed.'
                : undefined
            }
            data-testid="tx-action-status"
            primaryTypographyProps={{ fontWeight: 700 }}
            secondaryTypographyProps={{ mt: 1 }}
          />
        </ListItem>
      </List>
      {executor ? (
        <Box data-testid="executor" className={css.listFooter}>
          <EthHashInfo
            address={executor.value}
            name={executor.name}
            customAvatar={executor.logoUri}
            hasExplorer
            showCopyButton
          />
        </Box>
      ) : (
        !isConfirmed && (
          <Box className={css.listFooter}>
            <Typography sx={({ palette }) => ({ color: palette.border.main })}>
              Can be executed once the threshold is reached
            </Typography>
          </Box>
        )
      )}
    </Box>
  )
}

export default TxSigners
</file>

<file path="src/components/transactions/TxSigners/styles.module.css">
.icon {
  height: 16px;
  width: 16px;
}

.dot {
  height: 10px;
  width: 10px;
}

.signers {
  padding: 0;
}

.signers::before {
  content: '';
  position: absolute;
  border-left: 2px solid var(--color-border-light);
  left: 15px;
  top: 20px;
  height: calc(100% - 40px);
}

.signers :global .MuiListItem-root:first-of-type {
  padding-top: 0;
}

.signers :global .MuiListItem-root {
  padding-left: 0;
  padding-right: 0;
}

.signers :global .MuiListItemIcon-root {
  color: var(--color-primary-main);
  justify-content: center;
  min-width: 32px;
  padding: var(--space-1) 0;
  background-color: var(--color-background-paper);
}

.confirmationsTotal {
  color: var(--color-border-main);
  display: inline;
  font-weight: normal;
}

.listFooter {
  margin-left: var(--space-4);
}
</file>

<file path="src/components/transactions/TxStatusChip/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import StatusChip from './index'
import { Paper } from '@mui/material'

const meta = {
  component: StatusChip,
  parameters: {
    componentSubtitle: 'Renders a token Amount with Token Symbol and Logo',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof StatusChip>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    children: 'Processing',
  },
}
</file>

<file path="src/components/transactions/TxStatusChip/index.tsx">
import type { ReactElement, ReactNode } from 'react'
import { Typography, Chip } from '@mui/material'

export type TxStatusChipProps = {
  children: ReactNode
  color?: 'primary' | 'secondary' | 'info' | 'warning' | 'success' | 'error'
}

const TxStatusChip = ({ children, color }: TxStatusChipProps): ReactElement => {
  return (
    <Chip
      size="small"
      sx={{
        backgroundColor: `${color}.background`,
        color: `${color}.${color === 'success' ? 'dark' : color === 'primary' ? 'light' : 'main'}`,
      }}
      label={
        <Typography
          variant="caption"
          fontWeight="bold"
          display="flex"
          alignItems="center"
          justifyContent="center"
          gap={0.7}
        >
          {children}
        </Typography>
      }
    />
  )
}

export default TxStatusChip
</file>

<file path="src/components/transactions/TxStatusLabel/index.tsx">
import { isCancelledSwapOrder } from '@/utils/transaction-guards'
import { CircularProgress, type Palette, Typography } from '@mui/material'
import { TransactionStatus, type TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import useIsPending from '@/hooks/useIsPending'
import useTransactionStatus from '@/hooks/useTransactionStatus'

const getStatusColor = (tx: TransactionSummary, palette: Palette) => {
  if (isCancelledSwapOrder(tx.txInfo)) {
    return palette.error.main
  }

  switch (tx.txStatus) {
    case TransactionStatus.SUCCESS:
      return palette.success.main
    case TransactionStatus.FAILED:
    case TransactionStatus.CANCELLED:
      return palette.error.main
    case TransactionStatus.AWAITING_CONFIRMATIONS:
    case TransactionStatus.AWAITING_EXECUTION:
      return palette.warning.main
    default:
      return palette.primary.main
  }
}

const TxStatusLabel = ({ tx }: { tx: TransactionSummary }) => {
  const txStatusLabel = useTransactionStatus(tx)
  const isPending = useIsPending(tx.id)

  return (
    <Typography
      variant="caption"
      fontWeight="bold"
      display="flex"
      alignItems="center"
      gap={1}
      sx={{ color: ({ palette }) => getStatusColor(tx, palette) }}
      data-testid="tx-status-label"
    >
      {isPending && <CircularProgress size={14} color="inherit" />}
      {txStatusLabel}
    </Typography>
  )
}

export default TxStatusLabel
</file>

<file path="src/components/transactions/TxSummary/index.tsx">
import TxProposalChip from '@/features/proposers/components/TxProposalChip'
import StatusLabel from '@/features/swap/components/StatusLabel'
import useIsExpiredSwap from '@/features/swap/hooks/useIsExpiredSwap'
import { Box } from '@mui/material'
import type { ReactElement } from 'react'
import { type Transaction } from '@safe-global/safe-gateway-typescript-sdk'

import css from './styles.module.css'
import DateTime from '@/components/common/DateTime'
import TxInfo from '@/components/transactions/TxInfo'
import { isMultisigExecutionInfo, isTxQueued } from '@/utils/transaction-guards'
import TxType from '@/components/transactions/TxType'
import classNames from 'classnames'
import { isImitation, isTrustedTx } from '@/utils/transactions'
import MaliciousTxWarning from '../MaliciousTxWarning'
import QueueActions from './QueueActions'
import useIsPending from '@/hooks/useIsPending'
import TxConfirmations from '../TxConfirmations'
import { useHasFeature } from '@/hooks/useChains'
import TxStatusLabel from '@/components/transactions/TxStatusLabel'
import { FEATURES } from '@safe-global/utils/utils/chains'

type TxSummaryProps = {
  isConflictGroup?: boolean
  isBulkGroup?: boolean
  item: Transaction
}

const TxSummary = ({ item, isConflictGroup, isBulkGroup }: TxSummaryProps): ReactElement => {
  const hasDefaultTokenlist = useHasFeature(FEATURES.DEFAULT_TOKENLIST)

  const tx = item.transaction
  const isQueue = isTxQueued(tx.txStatus)
  const nonce = isMultisigExecutionInfo(tx.executionInfo) ? tx.executionInfo.nonce : undefined
  const isTrusted = !hasDefaultTokenlist || isTrustedTx(tx)
  const isImitationTransaction = isImitation(tx)
  const isPending = useIsPending(tx.id)
  const executionInfo = isMultisigExecutionInfo(tx.executionInfo) ? tx.executionInfo : undefined
  const expiredSwap = useIsExpiredSwap(tx.txInfo)

  return (
    <Box
      data-testid="transaction-item"
      className={classNames(css.gridContainer, {
        [css.history]: !isQueue,
        [css.conflictGroup]: isConflictGroup,
        [css.bulkGroup]: isBulkGroup,
        [css.untrusted]: !isTrusted || isImitationTransaction,
      })}
      id={tx.id}
    >
      {nonce !== undefined && !isConflictGroup && !isBulkGroup && (
        <Box data-testid="nonce" className={css.nonce} gridArea="nonce">
          {nonce}
        </Box>
      )}

      {(isImitationTransaction || !isTrusted) && (
        <Box data-testid="warning" gridArea="nonce">
          <MaliciousTxWarning withTooltip={!isImitationTransaction} />
        </Box>
      )}

      <Box data-testid="tx-type" gridArea="type">
        <TxType tx={tx} />
      </Box>

      <Box data-testid="tx-info" gridArea="info">
        <TxInfo info={tx.txInfo} />
      </Box>

      <Box data-testid="tx-date" className={css.date} gridArea="date">
        <DateTime value={tx.timestamp} />
      </Box>

      {isQueue && executionInfo && (
        <Box gridArea="confirmations">
          {executionInfo.confirmationsSubmitted > 0 || isPending ? (
            <TxConfirmations
              submittedConfirmations={executionInfo.confirmationsSubmitted}
              requiredConfirmations={executionInfo.confirmationsRequired}
            />
          ) : (
            <TxProposalChip />
          )}
        </Box>
      )}

      {(!isQueue || expiredSwap || isPending) && (
        <Box className={css.status} gridArea="status">
          {isQueue && expiredSwap ? <StatusLabel status="expired" /> : <TxStatusLabel tx={tx} />}
        </Box>
      )}

      {isQueue && !expiredSwap && (
        <Box gridArea="actions">
          <QueueActions tx={tx} />
        </Box>
      )}
    </Box>
  )
}

export default TxSummary
</file>

<file path="src/components/transactions/TxSummary/QueueActions.tsx">
import { Box } from '@mui/material'
import { type TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { isAwaitingExecution } from '@/utils/transaction-guards'
import ExecuteTxButton from '../ExecuteTxButton'
import SignTxButton from '../SignTxButton'
import { useAppSelector } from '@/store'
import { PendingStatus, selectPendingTxById } from '@/store/pendingTxsSlice'
import { SpeedUpMonitor } from '@/features/speedup/components/SpeedUpMonitor'

const QueueActions = ({ tx }: { tx: TransactionSummary }) => {
  const awaitingExecution = isAwaitingExecution(tx.txStatus)
  const pendingTx = useAppSelector((state) => selectPendingTxById(state, tx.id))

  let ExecutionComponent = null
  if (!pendingTx) {
    ExecutionComponent = <SignTxButton txSummary={tx} compact />
    if (awaitingExecution) {
      ExecutionComponent = <ExecuteTxButton txSummary={tx} compact />
    }
  }

  return (
    <Box data-testid="tx-actions" mr={2} display="flex" justifyContent="center">
      {ExecutionComponent}
      {pendingTx && pendingTx.status === PendingStatus.PROCESSING && (
        <SpeedUpMonitor txId={tx.id} pendingTx={pendingTx} modalTrigger="alertButton" />
      )}
    </Box>
  )
}

export default QueueActions
</file>

<file path="src/components/transactions/TxSummary/styles.module.css">
.gridContainer {
  --grid-nonce: minmax(45px, 0.25fr);
  --grid-type: minmax(150px, 3fr);
  --grid-info: minmax(190px, 3fr);
  --grid-date: minmax(200px, 3fr);
  --grid-confirmations: minmax(120px, 1fr);

  --grid-status: minmax(120px, 1fr);
  --grid-actions: minmax(100px, 1fr);

  width: 100%;
  display: grid;
  gap: var(--space-2);
  align-items: center;
  white-space: nowrap;
  grid-template-columns:
    var(--grid-nonce) var(--grid-type) var(--grid-info) var(--grid-date) var(--grid-confirmations)
    var(--grid-status) var(--grid-actions);
  grid-template-areas: 'nonce type info date confirmations status actions';
}

.gridContainer > * {
  max-width: 100%;
}

.gridContainer.history {
  grid-template-columns: var(--grid-nonce) var(--grid-type) var(--grid-info) var(--grid-date) var(--grid-status);
  grid-template-areas: 'nonce type info date status';
}

.gridContainer.conflictGroup {
  grid-template-columns:
    var(--grid-type) var(--grid-info) var(--grid-date) var(--grid-confirmations) var(--grid-status)
    var(--grid-actions);
  grid-template-areas: 'type info date confirmations status actions';
}

.gridContainer.bulkGroup {
  grid-template-columns: var(--grid-type) var(--grid-info) var(--grid-date) var(--grid-status);
  grid-template-areas: 'type info date status';
}

.gridContainer.bulkGroup.untrusted {
  grid-template-columns: var(--grid-nonce) minmax(200px, 2.4fr) var(--grid-info) var(--grid-date) var(--grid-status);
  grid-template-areas: 'nonce type info date status';
}

.gridContainer.message {
  grid-template-columns: var(--grid-type) var(--grid-info) var(--grid-date) var(--grid-status) var(--grid-confirmations);
  grid-template-areas: 'type info date status confirmations';
}

.gridContainer.untrusted :not(:first-child):is(div) {
  opacity: 0.4;
}

.gridContainer .status {
  margin-right: var(--space-3);
  display: flex;
  justify-content: flex-end;
}

.date {
  color: var(--color-text-secondary);
}

@media (max-width: 1350px) {
  .gridContainer {
    gap: var(--space-1);
    display: flex;
    flex-wrap: wrap;
  }

  .nonce {
    min-width: 30px;
  }

  .date {
    width: 100%;
  }

  .status {
    margin: 0 var(--space-1);
  }
}
</file>

<file path="src/components/transactions/TxType/index.tsx">
import { useTransactionType } from '@/hooks/useTransactionType'
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { Box } from '@mui/material'
import css from './styles.module.css'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import { isValidElement } from 'react'

type TxTypeProps = {
  tx: TransactionSummary
}

const TxType = ({ tx }: TxTypeProps) => {
  const type = useTransactionType(tx)

  return (
    <Box className={css.txType}>
      {isValidElement(type.icon) ? (
        type.icon
      ) : typeof type.icon == 'string' ? (
        <SafeAppIconCard
          src={type.icon}
          alt={type.text}
          width={16}
          height={16}
          fallback="/images/transactions/custom.svg"
        />
      ) : null}

      <span className={css.txTypeText}>{type.text}</span>
    </Box>
  )
}

export default TxType
</file>

<file path="src/components/transactions/TxType/styles.module.css">
.txType {
  display: flex;
  align-items: center;
  flex-wrap: nowrap;
  gap: var(--space-1);
  color: var(--color-text-primary);
  overflow: hidden;
}

.txTypeText {
  overflow: hidden;
  text-overflow: ellipsis;
  text-wrap: nowrap;
}
</file>

<file path="src/components/transactions/Warning/index.tsx">
import type { ReactElement } from 'react'
import { Alert, SvgIcon, Tooltip } from '@mui/material'
import type { AlertColor } from '@mui/material'

import InfoOutlinedIcon from '@/public/images/notifications/info.svg'
import css from './styles.module.css'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { useIsOfficialFallbackHandler } from '@/hooks/useIsOfficialFallbackHandler'
import { useIsTWAPFallbackHandler } from '@/features/swap/hooks/useIsTWAPFallbackHandler'
import { UntrustedFallbackHandlerTxText } from '@/components/tx/confirmation-views/SettingsChange/UntrustedFallbackHandlerTxAlert'

const Warning = ({
  datatestid,
  title,
  text,
  severity,
}: {
  datatestid?: String
  title: string | ReactElement
  text: string
  severity: AlertColor
}): ReactElement => {
  return (
    <Tooltip data-testid={datatestid} title={title} placement="top-start" arrow>
      <Alert
        className={css.alert}
        sx={{ borderLeft: ({ palette }) => `3px solid ${palette[severity].main} !important`, alignItems: 'center' }}
        severity={severity}
        icon={<SvgIcon component={InfoOutlinedIcon} inheritViewBox color={severity} />}
      >
        <b>{text}</b>
      </Alert>
    </Tooltip>
  )
}

export const DelegateCallWarning = ({ showWarning }: { showWarning: boolean }): ReactElement => {
  const severity = showWarning ? 'warning' : 'success'
  return (
    <Warning
      datatestid="delegate-call-warning"
      title={
        <>
          This transaction calls a smart contract that will be able to modify your Safe Account.
          {showWarning && (
            <>
              <br />
              <ExternalLink href={HelpCenterArticle.UNEXPECTED_DELEGATE_CALL}>Learn more</ExternalLink>
            </>
          )}
        </>
      }
      severity={severity}
      text={showWarning ? 'Unexpected delegate call' : 'Delegate call'}
    />
  )
}

export const UntrustedFallbackHandlerWarning = ({
  fallbackHandler,
  isTxExecuted = false,
}: {
  fallbackHandler: string
  isTxExecuted?: boolean
}): ReactElement | null => {
  const isOfficial = useIsOfficialFallbackHandler(fallbackHandler)
  const isTWAPFallbackHandler = useIsTWAPFallbackHandler(fallbackHandler)

  if (isOfficial || isTWAPFallbackHandler) {
    return null
  }

  return (
    <Warning
      datatestid="untrusted-fallback-handler-warning"
      title={<UntrustedFallbackHandlerTxText isTxExecuted={isTxExecuted} />}
      severity="warning"
      text="Untrusted fallback handler"
    />
  )
}

export const ApprovalWarning = ({ approvalTxCount }: { approvalTxCount: number }): ReactElement => (
  <Warning title="" severity="warning" text={`${approvalTxCount} ERC20 approval${maybePlural(approvalTxCount)}`} />
)

export const ThresholdWarning = (): ReactElement => (
  <Warning
    datatestid="threshold-warning"
    title="This transaction potentially alters the number of confirmations required to execute a transaction. Please verify before signing."
    severity="warning"
    text="Confirmation policy change"
  />
)

export const UnsignedWarning = (): ReactElement => (
  <Warning
    title="This transaction is unsigned and could have been created by anyone. To avoid phishing, only sign it if you trust the source of the link."
    severity="error"
    text="Untrusted transaction"
  />
)
</file>

<file path="src/components/transactions/Warning/styles.module.css">
.alert {
  width: fit-content;
  padding: 0px 10px;
  margin-bottom: 10px;
}
</file>

<file path="src/components/tx/AdvancedParams/AdvancedParamsForm.tsx">
import { type SyntheticEvent } from 'react'
import { Button, DialogActions, FormControl, Grid, Typography, DialogContent } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import { safeFormatUnits, safeParseUnits } from '@safe-global/utils/utils/formatters'
import { FLOAT_REGEX } from '@safe-global/utils/utils/validation'
import ModalDialog from '@/components/common/ModalDialog'
import { AdvancedField, type AdvancedParameters } from './types'
import GasLimitInput from './GasLimitInput'
import ExternalLink from '@/components/common/ExternalLink'
import NumberField from '@/components/common/NumberField'
import { HelpCenterArticle } from '@/config/constants'

type AdvancedParamsFormProps = {
  params: AdvancedParameters
  onSubmit: (params: AdvancedParameters) => void
  recommendedGasLimit?: AdvancedParameters['gasLimit']
  isExecution: boolean
  isEIP1559?: boolean
  willRelay?: boolean
}

type FormData = {
  [AdvancedField.userNonce]: number
  [AdvancedField.gasLimit]?: string
  [AdvancedField.maxFeePerGas]: string
  [AdvancedField.maxPriorityFeePerGas]: string
}

const AdvancedParamsForm = ({ params, ...props }: AdvancedParamsFormProps) => {
  const formMethods = useForm<FormData>({
    mode: 'onChange',
    defaultValues: {
      userNonce: params.userNonce ?? 0,
      gasLimit: params.gasLimit?.toString() || undefined,
      maxFeePerGas: params.maxFeePerGas ? safeFormatUnits(params.maxFeePerGas) : '',
      maxPriorityFeePerGas: params.maxPriorityFeePerGas ? safeFormatUnits(params.maxPriorityFeePerGas) : '',
    },
  })
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = formMethods

  const onBack = () => {
    props.onSubmit({
      userNonce: params.userNonce,
      gasLimit: params.gasLimit,
      maxFeePerGas: params.maxFeePerGas,
      maxPriorityFeePerGas: params.maxPriorityFeePerGas,
    })
  }

  const onSubmit = (data: FormData) => {
    props.onSubmit({
      userNonce: data.userNonce,
      gasLimit: data.gasLimit ? BigInt(data.gasLimit) : undefined,
      maxFeePerGas: safeParseUnits(data.maxFeePerGas) ?? params.maxFeePerGas,
      maxPriorityFeePerGas: safeParseUnits(data.maxPriorityFeePerGas) ?? params.maxPriorityFeePerGas,
    })
  }

  const onFormSubmit = (e: SyntheticEvent) => {
    e.preventDefault()
    e.stopPropagation()
    handleSubmit(onSubmit)()
  }

  return (
    <ModalDialog open dialogTitle="Advanced parameters" hideChainIndicator>
      <FormProvider {...formMethods}>
        <form onSubmit={onFormSubmit}>
          <DialogContent>
            <Grid container spacing={2}>
              <Grid item xs={12}>
                <Typography variant="body1" fontWeight={700}>
                  Execution parameters
                </Typography>
              </Grid>

              {/* User nonce */}
              <Grid item xs={6}>
                <FormControl fullWidth>
                  <NumberField
                    disabled={props.willRelay}
                    label={errors.userNonce?.message || 'Wallet nonce'}
                    error={!!errors.userNonce}
                    {...register(AdvancedField.userNonce)}
                  />
                </FormControl>
              </Grid>

              {/* Gas limit */}
              <Grid item xs={6}>
                <GasLimitInput recommendedGasLimit={props.recommendedGasLimit?.toString()} />
              </Grid>

              {/* Gas price */}
              {props.isEIP1559 && (
                <Grid item xs={6}>
                  <FormControl fullWidth>
                    <NumberField
                      disabled={props.willRelay}
                      label={errors.maxPriorityFeePerGas?.message || 'Max priority fee (Gwei)'}
                      error={!!errors.maxPriorityFeePerGas}
                      required
                      {...register(AdvancedField.maxPriorityFeePerGas, {
                        required: true,
                        pattern: FLOAT_REGEX,
                        min: 0,
                      })}
                    />
                  </FormControl>
                </Grid>
              )}

              <Grid item xs={6}>
                <FormControl fullWidth>
                  <NumberField
                    disabled={props.willRelay}
                    label={errors.maxFeePerGas?.message || props.isEIP1559 ? 'Max fee (Gwei)' : 'Gas price (Gwei)'}
                    error={!!errors.maxFeePerGas}
                    required
                    {...register(AdvancedField.maxFeePerGas, { required: true, pattern: FLOAT_REGEX, min: 0 })}
                  />
                </FormControl>
              </Grid>
            </Grid>

            {/* Help link */}
            <Typography mt={2}>
              <ExternalLink href={HelpCenterArticle.ADVANCED_PARAMS}>
                How can I configure these parameters manually?
              </ExternalLink>
            </Typography>
          </DialogContent>

          {/* Buttons */}
          <DialogActions>
            <Button color="inherit" onClick={onBack}>
              Back
            </Button>

            <Button variant="contained" type="submit">
              Confirm
            </Button>
          </DialogActions>
        </form>
      </FormProvider>
    </ModalDialog>
  )
}

export default AdvancedParamsForm
</file>

<file path="src/components/tx/AdvancedParams/GasLimitInput.tsx">
import useSafeInfo from '@/hooks/useSafeInfo'
import { FormControl, IconButton, Tooltip } from '@mui/material'
import RotateLeftIcon from '@mui/icons-material/RotateLeft'
import { useFormContext } from 'react-hook-form'
import { BASE_TX_GAS } from '@/config/constants'
import { AdvancedField } from './types'
import NumberField from '@/components/common/NumberField'

const GasLimitInput = ({ recommendedGasLimit }: { recommendedGasLimit?: string }) => {
  const { safe } = useSafeInfo()

  const {
    register,
    watch,
    setValue,
    trigger,
    formState: { errors },
  } = useFormContext()

  const currentGasLimit = watch(AdvancedField.gasLimit)

  const onResetGasLimit = () => {
    setValue(AdvancedField.gasLimit, recommendedGasLimit)
    trigger(AdvancedField.gasLimit)
  }

  const error = errors.gasLimit as
    | {
        message: string
        type: string
      }
    | undefined

  const errorMessage = error ? (error.type === 'min' ? 'Gas limit must be at least 21000' : error.message) : undefined

  return (
    <FormControl fullWidth>
      <NumberField
        label={errorMessage || 'Gas limit'}
        error={!!errorMessage}
        InputProps={{
          endAdornment: recommendedGasLimit && recommendedGasLimit !== currentGasLimit.toString() && (
            <Tooltip title="Reset to recommended gas limit">
              <IconButton onClick={onResetGasLimit} size="small" color="primary">
                <RotateLeftIcon />
              </IconButton>
            </Tooltip>
          ),
        }}
        // @see https://github.com/react-hook-form/react-hook-form/issues/220
        InputLabelProps={{
          shrink: currentGasLimit !== undefined,
        }}
        disabled={!safe.deployed}
        required
        {...register(AdvancedField.gasLimit, { required: true, min: BASE_TX_GAS })}
      />
    </FormControl>
  )
}

export default GasLimitInput
</file>

<file path="src/components/tx/AdvancedParams/index.tsx">
import GasParams from '@/components/tx/GasParams'
import { useHasFeature } from '@/hooks/useChains'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import { useState } from 'react'
import AdvancedParamsForm from './AdvancedParamsForm'
import { type AdvancedParameters } from './types'
import { FEATURES } from '@safe-global/utils/utils/chains'

type Props = {
  params: AdvancedParameters
  recommendedGasLimit?: AdvancedParameters['gasLimit']
  willExecute: boolean
  onFormSubmit: (data: AdvancedParameters) => void
  gasLimitError?: Error
  willRelay?: boolean
}

const AdvancedParams = ({
  params,
  recommendedGasLimit,
  willExecute,
  onFormSubmit,
  gasLimitError,
  willRelay,
}: Props) => {
  const [isEditing, setIsEditing] = useState<boolean>(false)
  const isEIP1559 = useHasFeature(FEATURES.EIP1559)

  const onEditOpen = () => {
    setIsEditing(true)
    trackEvent(MODALS_EVENTS.EDIT_ADVANCED_PARAMS)
  }

  const onAdvancedSubmit = (data: AdvancedParameters) => {
    onFormSubmit(data)
    setIsEditing(false)
  }

  return isEditing ? (
    <AdvancedParamsForm
      params={params}
      isExecution={willExecute}
      recommendedGasLimit={recommendedGasLimit}
      onSubmit={onAdvancedSubmit}
      isEIP1559={isEIP1559}
      willRelay={willRelay}
    />
  ) : (
    <GasParams
      params={params}
      isExecution={willExecute}
      isEIP1559={isEIP1559}
      gasLimitError={gasLimitError}
      onEdit={onEditOpen}
      willRelay={willRelay}
    />
  )
}

export default AdvancedParams

export * from './useAdvancedParams'

export * from './types'
</file>

<file path="src/components/tx/AdvancedParams/types.ts">
// import type {BigNumberish, BigNumber}    from 'ethers'
// import { type BigNumber } from '@ethersproject/bignumber'

export enum AdvancedField {
  nonce = 'nonce',
  userNonce = 'userNonce',
  gasLimit = 'gasLimit',
  maxFeePerGas = 'maxFeePerGas',
  maxPriorityFeePerGas = 'maxPriorityFeePerGas',
  safeTxGas = 'safeTxGas',
}

export type AdvancedParameters = Partial<{
  [AdvancedField.nonce]: number
  [AdvancedField.userNonce]: number
  [AdvancedField.gasLimit]: bigint | null
  [AdvancedField.maxFeePerGas]: bigint | null
  [AdvancedField.maxPriorityFeePerGas]: bigint | null
  [AdvancedField.safeTxGas]: number
}>
</file>

<file path="src/components/tx/AdvancedParams/useAdvancedParams.ts">
import { useMemo, useState } from 'react'
import useGasPrice from '@/hooks/useGasPrice'
import { type AdvancedParameters } from './types'
import useUserNonce from './useUserNonce'

export const useAdvancedParams = (
  gasLimit?: AdvancedParameters['gasLimit'],
): [AdvancedParameters, (params: AdvancedParameters) => void] => {
  const [manualParams, setManualParams] = useState<AdvancedParameters>()
  const [gasPrice] = useGasPrice()
  const userNonce = useUserNonce()

  const advancedParams: AdvancedParameters = useMemo(
    () => ({
      userNonce: manualParams?.userNonce ?? userNonce,
      gasLimit: manualParams?.gasLimit ?? gasLimit,
      maxFeePerGas: manualParams?.maxFeePerGas ?? gasPrice?.maxFeePerGas,
      maxPriorityFeePerGas: manualParams?.maxPriorityFeePerGas ?? gasPrice?.maxPriorityFeePerGas,
    }),
    [manualParams, userNonce, gasLimit, gasPrice?.maxFeePerGas, gasPrice?.maxPriorityFeePerGas],
  )

  return [advancedParams, setManualParams]
}
</file>

<file path="src/components/tx/AdvancedParams/useUserNonce.ts">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useWallet from '@/hooks/wallets/useWallet'
import { getUserNonce } from '@/hooks/wallets/web3'

const useUserNonce = (): number | undefined => {
  const wallet = useWallet()

  const [userNonce] = useAsync<number>(() => {
    if (!wallet) return
    return getUserNonce(wallet.address)
  }, [wallet])

  return userNonce
}

export default useUserNonce
</file>

<file path="src/components/tx/ApprovalEditor/hooks/useApprovalInfos.ts">
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useBalances from '@/hooks/useBalances'
import { type Approval, ApprovalModule } from '@safe-global/utils/services/security/modules/ApprovalModule'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { getERC20TokenInfoOnChain, getErc721Symbol, isErc721Token } from '@/utils/tokens'
import { type SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import { useMemo } from 'react'
import { PSEUDO_APPROVAL_VALUES } from '../utils/approvals'
import { safeFormatUnits } from '@safe-global/utils/utils/formatters'
import { UNLIMITED_APPROVAL_AMOUNT, UNLIMITED_PERMIT2_AMOUNT } from '@safe-global/utils/utils/tokens'
import { type Balance } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

export type ApprovalInfo = {
  tokenInfo: (Omit<Balance['tokenInfo'], 'logoUri' | 'name'> & { logoUri?: string }) | undefined
  tokenAddress: string
  spender: any
  amount: any
  amountFormatted: string
  method: Approval['method']
  /** Index of approval transaction within (batch) transaction */
  transactionIndex: number
}

const DEFAULT_DECIMALS = 18

const ApprovalModuleInstance = new ApprovalModule()

export const useApprovalInfos = (payload: {
  safeTransaction?: SafeTransaction
  safeMessage?: TypedData
}): [ApprovalInfo[] | undefined, Error | undefined, boolean] => {
  const { safeTransaction, safeMessage } = payload
  const { balances } = useBalances()
  const approvals = useMemo(() => {
    if (safeTransaction) {
      return ApprovalModuleInstance.scanTransaction({ safeTransaction })
    }
    if (safeMessage) {
      return ApprovalModuleInstance.scanMessage({ safeMessage })
    }
  }, [safeMessage, safeTransaction])

  const hasApprovalSignatures = !!approvals && !!approvals.payload && approvals.payload.length > 0

  const [approvalInfos, error, loading] = useAsync<ApprovalInfo[] | undefined>(
    async () => {
      if (!hasApprovalSignatures) return

      return Promise.all(
        approvals.payload.map(async (approval) => {
          let tokenInfo: Omit<Balance['tokenInfo'], 'name' | 'logoUri'> | undefined = balances.items.find((item) =>
            sameAddress(item.tokenInfo.address, approval.tokenAddress),
          )?.tokenInfo

          if (!tokenInfo) {
            try {
              tokenInfo = await getERC20TokenInfoOnChain(approval.tokenAddress)
            } catch (e) {
              const isErc721 = await isErc721Token(approval.tokenAddress)
              const symbol = await getErc721Symbol(approval.tokenAddress)

              tokenInfo = {
                address: approval.tokenAddress,
                symbol,
                decimals: 1, // Doesn't exist for ERC-721 tokens
                type: isErc721 ? TokenType.ERC721 : TokenType.ERC20,
              }
            }
          }

          const amountFormatted =
            UNLIMITED_APPROVAL_AMOUNT == approval.amount || UNLIMITED_PERMIT2_AMOUNT == approval.amount
              ? PSEUDO_APPROVAL_VALUES.UNLIMITED
              : safeFormatUnits(approval.amount, tokenInfo?.decimals ?? DEFAULT_DECIMALS)

          return { ...approval, tokenInfo, amountFormatted }
        }),
      )
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [hasApprovalSignatures, balances.items.length],
    false, // Do not clear data on balance updates
  )

  return [hasApprovalSignatures ? approvalInfos : [], error, loading]
}
</file>

<file path="src/components/tx/ApprovalEditor/utils/approvals.ts">
import type { BaseTransaction } from '@safe-global/safe-apps-sdk'
import type { DecodedDataResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { parseUnits } from 'ethers'
import { EMPTY_DATA } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { type ApprovalInfo } from '../hooks/useApprovalInfos'
import { UNLIMITED_APPROVAL_AMOUNT } from '@safe-global/utils/utils/tokens'
import {
  APPROVAL_SIGNATURE_HASH,
  ERC20_INTERFACE,
  INCREASE_ALLOWANCE_SIGNATURE_HASH,
} from '@safe-global/utils/components/tx/ApprovalEditor/utils/approvals'

const MULTISEND_METHOD = 'multiSend'

const APPROVE_METHOD = 'approve'

const TRANSACTIONS_PARAM = 'transactions'

const ADDRESS_TYPE = 'address'
const UINT256_TYPE = 'uint256'

export enum PSEUDO_APPROVAL_VALUES {
  UNLIMITED = 'Unlimited amount',
}

const parseApprovalAmount = (amount: string, decimals: number) => {
  if (amount === PSEUDO_APPROVAL_VALUES.UNLIMITED) {
    return UNLIMITED_APPROVAL_AMOUNT
  }

  return parseUnits(amount, decimals)
}

export const extractTxs: (txs: BaseTransaction[] | (DecodedDataResponse & { to: string })) => BaseTransaction[] = (
  txs,
) => {
  if (Array.isArray(txs)) {
    return txs
  }

  const isMultiSendCall = txs.method === MULTISEND_METHOD && txs.parameters.length === 1

  // Our multisend contract takes 1 param called transactions
  if (isMultiSendCall) {
    const txParam = txs.parameters[0]
    if (txParam.name === TRANSACTIONS_PARAM) {
      return txParam.valueDecoded
        ? txParam.valueDecoded.map((innerTx) => ({
            to: innerTx.to,
            data: innerTx.data || EMPTY_DATA,
            value: innerTx.value,
          }))
        : []
    }
  }

  const isApproveCall = txs.method === APPROVE_METHOD && txs.parameters.length === 2

  if (isApproveCall) {
    const spenderParam = txs.parameters[0]
    const amountParam = txs.parameters[1]

    // We only check the types here instead of the names may vary in ERC20 implementations
    if (
      spenderParam.type == ADDRESS_TYPE &&
      typeof spenderParam.value === 'string' &&
      amountParam.type === UINT256_TYPE &&
      typeof amountParam.value === 'string'
    ) {
      return [
        {
          to: txs.to,
          value: '0x',
          data: ERC20_INTERFACE.encodeFunctionData(APPROVE_METHOD, [spenderParam.value, amountParam.value]),
        },
      ]
    }
  }
  return []
}

export const updateApprovalTxs = (
  approvalFormValues: string[],
  approvalInfos: ApprovalInfo[] | undefined,
  txs: BaseTransaction[],
) => {
  const updatedTxs = txs.map((tx, txIndex) => {
    const approvalIndex = approvalInfos?.findIndex((approval) => approval.transactionIndex === txIndex)
    if (approvalIndex === undefined) {
      return tx
    }
    if (tx.data.startsWith(APPROVAL_SIGNATURE_HASH) || tx.data.startsWith(INCREASE_ALLOWANCE_SIGNATURE_HASH)) {
      const newApproval = approvalFormValues[approvalIndex]
      const approvalInfo = approvalInfos?.[approvalIndex]
      if (!approvalInfo || !approvalInfo.tokenInfo) {
        // Without decimals and spender we cannot create a new tx
        return tx
      }
      const decimals = approvalInfo.tokenInfo.decimals
      const newAmountWei = parseApprovalAmount(newApproval, decimals ?? 0)
      if (tx.data.startsWith(APPROVAL_SIGNATURE_HASH)) {
        return {
          to: approvalInfo.tokenAddress,
          value: '0',
          data: ERC20_INTERFACE.encodeFunctionData('approve', [approvalInfo.spender, newAmountWei]),
        }
      } else {
        return {
          to: approvalInfo.tokenAddress,
          value: '0',
          data: ERC20_INTERFACE.encodeFunctionData('increaseAllowance', [approvalInfo.spender, newAmountWei]),
        }
      }
    }
    return tx
  })

  return updatedTxs
}
</file>

<file path="src/components/tx/ApprovalEditor/ApprovalEditorForm.tsx">
import { Box, Divider, List, ListItem, Stack } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import css from './styles.module.css'
import type { ApprovalInfo } from './hooks/useApprovalInfos'

import { useMemo } from 'react'
import EditableApprovalItem from './EditableApprovalItem'
import groupBy from 'lodash/groupBy'
import { SpenderField } from './SpenderField'

export type ApprovalEditorFormData = {
  approvals: string[]
}

export const ApprovalEditorForm = ({
  approvalInfos,
  updateApprovals,
}: {
  approvalInfos: ApprovalInfo[]
  updateApprovals: (newApprovals: string[]) => void
}) => {
  const groupedApprovals = useMemo(() => groupBy(approvalInfos, (approval) => approval.spender), [approvalInfos])

  const initialApprovals = useMemo(() => approvalInfos.map((info) => info.amountFormatted), [approvalInfos])

  const formMethods = useForm<ApprovalEditorFormData>({
    defaultValues: {
      approvals: initialApprovals,
    },
    mode: 'onChange',
  })

  const { getValues, reset } = formMethods

  const onSave = () => {
    const formData = getValues('approvals')
    updateApprovals(formData)
    reset({ approvals: formData })
  }

  let fieldIndex = 0

  return (
    <FormProvider {...formMethods}>
      <List className={css.approvalsList}>
        {Object.entries(groupedApprovals).map(([spender, approvals], spenderIdx) => (
          <Box key={spender}>
            <Stack
              sx={{
                gap: 2,
              }}
            >
              {approvals.map((tx) => (
                <ListItem
                  key={tx.tokenAddress + tx.spender}
                  className={0n === tx.amount ? css.zeroValueApproval : undefined}
                  disablePadding
                  data-testid="approval-item"
                >
                  <EditableApprovalItem approval={tx} name={`approvals.${fieldIndex++}`} onSave={onSave} />
                </ListItem>
              ))}
              <SpenderField address={spender} />

              {spenderIdx !== Object.keys(groupedApprovals).length - 1 && <Divider />}
            </Stack>
          </Box>
        ))}
      </List>
    </FormProvider>
  )
}
</file>

<file path="src/components/tx/ApprovalEditor/ApprovalItem.tsx">
import TokenIcon from '@/components/common/TokenIcon'
import css from '@/components/tx/ApprovalEditor/styles.module.css'
import type { Approval } from '@safe-global/utils/services/security/modules/ApprovalModule'
import { Box, Stack, Typography } from '@mui/material'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk/dist/types/common'
import type { ApprovalInfo } from './hooks/useApprovalInfos'
import { PSEUDO_APPROVAL_VALUES } from './utils/approvals'
import { formatAmountPrecise } from '@safe-global/utils/utils/formatNumber'
import { type Balance } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

export const approvalMethodDescription: Record<
  Approval['method'],
  (symbol: string, type?: Balance['tokenInfo']['type']) => string
> = {
  approve: (symbol: string, type?: Balance['tokenInfo']['type']) =>
    type === TokenType.ERC721 ? `Allow to transfer ${symbol}` : `Set ${symbol} allowance to`,
  increaseAllowance: (symbol: string) => `Increase ${symbol} allowance by`,
  Permit2: (symbol: string) => `Give permission to spend ${symbol}`,
}

const ApprovalItem = ({
  method,
  amount,
  rawAmount,
  tokenInfo,
}: {
  spender: string
  amount: string
  rawAmount: any
  tokenInfo: NonNullable<ApprovalInfo['tokenInfo']>
  method: Approval['method']
}) => {
  return (
    <Stack
      direction="row"
      className={css.approvalField}
      sx={{
        alignItems: 'center',
        gap: 2,
      }}
    >
      <TokenIcon size={32} logoUri={tokenInfo?.logoUri} tokenSymbol={tokenInfo?.symbol} />
      <Box sx={{ overflowX: 'auto' }}>
        <Typography
          variant="body2"
          sx={{
            color: 'text.secondary',
          }}
        >
          {approvalMethodDescription[method](tokenInfo.symbol ?? '', tokenInfo.type)}
        </Typography>
        {amount === PSEUDO_APPROVAL_VALUES.UNLIMITED ? (
          <Typography>{PSEUDO_APPROVAL_VALUES.UNLIMITED}</Typography>
        ) : (
          <Typography data-testid="token-amount">
            {tokenInfo.type === TokenType.ERC20
              ? formatAmountPrecise(amount, tokenInfo.decimals ?? 0)
              : `#${rawAmount.toString()}`}
          </Typography>
        )}
      </Box>
    </Stack>
  )
}

export default ApprovalItem
</file>

<file path="src/components/tx/ApprovalEditor/Approvals.tsx">
import { List, ListItem, Stack } from '@mui/material'

import { type ApprovalInfo } from '@/components/tx/ApprovalEditor/hooks/useApprovalInfos'
import css from './styles.module.css'
import ApprovalItem from '@/components/tx/ApprovalEditor/ApprovalItem'
import groupBy from 'lodash/groupBy'
import { useMemo } from 'react'
import { SpenderField } from './SpenderField'

const Approvals = ({ approvalInfos }: { approvalInfos: ApprovalInfo[] }) => {
  const groupedApprovals = useMemo(() => groupBy(approvalInfos, (approval) => approval.spender), [approvalInfos])

  return (
    <List className={css.approvalsList}>
      {Object.entries(groupedApprovals).map(([spender, approvals]) => (
        <Stack
          key={spender}
          sx={{
            gap: 2,
          }}
        >
          <SpenderField address={spender} />
          {approvals.map((tx) => {
            if (!tx.tokenInfo) return <></>

            return (
              <ListItem
                key={tx.tokenAddress + tx.spender}
                className={BigInt(0) === BigInt(tx.amount) ? css.zeroValueApproval : undefined}
                disablePadding
                data-testid="approval-item"
              >
                <ApprovalItem
                  spender={tx.spender}
                  method={tx.method}
                  amount={tx.amountFormatted}
                  rawAmount={tx.amount}
                  tokenInfo={tx.tokenInfo}
                />
              </ListItem>
            )
          })}
        </Stack>
      ))}
    </List>
  )
}

export default Approvals
</file>

<file path="src/components/tx/ApprovalEditor/ApprovalValueField.tsx">
import NumberField from '@/components/common/NumberField'
import { validateAmount, validateDecimalLength } from '@safe-global/utils/utils/validation'
import { Autocomplete, type MenuItemProps, MenuItem } from '@mui/material'
import { useController, useFormContext } from 'react-hook-form'
import type { ApprovalInfo } from './hooks/useApprovalInfos'
import css from './styles.module.css'
import { PSEUDO_APPROVAL_VALUES } from './utils/approvals'
import { approvalMethodDescription } from './ApprovalItem'

const ApprovalOption = ({ menuItemProps, value }: { menuItemProps: MenuItemProps; value: string }) => {
  return (
    <MenuItem key={value} {...menuItemProps}>
      {value}
    </MenuItem>
  )
}

export const ApprovalValueField = ({ name, tx, readOnly }: { name: string; tx: ApprovalInfo; readOnly: boolean }) => {
  const { control } = useFormContext()
  const selectValues = Object.values(PSEUDO_APPROVAL_VALUES)
  const {
    field: { ref, onBlur, onChange, value },
    fieldState,
  } = useController({
    name,
    control,
    rules: {
      required: true,
      validate: (val) => {
        if (selectValues.includes(val)) {
          return undefined
        }
        const decimals = tx.tokenInfo?.decimals
        return validateAmount(val, true) || validateDecimalLength(val, decimals)
      },
    },
  })

  const helperText = fieldState.error?.message ?? (fieldState.isDirty ? 'Save to apply changes' : '')

  const label = `${approvalMethodDescription[tx.method](tx.tokenInfo?.symbol ?? '')}`
  const options = selectValues

  return (
    <Autocomplete
      freeSolo
      fullWidth
      options={options}
      renderOption={(props, value: string) => <ApprovalOption key={value} menuItemProps={props} value={value} />}
      value={value}
      // On option select or free text entry
      onInputChange={(_, value) => {
        onChange(value)
      }}
      disableClearable
      selectOnFocus={!readOnly}
      readOnly={readOnly}
      componentsProps={{
        paper: {
          elevation: 2,
        },
      }}
      renderInput={(params) => {
        return (
          <NumberField
            {...params}
            label={label}
            name={name}
            fullWidth
            helperText={helperText}
            onFocus={(field) => {
              if (!readOnly) {
                field.target.select()
              }
            }}
            margin="dense"
            variant="standard"
            error={!!fieldState.error}
            size="small"
            onBlur={onBlur}
            inputRef={ref}
            InputProps={{
              ...params.InputProps,
              sx: {
                flexWrap: 'nowrap !important',
                '&::before': {
                  border: 'none !important',
                },
                '&::after': {
                  display: readOnly ? 'none' : undefined,
                },
                border: 'none !important',
              },
            }}
            inputProps={{
              ...params.inputProps,
              className: css.approvalAmount,
            }}
            InputLabelProps={{
              ...params.InputLabelProps,
              shrink: true,
              sx: {
                color: (theme) => (readOnly ? `${theme.palette.text.secondary} !important` : undefined),
              },
            }}
          />
        )
      }}
    />
  )
}
</file>

<file path="src/components/tx/ApprovalEditor/EditableApprovalItem.tsx">
import { Box, Button, IconButton, Stack, SvgIcon } from '@mui/material'
import css from '@/components/tx/ApprovalEditor/styles.module.css'
import type { ApprovalInfo } from './hooks/useApprovalInfos'

import { ApprovalValueField } from './ApprovalValueField'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'
import { useFormContext } from 'react-hook-form'
import get from 'lodash/get'
import { EditOutlined } from '@mui/icons-material'
import TokenIcon from '@/components/common/TokenIcon'
import { useState } from 'react'

const EditableApprovalItem = ({
  approval,
  name,
  onSave,
}: {
  approval: ApprovalInfo
  onSave: () => void
  name: string
}) => {
  const { formState, setFocus } = useFormContext()

  const { errors, dirtyFields } = formState

  const fieldErrors = get(errors, name)
  const isDirty = get(dirtyFields, name)

  const [readOnly, setReadOnly] = useState(true)

  const handleSave = () => {
    onSave()
    setReadOnly(true)
  }

  const handleEditMode = () => {
    setReadOnly(false)
    // We need to rerender such that select on focus triggers
    setTimeout(() => setFocus(name), 0)
  }

  return (
    <Stack
      direction="row"
      alignItems="center"
      gap={2}
      className={css.approvalField}
      onClick={readOnly ? handleEditMode : undefined}
    >
      <Box display="flex" flexDirection="row" alignItems="center" gap="4px">
        <TokenIcon size={32} logoUri={approval.tokenInfo?.logoUri} tokenSymbol={approval.tokenInfo?.symbol} />
      </Box>

      <ApprovalValueField name={name} tx={approval} readOnly={readOnly} />

      <Track {...MODALS_EVENTS.EDIT_APPROVALS} label={readOnly ? 'edit' : 'save'}>
        {readOnly ? (
          <IconButton color="border" onClick={handleEditMode} title="Edit">
            <SvgIcon fontSize="small" component={EditOutlined} inheritViewBox />
          </IconButton>
        ) : (
          <Button title="Save" variant="text" size="small" onClick={handleSave} disabled={!!fieldErrors || !isDirty}>
            Save
          </Button>
        )}
      </Track>
    </Stack>
  )
}

export default EditableApprovalItem
</file>

<file path="src/components/tx/ApprovalEditor/index.tsx">
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import Approvals from '@/components/tx/ApprovalEditor/Approvals'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import { decodeSafeTxToBaseTransactions } from '@/utils/transactions'
import { Alert, Box, Skeleton, Typography } from '@mui/material'
import { type SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import { useContext } from 'react'
import { ApprovalEditorForm } from './ApprovalEditorForm'
import { useApprovalInfos } from './hooks/useApprovalInfos'
import css from './styles.module.css'
import { updateApprovalTxs } from './utils/approvals'

const Title = ({ isErc721 }: { isErc721: boolean }) => {
  const title = 'Allow access to tokens?'
  const subtitle = isErc721
    ? 'This allows the spender to transfer the specified token.'
    : 'This allows the spender to spend the specified amount of your tokens.'

  return (
    <div>
      <Typography
        sx={{
          fontWeight: 700,
        }}
      >
        {title}
      </Typography>
      <Typography variant="body2">{subtitle}</Typography>
    </div>
  )
}

export const ApprovalEditor = ({
  safeTransaction,
  safeMessage,
}: {
  safeTransaction?: SafeTransaction
  safeMessage?: TypedData
}) => {
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const [readableApprovals, error, loading] = useApprovalInfos({ safeTransaction, safeMessage })

  const nonZeroApprovals = readableApprovals?.filter((approval) => !(0n === approval.amount))

  if (nonZeroApprovals?.length === 0 || (!safeTransaction && !safeMessage)) {
    return null
  }

  const updateApprovals = (approvals: string[]) => {
    if (!safeTransaction) {
      return
    }
    const extractedTxs = decodeSafeTxToBaseTransactions(safeTransaction)
    const updatedTxs = updateApprovalTxs(approvals, readableApprovals, extractedTxs)

    const createSafeTx = async (): Promise<SafeTransaction> => {
      const isMultiSend = updatedTxs.length > 1
      return isMultiSend ? createMultiSendCallOnlyTx(updatedTxs) : createTx(updatedTxs[0])
    }

    createSafeTx().then(setSafeTx).catch(setSafeTxError)
  }

  const isErc721Approval = !!readableApprovals?.some((approval) => approval.tokenInfo?.type === TokenType.ERC721)

  const isReadOnly =
    (safeTransaction && safeTransaction.signatures.size > 0) || safeMessage !== undefined || isErc721Approval

  return (
    <Box
      className={css.container}
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        mb: 1,
      }}
    >
      <Title isErc721={isErc721Approval} />
      {error ? (
        <Alert severity="error">Error while decoding approval transactions.</Alert>
      ) : loading || !readableApprovals ? (
        <Skeleton variant="rounded" height={100} data-testid="approval-editor-loading" />
      ) : isReadOnly ? (
        <Approvals approvalInfos={readableApprovals} />
      ) : (
        <ApprovalEditorForm approvalInfos={readableApprovals} updateApprovals={updateApprovals} />
      )}
    </Box>
  )
}

export default ApprovalEditor
</file>

<file path="src/components/tx/ApprovalEditor/SpenderField.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import { Stack, Typography, useMediaQuery, useTheme } from '@mui/material'

import css from './styles.module.css'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import { getContract } from '@safe-global/safe-gateway-typescript-sdk'

export const SpenderField = ({ address }: { address: string }) => {
  const chainId = useChainId()
  const [spendingContract] = useAsync(() => getContract(chainId, address), [chainId, address])
  const { breakpoints } = useTheme()
  const isSmallScreen = useMediaQuery(breakpoints.down('md'))

  return (
    <Stack
      direction="row"
      className={css.approvalField}
      sx={{
        justifyContent: 'space-between',
        alignItems: 'center',
        gap: 2,
      }}
    >
      <Typography
        variant="body2"
        sx={{
          color: 'text.secondary',
        }}
      >
        Spender
      </Typography>
      <div>
        <EthHashInfo
          avatarSize={24}
          address={address}
          name={spendingContract?.displayName || spendingContract?.name}
          customAvatar={spendingContract?.logoUri}
          shortAddress={isSmallScreen}
          hasExplorer
        />
      </div>
    </Stack>
  )
}
</file>

<file path="src/components/tx/ApprovalEditor/styles.module.css">
.container {
  background-color: var(--color-warning-background);
  border-radius: 4px;
  padding: var(--space-2);
}

.warningAccordion {
  border: 1px var(--color-warning-main) solid !important;
  margin-bottom: var(--space-2) !important;
}
.warningAccordion:hover {
  border: 1px var(--color-warning-main) solid !important;
}

.warningAccordion :global .Mui-expanded.MuiAccordionSummary-root,
.warningAccordion :global .MuiAccordionSummary-root:hover {
  background-color: var(--color-warning-background);
}

.alert {
  width: 100%;
}

.approvalField {
  background-color: var(--color-background-paper);
  border-radius: 6px;
  padding: 12px 16px;
  width: 100%;
}

.alert :global .MuiAlert-message {
  width: 100%;
}

.zeroValueApproval {
  display: none;
}

.approvalAmount {
  padding-left: var(--space-1);
}

.approvalsList {
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.wrapper {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.icon {
  width: 34px;
  height: 34px;
  border-radius: 6px;
  display: flex;
  flex-shrink: 0;
  align-items: center;
  justify-content: center;
  background-color: var(--color-warning-background);
}

.icon svg {
  color: var(--color-warning-main);
}
</file>

<file path="src/components/tx/BalanceInfo/index.tsx">
import { Typography } from '@mui/material'
import css from './styles.module.css'
import useWalletBalance from '@/hooks/wallets/useWalletBalance'
import WalletBalance from '@/components/common/WalletBalance'

// TODO: Remove this component if not being used
const BalanceInfo = () => {
  const [balance] = useWalletBalance()

  return (
    <div className={css.container}>
      <Typography variant="body2" color="primary.light">
        <b>Wallet balance:</b> <WalletBalance balance={balance} />
      </Typography>
    </div>
  )
}

export default BalanceInfo
</file>

<file path="src/components/tx/BalanceInfo/styles.module.css">
.container {
  padding: 8px 12px;
  background-color: var(--color-background-main);
  border-bottom-left-radius: 6px;
  border-bottom-right-radius: 6px;
  border-top: 1px solid var(--color-border-light);
  display: flex;
}
</file>

<file path="src/components/tx/ColorCodedTxAccordion/HelpTooltip.tsx">
import { Tooltip, SvgIcon } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'

const HelpTooltip = () => (
  <Tooltip
    title={
      <>
        Always verify transaction details.{' '}
        <ExternalLink href={HelpCenterArticle.VERIFY_TX_DETAILS}>Learn more</ExternalLink>.
      </>
    }
    arrow
    placement="top"
  >
    <span>
      <SvgIcon
        component={InfoIcon}
        inheritViewBox
        color="border"
        fontSize="small"
        sx={{
          verticalAlign: 'middle',
          ml: 0.5,
          mt: '-1px',
        }}
      />
    </span>
  </Tooltip>
)

export default HelpTooltip
</file>

<file path="src/components/tx/ColorCodedTxAccordion/index.tsx">
import type { ReactNode } from 'react'
import { type SyntheticEvent, type ReactElement, memo, useMemo } from 'react'
import { isNativeTokenTransfer, isTransferTxInfo } from '@/utils/transaction-guards'
import {
  Accordion,
  accordionClasses,
  AccordionDetails,
  AccordionSummary,
  accordionSummaryClasses,
  Box,
  Stack,
  styled,
  Typography,
} from '@mui/material'
import { TransactionInfoType, type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { trackEvent, MODALS_EVENTS } from '@/services/analytics'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import accordionCss from '@/styles/accordion.module.css'
import HelpTooltip from './HelpTooltip'
import { useDarkMode } from '@/hooks/useDarkMode'

enum ColorLevel {
  info = 'info',
  warning = 'warning',
  success = 'success',
}

const TX_INFO_LEVEL = {
  [ColorLevel.warning]: [TransactionInfoType.SETTINGS_CHANGE],
  [ColorLevel.success]: [
    TransactionInfoType.TRANSFER,
    TransactionInfoType.SWAP_TRANSFER,
    TransactionInfoType.TWAP_ORDER,
    TransactionInfoType.NATIVE_STAKING_DEPOSIT,
  ],
}

const TxInfoColors: Record<ColorLevel, { main: string; mainDark?: string; background: string; border?: string }> = {
  [ColorLevel.info]: { main: 'info.dark', background: 'info.background' },
  [ColorLevel.warning]: { main: 'warning.main', background: 'warning.background', border: 'warning.light' },
  [ColorLevel.success]: {
    main: 'success.main',
    mainDark: 'primary.main',
    background: 'background.light',
    border: 'success.light',
  },
}

const getMethodLevel = (txInfo?: TransactionInfoType): ColorLevel => {
  if (!txInfo) {
    return ColorLevel.info
  }

  const methodLevels = Object.keys(TX_INFO_LEVEL) as (keyof typeof TX_INFO_LEVEL)[]
  return (methodLevels.find((key) => TX_INFO_LEVEL[key].includes(txInfo)) as ColorLevel) || ColorLevel.info
}

const toCssVar = (color: string) => `var(--color-${color.replace('.', '-')})`

const StyledAccordion = styled(Accordion)<{ color?: ColorLevel }>(({ color = ColorLevel.info }) => {
  const { main, border, background } = TxInfoColors[color]
  return {
    [`&.${accordionClasses.expanded}.${accordionClasses.root}, &:hover.${accordionClasses.root}`]: {
      borderColor: toCssVar(border || main),
    },
    [`&.${accordionClasses.expanded} > * > .${accordionSummaryClasses.root}`]: {
      backgroundColor: toCssVar(background),
    },
  }
})

type DecodedTxProps = {
  txInfo?: TransactionDetails['txInfo']
  txData?: TransactionDetails['txData']
  children: ReactNode
  defaultExpanded?: boolean
}

export const Divider = () => (
  <Box
    borderBottom="1px solid var(--color-border-light)"
    width="calc(100% + 32px)"
    my={2}
    sx={{ ml: '-16px !important' }}
  />
)

const onChangeExpand = (_: SyntheticEvent, expanded: boolean) => {
  trackEvent({ ...MODALS_EVENTS.TX_DETAILS, label: expanded ? 'Open' : 'Close' })
}

const ColorCodedTxAccordion = ({ txInfo, txData, children, defaultExpanded }: DecodedTxProps): ReactElement => {
  const isDarkMode = useDarkMode()
  const decodedData = txData?.dataDecoded
  const level = useMemo(() => getMethodLevel(txInfo?.type), [txInfo?.type])
  const colors = TxInfoColors[level]

  const methodLabel =
    txInfo && isTransferTxInfo(txInfo) && isNativeTokenTransfer(txInfo.transferInfo)
      ? 'native transfer'
      : decodedData?.method

  return (
    <StyledAccordion elevation={0} onChange={onChangeExpand} color={level} defaultExpanded={defaultExpanded}>
      <AccordionSummary
        data-testid="decoded-tx-summary"
        expandIcon={<ExpandMoreIcon />}
        className={accordionCss.accordion}
      >
        <Stack direction="row" justifyContent="space-between" alignItems="center" width="100%">
          <Typography variant="subtitle2" fontWeight={700}>
            Transaction details
            <HelpTooltip />
          </Typography>

          {methodLabel && (
            <Typography
              component="span"
              variant="body2"
              alignContent="center"
              color={isDarkMode ? (colors.mainDark ?? colors.main) : colors.main}
              py={0.5}
              px={1}
              borderRadius={0.5}
              bgcolor={colors.background}
            >
              {methodLabel}
            </Typography>
          )}
        </Stack>
      </AccordionSummary>

      <AccordionDetails data-testid="decoded-tx-details">{children}</AccordionDetails>
    </StyledAccordion>
  )
}

export default memo(ColorCodedTxAccordion)
</file>

<file path="src/components/tx/confirmation-views/BatchTransactions/BatchTransactions.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { Paper, ThemeProvider } from '@mui/material'
import { StoreDecorator } from '@/stories/storeDecorator'
import BatchTransactions from './index'
import { mockedDarftBatch } from './mockData'
import createSafeTheme from '@/components/theme/safeTheme'

const meta = {
  component: BatchTransactions,
  parameters: {
    layout: 'centered',
  },
  decorators: [
    (Story) => {
      return (
        <StoreDecorator
          initialState={{
            chains: { data: [{ chainId: '11155111' }] },
            batch: {
              '11155111': {
                '': [mockedDarftBatch[0], mockedDarftBatch[0]],
              },
            },
          }}
        >
          <ThemeProvider theme={createSafeTheme('dark')}>
            <Paper sx={{ padding: 2 }}>
              <Story />
            </Paper>
          </ThemeProvider>
        </StoreDecorator>
      )
    },
  ],

  tags: ['autodocs'],
} satisfies Meta<typeof BatchTransactions>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {}
</file>

<file path="src/components/tx/confirmation-views/BatchTransactions/index.tsx">
import BatchTxList from '@/components/batch/BatchSidebar/BatchTxList'
import { useDraftBatch } from '@/hooks/useDraftBatch'

function BatchTransactions() {
  const batchTxs = useDraftBatch()

  return <BatchTxList txItems={batchTxs} />
}

export default BatchTransactions
</file>

<file path="src/components/tx/confirmation-views/BatchTransactions/mockData.ts">
import type { DraftBatchItem } from '@/store/batchSlice'

export const mockedDarftBatch = [
  {
    id: '6283sw7pzyk',
    timestamp: 1726820415651,
    txDetails: {
      safeAddress: '0xA77DE01e157f9f57C7c4A326eeE9C4874D0598b6',
      txId: 'multisig_0xA77DE01e157f9f57C7c4A326eeE9C4874D0598b6_0x876e728deafcc9ba46461cc63078a521f520b620b0a3c2e4b40a5f1f69358f6c',
      executedAt: null,
      txStatus: 'AWAITING_CONFIRMATIONS',
      txInfo: {
        type: 'Transfer',
        humanDescription: null,
        sender: {
          value: '0xA77DE01e157f9f57C7c4A326eeE9C4874D0598b6',
          name: null,
          logoUri: null,
        },
        recipient: {
          value: '0xA77DE01e157f9f57C7c4A326eeE9C4874D0598b6',
          name: 'GnosisSafeProxy',
          logoUri: null,
        },
        direction: 'OUTGOING',
        transferInfo: {
          type: 'NATIVE_COIN',
          value: '1000000000000',
        },
      },
      txData: {
        hexData: null,
        dataDecoded: null,
        to: {
          value: '0xA77DE01e157f9f57C7c4A326eeE9C4874D0598b6',
          name: 'GnosisSafeProxy',
          logoUri: null,
        },
        value: '1000000000000',
        operation: 0,
        trustedDelegateCallTarget: null,
        addressInfoIndex: null,
      },
      txHash: null,
      detailedExecutionInfo: {
        type: 'MULTISIG',
        submittedAt: 1726820406700,
        nonce: 45,
        safeTxGas: '0',
        baseGas: '0',
        gasPrice: '0',
        gasToken: '0x0000000000000000000000000000000000000000',
        refundReceiver: {
          value: '0x0000000000000000000000000000000000000000',
          name: null,
          logoUri: null,
        },
        safeTxHash: '0x876e728deafcc9ba46461cc63078a521f520b620b0a3c2e4b40a5f1f69358f6c',
        executor: null,
        signers: [
          {
            value: '0xDa5e9FA404881Ff36DDa97b41Da402dF6430EE6b',
            name: null,
            logoUri: null,
          },
          {
            value: '0xEe91F585eA6ABc2822FaD082a095B46939059a31',
            name: null,
            logoUri: null,
          },
          {
            value: '0x3819b800c67Be64029C1393c8b2e0d0d627dADE2',
            name: null,
            logoUri: null,
          },
          {
            value: '0xd8BBcB76BC9AeA78972ED4773A5EB67B413f26A5',
            name: null,
            logoUri: null,
          },
          {
            value: '0x21D62C6894741DE97944D7844ED44D7782C66ABC',
            name: null,
            logoUri: null,
          },
          {
            value: '0xD33dD066fC8a0BC70269AC06B0ED98B00BFA3A0a',
            name: null,
            logoUri: null,
          },
          {
            value: '0xC2e333cb4aFfD6067D1d46ff80A6e631EC7B5A17',
            name: null,
            logoUri: null,
          },
          {
            value: '0xbc2BB26a6d821e69A38016f3858561a1D80d4182',
            name: null,
            logoUri: null,
          },
          {
            value: '0x474e5Ded6b5D078163BFB8F6dBa355C3aA5478C8',
            name: null,
            logoUri: null,
          },
        ],
        confirmationsRequired: 2,
        confirmations: [],
        rejectors: [],
        gasTokenInfo: null,
        trusted: false,
        proposer: {
          value: '0xDa5e9FA404881Ff36DDa97b41Da402dF6430EE6b',
          name: null,
          logoUri: null,
        },
      },
      safeAppInfo: null,
    },
  },
] as unknown as DraftBatchItem[]
</file>

<file path="src/components/tx/confirmation-views/ChangeThreshold/ChangeThreshold.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { Paper } from '@mui/material'
import { StoreDecorator } from '@/stories/storeDecorator'
import ChangeThreshold from './index'
import { SettingsInfoType, type TransactionInfo, TransactionInfoType } from '@safe-global/safe-gateway-typescript-sdk'

const meta = {
  component: ChangeThreshold,
  args: {
    txInfo: {
      type: TransactionInfoType.SETTINGS_CHANGE,
      settingsInfo: {
        type: SettingsInfoType.CHANGE_THRESHOLD,
        threshold: 1,
      },
    } as TransactionInfo,
  },
  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{}}>
          <Paper sx={{ padding: 2 }}>
            <Story />
          </Paper>
        </StoreDecorator>
      )
    },
  ],

  tags: ['autodocs'],
} satisfies Meta<typeof ChangeThreshold>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {},
}
</file>

<file path="src/components/tx/confirmation-views/ChangeThreshold/index.tsx">
import { Box, Divider, Typography } from '@mui/material'
import React from 'react'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import useSafeInfo from '@/hooks/useSafeInfo'
import { ChangeSignerSetupWarning } from '@/features/multichain/components/SignerSetupWarning/ChangeSignerSetupWarning'
import { type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { isChangeThresholdView } from '../utils'
import { maybePlural } from '@safe-global/utils/utils/formatters'

interface ChangeThresholdProps {
  txInfo?: TransactionDetails['txInfo']
}

function ChangeThreshold({ txInfo }: ChangeThresholdProps) {
  const { safe } = useSafeInfo()
  const threshold = txInfo && isChangeThresholdView(txInfo) && txInfo.settingsInfo?.threshold

  return (
    <>
      <ChangeSignerSetupWarning />

      <div>
        <Typography variant="body2" color="text.secondary" mb={0.5}>
          Any transaction will require the confirmation of:
        </Typography>

        <Typography aria-label="threshold">
          <b>{threshold}</b> out of{' '}
          <b>
            {safe.owners.length} signer{maybePlural(safe.owners)}
          </b>
        </Typography>
      </div>
      <Box
        sx={{
          my: 1,
        }}
      >
        <Divider className={commonCss.nestedDivider} />
      </Box>
    </>
  )
}

export default ChangeThreshold
</file>

<file path="src/components/tx/confirmation-views/MigrateToL2Information/index.tsx">
import { Alert, AlertTitle, Box, SvgIcon, Typography } from '@mui/material'
import type { TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import InfoOutlinedIcon from '@/public/images/notifications/info.svg'

export const MigrateToL2Information = ({ variant }: { variant: 'history' | 'queue'; txData?: TransactionData }) => {
  return (
    <Box>
      <Alert severity="info" icon={<SvgIcon component={InfoOutlinedIcon} color="info" />}>
        <AlertTitle>
          <Typography variant="h5" fontWeight={700}>
            Migration to compatible base contract
          </Typography>
        </AlertTitle>
        <Typography>
          {variant === 'history'
            ? 'This Safe was using an incompatible base contract. This transaction includes the migration to a supported base contract.'
            : 'This Safe is currently using an incompatible base contract. The transaction was automatically modified to first migrate to a supported base contract.'}
        </Typography>
      </Alert>
    </Box>
  )
}
</file>

<file path="src/components/tx/confirmation-views/NestedSafeCreation/index.tsx">
import { Box, Typography } from '@mui/material'
import type { ReactElement } from 'react'
import type { TransactionData } from '@safe-global/safe-gateway-typescript-sdk'

import useAsync from '@safe-global/utils/hooks/useAsync'
import { predictSafeAddress } from '@/features/multichain/utils/utils'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import EthHashInfo from '@/components/common/EthHashInfo'
import useAddressBook from '@/hooks/useAddressBook'
import { _getFactoryAddressAndSetupData } from '@/utils/nested-safes'

export function NestedSafeCreation({ txData }: { txData: TransactionData }): ReactElement | null {
  const addressBook = useAddressBook()
  const provider = useWeb3ReadOnly()

  const [predictedSafeAddress] = useAsync(async () => {
    if (provider) {
      const { factoryAddress, ...setupData } = _getFactoryAddressAndSetupData(txData)
      return predictSafeAddress(setupData, factoryAddress, provider)
    }
  }, [provider, txData])

  if (!predictedSafeAddress) {
    return null
  }

  return (
    <Box display="flex" alignItems="center" justifyContent="space-between">
      <Typography variant="body2" color="text.secondary" whiteSpace="nowrap">
        Nested Safe
      </Typography>

      <div>
        <EthHashInfo
          name={addressBook[predictedSafeAddress]}
          address={predictedSafeAddress}
          shortAddress={false}
          hasExplorer
          showCopyButton
          showAvatar
        />
      </div>
    </Box>
  )
}
</file>

<file path="src/components/tx/confirmation-views/SettingsChange/index.tsx">
import { Paper, Typography, Box, Divider, SvgIcon } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import type { NarrowConfirmationViewProps } from '../types'
import { OwnerList } from '@/components/tx-flow/common/OwnerList'
import MinusIcon from '@/public/images/common/minus.svg'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import useSafeInfo from '@/hooks/useSafeInfo'
import { SettingsInfoType, type SettingsChange } from '@safe-global/safe-gateway-typescript-sdk'
import { ChangeSignerSetupWarning } from '@/features/multichain/components/SignerSetupWarning/ChangeSignerSetupWarning'
import { useContext } from 'react'
import { SettingsChangeContext } from '@/components/tx-flow/flows/AddOwner/context'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { UntrustedFallbackHandlerTxAlert } from '@/components/tx/confirmation-views/SettingsChange/UntrustedFallbackHandlerTxAlert'

export interface SettingsChangeProps extends NarrowConfirmationViewProps {
  txInfo: SettingsChange
}

const SettingsChange: React.FC<SettingsChangeProps> = ({ txInfo: { settingsInfo } }) => {
  const { safe } = useSafeInfo()
  const params = useContext(SettingsChangeContext)

  if (!settingsInfo || settingsInfo.type === SettingsInfoType.REMOVE_OWNER) return null

  const shouldShowChangeSigner = 'owner' in settingsInfo || 'newOwner' in params
  const hasNewOwner = 'newOwner' in params
  const newSignersLength = safe.owners.length + ('removedOwner' in settingsInfo ? 0 : 1)
  const setsFallbackHandler = settingsInfo.type === SettingsInfoType.SET_FALLBACK_HANDLER

  return (
    <>
      {setsFallbackHandler && <UntrustedFallbackHandlerTxAlert fallbackHandler={settingsInfo.handler.value} />}

      {'oldOwner' in settingsInfo && (
        <Paper sx={{ backgroundColor: ({ palette }) => palette.warning.background, p: 2 }}>
          <Typography color="text.secondary" mb={2} display="flex" alignItems="center">
            <SvgIcon component={MinusIcon} inheritViewBox fontSize="small" sx={{ mr: 1 }} />
            Previous signer
          </Typography>
          <EthHashInfo
            name={settingsInfo.oldOwner.name}
            address={settingsInfo.oldOwner.value}
            shortAddress={false}
            showCopyButton
            hasExplorer
          />
        </Paper>
      )}

      {'owner' in settingsInfo && !hasNewOwner && <OwnerList owners={[settingsInfo.owner]} />}
      {hasNewOwner && <OwnerList owners={[{ name: params.newOwner.name, value: params.newOwner.address }]} />}

      {shouldShowChangeSigner && <ChangeSignerSetupWarning />}

      {'threshold' in settingsInfo && (
        <>
          <Divider className={commonCss.nestedDivider} />

          <Box>
            <Typography variant="body2">Any transaction requires the confirmation of:</Typography>
            <Typography>
              <b>{settingsInfo.threshold}</b> out of{' '}
              <b>
                {newSignersLength} signer{maybePlural(newSignersLength)}
              </b>
            </Typography>
          </Box>
        </>
      )}
      <Divider className={commonCss.nestedDivider} />
    </>
  )
}

export default SettingsChange
</file>

<file path="src/components/tx/confirmation-views/SettingsChange/mockData.ts">
import type { SettingsChange } from '@safe-global/safe-gateway-typescript-sdk'
import { SettingsInfoType, TransactionInfoType } from '@safe-global/safe-gateway-typescript-sdk'

export const ownerAddress = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
export const txInfo: SettingsChange = {
  type: TransactionInfoType.SETTINGS_CHANGE,
  humanDescription: 'Add new owner 0xd8dA...6045 with threshold 1',
  dataDecoded: {
    method: 'addOwnerWithThreshold',
    parameters: [
      {
        name: 'owner',
        type: 'address',
        value: ownerAddress,
      },
      {
        name: '_threshold',
        type: 'uint256',
        value: '1',
      },
    ],
  },
  settingsInfo: {
    type: SettingsInfoType.ADD_OWNER,
    owner: {
      value: ownerAddress,
      name: 'Nevinha',
      logoUri: 'http://something.com',
    },
    threshold: 1,
  },
}
</file>

<file path="src/components/tx/confirmation-views/SettingsChange/SettingsChange.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { Paper } from '@mui/material'
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { SettingsInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import { StoreDecorator } from '@/stories/storeDecorator'
import { ownerAddress, txInfo } from './mockData'
import SettingsChange from '.'

const meta = {
  component: SettingsChange,
  parameters: {
    layout: 'centered',
  },
  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{}}>
          <Paper sx={{ padding: 2 }}>
            <Story />
          </Paper>
        </StoreDecorator>
      )
    },
  ],

  tags: ['autodocs'],
} satisfies Meta<typeof SettingsChange>

export default meta
type Story = StoryObj<typeof meta>

export const AddOwner: Story = {
  args: {
    txInfo,
    txData: {} as TransactionDetails['txData'],
  },
}

export const SwapOwner: Story = {
  args: {
    txInfo: {
      ...txInfo,
      settingsInfo: {
        type: SettingsInfoType.SWAP_OWNER,
        oldOwner: {
          value: '0x00000000',
          name: 'Bob',
          logoUri: 'http://bob.com',
        },
        newOwner: {
          value: ownerAddress,
          name: 'Alice',
          logoUri: 'http://something.com',
        },
      },
    },
    txData: {} as TransactionDetails['txData'],
  },
}
</file>

<file path="src/components/tx/confirmation-views/SettingsChange/UntrustedFallbackHandlerTxAlert.tsx">
import type { ReactElement } from 'react'
import { Alert, SvgIcon } from '@mui/material'
import InfoOutlinedIcon from '@/public/images/notifications/info.svg'
import { useIsOfficialFallbackHandler } from '@/hooks/useIsOfficialFallbackHandler'
import { useIsTWAPFallbackHandler } from '@/features/swap/hooks/useIsTWAPFallbackHandler'
import { FallbackHandlerWarning } from '@/components/settings/FallbackHandler'

export const UntrustedFallbackHandlerTxText = ({ isTxExecuted = false }: { isTxExecuted?: boolean }) => (
  <>
    <FallbackHandlerWarning
      message={
        <>
          This transaction {isTxExecuted ? 'has set' : 'sets'} an <b>unofficial</b> fallback handler.
        </>
      }
      txBuilderLinkPrefix={isTxExecuted ? 'It can be altered via the' : ''}
    />
    {!isTxExecuted && (
      <>
        <br />
        <b>Proceed with caution:</b> ensure the fallback handler address is trusted and secure. If unsure, do not
        proceed.
      </>
    )}
  </>
)

export const UntrustedFallbackHandlerTxAlert = ({
  fallbackHandler,
  isTxExecuted = false,
}: {
  fallbackHandler: string
  isTxExecuted?: boolean
}): ReactElement | null => {
  const isOfficial = useIsOfficialFallbackHandler(fallbackHandler)
  const isTWAPFallbackHandler = useIsTWAPFallbackHandler(fallbackHandler)

  if (isOfficial || isTWAPFallbackHandler) {
    return null
  }

  return (
    <Alert
      data-testid="untrusted-fallback-handler-alert"
      severity="warning"
      icon={<SvgIcon component={InfoOutlinedIcon} inheritViewBox color="error" />}
      sx={{ mb: 1 }}
    >
      <UntrustedFallbackHandlerTxText isTxExecuted={isTxExecuted} />
    </Alert>
  )
}
</file>

<file path="src/components/tx/confirmation-views/StakingTx/index.tsx">
import StrakingConfirmationTx from '@/features/stake/components/StakingConfirmationTx'
import type { StakingTxInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { NarrowConfirmationViewProps } from '../types'

export interface StakingTxProps extends NarrowConfirmationViewProps {
  txInfo: StakingTxInfo
}

function StakingTx({ txInfo }: StakingTxProps) {
  return <StrakingConfirmationTx order={txInfo} />
}

export default StakingTx
</file>

<file path="src/components/tx/confirmation-views/SwapOrder/index.tsx">
import SwapOrderConfirmation from '@/features/swap/components/SwapOrderConfirmationView'
import type { Order } from '@safe-global/safe-gateway-typescript-sdk'
import type { NarrowConfirmationViewProps } from '../types'

interface SwapOrderProps extends NarrowConfirmationViewProps {
  txInfo: Order
}

function SwapOrder({ txInfo, txData }: SwapOrderProps) {
  return (
    <SwapOrderConfirmation
      order={txInfo}
      decodedData={txData?.dataDecoded}
      settlementContract={txData?.to?.value ?? ''}
    />
  )
}

export default SwapOrder
</file>

<file path="src/components/tx/confirmation-views/UpdateSafe/index.tsx">
import type { ReactNode } from 'react'
import { Alert, AlertTitle, Box, Divider, Stack, Typography } from '@mui/material'
import semverSatisfies from 'semver/functions/satisfies'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useQueuedTxsLength } from '@/hooks/useTxQueue'
import ExternalLink from '@/components/common/ExternalLink'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import madProps from '@/utils/mad-props'
import { type TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import { extractTargetVersionFromUpdateSafeTx } from '@/services/tx/safeUpdateParams'

const QUEUE_WARNING_VERSION = '<1.3.0'

function BgBox({ children, light, warning }: { children: ReactNode; light?: boolean; warning?: boolean }) {
  const bgcolor = warning ? 'warning.background' : light ? 'background.light' : 'border.background'
  return (
    <Box flex={1} bgcolor={bgcolor} p={2} textAlign="center" fontWeight={700} fontSize={18} borderRadius={1}>
      {children}
    </Box>
  )
}

export function _UpdateSafe({
  safeInfo,
  queueSize,
  chain,
  txData,
}: {
  safeInfo: ReturnType<typeof useSafeInfo>
  queueSize: string
  chain: ReturnType<typeof useCurrentChain>
  txData: TransactionData | undefined
}) {
  const { safe } = safeInfo
  if (!safe.version) {
    return null
  }
  const showQueueWarning = queueSize && semverSatisfies(safe.version, QUEUE_WARNING_VERSION)
  const newVersion = extractTargetVersionFromUpdateSafeTx(txData, safe)

  return (
    <>
      <Stack direction="row" alignItems="center" spacing={2}>
        <BgBox>Current version: {safe.version}</BgBox>
        <Box fontSize={28}>→</Box>
        {newVersion !== undefined ? (
          <BgBox light>
            New version: {newVersion} {chain?.l2 ? '+L2' : ''}
          </BgBox>
        ) : (
          <BgBox warning>Unknown contract</BgBox>
        )}
      </Stack>
      {newVersion !== undefined ? (
        <Typography>
          Read about the updates in the new Safe contracts version in the{' '}
          <ExternalLink href={`https://github.com/safe-global/safe-contracts/releases/tag/v${newVersion}`}>
            version {newVersion} changelog
          </ExternalLink>
        </Typography>
      ) : (
        <Alert severity="error">
          <AlertTitle sx={{ fontWeight: 700 }}>Unknown contract</AlertTitle>
          The target contract for this upgrade is unknown. Verify the transaction data and the target contract address
          before executing this transaction.
        </Alert>
      )}

      {showQueueWarning && (
        <Alert severity="warning">
          <AlertTitle sx={{ fontWeight: 700 }}>This upgrade will invalidate all queued transactions!</AlertTitle>
          You have {queueSize} unexecuted transaction{maybePlural(parseInt(queueSize))}. Please make sure to execute or
          delete them before upgrading, otherwise you&apos;ll have to reject or replace them after the upgrade.
        </Alert>
      )}

      <Divider sx={{ my: 1, mx: -3 }} />
    </>
  )
}

const UpdateSafe = madProps(_UpdateSafe, {
  chain: useCurrentChain,
  safeInfo: useSafeInfo,
  queueSize: useQueuedTxsLength,
})

export default UpdateSafe
</file>

<file path="src/components/tx/confirmation-views/index.tsx">
import type { TransactionPreview } from '@safe-global/safe-gateway-typescript-sdk'
import { type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import {
  isAnyStakingTxInfo,
  isCustomTxInfo,
  isExecTxData,
  isOnChainConfirmationTxData,
  isSafeMigrationTxData,
  isSafeUpdateTxData,
  isSwapOrderTxInfo,
  isTwapOrderTxInfo,
} from '@/utils/transaction-guards'
import { type ReactNode, useContext, useMemo } from 'react'
import TxData from '@/components/transactions/TxDetails/TxData'
import type { NarrowConfirmationViewProps } from './types'
import SettingsChange from './SettingsChange'
import ChangeThreshold from './ChangeThreshold'
import BatchTransactions from './BatchTransactions'
import { TxModalContext } from '@/components/tx-flow'
import { isSettingsChangeView, isChangeThresholdView, isConfirmBatchView } from './utils'
import { OnChainConfirmation } from '@/components/transactions/TxDetails/TxData/NestedTransaction/OnChainConfirmation'
import { ExecTransaction } from '@/components/transactions/TxDetails/TxData/NestedTransaction/ExecTransaction'
import { type ReactElement } from 'react'
import SwapOrder from './SwapOrder'
import StakingTx from './StakingTx'
import UpdateSafe from './UpdateSafe'
import { MigrateToL2Information } from './MigrateToL2Information'
import { NestedSafeCreation } from './NestedSafeCreation'
import { isNestedSafeCreation } from '@/utils/nested-safes'
import Summary from '@/components/transactions/TxDetails/Summary'

type ConfirmationViewProps = {
  txDetails?: TransactionDetails
  txPreview?: TransactionPreview
  safeTx?: SafeTransaction
  isBatch?: boolean
  isApproval?: boolean
  isCreation?: boolean
  children?: ReactNode
}

const getConfirmationViewComponent = ({
  txInfo,
  txData,
  txFlow,
}: NarrowConfirmationViewProps & { txFlow?: ReactElement }) => {
  if (isChangeThresholdView(txInfo)) return <ChangeThreshold txInfo={txInfo} />

  if (isConfirmBatchView(txFlow)) return <BatchTransactions />

  if (isSettingsChangeView(txInfo)) return <SettingsChange txInfo={txInfo as SettingsChange} />

  if (isOnChainConfirmationTxData(txData)) return <OnChainConfirmation data={txData} isConfirmationView />

  if (isExecTxData(txData)) return <ExecTransaction data={txData} isConfirmationView />

  if (isSwapOrderTxInfo(txInfo) || isTwapOrderTxInfo(txInfo)) return <SwapOrder txInfo={txInfo} txData={txData} />

  if (isAnyStakingTxInfo(txInfo)) return <StakingTx txInfo={txInfo} />

  if (isCustomTxInfo(txInfo) && isSafeUpdateTxData(txData)) return <UpdateSafe txData={txData} />

  if (isCustomTxInfo(txInfo) && isSafeMigrationTxData(txData)) {
    return <MigrateToL2Information variant="queue" txData={txData} />
  }

  if (isCustomTxInfo(txInfo) && txData && isNestedSafeCreation(txData)) {
    return <NestedSafeCreation txData={txData} />
  }

  return null
}

const ConfirmationView = ({ safeTx, txPreview, txDetails, ...props }: ConfirmationViewProps) => {
  const { txFlow } = useContext(TxModalContext)
  const details = txDetails ?? txPreview

  const ConfirmationViewComponent = useMemo(() => {
    return details
      ? getConfirmationViewComponent({
          txInfo: details.txInfo,
          txData: details.txData,
          txFlow,
        })
      : undefined
  }, [details, txFlow])

  return (
    <>
      {ConfirmationViewComponent ||
        (details && (
          <TxData txData={details?.txData} txInfo={details?.txInfo} txDetails={txDetails} imitation={false} trusted />
        ))}

      {props.children}

      <Summary safeTxData={safeTx?.data} txDetails={txDetails} txData={details?.txData} txInfo={details?.txInfo} />
    </>
  )
}

export default ConfirmationView
</file>

<file path="src/components/tx/confirmation-views/types.d.ts">
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'

export type NarrowConfirmationViewProps = {
  txInfo: TransactionDetails['txInfo']
  txData?: TransactionDetails['txData']
}
</file>

<file path="src/components/tx/confirmation-views/useTxPreview.ts">
import { Operation, getTxPreview } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '@/hooks/useSafeInfo'

const useTxPreview = (
  safeTxData?: {
    operation: SafeTransaction['data']['operation']
    data: SafeTransaction['data']['data']
    value: SafeTransaction['data']['value']
    to: SafeTransaction['data']['to']
  },
  customSafeAddress?: string,
  txId?: string,
) => {
  const skip = !!txId || !safeTxData
  const {
    safe: { chainId },
    safeAddress,
  } = useSafeInfo()
  const address = customSafeAddress ?? safeAddress
  const { operation = Operation.CALL, data = '', to, value } = safeTxData ?? {}

  return useAsync(() => {
    if (skip) return
    return getTxPreview(chainId, address, operation, data, to, value)
  }, [skip, chainId, address, operation, data, to, value])
}

export default useTxPreview
</file>

<file path="src/components/tx/confirmation-views/utils.ts">
import type { ChangeThreshold, SettingsChange, TransactionInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { SettingsInfoType, TransactionInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import { ConfirmBatchFlow } from '@/components/tx-flow/flows'
import { type ReactElement } from 'react'

export const isSettingsChangeView = (txInfo: TransactionInfo) => txInfo.type === TransactionInfoType.SETTINGS_CHANGE

export const isConfirmBatchView = (txFlow?: ReactElement) => txFlow?.type === ConfirmBatchFlow

export const isChangeThresholdView = (
  txInfo: TransactionInfo,
): txInfo is SettingsChange & { settingsInfo: ChangeThreshold } =>
  txInfo.type === TransactionInfoType.SETTINGS_CHANGE && txInfo.settingsInfo?.type === SettingsInfoType.CHANGE_THRESHOLD
</file>

<file path="src/components/tx/ConfirmationOrder/ConfirmationOrderHeader.tsx">
import { Stack, Box, Typography, SvgIcon } from '@mui/material'
import EastRoundedIcon from '@mui/icons-material/EastRounded'
import TokenIcon from '@/components/common/TokenIcon'
import TokenAmount from '@/components/common/TokenAmount'

export type InfoBlock = {
  value: string
  label: string
  tokenInfo?: {
    decimals?: number | null
    symbol: string
    logoUri?: string | null
  }
}

const ConfirmationOrderHeader = ({ blocks, showArrow }: { blocks: [InfoBlock, InfoBlock]; showArrow?: boolean }) => {
  return (
    <Stack direction="row" spacing={1}>
      {blocks.map((block, index) => (
        <Stack
          key={index}
          direction="row"
          sx={{
            flexWrap: 'wrap',
            alignItems: 'center',
            width: '50%',
            bgcolor: 'border.background',
            position: 'relative',
            borderRadius: 1,
            py: 2,
            px: 3,
          }}
        >
          {block.tokenInfo && (
            <Box width={40} mr={2}>
              <TokenIcon size={40} logoUri={block.tokenInfo.logoUri || ''} tokenSymbol={block.tokenInfo.symbol} />
            </Box>
          )}

          <Box data-testid="block-label" flex={1}>
            <Typography variant="body2" color="primary.light">
              {block.label}
            </Typography>

            <Typography variant="h4" fontWeight="bold" component="div">
              {block.tokenInfo ? (
                <TokenAmount
                  tokenSymbol={block.tokenInfo.symbol}
                  decimals={block.tokenInfo.decimals}
                  value={block.value}
                />
              ) : (
                block.value
              )}
            </Typography>
          </Box>

          {showArrow && index === 0 && (
            <Stack
              sx={{
                width: 40,
                height: 40,
                alignItems: 'center',
                justifyContent: 'center',
                p: 1,
                borderRadius: '100%',
                bgcolor: 'background.paper',
                position: 'absolute',
                right: -20,
                top: '50%',
                transform: 'translateY(-50%)',
                zIndex: 2,
              }}
            >
              <SvgIcon component={EastRoundedIcon} inheritViewBox fontSize="small" />
            </Stack>
          )}
        </Stack>
      ))}
    </Stack>
  )
}

export default ConfirmationOrderHeader
</file>

<file path="src/components/tx/ConfirmTxDetails/index.tsx">
import TxCard from '@/components/tx-flow/common/TxCard'
import { Grid2 as Grid, Stack, StepIcon, Typography } from '@mui/material'
import { TxDetails } from './TxDetails'
import ExternalLink from '@/components/common/ExternalLink'
import { useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import SignOrExecuteFormV2 from '../SignOrExecuteForm/SignOrExecuteFormV2'
import type { SignOrExecuteProps } from '../SignOrExecuteForm/SignOrExecuteFormV2'
import useTxPreview from '../confirmation-views/useTxPreview'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'
import useWallet from '@/hooks/wallets/useWallet'
import { isHardwareWallet, isLedgerLive } from '@/utils/wallets'

const InfoSteps = [
  {
    label: 'Review what you will sign',
    description: (
      <Typography>
        Signing is an irreversible action so make sure you know what you are signing.{' '}
        <Track {...MODALS_EVENTS.SIGNING_ARTICLE}>
          <ExternalLink href="https://help.safe.global/en/articles/276343-how-to-perform-basic-transactions-checks-on-safe-wallet">
            Read more
          </ExternalLink>
        </Track>
        .
      </Typography>
    ),
  },
  {
    label: 'Compare with your wallet',
    description: (
      <Typography>
        Once you click <b>Sign</b>, the transaction will appear in your signing wallet. Make sure that all the details
        match.
      </Typography>
    ),
  },
  {
    label: 'Verify with external tools',
    description: (
      <Typography>
        You can additionally cross-verify your transaction data in a third-party tool like{' '}
        <Track {...MODALS_EVENTS.OPEN_SAFE_UTILS}>
          <ExternalLink href="https://safeutils.openzeppelin.com/">Safe Utils</ExternalLink>
        </Track>
        .
      </Typography>
    ),
  },
]

const HardwareWalletStep = [
  InfoSteps[1],
  {
    label: 'Compare with your device',
    description: (
      <Typography>
        If you&apos;re using a hardware wallet with &ldquo;blind signing&rdquo;, please compare what you see on your
        device with the hashes on the right.
      </Typography>
    ),
  },
  InfoSteps[2],
]

export const ConfirmTxDetails = (props: SignOrExecuteProps) => {
  const { safeTx, txOrigin } = useContext(SafeTxContext)
  const [txPreview] = useTxPreview(safeTx?.data)
  const wallet = useWallet()
  const showHashes = wallet ? isHardwareWallet(wallet) || isLedgerLive(wallet) : false
  const steps = showHashes ? HardwareWalletStep : InfoSteps

  if (!safeTx) {
    return null
  }

  return (
    <TxCard>
      <Grid container spacing={2}>
        <Grid size={{ xs: 12, sm: 6 }}>
          <Stack px={1} gap={6}>
            {steps.map(({ label, description }, index) => (
              <Stack key={index} spacing={2} direction="row">
                <StepIcon icon={index + 1} active />
                <Stack spacing={1}>
                  <Typography fontWeight="bold">{label}</Typography>
                  {description}
                </Stack>
              </Stack>
            ))}
          </Stack>
        </Grid>
        <Grid size={{ xs: 12, sm: 6 }}>
          <TxDetails safeTxData={safeTx.data} txData={txPreview?.txData} />
        </Grid>
      </Grid>

      <SignOrExecuteFormV2 origin={txOrigin} isCreation={!props.txId} {...props} />
    </TxCard>
  )
}
</file>

<file path="src/components/tx/ConfirmTxDetails/NameChip.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import { useAddressName } from '@/components/common/NamedAddressInfo'
import { Chip } from '@mui/material'
import type { TransactionData } from '@safe-global/safe-gateway-typescript-sdk'

const NameChip = ({ txData, withBackground }: { txData?: TransactionData; withBackground?: boolean }) => {
  const toAddress = txData?.to.value
  const toInfo = txData?.addressInfoIndex?.[txData?.to.value] || txData?.to
  const toName = toInfo?.name || (toInfo && 'displayName' in toInfo ? String(toInfo.displayName || '') : undefined)
  const toLogo = toInfo?.logoUri
  const contractInfo = useAddressName(toAddress, toName)
  const name = toName || contractInfo?.name
  const logo = toLogo || contractInfo?.logoUri

  return toAddress && (name || logo) ? (
    <Chip
      sx={{
        backgroundColor: contractInfo?.isUnverifiedContract
          ? 'error.background'
          : withBackground
            ? 'Background.main'
            : 'background.paper',
        color: contractInfo?.isUnverifiedContract ? 'error.main' : undefined,
        height: 'unset',
      }}
      label={
        <EthHashInfo address={toAddress} name={name} customAvatar={logo} showAvatar={!!logo} avatarSize={20} onlyName />
      }
    ></Chip>
  ) : null
}

export default NameChip
</file>

<file path="src/components/tx/ConfirmTxDetails/TxDetails.tsx">
import { Fragment, type ReactElement } from 'react'
import { Box, Divider, Stack, Typography } from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { PaperViewToggle } from '../../common/PaperViewToggle'
import EthHashInfo from '@/components/common/EthHashInfo'
import { Operation, type TransactionData } from '@safe-global/safe-gateway-typescript-sdk/dist/types/transactions'
import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import {
  useDomainHash,
  useMessageHash,
  useSafeTxHash,
} from '@/components/transactions/TxDetails/Summary/SafeTxHashDataRow'
import TxDetailsRow from './TxDetailsRow'
import NameChip from './NameChip'

type TxDetailsProps = {
  safeTxData: SafeTransaction['data']
  txData?: TransactionData
  grid?: boolean
}

const ContentWrapper = ({ children }: { children: ReactElement | ReactElement[] }) => (
  <Box sx={{ maxHeight: '550px', minHeight: '447px', overflowY: 'auto', px: 2 }}>{children}</Box>
)

export const TxDetails = ({ safeTxData, txData, grid }: TxDetailsProps) => {
  const safeTxHash = useSafeTxHash({ safeTxData })
  const domainHash = useDomainHash()
  const messageHash = useMessageHash({ safeTxData })
  const operation = Number(safeTxData.operation) as Operation

  const ToWrapper = grid ? Box : Fragment

  return (
    <PaperViewToggle activeView={0} leftAlign={grid}>
      {[
        {
          title: 'Data',
          content: (
            <ContentWrapper>
              <Stack spacing={1} divider={<Divider />}>
                <TxDetailsRow label="Primary type" grid={grid}>
                  SafeTx
                </TxDetailsRow>

                <TxDetailsRow label="To" grid={grid}>
                  <ToWrapper>
                    <NameChip txData={txData} withBackground={grid} />

                    <Typography
                      variant="body2"
                      mt={grid ? 0.75 : 0}
                      width={grid ? undefined : '100%'}
                      sx={{
                        '& *': { whiteSpace: 'normal', wordWrap: 'break-word', alignItems: 'flex-start !important' },
                      }}
                    >
                      <EthHashInfo
                        address={safeTxData.to}
                        avatarSize={20}
                        showPrefix={false}
                        showName={false}
                        shortAddress={false}
                        hasExplorer
                        showAvatar
                        highlight4bytes
                      />
                    </Typography>
                  </ToWrapper>
                </TxDetailsRow>

                <TxDetailsRow label="Value" grid={grid}>
                  {safeTxData.value}
                </TxDetailsRow>

                <TxDetailsRow label="Data" grid={grid}>
                  <Typography variant="body2" width={grid ? '70%' : undefined}>
                    <HexEncodedData hexData={safeTxData.data} limit={66} />
                  </Typography>
                </TxDetailsRow>

                <TxDetailsRow label="Operation" grid={grid}>
                  <Typography variant="body2" display="flex" alignItems="center" gap={0.5}>
                    {safeTxData.operation} ({operation === Operation.CALL ? 'call' : 'delegate call'})
                    {operation === Operation.CALL && <CheckIcon color="success" fontSize="inherit" />}
                  </Typography>
                </TxDetailsRow>

                <TxDetailsRow label="SafeTxGas" grid={grid}>
                  {safeTxData.safeTxGas}
                </TxDetailsRow>

                <TxDetailsRow label="BaseGas" grid={grid}>
                  {safeTxData.baseGas}
                </TxDetailsRow>

                <TxDetailsRow label="GasPrice" grid={grid}>
                  {safeTxData.gasPrice}
                </TxDetailsRow>

                <TxDetailsRow label="GasToken" grid={grid}>
                  <Typography variant="body2">
                    <EthHashInfo
                      address={safeTxData.gasToken}
                      avatarSize={20}
                      showPrefix={false}
                      showName={false}
                      shortAddress
                      hasExplorer
                    />
                  </Typography>
                </TxDetailsRow>

                <TxDetailsRow label="RefundReceiver" grid={grid}>
                  <Typography variant="body2">
                    <EthHashInfo
                      address={safeTxData.refundReceiver}
                      avatarSize={20}
                      showPrefix={false}
                      shortAddress
                      showName={false}
                      hasExplorer
                    />
                  </Typography>
                </TxDetailsRow>

                <TxDetailsRow label="Nonce" grid={grid}>
                  {safeTxData.nonce}
                </TxDetailsRow>
              </Stack>
            </ContentWrapper>
          ),
        },
        {
          title: 'Hashes',
          content: (
            <ContentWrapper>
              <Stack spacing={1} divider={<Divider />}>
                {domainHash && (
                  <TxDetailsRow label="Domain hash" grid={grid}>
                    <Typography variant="body2" width="100%" sx={{ wordWrap: 'break-word' }}>
                      <HexEncodedData hexData={domainHash} limit={66} highlightFirstBytes={false} />
                    </Typography>
                  </TxDetailsRow>
                )}

                {messageHash && (
                  <TxDetailsRow label="Message hash" grid={grid}>
                    <Typography variant="body2" width="100%" sx={{ wordWrap: 'break-word' }}>
                      <HexEncodedData hexData={messageHash} limit={66} highlightFirstBytes={false} />
                    </Typography>
                  </TxDetailsRow>
                )}

                {safeTxHash && (
                  <TxDetailsRow label="safeTxHash" grid={grid}>
                    <Typography variant="body2" width="100%" sx={{ wordWrap: 'break-word' }}>
                      <HexEncodedData hexData={safeTxHash} limit={66} highlightFirstBytes={false} />
                    </Typography>
                  </TxDetailsRow>
                )}
              </Stack>
            </ContentWrapper>
          ),
        },
      ]}
    </PaperViewToggle>
  )
}
</file>

<file path="src/components/tx/ConfirmTxDetails/TxDetailsRow.tsx">
import { Stack, type StackProps, Typography } from '@mui/material'
import type { ReactNode } from 'react'
import isString from 'lodash/isString'
import isNumber from 'lodash/isNumber'
import { gridSx } from '../FieldsGrid'

const TxDetailsRow = ({
  label,
  children,
  grid = false,
}: {
  label: string
  children: ReactNode
  direction?: StackProps['direction']
  grid?: boolean
}) => (
  <Stack
    gap={1}
    direction="row"
    justifyContent={grid ? 'flex-start' : 'space-between'}
    flexWrap="wrap"
    alignItems="center"
  >
    <Typography variant="body2" color={grid ? 'primary.light' : 'text.secondary'} sx={grid ? gridSx : undefined}>
      {label}
    </Typography>

    {isString(children) || isNumber(children) ? <Typography variant="body2">{children}</Typography> : children}
  </Stack>
)

export default TxDetailsRow
</file>

<file path="src/components/tx/ConfirmTxReceipt/index.tsx">
import TxCard from '@/components/tx-flow/common/TxCard'
import { Grid2 as Grid, Stack, StepIcon, Typography } from '@mui/material'
import ExternalLink from '@/components/common/ExternalLink'
import { type PropsWithChildren, useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import useTxPreview from '../confirmation-views/useTxPreview'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'
import useWallet from '@/hooks/wallets/useWallet'
import { isHardwareWallet, isLedgerLive } from '@/utils/wallets'
import { TxFlowStep } from '@/components/tx-flow/TxFlowStep'
import { TxDetails } from '../ConfirmTxDetails/TxDetails'
import { Slot, SlotName } from '@/components/tx-flow/slots'
import { Sign } from '@/components/tx-flow/actions/Sign'

const InfoSteps = [
  {
    label: 'Review what you will sign',
    description: (
      <Typography>
        Signing is an irreversible action so make sure you know what you are signing.{' '}
        <Track {...MODALS_EVENTS.SIGNING_ARTICLE}>
          <ExternalLink href="https://help.safe.global/en/articles/276343-how-to-perform-basic-transactions-checks-on-safe-wallet">
            Read more
          </ExternalLink>
        </Track>
        .
      </Typography>
    ),
  },
  {
    label: 'Compare with your wallet',
    description: (
      <Typography>
        Once you click <b>Sign</b>, the transaction will appear in your signing wallet. Make sure that all the details
        match.
      </Typography>
    ),
  },
  {
    label: 'Verify with external tools',
    description: (
      <Typography>
        You can additionally cross-verify your transaction data in a third-party tool like{' '}
        <Track {...MODALS_EVENTS.OPEN_SAFE_UTILS}>
          <ExternalLink href="https://safeutils.openzeppelin.com/">Safe Utils</ExternalLink>
        </Track>
        .
      </Typography>
    ),
  },
]

const HardwareWalletStep = [
  InfoSteps[1],
  {
    label: 'Compare with your device',
    description: (
      <Typography>
        If you&apos;re using a hardware wallet with &ldquo;blind signing&rdquo;, please compare what you see on your
        device with the hashes on the right.
      </Typography>
    ),
  },
  InfoSteps[2],
]

export const ConfirmTxReceipt = ({ children, onSubmit }: PropsWithChildren<{ onSubmit: () => void }>) => {
  const { safeTx } = useContext(SafeTxContext)
  const [txPreview] = useTxPreview(safeTx?.data)
  const wallet = useWallet()
  const showHashes = wallet ? isHardwareWallet(wallet) || isLedgerLive(wallet) : false
  const steps = showHashes ? HardwareWalletStep : InfoSteps

  if (!safeTx) {
    return false
  }

  return (
    <TxFlowStep title="Review details" fixedNonce>
      <TxCard>
        <Grid container spacing={2}>
          <Grid size={{ xs: 12, sm: 6 }}>
            <Stack px={1} gap={6}>
              {steps.map(({ label, description }, index) => (
                <Stack key={index} spacing={2} direction="row">
                  <StepIcon icon={index + 1} active />
                  <Stack spacing={1}>
                    <Typography fontWeight="bold">{label}</Typography>
                    {description}
                  </Stack>
                </Stack>
              ))}
            </Stack>
          </Grid>
          <Grid size={{ xs: 12, sm: 6 }}>
            <TxDetails safeTxData={safeTx?.data} txData={txPreview?.txData} />
          </Grid>
        </Grid>

        {children}

        <Slot name={SlotName.Submit} onSubmitSuccess={onSubmit}>
          <Sign
            onSubmitSuccess={onSubmit}
            options={[{ id: 'sign', label: 'Sign' }]}
            onChange={() => {}}
            slotId="sign"
          />
        </Slot>
      </TxCard>
    </TxFlowStep>
  )
}
</file>

<file path="src/components/tx/ErrorMessage/index.tsx">
import { type ReactElement, type ReactNode, type SyntheticEvent, useState } from 'react'
import { Link, Typography, SvgIcon, AlertTitle } from '@mui/material'
import classNames from 'classnames'
import WarningIcon from '@/public/images/notifications/warning.svg'
import InfoIcon from '@/public/images/notifications/info.svg'
import css from './styles.module.css'

const ETHERS_PREFIX = 'could not coalesce error'

const ErrorMessage = ({
  children,
  error,
  className,
  level = 'error',
  title,
}: {
  children: ReactNode
  error?: Error & { reason?: string }
  className?: string
  level?: 'error' | 'warning' | 'info'
  title?: string
}): ReactElement => {
  const [showDetails, setShowDetails] = useState<boolean>(false)

  const onDetailsToggle = (e: SyntheticEvent) => {
    e.preventDefault()
    setShowDetails((prev) => !prev)
  }

  return (
    <div data-testid="error-message" className={classNames(css.container, css[level], className, 'errorMessage')}>
      <div className={css.message}>
        <SvgIcon
          component={level === 'info' ? InfoIcon : WarningIcon}
          inheritViewBox
          fontSize="medium"
          sx={{ color: ({ palette }) => `${palette[level].main} !important` }}
        />

        <div>
          <Typography variant="body2" component="span">
            {title && (
              <AlertTitle>
                <Typography
                  variant="subtitle1"
                  sx={{
                    fontWeight: 700,
                  }}
                >
                  {title}
                </Typography>
              </AlertTitle>
            )}
            {children}

            {error && (
              <Link
                component="button"
                onClick={onDetailsToggle}
                sx={{
                  display: 'block',
                }}
              >
                Details
              </Link>
            )}
          </Typography>

          {error && showDetails && (
            <Typography variant="body2" className={css.details}>
              {(error.reason || error.message).replace(ETHERS_PREFIX, '').trim().slice(0, 500)}
            </Typography>
          )}
        </div>
      </div>
    </div>
  )
}

export default ErrorMessage
</file>

<file path="src/components/tx/ErrorMessage/styles.module.css">
.container {
  padding: var(--space-2);
  margin: var(--space-2) 0;
  border-radius: 4px;
}

.container.error {
  background-color: var(--color-error-background);
  color: var(--color-error-dark);
}

.container.warning {
  background-color: var(--color-warning-background);
}

.container.info {
  background-color: var(--color-info-background);
  color: var(--color-primary-main);
}

.container.info svg {
  color: var(--color-text-secondary);
}

.message {
  display: flex;
  align-items: flex-start;
  gap: var(--space-1);
}

.message button {
  vertical-align: baseline;
  text-decoration: underline;
}

.details {
  margin-top: var(--space-1);
  color: var(--color-primary-light);
  word-break: break-word;
}
</file>

<file path="src/components/tx/ExecuteCheckbox/index.tsx">
import type { ChangeEvent, ReactElement } from 'react'
import { FormControlLabel, RadioGroup, Radio, Typography } from '@mui/material'
import { trackEvent, MODALS_EVENTS } from '@/services/analytics'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setTransactionExecution } from '@/store/settingsSlice'

import css from './styles.module.css'

const ExecuteCheckbox = ({ onChange }: { onChange: (checked: boolean) => void }): ReactElement => {
  const settings = useAppSelector(selectSettings)
  const dispatch = useAppDispatch()

  const handleChange = (_: ChangeEvent<HTMLInputElement>, value: string) => {
    const checked = value === 'true'
    trackEvent({ ...MODALS_EVENTS.TOGGLE_EXECUTE_TX, label: checked })
    dispatch(setTransactionExecution(checked))
    onChange(checked)
  }

  return (
    <>
      <Typography>Would you like to execute the transaction immediately?</Typography>

      <RadioGroup row value={String(settings.transactionExecution)} onChange={handleChange} className={css.group}>
        <FormControlLabel
          value="true"
          label={
            <>
              Yes, <b>execute</b>
            </>
          }
          control={<Radio />}
          className={css.radio}
          data-testid="execute-checkbox"
        />
        <FormControlLabel
          value="false"
          label={<>No, later</>}
          control={<Radio />}
          className={css.radio}
          data-testid="sign-checkbox"
        />
      </RadioGroup>
    </>
  )
}

export default ExecuteCheckbox
</file>

<file path="src/components/tx/ExecuteCheckbox/styles.module.css">
.group {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-2);
}

.radio {
  margin: 0;
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
  padding: 6px 3px;
}

.select {
  margin-top: var(--space-2);
}

.select :global .MuiFormLabel-root {
  color: var(--color-text-primary);
  transform: translate(22px, 22px) scale(1);
}

.select :global .MuiSelect-select {
  padding: 22px;
  text-align: right;
  font-weight: 700;
  padding-right: 52px !important;
}

.select :global .MuiInputBase-root fieldset {
  border-color: var(--color-border-light) !important;
  border-width: 1px !important;
}

.select :global .MuiSvgIcon-root {
  right: 22px;
}
</file>

<file path="src/components/tx/ExecutionMethodSelector/index.tsx">
import { Box, FormControl, FormControlLabel, Radio, RadioGroup, Typography } from '@mui/material'
import type { Dispatch, SetStateAction, ReactElement, ChangeEvent } from 'react'

import useWallet from '@/hooks/wallets/useWallet'
import WalletIcon from '@/components/common/WalletIcon'
import SponsoredBy from '../SponsoredBy'
import RemainingRelays from '../RemainingRelays'

import css from './styles.module.css'
import BalanceInfo from '@/components/tx/BalanceInfo'
import madProps from '@/utils/mad-props'
import { useCurrentChain } from '@/hooks/useChains'
import type { ChainInfo, RelayCountResponse } from '@safe-global/safe-gateway-typescript-sdk'
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'

export const enum ExecutionMethod {
  RELAY = 'RELAY',
  WALLET = 'WALLET',
}

const _ExecutionMethodSelector = ({
  wallet,
  chain,
  executionMethod,
  setExecutionMethod,
  relays,
  noLabel,
  tooltip,
}: {
  wallet: ConnectedWallet | null
  chain?: ChainInfo
  executionMethod: ExecutionMethod
  setExecutionMethod: Dispatch<SetStateAction<ExecutionMethod>>
  relays?: RelayCountResponse
  noLabel?: boolean
  tooltip?: string
}): ReactElement | null => {
  const shouldRelay = executionMethod === ExecutionMethod.RELAY

  const onChooseExecutionMethod = (_: ChangeEvent<HTMLInputElement>, newExecutionMethod: string) => {
    setExecutionMethod(newExecutionMethod as ExecutionMethod)
  }

  return (
    <Box className={css.container} sx={{ borderRadius: ({ shape }) => `${shape.borderRadius}px` }}>
      <div className={css.method}>
        <FormControl sx={{ display: 'flex' }}>
          {!noLabel ? (
            <Typography variant="body2" className={css.label}>
              Who will pay gas fees:
            </Typography>
          ) : null}

          <RadioGroup row value={executionMethod} onChange={onChooseExecutionMethod}>
            <FormControlLabel
              data-testid="relay-execution-method"
              sx={{ flex: 1 }}
              value={ExecutionMethod.RELAY}
              label={
                <Typography className={css.radioLabel} whiteSpace="nowrap">
                  Sponsored by
                  <SponsoredBy chainId={chain?.chainId ?? ''} />
                </Typography>
              }
              control={<Radio />}
            />

            <FormControlLabel
              data-testid="connected-wallet-execution-method"
              sx={{ flex: 1 }}
              value={ExecutionMethod.WALLET}
              label={
                <Typography className={css.radioLabel}>
                  <WalletIcon provider={wallet?.label || ''} width={20} height={20} icon={wallet?.icon} /> Connected
                  wallet
                </Typography>
              }
              control={<Radio />}
            />
          </RadioGroup>
        </FormControl>
      </div>

      {shouldRelay && relays ? <RemainingRelays relays={relays} tooltip={tooltip} /> : wallet ? <BalanceInfo /> : null}
    </Box>
  )
}

export const ExecutionMethodSelector = madProps(_ExecutionMethodSelector, {
  wallet: useWallet,
  chain: useCurrentChain,
})
</file>

<file path="src/components/tx/ExecutionMethodSelector/styles.module.css">
.container {
  border: 1px solid var(--color-border-light);
}

.method {
  padding: var(--space-2) var(--space-2) var(--space-1) var(--space-2);
}

.label {
  color: var(--color-text-secondary);
}

.radioLabel {
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: calc(var(--space-1) / 2);
}
</file>

<file path="src/components/tx/FieldsGrid/index.tsx">
import { type ReactNode } from 'react'
import { Grid, Typography } from '@mui/material'

export const gridSx = {
  width: { xl: '25%', lg: '170px', xs: 'auto' },
  minWidth: '100px',
  flexWrap: { xl: 'nowrap' },
}

const FieldsGrid = ({ title, children }: { title: string | ReactNode; children: ReactNode }) => {
  return (
    <Grid
      container
      sx={[
        {
          gap: 1,
          flexWrap: gridSx.flexWrap,
        },
      ]}
    >
      <Grid item data-testid="tx-row-title" style={{ wordBreak: 'break-word' }} sx={gridSx}>
        <Typography color="primary.light" variant="body2" component="span">
          {title}
        </Typography>
      </Grid>
      <Grid item xs data-testid="tx-data-row">
        {children}
      </Grid>
    </Grid>
  )
}

export default FieldsGrid
</file>

<file path="src/components/tx/GasParams/index.tsx">
import { getTotalFee } from '@/hooks/useGasPrice'
import type { ReactElement, SyntheticEvent } from 'react'
import { Accordion, AccordionDetails, AccordionSummary, Skeleton, Typography, Link, Grid, SvgIcon } from '@mui/material'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import WarningIcon from '@/public/images/notifications/warning.svg'
import { useCurrentChain } from '@/hooks/useChains'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { type AdvancedParameters } from '../AdvancedParams/types'
import { trackEvent, MODALS_EVENTS } from '@/services/analytics'
import classnames from 'classnames'
import css from './styles.module.css'
import accordionCss from '@/styles/accordion.module.css'
import madProps from '@/utils/mad-props'

const GasDetail = ({ name, value, isLoading }: { name: string; value: string; isLoading: boolean }): ReactElement => {
  const valueSkeleton = <Skeleton variant="text" sx={{ minWidth: '5em' }} />
  return (
    <Grid container>
      <Grid item xs>
        {name}
      </Grid>
      <Grid item>{value || (isLoading ? valueSkeleton : '-')}</Grid>
    </Grid>
  )
}

type GasParamsProps = {
  params: AdvancedParameters
  isExecution: boolean
  isEIP1559?: boolean
  onEdit?: () => void
  gasLimitError?: Error
  willRelay?: boolean
}

export const _GasParams = ({
  params,
  isExecution,
  isEIP1559,
  onEdit,
  gasLimitError,
  willRelay,
  chain,
}: GasParamsProps & { chain?: ChainInfo }): ReactElement => {
  const { nonce, userNonce, safeTxGas, gasLimit, maxFeePerGas, maxPriorityFeePerGas } = params

  const onChangeExpand = (_: SyntheticEvent, expanded: boolean) => {
    trackEvent({ ...MODALS_EVENTS.ESTIMATION, label: expanded ? 'Open' : 'Close' })
  }

  const isLoading = !gasLimit || !maxFeePerGas
  const isError = gasLimitError && !gasLimit

  // Total gas cost
  const totalFee = !isLoading
    ? formatVisualAmount(getTotalFee(maxFeePerGas, gasLimit), chain?.nativeCurrency.decimals)
    : '> 0.001'

  // Individual gas params
  const gasLimitString = gasLimit?.toString() || ''
  const maxFeePerGasGwei = maxFeePerGas ? formatVisualAmount(maxFeePerGas) : ''
  const maxPrioGasGwei = maxPriorityFeePerGas ? formatVisualAmount(maxPriorityFeePerGas) : ''

  const onEditClick = (e: SyntheticEvent) => {
    e.preventDefault()
    onEdit?.()
  }

  const EditComponent = (
    <>
      {gasLimitError || !isExecution || (isExecution && !isLoading) ? (
        <Link
          component="button"
          onClick={onEditClick}
          sx={{
            fontSize: 'medium',
            mt: 2,
          }}
        >
          Edit
        </Link>
      ) : (
        <Skeleton variant="text" sx={{ display: 'inline-block', minWidth: '2em', mt: 2 }} />
      )}
    </>
  )

  return (
    <div className={classnames({ [css.error]: gasLimitError })}>
      <Accordion
        elevation={0}
        onChange={onChangeExpand}
        className={classnames({ [css.withExecutionMethod]: isExecution })}
      >
        <AccordionSummary expandIcon={<ExpandMoreIcon />} className={accordionCss.accordion}>
          {isExecution ? (
            <Typography
              sx={{
                display: 'flex',
                alignItems: 'center',
                width: 1,
              }}
            >
              <span style={{ flex: '1' }}>Estimated fee </span>
              {gasLimitError ? (
                <>
                  <SvgIcon
                    component={WarningIcon}
                    inheritViewBox
                    fontSize="small"
                    sx={{ color: 'var(--color-error-main)', mr: 'var(--space-1)' }}
                  />
                  <span style={{ fontWeight: 'normal' }}>Cannot Estimate</span>
                </>
              ) : isLoading ? (
                <Skeleton variant="text" sx={{ display: 'inline-block', minWidth: '7em' }} />
              ) : (
                <span>{willRelay ? 'Free' : `${totalFee} ${chain?.nativeCurrency.symbol}`}</span>
              )}
            </Typography>
          ) : (
            <Typography>
              Signing the transaction with nonce&nbsp;
              {nonce !== undefined ? (
                nonce
              ) : (
                <Skeleton variant="text" sx={{ display: 'inline-block', minWidth: '2em' }} />
              )}
            </Typography>
          )}
        </AccordionSummary>

        <AccordionDetails>
          {nonce !== undefined && (
            <GasDetail isLoading={false} name="Safe Account transaction nonce" value={nonce.toString()} />
          )}

          {safeTxGas !== undefined && <GasDetail isLoading={false} name="safeTxGas" value={safeTxGas.toString()} />}

          {isExecution && (
            <>
              {userNonce !== undefined && (
                <GasDetail isLoading={false} name="Wallet nonce" value={userNonce.toString()} />
              )}

              <GasDetail isLoading={isLoading} name="Gas limit" value={isError ? 'Cannot estimate' : gasLimitString} />

              {isEIP1559 ? (
                <>
                  <GasDetail isLoading={isLoading} name="Max priority fee (Gwei)" value={maxPrioGasGwei} />
                  <GasDetail isLoading={isLoading} name="Max fee (Gwei)" value={maxFeePerGasGwei} />
                </>
              ) : (
                <GasDetail isLoading={isLoading} name="Gas price (Gwei)" value={maxFeePerGasGwei} />
              )}
            </>
          )}

          {onEdit && EditComponent}
        </AccordionDetails>
      </Accordion>
    </div>
  )
}

const GasParams = madProps(_GasParams, {
  chain: useCurrentChain,
})

export default GasParams
</file>

<file path="src/components/tx/GasParams/styles.module.css">
.withExecutionMethod {
  border-bottom-left-radius: 0px;
  border-bottom-right-radius: 0px;
}

.error :global .MuiAccordion-root.Mui-expanded {
  border-color: var(--color-error-light);
}

.error :global .MuiAccordionSummary-root.Mui-expanded {
  background-color: var(--color-error-background);
  border-bottom: 1px solid var(--color-error-light);
}

.error :global .MuiAccordionSummary-expandIconWrapper {
  margin-left: var(--space-1);
}
</file>

<file path="src/components/tx/RemainingRelays/index.tsx">
import { SvgIcon, Tooltip, Typography } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import { MAX_DAY_RELAYS } from '@/hooks/useRemainingRelays'
import css from '../BalanceInfo/styles.module.css'
import type { RelayCountResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { maybePlural } from '@safe-global/utils/utils/formatters'

const RemainingRelays = ({ relays, tooltip }: { relays?: RelayCountResponse; tooltip?: string }) => {
  if (!tooltip) {
    const limit = relays?.limit ?? MAX_DAY_RELAYS
    tooltip = `${limit} transaction${maybePlural(limit)} per day for free`
  }

  return (
    <div className={css.container}>
      <Typography variant="body2" color="primary.light" display="flex" alignItems="center" gap={0.5}>
        <b>{relays?.remaining ?? MAX_DAY_RELAYS}</b> free transactions left today
        <Tooltip title={tooltip} placement="top" arrow>
          <span style={{ lineHeight: 0 }}>
            <SvgIcon component={InfoIcon} inheritViewBox color="info" fontSize="small" sx={{ color: '#B2B5B2' }} />
          </span>
        </Tooltip>
      </Typography>
    </div>
  )
}

export default RemainingRelays
</file>

<file path="src/components/tx/ReviewTransaction/index.tsx">
import { useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import ReviewTransactionSkeleton from './ReviewTransactionSkeleton'
import useTxDetails from '@/hooks/useTxDetails'
import useTxPreview from '../confirmation-views/useTxPreview'
import type { ReviewTransactionContentProps } from './ReviewTransactionContent'
import ReviewTransactionContent from './ReviewTransactionContent'

const ReviewTransaction = (props: ReviewTransactionContentProps) => {
  const { safeTx, safeTxError } = useContext(SafeTxContext)
  const [txDetails, , txDetailsLoading] = useTxDetails(props.txId)
  const [txPreview, , txPreviewLoading] = useTxPreview(safeTx?.data, undefined, props.txId)

  if ((!safeTx && !safeTxError) || txDetailsLoading || txPreviewLoading) {
    return <ReviewTransactionSkeleton />
  }

  return (
    <ReviewTransactionContent
      {...props}
      isCreation={!props.txId}
      txId={props.txId}
      txDetails={txDetails}
      txPreview={txPreview}
    >
      {props.children}
    </ReviewTransactionContent>
  )
}

export default ReviewTransaction
</file>

<file path="src/components/tx/ReviewTransaction/ReviewTransactionContent.tsx">
import { useIsWalletProposer } from '@/hooks/useProposers'
import useSafeInfo from '@/hooks/useSafeInfo'
import type { SyntheticEvent } from 'react'
import { type ReactElement, type ReactNode, useState, useContext, useCallback } from 'react'
import madProps from '@/utils/mad-props'
import ExecuteCheckbox from '../ExecuteCheckbox'
import { useImmediatelyExecutable, useValidateNonce, useTxActions } from '../SignOrExecuteForm/hooks'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import ErrorMessage from '../ErrorMessage'
import TxCard, { TxCardActions } from '@/components/tx-flow/common/TxCard'
import ConfirmationTitle, { ConfirmationTitleTypes } from '@/components/tx/SignOrExecuteForm/ConfirmationTitle'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'
import { ErrorBoundary } from '@sentry/react'
import ApprovalEditor from '../ApprovalEditor'
import { isDelegateCall } from '@/services/tx/tx-sender/sdk'
import {
  findAllowingRole,
  findMostLikelyRole,
  useRoles,
} from '@/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/hooks'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { BlockaidBalanceChanges } from '../security/blockaid/BlockaidBalanceChange'
import { Blockaid } from '../security/blockaid'
import { useApprovalInfos } from '../ApprovalEditor/hooks/useApprovalInfos'
import type { TransactionDetails, TransactionPreview } from '@safe-global/safe-gateway-typescript-sdk'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import ConfirmationView from '../confirmation-views'
import { TxNoteForm, encodeTxNote, trackAddNote } from '@/features/tx-notes'
import { SignerForm } from '@/components/tx-flow/features/SignerSelect/SignerForm'
import UnknownContractError from '../SignOrExecuteForm/UnknownContractError'
import TxChecks from '@/components/tx-flow/features/TxChecks/TxChecks'
import { Button, CircularProgress } from '@mui/material'
import BatchButton from '@/components/tx-flow/actions/Batching/BatchButton'
import { TxModalContext } from '@/components/tx-flow'
import CheckWallet from '@/components/common/CheckWallet'

export type ReviewTransactionContentProps = {
  txId?: string
  onSubmit?: () => void
  children?: ReactNode
  isExecutable?: boolean
  isRejection?: boolean
  isBatch?: boolean
  isBatchable?: boolean
  onlyExecute?: boolean
  disableSubmit?: boolean
  origin?: string
}

export const ReviewTransactionContent = ({
  safeTx,
  safeTxError,
  onSubmit,
  isCreation,
  isBatch,
  txActions,
  disableSubmit,
  isOwner,
  ...props
}: ReviewTransactionContentProps & {
  isOwner: ReturnType<typeof useIsSafeOwner>
  txActions: ReturnType<typeof useTxActions>
  safeTx: ReturnType<typeof useSafeTx>
  safeTxError: ReturnType<typeof useSafeTxError>
  isCreation?: boolean
  txDetails?: TransactionDetails
  txPreview?: TransactionPreview
}): ReactElement => {
  const [customOrigin, setCustomOrigin] = useState<string | undefined>(props.origin)
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const { transactionExecution } = useAppSelector(selectSettings)
  const [shouldExecute, setShouldExecute] = useState<boolean>(transactionExecution)
  const isNewExecutableTx = useImmediatelyExecutable() && isCreation
  const isCorrectNonce = useValidateNonce(safeTx)
  const isBatchable = props.isBatchable !== false && safeTx && !isDelegateCall(safeTx)
  const { setTxFlow } = useContext(TxModalContext)
  const { setTxOrigin } = useContext(SafeTxContext)

  const { addToBatch } = txActions

  const [readableApprovals] = useApprovalInfos({ safeTransaction: safeTx })
  const isApproval = readableApprovals && readableApprovals.length > 0
  const { safe } = useSafeInfo()
  const isSafeOwner = useIsSafeOwner()
  const isProposer = useIsWalletProposer()
  const isProposing = isProposer && !isSafeOwner && isCreation
  const isCounterfactualSafe = !safe.deployed

  // Check if a Zodiac Roles mod is enabled and if the user is a member of any role that allows the transaction
  const roles = useRoles(
    !isCounterfactualSafe && isCreation && !(isNewExecutableTx && isSafeOwner) ? safeTx : undefined,
  )
  const allowingRole = findAllowingRole(roles)
  const mostLikelyRole = findMostLikelyRole(roles)
  const canExecuteThroughRole = !!allowingRole || (!!mostLikelyRole && !isSafeOwner)
  const preferThroughRole = canExecuteThroughRole && !isSafeOwner // execute through role if a non-owner role member wallet is connected

  // If checkbox is checked and the transaction is executable, execute it, otherwise sign it
  const canExecute = isCorrectNonce && (props.isExecutable || isNewExecutableTx)
  const willExecute = (props.onlyExecute || shouldExecute) && canExecute && !preferThroughRole
  const willExecuteThroughRole =
    (props.onlyExecute || shouldExecute) && canExecuteThroughRole && (!canExecute || preferThroughRole)

  const onContinueClick = useCallback(
    async (e: SyntheticEvent) => {
      e.preventDefault()

      if (customOrigin !== props.origin) {
        trackAddNote()
      }

      setTxOrigin(customOrigin)
      onSubmit?.()
    },
    [onSubmit, customOrigin, props.origin, setTxOrigin],
  )

  const onNoteChange = useCallback(
    (note: string) => {
      setCustomOrigin(encodeTxNote(note, props.origin))
    },
    [setCustomOrigin, props.origin],
  )

  const onBatchClick = async (e: SyntheticEvent) => {
    e.preventDefault()

    if (!safeTx) return

    setIsSubmittable(false)

    await addToBatch(safeTx, customOrigin)

    setIsSubmittable(true)

    setTxFlow(undefined)
  }

  const submitDisabled = !safeTx || !isSubmittable || disableSubmit

  const showBatchButton =
    isOwner &&
    isCreation &&
    !isBatch &&
    !isCounterfactualSafe &&
    !willExecute &&
    !willExecuteThroughRole &&
    !isProposing

  return (
    <>
      <TxCard>
        {props.children}

        <ConfirmationView
          isCreation={isCreation}
          txDetails={props.txDetails}
          txPreview={props.txPreview}
          safeTx={safeTx}
          isBatch={isBatch}
          isApproval={isApproval}
        >
          {!props.isRejection && (
            <ErrorBoundary fallback={<div>Error parsing data</div>}>
              {isApproval && <ApprovalEditor safeTransaction={safeTx} />}
            </ErrorBoundary>
          )}
        </ConfirmationView>

        {!isCounterfactualSafe && !props.isRejection && <BlockaidBalanceChanges />}
      </TxCard>

      {!isCounterfactualSafe && !props.isRejection && safeTx && <TxChecks transaction={safeTx} />}

      <TxNoteForm isCreation={isCreation ?? false} onChange={onNoteChange} txDetails={props.txDetails} />

      <SignerForm willExecute={willExecute} />

      <TxCard>
        <ConfirmationTitle
          variant={
            isProposing
              ? ConfirmationTitleTypes.propose
              : willExecute
                ? ConfirmationTitleTypes.execute
                : ConfirmationTitleTypes.sign
          }
          isCreation={isCreation}
        />

        {safeTxError && (
          <ErrorMessage error={safeTxError}>
            This transaction will most likely fail. To save gas costs, avoid confirming the transaction.
          </ErrorMessage>
        )}

        {(canExecute || canExecuteThroughRole) && !props.onlyExecute && !isCounterfactualSafe && !isProposing && (
          <ExecuteCheckbox onChange={setShouldExecute} />
        )}

        <NetworkWarning />

        <UnknownContractError txData={props.txDetails?.txData ?? props.txPreview?.txData} />

        <Blockaid />

        <TxCardActions>
          {/* Batch button */}
          {showBatchButton && (
            <BatchButton
              onClick={onBatchClick}
              disabled={submitDisabled || !isBatchable}
              tooltip={!isBatchable ? `Cannot batch this type of transaction` : undefined}
            />
          )}

          {/* Continue button */}
          <CheckWallet allowNonOwner={props.onlyExecute} checkNetwork={!submitDisabled}>
            {(isOk) => (
              <Button
                data-testid="continue-sign-btn"
                variant="contained"
                type="submit"
                onClick={onContinueClick}
                disabled={!isOk || submitDisabled}
                sx={{ minWidth: '82px', order: '1', width: ['100%', '100%', '100%', 'auto'] }}
              >
                {!isSubmittable ? <CircularProgress size={20} /> : 'Continue'}
              </Button>
            )}
          </CheckWallet>
        </TxCardActions>
      </TxCard>
    </>
  )
}

const useSafeTx = () => useContext(SafeTxContext).safeTx
const useSafeTxError = () => useContext(SafeTxContext).safeTxError

export default madProps(ReviewTransactionContent, {
  isOwner: useIsSafeOwner,
  safeTx: useSafeTx,
  safeTxError: useSafeTxError,
  txActions: useTxActions,
})
</file>

<file path="src/components/tx/ReviewTransaction/ReviewTransactionSkeleton.tsx">
import LoadingSpinner, { SpinnerStatus } from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner'
import TxCard from '@/components/tx-flow/common/TxCard'
import { Box } from '@mui/material'

const ReviewTransactionSkeleton = () => (
  <TxCard>
    <Box minHeight="38svh" display="flex" alignItems="center" justifyContent="center" mb={5}>
      <LoadingSpinner status={SpinnerStatus.PROCESSING} />
    </Box>
  </TxCard>
)

export default ReviewTransactionSkeleton
</file>

<file path="src/components/tx/ReviewTransactionV2/index.tsx">
import { useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import ReviewTransactionSkeleton from './ReviewTransactionSkeleton'
import useTxPreview from '../confirmation-views/useTxPreview'
import type { ReviewTransactionContentProps } from './ReviewTransactionContent'
import ReviewTransactionContent from './ReviewTransactionContent'
import { TxFlowStep } from '@/components/tx-flow/TxFlowStep'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'

const ReviewTransaction = (props: ReviewTransactionContentProps) => {
  const { safeTx, safeTxError } = useContext(SafeTxContext)
  const { txId, txDetails, txDetailsLoading } = useContext(TxFlowContext)
  const [txPreview, , txPreviewLoading] = useTxPreview(safeTx?.data, undefined, txId)

  if ((!safeTx && !safeTxError) || txDetailsLoading || txPreviewLoading) {
    return <ReviewTransactionSkeleton />
  }

  return (
    <TxFlowStep title="Confirm transaction">
      <ReviewTransactionContent {...props} txDetails={txDetails} txPreview={txPreview}>
        {props.children}
      </ReviewTransactionContent>
    </TxFlowStep>
  )
}

export default ReviewTransaction
</file>

<file path="src/components/tx/ReviewTransactionV2/ReviewTransactionContent.tsx">
import type { PropsWithChildren, ReactElement } from 'react'
import { useContext } from 'react'
import madProps from '@/utils/mad-props'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import ErrorMessage from '../ErrorMessage'
import TxCard from '@/components/tx-flow/common/TxCard'
import ConfirmationTitle, { ConfirmationTitleTypes } from '@/components/tx/SignOrExecuteForm/ConfirmationTitle'
import { ErrorBoundary } from '@sentry/react'
import ApprovalEditor from '../ApprovalEditor'
import { BlockaidBalanceChanges } from '../security/blockaid/BlockaidBalanceChange'
import { Blockaid } from '../security/blockaid'
import { useApprovalInfos } from '../ApprovalEditor/hooks/useApprovalInfos'
import type { TransactionDetails, TransactionPreview } from '@safe-global/safe-gateway-typescript-sdk'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import ConfirmationView from '../confirmation-views'
import UnknownContractError from '../SignOrExecuteForm/UnknownContractError'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { Slot, SlotName } from '@/components/tx-flow/slots'
import { Sign } from '@/components/tx-flow/actions/Sign'
import type { SubmitCallback } from '@/components/tx-flow/TxFlow'

export type ReviewTransactionContentProps = PropsWithChildren<{
  onSubmit: SubmitCallback
  isBatch?: boolean
}>

export const ReviewTransactionContent = ({
  safeTx,
  safeTxError,
  onSubmit,
  isBatch,
  children,
  txDetails,
  txPreview,
}: ReviewTransactionContentProps & {
  safeTx: ReturnType<typeof useSafeTx>
  safeTxError: ReturnType<typeof useSafeTxError>
  isCreation?: boolean
  txDetails?: TransactionDetails
  txPreview?: TransactionPreview
}): ReactElement => {
  const { willExecute, isCreation, isProposing, isRejection, onNext } = useContext(TxFlowContext)

  const [readableApprovals] = useApprovalInfos({ safeTransaction: safeTx })
  const isApproval = readableApprovals && readableApprovals.length > 0
  const isCounterfactualSafe = useIsCounterfactualSafe()

  return (
    <>
      <TxCard>
        {children}

        <ConfirmationView
          isCreation={isCreation}
          txDetails={txDetails}
          txPreview={txPreview}
          safeTx={safeTx}
          isBatch={isBatch}
          isApproval={isApproval}
        >
          {!isRejection && (
            <ErrorBoundary fallback={<div>Error parsing data</div>}>
              {isApproval && <ApprovalEditor safeTransaction={safeTx} />}
            </ErrorBoundary>
          )}
        </ConfirmationView>

        {!isCounterfactualSafe && !isRejection && <BlockaidBalanceChanges />}
      </TxCard>

      <Slot name={SlotName.Feature} />

      <TxCard>
        <ConfirmationTitle
          variant={
            isProposing
              ? ConfirmationTitleTypes.propose
              : willExecute
                ? ConfirmationTitleTypes.execute
                : ConfirmationTitleTypes.sign
          }
          isCreation={isCreation}
        />

        {safeTxError && (
          <ErrorMessage error={safeTxError}>
            This transaction will most likely fail. To save gas costs, avoid confirming the transaction.
          </ErrorMessage>
        )}

        <Slot name={SlotName.Footer} />

        <NetworkWarning />

        <UnknownContractError txData={txDetails?.txData ?? txPreview?.txData} />

        <Blockaid />

        <Slot name={SlotName.Submit} onSubmit={onNext} onSubmitSuccess={onSubmit}>
          <Sign
            onSubmit={onNext}
            onSubmitSuccess={onSubmit}
            options={[{ id: 'sign', label: 'Sign' }]}
            onChange={() => {}}
            slotId="sign"
          />
        </Slot>
      </TxCard>
    </>
  )
}

const useSafeTx = () => useContext(SafeTxContext).safeTx
const useSafeTxError = () => useContext(SafeTxContext).safeTxError

export default madProps(ReviewTransactionContent, {
  safeTx: useSafeTx,
  safeTxError: useSafeTxError,
})
</file>

<file path="src/components/tx/ReviewTransactionV2/ReviewTransactionSkeleton.tsx">
import LoadingSpinner, { SpinnerStatus } from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner'
import TxCard from '@/components/tx-flow/common/TxCard'
import { Box } from '@mui/material'

const ReviewTransactionSkeleton = () => (
  <TxCard>
    <Box minHeight="38svh" display="flex" alignItems="center" justifyContent="center" mb={5}>
      <LoadingSpinner status={SpinnerStatus.PROCESSING} />
    </Box>
  </TxCard>
)

export default ReviewTransactionSkeleton
</file>

<file path="src/components/tx/security/blockaid/BlockaidBalanceChange.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import TokenIcon from '@/components/common/TokenIcon'
import useBalances from '@/hooks/useBalances'
import useChainId from '@/hooks/useChainId'
import { useHasFeature } from '@/hooks/useChains'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { Box, Chip, CircularProgress, Grid, SvgIcon, Tooltip, Typography } from '@mui/material'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import { ErrorBoundary } from '@sentry/react'
import { useContext } from 'react'
import { TxSecurityContext } from '../shared/TxSecurityContext'
import ArrowOutwardIcon from '@/public/images/transactions/outgoing.svg'
import ArrowDownwardIcon from '@/public/images/transactions/incoming.svg'
import InfoIcon from '@/public/images/notifications/info.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { REDEFINE_ARTICLE } from '@/config/constants'

import css from './styles.module.css'
import type {
  AssetDiff,
  Erc1155Diff,
  Erc1155TokenDetails,
  Erc20Diff,
  Erc721Diff,
  Erc721TokenDetails,
  GeneralAssetDiff,
  NativeDiff,
} from '@safe-global/utils/services/security/modules/BlockaidModule/types'
import { formatAmount } from '@safe-global/utils/utils/formatNumber'
import { FEATURES } from '@safe-global/utils/utils/chains'

const FungibleBalanceChange = ({ change, asset }: { asset: AssetDiff['asset']; change: Erc20Diff | NativeDiff }) => {
  const { balances } = useBalances()
  const logoUri =
    asset.logo_url ??
    balances.items.find((item) => {
      return asset.type === 'NATIVE'
        ? item.tokenInfo.type === TokenType.NATIVE_TOKEN
        : sameAddress(item.tokenInfo.address, asset.address)
    })?.tokenInfo.logoUri

  return (
    <>
      <Typography variant="body2" mx={1}>
        {change.value ? formatAmount(change.value) : 'unknown'}
      </Typography>
      <TokenIcon size={16} logoUri={logoUri} tokenSymbol={asset.symbol} />
      <Typography variant="body2" fontWeight={700} display="inline" ml={0.5}>
        {asset.symbol}
      </Typography>
      <span style={{ margin: 'auto' }} />
      <Chip className={css.categoryChip} label={asset.type} />
    </>
  )
}

const NFTBalanceChange = ({
  change,
  asset,
}: {
  asset: Erc721TokenDetails | Erc1155TokenDetails
  change: Erc721Diff | Erc1155Diff
}) => {
  const chainId = useChainId()

  return (
    <>
      {asset.symbol ? (
        <Typography variant="body2" fontWeight={700} display="inline" ml={1}>
          {asset.symbol}
        </Typography>
      ) : (
        <Typography variant="body2" ml={1}>
          <EthHashInfo
            address={asset.address}
            chainId={chainId}
            showCopyButton={false}
            showPrefix={false}
            hasExplorer
            customAvatar={asset.logo_url}
            showAvatar={!!asset.logo_url}
            avatarSize={16}
            shortAddress
          />
        </Typography>
      )}
      <Typography variant="subtitle2" className={css.nftId} ml={1}>
        #{Number(change.token_id)}
      </Typography>
      <span style={{ margin: 'auto' }} />
      <Chip className={css.categoryChip} label="NFT" />
    </>
  )
}

const BalanceChange = ({
  asset,
  positive = false,
  diff,
}: {
  asset: NonNullable<AssetDiff['asset']>
  positive?: boolean
  diff: GeneralAssetDiff
}) => {
  return (
    <Grid item xs={12} md={12}>
      <Box className={css.balanceChange}>
        {positive ? <ArrowDownwardIcon /> : <ArrowOutwardIcon />}
        {asset.type === 'ERC721' || asset.type === 'ERC1155' ? (
          <NFTBalanceChange asset={asset} change={diff as Erc721Diff | Erc1155Diff} />
        ) : (
          <FungibleBalanceChange asset={asset} change={diff as NativeDiff | Erc20Diff} />
        )}
      </Box>
    </Grid>
  )
}
const BalanceChanges = () => {
  const { blockaidResponse } = useContext(TxSecurityContext)
  const { isLoading, balanceChange, error } = blockaidResponse ?? {}

  const totalBalanceChanges = balanceChange
    ? balanceChange.reduce((prev, current) => prev + current.in.length + current.out.length, 0)
    : 0

  if (isLoading) {
    return (
      <div className={css.loader}>
        <CircularProgress
          size={22}
          sx={{
            color: ({ palette }) => palette.text.secondary,
          }}
        />
        <Typography variant="body2" color="text.secondary">
          Calculating...
        </Typography>
      </div>
    )
  }
  if (error) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ justifySelf: 'flex-end' }}>
        Could not calculate balance changes.
      </Typography>
    )
  }
  if (totalBalanceChanges === 0) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ justifySelf: 'flex-end' }}>
        No balance change detected
      </Typography>
    )
  }

  return (
    <Grid container className={css.balanceChanges}>
      <>
        {balanceChange?.map((change, assetIdx) => (
          <>
            {change.in.map((diff, changeIdx) => (
              <BalanceChange key={`${assetIdx}-in-${changeIdx}`} asset={change.asset} positive diff={diff} />
            ))}
            {change.out.map((diff, changeIdx) => (
              <BalanceChange key={`${assetIdx}-out-${changeIdx}`} asset={change.asset} diff={diff} />
            ))}
          </>
        ))}
      </>
    </Grid>
  )
}

export const BlockaidBalanceChanges = () => {
  const isFeatureEnabled = useHasFeature(FEATURES.RISK_MITIGATION)

  if (!isFeatureEnabled) {
    return null
  }

  return (
    <div className={css.box}>
      <Typography variant="subtitle2" fontWeight={700} flexShrink={0}>
        Balance change
        <Tooltip
          title={
            <>
              The balance change gives an overview of the implications of a transaction. You can see which assets will
              be sent and received after the transaction is executed.&nbsp;
              <ExternalLink href={REDEFINE_ARTICLE} title="Learn more about balance change">
                Learn more about balance change
              </ExternalLink>
              .
            </>
          }
          arrow
          placement="top"
        >
          <span>
            <SvgIcon
              component={InfoIcon}
              inheritViewBox
              color="border"
              fontSize="small"
              sx={{
                verticalAlign: 'middle',
                ml: 0.5,
              }}
            />
          </span>
        </Tooltip>
      </Typography>
      <ErrorBoundary fallback={<div>Error showing balance changes</div>}>
        <BalanceChanges />
      </ErrorBoundary>
    </div>
  )
}
</file>

<file path="src/components/tx/security/blockaid/BlockaidHint.tsx">
import { List, ListItem, Typography } from '@mui/material'

export const BlockaidHint = ({ warnings }: { warnings: string[] }) => {
  return (
    <List sx={{ listStyle: 'disc', pl: 2, py: 0, '& li:last-child': { m: 0 } }}>
      {warnings.map((warning) => (
        <ListItem key={warning} disablePadding sx={{ display: 'list-item', mb: 1 }}>
          <Typography variant="body2">{warning}</Typography>
        </ListItem>
      ))}
    </List>
  )
}
</file>

<file path="src/components/tx/security/blockaid/ContractChangeWarning.tsx">
import { Box, Stack, Typography } from '@mui/material'
import type {
  ModulesChangeManagement,
  OwnershipChangeManagement,
  ProxyUpgradeManagement,
} from '@safe-global/utils/services/security/modules/BlockaidModule/types'
import { SecuritySeverity } from '@safe-global/utils/services/security/modules/types'
import { mapSecuritySeverity } from '../utils'
import EthHashInfo from '@/components/common/EthHashInfo'
import { Warning } from '.'
import { CONTRACT_CHANGE_TITLES_MAPPING } from '@safe-global/utils/components/tx/security/blockaid/utils'

const ProxyUpgradeSummary = ({ beforeAddress, afterAddress }: { beforeAddress: string; afterAddress: string }) => {
  return (
    <Stack direction="column" spacing={0.5}>
      <Typography variant="body2" sx={{ marginBottom: 'var(--space-2) !important' }}>
        Please verify that this change is intended and correct as it may overwrite the ownership of your account
      </Typography>
      <Typography variant="overline">Current mastercopy:</Typography>
      <Box sx={{ padding: '6px 12px', borderRadius: '6px', backgroundColor: 'background.paper' }}>
        <EthHashInfo address={beforeAddress} showCopyButton hasExplorer shortAddress={false} showAvatar={false} />
      </Box>

      <Typography variant="overline">New mastercopy:</Typography>
      <Box sx={{ padding: '6px 12px', borderRadius: '6px', backgroundColor: 'background.paper' }}>
        <EthHashInfo address={afterAddress} showCopyButton hasExplorer shortAddress={false} showAvatar={false} />
      </Box>
    </Stack>
  )
}

export const ContractChangeWarning = ({
  contractChange,
}: {
  contractChange: ProxyUpgradeManagement | OwnershipChangeManagement | ModulesChangeManagement
}) => {
  const title = CONTRACT_CHANGE_TITLES_MAPPING[contractChange.type]
  const severityProps = mapSecuritySeverity[SecuritySeverity.MEDIUM]
  const { before, after, type } = contractChange
  const isProxyUpgrade = type === 'PROXY_UPGRADE'

  const warningContent = (
    <>
      {isProxyUpgrade ? (
        <ProxyUpgradeSummary beforeAddress={before.address} afterAddress={after.address} />
      ) : (
        <Typography variant="body2">Please verify that this change is intended and correct.</Typography>
      )}
    </>
  )

  return <Warning title={title} severityProps={severityProps} content={warningContent} isTransaction={true} />
}
</file>

<file path="src/components/tx/security/blockaid/index.tsx">
import type { ReactNode } from 'react'
import { useContext } from 'react'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'
import groupBy from 'lodash/groupBy'
import { Alert, AlertTitle, Box, Checkbox, FormControlLabel, Stack, Typography } from '@mui/material'
import { useHasFeature } from '@/hooks/useChains'
import { ErrorBoundary } from '@sentry/react'
import css from './styles.module.css'

import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'

import BlockaidIcon from '@/public/images/transactions/blockaid-icon.svg'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { type SecurityWarningProps, mapSecuritySeverity } from '../utils'
import { BlockaidHint } from './BlockaidHint'
import { ContractChangeWarning } from './ContractChangeWarning'
import { FEATURES } from '@safe-global/utils/utils/chains'
import { CLASSIFICATION_MAPPING, REASON_MAPPING } from '@safe-global/utils/components/tx/security/blockaid/utils'

export const Warning = ({
  title,
  content,
  severityProps,
  needsRiskConfirmation = false,
  isRiskConfirmed = true,
  isTransaction = true,
  toggleConfirmation,
}: {
  title: ReactNode
  content: ReactNode
  severityProps?: SecurityWarningProps
  needsRiskConfirmation?: boolean
  isRiskConfirmed?: boolean
  isTransaction?: boolean
  toggleConfirmation?: () => void
}) => {
  return (
    <Box>
      <Alert
        severity={severityProps?.color}
        className={css.customAlert}
        sx={needsRiskConfirmation ? { borderBottomLeftRadius: '0px', borderBottomRightRadius: '0px' } : undefined}
      >
        <AlertTitle fontWeight="700 !important" mb={1}>
          {title}
        </AlertTitle>
        {content}
      </Alert>
      {needsRiskConfirmation && (
        <Box className={css.riskConfirmationBlock} sx={{ pl: 2 }}>
          <Track {...MODALS_EVENTS.ACCEPT_RISK}>
            <FormControlLabel
              label={
                <Typography variant="body2" color="static.main">
                  I understand the risks and would like to sign this {isTransaction ? 'transaction' : 'message'}
                </Typography>
              }
              control={<Checkbox checked={isRiskConfirmed} onChange={toggleConfirmation} color="primary" />}
            />
          </Track>
        </Box>
      )}
    </Box>
  )
}

const ResultDescription = ({
  description,
  reason,
  classification,
}: {
  description: string | undefined
  reason: string | undefined
  classification: string | undefined
}) => {
  let text: string | undefined = ''
  if (reason && classification && REASON_MAPPING[reason] && CLASSIFICATION_MAPPING[classification]) {
    text = `The transaction ${REASON_MAPPING[reason]} ${CLASSIFICATION_MAPPING[classification]}.`
  } else {
    text = description
  }

  return (
    <Typography
      variant="subtitle1"
      sx={{
        fontWeight: 700,
        lineHeight: '20px',
      }}
    >
      {text ?? 'The transaction is malicious.'}
    </Typography>
  )
}

const BlockaidError = () => {
  return (
    <Alert data-testid="blockaid-error" severity="warning" className={css.customAlert}>
      <AlertTitle>
        <Typography
          variant="subtitle1"
          sx={{
            fontWeight: 700,
          }}
        >
          Proceed with caution
        </Typography>
      </AlertTitle>
      <Typography variant="body2">
        The transaction could not be checked for security alerts. Verify the details and addresses before proceeding.
      </Typography>
      <BlockaidMessage />
    </Alert>
  )
}

export const Blockaid = () => {
  const isFeatureEnabled = useHasFeature(FEATURES.RISK_MITIGATION)

  if (!isFeatureEnabled) {
    return null
  }

  return (
    <ErrorBoundary fallback={<div>Error showing scan result</div>}>
      <BlockaidWarning />
    </ErrorBoundary>
  )
}

const BlockaidWarning = () => {
  const { blockaidResponse, setIsRiskConfirmed, needsRiskConfirmation, isRiskConfirmed } = useContext(TxSecurityContext)
  const { severity, isLoading, error } = blockaidResponse ?? {}

  const { safeTx } = useContext(SafeTxContext)

  // We either scan a tx or a message if tx is undefined
  const isTransaction = !!safeTx

  const severityProps = severity !== undefined ? mapSecuritySeverity[severity] : undefined

  const toggleConfirmation = () => {
    setIsRiskConfirmed((prev) => !prev)
  }

  if (error) {
    return <BlockaidError />
  }

  if (isLoading || !blockaidResponse) {
    return null
  }

  return (
    <>
      {!!blockaidResponse.severity ? (
        <Box>
          <Warning
            isRiskConfirmed={isRiskConfirmed}
            isTransaction={isTransaction}
            needsRiskConfirmation={needsRiskConfirmation}
            toggleConfirmation={toggleConfirmation}
            title={
              <ResultDescription
                classification={blockaidResponse.classification}
                reason={blockaidResponse.reason}
                description={blockaidResponse.description}
              />
            }
            content={<BlockaidMessage />}
            severityProps={severityProps}
          />
          <PoweredByBlockaid />
        </Box>
      ) : blockaidResponse?.contractManagement && blockaidResponse.contractManagement.length > 0 ? (
        <Box>
          <Stack direction="column" spacing={1}>
            {blockaidResponse?.contractManagement.map((contractChange) => (
              <ContractChangeWarning key={contractChange.type} contractChange={contractChange} />
            ))}
          </Stack>
          <PoweredByBlockaid />
        </Box>
      ) : null}
    </>
  )
}

const PoweredByBlockaid = () => (
  <Stack direction="row" spacing={0.5} sx={{ alignItems: 'center', mt: 1 }}>
    <Typography variant="caption" sx={{ color: 'text.secondary' }}>
      Powered by
    </Typography>
    <BlockaidIcon />
  </Stack>
)

export const BlockaidMessage = () => {
  const { blockaidResponse } = useContext(TxSecurityContext)
  if (!blockaidResponse) {
    return null
  }

  const { warnings } = blockaidResponse

  /* Evaluate security warnings */
  const groupedShownWarnings = groupBy(warnings, (warning) => warning.severity)
  const sortedSeverities = Object.keys(groupedShownWarnings).sort((a, b) => (Number(a) < Number(b) ? 1 : -1))

  if (sortedSeverities.length === 0) return null

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 1,
      }}
    >
      {sortedSeverities.map((key) => (
        <BlockaidHint key={key} warnings={groupedShownWarnings[key].map((warning) => warning.description)} />
      ))}
    </Box>
  )
}
</file>

<file path="src/components/tx/security/blockaid/styles.module.css">
.hint {
  padding: var(--space-2);
  border: unset;
}

.hint :global .MuiAlert-icon {
  padding: 0;
}

.hint :global .MuiAlert-message {
  padding: 0;
}

.wrapperBox :global .MuiAccordion-root.Mui-expanded,
.wrapperBox :global .MuiAccordion-root {
  border: none;
}

.wrapperBox {
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
  padding: 0;
  background-color: var(--color-background-main);
  line-height: 1;
}

.loader {
  display: flex;
  align-items: center;
  gap: var(--space-1);
  padding-right: 12px;
  justify-self: flex-end;
}

.balanceChanges {
  max-height: 300px;
  overflow-y: auto;
  align-items: center;
  gap: var(--space-1);
}

.balanceChange {
  display: flex;
  margin-bottom: 6px;
  align-items: center;
}

.balanceChange:last-child {
  margin-bottom: 0;
}

.balanceChange svg {
  flex-shrink: 0;
}

.nftId {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.categoryChip {
  border-radius: 4px;
  height: auto;
}

.box {
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
  display: grid;
  grid-template-columns: 35% auto;
  padding: var(--space-2) 12px;
}

@keyframes popup {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

.checkboxError {
  color: var(--color-error-main);
  animation: popup 0.5s ease-in-out;
}

.checkboxError svg {
  color: var(--color-error-main) !important;
}

.redefine {
  height: 40px;
  width: 52px;
  position: absolute;
  right: -58px;
}

.resultAccordion :global .Mui-expanded.MuiAccordionSummary-root {
  background: inherit;
}

.resultAccordion :global .Mui-expanded {
  border: var(--color-border-light);
}

.customAlert {
  border: none;
}

.riskConfirmationBlock {
  background-color: var(--color-error-light);
  border-bottom-left-radius: 6px;
  border-bottom-right-radius: 6px;
}

.riskConfirmationBlock :global .MuiCheckbox-root {
  color: var(--color-static-main);
}
</file>

<file path="src/components/tx/security/blockaid/useBlockaid.ts">
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { useHasFeature } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useSigner } from '@/hooks/wallets/useWallet'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import type { SecurityResponse } from '@safe-global/utils/services/security/modules/types'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'

import { useEffect, useMemo } from 'react'
import {
  BlockaidModule,
  type BlockaidModuleResponse,
} from '@safe-global/utils/services/security/modules/BlockaidModule'
import { FEATURES } from '@safe-global/utils/utils/chains'
import { Errors, logError } from '@/services/exceptions'

const BlockaidModuleInstance = new BlockaidModule()

const DEFAULT_ERROR_MESSAGE = 'Unavailable'

export const useBlockaid = (
  data: SafeTransaction | TypedData | undefined,
  origin?: string,
): AsyncResult<SecurityResponse<BlockaidModuleResponse>> => {
  const { safe, safeAddress } = useSafeInfo()
  const signer = useSigner()
  const isFeatureEnabled = useHasFeature(FEATURES.RISK_MITIGATION)

  const [blockaidPayload, blockaidErrors, blockaidLoading] = useAsync<SecurityResponse<BlockaidModuleResponse>>(
    () => {
      if (!isFeatureEnabled || !data || !signer?.address) {
        return
      }

      return BlockaidModuleInstance.scanTransaction({
        chainId: Number(safe.chainId),
        data,
        safeAddress,
        walletAddress: signer.address,
        threshold: safe.threshold,
        origin,
      })
    },
    [safe.chainId, safe.threshold, safeAddress, data, signer?.address, isFeatureEnabled, origin],
    false,
  )

  const loading = blockaidLoading

  useEffect(() => {
    if (!loading && blockaidPayload) {
      trackEvent({ ...MODALS_EVENTS.BLOCKAID_RESULT, label: blockaidPayload.severity })
    }
  }, [loading, blockaidPayload])

  const errorMsg = useMemo(
    () => (blockaidErrors ? new Error(DEFAULT_ERROR_MESSAGE) : blockaidPayload?.payload?.error),

    [blockaidErrors, blockaidPayload],
  )

  useEffect(() => {
    logError(Errors._201, errorMsg)
  }, [errorMsg])

  return [blockaidPayload, errorMsg, loading]
}
</file>

<file path="src/components/tx/security/shared/styles.module.css">
.wrapper {
  display: flex;
  justify-content: space-between;
  padding: var(--space-1) var(--space-2);
  border-width: 1px;
}

.poweredBy {
  color: var(--color-text-secondary);
  display: inline-flex;
  align-items: center;
  gap: var(--space-1);
}

.result {
  display: inline-flex;
  align-items: center;
}
</file>

<file path="src/components/tx/security/shared/TxSecurityContext.tsx">
import { SecuritySeverity } from '@safe-global/utils/services/security/modules/types'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { createContext, type ReactElement, useContext, useMemo, useState } from 'react'
import { useBlockaid } from '../blockaid/useBlockaid'
import { defaultSecurityContextValues } from '@safe-global/utils/components/tx/security/shared/utils'
import { type TxSecurityContextProps } from '@safe-global/utils/components/tx/security/shared/types'

export const TxSecurityContext = createContext<TxSecurityContextProps>(defaultSecurityContextValues)

export const TxSecurityProvider = ({ children }: { children: ReactElement }) => {
  const { safeTx, safeMessage, txOrigin } = useContext(SafeTxContext)
  const [blockaidResponse, blockaidError, blockaidLoading] = useBlockaid(safeTx ?? safeMessage, txOrigin)

  const [isRiskConfirmed, setIsRiskConfirmed] = useState(false)
  const [isRiskIgnored, setIsRiskIgnored] = useState(false)

  const providedValue = useMemo(
    () => ({
      blockaidResponse: {
        description: blockaidResponse?.payload?.description,
        reason: blockaidResponse?.payload?.reason,
        classification: blockaidResponse?.payload?.classification,
        severity: blockaidResponse?.severity,
        warnings: blockaidResponse?.payload?.issues || [],
        balanceChange: blockaidResponse?.payload?.balanceChange,
        contractManagement: blockaidResponse?.payload?.contractManagement,
        error: blockaidError,
        isLoading: blockaidLoading,
      },
      needsRiskConfirmation: !!blockaidResponse && blockaidResponse.severity >= SecuritySeverity.HIGH,
      isRiskConfirmed,
      setIsRiskConfirmed,
      isRiskIgnored: isRiskIgnored && !isRiskConfirmed,
      setIsRiskIgnored,
    }),
    [blockaidError, blockaidLoading, blockaidResponse, isRiskConfirmed, isRiskIgnored],
  )

  return <TxSecurityContext.Provider value={providedValue}>{children}</TxSecurityContext.Provider>
}
</file>

<file path="src/components/tx/security/tenderly/index.tsx">
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { Alert, Button, Paper, SvgIcon, Tooltip, Typography } from '@mui/material'
import { useContext, useEffect } from 'react'
import type { ReactElement } from 'react'

import useSafeInfo from '@/hooks/useSafeInfo'
import { useSigner } from '@/hooks/wallets/useWallet'
import CheckIcon from '@/public/images/common/check.svg'
import CloseIcon from '@/public/images/common/close.svg'
import { useDarkMode } from '@/hooks/useDarkMode'
import CircularProgress from '@mui/material/CircularProgress'
import ExternalLink from '@/components/common/ExternalLink'
import { useCurrentChain } from '@/hooks/useChains'
import {
  isTxSimulationEnabled,
  type SimulationTxParams,
} from '@safe-global/utils/components/tx/security/tenderly/utils'

import css from './styles.module.css'
import sharedCss from '@/components/tx/security/shared/styles.module.css'
import { TxInfoContext } from '@/components/tx-flow/TxInfoProvider'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import InfoIcon from '@/public/images/notifications/info.svg'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'

export type TxSimulationProps = {
  transactions?: SimulationTxParams['transactions']
  gasLimit?: number
  disabled: boolean
  executionOwner?: string
}

// TODO: Investigate resetting on gasLimit change as we are not simulating with the gasLimit of the tx
// otherwise remove all usage of gasLimit in simulation. Note: this was previously being done.
// TODO: Test this component
const TxSimulationBlock = ({ transactions, disabled, gasLimit, executionOwner }: TxSimulationProps): ReactElement => {
  const { safe } = useSafeInfo()
  const signer = useSigner()
  const isSafeOwner = useIsSafeOwner()
  const isDarkMode = useDarkMode()
  const { safeTx } = useContext(SafeTxContext)
  const {
    simulation: { simulateTransaction, resetSimulation },
    status: { isFinished, isError, isSuccess, isCallTraceError, isLoading },
  } = useContext(TxInfoContext)

  const handleSimulation = async () => {
    if (!signer) {
      return
    }

    simulateTransaction({
      safe,
      // fall back to the first owner of the safe in case the transaction is created by a proposer
      executionOwner: (executionOwner ?? isSafeOwner) ? signer.address : safe.owners[0].value,
      transactions,
      gasLimit,
    } as SimulationTxParams)
  }

  // Reset simulation if safeTx changes
  useEffect(() => {
    resetSimulation()
  }, [safeTx, resetSimulation])

  return (
    <Paper variant="outlined" className={sharedCss.wrapper}>
      <div className={css.wrapper}>
        <Typography variant="body2" fontWeight={700}>
          Run a simulation
          <Tooltip
            title="This transaction can be simulated before execution to ensure that it will be succeed, generating a detailed report of the transaction execution."
            arrow
            placement="top"
          >
            <span>
              <SvgIcon
                component={InfoIcon}
                inheritViewBox
                color="border"
                fontSize="small"
                sx={{
                  verticalAlign: 'middle',
                  ml: 0.5,
                }}
              />
            </span>
          </Tooltip>
        </Typography>
        <Typography variant="caption" className={sharedCss.poweredBy}>
          Powered by{' '}
          <img
            src={isDarkMode ? '/images/transactions/tenderly-light.svg' : '/images/transactions/tenderly-dark.svg'}
            alt="Tenderly"
            width="65px"
            height="15px"
          />
        </Typography>
      </div>

      <div className={sharedCss.result}>
        {isLoading ? (
          <CircularProgress
            size={22}
            sx={{
              color: ({ palette }) => palette.text.secondary,
            }}
          />
        ) : isFinished ? (
          !isSuccess || isError || isCallTraceError ? (
            <Typography
              variant="body2"
              className={sharedCss.result}
              sx={{
                color: 'error.main',
              }}
            >
              <SvgIcon component={CloseIcon} inheritViewBox fontSize="small" sx={{ verticalAlign: 'middle', mr: 1 }} />
              Error
            </Typography>
          ) : (
            <Typography
              data-testid="simulation-success-msg"
              variant="body2"
              className={sharedCss.result}
              sx={{
                color: 'success.main',
              }}
            >
              <SvgIcon component={CheckIcon} inheritViewBox fontSize="small" sx={{ verticalAlign: 'middle', mr: 1 }} />
              Success
            </Typography>
          )
        ) : (
          <Track {...MODALS_EVENTS.SIMULATE_TX}>
            <Button
              data-testid="simulate-btn"
              variant="outlined"
              size="small"
              className={css.simulate}
              onClick={handleSimulation}
              disabled={!transactions || disabled}
            >
              Simulate
            </Button>
          </Track>
        )}
      </div>
    </Paper>
  )
}

export const TxSimulation = (props: TxSimulationProps): ReactElement | null => {
  const chain = useCurrentChain()

  if (!chain || !isTxSimulationEnabled(chain)) {
    return null
  }

  return <TxSimulationBlock {...props} />
}

// TODO: Test this component
export const TxSimulationMessage = () => {
  const {
    simulation: { simulationLink, simulation, requestError },
    status: { isError, isSuccess, isCallTraceError, isFinished },
  } = useContext(TxInfoContext)

  if (!isFinished) {
    return null
  }

  if (!isSuccess || isError || isCallTraceError) {
    return (
      <Alert severity="error" sx={{ border: 'unset' }}>
        <Typography variant="body1" fontWeight={700}>
          Simulation failed
        </Typography>
        {requestError ? (
          <Typography color="error" variant="body2">
            An unexpected error occurred during simulation: <b>{requestError}</b>.
          </Typography>
        ) : (
          <Typography variant="body2">
            {isCallTraceError ? (
              <>The transaction failed during the simulation.</>
            ) : (
              <>
                The transaction failed during the simulation throwing error{' '}
                <b>{simulation?.transaction.error_message}</b> in the contract at{' '}
                <b>{simulation?.transaction.error_info?.address}</b>.
              </>
            )}{' '}
            Full simulation report is available <ExternalLink href={simulationLink}>on Tenderly</ExternalLink>.
          </Typography>
        )}
      </Alert>
    )
  }

  return (
    <Alert severity="info" sx={{ border: 'unset' }}>
      <Typography variant="body2" fontWeight={700}>
        Simulation successful
      </Typography>
      Full simulation report is available <ExternalLink href={simulationLink}>on Tenderly</ExternalLink>.
    </Alert>
  )
}
</file>

<file path="src/components/tx/security/tenderly/styles.module.css">
.simulate {
  margin: 0;
  padding: calc(var(--space-1) / 2) var(--space-2);
}

.wrapper {
  line-height: 1;
}
</file>

<file path="src/components/tx/security/tenderly/useSimulation.ts">
import { useCallback, useMemo, useState } from 'react'

import { getSimulationPayload } from '@/components/tx/security/tenderly/utils'
import { FETCH_STATUS, type TenderlySimulation } from '@safe-global/utils/components/tx/security/tenderly/types'
import { useAppSelector } from '@/store'
import { selectTenderly } from '@/store/settingsSlice'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { type UseSimulationReturn } from '@safe-global/utils/components/tx/security/tenderly/useSimulation'
import {
  getSimulation,
  getSimulationLink,
  type SimulationTxParams,
} from '@safe-global/utils/components/tx/security/tenderly/utils'
import { Errors, logError } from '@/services/exceptions'

export const useSimulation = (): UseSimulationReturn => {
  const [simulation, setSimulation] = useState<TenderlySimulation | undefined>()
  const [simulationRequestStatus, setSimulationRequestStatus] = useState<FETCH_STATUS>(FETCH_STATUS.NOT_ASKED)
  const [requestError, setRequestError] = useState<string | undefined>(undefined)
  const tenderly = useAppSelector(selectTenderly)

  const simulationLink = useMemo(() => getSimulationLink(simulation?.simulation.id || ''), [simulation])

  const resetSimulation = useCallback(() => {
    setSimulationRequestStatus(FETCH_STATUS.NOT_ASKED)
    setRequestError(undefined)
    setSimulation(undefined)
  }, [])

  const simulateTransaction = useCallback(
    async (params: SimulationTxParams) => {
      setSimulationRequestStatus(FETCH_STATUS.LOADING)
      setRequestError(undefined)

      try {
        const simulationPayload = await getSimulationPayload(params)

        const data = await getSimulation(simulationPayload, tenderly)

        setSimulation(data)
        setSimulationRequestStatus(FETCH_STATUS.SUCCESS)
      } catch (error) {
        logError(Errors._200, error)

        setRequestError(asError(error).message)
        setSimulationRequestStatus(FETCH_STATUS.ERROR)
      }
    },
    [tenderly],
  )

  return {
    simulateTransaction,
    // This is only used by the provider
    _simulationRequestStatus: simulationRequestStatus,
    simulation,
    simulationLink,
    requestError,
    resetSimulation,
  } as UseSimulationReturn
}
</file>

<file path="src/components/tx/security/tenderly/utils.ts">
import { generatePreValidatedSignature } from '@safe-global/protocol-kit/dist/src/utils/signatures'
import EthSafeTransaction from '@safe-global/protocol-kit/dist/src/utils/transactions/SafeTransaction'
import { encodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils/transactions/utils'

import {
  getReadOnlyCurrentGnosisSafeContract,
  getReadOnlyMultiSendCallOnlyContract,
} from '@/services/contracts/safeContracts'
import type { TenderlySimulatePayload } from '@safe-global/utils/components/tx/security/tenderly/types'
import { getWeb3ReadOnly } from '@/hooks/wallets/web3'

import type {
  MultiSendTransactionSimulationParams,
  SimulationTxParams,
  SingleTransactionSimulationParams,
} from '@safe-global/utils/components/tx/security/tenderly/utils'
import {
  _getStateOverride,
  getStateOverwrites,
  isSingleTransactionSimulation,
} from '@safe-global/utils/components/tx/security/tenderly/utils'

export const _getSingleTransactionPayload = async (
  params: SingleTransactionSimulationParams,
): Promise<Pick<TenderlySimulatePayload, 'to' | 'input'>> => {
  // If a transaction is executable we simulate with the proposed/selected gasLimit and the actual signatures
  let transaction = params.transactions
  const hasOwnerSignature = transaction.signatures.has(params.executionOwner)
  // If the owner's sig is missing and the tx threshold is not reached we add the owner's preValidated signature
  const needsOwnerSignature = !hasOwnerSignature && transaction.signatures.size < params.safe.threshold
  if (needsOwnerSignature) {
    const simulatedTransaction = new EthSafeTransaction(transaction.data)

    transaction.signatures.forEach((signature) => {
      simulatedTransaction.addSignature(signature)
    })
    simulatedTransaction.addSignature(generatePreValidatedSignature(params.executionOwner))

    transaction = simulatedTransaction
  }

  const readOnlySafeContract = await getReadOnlyCurrentGnosisSafeContract(params.safe)

  const input = readOnlySafeContract.encode('execTransaction', [
    transaction.data.to,
    transaction.data.value,
    transaction.data.data,
    transaction.data.operation,
    transaction.data.safeTxGas,
    transaction.data.baseGas,
    transaction.data.gasPrice,
    transaction.data.gasToken,
    transaction.data.refundReceiver,
    transaction.encodedSignatures(),
  ])

  return {
    to: await readOnlySafeContract.getAddress(),
    input,
  }
}

export const _getMultiSendCallOnlyPayload = async (
  params: MultiSendTransactionSimulationParams,
): Promise<Pick<TenderlySimulatePayload, 'to' | 'input'>> => {
  const data = encodeMultiSendData(params.transactions)
  const readOnlyMultiSendContract = await getReadOnlyMultiSendCallOnlyContract(params.safe.version)

  return {
    to: await readOnlyMultiSendContract.getAddress(),
    input: readOnlyMultiSendContract.encode('multiSend', [data]),
  }
}

const getLatestBlockGasLimit = async (): Promise<number> => {
  const web3ReadOnly = getWeb3ReadOnly()
  const latestBlock = await web3ReadOnly?.getBlock('latest')
  if (!latestBlock) {
    throw Error('Could not determine block gas limit')
  }
  return Number(latestBlock.gasLimit)
}

export const getSimulationPayload = async (params: SimulationTxParams): Promise<TenderlySimulatePayload> => {
  const gasLimit = params.gasLimit ?? (await getLatestBlockGasLimit())

  const payload = isSingleTransactionSimulation(params)
    ? await _getSingleTransactionPayload(params)
    : await _getMultiSendCallOnlyPayload(params)

  const stateOverwrites = getStateOverwrites(params)
  const stateOverwritesLength = Object.keys(stateOverwrites).length

  return {
    ...payload,
    network_id: params.safe.chainId,
    from: params.executionOwner,
    gas: gasLimit,
    // With gas price 0 account don't need token for gas
    gas_price: '0',
    state_objects:
      stateOverwritesLength > 0
        ? _getStateOverride(params.safe.address.value, undefined, undefined, stateOverwrites)
        : undefined,
    save: true,
    save_if_fails: true,
  }
}
</file>

<file path="src/components/tx/security/SecurityWarnings.tsx">
import { TxSimulationMessage } from './tenderly'

const SecurityWarnings = () => (
  <>
    <TxSimulationMessage />
  </>
)

export default SecurityWarnings
</file>

<file path="src/components/tx/security/useDelegateCallModule.ts">
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'

import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '@/hooks/useSafeInfo'
import { DelegateCallModule } from '@safe-global/utils/services/security/modules/DelegateCallModule'
import type { DelegateCallModuleResponse } from '@safe-global/utils/services/security/modules/DelegateCallModule'
import type { SecurityResponse } from '@safe-global/utils/services/security/modules/types'
import { useCurrentChain } from '@/hooks/useChains'

const DelegateCallModuleInstance = new DelegateCallModule()

// TODO: Not being used right now
export const useDelegateCallModule = (safeTransaction: SafeTransaction | undefined) => {
  const { safe, safeLoaded } = useSafeInfo()
  const currentChain = useCurrentChain()

  return useAsync<SecurityResponse<DelegateCallModuleResponse>>(() => {
    if (!safeTransaction || !safeLoaded || !currentChain) {
      return
    }

    return DelegateCallModuleInstance.scanTransaction({
      safeTransaction,
      safeVersion: safe.version,
      chain: currentChain,
    })
  }, [safeTransaction, safeLoaded, safe.version, currentChain])
}
</file>

<file path="src/components/tx/security/utils.ts">
import { SecuritySeverity } from '@safe-global/utils/services/security/modules/types'
import CloseIcon from '@/public/images/common/close.svg'
import InfoIcon from '@/public/images/notifications/info.svg'
import type { ComponentType } from 'react'
import type { AlertColor } from '@mui/material'

const ACTION_REJECT = 'Reject this transaction'
const ACTION_REVIEW = 'Review before processing'

export type SecurityWarningProps = {
  color: AlertColor
  icon: ComponentType
  label: string
  action?: string
}

export const mapSecuritySeverity: Record<SecuritySeverity, SecurityWarningProps> = {
  [SecuritySeverity.CRITICAL]: {
    action: ACTION_REJECT,
    color: 'error',
    icon: CloseIcon,
    label: 'critical risk',
  },
  [SecuritySeverity.HIGH]: {
    action: ACTION_REJECT,
    color: 'error',
    icon: CloseIcon,
    label: 'high risk',
  },
  [SecuritySeverity.MEDIUM]: {
    action: ACTION_REVIEW,
    color: 'warning',
    icon: InfoIcon,
    label: 'warning',
  },
  [SecuritySeverity.LOW]: {
    action: ACTION_REVIEW,
    color: 'warning',
    icon: InfoIcon,
    label: 'warning',
  },
  [SecuritySeverity.NONE]: {
    color: 'info',
    icon: InfoIcon,
    label: 'info',
  },
}
</file>

<file path="src/components/tx/SendFromBlock/index.tsx">
import { type ReactElement } from 'react'
import { Box, Typography } from '@mui/material'
import SouthIcon from '@mui/icons-material/South'
import css from './styles.module.css'
import useSafeAddress from '@/hooks/useSafeAddress'
import EthHashInfo from '@/components/common/EthHashInfo'

// TODO: Remove this file after replacing in all tx flow components
const SendFromBlock = ({ title }: { title?: string }): ReactElement => {
  const address = useSafeAddress()

  return (
    <Box className={css.container} pb={2} mb={2}>
      <Typography color="text.secondary" pb={1}>
        {title || 'Sending from'}
      </Typography>

      <Typography variant="body2" component="div">
        <EthHashInfo address={address} shortAddress={false} hasExplorer showCopyButton />
      </Typography>

      <SouthIcon className={css.arrow} />
    </Box>
  )
}

export default SendFromBlock
</file>

<file path="src/components/tx/SendFromBlock/styles.module.css">
.container {
  border-bottom: 2px solid var(--color-border-light);
  position: relative;
}

.arrow {
  position: absolute;
  bottom: -12px;
  left: 50%;
  margin-left: -12px;
  color: var(--color-border-light);
  background-color: var(--color-background-paper);
}
</file>

<file path="src/components/tx/SendToBlock/index.tsx">
import { Typography } from '@mui/material'
import NamedAddressInfo from '@/components/common/NamedAddressInfo'
import FieldsGrid from '../FieldsGrid'

const SendToBlock = ({
  address,
  title = 'Recipient',
  customAvatar,
  avatarSize,
  name,
}: {
  address: string
  name?: string
  title?: string
  customAvatar?: string
  avatarSize?: number
}) => {
  return (
    <FieldsGrid title={title}>
      <Typography variant="body2" component="div">
        <NamedAddressInfo
          address={address}
          name={name}
          shortAddress={false}
          hasExplorer
          showCopyButton
          avatarSize={avatarSize}
          customAvatar={customAvatar}
        />
      </Typography>
    </FieldsGrid>
  )
}

export default SendToBlock
</file>

<file path="src/components/tx/SignOrExecuteForm/ConfirmationTitle.tsx">
import { SvgIcon, Typography } from '@mui/material'
import EditIcon from '@/public/images/common/edit.svg'
import css from './styles.module.css'

export enum ConfirmationTitleTypes {
  sign = 'confirm',
  execute = 'execute',
  propose = 'propose',
}

const ConfirmationTitle = ({ isCreation, variant }: { isCreation?: boolean; variant: ConfirmationTitleTypes }) => {
  return (
    <div className={css.wrapper}>
      <div className={`${css.icon} ${variant === ConfirmationTitleTypes.sign ? css.sign : css.execute}`}>
        <SvgIcon component={EditIcon} inheritViewBox fontSize="small" />
      </div>
      <div>
        <Typography variant="h5" sx={{ textTransform: 'capitalize' }}>
          {variant}
        </Typography>
        <Typography variant="body2">
          You&apos;re about to {isCreation ? 'create and ' : ''}
          {variant} this transaction.
        </Typography>
      </div>
    </div>
  )
}

export default ConfirmationTitle
</file>

<file path="src/components/tx/SignOrExecuteForm/hooks.ts">
import { assertTx, assertOnboard, assertChainInfo, assertProvider } from '@/utils/helpers'
import { useMemo } from 'react'
import { type TransactionOptions, type SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { sameString } from '@safe-global/protocol-kit/dist/src/utils'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWallet, { useSigner } from '@/hooks/wallets/useWallet'
import useOnboard from '@/hooks/wallets/useOnboard'
import { isSmartContractWallet } from '@/utils/wallets'
import {
  dispatchProposerTxSigning,
  dispatchOnChainSigning,
  dispatchTxExecution,
  dispatchTxProposal,
  dispatchTxRelay,
  dispatchTxSigning,
} from '@/services/tx/tx-sender'
import { useHasPendingTxs } from '@/hooks/usePendingTxs'
import { getSafeTxGas, getNonces } from '@/services/tx/tx-sender/recommendedNonce'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { useUpdateBatch } from '@/hooks/useDraftBatch'
import { type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { useCurrentChain } from '@/hooks/useChains'

type TxActions = {
  addToBatch: (safeTx?: SafeTransaction, origin?: string) => Promise<string>
  signTx: (safeTx?: SafeTransaction, txId?: string, origin?: string) => Promise<string>
  executeTx: (
    txOptions: TransactionOptions,
    safeTx?: SafeTransaction,
    txId?: string,
    origin?: string,
    isRelayed?: boolean,
  ) => Promise<string>
  signProposerTx: (safeTx?: SafeTransaction, origin?: string) => Promise<string>
  proposeTx: (safeTx: SafeTransaction, txId?: string, origin?: string) => Promise<TransactionDetails>
}

export const useTxActions = (): TxActions => {
  const { safe } = useSafeInfo()
  const onboard = useOnboard()
  const signer = useSigner()
  const wallet = useWallet()
  const [addTxToBatch] = useUpdateBatch()
  const chain = useCurrentChain()

  return useMemo<TxActions>(() => {
    const safeAddress = safe.address.value
    const { chainId } = safe

    const _propose = async (sender: string, safeTx: SafeTransaction, txId?: string, origin?: string) => {
      return dispatchTxProposal({
        chainId,
        safeAddress,
        sender,
        safeTx,
        txId,
        origin,
      })
    }

    const proposeTx: TxActions['proposeTx'] = async (safeTx, txId, origin) => {
      assertTx(safeTx)
      return _propose(wallet?.address || safe.owners[0].value, safeTx, txId, origin)
    }

    const addToBatch: TxActions['addToBatch'] = async (safeTx, origin) => {
      assertTx(safeTx)
      assertProvider(signer?.provider)

      const tx = await _propose(signer.address, safeTx, undefined, origin)
      await addTxToBatch(tx)
      return tx.txId
    }

    const signRelayedTx = async (safeTx: SafeTransaction, txId?: string): Promise<SafeTransaction> => {
      assertTx(safeTx)
      assertProvider(signer?.provider)

      // Smart contracts cannot sign transactions off-chain
      if (await isSmartContractWallet(signer.chainId, signer.address)) {
        throw new Error('Cannot relay an unsigned transaction from a smart contract wallet')
      }
      return await dispatchTxSigning(safeTx, signer.provider, txId)
    }

    const signTx: TxActions['signTx'] = async (safeTx, txId, origin) => {
      assertTx(safeTx)
      assertProvider(signer?.provider)
      assertOnboard(onboard)

      // Smart contract wallets must sign via an on-chain tx
      if (signer.isSafe || (await isSmartContractWallet(signer.chainId, signer.address))) {
        // If the first signature is a smart contract wallet, we have to propose w/o signatures
        // Otherwise the backend won't pick up the tx
        // The signature will be added once the on-chain signature is indexed
        const id = txId || (await _propose(signer.address, safeTx, txId, origin)).txId
        await dispatchOnChainSigning(
          safeTx,
          id,
          signer.provider,
          chainId,
          signer.address,
          safeAddress,
          Boolean(signer.isSafe),
        )
        return id
      }

      // Otherwise, sign off-chain
      const signedTx = await dispatchTxSigning(safeTx, signer.provider, txId)
      const tx = await _propose(signer.address, signedTx, txId, origin)
      return tx.txId
    }

    const signProposerTx: TxActions['signProposerTx'] = async (safeTx, origin) => {
      assertTx(safeTx)
      assertProvider(wallet?.provider)
      assertOnboard(onboard)

      const signedTx = await dispatchProposerTxSigning(safeTx, wallet)

      const tx = await _propose(wallet.address, signedTx, undefined, origin)
      return tx.txId
    }

    const executeTx: TxActions['executeTx'] = async (txOptions, safeTx, txId, origin, isRelayed) => {
      assertTx(safeTx)
      assertProvider(signer?.provider)
      assertOnboard(onboard)
      assertChainInfo(chain)

      let tx: TransactionDetails | undefined
      let rePropose = false
      // Relayed transactions must be fully signed, so request a final signature if needed
      if (isRelayed && safeTx.signatures.size < safe.threshold) {
        safeTx = await signRelayedTx(safeTx)
        rePropose = true
      }

      // Propose the tx if there's no id yet ("immediate execution")
      if (!txId || rePropose) {
        tx = await _propose(signer.address, safeTx, txId, origin)
        txId = tx.txId
      }

      // Relay or execute the tx via connected wallet
      if (isRelayed) {
        await dispatchTxRelay(safeTx, safe, txId, chain, txOptions.gasLimit)
      } else {
        const isSmartAccount = await isSmartContractWallet(signer.chainId, signer.address)
        await dispatchTxExecution(safeTx, txOptions, txId, signer.provider, signer.address, safeAddress, isSmartAccount)
      }

      return txId
    }

    return { addToBatch, signTx, executeTx, signProposerTx, proposeTx }
  }, [safe, wallet, signer?.provider, signer?.address, signer?.chainId, signer?.isSafe, addTxToBatch, onboard, chain])
}

export const useValidateNonce = (safeTx: SafeTransaction | undefined): boolean => {
  const { safe } = useSafeInfo()
  return !!safeTx && safeTx?.data.nonce === safe.nonce
}

export const useImmediatelyExecutable = (): boolean => {
  const { safe } = useSafeInfo()
  const hasPending = useHasPendingTxs()
  return safe.threshold === 1 && !hasPending
}

// Check if the executor is the safe itself (it won't work)
export const useIsExecutionLoop = (): boolean => {
  const wallet = useWallet()
  const { safeAddress } = useSafeInfo()
  return wallet ? sameString(wallet.address, safeAddress) : false
}

export const useRecommendedNonce = (): number | undefined => {
  const { safeAddress, safe } = useSafeInfo()

  const [recommendedNonce] = useAsync(
    async () => {
      if (!safe.chainId || !safeAddress) return
      if (!safe.deployed) return 0

      const nonces = await getNonces(safe.chainId, safeAddress)

      return nonces?.recommendedNonce
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [safeAddress, safe.chainId, safe.txQueuedTag, safe.txHistoryTag], // update when tx queue or history changes
    false, // keep old recommended nonce while refreshing to avoid skeleton
  )

  return recommendedNonce
}

export const useSafeTxGas = (safeTx: SafeTransaction | undefined): string | undefined => {
  const { safeAddress, safe } = useSafeInfo()

  // Memoize only the necessary params so that the useAsync hook is not called every time safeTx changes
  const safeTxParams = useMemo(() => {
    return !safeTx?.data?.to
      ? undefined
      : {
          to: safeTx?.data.to,
          value: safeTx?.data?.value,
          data: safeTx?.data?.data,
          operation: safeTx?.data?.operation,
        }
  }, [safeTx?.data.to, safeTx?.data.value, safeTx?.data.data, safeTx?.data.operation])

  const [safeTxGas] = useAsync(() => {
    if (!safe.chainId || !safeAddress || !safeTxParams || !safe.version) return

    return getSafeTxGas(safe.chainId, safeAddress, safe.version, safeTxParams)
  }, [safeAddress, safe.chainId, safe.version, safeTxParams])

  return safeTxGas
}

export const useAlreadySigned = (safeTx: SafeTransaction | undefined): boolean => {
  const wallet = useSigner()
  const hasSigned =
    safeTx && wallet && (safeTx.signatures.has(wallet.address.toLowerCase()) || safeTx.signatures.has(wallet.address))
  return Boolean(hasSigned)
}
</file>

<file path="src/components/tx/SignOrExecuteForm/index.tsx">
import { useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import SignOrExecuteForm from './SignOrExecuteForm'
import type { SignOrExecuteProps, SubmitCallback } from './SignOrExecuteForm'
import SignOrExecuteSkeleton from './SignOrExecuteSkeleton'
import useTxDetails from '@/hooks/useTxDetails'
import useTxPreview from '../confirmation-views/useTxPreview'

type SignOrExecuteExtendedProps = SignOrExecuteProps & {
  onSubmit?: SubmitCallback
  txId?: string
  children?: React.ReactNode
  isExecutable?: boolean
  isRejection?: boolean
  isBatch?: boolean
  isBatchable?: boolean
  onlyExecute?: boolean
  disableSubmit?: boolean
  origin?: string
  isCreation?: boolean
}

const SignOrExecute = (props: SignOrExecuteExtendedProps) => {
  const { safeTx, safeTxError } = useContext(SafeTxContext)
  const [txDetails, , txDetailsLoading] = useTxDetails(props.txId)
  const [txPreview, , txPreviewLoading] = useTxPreview(safeTx?.data, undefined, props.txId)

  if ((!safeTx && !safeTxError) || txDetailsLoading || txPreviewLoading) {
    return <SignOrExecuteSkeleton />
  }

  return (
    <SignOrExecuteForm
      {...props}
      isCreation={!props.txId}
      txId={props.txId}
      txDetails={txDetails}
      txPreview={txPreview}
    >
      {props.children}
    </SignOrExecuteForm>
  )
}

export default SignOrExecute
</file>

<file path="src/components/tx/SignOrExecuteForm/NonOwnerError.tsx">
import ErrorMessage from '@/components/tx/ErrorMessage'

const NonOwnerError = () => {
  return (
    <ErrorMessage>
      You are currently not a signer of this Safe Account and won&apos;t be able to submit this transaction.
    </ErrorMessage>
  )
}

export default NonOwnerError
</file>

<file path="src/components/tx/SignOrExecuteForm/RiskConfirmationError.tsx">
import { useContext } from 'react'
import ErrorMessage from '../ErrorMessage'
import { TxSecurityContext } from '../security/shared/TxSecurityContext'

const RiskConfirmationError = () => {
  const { isRiskConfirmed, isRiskIgnored } = useContext(TxSecurityContext)

  if (isRiskConfirmed || !isRiskIgnored) {
    return null
  }

  return <ErrorMessage level="warning">Please acknowledge the risk before proceeding.</ErrorMessage>
}

export default RiskConfirmationError
</file>

<file path="src/components/tx/SignOrExecuteForm/SignForm.tsx">
import madProps from '@/utils/mad-props'
import { type ReactElement, type SyntheticEvent, useContext, useMemo, useState } from 'react'
import { CircularProgress, Box, Button, Divider, Tooltip } from '@mui/material'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { trackError, Errors } from '@/services/exceptions'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import CheckWallet from '@/components/common/CheckWallet'
import { useAlreadySigned, useTxActions } from './hooks'
import type { SignOrExecuteProps } from './SignOrExecuteForm'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { TxModalContext } from '@/components/tx-flow'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxSecurityContext } from '../security/shared/TxSecurityContext'
import NonOwnerError from '@/components/tx/SignOrExecuteForm/NonOwnerError'
import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'
import BatchButton from '@/components/tx-flow/actions/Batching/BatchButton'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { isWalletRejection } from '@/utils/wallets'
import { useSigner } from '@/hooks/wallets/useWallet'
import { NestedTxSuccessScreenFlow } from '@/components/tx-flow/flows'
import { useValidateTxData } from '@/hooks/useValidateTxData'
import { TxCardActions } from '@/components/tx-flow/common/TxCard'

export const SignForm = ({
  safeTx,
  txId,
  onSubmit,
  disableSubmit = false,
  origin,
  isBatch,
  isBatchable,
  isCreation,
  isOwner,
  txActions,
  txSecurity,
  tooltip,
}: SignOrExecuteProps & {
  isOwner: ReturnType<typeof useIsSafeOwner>
  txActions: ReturnType<typeof useTxActions>
  txSecurity: ReturnType<typeof useTxSecurityContext>
  isCreation?: boolean
  safeTx?: SafeTransaction
  tooltip?: string
}): ReactElement => {
  // Form state
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [submitError, setSubmitError] = useState<Error | undefined>()
  const [isRejectedByUser, setIsRejectedByUser] = useState<Boolean>(false)

  const [validationResult, , validationLoading] = useValidateTxData(txId)
  const validationError = useMemo(
    () => (validationResult !== undefined ? new Error(validationResult) : undefined),
    [validationResult],
  )

  // Hooks
  const { signTx, addToBatch } = txActions
  const { setTxFlow } = useContext(TxModalContext)
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = txSecurity
  const hasSigned = useAlreadySigned(safeTx)
  const signer = useSigner()

  // On modal submit
  const handleSubmit = async (e: SyntheticEvent, isAddingToBatch = false) => {
    e.preventDefault()

    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    if (!safeTx || validationError) return

    setIsSubmittable(false)
    setSubmitError(undefined)
    setIsRejectedByUser(false)

    let resultTxId: string
    try {
      resultTxId = await (isAddingToBatch ? addToBatch(safeTx, origin) : signTx(safeTx, txId, origin))
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        trackError(Errors._804, err)
        setSubmitError(err)
      }
      setIsSubmittable(true)
      return
    }

    // On successful sign
    if (!isAddingToBatch) {
      onSubmit?.(resultTxId)
    }

    if (!isAddingToBatch && signer?.isSafe) {
      setTxFlow(<NestedTxSuccessScreenFlow txId={resultTxId} />, undefined, false)
    } else {
      setTxFlow(undefined)
    }
  }

  const onBatchClick = (e: SyntheticEvent) => {
    handleSubmit(e, true)
  }

  const cannotPropose = !isOwner
  const submitDisabled =
    !safeTx ||
    !isSubmittable ||
    disableSubmit ||
    cannotPropose ||
    (needsRiskConfirmation && !isRiskConfirmed) ||
    validationError !== undefined ||
    validationLoading

  return (
    <form onSubmit={handleSubmit}>
      {hasSigned && <ErrorMessage level="warning">You have already signed this transaction.</ErrorMessage>}

      {cannotPropose ? (
        <NonOwnerError />
      ) : (
        submitError && (
          <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
        )
      )}

      {isRejectedByUser && (
        <Box mt={1}>
          <WalletRejectionError />
        </Box>
      )}

      {validationError !== undefined && (
        <ErrorMessage error={validationError}>Error validating transaction data</ErrorMessage>
      )}

      <Divider className={commonCss.nestedDivider} sx={{ pt: 3 }} />

      <TxCardActions>
        {/* Batch button */}
        {isCreation && !isBatch && (
          <BatchButton
            onClick={onBatchClick}
            disabled={submitDisabled || !isBatchable}
            tooltip={!isBatchable ? `Cannot batch this type of transaction` : undefined}
          />
        )}

        {/* Submit button */}
        <CheckWallet checkNetwork={!submitDisabled}>
          {(isOk) => (
            <Tooltip title={tooltip} placement="top">
              <span>
                <Button
                  data-testid="sign-btn"
                  variant="contained"
                  type="submit"
                  disabled={!isOk || submitDisabled}
                  sx={{ minWidth: '82px', order: '1', width: ['100%', '100%', '100%', 'auto'] }}
                >
                  {!isSubmittable ? <CircularProgress size={20} /> : 'Sign'}
                </Button>
              </span>
            </Tooltip>
          )}
        </CheckWallet>
      </TxCardActions>
    </form>
  )
}

const useTxSecurityContext = () => useContext(TxSecurityContext)

export default madProps(SignForm, {
  isOwner: useIsSafeOwner,
  txActions: useTxActions,
  txSecurity: useTxSecurityContext,
})
</file>

<file path="src/components/tx/SignOrExecuteForm/SignOrExecuteForm.tsx">
import ProposerForm from '@/components/tx-flow/actions/Propose/ProposerForm'
import CounterfactualForm from '@/features/counterfactual/CounterfactualForm'
import { useIsWalletProposer } from '@/hooks/useProposers'
import useSafeInfo from '@/hooks/useSafeInfo'
import { type ReactElement, type ReactNode, useState, useContext, useCallback } from 'react'
import madProps from '@/utils/mad-props'
import ExecuteCheckbox from '../ExecuteCheckbox'
import { useImmediatelyExecutable, useValidateNonce } from './hooks'
import ExecuteForm from '@/components/tx-flow/actions/Execute/ExecuteForm'
import SignForm from './SignForm'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import ErrorMessage from '../ErrorMessage'
import TxChecks from '@/components/tx-flow/features/TxChecks/TxChecks'
import TxCard from '@/components/tx-flow/common/TxCard'
import ConfirmationTitle, { ConfirmationTitleTypes } from '@/components/tx/SignOrExecuteForm/ConfirmationTitle'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'
import UnknownContractError from './UnknownContractError'
import { ErrorBoundary } from '@sentry/react'
import ApprovalEditor from '../ApprovalEditor'
import { isDelegateCall } from '@/services/tx/tx-sender/sdk'
import useChainId from '@/hooks/useChainId'
import ExecuteThroughRoleForm from '@/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm'
import {
  findAllowingRole,
  findMostLikelyRole,
  useRoles,
} from '@/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/hooks'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { BlockaidBalanceChanges } from '../security/blockaid/BlockaidBalanceChange'
import { Blockaid } from '../security/blockaid'
import { useLazyGetTransactionDetailsQuery } from '@/store/api/gateway'
import { useApprovalInfos } from '../ApprovalEditor/hooks/useApprovalInfos'
import type { TransactionDetails, TransactionPreview } from '@safe-global/safe-gateway-typescript-sdk'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import ConfirmationView from '../confirmation-views'
import { SignerForm } from '@/components/tx-flow/features/SignerSelect/SignerForm'
import { useSigner } from '@/hooks/wallets/useWallet'
import { trackTxEvents } from './tracking'
import { TxNoteForm, encodeTxNote, trackAddNote } from '@/features/tx-notes'

export type SubmitCallback = (txId: string, isExecuted?: boolean) => void

export type SignOrExecuteProps = {
  txId?: string
  onSubmit?: SubmitCallback
  children?: ReactNode
  isExecutable?: boolean
  isRejection?: boolean
  isBatch?: boolean
  isBatchable?: boolean
  onlyExecute?: boolean
  disableSubmit?: boolean
  origin?: string
}

export const SignOrExecuteForm = ({
  chainId,
  safeTx,
  safeTxError,
  onSubmit,
  isCreation,
  ...props
}: SignOrExecuteProps & {
  chainId: ReturnType<typeof useChainId>
  safeTx: ReturnType<typeof useSafeTx>
  safeTxError: ReturnType<typeof useSafeTxError>
  isCreation?: boolean
  txDetails?: TransactionDetails
  txPreview?: TransactionPreview
}): ReactElement => {
  const [customOrigin, setCustomOrigin] = useState<string | undefined>(props.origin)
  const { transactionExecution } = useAppSelector(selectSettings)
  const [shouldExecute, setShouldExecute] = useState<boolean>(transactionExecution)
  const isNewExecutableTx = useImmediatelyExecutable() && isCreation
  const isCorrectNonce = useValidateNonce(safeTx)
  const isBatchable = props.isBatchable !== false && safeTx && !isDelegateCall(safeTx)

  const [trigger] = useLazyGetTransactionDetailsQuery()
  const [readableApprovals] = useApprovalInfos({ safeTransaction: safeTx })
  const isApproval = readableApprovals && readableApprovals.length > 0
  const { safe } = useSafeInfo()
  const isSafeOwner = useIsSafeOwner()
  const signer = useSigner()
  const isProposer = useIsWalletProposer()
  const isProposing = isProposer && !isSafeOwner && isCreation
  const isCounterfactualSafe = !safe.deployed

  // Check if a Zodiac Roles mod is enabled and if the user is a member of any role that allows the transaction
  const roles = useRoles(
    !isCounterfactualSafe && isCreation && !(isNewExecutableTx && isSafeOwner) ? safeTx : undefined,
  )
  const allowingRole = findAllowingRole(roles)
  const mostLikelyRole = findMostLikelyRole(roles)
  const canExecuteThroughRole = !!allowingRole || (!!mostLikelyRole && !isSafeOwner)
  const preferThroughRole = canExecuteThroughRole && !isSafeOwner // execute through role if a non-owner role member wallet is connected

  // If checkbox is checked and the transaction is executable, execute it, otherwise sign it
  const canExecute = isCorrectNonce && (props.isExecutable || isNewExecutableTx)
  const willExecute = (props.onlyExecute || shouldExecute) && canExecute && !preferThroughRole
  const willExecuteThroughRole =
    (props.onlyExecute || shouldExecute) && canExecuteThroughRole && (!canExecute || preferThroughRole)

  const onFormSubmit = useCallback(
    async (txId: string, isExecuted = false, isRoleExecution = false, isProposerCreation = false) => {
      onSubmit?.(txId, isExecuted)

      const { data: details } = await trigger({ chainId, txId })
      // Track tx event
      trackTxEvents(
        details,
        !!isCreation,
        isExecuted,
        isRoleExecution,
        isProposerCreation,
        !!signer?.isSafe,
        customOrigin,
      )

      if (customOrigin !== props.origin) {
        trackAddNote()
      }
    },
    [chainId, isCreation, onSubmit, trigger, signer?.isSafe, customOrigin, props.origin],
  )

  const onRoleExecutionSubmit = useCallback<typeof onFormSubmit>(
    (txId, isExecuted) => onFormSubmit(txId, isExecuted, true),
    [onFormSubmit],
  )

  const onProposerFormSubmit = useCallback<typeof onFormSubmit>(
    (txId, isExecuted) => onFormSubmit(txId, isExecuted, false, true),
    [onFormSubmit],
  )

  const onNoteChange = useCallback(
    (note: string) => {
      setCustomOrigin(encodeTxNote(note, props.origin))
    },
    [setCustomOrigin, props.origin],
  )

  const getForm = () => {
    const commonProps = {
      ...props,
      safeTx,
      isCreation,
      origin: customOrigin,
      onSubmit: onFormSubmit,
    }
    if (isCounterfactualSafe && !isProposing) {
      return <CounterfactualForm {...commonProps} onlyExecute />
    }

    if (!isCounterfactualSafe && willExecute && !isProposing) {
      return (
        <ExecuteForm
          {...commonProps}
          options={[{ label: 'Execute', id: 'execute' }]}
          slotId="execute"
          onChange={() => {}}
          onSubmit={() => {}}
          onSubmitSuccess={({ txId, isExecuted } = {}) => onFormSubmit(txId!, isExecuted)}
        />
      )
    }

    if (!isCounterfactualSafe && willExecuteThroughRole) {
      return (
        <ExecuteThroughRoleForm
          {...commonProps}
          role={(allowingRole || mostLikelyRole)!}
          safeTxError={safeTxError}
          onSubmit={onRoleExecutionSubmit}
        />
      )
    }

    if (!isCounterfactualSafe && !willExecute && !willExecuteThroughRole && !isProposing) {
      return <SignForm {...commonProps} isBatchable={isBatchable} />
    }

    if (isProposing) {
      return <ProposerForm {...commonProps} onSubmit={onProposerFormSubmit} />
    }
  }

  return (
    <>
      <TxCard>
        {props.children}

        <ConfirmationView
          isCreation={isCreation}
          txDetails={props.txDetails}
          txPreview={props.txPreview}
          safeTx={safeTx}
          isBatch={props.isBatch}
          isApproval={isApproval}
        >
          {!props.isRejection && (
            <ErrorBoundary fallback={<div>Error parsing data</div>}>
              {isApproval && <ApprovalEditor safeTransaction={safeTx} />}
            </ErrorBoundary>
          )}
        </ConfirmationView>

        {!isCounterfactualSafe && !props.isRejection && <BlockaidBalanceChanges />}
      </TxCard>

      {!isCounterfactualSafe && !props.isRejection && safeTx && <TxChecks transaction={safeTx} />}

      <TxNoteForm isCreation={isCreation ?? false} onChange={onNoteChange} txDetails={props.txDetails} />

      <SignerForm willExecute={willExecute} />

      <TxCard>
        <ConfirmationTitle
          variant={
            isProposing
              ? ConfirmationTitleTypes.propose
              : willExecute
                ? ConfirmationTitleTypes.execute
                : ConfirmationTitleTypes.sign
          }
          isCreation={isCreation}
        />

        {safeTxError && (
          <ErrorMessage error={safeTxError}>
            This transaction will most likely fail. To save gas costs, avoid confirming the transaction.
          </ErrorMessage>
        )}

        {(canExecute || canExecuteThroughRole) && !props.onlyExecute && !isCounterfactualSafe && !isProposing && (
          <ExecuteCheckbox onChange={setShouldExecute} />
        )}

        <NetworkWarning />

        <UnknownContractError txData={props.txDetails?.txData ?? props.txPreview?.txData} />

        <Blockaid />

        {getForm()}
      </TxCard>
    </>
  )
}

const useSafeTx = () => useContext(SafeTxContext).safeTx
const useSafeTxError = () => useContext(SafeTxContext).safeTxError

export default madProps(SignOrExecuteForm, {
  chainId: useChainId,
  safeTx: useSafeTx,
  safeTxError: useSafeTxError,
})
</file>

<file path="src/components/tx/SignOrExecuteForm/SignOrExecuteFormV2.tsx">
import ProposerForm from '@/components/tx-flow/actions/Propose/ProposerForm'
import CounterfactualForm from '@/features/counterfactual/CounterfactualForm'
import { useIsWalletProposer } from '@/hooks/useProposers'
import useSafeInfo from '@/hooks/useSafeInfo'
import { type ReactElement, type ReactNode, useContext, useCallback } from 'react'
import madProps from '@/utils/mad-props'
import { useImmediatelyExecutable, useValidateNonce } from './hooks'
import ExecuteForm from '@/components/tx-flow/actions/Execute/ExecuteForm'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'
import useChainId from '@/hooks/useChainId'
import ExecuteThroughRoleForm from '@/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm'
import {
  findAllowingRole,
  findMostLikelyRole,
  useRoles,
} from '@/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/hooks'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useLazyGetTransactionDetailsQuery } from '@/store/api/gateway'
import type { TransactionDetails, TransactionPreview } from '@safe-global/safe-gateway-typescript-sdk'
import { useSigner } from '@/hooks/wallets/useWallet'
import { trackTxEvents } from './tracking'
import SignForm from './SignForm'

export type SubmitCallback = (txId: string, isExecuted?: boolean) => void

export type SignOrExecuteProps = {
  txId?: string
  onSubmit?: SubmitCallback
  children?: ReactNode
  isExecutable?: boolean
  isRejection?: boolean
  onlyExecute?: boolean
  disableSubmit?: boolean
  origin?: string
  tooltip?: string
  isMassPayout?: boolean
}

export const SignOrExecuteFormV2 = ({
  chainId,
  safeTx,
  safeTxError,
  onSubmit,
  isCreation,
  origin,
  isMassPayout = false,
  ...props
}: SignOrExecuteProps & {
  chainId: ReturnType<typeof useChainId>
  safeTx: ReturnType<typeof useSafeTx>
  safeTxError: ReturnType<typeof useSafeTxError>
  isCreation?: boolean
  txDetails?: TransactionDetails
  txPreview?: TransactionPreview
}): ReactElement | undefined => {
  const { transactionExecution: shouldExecute } = useAppSelector(selectSettings)
  const isNewExecutableTx = useImmediatelyExecutable() && isCreation
  const isCorrectNonce = useValidateNonce(safeTx)

  const [trigger] = useLazyGetTransactionDetailsQuery()
  const { safe } = useSafeInfo()
  const isSafeOwner = useIsSafeOwner()
  const signer = useSigner()
  const isProposer = useIsWalletProposer()
  const isProposing = isProposer && !isSafeOwner && !!isCreation
  const isCounterfactualSafe = !safe.deployed

  // Check if a Zodiac Roles mod is enabled and if the user is a member of any role that allows the transaction
  const roles = useRoles(
    !isCounterfactualSafe && isCreation && !(isNewExecutableTx && isSafeOwner) ? safeTx : undefined,
  )
  const allowingRole = findAllowingRole(roles)
  const mostLikelyRole = findMostLikelyRole(roles)
  const canExecuteThroughRole = !!allowingRole || (!!mostLikelyRole && !isSafeOwner)
  const preferThroughRole = canExecuteThroughRole && !isSafeOwner // execute through role if a non-owner role member wallet is connected

  // If checkbox is checked and the transaction is executable, execute it, otherwise sign it
  const canExecute = isCorrectNonce && (props.isExecutable || isNewExecutableTx)
  const willExecute = (props.onlyExecute || shouldExecute) && canExecute && !preferThroughRole
  const willExecuteThroughRole =
    (props.onlyExecute || shouldExecute) && canExecuteThroughRole && (!canExecute || preferThroughRole)

  const onFormSubmit = useCallback(
    async (txId: string, isExecuted = false, isRoleExecution = false, isProposerCreation = false) => {
      onSubmit?.(txId, isExecuted)

      const { data: details } = await trigger({ chainId, txId })
      // Track tx event
      trackTxEvents(
        details,
        !!isCreation,
        isExecuted,
        isRoleExecution,
        isProposerCreation,
        !!signer?.isSafe,
        origin,
        isMassPayout,
      )
    },
    [chainId, isCreation, onSubmit, trigger, signer?.isSafe, origin, isMassPayout],
  )

  const onRoleExecutionSubmit = useCallback<typeof onFormSubmit>(
    (txId, isExecuted) => onFormSubmit(txId, isExecuted, true),
    [onFormSubmit],
  )

  const onProposerFormSubmit = useCallback<typeof onFormSubmit>(
    (txId, isExecuted) => onFormSubmit(txId, isExecuted, false, true),
    [onFormSubmit],
  )

  const commonProps = {
    ...props,
    safeTx,
    isCreation,
    origin,
    onSubmit: onFormSubmit,
  }
  if (isCounterfactualSafe && !isProposing) {
    return <CounterfactualForm {...commonProps} onlyExecute />
  }

  if (!isCounterfactualSafe && willExecute && !isProposing) {
    return (
      <ExecuteForm
        {...commonProps}
        options={[{ label: 'Execute', id: 'execute' }]}
        slotId="execute"
        onChange={() => {}}
        onSubmit={() => {}}
        onSubmitSuccess={({ txId, isExecuted } = {}) => onFormSubmit(txId!, isExecuted)}
      />
    )
  }

  if (!isCounterfactualSafe && willExecuteThroughRole) {
    return (
      <ExecuteThroughRoleForm
        {...commonProps}
        role={(allowingRole || mostLikelyRole)!}
        safeTxError={safeTxError}
        onSubmit={onRoleExecutionSubmit}
      />
    )
  }

  if (!isCounterfactualSafe && !willExecute && !willExecuteThroughRole && !isProposing) {
    return <SignForm {...commonProps} />
  }

  if (isProposing) {
    return <ProposerForm {...commonProps} onSubmit={onProposerFormSubmit} />
  }
}

const useSafeTx = () => useContext(SafeTxContext).safeTx
const useSafeTxError = () => useContext(SafeTxContext).safeTxError

export default madProps(SignOrExecuteFormV2, {
  chainId: useChainId,
  safeTx: useSafeTx,
  safeTxError: useSafeTxError,
})
</file>

<file path="src/components/tx/SignOrExecuteForm/SignOrExecuteSkeleton.tsx">
import LoadingSpinner, { SpinnerStatus } from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner'
import TxCard from '@/components/tx-flow/common/TxCard'
import { Box } from '@mui/material'

const SignOrExecuteSkeleton = () => (
  <TxCard>
    <Box minHeight="38svh" display="flex" alignItems="center" justifyContent="center" mb={5}>
      <LoadingSpinner status={SpinnerStatus.PROCESSING} />
    </Box>
  </TxCard>
)

export default SignOrExecuteSkeleton
</file>

<file path="src/components/tx/SignOrExecuteForm/styles.module.css">
.wrapper {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  margin-bottom: var(--space-1);
}

.icon {
  width: 34px;
  height: 34px;
  border-radius: 6px;
  display: flex;
  flex-shrink: 0;
  align-items: center;
  justify-content: center;
}

.sign {
  background-color: var(--color-info-background);
}

.sign svg {
  color: var(--color-info-dark);
}

.execute {
  background-color: var(--color-secondary-background);
}

.execute svg {
  color: var(--color-secondary-dark);
}

[data-theme='dark'] .execute {
  background-color: var(--color-success-background);
}

[data-theme='dark'] .execute svg {
  color: var(--color-success-dark);
}
</file>

<file path="src/components/tx/SignOrExecuteForm/tracking.ts">
import { trackEvent } from '@/services/analytics'
import { TX_EVENTS } from '@/services/analytics/events/transactions'
import { getTransactionTrackingType } from '@/services/analytics/tx-tracking'
import { isNestedConfirmationTxInfo } from '@/utils/transaction-guards'
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'

function getCreationEvent(args: { isParentSigner: boolean; isRoleExecution: boolean; isProposerCreation: boolean }) {
  if (args.isParentSigner) {
    return TX_EVENTS.CREATE_VIA_PARENT
  }
  if (args.isRoleExecution) {
    return TX_EVENTS.CREATE_VIA_ROLE
  }
  if (args.isProposerCreation) {
    return TX_EVENTS.CREATE_VIA_PROPOSER
  }
  return TX_EVENTS.CREATE
}

function getConfirmationEvent(args: { isParentSigner: boolean; isNestedConfirmation: boolean }) {
  if (args.isParentSigner) {
    return TX_EVENTS.CONFIRM_VIA_PARENT
  }
  if (args.isNestedConfirmation) {
    return TX_EVENTS.CONFIRM_IN_PARENT
  }
  return TX_EVENTS.CONFIRM
}

function getExecutionEvent(args: { isParentSigner: boolean; isNestedConfirmation: boolean; isRoleExecution: boolean }) {
  if (args.isParentSigner) {
    return TX_EVENTS.EXECUTE_VIA_PARENT
  }
  if (args.isNestedConfirmation) {
    return TX_EVENTS.EXECUTE_IN_PARENT
  }
  if (args.isRoleExecution) {
    return TX_EVENTS.EXECUTE_VIA_ROLE
  }
  return TX_EVENTS.EXECUTE
}

export function trackTxEvents(
  details: TransactionDetails | undefined,
  isCreation: boolean,
  isExecuted: boolean,
  isRoleExecution: boolean,
  isProposerCreation: boolean,
  isParentSigner: boolean,
  origin?: string,
  isMassPayout: boolean = false,
) {
  const isNestedConfirmation = !!details && isNestedConfirmationTxInfo(details.txInfo)

  const creationEvent = getCreationEvent({ isParentSigner, isRoleExecution, isProposerCreation })
  const confirmationEvent = getConfirmationEvent({ isParentSigner, isNestedConfirmation })
  const executionEvent = getExecutionEvent({ isParentSigner, isNestedConfirmation, isRoleExecution })

  const event = (() => {
    if (isCreation) {
      return creationEvent
    }
    if (isExecuted) {
      return executionEvent
    }
    return confirmationEvent
  })()

  const txType = getTransactionTrackingType(details, origin, isMassPayout)
  trackEvent({ ...event, label: txType })

  // Immediate execution on creation
  if (isCreation && isExecuted) {
    trackEvent({ ...executionEvent, label: txType })
  }
}
</file>

<file path="src/components/tx/SignOrExecuteForm/UnknownContractError.tsx">
import { useMemo, type ReactElement } from 'react'
import type { TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import ExternalLink from '@/components/common/ExternalLink'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import ErrorMessage from '../ErrorMessage'
import { isMigrationToL2Possible } from '@/services/contracts/safeContracts'
import { isValidMasterCopy } from '@safe-global/utils/services/contracts/safeContracts'
import { AlertTitle, Typography } from '@mui/material'
import { isMigrateL2SingletonCall } from '@/utils/safe-migrations'
import { getExplorerLink } from '@safe-global/utils/utils/gateway'

const UnknownContractError = ({ txData }: { txData: TransactionData | undefined }): ReactElement | null => {
  const { safe, safeAddress } = useSafeInfo()
  const currentChain = useCurrentChain()

  const isMigrationTx = useMemo((): boolean => {
    return txData !== undefined && isMigrateL2SingletonCall(txData)
  }, [txData])

  // Unsupported base contract
  const isUnknown = !isValidMasterCopy(safe.implementationVersionState)
  const isMigrationPossible = isMigrationToL2Possible(safe)

  if (!isUnknown || isMigrationTx) return null

  return (
    <ErrorMessage level="error">
      <AlertTitle>
        <Typography
          variant="subtitle1"
          sx={{
            fontWeight: 700,
          }}
        >
          This Safe Account was created with an unsupported base contract.
        </Typography>
      </AlertTitle>
      {isMigrationPossible ? (
        <>
          The Safe Account can be migrated to use the supported base contract. We advise to do that in the Safe&apos;s
          settings before executing other transactions.
        </>
      ) : (
        <>
          It should <b>ONLY</b> be used for fund recovery. Transactions will execute but the transaction list may not
          update. Transaction success can be verified on the{' '}
          <ExternalLink
            href={currentChain ? getExplorerLink(safeAddress, currentChain.blockExplorerUriTemplate).href : ''}
          >
            {currentChain?.chainName} explorer
          </ExternalLink>
          .
        </>
      )}
    </ErrorMessage>
  )
}

export default UnknownContractError
</file>

<file path="src/components/tx/SignOrExecuteForm/WalletRejectionError.tsx">
import ErrorMessage from '@/components/tx/ErrorMessage'

const WalletRejectionError = () => {
  return <ErrorMessage>User rejected signing.</ErrorMessage>
}

export default WalletRejectionError
</file>

<file path="src/components/tx/SponsoredBy/index.tsx">
import chains from '@/config/chains'
import css from './styles.module.css'

export const RELAY_SPONSORS = {
  [chains.gno]: {
    name: 'Gnosis',
    logo: '/images/common/gnosis-chain-logo.png',
  },
  default: {
    name: 'Safe',
    logo: '/images/logo-no-text.svg',
  },
}

const SponsoredBy = ({ chainId }: { chainId: string }) => {
  const sponsor = RELAY_SPONSORS[chainId] || RELAY_SPONSORS.default

  return (
    <>
      <img src={sponsor.logo} alt={sponsor.name} className={css.logo} /> {sponsor.name}
    </>
  )
}

export default SponsoredBy
</file>

<file path="src/components/tx/SponsoredBy/styles.module.css">
.sponsoredBy {
  padding: 8px 12px;
  background-color: var(--color-background-main);
  border-bottom-left-radius: 6px;
  border-bottom-right-radius: 6px;
  border-top: 1px solid var(--color-border-light);
  display: flex;
}

.icon {
  margin-right: 8px;
  margin-top: -1px;
  color: var(--color-text-secondary);
  width: 24px;
}

.logo {
  width: 16px;
  height: 16px;
  margin-left: 2px;
}

[data-theme='dark'] .logo {
  filter: brightness(0) invert(1);
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme='light']) .logo {
    filter: brightness(0) invert(1);
  }
}
</file>

<file path="src/components/tx/SuccessMessage/index.tsx">
import { type ReactElement, type ReactNode } from 'react'
import { Typography, SvgIcon } from '@mui/material'
import classNames from 'classnames'
import CheckIcon from '@/public/images/common/check.svg'
import css from './styles.module.css'

const SuccessMessage = ({ children, className }: { children: ReactNode; className?: string }): ReactElement => {
  return (
    <div className={classNames(css.container, className)}>
      <div className={css.message}>
        <SvgIcon component={CheckIcon} color="success" inheritViewBox fontSize="small" />

        <Typography variant="body2" width="100%">
          {children}
        </Typography>
      </div>
    </div>
  )
}

export default SuccessMessage
</file>

<file path="src/components/tx/SuccessMessage/styles.module.css">
.container {
  background-color: var(--color-success-background);
  padding: var(--space-2);
  border-radius: 4px;
}

.message {
  display: flex;
  align-items: flex-start;
  gap: var(--space-1);
}

.message svg {
  margin-top: 4px;
}

.details {
  margin-top: var(--space-1);
  color: var(--color-primary-light);
  word-break: break-word;
}
</file>

<file path="src/components/tx-flow/actions/Batching/BatchButton.tsx">
import { type SyntheticEvent } from 'react'
import { Box, Button, Divider, SvgIcon, Tooltip } from '@mui/material'
import PlusIcon from '@/public/images/common/plus.svg'
import Track from '@/components/common/Track'
import { BATCH_EVENTS } from '@/services/analytics'

const BatchButton = ({
  onClick,
  disabled,
  tooltip,
}: {
  onClick: (e: SyntheticEvent) => void
  disabled?: boolean
  tooltip?: string
}) => (
  <>
    <Tooltip title={tooltip} placement="top">
      <span>
        <Track {...BATCH_EVENTS.BATCH_APPEND}>
          <Button
            variant="outlined"
            onClick={onClick}
            disabled={disabled}
            sx={{ display: ['none', 'flex'], width: ['100%', '100%', '100%', 'auto'] }}
          >
            <SvgIcon component={PlusIcon} inheritViewBox fontSize="small" sx={{ mr: 1 }} />
            Add to batch
          </Button>
        </Track>
      </span>
    </Tooltip>
    <Box display={['none', 'flex']} flexDirection="column" justifyContent="center" color="border.main">
      {' '}
      <Divider
        sx={{
          '&:before': {
            display: { sx: 'block', lg: 'none' },
          },
        }}
      >
        or
      </Divider>
    </Box>
  </>
)

export default BatchButton
</file>

<file path="src/components/tx-flow/actions/Batching/index.tsx">
import { useContext, type SyntheticEvent } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useTxActions } from '@/components/tx/SignOrExecuteForm/hooks'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { isDelegateCall } from '@/services/tx/tx-sender/sdk'
import { TxModalContext } from '@/components/tx-flow'
import { TxFlowContext } from '../../TxFlowProvider'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { type SlotComponentProps, SlotName, withSlot } from '../../slots'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { Errors, logError } from '@/services/exceptions'
import SplitMenuButton from '@/components/common/SplitMenuButton'
import { BATCH_EVENTS, trackEvent } from '@/services/analytics'
import { TxCardActions } from '../../common/TxCard'
import { Box, Divider } from '@mui/material'
import commonCss from '@/components/tx-flow/common/styles.module.css'

const Batching = ({
  onSubmit,
  onSubmitSuccess,
  options = [],
  onChange,
  disabled = false,
  slotId,
}: SlotComponentProps<SlotName.ComboSubmit>) => {
  const { setTxFlow } = useContext(TxModalContext)
  const { addToBatch } = useTxActions()
  const { safeTx } = useContext(SafeTxContext)
  const { isSubmittable, setIsSubmittable, setSubmitError, setIsRejectedByUser } = useContext(TxFlowContext)

  const isBatchable = !!safeTx && !isDelegateCall(safeTx)

  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()

    if (!safeTx) return

    onSubmit?.()

    trackEvent(BATCH_EVENTS.BATCH_APPEND)

    setIsSubmittable(false)
    setIsRejectedByUser(false)
    setSubmitError(undefined)

    try {
      await addToBatch(safeTx, origin)
    } catch (_err) {
      const err = asError(_err)
      logError(Errors._819, err)
      setSubmitError(err)

      setIsSubmittable(true)
      return
    }

    onSubmitSuccess?.({ isExecuted: false })

    setIsSubmittable(true)

    setTxFlow(undefined)
  }

  return (
    <Box>
      <Divider className={commonCss.nestedDivider} />

      <TxCardActions>
        <SplitMenuButton
          onClick={(_, e) => handleSubmit(e)}
          selected={slotId}
          onChange={({ id }) => onChange(id)}
          options={options}
          disabled={!isSubmittable || !isBatchable || disabled}
          loading={!isSubmittable}
          tooltip={!isBatchable ? `Cannot batch this type of transaction` : undefined}
        />
      </TxCardActions>
    </Box>
  )
}

const useShouldRegisterSlot = () => {
  const isCounterfactualSafe = useIsCounterfactualSafe()
  const { isBatch, isProposing, willExecuteThroughRole, isCreation } = useContext(TxFlowContext)
  const isOwner = useIsSafeOwner()

  return isOwner && isCreation && !isBatch && !isCounterfactualSafe && !willExecuteThroughRole && !isProposing
}

const BatchingSlot = withSlot({
  Component: Batching,
  label: 'Add to batch',
  slotName: SlotName.ComboSubmit,
  id: 'batching',
  useSlotCondition: useShouldRegisterSlot,
})

export default BatchingSlot
</file>

<file path="src/components/tx-flow/actions/Execute/ExecuteForm.tsx">
import useWalletCanPay from '@/hooks/useWalletCanPay'
import madProps from '@/utils/mad-props'
import { type ReactElement, type SyntheticEvent, useContext, useState } from 'react'
import { Box, CardActions, Divider, Tooltip } from '@mui/material'
import classNames from 'classnames'

import ErrorMessage from '@/components/tx/ErrorMessage'
import { trackError, Errors } from '@/services/exceptions'
import { useCurrentChain } from '@/hooks/useChains'
import { getTxOptions } from '@/utils/transactions'
import useIsValidExecution from '@/hooks/useIsValidExecution'
import CheckWallet from '@/components/common/CheckWallet'
import { useIsExecutionLoop, useTxActions } from '@/components/tx/SignOrExecuteForm/hooks'
import { useRelaysBySafe } from '@/hooks/useRemainingRelays'
import useWalletCanRelay from '@/hooks/useWalletCanRelay'
import { ExecutionMethod, ExecutionMethodSelector } from '@/components/tx/ExecutionMethodSelector'
import { hasRemainingRelays } from '@/utils/relaying'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { TxModalContext } from '@/components/tx-flow'
import { SuccessScreenFlow } from '@/components/tx-flow/flows'
import useGasLimit from '@/hooks/useGasLimit'
import AdvancedParams, { useAdvancedParams } from '@/components/tx/AdvancedParams'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { isWalletRejection } from '@/utils/wallets'

import css from './styles.module.css'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import NonOwnerError from '@/components/tx/SignOrExecuteForm/NonOwnerError'
import SplitMenuButton from '@/components/common/SplitMenuButton'
import type { SlotComponentProps, SlotName } from '../../slots'
import { TxFlowContext } from '../../TxFlowProvider'

export const ExecuteForm = ({
  safeTx,
  txId,
  onSubmit,
  onSubmitSuccess,
  options = [],
  onChange,
  disableSubmit = false,
  origin,
  onlyExecute,
  isCreation,
  isOwner,
  isExecutionLoop,
  slotId,
  txActions,
  tooltip,
  txSecurity,
}: SlotComponentProps<SlotName.ComboSubmit> & {
  txId?: string
  disableSubmit?: boolean
  onlyExecute?: boolean
  origin?: string
  isOwner: ReturnType<typeof useIsSafeOwner>
  isExecutionLoop: ReturnType<typeof useIsExecutionLoop>
  txActions: ReturnType<typeof useTxActions>
  txSecurity: ReturnType<typeof useTxSecurityContext>
  isCreation?: boolean
  safeTx?: SafeTransaction
  tooltip?: string
}): ReactElement => {
  // Form state
  const [isSubmittableLocal, setIsSubmittableLocal] = useState<boolean>(true) // TODO: remove this local state and use only the one from TxFlowContext when tx-flow refactor is done

  // Hooks
  const currentChain = useCurrentChain()
  const { executeTx } = txActions
  const { setTxFlow } = useContext(TxModalContext)
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = txSecurity
  const { isSubmittable, setIsSubmittable, setSubmitError, setIsRejectedByUser } = useContext(TxFlowContext)

  // We default to relay, but the option is only shown if we canRelay
  const [executionMethod, setExecutionMethod] = useState(ExecutionMethod.RELAY)

  // SC wallets can relay fully signed transactions
  const [walletCanRelay] = useWalletCanRelay(safeTx)
  const relays = useRelaysBySafe()
  // The transaction can/will be relayed
  const canRelay = walletCanRelay && hasRemainingRelays(relays[0])
  const willRelay = canRelay && executionMethod === ExecutionMethod.RELAY

  // Estimate gas limit
  const { gasLimit, gasLimitError } = useGasLimit(safeTx)
  const [advancedParams, setAdvancedParams] = useAdvancedParams(gasLimit)

  // Check if transaction will fail
  const { executionValidationError } = useIsValidExecution(
    safeTx,
    advancedParams.gasLimit ? advancedParams.gasLimit : undefined,
  )

  // On modal submit
  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()

    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    setIsSubmittable(false)
    setIsSubmittableLocal(false)
    setSubmitError(undefined)
    setIsRejectedByUser(false)

    const txOptions = getTxOptions(advancedParams, currentChain)

    onSubmit?.()

    let executedTxId: string
    try {
      executedTxId = await executeTx(txOptions, safeTx, txId, origin, willRelay)
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        trackError(Errors._804, err)
        setSubmitError(err)
      }

      setIsSubmittable(true)
      setIsSubmittableLocal(true)
      return
    }

    // On success
    onSubmitSuccess?.({ txId: executedTxId, isExecuted: true })
    setTxFlow(<SuccessScreenFlow txId={executedTxId} />, undefined, false)
  }

  const walletCanPay = useWalletCanPay({
    gasLimit,
    maxFeePerGas: advancedParams.maxFeePerGas,
  })

  const cannotPropose = !isOwner && !onlyExecute
  const submitDisabled =
    !safeTx ||
    !isSubmittable ||
    !isSubmittableLocal ||
    disableSubmit ||
    isExecutionLoop ||
    cannotPropose ||
    (needsRiskConfirmation && !isRiskConfirmed)

  return (
    <>
      <form onSubmit={handleSubmit}>
        <div className={classNames(commonCss.params, { [css.noBottomBorderRadius]: canRelay })}>
          <AdvancedParams
            willExecute
            params={advancedParams}
            recommendedGasLimit={gasLimit}
            onFormSubmit={setAdvancedParams}
            gasLimitError={gasLimitError}
            willRelay={willRelay}
          />

          {canRelay && (
            <div className={css.noTopBorder}>
              <ExecutionMethodSelector
                executionMethod={executionMethod}
                setExecutionMethod={setExecutionMethod}
                relays={relays[0]}
              />
            </div>
          )}
        </div>

        {/* Error messages */}
        {cannotPropose ? (
          <NonOwnerError />
        ) : isExecutionLoop ? (
          <ErrorMessage>
            Cannot execute a transaction from the Safe Account itself, please connect a different account.
          </ErrorMessage>
        ) : !walletCanPay && !willRelay ? (
          <ErrorMessage level="info">
            Your connected wallet doesn&apos;t have enough funds to execute this transaction.
          </ErrorMessage>
        ) : (
          (executionValidationError || gasLimitError) && (
            <ErrorMessage error={executionValidationError || gasLimitError}>
              This transaction will most likely fail.
              {` To save gas costs, ${isCreation ? 'avoid creating' : 'reject'} this transaction.`}
            </ErrorMessage>
          )
        )}

        <Divider className={commonCss.nestedDivider} sx={{ pt: 3 }} />

        <CardActions>
          {/* Submit button */}
          <CheckWallet allowNonOwner={onlyExecute} checkNetwork={!submitDisabled}>
            {(isOk) => (
              <Tooltip title={tooltip} placement="top">
                <Box sx={{ minWidth: '112px', width: ['100%', '100%', '100%', 'auto'] }}>
                  <SplitMenuButton
                    selected={slotId}
                    onChange={({ id }) => onChange?.(id)}
                    options={options}
                    disabled={!isOk || submitDisabled}
                    loading={!isSubmittable || !isSubmittableLocal}
                    tooltip={tooltip}
                  />
                </Box>
              </Tooltip>
            )}
          </CheckWallet>
        </CardActions>
      </form>
    </>
  )
}

const useTxSecurityContext = () => useContext(TxSecurityContext)

export default madProps(ExecuteForm, {
  isOwner: useIsSafeOwner,
  isExecutionLoop: useIsExecutionLoop,
  txActions: useTxActions,
  txSecurity: useTxSecurityContext,
})
</file>

<file path="src/components/tx-flow/actions/Execute/index.tsx">
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useCallback, useContext, useEffect } from 'react'
import { TxFlowContext } from '../../TxFlowProvider'
import ExecuteForm from './ExecuteForm'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { type SlotComponentProps, SlotName, withSlot } from '../../slots'
import type { SubmitCallback } from '../../TxFlow'

const Execute = ({
  onSubmit,
  onSubmitSuccess,
  disabled = false,
  onChange,
  ...props
}: SlotComponentProps<SlotName.ComboSubmit>) => {
  const { safeTx, txOrigin } = useContext(SafeTxContext)
  const { txId, isCreation, onlyExecute, isSubmittable, trackTxEvent, setShouldExecute } = useContext(TxFlowContext)

  useEffect(() => {
    setShouldExecute(true)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const handleSubmit = useCallback<SubmitCallback>(
    async ({ txId, isExecuted = false } = {}) => {
      onSubmitSuccess?.({ txId, isExecuted })
      trackTxEvent(txId!, isExecuted)
    },
    [onSubmitSuccess, trackTxEvent],
  )

  const onChangeSubmitOption = useCallback(
    async (option: string) => {
      // When changing to another submit option, we update the context to not execute the transaction
      setShouldExecute(false)
      onChange(option)
    },
    [setShouldExecute, onChange],
  )

  return (
    <ExecuteForm
      safeTx={safeTx}
      txId={txId}
      onSubmit={onSubmit}
      onSubmitSuccess={handleSubmit}
      disableSubmit={!isSubmittable || disabled}
      origin={txOrigin}
      onlyExecute={onlyExecute}
      isCreation={isCreation}
      onChange={onChangeSubmitOption}
      {...props}
    />
  )
}

const useShouldRegisterSlot = () => {
  const isCounterfactualSafe = useIsCounterfactualSafe()
  const { canExecute, isProposing } = useContext(TxFlowContext)

  return !isCounterfactualSafe && canExecute && !isProposing
}

const ExecuteSlot = withSlot({
  Component: Execute,
  slotName: SlotName.ComboSubmit,
  label: 'Execute',
  id: 'execute',
  useSlotCondition: useShouldRegisterSlot,
})

export default ExecuteSlot
</file>

<file path="src/components/tx-flow/actions/Execute/styles.module.css">
.noBottomBorderRadius :global(.MuiPaper-root) {
  border-bottom-left-radius: 0 !important;
  border-bottom-right-radius: 0 !important;
}

.noTopBorder > div {
  margin-top: -1px;
  border-top-left-radius: 0 !important;
  border-top-right-radius: 0 !important;
}
</file>

<file path="src/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/hooks.ts">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { Errors, logError } from '@/services/exceptions'
import { getModuleTransactionId } from '@/services/transactions'
import { backOff } from 'exponential-backoff'
import { useEffect, useMemo } from 'react'
import {
  type ChainId,
  chains,
  fetchRolesMod,
  Clearance,
  type RoleSummary,
  ExecutionOptions,
  Status,
} from 'zodiac-roles-deployments'
import {
  OperationType,
  type Transaction,
  type MetaTransactionData,
  type SafeTransaction,
} from '@safe-global/safe-core-sdk-types'
import { type JsonRpcProvider } from 'ethers'
import { KnownContracts, getModuleInstance } from '@gnosis.pm/zodiac'
import useWallet from '@/hooks/wallets/useWallet'
import { useHasFeature } from '@/hooks/useChains'
import { encodeMultiSendData } from '@safe-global/protocol-kit'
import { Multi_send__factory } from '@safe-global/utils/types/contracts'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'
import { FEATURES } from '@safe-global/utils/utils/chains'

const ROLES_V2_SUPPORTED_CHAINS = Object.keys(chains)
const multiSendInterface = Multi_send__factory.createInterface()

/**
 * Turns a Safe Transaction into a set of meta transactions, unbundling multisend calls
 */
export const useMetaTransactions = (safeTx?: SafeTransaction): MetaTransactionData[] => {
  const safeTxData = safeTx?.data
  return useMemo(() => {
    if (!safeTxData) return []

    const metaTx: MetaTransactionData = {
      to: safeTxData.to,
      value: safeTxData.value,
      data: safeTxData.data,
      operation: safeTxData.operation,
    }

    if (metaTx.operation === OperationType.DelegateCall) {
      // try decoding as multisend
      try {
        const baseTransactions = decodeMultiSendData(metaTx.data)
        if (baseTransactions.length > 0) {
          return baseTransactions.map((tx) => ({ ...tx, operation: OperationType.Call }))
        }
      } catch (e) {}
    }

    return [metaTx]
  }, [safeTxData])
}

/**
 * Returns all Zodiac Roles Modifiers v2 instances that are enabled and correctly configured on this Safe
 */
export const useRolesMods = () => {
  const { safe } = useSafeInfo()
  const isFeatureEnabled = useHasFeature(FEATURES.ZODIAC_ROLES)

  const [data] = useAsync(async () => {
    if (!ROLES_V2_SUPPORTED_CHAINS.includes(safe.chainId) || !isFeatureEnabled) return []

    const safeModules = safe.modules || []
    const rolesMods = await Promise.all(
      safeModules.map((address) =>
        fetchRolesMod({ address: address.value as `0x${string}`, chainId: parseInt(safe.chainId) as ChainId }),
      ),
    )

    return rolesMods.filter(
      (mod): mod is Exclude<typeof mod, null> =>
        mod !== null &&
        mod.target === safe.address.value.toLowerCase() &&
        mod.avatar === safe.address.value.toLowerCase() &&
        mod.roles.length > 0,
    )
  }, [safe, isFeatureEnabled])

  return data
}

const KNOWN_MULTISEND_ADDRESSES = [
  '0x38869bf66a61cf6bdb996a6ae40d5853fd43b526', // MultiSend 1.4.1
  '0xa238cbeb142c10ef7ad8442c6d1f9e89e07e7761', // MultiSend 1.3.0
  '0x998739bfdaadde7c933b942a68053933098f9eda', // MultiSend 1.3.0 alternative
  '0x8d29be29923b68abfdd21e541b9374737b49cdad', // MultiSend 1.1.1
]
const KNOWN_MULTISEND_CALL_ONLY_ADDRESSES = [
  '0x9641d764fc13c8b624c04430c7356c1c7c8102e2', // MultiSendCallOnly 1.4.1
  '0x40a2accbd92bca938b02010e17a5b8929b49130d', // MultiSendCallOnly 1.3.0
  '0xa1dabef33b3b82c7814b6d82a79e50f4ac44102b', // MultiSendCallOnly 1.3.0 alternative
]

export interface Role {
  modAddress: `0x${string}`
  roleKey: `0x${string}`
  multiSend?: `0x${string}`
  status: Status | null
}

/**
 * Returns a list of roles mod address + role key assigned to the connected wallet.
 * For each role, checks if the role allows the given meta transaction and returns the status.
 */
export const useRoles = (safeTx?: SafeTransaction) => {
  const metaTransactions = useMetaTransactions(safeTx)
  const rolesMods = useRolesMods()
  const wallet = useWallet()
  const walletAddress = wallet?.address.toLowerCase() as undefined | `0x${string}`

  // find all roles assigned to the connected wallet, statically check if they allow the given meta transaction
  const potentialRoles = useMemo(() => {
    const result: Role[] = []
    if (metaTransactions.length === 0) return result

    if (walletAddress && rolesMods) {
      for (const rolesMod of rolesMods) {
        const multiSend = rolesMod.multiSendAddresses.find((addr) => KNOWN_MULTISEND_ADDRESSES.includes(addr))
        const multiSendCallOnly = rolesMod.multiSendAddresses.find((addr) =>
          KNOWN_MULTISEND_CALL_ONLY_ADDRESSES.includes(addr),
        )

        for (const role of rolesMod.roles) {
          if (role.members.includes(walletAddress)) {
            const statuses = metaTransactions.map((metaTx) => checkPermissions(role, metaTx))
            result.push({
              modAddress: rolesMod.address,
              roleKey: role.key,
              multiSend: metaTransactions.some((metaTx) => metaTx.operation === OperationType.DelegateCall)
                ? multiSend
                : multiSendCallOnly,
              status:
                statuses.find((status) => status !== Status.Ok && status !== null) ||
                statuses.find((status) => status !== Status.Ok) ||
                Status.Ok,
            })
          }
        }
      }
    }

    return result
  }, [rolesMods, walletAddress, metaTransactions])
  const web3ReadOnly = useWeb3ReadOnly()

  // if the static check is inconclusive (status: null), evaluate the condition through a test call
  const [dynamicallyCheckedPotentialRoles] = useAsync(
    () =>
      Promise.all(
        potentialRoles.map(async (role: Role) => {
          if (role.status === null && walletAddress && web3ReadOnly) {
            role.status = await checkCondition(role, metaTransactions, walletAddress, web3ReadOnly)
          }
          return role
        }),
      ),
    [potentialRoles, metaTransactions, walletAddress, web3ReadOnly],
  )

  // Return the statically checked roles while the dynamic checks are still pending
  return dynamicallyCheckedPotentialRoles || potentialRoles
}

export const findAllowingRole = (roles: Role[]): Role | undefined => roles.find((role) => role.status === Status.Ok)

export const findMostLikelyRole = (roles: Role[]): Role | undefined =>
  findAllowingRole(roles) ||
  roles.find((role) => role.status !== Status.TargetAddressNotAllowed && role.status !== Status.FunctionNotAllowed) ||
  roles.find((role) => role.status !== Status.TargetAddressNotAllowed) ||
  roles[0]

/**
 * Returns the status of the permission check, `null` if it depends on the condition evaluation.
 */
const checkPermissions = (role: RoleSummary, metaTx: MetaTransactionData): Status | null => {
  const target = role.targets.find((t) => t.address === metaTx.to.toLowerCase())
  if (!target) return Status.TargetAddressNotAllowed

  if (target.clearance === Clearance.Target) {
    // all calls to the target are allowed
    return checkExecutionOptions(target.executionOptions, metaTx)
  }

  if (target.clearance === Clearance.Function) {
    // check if the function is allowed
    const selector = metaTx.data.slice(0, 10) as `0x${string}`
    const func = target.functions.find((f) => f.selector === selector)

    if (func) {
      const execOptionsStatus = checkExecutionOptions(func.executionOptions, metaTx)
      if (execOptionsStatus !== Status.Ok) return execOptionsStatus
      return func.wildcarded ? Status.Ok : null // wildcarded means there's no condition set
    }
  }

  return Status.FunctionNotAllowed
}

const checkExecutionOptions = (execOptions: ExecutionOptions, metaTx: MetaTransactionData): Status => {
  const isSend = BigInt(metaTx.value || '0') > 0n
  const isDelegateCall = metaTx.operation === OperationType.DelegateCall

  if (isSend && execOptions !== ExecutionOptions.Send && execOptions !== ExecutionOptions.Both) {
    return Status.SendNotAllowed
  }
  if (isDelegateCall && execOptions !== ExecutionOptions.DelegateCall && execOptions !== ExecutionOptions.Both) {
    return Status.DelegateCallNotAllowed
  }

  return Status.Ok
}

export const useExecuteThroughRole = ({
  role,
  metaTransactions,
}: {
  role?: Role
  metaTransactions: MetaTransactionData[]
}) => {
  const web3ReadOnly = useWeb3ReadOnly()
  const wallet = useWallet()
  const walletAddress = wallet?.address.toLowerCase() as undefined | `0x${string}`

  return useMemo(
    () =>
      role && walletAddress && web3ReadOnly
        ? encodeExecuteThroughRole(role, metaTransactions, walletAddress, web3ReadOnly)
        : undefined,
    [role, metaTransactions, walletAddress, web3ReadOnly],
  )
}

const encodeMetaTransactions = (role: Role, metaTransactions: MetaTransactionData[]): MetaTransactionData => {
  if (metaTransactions.length === 0) {
    throw new Error('No meta transactions to encode')
  }
  if (metaTransactions.length === 1) {
    return metaTransactions[0]
  } else {
    const to = role.multiSend || KNOWN_MULTISEND_ADDRESSES[0]

    return {
      to,
      value: '0',
      data: multiSendInterface.encodeFunctionData('multiSend', [encodeMultiSendData(metaTransactions)]),
      operation: OperationType.DelegateCall,
    }
  }
}

const encodeExecuteThroughRole = (
  role: Role,
  metaTransactions: MetaTransactionData[],
  from: `0x${string}`,
  provider: JsonRpcProvider,
): Transaction => {
  const combinedMetaTx = encodeMetaTransactions(role, metaTransactions)

  const rolesModifier = getModuleInstance(KnownContracts.ROLES_V2, role.modAddress, provider)
  const data = rolesModifier.interface.encodeFunctionData('execTransactionWithRole', [
    combinedMetaTx.to,
    BigInt(combinedMetaTx.value),
    combinedMetaTx.data,
    combinedMetaTx.operation || 0,
    role.roleKey,
    true,
  ])

  return {
    to: role.modAddress,
    data,
    value: '0',
    from,
  }
}

const checkCondition = async (
  role: Role,
  metaTransactions: MetaTransactionData[],
  from: `0x${string}`,
  provider: JsonRpcProvider,
) => {
  const combinedMetaTx = encodeMetaTransactions(role, metaTransactions)

  const rolesModifier = getModuleInstance(KnownContracts.ROLES_V2, role.modAddress, provider)
  try {
    await rolesModifier.execTransactionWithRole.estimateGas(
      combinedMetaTx.to,
      BigInt(combinedMetaTx.value),
      combinedMetaTx.data,
      combinedMetaTx.operation || 0,
      role.roleKey,
      false,
      { from },
    )

    return Status.Ok
  } catch (e: any) {
    const error = rolesModifier.interface.getError(e.data.slice(0, 10))
    if (error === null || error.name !== 'ConditionViolation') {
      console.error('Unexpected error in condition check', error, e.data, e)
      return null
    }

    // status is a BigInt, convert it to enum
    const { status } = rolesModifier.interface.decodeErrorResult(error, e.data)
    return Number(status) as Status
  }
}

export const useGasLimit = (
  tx?: Transaction,
): {
  gasLimit?: bigint
  gasLimitError?: Error
  gasLimitLoading: boolean
} => {
  const web3ReadOnly = useWeb3ReadOnly()

  const [gasLimit, gasLimitError, gasLimitLoading] = useAsync<bigint | undefined>(async () => {
    if (!web3ReadOnly || !tx) return

    return web3ReadOnly.estimateGas(tx)
  }, [web3ReadOnly, tx])

  useEffect(() => {
    if (gasLimitError) {
      logError(Errors._612, gasLimitError.message)
    }
  }, [gasLimitError])

  return { gasLimit, gasLimitError, gasLimitLoading }
}

export const pollModuleTransactionId = async (
  chainId: string,
  safeAddress: string,
  txHash: string,
): Promise<string> => {
  // exponential delay between attempts for around 4 min
  return backOff(() => getModuleTransactionId(chainId, safeAddress, txHash), {
    startingDelay: 750,
    maxDelay: 20000,
    numOfAttempts: 19,
    retry: (e: any) => {
      console.info('waiting for transaction-service to index the module transaction', e)
      return true
    },
  })
}
</file>

<file path="src/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/index.tsx">
import useWalletCanPay from '@/hooks/useWalletCanPay'
import madProps from '@/utils/mad-props'
import { type ReactElement, type SyntheticEvent, useContext, useState } from 'react'
import { CircularProgress, Box, Button, CardActions, Divider, Typography } from '@mui/material'

import ErrorMessage from '@/components/tx/ErrorMessage'
import { trackError, Errors } from '@/services/exceptions'
import { useCurrentChain } from '@/hooks/useChains'
import { getTxOptions } from '@/utils/transactions'
import CheckWallet from '@/components/common/CheckWallet'

import type { SignOrExecuteProps } from '@/components/tx/SignOrExecuteForm/SignOrExecuteFormV2'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { TxModalContext } from '@/components/tx-flow'
import { SuccessScreenFlow } from '@/components/tx-flow/flows'
import AdvancedParams, { useAdvancedParams } from '../../../../tx/AdvancedParams'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { isWalletRejection } from '@/utils/wallets'

import css from './styles.module.css'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'

import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'
import { pollModuleTransactionId, useExecuteThroughRole, useGasLimit, useMetaTransactions, type Role } from './hooks'
import { decodeBytes32String } from 'ethers'
import useOnboard from '@/hooks/wallets/useOnboard'
import useWallet from '@/hooks/wallets/useWallet'
import useSafeInfo from '@/hooks/useSafeInfo'
import { assertOnboard, assertWallet } from '@/utils/helpers'
import { dispatchModuleTxExecution } from '@/services/tx/tx-sender'
import { Status } from 'zodiac-roles-deployments'

const Role = ({ children }: { children: string }) => {
  let humanReadableRoleKey = children
  try {
    humanReadableRoleKey = decodeBytes32String(children)
  } catch (e) {}

  return <span className={css.roleChip}>{humanReadableRoleKey}</span>
}

export const ExecuteThroughRoleForm = ({
  safeTx,
  role,
  onSubmit,
  disableSubmit = false,
  txSecurity,
}: SignOrExecuteProps & {
  safeTx?: SafeTransaction
  safeTxError?: Error
  role: Role
  txSecurity: ReturnType<typeof useTxSecurityContext>
}): ReactElement => {
  const currentChain = useCurrentChain()
  const onboard = useOnboard()
  const wallet = useWallet()
  const { safe } = useSafeInfo()

  const chainId = currentChain?.chainId || '1'

  const [isPending, setIsPending] = useState<boolean>(false)
  const [isRejectedByUser, setIsRejectedByUser] = useState<boolean>(false)
  const [submitError, setSubmitError] = useState<Error | undefined>()

  const { setTxFlow } = useContext(TxModalContext)
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = txSecurity

  const permissionsError = role.status !== null ? PermissionsErrorMessage[role.status] : null
  const metaTransactions = useMetaTransactions(safeTx)
  const multiSendImpossible = metaTransactions.length > 1 && !role.multiSend

  // Wrap call, routing it through the Roles mod with the allowing role
  const txThroughRole = useExecuteThroughRole({
    role: role.status === Status.Ok && !multiSendImpossible ? role : undefined,
    metaTransactions,
  })

  // Estimate gas limit
  const { gasLimit, gasLimitError } = useGasLimit(txThroughRole)
  const [advancedParams, setAdvancedParams] = useAdvancedParams(gasLimit)

  // On form submit
  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()

    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    assertWallet(wallet)
    assertOnboard(onboard)

    setIsRejectedByUser(false)
    setIsPending(true)
    setSubmitError(undefined)
    setIsRejectedByUser(false)

    if (!txThroughRole) {
      throw new Error('Execution through role is not possible')
    }

    const txOptions = getTxOptions(advancedParams, currentChain)

    let txHash: string
    try {
      txHash = await dispatchModuleTxExecution({ ...txThroughRole, ...txOptions }, wallet.provider, safe.address.value)
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        trackError(Errors._815, err)
        setSubmitError(err)
      }
      setIsPending(false)
      return
    }

    // On success, forward to the success screen, initially without a txId
    setTxFlow(<SuccessScreenFlow txHash={txHash} />, undefined, false)

    // Wait for module tx to be indexed
    const transactionService = currentChain?.transactionService
    if (!transactionService) {
      throw new Error('Transaction service not found')
    }
    const txId = await pollModuleTransactionId(chainId, safe.address.value, txHash)
    onSubmit?.(txId, true)

    // Update the success screen so it shows a link to the transaction
    setTxFlow(<SuccessScreenFlow txId={txId} />, undefined, false)
  }

  const walletCanPay = useWalletCanPay({
    gasLimit,
    maxFeePerGas: advancedParams.maxFeePerGas,
  })

  const submitDisabled = !txThroughRole || isPending || disableSubmit || (needsRiskConfirmation && !isRiskConfirmed)

  return (
    <>
      <Divider className={commonCss.nestedDivider} sx={{ pt: 1 }} />

      <form onSubmit={handleSubmit}>
        {!permissionsError && (
          <>
            <Typography sx={{ mb: 2 }}>
              Your <Role>{role.roleKey}</Role> role allows you to execute this transaction without the confirmations of
              other owners.
            </Typography>

            <div className={commonCss.params}>
              <AdvancedParams
                willExecute
                params={advancedParams}
                recommendedGasLimit={gasLimit}
                onFormSubmit={setAdvancedParams}
                gasLimitError={gasLimitError}
              />
            </div>
          </>
        )}

        {permissionsError && (
          <Box mb={2}>
            <Typography sx={{ mb: 2 }}>
              You are a member of the <Role>{role.roleKey}</Role> role but it does not allow this transaction.
            </Typography>

            <ErrorMessage>{permissionsError}</ErrorMessage>
          </Box>
        )}

        <Typography variant="caption" display="flex" gap="2px" color="text.secondary" sx={{ mb: 2 }}>
          Powered by
          <img src="/images/transactions/zodiac-roles.svg" width={16} height={16} alt="Zodiac Roles" />
          <span className={css.zodiac}>Zodiac</span>
        </Typography>

        {multiSendImpossible && (
          <Box mt={1}>
            <ErrorMessage>
              The current configuration of the Zodiac Roles module does not allow executing multiple transactions in
              batch.
            </ErrorMessage>
          </Box>
        )}

        {!walletCanPay ? (
          <Box mt={1}>
            <ErrorMessage level="info">
              Your connected wallet doesn&apos;t have enough funds to execute this transaction.
            </ErrorMessage>
          </Box>
        ) : (
          gasLimitError && (
            <Box mt={1}>
              <ErrorMessage error={gasLimitError}>
                This transaction will most likely fail. To save gas costs, avoid creating this transaction.
              </ErrorMessage>
            </Box>
          )
        )}

        {submitError && (
          <Box mt={1}>
            <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
          </Box>
        )}

        {isRejectedByUser && (
          <Box mt={1}>
            <WalletRejectionError />
          </Box>
        )}

        <Box mt={3}>
          <Divider className={commonCss.nestedDivider} />
        </Box>

        <CardActions>
          {/* Submit button, also available to non-owner role members */}
          <CheckWallet allowNonOwner checkNetwork={!submitDisabled}>
            {(isOk) => (
              <Button
                data-testid="execute-through-role-form-btn"
                variant="contained"
                type="submit"
                disabled={!isOk || submitDisabled}
                sx={{ minWidth: '112px' }}
              >
                {isPending ? <CircularProgress size={20} /> : 'Execute'}
              </Button>
            )}
          </CheckWallet>
        </CardActions>
      </form>
    </>
  )
}

const useTxSecurityContext = () => useContext(TxSecurityContext)

export default madProps(ExecuteThroughRoleForm, {
  txSecurity: useTxSecurityContext,
})

const PermissionsErrorMessage: Record<Status, string | null> = {
  [Status.Ok]: null,

  [Status.DelegateCallNotAllowed]: 'Role is not allowed to delegate call to target address',
  [Status.TargetAddressNotAllowed]: 'Role is not allowed to call target address',
  [Status.FunctionNotAllowed]: 'Role is not allowed to call this function on the target address',
  [Status.SendNotAllowed]: 'Role is not allowed to send to target address',
  [Status.OrViolation]: 'Condition violation: None of the Or branch conditions are met',
  [Status.NorViolation]: 'Condition violation: At least one Nor branch condition is met',
  [Status.ParameterNotAllowed]: 'Condition violation: Parameter value is not allowed',
  [Status.ParameterLessThanAllowed]: 'Condition violation: Parameter value is less than allowed',
  [Status.ParameterGreaterThanAllowed]: 'Condition violation: Parameter value is greater than allowed',
  [Status.ParameterNotAMatch]: 'Condition violation: Parameter value does not match',
  [Status.NotEveryArrayElementPasses]: 'Condition violation: Not every array element meets the criteria',
  [Status.NoArrayElementPasses]: 'Condition violation: None of the array elements meet the criteria',
  [Status.ParameterNotSubsetOfAllowed]: 'Condition violation: Parameter value is not a subset of allowed values',
  [Status.BitmaskOverflow]: 'Condition violation: Bitmask exceeded value length',
  [Status.BitmaskNotAllowed]: 'Condition violation: Bitmask does not allow the value',
  [Status.CustomConditionViolation]: 'Condition violation: Custom condition is not met',
  [Status.AllowanceExceeded]: 'Condition violation: Allowance is exceeded',
  [Status.CallAllowanceExceeded]: 'Condition violation: Call allowance is exceeded',
  [Status.EtherAllowanceExceeded]: 'Condition violation: Ether allowance is exceeded',
}
</file>

<file path="src/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/styles.module.css">
.roleChip {
  background-color: var(--color-background-main);
  font-size: 12px;
  border-radius: 4px;
  padding: 2px 8px;
}

.zodiac {
  color: var(--color-text-primary);
}
</file>

<file path="src/components/tx-flow/actions/ExecuteThroughRole/index.tsx">
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useCallback, useContext } from 'react'
import { TxFlowContext } from '../../TxFlowProvider'
import ExecuteThroughRoleForm from './ExecuteThroughRoleForm'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { type SlotComponentProps, SlotName, withSlot } from '../../slots'

const ExecuteThroughRole = ({ onSubmitSuccess }: SlotComponentProps<SlotName.Submit>) => {
  const { safeTx } = useContext(SafeTxContext)
  const { trackTxEvent, role, isSubmittable } = useContext(TxFlowContext)

  const handleSubmit = useCallback(
    async (txId: string, isExecuted = false) => {
      onSubmitSuccess?.({ txId, isExecuted })
      trackTxEvent(txId, isExecuted, true)
    },
    [onSubmitSuccess, trackTxEvent],
  )

  return <ExecuteThroughRoleForm safeTx={safeTx} disableSubmit={!isSubmittable} role={role!} onSubmit={handleSubmit} />
}

const useShouldRegisterSlot = () => {
  const isCounterfactualSafe = useIsCounterfactualSafe()
  const { willExecuteThroughRole } = useContext(TxFlowContext)

  return !isCounterfactualSafe && willExecuteThroughRole
}

const ExecuteThroughRoleSlot = withSlot({
  Component: ExecuteThroughRole,
  slotName: SlotName.Submit,
  id: 'executeThroughRole',
  useSlotCondition: useShouldRegisterSlot,
})

export default ExecuteThroughRoleSlot
</file>

<file path="src/components/tx-flow/actions/Propose/index.tsx">
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useCallback, useContext } from 'react'
import { TxFlowContext } from '../../TxFlowProvider'
import ProposerForm from './ProposerForm'
import { type SlotComponentProps, SlotName, withSlot } from '../../slots'

const Propose = ({ onSubmitSuccess }: SlotComponentProps<SlotName.Submit>) => {
  const { safeTx, txOrigin } = useContext(SafeTxContext)
  const { trackTxEvent, isSubmittable } = useContext(TxFlowContext)

  const handleSubmit = useCallback(
    async (txId: string, isExecuted = false) => {
      onSubmitSuccess?.({ txId, isExecuted })
      trackTxEvent(txId, isExecuted, false, true)
    },
    [onSubmitSuccess, trackTxEvent],
  )

  return <ProposerForm safeTx={safeTx} origin={txOrigin} disableSubmit={!isSubmittable} onSubmit={handleSubmit} />
}

const useShouldRegisterSlot = () => {
  const { isProposing } = useContext(TxFlowContext)
  return isProposing
}

const ProposeSlot = withSlot({
  Component: Propose,
  slotName: SlotName.Submit,
  id: 'propose',
  useSlotCondition: useShouldRegisterSlot,
})

export default ProposeSlot
</file>

<file path="src/components/tx-flow/actions/Propose/ProposerForm.tsx">
import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'
import { isWalletRejection } from '@/utils/wallets'
import { type ReactElement, type SyntheticEvent, useContext, useState } from 'react'
import { Box, Button, CircularProgress, Divider, Typography } from '@mui/material'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import CheckWallet from '@/components/common/CheckWallet'
import { TxModalContext } from '@/components/tx-flow'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'
import { useTxActions } from '@/components/tx/SignOrExecuteForm/hooks'
import type { SignOrExecuteProps } from '@/components/tx/SignOrExecuteForm/SignOrExecuteFormV2'
import useWallet from '@/hooks/wallets/useWallet'
import { Errors, trackError } from '@/services/exceptions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import madProps from '@/utils/mad-props'
import { TxCardActions } from '@/components/tx-flow/common/TxCard'

export const ProposerForm = ({
  safeTx,
  origin,
  disableSubmit = false,
  txActions,
  txSecurity,
  onSubmit,
}: SignOrExecuteProps & {
  txActions: ReturnType<typeof useTxActions>
  txSecurity: ReturnType<typeof useTxSecurityContext>
  safeTx?: SafeTransaction
}): ReactElement => {
  // Form state
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [isRejectedByUser, setIsRejectedByUser] = useState<Boolean>(false)

  // Hooks
  const wallet = useWallet()
  const { signProposerTx } = txActions
  const { setTxFlow } = useContext(TxModalContext)
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = txSecurity

  // On modal submit
  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()

    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    if (!safeTx || !wallet) return

    setIsSubmittable(false)
    setIsRejectedByUser(false)

    try {
      const txId = await signProposerTx(safeTx, origin)
      onSubmit?.(txId)
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        trackError(Errors._805, err)
      }
      setIsSubmittable(true)
      return
    }

    setTxFlow(undefined)
  }

  const submitDisabled = !safeTx || !isSubmittable || disableSubmit || (needsRiskConfirmation && !isRiskConfirmed)

  return (
    <form onSubmit={handleSubmit}>
      <Typography>
        As a <strong>Proposer</strong>, you&apos;re creating this transaction without any signatures. It will need
        approval from a signer before it becomes a valid transaction.
      </Typography>

      {isRejectedByUser && (
        <Box mt={1}>
          <WalletRejectionError />
        </Box>
      )}

      <Divider className={commonCss.nestedDivider} sx={{ pt: 3 }} />

      <TxCardActions>
        {/* Submit button */}
        <CheckWallet checkNetwork>
          {(isOk) => (
            <Button
              data-testid="sign-btn"
              variant="contained"
              type="submit"
              disabled={!isOk || submitDisabled}
              sx={{ minWidth: '82px', order: '1', width: ['100%', '100%', '100%', 'auto'] }}
            >
              {!isSubmittable ? <CircularProgress size={20} /> : 'Propose transaction'}
            </Button>
          )}
        </CheckWallet>
      </TxCardActions>
    </form>
  )
}

const useTxSecurityContext = () => useContext(TxSecurityContext)

export default madProps(ProposerForm, {
  txActions: useTxActions,
  txSecurity: useTxSecurityContext,
})
</file>

<file path="src/components/tx-flow/actions/Sign/index.tsx">
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useCallback, useContext } from 'react'
import { TxFlowContext } from '../../TxFlowProvider'
import SignForm from './SignForm'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { type SlotComponentProps, SlotName, withSlot } from '../../slots'
import type { SubmitCallback } from '../../TxFlow'
import { useAlreadySigned } from '@/components/tx/SignOrExecuteForm/hooks'

export const Sign = ({
  onSubmit,
  onSubmitSuccess,
  disabled = false,
  ...props
}: SlotComponentProps<SlotName.ComboSubmit>) => {
  const { safeTx, txOrigin } = useContext(SafeTxContext)
  const { txId, trackTxEvent, isSubmittable } = useContext(TxFlowContext)

  const handleSubmitSuccess = useCallback<SubmitCallback>(
    async ({ txId, isExecuted = false } = {}) => {
      onSubmitSuccess?.({ txId, isExecuted })
      trackTxEvent(txId!, isExecuted)
    },
    [onSubmitSuccess, trackTxEvent],
  )

  return (
    <SignForm
      disableSubmit={!isSubmittable || disabled}
      origin={txOrigin}
      safeTx={safeTx}
      onSubmit={onSubmit}
      onSubmitSuccess={handleSubmitSuccess}
      txId={txId}
      {...props}
    />
  )
}

const useShouldRegisterSlot = () => {
  const { isProposing, willExecuteThroughRole } = useContext(TxFlowContext)
  const { safeTx } = useContext(SafeTxContext)
  const isCounterfactualSafe = useIsCounterfactualSafe()
  const hasSigned = useAlreadySigned(safeTx)

  return !!safeTx && !hasSigned && !isCounterfactualSafe && !willExecuteThroughRole && !isProposing
}

const SignSlot = withSlot({
  Component: Sign,
  label: 'Sign',
  slotName: SlotName.ComboSubmit,
  id: 'sign',
  useSlotCondition: useShouldRegisterSlot,
})

export default SignSlot
</file>

<file path="src/components/tx-flow/actions/Sign/SignForm.tsx">
import madProps from '@/utils/mad-props'
import { type ReactElement, type SyntheticEvent, useContext, useState } from 'react'
import { Box, Divider, Stack } from '@mui/material'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { trackError, Errors } from '@/services/exceptions'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import CheckWallet from '@/components/common/CheckWallet'
import { useAlreadySigned, useTxActions } from '@/components/tx/SignOrExecuteForm/hooks'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { TxModalContext } from '@/components/tx-flow'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'
import NonOwnerError from '@/components/tx/SignOrExecuteForm/NonOwnerError'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { isWalletRejection } from '@/utils/wallets'
import { useSigner } from '@/hooks/wallets/useWallet'
import { NestedTxSuccessScreenFlow } from '@/components/tx-flow/flows'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'
import { TxCardActions } from '@/components/tx-flow/common/TxCard'
import SplitMenuButton from '@/components/common/SplitMenuButton'
import type { SlotComponentProps, SlotName } from '../../slots'

export const SignForm = ({
  safeTx,
  txId,
  onSubmit,
  onSubmitSuccess,
  onChange,
  options = [],
  disableSubmit = false,
  origin,
  isOwner,
  slotId,
  txActions,
  txSecurity,
  tooltip,
}: SlotComponentProps<SlotName.ComboSubmit> & {
  txId?: string
  disableSubmit?: boolean
  origin?: string
  isOwner: ReturnType<typeof useIsSafeOwner>
  txActions: ReturnType<typeof useTxActions>
  txSecurity: ReturnType<typeof useTxSecurityContext>
  safeTx?: SafeTransaction
  tooltip?: string
}): ReactElement => {
  // Form state
  const [isSubmittableLocal, setIsSubmittableLocal] = useState<boolean>(true) // TODO: remove this local state and use only the one from TxFlowContext when tx-flow refactor is done

  // Hooks
  const { signTx } = txActions
  const { setTxFlow } = useContext(TxModalContext)
  const { isSubmittable, setIsSubmittable, setSubmitError, setIsRejectedByUser } = useContext(TxFlowContext)
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = txSecurity
  const hasSigned = useAlreadySigned(safeTx)
  const signer = useSigner()

  const handleOptionChange = (option: string) => {
    onChange?.(option)
  }

  // On modal submit
  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()

    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    if (!safeTx) return

    setIsSubmittable(false)
    setIsSubmittableLocal(false)

    setSubmitError(undefined)
    setIsRejectedByUser(false)

    onSubmit?.()

    let resultTxId: string
    try {
      resultTxId = await signTx(safeTx, txId, origin)
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        trackError(Errors._804, err)
        setSubmitError(err)
      }
      setIsSubmittable(true)
      setIsSubmittableLocal(true)
      return
    }

    // On successful sign
    onSubmitSuccess?.({ txId: resultTxId })

    if (signer?.isSafe) {
      setTxFlow(<NestedTxSuccessScreenFlow txId={resultTxId} />, undefined, false)
    } else {
      setTxFlow(undefined)
    }
  }

  const cannotPropose = !isOwner
  const submitDisabled =
    !safeTx ||
    !isSubmittable ||
    !isSubmittableLocal ||
    disableSubmit ||
    cannotPropose ||
    (needsRiskConfirmation && !isRiskConfirmed)

  return (
    <Stack gap={3}>
      {hasSigned && <ErrorMessage level="warning">You have already signed this transaction.</ErrorMessage>}

      {cannotPropose && <NonOwnerError />}

      <Box>
        <Divider className={commonCss.nestedDivider} />

        {/* Submit button */}
        <TxCardActions>
          <form onSubmit={handleSubmit}>
            <CheckWallet checkNetwork={!submitDisabled}>
              {(isOk) => (
                <SplitMenuButton
                  selected={slotId}
                  onChange={({ id }) => handleOptionChange(id)}
                  options={options}
                  disabled={!isOk || submitDisabled}
                  loading={!isSubmittable || !isSubmittableLocal}
                  tooltip={isOk ? tooltip : undefined}
                />
              )}
            </CheckWallet>
          </form>
        </TxCardActions>
      </Box>
    </Stack>
  )
}

const useTxSecurityContext = () => useContext(TxSecurityContext)

export default madProps(SignForm, {
  isOwner: useIsSafeOwner,
  txActions: useTxActions,
  txSecurity: useTxSecurityContext,
})
</file>

<file path="src/components/tx-flow/actions/ComboSubmit.tsx">
import { useContext, useMemo } from 'react'
import { Slot, type SlotComponentProps, SlotName, useSlot, useSlotIds, withSlot } from '../slots'
import { Box } from '@mui/material'
import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { TxFlowContext } from '../TxFlowProvider'
import { useValidateTxData } from '@/hooks/useValidateTxData'
import useLocalStorage from '@/services/local-storage/useLocalStorage'

const COMBO_SUBMIT_ACTION = 'comboSubmitAction'

export const ComboSubmit = ({ onSubmit }: SlotComponentProps<SlotName.Submit>) => {
  const { txId, submitError, isRejectedByUser } = useContext(TxFlowContext)
  const slotItems = useSlot(SlotName.ComboSubmit)
  const slotIds = useSlotIds(SlotName.ComboSubmit)

  const [validationResult, , validationLoading] = useValidateTxData(txId)
  const validationError = useMemo(
    () => (validationResult !== undefined ? new Error(validationResult) : undefined),
    [validationResult],
  )

  const initialSubmitAction = slotIds?.[0]
  const options = useMemo(() => slotItems.map(({ label, id }) => ({ label, id })), [slotItems])
  const [submitAction = initialSubmitAction, setSubmitAction] = useLocalStorage<string>(COMBO_SUBMIT_ACTION)

  const slotId = useMemo(
    () => (slotIds.includes(submitAction) ? submitAction : initialSubmitAction),
    [slotIds, submitAction, initialSubmitAction],
  )

  if (slotIds.length === 0) {
    return false
  }

  const disabled = validationError !== undefined || validationLoading

  return (
    <>
      {submitError && (
        <Box mt={1}>
          <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
        </Box>
      )}

      {isRejectedByUser && (
        <Box mt={1}>
          <WalletRejectionError />
        </Box>
      )}

      {validationError !== undefined && (
        <ErrorMessage error={validationError}>Error validating transaction data</ErrorMessage>
      )}

      <Slot
        name={SlotName.ComboSubmit}
        id={slotId}
        onSubmit={onSubmit}
        options={options}
        onChange={setSubmitAction}
        disabled={disabled}
      />
    </>
  )
}

const useShouldRegisterSlot = () => {
  const slotIds = useSlotIds(SlotName.ComboSubmit)
  return slotIds.length > 0
}

const ComboSubmitSlot = withSlot({
  Component: ComboSubmit,
  slotName: SlotName.Submit,
  id: 'combo-submit',
  useSlotCondition: useShouldRegisterSlot,
})

export default ComboSubmitSlot
</file>

<file path="src/components/tx-flow/actions/Counterfactual.tsx">
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useCallback, useContext } from 'react'
import { TxFlowContext } from '../TxFlowProvider'
import CounterfactualForm from '@/features/counterfactual/CounterfactualForm'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { type SlotComponentProps, SlotName, withSlot } from '../slots'

const Counterfactual = ({ onSubmitSuccess }: SlotComponentProps<SlotName.Submit>) => {
  const { safeTx, txOrigin } = useContext(SafeTxContext)
  const { isCreation, trackTxEvent, isSubmittable } = useContext(TxFlowContext)

  const handleSubmit = useCallback(
    async (txId: string, isExecuted = false) => {
      onSubmitSuccess?.({ txId, isExecuted })
      trackTxEvent(txId, isExecuted)
    },
    [onSubmitSuccess, trackTxEvent],
  )

  return (
    <CounterfactualForm
      origin={txOrigin}
      disableSubmit={!isSubmittable}
      isCreation={isCreation}
      safeTx={safeTx}
      onSubmit={handleSubmit}
      onlyExecute
    />
  )
}

const useShouldRegisterSlot = () => {
  const isCounterfactualSafe = useIsCounterfactualSafe()
  const { isProposing } = useContext(TxFlowContext)

  return isCounterfactualSafe && !isProposing
}

const CounterfactualSlot = withSlot({
  Component: Counterfactual,
  slotName: SlotName.Submit,
  id: 'counterfactual',
  useSlotCondition: useShouldRegisterSlot,
})

export default CounterfactualSlot
</file>

<file path="src/components/tx-flow/actions/index.ts">
import dynamic from 'next/dynamic'

export const Batching = dynamic(() => import('./Batching'))
export const ComboSubmit = dynamic(() => import('./ComboSubmit'))
export const Counterfactual = dynamic(() => import('./Counterfactual'))
export const Execute = dynamic(() => import('./Execute'))
export const ExecuteThroughRole = dynamic(() => import('./ExecuteThroughRole'))
export const Propose = dynamic(() => import('./Propose'))
export const Sign = dynamic(() => import('./Sign'))
</file>

<file path="src/components/tx-flow/common/OwnerList/index.tsx">
import { Paper, Typography, SvgIcon } from '@mui/material'
import type { PaperProps } from '@mui/material'
import type { AddressEx } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'

import PlusIcon from '@/public/images/common/plus.svg'
import EthHashInfo from '@/components/common/EthHashInfo'

import css from './styles.module.css'
import { maybePlural } from '@safe-global/utils/utils/formatters'

export function OwnerList({
  title,
  owners,
  sx,
}: {
  owners: Array<AddressEx>
  title?: string
  sx?: PaperProps['sx']
}): ReactElement {
  return (
    <Paper className={css.container} sx={sx}>
      <Typography
        sx={{
          color: 'text.secondary',
          display: 'flex',
          alignItems: 'center',
        }}
      >
        <SvgIcon component={PlusIcon} inheritViewBox fontSize="small" sx={{ mr: 1 }} />
        {title ?? `New signer${maybePlural(owners)}`}
      </Typography>
      {owners.map((newOwner) => (
        <EthHashInfo
          key={newOwner.value}
          address={newOwner.value}
          name={newOwner.name}
          shortAddress={false}
          showCopyButton
          hasExplorer
          avatarSize={32}
        />
      ))}
    </Paper>
  )
}
</file>

<file path="src/components/tx-flow/common/OwnerList/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
  padding: var(--space-2);
  background-color: var(--color-success-background);
}
</file>

<file path="src/components/tx-flow/common/TxCard/index.tsx">
import type { ReactNode } from 'react'
import { Card, CardActions, CardContent, Stack } from '@mui/material'
import css from '../styles.module.css'

const sx = { my: 2, border: 0 }

const TxCard = ({ children }: { children: ReactNode }) => {
  return (
    <Card sx={sx}>
      <CardContent data-testid="card-content" className={css.cardContent}>
        {children}
      </CardContent>
    </Card>
  )
}

export default TxCard

export const TxCardActions = ({ children }: { children: ReactNode }) => {
  return (
    <CardActions>
      <Stack
        sx={{
          width: ['100%', '100%', '100%', 'auto'],
        }}
        direction={{ xs: 'column-reverse', lg: 'row' }}
        spacing={{ xs: 2, md: 2 }}
      >
        {children}
      </Stack>
    </CardActions>
  )
}
</file>

<file path="src/components/tx-flow/common/TxFlowContent/index.tsx">
import { TxFlowContext } from '../../TxFlowProvider'
import { type ReactNode, useContext, useEffect, useState } from 'react'
import { Box, Container, Grid, Typography, Button, Paper, IconButton, useMediaQuery } from '@mui/material'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import { useTheme } from '@mui/material/styles'
import classnames from 'classnames'
import { ProgressBar } from '@/components/common/ProgressBar'
import css from './styles.module.css'
import SafeLogo from '@/public/images/logo-no-text.svg'
import ChainIndicator from '@/components/common/ChainIndicator'
import SecurityWarnings from '@/components/tx/security/SecurityWarnings'
import TxStatusWidget from '@/components/tx-flow/common/TxStatusWidget'
import { TxLayoutHeader } from '../TxLayout'
import { Slot, SlotName } from '../../slots'

/**
 * TxFlowContent is a component that renders the main content of the transaction flow.
 * It uses the TxFlowContext to manage the transaction state and layout properties.
 * The component also handles the transaction steps and progress.
 * It accepts children components to be rendered within the flow.
 */
export const TxFlowContent = ({ children }: { children?: ReactNode[] | ReactNode }) => {
  const {
    txLayoutProps: {
      title = '',
      subtitle,
      txSummary,
      icon,
      fixedNonce,
      hideNonce,
      hideProgress,
      isReplacement,
      isMessage,
    },
    isBatch,
    step,
    progress,
    onPrev,
  } = useContext(TxFlowContext)

  const childrenArray = Array.isArray(children) ? children : [children]

  const [statusVisible, setStatusVisible] = useState<boolean>(true)

  const theme = useTheme()
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('md'))
  const isDesktop = useMediaQuery(theme.breakpoints.down('lg'))

  useEffect(() => {
    setStatusVisible(!isSmallScreen)
  }, [isSmallScreen])

  const toggleStatus = () => {
    setStatusVisible((prev) => !prev)
  }

  return (
    <>
      {/* Header status button */}
      {!isReplacement && (
        <IconButton className={css.statusButton} aria-label="Transaction status" size="large" onClick={toggleStatus}>
          <SafeLogo width={16} height={16} />
        </IconButton>
      )}

      <Container className={css.container}>
        <Grid
          container
          sx={{
            gap: 3,
            justifyContent: 'center',
          }}
        >
          {/* Main content */}
          <Grid item xs={12} md={7}>
            <div className={css.titleWrapper}>
              <Typography
                data-testid="modal-title"
                variant="h3"
                component="div"
                className={css.title}
                sx={{
                  fontWeight: '700',
                }}
              >
                {title}
              </Typography>

              <ChainIndicator inline />
            </div>

            <Paper data-testid="modal-header" className={css.header}>
              {!hideProgress && (
                <Box className={css.progressBar}>
                  <ProgressBar value={progress} />
                </Box>
              )}

              <TxLayoutHeader subtitle={subtitle} icon={icon} hideNonce={hideNonce} fixedNonce={fixedNonce} />
            </Paper>

            <div className={css.step}>
              {childrenArray[step]}

              {onPrev && step > 0 && (
                <Button
                  data-testid="modal-back-btn"
                  variant={isDesktop ? 'text' : 'outlined'}
                  onClick={onPrev}
                  className={css.backButton}
                  startIcon={<ArrowBackIcon fontSize="small" />}
                >
                  Back
                </Button>
              )}
            </div>
          </Grid>

          {/* Sidebar */}
          {!isReplacement && (
            <Grid item xs={12} md={4} className={classnames(css.widget, { [css.active]: statusVisible })}>
              {statusVisible && (
                <TxStatusWidget
                  step={step}
                  txSummary={txSummary}
                  handleClose={() => setStatusVisible(false)}
                  isBatch={isBatch}
                  isMessage={isMessage}
                />
              )}

              <Slot name={SlotName.Sidebar} />

              <Box className={css.sticky}>
                <SecurityWarnings />
              </Box>
            </Grid>
          )}
        </Grid>
      </Container>
    </>
  )
}
</file>

<file path="src/components/tx-flow/common/TxFlowContent/styles.module.css">
.container {
  margin-top: 10px;
}

.header {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.headerInner {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-3);
  border-bottom: 1px solid var(--color-border-light);
}

.step {
  position: relative;
}

/* Back button */
.backButton {
  position: absolute;
  left: var(--space-3);
  bottom: var(--space-3);
}

.step :global(.MuiCard-root:first-child) {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  margin-top: 0;
}

/* Submit button */
.step :global(.MuiCardActions-root) {
  display: flex;
  flex-direction: column;
  padding: 0;
  margin-top: var(--space-3);
}

.step :global(.MuiCardActions-root) > * {
  align-self: flex-end;
}

.icon {
  width: 32px;
  height: 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
  margin-right: var(--space-2);
}

.icon svg {
  height: 16px;
  width: auto;
}

.step :global(.MuiAccordionSummary-content),
.step :global(.MuiAccordionSummary-content) p {
  font-weight: bold;
  font-size: 14px;
}

.step :global(.MuiAccordionSummary-expandIconWrapper) {
  margin-left: var(--space-2);
}

.statusButton {
  position: absolute;
  top: 0;
  right: 57px;
  color: var(--color-text-primary);
  padding: var(--space-2);
  border-left: 1px solid var(--color-border-light);
  border-right: 1px solid var(--color-border-light);
  border-radius: 0;
  width: 24px;
  height: 24px;
  box-sizing: content-box;
  display: none;
}

.sticky {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  position: sticky;
  top: var(--space-2);
  margin-top: var(--space-2);
}

.titleWrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-2);
}

.widget {
  /* Height of transaction type title */
  margin-top: 46px;
}

@media (max-width: 1199px) {
  .backButton {
    left: 50%;
    transform: translateX(-50%);
  }

  .step :global(.MuiCardActions-root) {
    margin-bottom: var(--space-8);
  }
}

@media (max-width: 899.95px) {
  .widget {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    margin-top: unset;
  }

  .widget.active {
    z-index: 1;
  }

  .widget :global .MuiPaper-root {
    height: 100%;
  }

  .titleWrapper {
    position: absolute;
    top: 16px;
    left: var(--space-2);
    margin-bottom: 0;
    width: calc(100% - 145px);
  }

  .title {
    font-size: 16px;
    line-height: 18px;
  }

  .container {
    padding: 0;
  }

  .progressBar {
    display: none;
  }

  .step :global(.MuiCard-root),
  .header {
    border-radius: 0;
  }

  .statusButton {
    display: inline-flex;
  }
}
</file>

<file path="src/components/tx-flow/common/TxLayout/index.tsx">
import useSafeInfo from '@/hooks/useSafeInfo'
import { type ComponentType, type ReactElement, type ReactNode, useContext, useEffect, useState } from 'react'
import { Box, Container, Grid, Typography, Button, Paper, SvgIcon, IconButton, useMediaQuery } from '@mui/material'
import ArrowBackIcon from '@mui/icons-material/ArrowBack'
import { useTheme } from '@mui/material/styles'
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import classnames from 'classnames'
import { ProgressBar } from '@/components/common/ProgressBar'
import SafeTxProvider, { SafeTxContext } from '../../SafeTxProvider'
import { TxInfoProvider } from '@/components/tx-flow/TxInfoProvider'
import TxNonce from '../TxNonce'
import TxStatusWidget from '../TxStatusWidget'
import css from './styles.module.css'
import SafeLogo from '@/public/images/logo-no-text.svg'
import { TxSecurityProvider } from '@/components/tx/security/shared/TxSecurityContext'
import ChainIndicator from '@/components/common/ChainIndicator'
import SecurityWarnings from '@/components/tx/security/SecurityWarnings'

export const TxLayoutHeader = ({
  hideNonce,
  fixedNonce,
  icon,
  subtitle,
}: {
  hideNonce: TxLayoutProps['hideNonce']
  fixedNonce: TxLayoutProps['fixedNonce']
  icon: TxLayoutProps['icon']
  subtitle: TxLayoutProps['subtitle']
}) => {
  const { safe } = useSafeInfo()
  const { nonceNeeded } = useContext(SafeTxContext)

  if (hideNonce && !icon && !subtitle) return null

  return (
    <Box className={css.headerInner}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
        }}
      >
        {icon && (
          <div className={css.icon}>
            <SvgIcon component={icon} inheritViewBox />
          </div>
        )}

        <Typography
          variant="h4"
          component="div"
          sx={{
            fontWeight: 'bold',
          }}
        >
          {subtitle}
        </Typography>
      </Box>
      {!hideNonce && safe.deployed && nonceNeeded && <TxNonce canEdit={!fixedNonce} />}
    </Box>
  )
}

export type TxStep = {
  txLayoutProps: Omit<TxLayoutProps, 'children'>
  content: ReactElement
}

type TxLayoutProps = {
  title: ReactNode
  children: ReactNode
  subtitle?: ReactNode
  icon?: ComponentType
  step?: number
  txSummary?: TransactionSummary
  onBack?: () => void
  hideNonce?: boolean
  fixedNonce?: boolean
  hideProgress?: boolean
  isBatch?: boolean
  isReplacement?: boolean
  isMessage?: boolean
}

const TxLayout = ({
  title,
  subtitle,
  icon,
  children,
  step = 0,
  txSummary,
  onBack,
  hideNonce = false,
  fixedNonce = false,
  hideProgress = false,
  isBatch = false,
  isReplacement = false,
  isMessage = false,
}: TxLayoutProps): ReactElement => {
  const [statusVisible, setStatusVisible] = useState<boolean>(true)

  const theme = useTheme()
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('md'))
  const isDesktop = useMediaQuery(theme.breakpoints.down('lg'))

  const steps = Array.isArray(children) ? children : [children]
  const progress = Math.round(((step + 1) / steps.length) * 100)

  useEffect(() => {
    setStatusVisible(!isSmallScreen)
  }, [isSmallScreen])

  const toggleStatus = () => {
    setStatusVisible((prev) => !prev)
  }

  return (
    <SafeTxProvider>
      <TxInfoProvider>
        <TxSecurityProvider>
          <>
            {/* Header status button */}
            {!isReplacement && (
              <IconButton
                className={css.statusButton}
                aria-label="Transaction status"
                size="large"
                onClick={toggleStatus}
              >
                <SafeLogo width={16} height={16} />
              </IconButton>
            )}

            <Container className={css.container}>
              <Grid
                container
                sx={{
                  gap: 3,
                  justifyContent: 'center',
                }}
              >
                {/* Main content */}
                <Grid item xs={12} md={7}>
                  <div className={css.titleWrapper}>
                    <Typography
                      data-testid="modal-title"
                      variant="h3"
                      component="div"
                      className={css.title}
                      sx={{
                        fontWeight: '700',
                      }}
                    >
                      {title}
                    </Typography>

                    <ChainIndicator inline />
                  </div>

                  <Paper data-testid="modal-header" className={css.header}>
                    {!hideProgress && (
                      <Box className={css.progressBar}>
                        <ProgressBar value={progress} />
                      </Box>
                    )}

                    <TxLayoutHeader subtitle={subtitle} icon={icon} hideNonce={hideNonce} fixedNonce={fixedNonce} />
                  </Paper>

                  <div className={css.step}>
                    {steps[step]}

                    {onBack && step > 0 && (
                      <Button
                        data-testid="modal-back-btn"
                        variant={isDesktop ? 'text' : 'outlined'}
                        onClick={onBack}
                        className={css.backButton}
                        startIcon={<ArrowBackIcon fontSize="small" />}
                      >
                        Back
                      </Button>
                    )}
                  </div>
                </Grid>

                {/* Sidebar */}
                {!isReplacement && (
                  <Grid item xs={12} md={4} className={classnames(css.widget, { [css.active]: statusVisible })}>
                    {statusVisible && (
                      <TxStatusWidget
                        step={step}
                        txSummary={txSummary}
                        handleClose={() => setStatusVisible(false)}
                        isBatch={isBatch}
                        isMessage={isMessage}
                      />
                    )}

                    <Box className={css.sticky}>
                      <SecurityWarnings />
                    </Box>
                  </Grid>
                )}
              </Grid>
            </Container>
          </>
        </TxSecurityProvider>
      </TxInfoProvider>
    </SafeTxProvider>
  )
}

export default TxLayout
</file>

<file path="src/components/tx-flow/common/TxLayout/styles.module.css">
.container {
  margin-top: 10px;
}

.header {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.headerInner {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-3);
  border-bottom: 1px solid var(--color-border-light);
}

.step {
  position: relative;
}

/* Back button */
.backButton {
  position: absolute;
  left: var(--space-3);
  bottom: var(--space-3);
}

.step :global(.MuiCard-root:first-child) {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  margin-top: 0;
}

/* Submit button */
.step :global(.MuiCardActions-root) {
  display: flex;
  flex-direction: column;
  padding: 0;
  margin-top: var(--space-3);
}

.step :global(.MuiCardActions-root) > * {
  align-self: flex-end;
}

.icon {
  width: 32px;
  height: 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
  margin-right: var(--space-2);
}

.icon svg {
  height: 16px;
  width: auto;
}

.step :global(.MuiAccordionSummary-content),
.step :global(.MuiAccordionSummary-content) p {
  font-weight: bold;
  font-size: 14px;
}

.step :global(.MuiAccordionSummary-expandIconWrapper) {
  margin-left: var(--space-2);
}

.statusButton {
  position: absolute;
  top: 0;
  right: 57px;
  color: var(--color-text-primary);
  padding: var(--space-2);
  border-left: 1px solid var(--color-border-light);
  border-right: 1px solid var(--color-border-light);
  border-radius: 0;
  width: 24px;
  height: 24px;
  box-sizing: content-box;
  display: none;
}

.sticky {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  position: sticky;
  top: var(--space-2);
  margin-top: var(--space-2);
}

.titleWrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-2);
}

.widget {
  /* Height of transaction type title */
  margin-top: 46px;
}

@media (max-width: 1199px) {
  .backButton {
    left: 50%;
    transform: translateX(-50%);
  }

  .step :global(.MuiCardActions-root) {
    margin-bottom: var(--space-8);
  }
}

@media (max-width: 899.95px) {
  .widget {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    margin-top: unset;
  }

  .widget.active {
    z-index: 1;
  }

  .widget :global .MuiPaper-root {
    height: 100%;
  }

  .titleWrapper {
    position: absolute;
    top: 16px;
    left: var(--space-2);
    margin-bottom: 0;
    width: calc(100% - 145px);
  }

  .title {
    font-size: 16px;
    line-height: 18px;
  }

  .container {
    padding: 0;
  }

  .progressBar {
    display: none;
  }

  .step :global(.MuiCard-root),
  .header {
    border-radius: 0;
  }

  .statusButton {
    display: inline-flex;
  }
}
</file>

<file path="src/components/tx-flow/common/TxNonce/index.tsx">
import { memo, type ReactElement, useContext, useMemo, useState, useEffect } from 'react'
import {
  Autocomplete,
  Box,
  IconButton,
  InputAdornment,
  Skeleton,
  Tooltip,
  Popper,
  type PopperProps,
  type MenuItemProps,
  MenuItem,
  Typography,
  ListSubheader,
  type ListSubheaderProps,
} from '@mui/material'
import { createFilterOptions } from '@mui/material/Autocomplete'
import { Controller, useForm } from 'react-hook-form'

import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import RotateLeftIcon from '@mui/icons-material/RotateLeft'
import NumberField from '@/components/common/NumberField'
import { useQueuedTxByNonce } from '@/hooks/useTxQueue'
import useSafeInfo from '@/hooks/useSafeInfo'
import useAddressBook from '@/hooks/useAddressBook'
import { getLatestTransactions } from '@/utils/tx-list'
import { getTransactionType } from '@/hooks/useTransactionType'
import usePreviousNonces from '@/hooks/usePreviousNonces'
import { isRejectionTx } from '@/utils/transactions'

import css from './styles.module.css'
import classNames from 'classnames'

const CustomPopper = function ({
  // Don't set width of Popper to that of the field
  className,
  ...props
}: PopperProps) {
  return <Popper {...props} className={classNames(className, css.popper)} style={undefined} placement="bottom-start" />
}

const NonceFormHeader = memo(function NonceFormSubheader({ children, ...props }: ListSubheaderProps) {
  return (
    <ListSubheader {...props} disableSticky>
      <Typography variant="caption" fontWeight={700} color="text.secondary">
        {children}
      </Typography>
    </ListSubheader>
  )
})

const NonceFormOption = memo(function NonceFormOption({
  nonce,
  menuItemProps,
}: {
  nonce: string
  menuItemProps: MenuItemProps
}): ReactElement {
  const addressBook = useAddressBook()
  const transactions = useQueuedTxByNonce(Number(nonce))

  const txLabel = useMemo(() => {
    const latestTransactions = getLatestTransactions(transactions)

    if (latestTransactions.length === 0) {
      return
    }

    const [{ transaction }] = latestTransactions
    return transaction.txInfo.humanDescription || `${getTransactionType(transaction, addressBook).text} transaction`
  }, [addressBook, transactions])

  const label = txLabel || 'New transaction'

  return (
    <MenuItem {...menuItemProps}>
      <Typography variant="body2">
        <b>{nonce}</b>&nbsp;- {label}
      </Typography>
    </MenuItem>
  )
})

const getFieldMinWidth = (value: string): string => {
  const MIN_CHARS = 7
  const MAX_WIDTH = '200px'
  const clamped = `clamp(calc(${MIN_CHARS}ch + 6px), calc(${Math.max(MIN_CHARS, value.length)}ch + 6px), ${MAX_WIDTH})`
  return clamped
}

const filter = createFilterOptions<string>()

enum TxNonceFormFieldNames {
  NONCE = 'nonce',
}

enum ErrorMessages {
  NONCE_MUST_BE_NUMBER = 'Nonce must be a number',
  NONCE_TOO_LOW = "Nonce can't be lower than %%nonce%%",
  NONCE_TOO_HIGH = 'Nonce is too high',
  NONCE_TOO_FAR = 'Nonce is much higher than the current nonce',
  NONCE_GT_RECOMMENDED = 'Nonce is higher than the recommended nonce',
  NONCE_MUST_BE_INTEGER = "Nonce can't contain decimals",
}

const MAX_NONCE_DIFFERENCE = 100

const TxNonceForm = ({ nonce, recommendedNonce }: { nonce: string; recommendedNonce: string }) => {
  const { safeTx, setNonce } = useContext(SafeTxContext)
  const previousNonces = usePreviousNonces().map((nonce) => nonce.toString())
  const { safe } = useSafeInfo()
  const [warning, setWarning] = useState<string>('')

  const showRecommendedNonceButton = recommendedNonce !== nonce
  const isEditable = !safeTx || safeTx?.signatures.size === 0
  const readOnly = !isEditable || isRejectionTx(safeTx)

  const formMethods = useForm({
    defaultValues: {
      [TxNonceFormFieldNames.NONCE]: nonce,
    },
    mode: 'all',
    values: {
      [TxNonceFormFieldNames.NONCE]: nonce,
    },
  })

  const resetNonce = () => {
    formMethods.setValue(TxNonceFormFieldNames.NONCE, recommendedNonce)
  }

  useEffect(() => {
    let message = ''
    // Warnings
    if (Number(nonce) > Number(recommendedNonce)) {
      message = ErrorMessages.NONCE_GT_RECOMMENDED
    }

    if (Number(nonce) >= safe.nonce + MAX_NONCE_DIFFERENCE) {
      message = ErrorMessages.NONCE_TOO_FAR
    }

    setWarning(message)
  }, [nonce, recommendedNonce, safe.nonce])

  return (
    <Controller
      name={TxNonceFormFieldNames.NONCE}
      control={formMethods.control}
      rules={{
        required: 'Nonce is required',
        // Validation must be async to allow resetting invalid values onBlur
        validate: async (value) => {
          // nonce is always valid so no need to validate if the input is the same
          if (value === nonce) return

          const newNonce = Number(value)

          if (isNaN(newNonce)) {
            return ErrorMessages.NONCE_MUST_BE_NUMBER
          }

          if (newNonce < safe.nonce) {
            return ErrorMessages.NONCE_TOO_LOW.replace('%%nonce%%', safe.nonce.toString())
          }

          if (newNonce >= Number.MAX_SAFE_INTEGER) {
            return ErrorMessages.NONCE_TOO_HIGH
          }

          if (!Number.isInteger(newNonce)) {
            return ErrorMessages.NONCE_MUST_BE_INTEGER
          }

          // Update context with valid nonce
          setNonce(newNonce)
        },
      }}
      render={({ field, fieldState }) => {
        if (readOnly) {
          return (
            <Typography variant="body2" fontWeight={700} ml={-1}>
              {nonce}
            </Typography>
          )
        }

        return (
          <Autocomplete
            value={field.value}
            freeSolo
            onChange={(_, value) => field.onChange(value)}
            onInputChange={(_, value) => field.onChange(value)}
            onBlur={() => {
              field.onBlur()

              if (fieldState.error) {
                formMethods.setValue(field.name, recommendedNonce.toString())
              }
            }}
            options={[recommendedNonce, ...previousNonces]}
            getOptionLabel={(option) => option.toString()}
            filterOptions={(options, params) => {
              const filtered = filter(options, params)

              // Prevent segments from showing recommended, e.g. if recommended is 250, don't show for 2, 5 or 25
              const shouldShow = !recommendedNonce.includes(params.inputValue)
              const isQueued = options.some((option) => params.inputValue === option)

              if (params.inputValue !== '' && !isQueued && shouldShow) {
                filtered.push(recommendedNonce)
              }

              return filtered
            }}
            renderOption={(props, option) => {
              const isRecommendedNonce = option === recommendedNonce
              const isInitialPreviousNonce = option === previousNonces[0]

              const { key, ...rest } = props

              return (
                <div key={key}>
                  {isRecommendedNonce && <NonceFormHeader>Recommended nonce</NonceFormHeader>}
                  {isInitialPreviousNonce && <NonceFormHeader sx={{ pt: 3 }}>Replace existing</NonceFormHeader>}
                  <NonceFormOption menuItemProps={rest} nonce={option} />
                </div>
              )
            }}
            disableClearable
            componentsProps={{
              paper: {
                elevation: 2,
              },
            }}
            renderInput={(params) => {
              return (
                <Tooltip title={fieldState.error?.message || warning} open arrow placement="top">
                  <NumberField
                    {...params}
                    error={!!fieldState.error}
                    InputProps={{
                      ...params.InputProps,
                      name: field.name,
                      endAdornment: showRecommendedNonceButton ? (
                        <InputAdornment position="end" className={css.adornment}>
                          <Tooltip title="Reset to recommended nonce">
                            <IconButton onClick={resetNonce} size="small" color="primary">
                              <RotateLeftIcon fontSize="small" />
                            </IconButton>
                          </Tooltip>
                        </InputAdornment>
                      ) : null,
                    }}
                    className={classNames([
                      css.input,
                      {
                        [css.withAdornment]: showRecommendedNonceButton,
                      },
                    ])}
                    sx={{
                      minWidth: getFieldMinWidth(field.value),
                    }}
                  />
                </Tooltip>
              )
            }}
            PopperComponent={CustomPopper}
          />
        )
      }}
    />
  )
}

const skeletonMinWidth = getFieldMinWidth('')

const TxNonce = ({ canEdit = true }: { canEdit?: boolean } = {}) => {
  const { nonce, recommendedNonce } = useContext(SafeTxContext)

  return (
    <Box data-testid="nonce-fld" display="flex" alignItems="center" gap={1}>
      Nonce{' '}
      <Typography component="span" fontWeight={700}>
        #
      </Typography>
      {nonce === undefined || recommendedNonce === undefined ? (
        <Skeleton width={skeletonMinWidth} height="38px" />
      ) : canEdit ? (
        <TxNonceForm nonce={nonce.toString()} recommendedNonce={recommendedNonce.toString()} />
      ) : (
        <Typography ml={-1} fontWeight={700}>
          {nonce}
        </Typography>
      )}
    </Box>
  )
}

export default TxNonce
</file>

<file path="src/components/tx-flow/common/TxNonce/styles.module.css">
.popper :global .MuiAutocomplete-paper {
  margin-top: calc(var(--space-1) / 2);
  padding-top: var(--space-1);
  padding-bottom: var(--space-1);
  border: 1px solid var(--color-border-light);
}

.popper :global .MuiAutocomplete-listbox {
  max-height: unset;
}

.popper :global .MuiListSubheader-root {
  line-height: 22px;
  margin-bottom: var(--space-1);
}

.popper :global .MuiAutocomplete-option,
.popper :global .MuiListSubheader-root {
  padding-left: var(--space-3);
  padding-right: var(--space-3);
}

.input :global .MuiOutlinedInput-root {
  padding: 0;
}

.input input {
  font-weight: bold;
  min-width: 0px !important;
}

.input.withAdornment input {
  padding-right: 24px !important;
}

.adornment {
  margin-left: 0;
  margin-right: 4px;
  position: absolute;
  right: 0;
}
</file>

<file path="src/components/tx-flow/common/TxStatusWidget/index.tsx">
import { useContext } from 'react'
import { Divider, IconButton, List, ListItem, ListItemIcon, ListItemText, Paper, Typography } from '@mui/material'
import CreatedIcon from '@/public/images/messages/created.svg'
import SignedIcon from '@/public/images/messages/signed.svg'
import { type TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import useSafeInfo from '@/hooks/useSafeInfo'
import { isMultisigExecutionInfo, isSignableBy, isConfirmableBy } from '@/utils/transaction-guards'
import classnames from 'classnames'
import css from './styles.module.css'
import CloseIcon from '@mui/icons-material/Close'
import useWallet from '@/hooks/wallets/useWallet'
import SafeLogo from '@/public/images/logo-no-text.svg'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useIsWalletProposer } from '@/hooks/useProposers'

const TxStatusWidget = ({
  step,
  txSummary,
  handleClose,
  isBatch = false,
  isMessage = false,
}: {
  step: number
  txSummary?: TransactionSummary
  handleClose: () => void
  isBatch?: boolean
  isMessage?: boolean
}) => {
  const wallet = useWallet()
  const { safe } = useSafeInfo()
  const { nonceNeeded } = useContext(SafeTxContext)
  const { threshold } = safe
  const isSafeOwner = useIsSafeOwner()
  const isProposer = useIsWalletProposer()
  const isProposing = isProposer && !isSafeOwner

  const { executionInfo = undefined } = txSummary || {}
  const { confirmationsSubmitted = 0 } = isMultisigExecutionInfo(executionInfo) ? executionInfo : {}

  const canConfirm = txSummary
    ? isConfirmableBy(txSummary, wallet?.address || '')
    : safe.threshold === 1 && !isProposing

  const canSign = txSummary ? isSignableBy(txSummary, wallet?.address || '') : !isProposing

  return (
    <Paper>
      <div className={css.header}>
        <Typography fontWeight="700" display="flex" alignItems="center" gap={1}>
          <SafeLogo width={16} height={16} className={css.logo} />
          {isMessage ? 'Message' : 'Transaction'} status
        </Typography>

        <IconButton className={css.close} aria-label="close" onClick={handleClose} size="small">
          <CloseIcon />
        </IconButton>
      </div>

      <Divider />

      <div className={css.content}>
        <List className={css.status}>
          <ListItem>
            <ListItemIcon>
              <CreatedIcon />
            </ListItemIcon>

            <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>
              {isBatch ? 'Queue transactions' : 'Create'}
            </ListItemText>
          </ListItem>

          <ListItem className={classnames({ [css.incomplete]: !canConfirm && !isBatch })}>
            <ListItemIcon>
              <SignedIcon />
            </ListItemIcon>

            <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>
              {isBatch ? (
                'Create batch'
              ) : !nonceNeeded ? (
                'Confirmed'
              ) : isMessage ? (
                'Collect signatures'
              ) : (
                <>
                  Confirmed ({confirmationsSubmitted} of {threshold})
                  {canSign && (
                    <Typography variant="body2" component="span" className={css.badge}>
                      +1
                    </Typography>
                  )}
                </>
              )}
            </ListItemText>
          </ListItem>

          <ListItem className={classnames({ [css.incomplete]: step < 2 })}>
            <ListItemIcon>
              <SignedIcon />
            </ListItemIcon>

            <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>{isMessage ? 'Done' : 'Execute'}</ListItemText>
          </ListItem>
        </List>
      </div>
    </Paper>
  )
}

export default TxStatusWidget
</file>

<file path="src/components/tx-flow/common/TxStatusWidget/styles.module.css">
.header {
  padding: var(--space-4) var(--space-3);
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
}

.content {
  padding: var(--space-2);
}

.status {
  padding: 0;
}

.status::before {
  content: '';
  position: absolute;
  border-left: 2px solid var(--color-border-light);
  left: 15px;
  top: 20px;
  height: calc(100% - 40px);
}

.status :global .MuiListItem-root:first-of-type {
  padding-top: 0;
}

.status :global .MuiListItem-root {
  padding-left: 0;
  padding-right: 0;
}

.status :global .MuiListItemIcon-root {
  color: var(--color-primary-main);
  justify-content: center;
  min-width: 32px;
  padding: var(--space-1);
  background-color: var(--color-background-paper);
}

[data-theme='light'] .status :global .MuiListItemIcon-root {
  color: var(--color-secondary-dark);
}

.incomplete > * {
  color: var(--color-text-secondary) !important;
}

.close {
  color: var(--color-border-main);
  padding: var(--space-2);
  border-left: 1px solid var(--color-border-light);
  border-radius: 0;
  margin-left: auto;
  display: none;
}

.badge {
  margin-left: var(--space-1);
  padding-right: 2px;
  border-radius: 50%;
  width: var(--space-3);
  height: var(--space-3);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background-color: var(--color-secondary-main);
  color: var(--color-text-primary);
}

[data-theme='dark'] .badge {
  background-color: var(--color-primary-main);
  color: var(--color-text-secondary);
}

@media (max-width: 899.95px) {
  .header {
    padding: 0;
    flex-direction: row;
  }

  .logo {
    width: 24px;
    height: 24px;
    margin-left: 16px;
  }

  .close {
    display: flex;
  }

  .content {
    padding: var(--space-3);
  }
}
</file>

<file path="src/components/tx-flow/common/constants.ts">
export const TOOLTIP_TITLES = {
  THRESHOLD:
    'The threshold of a Safe Account specifies how many signers need to confirm a Safe Account transaction before it can be executed.',
  REVIEW_WINDOW:
    'A period that begins after a recovery is submitted on-chain, during which the Safe Account signers can review the proposal and cancel it before it is executable.',
  PROPOSAL_EXPIRY: 'A period after which the recovery proposal will expire and can no longer be executed.',
} as const
</file>

<file path="src/components/tx-flow/common/styles.module.css">
.cardContent {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  padding: var(--space-3);
}

.cardContent :global .errorMessage {
  margin: 0;
}

.nestedDivider {
  margin: 0 calc(-1 * var(--space-3));
}

.form > :global(.MuiFormControl-root) {
  margin-bottom: 28px;
}

.params {
  margin-bottom: var(--space-2);
}
</file>

<file path="src/components/tx-flow/common/TxButton.tsx">
import Link from 'next/link'
import { useRouter } from 'next/router'
import { Button, type ButtonProps } from '@mui/material'

import { useTxBuilderApp } from '@/hooks/safe-apps/useTxBuilderApp'
import { AppRoutes } from '@/config/routes'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'
import { useContext } from 'react'
import { TxModalContext } from '..'
import SwapIcon from '@/public/images/common/swap.svg'
import AssetsIcon from '@/public/images/sidebar/assets.svg'
import useIsSwapFeatureEnabled from '@/features/swap/hooks/useIsSwapFeatureEnabled'

const buttonSx = {
  height: '58px',
  '& svg path': { fill: 'currentColor' },
}

export const SendTokensButton = ({ onClick, sx }: { onClick: () => void; sx?: ButtonProps['sx'] }) => {
  return (
    <Track {...MODALS_EVENTS.SEND_FUNDS}>
      <Button
        data-testid="send-tokens-btn"
        onClick={onClick}
        variant="contained"
        sx={sx ?? buttonSx}
        fullWidth
        startIcon={<AssetsIcon width={20} />}
      >
        Send tokens
      </Button>
    </Track>
  )
}

export const TxBuilderButton = () => {
  const txBuilder = useTxBuilderApp()
  const router = useRouter()
  const { setTxFlow } = useContext(TxModalContext)

  if (!txBuilder?.app) return null

  const isTxBuilder = typeof txBuilder.link.query === 'object' && router.query.appUrl === txBuilder.link.query?.appUrl
  const onClick = isTxBuilder ? () => setTxFlow(undefined) : undefined

  return (
    <Track {...MODALS_EVENTS.CONTRACT_INTERACTION}>
      <Link href={txBuilder.link} passHref style={{ width: '100%' }}>
        <Button
          variant="outlined"
          sx={buttonSx}
          fullWidth
          onClick={onClick}
          startIcon={<img src={txBuilder.app.iconUrl} height={24} width="auto" alt={txBuilder.app.name} />}
        >
          Transaction Builder
        </Button>
      </Link>
    </Track>
  )
}

export const MakeASwapButton = () => {
  const router = useRouter()
  const { setTxFlow } = useContext(TxModalContext)
  const isSwapFeatureEnabled = useIsSwapFeatureEnabled()
  if (!isSwapFeatureEnabled) return null

  const isSwapPage = router.pathname === AppRoutes.swap
  const onClick = isSwapPage ? () => setTxFlow(undefined) : undefined

  return (
    <Track {...MODALS_EVENTS.SWAP}>
      <Link href={{ pathname: AppRoutes.swap, query: { safe: router.query.safe } }} passHref legacyBehavior>
        <Button variant="contained" sx={buttonSx} fullWidth onClick={onClick} startIcon={<SwapIcon width={20} />}>
          Swap tokens
        </Button>
      </Link>
    </Track>
  )
}
</file>

<file path="src/components/tx-flow/features/SignerSelect/SignerForm/index.tsx">
import {
  Box,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  SvgIcon,
  Tooltip,
  Typography,
  type SelectChangeEvent,
} from '@mui/material'
import { useNestedSafeOwners } from '@/hooks/useNestedSafeOwners'
import { useWalletContext } from '@/hooks/wallets/useWallet'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useCallback, useContext, useEffect, useMemo } from 'react'
import useSafeInfo from '@/hooks/useSafeInfo'
import TxCard from '@/components/tx-flow/common/TxCard'
import InfoIcon from '@/public/images/notifications/info.svg'
import SignatureIcon from '@/public/images/transactions/signature.svg'

import css from './styles.module.css'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import { useIsNestedSafeOwner } from '@/hooks/useIsNestedSafeOwner'

export const SignerForm = ({ willExecute }: { willExecute?: boolean }) => {
  const { signer, setSignerAddress, connectedWallet: wallet } = useWalletContext() ?? {}
  const nestedSafeOwners = useNestedSafeOwners()
  const signerAddress = signer?.address
  const { safe } = useSafeInfo()
  const { safeTx } = useContext(SafeTxContext)
  const isNestedOwner = useIsNestedSafeOwner()

  const onChange = (event: SelectChangeEvent<string>) => {
    trackEvent(MODALS_EVENTS.CHANGE_SIGNER)
    setSignerAddress?.(event.target.value)
  }

  const isOptionEnabled = useCallback(
    (address: string) => {
      if (!safeTx) {
        return true
      }

      if (safeTx.signatures.size < safe.threshold) {
        const signers = Array.from(safeTx.signatures.keys())
        return !signers.some((key) => sameAddress(key, address))
      }

      return true
    },
    [safeTx, safe.threshold],
  )

  const options = useMemo(() => {
    if (!wallet) {
      return []
    }
    const isFullySigned = safeTx ? safeTx.signatures.size >= safe.threshold : false

    // No nested execution for fully signed transactions
    if (isFullySigned && willExecute) {
      return [wallet.address]
    }

    const owners = new Set(nestedSafeOwners ?? [])

    if (safe.owners.some((owner) => sameAddress(owner.value, wallet.address))) {
      owners.add(wallet.address)
    }

    return Array.from(owners)
  }, [nestedSafeOwners, safe.owners, safe.threshold, safeTx, wallet, willExecute])

  // Select first option if no signer is selected and the connected wallet cannot sign
  useEffect(() => {
    const isValidSigner = signerAddress && options.includes(signerAddress) && isOptionEnabled(signerAddress)
    if (isValidSigner || !setSignerAddress || !wallet) {
      return
    }

    const enabledOptions = options.filter(isOptionEnabled)
    if (enabledOptions.length > 0 && !enabledOptions.includes(wallet.address)) {
      setSignerAddress(enabledOptions[0])
    }
  }, [isOptionEnabled, options, setSignerAddress, signerAddress, wallet])

  if (!wallet || !isNestedOwner || (options.length === 1 && options[0] === wallet.address)) {
    return null
  }

  return (
    <TxCard>
      <Typography variant="h5" display="flex" gap={1} alignItems="center">
        <SvgIcon component={SignatureIcon} inheritViewBox fontSize="small" />
        {willExecute ? 'Execute' : 'Sign'} with
        <Tooltip
          title={`Your connected wallet controls other Safe Accounts, which can sign this transaction. You can select which Account to ${
            willExecute ? 'execute' : 'sign'
          } with.`}
          arrow
          placement="top"
        >
          <SvgIcon component={InfoIcon} inheritViewBox color="border" fontSize="small" />
        </Tooltip>
      </Typography>

      <Box display="flex" alignItems="center" gap={1}>
        <FormControl fullWidth size="medium">
          <InputLabel id="signer-label">Signer Account</InputLabel>
          <Select
            className={css.signerForm}
            labelId="signer-label"
            label="Signer account"
            fullWidth
            onChange={onChange}
            value={signerAddress}
          >
            {options?.map((owner) => (
              <MenuItem key={owner} value={owner} disabled={!isOptionEnabled(owner)}>
                <EthHashInfo address={owner} avatarSize={32} onlyName copyAddress={false} />
                {!isOptionEnabled(owner) && (
                  <Typography variant="caption" component="span" className={css.disabledPill}>
                    Already signed
                  </Typography>
                )}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      </Box>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/features/SignerSelect/SignerForm/styles.module.css">
.signerForm :global .MuiOutlinedInput-notchedOutline {
  border: 1px solid var(--color-border-light) !important;
}

.disabledPill {
  background-color: var(--color-border-light);
  border-radius: 4px;
  color: var(--color-text-primary);
  padding: 4px 8px;
}
</file>

<file path="src/components/tx-flow/features/SignerSelect/index.tsx">
import { useContext } from 'react'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'
import { SlotName, withSlot } from '../../slots'
import { SignerForm } from './SignerForm'
import { useWalletContext } from '@/hooks/wallets/useWallet'
import { useIsNestedSafeOwner } from '@/hooks/useIsNestedSafeOwner'

const useShouldRegisterSlot = () => {
  const { connectedWallet } = useWalletContext() ?? {}
  const isNestedOwner = useIsNestedSafeOwner()
  return !!connectedWallet && !!isNestedOwner
}

const SignerSelectSlot = withSlot({
  Component: () => {
    const { willExecute } = useContext(TxFlowContext)
    return <SignerForm willExecute={willExecute} />
  },
  slotName: SlotName.Feature,
  id: 'signerSelect',
  useSlotCondition: useShouldRegisterSlot,
})

export default SignerSelectSlot
</file>

<file path="src/components/tx-flow/features/TxChecks/index.tsx">
import { useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import TxChecks from './TxChecks'
import { SlotName, withSlot } from '../../slots'

const useShouldRegisterSlot = () => {
  const { isRejection } = useContext(TxFlowContext)
  const { safeTx } = useContext(SafeTxContext)
  const isCounterfactualSafe = useIsCounterfactualSafe()

  return !isCounterfactualSafe && !isRejection && !!safeTx
}

const TxChecksSlot = withSlot({
  Component: () => {
    const { safeTx } = useContext(SafeTxContext)

    if (!safeTx) return false

    return <TxChecks transaction={safeTx} />
  },
  slotName: SlotName.Feature,
  id: 'txChecks',
  useSlotCondition: useShouldRegisterSlot,
})

export default TxChecksSlot
</file>

<file path="src/components/tx-flow/features/TxChecks/styles.module.css">
.mobileTxCheckMessages,
.mobileTxCheckMessages:empty {
  display: none;
}

@media (max-width: 899.95px) {
  .mobileTxCheckMessages {
    display: block;
  }
}
</file>

<file path="src/components/tx-flow/features/TxChecks/TxChecks.tsx">
import { useCurrentChain, useHasFeature } from '@/hooks/useChains'
import { type ReactElement } from 'react'
import { TxSimulation, TxSimulationMessage } from '@/components/tx/security/tenderly'
import TxCard from '@/components/tx-flow/common/TxCard'
import { Box, Typography } from '@mui/material'

import type { SafeTransaction, MetaTransactionData } from '@safe-global/safe-core-sdk-types'

import css from './styles.module.css'
import { FEATURES } from '@safe-global/utils/utils/chains'
import { isTxSimulationEnabled } from '@safe-global/utils/components/tx/security/tenderly/utils'

const TxChecks = ({
  executionOwner,
  disabled = false,
  transaction,
}: {
  executionOwner?: string
  disabled?: boolean
  transaction: SafeTransaction | Array<MetaTransactionData>
}): ReactElement | null => {
  const chain = useCurrentChain()
  const isRiskMitigationFeatureEnabled = useHasFeature(FEATURES.RISK_MITIGATION)
  const isTxSimulationFeatureEnabled = isTxSimulationEnabled(chain)

  return (
    <TxCard>
      <Typography variant="h5">Transaction checks</Typography>

      {(isTxSimulationFeatureEnabled || isRiskMitigationFeatureEnabled) && (
        <>
          <TxSimulation disabled={disabled} transactions={transaction} executionOwner={executionOwner} />

          <Box className={css.mobileTxCheckMessages}>
            <TxSimulationMessage />
          </Box>
        </>
      )}
    </TxCard>
  )
}

export default TxChecks
</file>

<file path="src/components/tx-flow/features/ExecuteCheckbox.tsx">
import { useContext } from 'react'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import { SlotName, withSlot } from '../slots'
import ExecuteCheckbox from '@/components/tx/ExecuteCheckbox'

const useShouldRegisterSlot = () => {
  const { canExecute, onlyExecute, isProposing, canExecuteThroughRole } = useContext(TxFlowContext)
  const isCounterfactualSafe = useIsCounterfactualSafe()

  return (canExecute || canExecuteThroughRole) && !onlyExecute && !isCounterfactualSafe && !isProposing
}

const ExecuteCheckboxSlot = withSlot({
  Component: () => {
    const { setShouldExecute } = useContext(TxFlowContext)
    return <ExecuteCheckbox onChange={setShouldExecute} />
  },
  slotName: SlotName.Footer,
  id: 'executeCheckbox',
  useSlotCondition: useShouldRegisterSlot,
})

export default ExecuteCheckboxSlot
</file>

<file path="src/components/tx-flow/features/index.ts">
import dynamic from 'next/dynamic'

export const ExecuteCheckbox = dynamic(() => import('./ExecuteCheckbox'))
export const TxChecks = dynamic(() => import('./TxChecks'))
export const TxNote = dynamic(() => import('./TxNote'))
export const SignerSelect = dynamic(() => import('./SignerSelect'))
</file>

<file path="src/components/tx-flow/features/TxNote.tsx">
import type { ReactElement } from 'react'
import { useCallback, useContext } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'
import { encodeTxNote, TxNoteForm } from '@/features/tx-notes'
import { SlotName, withSlot } from '../slots'

const TxNote = (): ReactElement => {
  const { txOrigin, setTxOrigin } = useContext(SafeTxContext)
  const { txDetails, isCreation } = useContext(TxFlowContext)

  const onNoteChange = useCallback(
    (note: string) => {
      setTxOrigin(encodeTxNote(note, txOrigin))
    },
    [setTxOrigin, txOrigin],
  )

  return <TxNoteForm isCreation={isCreation} onChange={onNoteChange} txDetails={txDetails} />
}

const useShouldRegisterSlot = () => {
  const { txDetails, isCreation } = useContext(TxFlowContext)

  return isCreation || !!txDetails?.note
}

const TxNoteSlot = withSlot({
  Component: TxNote,
  slotName: SlotName.Sidebar,
  id: 'txNote',
  useSlotCondition: useShouldRegisterSlot,
})

export default TxNoteSlot
</file>

<file path="src/components/tx-flow/flows/AddOwner/ChooseOwner.tsx">
import {
  Box,
  Typography,
  FormControl,
  InputAdornment,
  CircularProgress,
  Button,
  CardActions,
  Divider,
  Grid,
  TextField,
  MenuItem,
  SvgIcon,
  Tooltip,
} from '@mui/material'
import { useForm, FormProvider, Controller } from 'react-hook-form'

import AddressBookInput from '@/components/common/AddressBookInput'
import NameInput from '@/components/common/NameInput'
import { useAddressResolver } from '@/hooks/useAddressResolver'
import useSafeInfo from '@/hooks/useSafeInfo'
import { uniqueAddress, addressIsNotCurrentSafe } from '@safe-global/utils/utils/validation'
import type { AddOwnerFlowProps } from '.'
import type { ReplaceOwnerFlowProps } from '../ReplaceOwner'
import TxCard from '../../common/TxCard'
import InfoIcon from '@/public/images/notifications/info.svg'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TOOLTIP_TITLES } from '@/components/tx-flow/common/constants'
import EthHashInfo from '@/components/common/EthHashInfo'
import { maybePlural } from '@safe-global/utils/utils/formatters'

type FormData = Pick<AddOwnerFlowProps | ReplaceOwnerFlowProps, 'newOwner' | 'threshold'>

export enum ChooseOwnerMode {
  REPLACE,
  ADD,
}

export const ChooseOwner = ({
  params,
  onSubmit,
  mode,
}: {
  params: AddOwnerFlowProps | ReplaceOwnerFlowProps
  onSubmit: (data: FormData) => void
  mode: ChooseOwnerMode
}) => {
  const { safe, safeAddress } = useSafeInfo()

  const formMethods = useForm<FormData>({
    defaultValues: params,
    mode: 'onChange',
  })
  const { handleSubmit, formState, watch, control } = formMethods
  const isValid = Object.keys(formState.errors).length === 0 // do not use formState.isValid because names can be empty

  const notAlreadyOwner = uniqueAddress(safe.owners.map((owner) => owner.value))
  const notCurrentSafe = addressIsNotCurrentSafe(safeAddress)
  const combinedValidate = (address: string) => notAlreadyOwner(address) || notCurrentSafe(address)

  const address = watch('newOwner.address')

  const { name, ens, resolving } = useAddressResolver(address)

  // Address book, ENS
  const fallbackName = name || ens

  const onFormSubmit = handleSubmit((formData: FormData) => {
    onSubmit({
      ...formData,
      newOwner: {
        ...formData.newOwner,
        name: formData.newOwner.name || fallbackName,
      },
      threshold: formData.threshold,
    })
  })

  const newNumberOfOwners = safe.owners.length + (!params.removedOwner ? 1 : 0)

  return (
    <TxCard>
      <FormProvider {...formMethods}>
        <form onSubmit={onFormSubmit} className={commonCss.form}>
          {params.removedOwner && (
            <>
              <Typography
                variant="body2"
                sx={{
                  mb: 1,
                }}
              >
                {params.removedOwner &&
                  'Review the signer you want to replace in the active Safe Account, then specify the new signer you want to replace it with:'}
              </Typography>
              <Box
                sx={{
                  my: 3,
                }}
              >
                <Typography
                  variant="body2"
                  sx={{
                    color: 'text.secondary',
                    mb: 1,
                  }}
                >
                  Current signer
                </Typography>
                <EthHashInfo address={params.removedOwner.address} showCopyButton shortAddress={false} hasExplorer />
              </Box>
            </>
          )}

          <FormControl fullWidth>
            <NameInput
              label="New signer"
              name="newOwner.name"
              placeholder={fallbackName || 'Signer name'}
              InputLabelProps={{ shrink: true }}
              InputProps={{
                endAdornment: resolving && (
                  <InputAdornment position="end">
                    <CircularProgress size={20} />
                  </InputAdornment>
                ),
              }}
            />
          </FormControl>

          <FormControl fullWidth>
            <AddressBookInput
              name="newOwner.address"
              label="Signer address or ENS"
              validate={combinedValidate}
              required
            />
          </FormControl>

          <Divider className={commonCss.nestedDivider} />

          {mode === ChooseOwnerMode.ADD && (
            <FormControl fullWidth>
              <Typography
                variant="h6"
                sx={{
                  fontWeight: 700,
                  mt: 3,
                }}
              >
                Threshold
                <Tooltip title={TOOLTIP_TITLES.THRESHOLD} arrow placement="top">
                  <span>
                    <SvgIcon
                      component={InfoIcon}
                      inheritViewBox
                      color="border"
                      fontSize="small"
                      sx={{
                        verticalAlign: 'middle',
                        ml: 0.5,
                      }}
                    />
                  </span>
                </Tooltip>
              </Typography>

              <Typography
                variant="body2"
                sx={{
                  mb: 1,
                }}
              >
                Any transaction requires the confirmation of:
              </Typography>

              <Grid
                container
                direction="row"
                sx={{
                  alignItems: 'center',
                  gap: 2,
                  pt: 1,
                }}
              >
                <Grid item>
                  <Controller
                    control={control}
                    name="threshold"
                    render={({ field }) => (
                      <TextField data-testid="owner-number-dropdown" select {...field}>
                        {safe.owners.map((_, idx) => (
                          <MenuItem key={idx + 1} value={idx + 1}>
                            {idx + 1}
                          </MenuItem>
                        ))}
                        {!params.removedOwner && (
                          <MenuItem key={newNumberOfOwners} value={newNumberOfOwners}>
                            {newNumberOfOwners}
                          </MenuItem>
                        )}
                      </TextField>
                    )}
                  />
                </Grid>
                <Grid item>
                  <Typography>
                    out of {newNumberOfOwners} signer{maybePlural(newNumberOfOwners)}
                  </Typography>
                </Grid>
              </Grid>
            </FormControl>
          )}

          <Divider className={commonCss.nestedDivider} />

          <CardActions>
            <Button data-testid="add-owner-next-btn" variant="contained" type="submit" disabled={!isValid || resolving}>
              Next
            </Button>
          </CardActions>
        </form>
      </FormProvider>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/AddOwner/context.ts">
import { type Context, createContext } from 'react'
import { type AddOwnerFlowProps } from '.'
import { type ReplaceOwnerFlowProps } from '../ReplaceOwner'

type SettingsChange = Context<AddOwnerFlowProps | ReplaceOwnerFlowProps>

export const SettingsChangeContext: SettingsChange = createContext({} as AddOwnerFlowProps | ReplaceOwnerFlowProps)
</file>

<file path="src/components/tx-flow/flows/AddOwner/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import useTxStepper from '@/components/tx-flow/useTxStepper'
import { ChooseOwner, ChooseOwnerMode } from '@/components/tx-flow/flows/AddOwner/ChooseOwner'
import { ReviewOwner } from '@/components/tx-flow/flows/AddOwner/ReviewOwner'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import useSafeInfo from '@/hooks/useSafeInfo'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { useMemo } from 'react'
import { TxFlowType } from '@/services/analytics'

type Owner = {
  address: string
  name?: string
}

export type AddOwnerFlowProps = {
  newOwner: Owner
  removedOwner?: Owner
  threshold: number
}

const FlowInner = ({ defaultValues }: { defaultValues: AddOwnerFlowProps }) => {
  const { data, step, nextStep, prevStep } = useTxStepper<AddOwnerFlowProps>(defaultValues, TxFlowType.ADD_OWNER)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'New transaction' },
        content: (
          <ChooseOwner
            key={0}
            params={data}
            onSubmit={(formData) => nextStep({ ...data, ...formData })}
            mode={ChooseOwnerMode.ADD}
          />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewOwner key={1} params={data} onSubmit={() => nextStep(data)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, data],
  )

  return (
    <TxLayout
      subtitle="Add signer"
      icon={SaveAddressIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

const AddOwnerFlow = ({ address }: { address?: string }) => {
  const { safe, safeLoading, safeLoaded } = useSafeInfo()

  const defaultValues: AddOwnerFlowProps = {
    newOwner: {
      address: address || '',
      name: '',
    },
    threshold: safe.threshold,
  }

  if (!safeLoaded || safeLoading) return null

  return <FlowInner defaultValues={defaultValues} />
}

export default AddOwnerFlow
</file>

<file path="src/components/tx-flow/flows/AddOwner/ReviewOwner.tsx">
import { useCurrentChain } from '@/hooks/useChains'
import { useContext, useEffect } from 'react'

import useSafeInfo from '@/hooks/useSafeInfo'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import { createSwapOwnerTx, createAddOwnerTx } from '@/services/tx/tx-sender'
import { useAppDispatch } from '@/store'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'
import { SafeTxContext } from '../../SafeTxProvider'
import type { AddOwnerFlowProps } from '.'
import type { ReplaceOwnerFlowProps } from '../ReplaceOwner'
import { SettingsChangeContext } from './context'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const ReviewOwner = ({
  params,
  onSubmit,
}: {
  params: AddOwnerFlowProps | ReplaceOwnerFlowProps
  onSubmit?: () => void
}) => {
  const dispatch = useAppDispatch()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const { safe } = useSafeInfo()
  const { chainId } = safe
  const chain = useCurrentChain()
  const { newOwner, removedOwner, threshold } = params

  useEffect(() => {
    if (!chain) return

    const promise = removedOwner
      ? createSwapOwnerTx(chain, safe.deployed, {
          newOwnerAddress: newOwner.address,
          oldOwnerAddress: removedOwner.address,
        })
      : createAddOwnerTx(chain, safe.deployed, {
          ownerAddress: newOwner.address,
          threshold,
        })

    promise.then(setSafeTx).catch(setSafeTxError)
  }, [removedOwner, newOwner, threshold, setSafeTx, setSafeTxError, chain, safe.deployed])

  const addAddressBookEntryAndSubmit = () => {
    if (typeof newOwner.name !== 'undefined') {
      dispatch(
        upsertAddressBookEntries({
          chainIds: [chainId],
          address: newOwner.address,
          name: newOwner.name,
        }),
      )
    }

    trackEvent({ ...SETTINGS_EVENTS.SETUP.THRESHOLD, label: safe.threshold })
    trackEvent({ ...SETTINGS_EVENTS.SETUP.OWNERS, label: safe.owners.length })
  }

  const handleSubmit = () => {
    addAddressBookEntryAndSubmit()
    onSubmit?.()
  }

  return (
    <SettingsChangeContext.Provider value={params}>
      <ReviewTransaction onSubmit={handleSubmit} />
    </SettingsChangeContext.Provider>
  )
}
</file>

<file path="src/components/tx-flow/flows/CancelRecovery/CancelRecoveryFlowReview.tsx">
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Typography } from '@mui/material'
import { useContext } from 'react'
import type { ReactElement } from 'react'

import { SafeTxContext } from '../../SafeTxProvider'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { getRecoverySkipTransaction } from '@/features/recovery/services/transaction'
import { createTx } from '@/services/tx/tx-sender'
import ErrorMessage from '@/components/tx/ErrorMessage'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import useAsync from '@safe-global/utils/hooks/useAsync'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export function CancelRecoveryFlowReview({
  recovery,
  onSubmit,
}: {
  recovery: RecoveryQueueItem
  onSubmit: () => void
}): ReactElement {
  const web3ReadOnly = useWeb3ReadOnly()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)

  useAsync(async () => {
    if (!web3ReadOnly) {
      return
    }
    const transaction = await getRecoverySkipTransaction(recovery, web3ReadOnly)
    createTx(transaction).then(setSafeTx).catch(setSafeTxError)
  }, [setSafeTx, setSafeTxError, recovery, web3ReadOnly])

  const handleSubmit = () => {
    trackEvent({ ...RECOVERY_EVENTS.SUBMIT_RECOVERY_CANCEL })
    onSubmit()
  }

  return (
    <ReviewTransaction onSubmit={handleSubmit} isBatchable={false}>
      <Typography mb={1}>
        All actions initiated by the Recoverer will be cancelled. The current signers will remain the signers of the
        Safe Account.
      </Typography>

      <ErrorMessage level="info">
        This transaction will initiate the cancellation of the{' '}
        {recovery.isMalicious ? 'malicious transaction' : 'recovery proposal'}. It requires other signer signatures in
        order to be executed.
      </ErrorMessage>
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/CancelRecovery/CancelRecoveryOverview.tsx">
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Box, Button, Typography } from '@mui/material'
import { useContext } from 'react'
import type { ReactElement } from 'react'

import css from './styles.module.css'

import ReplaceTxIcon from '@/public/images/transactions/replace-tx.svg'
import { TxModalContext } from '../..'
import TxCard from '../../common/TxCard'

export function CancelRecoveryOverview({ onSubmit }: { onSubmit: () => void }): ReactElement {
  const { setTxFlow } = useContext(TxModalContext)

  const onClose = () => {
    setTxFlow(undefined)
    trackEvent(RECOVERY_EVENTS.GO_BACK)
  }

  return (
    <TxCard>
      <Box display="flex" flexDirection="column" alignItems="center" p={{ md: 5 }}>
        {/* TODO: Replace with correct icon when provided */}
        <ReplaceTxIcon />

        <Typography mb={1} variant="h4" mt={5} fontWeight={700} textAlign="center">
          Do you want to cancel the Account recovery?
        </Typography>

        <Typography variant="body2" mb={3} textAlign="center">
          If it is an unwanted recovery proposal or you&apos;ve noticed something suspicious, you can cancel it at any
          time.
        </Typography>

        <Box display="flex" columnGap={3} rowGap={1} flexWrap="wrap">
          <Button variant="outlined" onClick={onClose} className={css.button} size="small">
            Go back
          </Button>

          <Button data-testid="cancel-proposal-btn" variant="contained" onClick={onSubmit} className={css.button}>
            Yes, cancel proposal
          </Button>
        </Box>
      </Box>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/CancelRecovery/index.tsx">
import { useMemo, type ReactElement } from 'react'
import TxLayout from '../../common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import { CancelRecoveryFlowReview } from './CancelRecoveryFlowReview'
import { CancelRecoveryOverview } from './CancelRecoveryOverview'
import useTxStepper from '../../useTxStepper'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

const TITLE = 'Cancel Account recovery'

function CancelRecoveryFlow({ recovery }: { recovery: RecoveryQueueItem }): ReactElement {
  const { step, nextStep, prevStep } = useTxStepper<undefined>(undefined, TxFlowType.CANCEL_RECOVERY)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: TITLE, hideNonce: true },
        content: <CancelRecoveryOverview key={0} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction', subtitle: TITLE },
        content: <CancelRecoveryFlowReview key={1} recovery={recovery} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', subtitle: TITLE, fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, recovery],
  )

  return (
    <TxLayout step={step} onBack={prevStep} {...(steps?.[step]?.txLayoutProps || {})}>
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default CancelRecoveryFlow
</file>

<file path="src/components/tx-flow/flows/CancelRecovery/styles.module.css">
.button {
  width: 100%;
}

@media (min-width: 600px) {
  .button {
    width: auto;
  }
}
</file>

<file path="src/components/tx-flow/flows/ChangeThreshold/ChooseThreshold.tsx">
import { Controller, useForm } from 'react-hook-form'
import {
  TextField,
  MenuItem,
  Button,
  CardActions,
  Divider,
  Typography,
  Box,
  Grid,
  SvgIcon,
  Tooltip,
} from '@mui/material'
import { useContext, useEffect } from 'react'
import useSafeInfo from '@/hooks/useSafeInfo'
import TxCard from '@/components/tx-flow/common/TxCard'
import { ChangeThresholdFlowFieldNames } from '@/components/tx-flow/flows/ChangeThreshold'
import type { ChangeThresholdFlowProps } from '@/components/tx-flow/flows/ChangeThreshold'
import InfoIcon from '@/public/images/notifications/info.svg'
import { TOOLTIP_TITLES } from '@/components/tx-flow/common/constants'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { createUpdateThresholdTx } from '@/services/tx/tx-sender'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'

export const ChooseThreshold = () => {
  const { onNext, data } = useContext(TxFlowContext)
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const { safe } = useSafeInfo()

  const formMethods = useForm<ChangeThresholdFlowProps>({
    defaultValues: data,
    mode: 'onChange',
  })

  const newThreshold = formMethods.watch(ChangeThresholdFlowFieldNames.threshold)

  useEffect(() => {
    createUpdateThresholdTx(newThreshold).then(setSafeTx).catch(setSafeTxError)
  }, [newThreshold, setSafeTx, setSafeTxError])

  return (
    <TxCard>
      <div>
        <Typography
          variant="h3"
          sx={{
            fontWeight: 700,
          }}
        >
          Threshold
          <Tooltip title={TOOLTIP_TITLES.THRESHOLD} arrow placement="top">
            <span>
              <SvgIcon
                component={InfoIcon}
                inheritViewBox
                color="border"
                fontSize="small"
                sx={{
                  verticalAlign: 'middle',
                  ml: 0.5,
                }}
              />
            </span>
          </Tooltip>
        </Typography>

        <Typography>Any transaction will require the confirmation of:</Typography>
      </div>
      <form onSubmit={formMethods.handleSubmit(onNext)}>
        <Box
          sx={{
            mb: 2,
          }}
        >
          <Controller
            control={formMethods.control}
            rules={{
              validate: (value) => {
                if (value === safe.threshold) {
                  return `Current policy is already set to ${safe.threshold}.`
                }
              },
            }}
            name={ChangeThresholdFlowFieldNames.threshold}
            render={({ field, fieldState }) => {
              const isError = !!fieldState.error

              return (
                <Grid
                  container
                  direction="row"
                  sx={{
                    gap: 2,
                    alignItems: 'center',
                  }}
                >
                  <Grid item>
                    <TextField select {...field} error={isError}>
                      {safe.owners.map((_, idx) => (
                        <MenuItem data-testid="threshold-item" key={idx + 1} value={idx + 1}>
                          {idx + 1}
                        </MenuItem>
                      ))}
                    </TextField>
                  </Grid>
                  <Grid item>
                    <Typography>
                      out of {safe.owners.length} signer{maybePlural(safe.owners)}
                    </Typography>
                  </Grid>
                  <Grid item xs={12}>
                    {isError ? (
                      <Typography
                        color="error"
                        sx={{
                          mb: 2,
                        }}
                      >
                        {fieldState.error?.message}
                      </Typography>
                    ) : (
                      <Typography
                        sx={{
                          mb: 2,
                        }}
                      >
                        {fieldState.isDirty ? 'Previous policy was ' : 'Current policy is '}
                        <b>
                          {safe.threshold} out of {safe.owners.length}
                        </b>
                        .
                      </Typography>
                    )}
                  </Grid>
                </Grid>
              )
            }}
          />
        </Box>

        <Divider className={commonCss.nestedDivider} />

        <CardActions>
          <Button
            data-testid="threshold-next-btn"
            variant="contained"
            type="submit"
            disabled={
              !!formMethods.formState.errors[ChangeThresholdFlowFieldNames.threshold] ||
              // Prevent initial submit before field was interacted with
              newThreshold === safe.threshold
            }
          >
            Next
          </Button>
        </CardActions>
      </form>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/ChangeThreshold/index.tsx">
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import useSafeInfo from '@/hooks/useSafeInfo'
import { ChooseThreshold } from './ChooseThreshold'
import { SETTINGS_EVENTS, trackEvent, TxFlowType } from '@/services/analytics'
import { type SubmitCallbackWithData, TxFlow } from '../../TxFlow'
import { TxFlowStep } from '../../TxFlowStep'

export enum ChangeThresholdFlowFieldNames {
  threshold = 'threshold',
}

export type ChangeThresholdFlowProps = {
  [ChangeThresholdFlowFieldNames.threshold]: number
}

const ChangeThresholdFlow = () => {
  const {
    safe: { threshold, owners },
  } = useSafeInfo()

  const trackEvents = (newThreshold: number) => {
    trackEvent({ ...SETTINGS_EVENTS.SETUP.OWNERS, label: owners.length })
    trackEvent({ ...SETTINGS_EVENTS.SETUP.THRESHOLD, label: newThreshold })
  }

  const handleSubmit: SubmitCallbackWithData<ChangeThresholdFlowProps> = ({ data }) => {
    trackEvents(data?.threshold || threshold)
  }

  return (
    <TxFlow
      initialData={{ threshold }}
      icon={SaveAddressIcon}
      subtitle="Change threshold"
      onSubmit={handleSubmit}
      eventCategory={TxFlowType.CHANGE_THRESHOLD}
    >
      <TxFlowStep title="New transaction">
        <ChooseThreshold key={0} />
      </TxFlowStep>
    </TxFlow>
  )
}

export default ChangeThresholdFlow
</file>

<file path="src/components/tx-flow/flows/ConfirmBatch/index.tsx">
import { type ReactElement, useContext, useEffect, useMemo } from 'react'
import { type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { createMultiSendCallOnlyTx } from '@/services/tx/tx-sender'
import { SafeTxContext } from '../../SafeTxProvider'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'
import { OperationType } from '@safe-global/safe-core-sdk-types'
import TxLayout from '../../common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import BatchIcon from '@/public/images/common/batch.svg'
import { useDraftBatch } from '@/hooks/useDraftBatch'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import useTxStepper from '../../useTxStepper'
import ReviewTransaction from '@/components/tx/ReviewTransaction'
import { TxFlowType } from '@/services/analytics'

type ConfirmBatchProps = {
  onSubmit: () => void
}

const getData = (txDetails: TransactionDetails): MetaTransactionData => {
  return {
    to: txDetails.txData?.to.value ?? '',
    value: txDetails.txData?.value ?? '0',
    data: txDetails.txData?.hexData ?? '0x',
    operation: OperationType.Call, // only calls can be batched
  }
}

const ConfirmBatch = ({ onSubmit }: ConfirmBatchProps): ReactElement => {
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const batchTxs = useDraftBatch()

  useEffect(() => {
    const calls = batchTxs.map((tx) => getData(tx.txDetails))
    createMultiSendCallOnlyTx(calls).then(setSafeTx).catch(setSafeTxError)
  }, [batchTxs, setSafeTx, setSafeTxError])

  return <ReviewTransaction onSubmit={onSubmit} isBatch />
}

const ConfirmBatchFlow = (props: ConfirmBatchProps) => {
  const { length } = useDraftBatch()
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.CONFIRM_BATCH)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm batch' },
        content: <ConfirmBatch key={0} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={1} {...props} />,
      },
    ],
    [nextStep, props],
  )

  return (
    <TxLayout
      subtitle={`This batch contains ${length} transaction${maybePlural(length)}`}
      icon={BatchIcon}
      step={step}
      onBack={prevStep}
      isBatch
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default ConfirmBatchFlow
</file>

<file path="src/components/tx-flow/flows/ConfirmTx/ConfirmProposedTx.tsx">
import { type PropsWithChildren, type ReactElement, useContext, useEffect } from 'react'
import { Typography } from '@mui/material'
import { useChainId } from '@/hooks/useChainId'
import { createExistingTx } from '@/services/tx/tx-sender'
import ReviewTransaction from '@/components/tx/ReviewTransactionV2'
import type { ReviewTransactionContentProps } from '@/components/tx/ReviewTransactionV2/ReviewTransactionContent'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { TxFlowContext } from '@/components/tx-flow/TxFlowProvider'

type ConfirmProposedTxProps = PropsWithChildren<
  {
    txNonce: number | undefined
  } & ReviewTransactionContentProps
>

const SIGN_TEXT = 'Sign this transaction.'
const EXECUTE_TEXT = 'Submit the form to execute this transaction.'
const SIGN_EXECUTE_TEXT = 'Sign or immediately execute this transaction.'

const ConfirmProposedTx = ({ txNonce, children, ...props }: ConfirmProposedTxProps): ReactElement => {
  const chainId = useChainId()
  const { setSafeTx, setSafeTxError, setNonce } = useContext(SafeTxContext)
  const { txId, onlyExecute, isExecutable } = useContext(TxFlowContext)

  useEffect(() => {
    txNonce !== undefined && setNonce(txNonce)
  }, [setNonce, txNonce])

  useEffect(() => {
    if (txId) {
      createExistingTx(chainId, txId).then(setSafeTx).catch(setSafeTxError)
    }
  }, [txId, chainId, setSafeTx, setSafeTxError])

  const text = !onlyExecute ? (isExecutable ? SIGN_EXECUTE_TEXT : SIGN_TEXT) : EXECUTE_TEXT

  return (
    <ReviewTransaction {...props}>
      <Typography mb={1}>{text}</Typography>
      {children}
    </ReviewTransaction>
  )
}

export default ConfirmProposedTx
</file>

<file path="src/components/tx-flow/flows/ConfirmTx/index.tsx">
import { isSwapOrderTxInfo } from '@/utils/transaction-guards'
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import ConfirmProposedTx from './ConfirmProposedTx'
import { useTransactionType } from '@/hooks/useTransactionType'
import SwapIcon from '@/public/images/common/swap.svg'
import { isExecutable, isMultisigExecutionInfo, isSignableBy } from '@/utils/transaction-guards'
import { useSigner } from '@/hooks/wallets/useWallet'
import useSafeInfo from '@/hooks/useSafeInfo'
import { TxFlow } from '../../TxFlow'
import { TxFlowType } from '@/services/analytics'

const ConfirmTxFlow = ({ txSummary }: { txSummary: TransactionSummary }) => {
  const { text } = useTransactionType(txSummary)
  const isSwapOrder = isSwapOrderTxInfo(txSummary.txInfo)
  const signer = useSigner()
  const { safe } = useSafeInfo()

  const txId = txSummary.id
  const txNonce = isMultisigExecutionInfo(txSummary.executionInfo) ? txSummary.executionInfo.nonce : undefined
  const canExecute = isExecutable(txSummary, signer?.address || '', safe)
  const canSign = isSignableBy(txSummary, signer?.address || '')

  return (
    <TxFlow
      icon={isSwapOrder && SwapIcon}
      subtitle={<>{text}&nbsp;</>}
      txId={txId}
      isExecutable={canExecute}
      onlyExecute={!canSign}
      txSummary={txSummary}
      ReviewTransactionComponent={(props) => <ConfirmProposedTx txNonce={txNonce} {...props} />}
      eventCategory={TxFlowType.CONFIRM_TX}
    />
  )
}

export default ConfirmTxFlow
</file>

<file path="src/components/tx-flow/flows/CreateNestedSafe/index.tsx">
import { useCallback, useMemo, useState, type ReactElement } from 'react'

import NestedSafeIcon from '@/public/images/sidebar/nested-safes-icon.svg'
import TxLayout, { type TxStep } from '@/components/tx-flow/common/TxLayout'
import useTxStepper from '@/components/tx-flow/useTxStepper'
import { ReviewNestedSafe } from '@/components/tx-flow/flows/CreateNestedSafe/ReviewNestedSafe'
import { SetUpNestedSafe } from '@/components/tx-flow/flows/CreateNestedSafe/SetupNestedSafe'
import type { SetupNestedSafeForm } from '@/components/tx-flow/flows/CreateNestedSafe/SetupNestedSafe'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { useAppDispatch } from '@/store'
import { upsertAddressBookEntries } from '@/store/addressBookSlice'
import useSafeInfo from '@/hooks/useSafeInfo'

export function CreateNestedSafe(): ReactElement {
  const dispatch = useAppDispatch()
  const { safe } = useSafeInfo()
  const [predictedSafeAddress, setPredictedSafeAddress] = useState<string | undefined>()

  const { data, step, nextStep, prevStep } = useTxStepper<SetupNestedSafeForm>({
    name: '',
    assets: [],
  })

  const handleSubmit = useCallback(() => {
    if (!predictedSafeAddress) {
      return
    }
    dispatch(
      upsertAddressBookEntries({
        chainIds: [safe.chainId],
        address: predictedSafeAddress,
        name: data.name,
      }),
    )
  }, [dispatch, data.name, predictedSafeAddress, safe.chainId])

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Set up Nested Safe' },
        content: <SetUpNestedSafe key={0} params={data} onSubmit={(formData) => nextStep({ ...data, ...formData })} />,
      },
      {
        txLayoutProps: { title: 'Confirm Nested Safe' },
        content: (
          <ReviewNestedSafe
            key={1}
            params={data}
            onSubmit={(predictedSafeAddress) => {
              setPredictedSafeAddress(predictedSafeAddress)
              nextStep(data)
            }}
          />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={handleSubmit} />,
      },
    ],
    [nextStep, data, handleSubmit],
  )

  return (
    <TxLayout
      subtitle="Create a Nested Safe"
      icon={NestedSafeIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}
</file>

<file path="src/components/tx-flow/flows/CreateNestedSafe/ReviewNestedSafe.tsx">
import { skipToken } from '@reduxjs/toolkit/query'
import { useCallback, useContext, useEffect, useMemo } from 'react'
import type { ReactElement } from 'react'
import type { MetaTransactionData, SafeTransaction } from '@safe-global/safe-core-sdk-types'

import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import useSafeInfo from '@/hooks/useSafeInfo'
import useBalances from '@/hooks/useBalances'
import { useCurrentChain } from '@/hooks/useChains'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { createNewUndeployedSafeWithoutSalt, encodeSafeCreationTx } from '@/components/new-safe/create/logic'
import { useGetOwnedSafesQuery } from '@/store/slices'
import { predictAddressBasedOnReplayData } from '@/features/multichain/utils/utils'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { createTokenTransferParams } from '@/services/tx/tokenTransferParams'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import { SetupNestedSafeFormAssetFields } from '@/components/tx-flow/flows/CreateNestedSafe/SetupNestedSafe'
import type { SetupNestedSafeForm } from '@/components/tx-flow/flows/CreateNestedSafe/SetupNestedSafe'
import ReviewTransaction from '@/components/tx/ReviewTransaction'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

export function ReviewNestedSafe({
  params,
  onSubmit,
}: {
  params: SetupNestedSafeForm
  onSubmit: (predictedSafeAddress?: string) => void
}): ReactElement {
  const { safeAddress, safe, safeLoaded } = useSafeInfo()
  const chain = useCurrentChain()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const { balances } = useBalances()
  const provider = useWeb3ReadOnly()
  const { data: nestedSafes } = useGetOwnedSafesQuery(
    safeLoaded ? { chainId: safe.chainId, ownerAddress: safeAddress } : skipToken,
  )
  const version = getLatestSafeVersion(chain)

  const safeAccountConfig = useMemo(() => {
    if (!chain || !nestedSafes) {
      return
    }

    const undeployedSafe = createNewUndeployedSafeWithoutSalt(
      version,
      {
        owners: [safeAddress],
        threshold: 1,
      },
      chain,
    )
    const saltNonce = Date.now().toString()

    return {
      ...undeployedSafe,
      saltNonce,
    }
  }, [chain, safeAddress, nestedSafes, version])

  const [predictedSafeAddress] = useAsync(async () => {
    if (provider && safeAccountConfig) {
      return predictAddressBasedOnReplayData(safeAccountConfig, provider)
    }
  }, [provider, safeAccountConfig])

  useEffect(() => {
    if (!chain || !safeAccountConfig || !predictedSafeAddress) {
      return
    }

    const deploymentTx = {
      to: safeAccountConfig.factoryAddress,
      data: encodeSafeCreationTx(safeAccountConfig, chain),
      value: '0',
    }

    const fundingTxs: Array<MetaTransactionData> = []

    for (const asset of params.assets) {
      const token = balances.items.find((item) => {
        return item.tokenInfo.address === asset[SetupNestedSafeFormAssetFields.tokenAddress]
      })

      if (token) {
        fundingTxs.push(
          createTokenTransferParams(
            predictedSafeAddress,
            asset[SetupNestedSafeFormAssetFields.amount],
            token.tokenInfo.decimals,
            token.tokenInfo.address,
          ),
        )
      }
    }

    const createSafeTx = async (): Promise<SafeTransaction> => {
      const isMultiSend = fundingTxs.length > 0
      return isMultiSend ? createMultiSendCallOnlyTx([deploymentTx, ...fundingTxs]) : createTx(deploymentTx)
    }

    createSafeTx().then(setSafeTx).catch(setSafeTxError)
  }, [chain, params.assets, safeAccountConfig, predictedSafeAddress, balances.items, setSafeTx, setSafeTxError])

  const handleSubmit = useCallback(() => {
    onSubmit(predictedSafeAddress)
  }, [onSubmit, predictedSafeAddress])

  return <ReviewTransaction onSubmit={handleSubmit} />
}
</file>

<file path="src/components/tx-flow/flows/CreateNestedSafe/SetupNestedSafe.tsx">
import {
  Box,
  Button,
  CardActions,
  Divider,
  FormControl,
  IconButton,
  InputAdornment,
  InputLabel,
  MenuItem,
  SvgIcon,
  TextField,
  Tooltip,
  Typography,
} from '@mui/material'
import classNames from 'classnames'
import { Controller, FormProvider, useFieldArray, useForm, useFormContext } from 'react-hook-form'
import type { ReactElement } from 'react'

import InfoIcon from '@/public/images/notifications/info.svg'
import AddIcon from '@/public/images/common/add.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import TxCard from '@/components/tx-flow/common/TxCard'
import useSafeAddress from '@/hooks/useSafeAddress'
import useAddressBook from '@/hooks/useAddressBook'
import NameInput from '@/components/common/NameInput'
import tokenInputCss from '@/components/common/TokenAmountInput/styles.module.css'
import NumberField from '@/components/common/NumberField'
import { useVisibleBalances } from '@/hooks/useVisibleBalances'
import { AutocompleteItem } from '@/components/tx-flow/flows/TokenTransfer/CreateTokenTransfer'
import { validateDecimalLength, validateLimitedAmount } from '@safe-global/utils/utils/validation'
import { safeFormatUnits } from '@safe-global/utils/utils/formatters'
import { useMnemonicPrefixedSafeName } from '@/hooks/useMnemonicName'

import css from '@/components/tx-flow/flows/CreateNestedSafe/styles.module.css'
import commonCss from '@/components/tx-flow/common/styles.module.css'

export type SetupNestedSafeForm = {
  [SetupNestedSafeFormFields.name]: string
  [SetupNestedSafeFormFields.assets]: Array<Record<SetupNestedSafeFormAssetFields, string>>
}

export enum SetupNestedSafeFormFields {
  name = 'name',
  assets = 'assets',
}

export enum SetupNestedSafeFormAssetFields {
  tokenAddress = 'tokenAddress',
  amount = 'amount',
}

export function SetUpNestedSafe({
  params,
  onSubmit,
}: {
  params: SetupNestedSafeForm
  onSubmit: (params: SetupNestedSafeForm) => void
}): ReactElement {
  const addressBook = useAddressBook()
  const safeAddress = useSafeAddress()
  const randomName = useMnemonicPrefixedSafeName('Nested')
  const fallbackName = addressBook[safeAddress] ?? randomName

  const formMethods = useForm<SetupNestedSafeForm>({
    defaultValues: params,
    mode: 'onChange',
  })

  const onFormSubmit = (data: SetupNestedSafeForm) => {
    onSubmit({
      ...data,
      [SetupNestedSafeFormFields.name]: data[SetupNestedSafeFormFields.name] || fallbackName,
    })
  }

  return (
    <TxCard>
      <FormProvider {...formMethods}>
        <form onSubmit={formMethods.handleSubmit(onFormSubmit)}>
          <Typography variant="body2" mt={1}>
            Name your Nested Safe and select which assets to fund it with. All selected assets will be transferred when
            deployed.
          </Typography>

          <FormControl fullWidth sx={{ mt: 3 }}>
            <NameInput
              data-testid="nested-safe-name-input"
              name={SetupNestedSafeFormFields.name}
              label="Name"
              placeholder={fallbackName}
              InputLabelProps={{ shrink: true }}
              InputProps={{
                endAdornment: (
                  <Tooltip
                    title="This name is stored locally and will never be shared with us or any third parties."
                    arrow
                    placement="top"
                  >
                    <InputAdornment position="end">
                      <SvgIcon component={InfoIcon} inheritViewBox />
                    </InputAdornment>
                  </Tooltip>
                ),
              }}
            />
          </FormControl>

          <AssetInputs name={SetupNestedSafeFormFields.assets} />

          <Divider className={commonCss.nestedDivider} />

          <CardActions>
            <Button data-testid="next-button" variant="contained" type="submit">
              Next
            </Button>
          </CardActions>
        </form>
      </FormProvider>
    </TxCard>
  )
}

/**
 * Note: the following is very similar to TokenAmountInput but with key differences to support
 * a field array. Adjusting the former was initially attempted but proved to be too complex.
 *
 * TODO: Refactor the both to share a common implementation.
 */
function AssetInputs({ name }: { name: SetupNestedSafeFormFields.assets }) {
  const { balances } = useVisibleBalances()

  const formMethods = useFormContext<SetupNestedSafeForm>()
  const fieldArray = useFieldArray<SetupNestedSafeForm>({ name })

  const selectedAssets = formMethods.watch(name)
  const nonSelectedAssets = balances.items.filter((item) => {
    return !selectedAssets.map((asset) => asset.tokenAddress).includes(item.tokenInfo.address)
  })
  const defaultAsset: SetupNestedSafeForm[typeof name][number] = {
    tokenAddress: nonSelectedAssets[0]?.tokenInfo.address,
    amount: '',
  }

  return (
    <>
      {fieldArray.fields.map((field, index) => {
        const errors = formMethods.formState.errors?.[name]?.[index]
        const label =
          errors?.[SetupNestedSafeFormAssetFields.tokenAddress]?.message ||
          errors?.[SetupNestedSafeFormAssetFields.amount]?.message ||
          'Amount'
        const isError = !!errors && Object.keys(errors).length > 0

        const thisAsset = balances.items.find((item) => {
          return item.tokenInfo.address === selectedAssets[index][SetupNestedSafeFormAssetFields.tokenAddress]
        })
        const thisAndNonSelectedAssets = balances.items.filter((item) => {
          return (
            item.tokenInfo.address === thisAsset?.tokenInfo.address ||
            nonSelectedAssets.some((nonSelected) => item.tokenInfo.address === nonSelected.tokenInfo.address)
          )
        })
        return (
          <Box data-testid="asset-data" className={css.assetInput} key={field.id}>
            <FormControl className={classNames(tokenInputCss.outline, { [tokenInputCss.error]: isError })} fullWidth>
              <InputLabel shrink required className={tokenInputCss.label}>
                {label}
              </InputLabel>

              <div className={tokenInputCss.inputs}>
                <Controller
                  name={`${name}.${index}.${SetupNestedSafeFormAssetFields.amount}`}
                  rules={{
                    required: true,
                    validate: (value) => {
                      return (
                        validateLimitedAmount(value, thisAsset?.tokenInfo.decimals, thisAsset?.balance) ||
                        validateDecimalLength(value, thisAsset?.tokenInfo.decimals)
                      )
                    },
                  }}
                  render={({ field }) => {
                    const onClickMax = () => {
                      if (thisAsset) {
                        const maxAmount = safeFormatUnits(thisAsset.balance, thisAsset.tokenInfo.decimals)
                        field.onChange(maxAmount)
                      }
                    }
                    return (
                      <NumberField
                        data-testid="amount-input"
                        variant="standard"
                        InputProps={{
                          disableUnderline: true,
                          endAdornment: (
                            <Button data-testid="max-button" className={tokenInputCss.max} onClick={onClickMax}>
                              Max
                            </Button>
                          ),
                        }}
                        className={tokenInputCss.amount}
                        required
                        placeholder="0"
                        {...field}
                      />
                    )
                  }}
                />

                <Divider orientation="vertical" flexItem />

                <Controller
                  name={`${name}.${index}.${SetupNestedSafeFormAssetFields.tokenAddress}`}
                  rules={{ required: true, deps: [`${name}.${index}.${SetupNestedSafeFormAssetFields.amount}`] }}
                  render={({ field }) => {
                    return (
                      <TextField
                        data-testid="token-selector"
                        select
                        variant="standard"
                        InputProps={{
                          disableUnderline: true,
                        }}
                        className={tokenInputCss.select}
                        required
                        sx={{ minWidth: '200px' }}
                        {...field}
                      >
                        {thisAndNonSelectedAssets.map((item) => {
                          return (
                            <MenuItem key={item.tokenInfo.address} value={item.tokenInfo.address}>
                              <AutocompleteItem {...item} />
                            </MenuItem>
                          )
                        })}
                      </TextField>
                    )
                  }}
                />
              </div>
            </FormControl>

            <IconButton data-testid="remove-asset-icon" onClick={() => fieldArray.remove(index)}>
              <SvgIcon component={DeleteIcon} inheritViewBox />
            </IconButton>
          </Box>
        )
      })}

      <Button
        data-testid="fund-asset-button"
        variant="text"
        onClick={() => {
          fieldArray.append(defaultAsset, { shouldFocus: true })
        }}
        startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
        size="large"
        sx={{ my: 3 }}
        disabled={nonSelectedAssets.length === 0}
      >
        Fund new asset
      </Button>
    </>
  )
}
</file>

<file path="src/components/tx-flow/flows/CreateNestedSafe/styles.module.css">
.assetInput {
  display: flex;
  flex-direction: row;
  margin-top: var(--space-3);
  gap: var(--space-1);
  align-items: center;
  justify-content: center;
}
</file>

<file path="src/components/tx-flow/flows/ExecuteBatch/DecodedTxs.tsx">
import type { DataDecoded, TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { Box } from '@mui/material'
import extractTxInfo from '@/services/tx/extractTxInfo'
import { isCustomTxInfo, isNativeTokenTransfer, isTransferTxInfo } from '@/utils/transaction-guards'
import SingleTxDecoded from '@/components/transactions/TxDetails/TxData/DecodedData/SingleTxDecoded'
import css from '@/components/transactions/TxDetails/TxData/DecodedData/Multisend/styles.module.css'
import { useState } from 'react'
import { MultisendActionsHeader } from '@/components/transactions/TxDetails/TxData/DecodedData/Multisend'
import { type AccordionProps } from '@mui/material/Accordion/Accordion'

const DecodedTxs = ({ txs }: { txs: TransactionDetails[] | undefined }) => {
  const [openMap, setOpenMap] = useState<Record<number, boolean>>()

  if (!txs) return null

  return (
    <>
      <MultisendActionsHeader title="Batched transactions" setOpen={setOpenMap} amount={txs.length} compact />

      <Box className={css.compact}>
        {txs.map((transaction, idx) => {
          if (!transaction.txData) return null

          const onChange: AccordionProps['onChange'] = (_, expanded) => {
            setOpenMap((prev) => ({
              ...prev,
              [idx]: expanded,
            }))
          }

          const { txParams } = extractTxInfo(transaction)

          let decodedDataParams: DataDecoded = {
            method: '',
            parameters: undefined,
          }

          if (isCustomTxInfo(transaction.txInfo) && transaction.txInfo.isCancellation) {
            decodedDataParams.method = 'On-chain rejection'
          }

          if (isTransferTxInfo(transaction.txInfo) && isNativeTokenTransfer(transaction.txInfo.transferInfo)) {
            decodedDataParams.method = 'transfer'
          }

          const dataDecoded = transaction.txData.dataDecoded || decodedDataParams

          return (
            <SingleTxDecoded
              key={transaction.txId}
              tx={{
                dataDecoded,
                data: txParams.data,
                value: txParams.value,
                to: txParams.to,
                operation: 0,
              }}
              txData={transaction.txData}
              actionTitle={`${idx + 1}`}
              expanded={openMap?.[idx] ?? false}
              onChange={onChange}
            />
          )
        })}
      </Box>
    </>
  )
}

export default DecodedTxs
</file>

<file path="src/components/tx-flow/flows/ExecuteBatch/index.tsx">
import type { Transaction } from '@safe-global/safe-gateway-typescript-sdk'

import TxLayout from '@/components/tx-flow/common/TxLayout'
import { ReviewBatch } from './ReviewBatch'
import BatchIcon from '@/public/images/apps/batch-icon.svg'

export type ExecuteBatchFlowProps = {
  txs: Transaction[]
}

const ExecuteBatchFlow = (props: ExecuteBatchFlowProps) => {
  return (
    <TxLayout title="Confirm transaction" subtitle="Batch" icon={BatchIcon} hideNonce isBatch>
      <ReviewBatch params={props} />
    </TxLayout>
  )
}

export default ExecuteBatchFlow
</file>

<file path="src/components/tx-flow/flows/ExecuteBatch/ReviewBatch.tsx">
import useWallet from '@/hooks/wallets/useWallet'
import { CircularProgress, Typography, Button, CardActions, Divider, Alert } from '@mui/material'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { getReadOnlyMultiSendCallOnlyContract } from '@/services/contracts/safeContracts'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { encodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils/transactions/utils'
import { useState, useMemo, useContext } from 'react'
import type { SyntheticEvent } from 'react'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { ExecutionMethod, ExecutionMethodSelector } from '@/components/tx/ExecutionMethodSelector'
import DecodedTxs from '@/components/tx-flow/flows/ExecuteBatch/DecodedTxs'
import TxChecks from '@/components/tx-flow/features/TxChecks/TxChecks'
import { useRelaysBySafe } from '@/hooks/useRemainingRelays'
import useOnboard from '@/hooks/wallets/useOnboard'
import { logError, Errors } from '@/services/exceptions'
import { dispatchBatchExecution, dispatchBatchExecutionRelay } from '@/services/tx/tx-sender'
import { hasRemainingRelays } from '@/utils/relaying'
import { getMultiSendTxs } from '@/utils/transactions'
import TxCard from '../../common/TxCard'
import CheckWallet from '@/components/common/CheckWallet'
import type { ExecuteBatchFlowProps } from '.'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import SendToBlock from '@/components/tx/SendToBlock'
import ConfirmationTitle, { ConfirmationTitleTypes } from '@/components/tx/SignOrExecuteForm/ConfirmationTitle'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxModalContext } from '@/components/tx-flow'
import useGasPrice from '@/hooks/useGasPrice'
import type { Overrides } from 'ethers'
import { trackEvent } from '@/services/analytics'
import { TX_EVENTS, TX_TYPES } from '@/services/analytics/events/transactions'
import { isWalletRejection } from '@/utils/wallets'
import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'
import useUserNonce from '@/components/tx/AdvancedParams/useUserNonce'
import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import { useGetMultipleTransactionDetailsQuery } from '@/store/api/gateway'
import { skipToken } from '@reduxjs/toolkit/query/react'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import { FEATURES, getLatestSafeVersion, hasFeature } from '@safe-global/utils/utils/chains'

export const ReviewBatch = ({ params }: { params: ExecuteBatchFlowProps }) => {
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [submitError, setSubmitError] = useState<Error | undefined>()
  const [isRejectedByUser, setIsRejectedByUser] = useState<Boolean>(false)
  const [executionMethod, setExecutionMethod] = useState(ExecutionMethod.RELAY)
  const chain = useCurrentChain()
  const { safe } = useSafeInfo()
  const [relays] = useRelaysBySafe()
  const { setTxFlow } = useContext(TxModalContext)
  const [gasPrice] = useGasPrice()

  const userNonce = useUserNonce()

  const latestSafeVersion = getLatestSafeVersion(chain)

  const maxFeePerGas = gasPrice?.maxFeePerGas
  const maxPriorityFeePerGas = gasPrice?.maxPriorityFeePerGas

  const isEIP1559 = chain && hasFeature(chain, FEATURES.EIP1559)

  // Chain has relaying feature and available relays
  const canRelay = hasRemainingRelays(relays)
  const willRelay = canRelay && executionMethod === ExecutionMethod.RELAY
  const onboard = useOnboard()
  const wallet = useWallet()

  const {
    data: txsWithDetails,
    error,
    isLoading: loading,
  } = useGetMultipleTransactionDetailsQuery(
    chain?.chainId && params.txs.length
      ? {
          chainId: chain.chainId,
          txIds: params.txs.map((tx) => tx.transaction.id),
        }
      : skipToken,
  )

  const [multiSendContract] = useAsync(async () => {
    if (!safe.version) return
    return await getReadOnlyMultiSendCallOnlyContract(safe.version)
  }, [safe.version])

  const [multisendContractAddress = ''] = useAsync(async () => {
    if (!multiSendContract) return ''
    return await multiSendContract.getAddress()
  }, [multiSendContract])

  const [multiSendTxs] = useAsync(async () => {
    if (!txsWithDetails || !chain || !safe.version) return
    return getMultiSendTxs(txsWithDetails, chain, safe.address.value, safe.version)
  }, [chain, safe.address.value, safe.version, txsWithDetails])

  const multiSendTxData = useMemo(() => {
    if (!txsWithDetails || !multiSendTxs) return
    return encodeMultiSendData(multiSendTxs)
  }, [txsWithDetails, multiSendTxs])

  const onExecute = async () => {
    if (!userNonce || !onboard || !wallet || !multiSendTxData || !multiSendContract || !txsWithDetails || !gasPrice)
      return

    const overrides: Overrides = isEIP1559
      ? { maxFeePerGas: maxFeePerGas?.toString(), maxPriorityFeePerGas: maxPriorityFeePerGas?.toString() }
      : { gasPrice: maxFeePerGas?.toString() }

    overrides.nonce = userNonce

    await dispatchBatchExecution(
      txsWithDetails,
      multiSendContract,
      multiSendTxData,
      wallet.provider,
      wallet.address,
      safe.address.value,
      overrides as Overrides & { nonce: number },
      safe.nonce,
    )
  }

  const onRelay = async () => {
    if (!multiSendTxData || !multiSendContract || !txsWithDetails) return

    await dispatchBatchExecutionRelay(
      txsWithDetails,
      multiSendContract,
      multiSendTxData,
      safe.chainId,
      safe.address.value,
      safe.version ?? latestSafeVersion,
    )
  }

  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()
    setIsSubmittable(false)
    setSubmitError(undefined)
    setIsRejectedByUser(false)

    try {
      await (willRelay ? onRelay() : onExecute())
      setTxFlow(undefined)
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        logError(Errors._804, err)
        setSubmitError(err)
      }

      setIsSubmittable(true)
      return
    }

    trackEvent({ ...TX_EVENTS.EXECUTE, label: TX_TYPES.bulk_execute })
  }

  const submitDisabled = loading || !isSubmittable || !gasPrice

  return (
    <>
      <TxCard>
        <Typography variant="body2">
          This transaction batches a total of {params.txs.length} transactions from your queue into a single Ethereum
          transaction. Please check every included transaction carefully, especially if you have rejection transactions,
          and make sure you want to execute all of them. Included transactions are highlighted when you hover over the
          execute button.
        </Typography>

        {multiSendContract && <SendToBlock address={multisendContractAddress} title="Interact with" />}

        {multiSendTxData && <HexEncodedData title="Data" hexData={multiSendTxData} />}

        <div>
          <DecodedTxs txs={txsWithDetails} />
        </div>
      </TxCard>

      {multiSendTxs && <TxChecks disabled={submitDisabled} transaction={multiSendTxs} />}

      <TxCard>
        <ConfirmationTitle variant={ConfirmationTitleTypes.execute} />

        <NetworkWarning />

        {canRelay ? (
          <>
            <ExecutionMethodSelector
              executionMethod={executionMethod}
              setExecutionMethod={setExecutionMethod}
              relays={relays}
              tooltip="You can only relay multisend transactions containing executions from the same Safe Account."
            />
          </>
        ) : null}

        <Alert severity="warning">
          Be aware that if any of the included transactions revert, none of them will be executed. This will result in
          the loss of the allocated transaction fees.
        </Alert>

        {error && (
          <ErrorMessage error={asError(error)}>
            This transaction will most likely fail. To save gas costs, avoid creating the transaction.
          </ErrorMessage>
        )}

        {submitError && (
          <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
        )}

        {isRejectedByUser && <WalletRejectionError />}

        <div>
          <Divider className={commonCss.nestedDivider} sx={{ pt: 2 }} />

          <CardActions>
            <CheckWallet allowNonOwner={true} checkNetwork>
              {(isOk) => (
                <Button
                  variant="contained"
                  type="submit"
                  disabled={!isOk || submitDisabled}
                  onClick={handleSubmit}
                  sx={{ minWidth: '114px' }}
                >
                  {!isSubmittable ? <CircularProgress size={20} /> : 'Submit'}
                </Button>
              )}
            </CheckWallet>
          </CardActions>
        </div>
      </TxCard>
    </>
  )
}
</file>

<file path="src/components/tx-flow/flows/MigrateSafeL2/index.tsx">
import TxLayout, { type TxStep } from '@/components/tx-flow/common/TxLayout'
import { MigrateSafeL2Review } from './MigrateSafeL2Review'
import SettingsIcon from '@/public/images/sidebar/settings.svg'
import { useMemo } from 'react'
import useTxStepper from '../../useTxStepper'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'

const MigrateSafeL2Flow = () => {
  const { data, step, nextStep, prevStep } = useTxStepper(undefined)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <MigrateSafeL2Review key={0} onSubmit={() => nextStep(data)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={1} onSubmit={() => {}} />,
      },
    ],
    [nextStep, data],
  )

  return (
    <TxLayout
      subtitle="Update Safe Account base contract"
      icon={SettingsIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default MigrateSafeL2Flow
</file>

<file path="src/components/tx-flow/flows/MigrateSafeL2/MigrateSafeL2Review.tsx">
import { useContext, useEffect } from 'react'
import { useCurrentChain } from '@/hooks/useChains'
import { createTx } from '@/services/tx/tx-sender'
import { SafeTxContext } from '../../SafeTxProvider'
import { createMigrateToL2 } from '@/utils/safe-migrations'
import { Box, Typography } from '@mui/material'
import ErrorMessage from '@/components/tx/ErrorMessage'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const MigrateSafeL2Review = ({ onSubmit }: { onSubmit: () => void }) => {
  const chain = useCurrentChain()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)

  useEffect(() => {
    if (!chain) return

    const txData = createMigrateToL2(chain)
    createTx(txData).then(setSafeTx).catch(setSafeTxError)
  }, [chain, setSafeTx, setSafeTxError])

  return (
    <Box>
      <ReviewTransaction onSubmit={onSubmit}>
        <ErrorMessage level="warning" title="Migration transaction">
          <Typography>
            When executing this transaction, it will not get indexed and appear in the history due to the current
            incompatible base contract. It might also take a few minutes until the new Safe Account version and nonce
            are reflected in the interface. After the migration is complete, future transactions will get processed and
            indexed as usual, and there will be no further restrictions.
          </Typography>
        </ErrorMessage>
      </ReviewTransaction>
    </Box>
  )
}
</file>

<file path="src/components/tx-flow/flows/NestedTxSuccessScreen/index.tsx">
import { useState, useEffect } from 'react'
import { Box, Container, Paper, Stack, SvgIcon, Typography } from '@mui/material'
import { PendingStatus, selectPendingTxById } from '@/store/pendingTxsSlice'
import EthHashInfo from '@/components/common/EthHashInfo'
import ErrorMessage from '@/components/tx/ErrorMessage'
import useAddressBook from '@/hooks/useAddressBook'
import NestedSafeIcon from '@/public/images/transactions/nestedTx.svg'
import ArrowDownIcon from '@/public/images/common/arrow-down.svg'

import css from './styles.module.css'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'
import { useAppSelector } from '@/store'
import ExternalLink from '@/components/common/ExternalLink'
import { MODALS_EVENTS } from '@/services/analytics'
import Track from '@/components/common/Track'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { getSafeTransaction } from '@/utils/transactions'
import { isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'

type Props = {
  txId: string
}
const NestedTxSuccessScreen = ({ txId }: Props) => {
  const addressBook = useAddressBook()

  // _pendingTx eventually clears from the store, so we need to cache it
  const _pendingTx = useAppSelector((state) => (txId ? selectPendingTxById(state, txId) : undefined))
  const [cachedPendingTx, setCachedPendingTx] = useState(_pendingTx)
  useEffect(() => {
    if (_pendingTx) {
      setCachedPendingTx(_pendingTx)
    }
  }, [_pendingTx])

  const [safeTx] = useAsync(() => {
    if (cachedPendingTx?.status == PendingStatus.NESTED_SIGNING) {
      return getSafeTransaction(
        cachedPendingTx.txHashOrParentSafeTxHash,
        cachedPendingTx.chainId,
        cachedPendingTx.signerAddress,
      )
    }
  }, [cachedPendingTx])
  const isSafeTxHash =
    cachedPendingTx?.status == PendingStatus.NESTED_SIGNING &&
    !!safeTx &&
    isMultisigDetailedExecutionInfo(safeTx.detailedExecutionInfo) &&
    safeTx.detailedExecutionInfo.safeTxHash === cachedPendingTx.txHashOrParentSafeTxHash

  if (cachedPendingTx?.status !== PendingStatus.NESTED_SIGNING) {
    return <ErrorMessage>No transaction data found</ErrorMessage>
  }

  const currentSafeAddress = addressBook[cachedPendingTx.safeAddress]
  const parentSafeAddress = addressBook[cachedPendingTx.signerAddress]

  return (
    <Container
      component={Paper}
      disableGutters
      sx={{
        textAlign: 'center',
        maxWidth: `${900 - 75}px`, // md={11}
      }}
      maxWidth={false}
    >
      <Box padding={3} mt={3} display="flex" flexDirection="column" alignItems="center" gap={2}>
        <Box className={css.icon}>
          <SvgIcon component={NestedSafeIcon} inheritViewBox fontSize="large" alt="Nested Safe" />
        </Box>
        <Typography data-testid="transaction-status" variant="h6" marginTop={2} fontWeight={700}>
          A nested transaction was created
        </Typography>
        <Typography variant="body2" mb={3}>
          Once confirmed and executed this signer transaction will confirm the child Safe&apos;s transaction.
        </Typography>
        <Stack spacing={2} width="70%">
          <Box display="flex" flexDirection="column" alignItems="start" gap={1}>
            <Typography variant="body2" color="text.secondary">
              Parent Safe
            </Typography>
            <EthHashInfo
              address={cachedPendingTx.signerAddress}
              name={parentSafeAddress}
              isAddressBookName={Boolean(parentSafeAddress)}
              shortAddress={false}
            />
          </Box>
          <Stack direction="row" spacing={2} alignItems="center" pl={1}>
            <SvgIcon component={ArrowDownIcon} fontSize="medium" color="border" inheritViewBox />
            <Typography
              component="code"
              variant="body2"
              color="primary.light"
              sx={{
                backgroundColor: 'background.main',
                px: 1,
                py: 0.5,
                borderRadius: 0.5,
                fontFamily: 'monospace',
                whiteSpace: 'nowrap',
              }}
            >
              approveHash
            </Typography>
          </Stack>
          <Box display="flex" flexDirection="column" alignItems="start" gap={1}>
            <Typography variant="body2" color="text.secondary">
              Current Safe
            </Typography>
            <EthHashInfo
              address={cachedPendingTx.safeAddress}
              name={currentSafeAddress}
              isAddressBookName={Boolean(currentSafeAddress)}
              shortAddress={false}
            />
          </Box>
        </Stack>
        <Track {...MODALS_EVENTS.OPEN_PARENT_TX}>
          <Link
            href={
              isSafeTxHash
                ? {
                    pathname: AppRoutes.transactions.tx,
                    query: {
                      safe: cachedPendingTx.signerAddress,
                      chainId: cachedPendingTx.chainId,
                      id: cachedPendingTx.txHashOrParentSafeTxHash,
                    },
                  }
                : {
                    pathname: AppRoutes.transactions.queue,
                    query: {
                      safe: cachedPendingTx.signerAddress,
                      chainId: cachedPendingTx.chainId,
                    },
                  }
            }
            passHref
            legacyBehavior
          >
            <ExternalLink mode="button">Open the transaction</ExternalLink>
          </Link>
        </Track>
      </Box>
    </Container>
  )
}

export default NestedTxSuccessScreen
</file>

<file path="src/components/tx-flow/flows/NestedTxSuccessScreen/styles.module.css">
.icon {
  border-radius: 100%;
  background-color: var(--color-background-light);
  height: 100px;
  width: 100px;
  padding-top: 30px;
}
</file>

<file path="src/components/tx-flow/flows/NewSpendingLimit/CreateSpendingLimit.tsx">
import { useCallback, useMemo } from 'react'
import { Controller, FormProvider, useForm } from 'react-hook-form'
import { Button, CardActions, FormControl, InputLabel, MenuItem, Select, Typography } from '@mui/material'
import ExpandMoreRoundedIcon from '@mui/icons-material/ExpandMoreRounded'
import { parseUnits, AbiCoder } from 'ethers'

import AddressBookInput from '@/components/common/AddressBookInput'
import useChainId from '@/hooks/useChainId'
import { getResetTimeOptions } from '@/components/transactions/TxDetails/TxData/SpendingLimits'
import { useVisibleBalances } from '@/hooks/useVisibleBalances'
import type { NewSpendingLimitFlowProps } from '.'
import TxCard from '../../common/TxCard'
import css from '@/components/tx/ExecuteCheckbox/styles.module.css'
import TokenAmountInput from '@/components/common/TokenAmountInput'
import { SpendingLimitFields } from '.'
import { validateAmount, validateDecimalLength } from '@safe-global/utils/utils/validation'

export const _validateSpendingLimit = (val: string, decimals?: number | null) => {
  // Allowance amount is uint96 https://github.com/safe-global/safe-modules/blob/main/modules/allowances/contracts/AllowanceModule.sol#L52
  try {
    const amount = parseUnits(val, decimals ?? 'Gwei')
    AbiCoder.defaultAbiCoder().encode(['int96'], [amount])
  } catch (e) {
    return Number(val) > 1 ? 'Amount is too big' : 'Amount is too small'
  }
}

export const CreateSpendingLimit = ({
  params,
  onSubmit,
}: {
  params: NewSpendingLimitFlowProps
  onSubmit: (data: NewSpendingLimitFlowProps) => void
}) => {
  const chainId = useChainId()
  const { balances } = useVisibleBalances()

  const resetTimeOptions = useMemo(() => getResetTimeOptions(chainId), [chainId])

  const formMethods = useForm<NewSpendingLimitFlowProps>({
    defaultValues: params,
    mode: 'onChange',
  })

  const { handleSubmit, watch, control } = formMethods

  const tokenAddress = watch(SpendingLimitFields.tokenAddress)
  const selectedToken = tokenAddress
    ? balances.items.find((item) => item.tokenInfo.address === tokenAddress)
    : undefined

  const validateSpendingLimit = useCallback(
    (value: string) => {
      return (
        validateAmount(value) ||
        validateDecimalLength(value, selectedToken?.tokenInfo.decimals) ||
        _validateSpendingLimit(value, selectedToken?.tokenInfo.decimals)
      )
    },
    [selectedToken?.tokenInfo.decimals],
  )

  return (
    <TxCard>
      <FormProvider {...formMethods}>
        <form onSubmit={handleSubmit(onSubmit)}>
          <FormControl fullWidth sx={{ mb: 3 }}>
            <AddressBookInput
              data-testid="beneficiary-section"
              name={SpendingLimitFields.beneficiary}
              label="Beneficiary"
            />
          </FormControl>

          <TokenAmountInput balances={balances.items} selectedToken={selectedToken} validate={validateSpendingLimit} />

          <Typography variant="h4" fontWeight={700} mt={3}>
            Reset Timer
          </Typography>
          <Typography>
            Set a reset time so the allowance automatically refills after the defined time period.
          </Typography>
          <FormControl fullWidth className={css.select}>
            <InputLabel shrink={false}>Time Period</InputLabel>
            <Controller
              rules={{ required: true }}
              control={control}
              name={SpendingLimitFields.resetTime}
              render={({ field }) => (
                <Select
                  data-testid="time-period-section"
                  {...field}
                  sx={{ textAlign: 'right', fontWeight: 700 }}
                  IconComponent={ExpandMoreRoundedIcon}
                >
                  {resetTimeOptions.map((resetTime) => (
                    <MenuItem
                      data-testid="time-period-item"
                      key={resetTime.value}
                      value={resetTime.value}
                      sx={{ overflow: 'hidden' }}
                    >
                      {resetTime.label}
                    </MenuItem>
                  ))}
                </Select>
              )}
            />
          </FormControl>

          <CardActions>
            <Button data-testid="next-btn" variant="contained" type="submit">
              Next
            </Button>
          </CardActions>
        </form>
      </FormProvider>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/NewSpendingLimit/index.tsx">
import TxLayout from '../../common/TxLayout'
import type { TxStep } from '@/components/tx-flow/common/TxLayout'
import useTxStepper from '../../useTxStepper'
import { CreateSpendingLimit } from './CreateSpendingLimit'
import { ReviewSpendingLimit } from './ReviewSpendingLimit'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { TokenAmountFields } from '@/components/common/TokenAmountInput'
import { useMemo } from 'react'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

enum Fields {
  beneficiary = 'beneficiary',
  resetTime = 'resetTime',
}

export const SpendingLimitFields = { ...Fields, ...TokenAmountFields }

export type NewSpendingLimitFlowProps = {
  [SpendingLimitFields.beneficiary]: string
  [SpendingLimitFields.tokenAddress]: string
  [SpendingLimitFields.amount]: string
  [SpendingLimitFields.resetTime]: string
}

const defaultValues: NewSpendingLimitFlowProps = {
  beneficiary: '',
  tokenAddress: ZERO_ADDRESS,
  amount: '',
  resetTime: '0',
}

const NewSpendingLimitFlow = () => {
  const { data, step, nextStep, prevStep } = useTxStepper<NewSpendingLimitFlowProps>(
    defaultValues,
    TxFlowType.SETUP_SPENDING_LIMIT,
  )

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'New transaction' },
        content: (
          <CreateSpendingLimit key={0} params={data} onSubmit={(formData) => nextStep({ ...data, ...formData })} />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewSpendingLimit key={1} params={data} onSubmit={() => nextStep(data)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, data],
  )

  return (
    <TxLayout
      subtitle="Spending limit"
      icon={SaveAddressIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default NewSpendingLimitFlow
</file>

<file path="src/components/tx-flow/flows/NewSpendingLimit/ReviewSpendingLimit.tsx">
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useEffect, useMemo, useContext } from 'react'
import { useSelector } from 'react-redux'
import { Typography, Grid, Alert } from '@mui/material'

import SpendingLimitLabel from '@/components/common/SpendingLimitLabel'
import { getResetTimeOptions } from '@/components/transactions/TxDetails/TxData/SpendingLimits'
import SendAmountBlock from '@/components/tx-flow/flows/TokenTransfer/SendAmountBlock'
import useBalances from '@/hooks/useBalances'
import useChainId from '@/hooks/useChainId'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import { createNewSpendingLimitTx } from '@/services/tx/tx-sender'
import { selectSpendingLimits } from '@/store/spendingLimitsSlice'
import { formatVisualAmount, safeParseUnits } from '@safe-global/utils/utils/formatters'
import type { NewSpendingLimitFlowProps } from '.'
import EthHashInfo from '@/components/common/EthHashInfo'
import { SafeTxContext } from '../../SafeTxProvider'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const ReviewSpendingLimit = ({
  params,
  onSubmit,
}: {
  params: NewSpendingLimitFlowProps
  onSubmit: () => void
}) => {
  const spendingLimits = useSelector(selectSpendingLimits)
  const { safe } = useSafeInfo()
  const chainId = useChainId()
  const chain = useCurrentChain()
  const { balances } = useBalances()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const token = balances.items.find((item) => item.tokenInfo.address === params.tokenAddress)
  const { decimals } = token?.tokenInfo || {}

  const amountInWei = useMemo(
    () => safeParseUnits(params.amount, token?.tokenInfo.decimals)?.toString() || '0',
    [params.amount, token?.tokenInfo.decimals],
  )

  const existingSpendingLimit = useMemo(() => {
    return spendingLimits.find(
      (spendingLimit) =>
        spendingLimit.beneficiary === params.beneficiary && spendingLimit.token.address === params.tokenAddress,
    )
  }, [spendingLimits, params])

  useEffect(() => {
    if (!chain) return

    createNewSpendingLimitTx(
      params,
      spendingLimits,
      chainId,
      chain,
      safe.modules,
      safe.deployed,
      decimals,
      existingSpendingLimit,
    )
      .then(setSafeTx)
      .catch(setSafeTxError)
  }, [
    chain,
    chainId,
    decimals,
    existingSpendingLimit,
    params,
    safe.modules,
    safe.deployed,
    setSafeTx,
    setSafeTxError,
    spendingLimits,
  ])

  const isOneTime = params.resetTime === '0'
  const resetTime = useMemo(() => {
    return isOneTime
      ? 'One-time spending limit'
      : getResetTimeOptions(chainId).find((time) => time.value === params.resetTime)?.label
  }, [isOneTime, params.resetTime, chainId])

  const onFormSubmit = () => {
    trackEvent({
      ...SETTINGS_EVENTS.SPENDING_LIMIT.RESET_PERIOD,
      label: resetTime,
    })

    onSubmit()
  }

  const existingAmount = existingSpendingLimit
    ? formatVisualAmount(BigInt(existingSpendingLimit?.amount), decimals)
    : undefined

  const oldResetTime = existingSpendingLimit
    ? getResetTimeOptions(chainId).find((time) => time.value === existingSpendingLimit?.resetTimeMin)?.label
    : undefined

  return (
    <ReviewTransaction onSubmit={onFormSubmit}>
      {token && (
        <SendAmountBlock amountInWei={amountInWei} tokenInfo={token.tokenInfo} title="Amount">
          {existingAmount && existingAmount !== params.amount && (
            <>
              <Typography
                data-testid="old-token-amount"
                color="error"
                sx={{ textDecoration: 'line-through' }}
                component="span"
              >
                {existingAmount}
              </Typography>
              →
            </>
          )}
        </SendAmountBlock>
      )}
      <Grid
        container
        sx={{
          gap: 1,
          alignItems: 'center',
        }}
      >
        <Grid item md>
          <Typography
            variant="body2"
            sx={{
              color: 'text.secondary',
            }}
          >
            Beneficiary
          </Typography>
        </Grid>

        <Grid data-testid="beneficiary-address" item md={10}>
          <EthHashInfo
            address={params.beneficiary}
            shortAddress={false}
            hasExplorer
            showCopyButton
            showAvatar={false}
          />
        </Grid>
      </Grid>
      <Grid
        container
        sx={{
          gap: 1,
          alignItems: 'center',
        }}
      >
        <Grid item md>
          <Typography
            variant="body2"
            sx={{
              color: 'text.secondary',
            }}
          >
            Reset time
          </Typography>
        </Grid>
        <Grid item md={10}>
          {existingSpendingLimit ? (
            <>
              <SpendingLimitLabel
                label={
                  <>
                    {existingSpendingLimit.resetTimeMin !== params.resetTime && (
                      <>
                        <Typography
                          data-testid="old-reset-time"
                          color="error"
                          component="span"
                          sx={{
                            display: 'inline',
                            textDecoration: 'line-through',
                          }}
                        >
                          {oldResetTime}
                        </Typography>
                        {' → '}
                      </>
                    )}
                    <Typography
                      component="span"
                      sx={{
                        display: 'inline',
                      }}
                    >
                      {resetTime}
                    </Typography>
                  </>
                }
                isOneTime={existingSpendingLimit.resetTimeMin === '0'}
              />
            </>
          ) : (
            <SpendingLimitLabel
              data-testid="spending-limit-label"
              label={resetTime || 'One-time spending limit'}
              isOneTime={!!resetTime && isOneTime}
            />
          )}
        </Grid>
      </Grid>
      {existingSpendingLimit && (
        <Alert severity="warning" sx={{ border: 'unset' }}>
          <Typography
            data-testid="limit-replacement-warning"
            sx={{
              fontWeight: 700,
            }}
          >
            You are about to replace an existing spending limit
          </Typography>
        </Alert>
      )}
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/NewTx/index.tsx">
import { useCallback, useContext } from 'react'
import { MakeASwapButton, SendTokensButton, TxBuilderButton } from '@/components/tx-flow/common/TxButton'
import { Container, Grid, Paper, Typography } from '@mui/material'
import { TxModalContext } from '../../'
import TokenTransferFlow from '../TokenTransfer'
import { useTxBuilderApp } from '@/hooks/safe-apps/useTxBuilderApp'
import { ProgressBar } from '@/components/common/ProgressBar'
import ChainIndicator from '@/components/common/ChainIndicator'
import NewTxIcon from '@/public/images/transactions/new-tx.svg'

import css from './styles.module.css'

const NewTxFlow = () => {
  const txBuilder = useTxBuilderApp()
  const { setTxFlow } = useContext(TxModalContext)

  const onTokensClick = useCallback(() => {
    setTxFlow(<TokenTransferFlow />)
  }, [setTxFlow])

  const progress = 10

  return (
    <Container className={css.container}>
      <Grid
        container
        sx={{
          justifyContent: 'center',
        }}
      >
        {/* Alignment of `TxLayout` */}
        <Grid
          item
          xs={12}
          md={11}
          sx={{
            display: 'flex',
            flexDirection: 'column',
          }}
        >
          <ChainIndicator inline className={css.chain} />

          <Grid container component={Paper}>
            <Grid item xs={12} className={css.progressBar}>
              <ProgressBar value={progress} />
            </Grid>
            <Grid
              item
              xs={12}
              md={6}
              className={css.pane}
              sx={{
                gap: 3,
              }}
            >
              <div className={css.globs}>
                <NewTxIcon />
              </div>

              <Typography variant="h1" className={css.title}>
                New transaction
              </Typography>
            </Grid>

            <Grid
              item
              xs={12}
              md={5}
              className={css.pane}
              sx={{
                gap: 2,
              }}
            >
              <Typography variant="h4" className={css.type}>
                Manage assets
              </Typography>

              <SendTokensButton onClick={onTokensClick} />
              <MakeASwapButton />

              {txBuilder?.app && (
                <>
                  <Typography
                    variant="h4"
                    className={css.type}
                    sx={{
                      mt: 3,
                    }}
                  >
                    Interact with contracts
                  </Typography>

                  <TxBuilderButton />
                </>
              )}
            </Grid>
          </Grid>
        </Grid>
      </Grid>
    </Container>
  )
}

export default NewTxFlow
</file>

<file path="src/components/tx-flow/flows/NewTx/styles.module.css">
.chain {
  align-self: flex-end;
  margin-bottom: var(--space-2);
}

.pane {
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: var(--space-10) var(--space-8);
  gap: var(--space-3);
}

.title {
  font-size: 44px;
  font-weight: 700;
}

.type {
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: var(--space-1);
}

.globs > div {
  padding: 0;
  margin: 0 0 var(--space-3) 0;
}

@media (max-width: 899.95px) {
  .container {
    margin-top: var(--space-3);
    padding: 0;
  }

  .container :global(.MuiPaper-root) {
    border-radius: unset;
  }

  .chain {
    position: absolute;
    top: 0;
    right: 57px;
    margin: var(--space-2);
  }

  .progressBar {
    display: none;
  }

  .pane + .pane {
    padding-top: 0;
  }
}
</file>

<file path="src/components/tx-flow/flows/NftTransfer/index.tsx">
import type { SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'
import NftIcon from '@/public/images/common/nft.svg'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '@/components/tx-flow/common/TxLayout'
import useTxStepper from '../../useTxStepper'
import SendNftBatch from './SendNftBatch'
import ReviewNftBatch from './ReviewNftBatch'
import { useMemo } from 'react'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

export type NftTransferParams = {
  recipient: string
  tokens: SafeCollectibleResponse[]
}

type NftTransferFlowProps = Partial<NftTransferParams> & {
  txNonce?: number
}

const defaultParams: NftTransferParams = {
  recipient: '',
  tokens: [],
}

const NftTransferFlow = ({ txNonce, ...params }: NftTransferFlowProps) => {
  const { data, step, nextStep, prevStep } = useTxStepper<NftTransferParams>(
    {
      ...defaultParams,
      ...params,
    },
    TxFlowType.NFT_TRANSFER,
  )

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'New transaction' },
        content: <SendNftBatch key={0} params={data} onSubmit={(formData) => nextStep({ ...data, ...formData })} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewNftBatch key={1} params={data} txNonce={txNonce} onSubmit={() => nextStep(data)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, data, txNonce],
  )

  return (
    <TxLayout
      subtitle="Send NFTs"
      icon={NftIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default NftTransferFlow
</file>

<file path="src/components/tx-flow/flows/NftTransfer/ReviewNftBatch.tsx">
import { type ReactElement, useEffect, useContext } from 'react'
import SendToBlock from '@/components/tx/SendToBlock'
import { createNftTransferParams } from '@/services/tx/tokenTransferParams'
import type { NftTransferParams } from '.'
import useSafeAddress from '@/hooks/useSafeAddress'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import { SafeTxContext } from '../../SafeTxProvider'
import { NftItems } from '@/components/tx-flow/flows/NftTransfer/SendNftBatch'
import ReviewTransaction from '@/components/tx/ReviewTransaction'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import FieldsGrid from '@/components/tx/FieldsGrid'

type ReviewNftBatchProps = {
  params: NftTransferParams
  onSubmit: () => void
  txNonce?: number
}

const ReviewNftBatch = ({ params, onSubmit, txNonce }: ReviewNftBatchProps): ReactElement => {
  const { setSafeTx, setSafeTxError, setNonce } = useContext(SafeTxContext)
  const safeAddress = useSafeAddress()
  const { tokens } = params

  useEffect(() => {
    if (txNonce !== undefined) {
      setNonce(txNonce)
    }
  }, [txNonce, setNonce])

  useEffect(() => {
    if (!safeAddress) return

    const calls = params.tokens.map((token) => {
      return createNftTransferParams(safeAddress, params.recipient, token.id, token.address)
    })

    const promise = calls.length > 1 ? createMultiSendCallOnlyTx(calls) : createTx(calls[0])

    promise.then(setSafeTx).catch(setSafeTxError)
  }, [safeAddress, params, setSafeTx, setSafeTxError])

  return (
    <ReviewTransaction onSubmit={onSubmit}>
      <SendToBlock address={params.recipient} />

      <FieldsGrid title={`NFT${maybePlural(tokens)}:`}>
        <NftItems tokens={tokens} />
      </FieldsGrid>
    </ReviewTransaction>
  )
}

export default ReviewNftBatch
</file>

<file path="src/components/tx-flow/flows/NftTransfer/SendNftBatch.tsx">
import { Box, Button, CardActions, Divider, FormControl, Stack, SvgIcon, Typography } from '@mui/material'
import { type SafeCollectibleResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { FormProvider, useForm } from 'react-hook-form'
import NftIcon from '@/public/images/common/nft.svg'
import AddressBookInput from '@/components/common/AddressBookInput'
import type { NftTransferParams } from '.'
import ImageFallback from '@/components/common/ImageFallback'
import TxCard from '../../common/TxCard'
import commonCss from '@/components/tx-flow/common/styles.module.css'

enum Field {
  recipient = 'recipient',
}

type FormData = Pick<NftTransferParams, Field.recipient>

type SendNftBatchProps = {
  onSubmit: (data: NftTransferParams) => void
  params: NftTransferParams
}

const NftItem = ({ image, name, description }: { image: string; name: string; description?: string }) => (
  <Stack direction="row" spacing={1} flexWrap="nowrap" alignItems="flex-start">
    <Box flex={0}>
      <ImageFallback
        src={image}
        fallbackSrc=""
        fallbackComponent={<SvgIcon component={NftIcon} inheritViewBox sx={{ width: 1, height: 1 }} />}
        alt={name}
        height={40}
      />
    </Box>

    <Box flex={1} minWidth={0} maxWidth={{ xl: 'calc(100% - 200px)' }}>
      <Typography
        data-testid="nft-item-name"
        variant="body2"
        fontWeight={700}
        whiteSpace="nowrap"
        overflow="hidden"
        textOverflow="ellipsis"
      >
        {name}
      </Typography>

      {description && (
        <Typography
          variant="body2"
          color="text.secondary"
          display="block"
          whiteSpace="nowrap"
          overflow="hidden"
          textOverflow="ellipsis"
        >
          {description}
        </Typography>
      )}
    </Box>
  </Stack>
)

export const NftItems = ({ tokens }: { tokens: SafeCollectibleResponse[] }) => {
  return (
    <Box
      data-testid="nft-item-list"
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        overflow: 'auto',
        maxHeight: '20vh',
        minHeight: '40px',
      }}
    >
      {tokens.map((token) => (
        <NftItem
          key={`${token.address}-${token.id}`}
          image={token.imageUri || token.logoUri}
          name={`${token.tokenName || token.tokenSymbol || ''} #${token.id}`}
          description={`Token ID: ${token.id}${token.name ? ` - ${token.name}` : ''}`}
        />
      ))}
    </Box>
  )
}

const SendNftBatch = ({ params, onSubmit }: SendNftBatchProps) => {
  const { tokens } = params

  const formMethods = useForm<FormData>({
    defaultValues: {
      [Field.recipient]: params.recipient,
    },
  })
  const {
    handleSubmit,
    watch,
    formState: { errors },
  } = formMethods

  const recipient = watch(Field.recipient)
  const isAddressValid = !!recipient && !errors[Field.recipient]

  const onFormSubmit = (data: FormData) => {
    onSubmit({
      recipient: data.recipient,
      tokens,
    })
  }

  return (
    <TxCard>
      <FormProvider {...formMethods}>
        <form onSubmit={handleSubmit(onFormSubmit)}>
          <FormControl fullWidth sx={{ mb: 3, mt: 1 }}>
            <AddressBookInput name={Field.recipient} canAdd={isAddressValid} />
          </FormControl>

          <Typography
            data-testid="selected-nfts"
            variant="body2"
            sx={{
              color: 'text.secondary',
              mb: 2,
            }}
          >
            Selected NFTs
          </Typography>

          <NftItems tokens={tokens} />

          <Divider className={commonCss.nestedDivider} sx={{ pt: 3 }} />

          <CardActions>
            <Button variant="contained" type="submit">
              Next
            </Button>
          </CardActions>
        </form>
      </FormProvider>
    </TxCard>
  )
}

export default SendNftBatch
</file>

<file path="src/components/tx-flow/flows/RecoverAccount/index.tsx">
import type { ReactElement } from 'react'
import type { AddressEx } from '@safe-global/safe-gateway-typescript-sdk'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import useTxStepper from '../../useTxStepper'
import { RecoverAccountFlowReview } from './RecoverAccountFlowReview'
import { RecoverAccountFlowSetup } from './RecoverAccountFlowSetup'
import { TxFlowType } from '@/services/analytics'

export enum RecoverAccountFlowFields {
  owners = 'owners',
  threshold = 'threshold',
}

export type RecoverAccountFlowProps = {
  // RHF accept primitive field arrays
  [RecoverAccountFlowFields.owners]: Array<AddressEx>
  [RecoverAccountFlowFields.threshold]: string
}

function RecoverAccountFlow(): ReactElement {
  const { data, step, nextStep, prevStep } = useTxStepper<RecoverAccountFlowProps>(
    {
      [RecoverAccountFlowFields.owners]: [{ value: '' }],
      [RecoverAccountFlowFields.threshold]: '1',
    },
    TxFlowType.START_RECOVERY,
  )

  const steps = [
    <RecoverAccountFlowSetup key={0} params={data} onSubmit={(formData) => nextStep({ ...data, ...formData })} />,
    <RecoverAccountFlowReview key={1} params={data} />,
  ]

  return (
    <TxLayout
      title={step === 0 ? 'Start Account recovery' : 'Confirm transaction'}
      subtitle="Change Account settings"
      icon={SaveAddressIcon}
      step={step}
      onBack={prevStep}
      hideNonce
    >
      {steps}
    </TxLayout>
  )
}

export default RecoverAccountFlow
</file>

<file path="src/components/tx-flow/flows/RecoverAccount/RecoverAccountFlowReview.tsx">
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { CardActions, Button, Typography, Divider, Box, CircularProgress } from '@mui/material'
import { useContext, useEffect, useState } from 'react'
import type { ReactElement } from 'react'

import useSafeInfo from '@/hooks/useSafeInfo'
import { getRecoveryProposalTransactions } from '@/features/recovery/services/transaction'
import ErrorMessage from '@/components/tx/ErrorMessage'
import ConfirmationTitle, { ConfirmationTitleTypes } from '@/components/tx/SignOrExecuteForm/ConfirmationTitle'
import TxChecks from '@/components/tx-flow/features/TxChecks/TxChecks'
import TxCard from '../../common/TxCard'
import { SafeTxContext } from '../../SafeTxProvider'
import CheckWallet from '@/components/common/CheckWallet'
import { dispatchRecoveryProposal } from '@/features/recovery/services/recovery-sender'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import { RecoverAccountFlowFields } from '.'
import { OwnerList } from '../../common/OwnerList'
import { selectDelayModifierByRecoverer } from '@/features/recovery/services/selectors'
import useWallet from '@/hooks/wallets/useWallet'
import useOnboard from '@/hooks/wallets/useOnboard'
import { TxModalContext } from '../..'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { trackError, Errors } from '@/services/exceptions'
import { getPeriod } from '@safe-global/utils/utils/date'
import useRecovery from '@/features/recovery/hooks/useRecovery'
import { useIsValidRecoveryExecTransactionFromModule } from '@/features/recovery/hooks/useIsValidRecoveryExecution'
import type { RecoverAccountFlowProps } from '.'
import { isWalletRejection } from '@/utils/wallets'
import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import { BlockaidBalanceChanges } from '@/components/tx/security/blockaid/BlockaidBalanceChange'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import { useGetTransactionDetailsQuery } from '@/store/api/gateway'
import { skipToken } from '@reduxjs/toolkit/query'
import useTxPreview from '@/components/tx/confirmation-views/useTxPreview'
import Summary from '@/components/transactions/TxDetails/Summary'

export function RecoverAccountFlowReview({ params }: { params: RecoverAccountFlowProps }): ReactElement | null {
  // Form state
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [submitError, setSubmitError] = useState<Error | undefined>()
  const [isRejectedByUser, setIsRejectedByUser] = useState<Boolean>(false)

  // Hooks
  const { setTxFlow } = useContext(TxModalContext)
  const { safeTx, safeTxError, setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const { safe } = useSafeInfo()
  const wallet = useWallet()
  const onboard = useOnboard()
  const [data] = useRecovery()
  const recovery = data && selectDelayModifierByRecoverer(data, wallet?.address ?? '')
  const [, executionValidationError] = useIsValidRecoveryExecTransactionFromModule(recovery?.address, safeTx)

  const { data: txDetails } = useGetTransactionDetailsQuery(skipToken)
  const [txPreview] = useTxPreview(safeTx?.data, undefined, txDetails?.txId)

  // Proposal
  const newThreshold = Number(params[RecoverAccountFlowFields.threshold])
  const newOwners = params[RecoverAccountFlowFields.owners]

  useEffect(() => {
    const transactions = getRecoveryProposalTransactions({
      safe,
      newThreshold,
      newOwners,
    })

    const promise = transactions.length > 1 ? createMultiSendCallOnlyTx(transactions) : createTx(transactions[0])

    promise.then(setSafeTx).catch(setSafeTxError)
  }, [newThreshold, newOwners, safe, setSafeTx, setSafeTxError])

  // On modal submit
  const onSubmit = async () => {
    if (!recovery || !onboard || !wallet || !safeTx) {
      return
    }

    setIsSubmittable(false)
    setSubmitError(undefined)
    setIsRejectedByUser(false)

    try {
      await dispatchRecoveryProposal({
        provider: wallet.provider,
        safe,
        safeTx,
        delayModifierAddress: recovery.address,
        signerAddress: wallet.address,
      })
      trackEvent({ ...RECOVERY_EVENTS.SUBMIT_RECOVERY_ATTEMPT })
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        trackError(Errors._804, err)
        setSubmitError(err)
      }
      setIsSubmittable(true)
      return
    }

    setTxFlow(undefined)
  }

  const submitDisabled = !safeTx || !isSubmittable || !recovery

  return (
    <>
      <TxCard>
        <Typography mb={1}>
          This transaction will reset the Account setup, changing the signers
          {newThreshold !== safe.threshold ? ' and threshold' : ''}.
        </Typography>

        <OwnerList owners={newOwners} />

        <Divider className={commonCss.nestedDivider} sx={{ mt: 'var(--space-2) !important' }} />

        <Box my={1}>
          <Typography variant="body2" color="text.secondary" gutterBottom>
            After recovery, Safe Account transactions will require:
          </Typography>
          <Typography>
            <b>{params.threshold}</b> out of <b>{params[RecoverAccountFlowFields.owners].length} signers.</b>
          </Typography>
        </Box>

        <Divider className={commonCss.nestedDivider} />

        {txPreview && <Summary txDetails={txDetails} safeTxData={safeTx?.data} {...txPreview} />}

        <BlockaidBalanceChanges />
      </TxCard>

      {safeTx && <TxChecks transaction={safeTx} executionOwner={safe.owners[0].value} />}

      <TxCard>
        <>
          <ConfirmationTitle variant={ConfirmationTitleTypes.execute} />

          {safeTxError && (
            <ErrorMessage error={safeTxError}>
              This recovery will most likely fail. To save gas costs, avoid executing the transaction.
            </ErrorMessage>
          )}

          {executionValidationError && (
            <ErrorMessage error={executionValidationError}>
              This transaction will most likely fail. To save gas costs, avoid executing the transaction.
            </ErrorMessage>
          )}

          {submitError && (
            <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
          )}

          <NetworkWarning />

          {recovery?.delay !== undefined && (
            <ErrorMessage level="info">
              Recovery will be{' '}
              {recovery.delay === 0n ? 'immediately possible' : `possible in ${getPeriod(Number(recovery.delay))}`}{' '}
              after this transaction is executed.
            </ErrorMessage>
          )}

          {isRejectedByUser && <WalletRejectionError />}

          <Divider className={commonCss.nestedDivider} />

          <CardActions sx={{ mt: 'var(--space-1) !important' }}>
            <CheckWallet allowNonOwner checkNetwork>
              {(isOk) => (
                <Button
                  data-testid="execute-btn"
                  variant="contained"
                  disabled={!isOk || submitDisabled}
                  onClick={onSubmit}
                >
                  {!isSubmittable ? <CircularProgress size={20} /> : 'Execute'}
                </Button>
              )}
            </CheckWallet>
          </CardActions>
        </>
      </TxCard>
    </>
  )
}
</file>

<file path="src/components/tx-flow/flows/RecoverAccount/RecoverAccountFlowSetup.tsx">
import {
  Typography,
  Divider,
  CardActions,
  Button,
  SvgIcon,
  Grid,
  MenuItem,
  TextField,
  IconButton,
  Tooltip,
  Alert,
} from '@mui/material'
import { useForm, FormProvider, useFieldArray, Controller } from 'react-hook-form'
import { Fragment } from 'react'
import type { ReactElement } from 'react'

import TxCard from '../../common/TxCard'
import AddIcon from '@/public/images/common/add.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import { RecoverAccountFlowFields } from '.'
import AddressBookInput from '@/components/common/AddressBookInput'
import { TOOLTIP_TITLES } from '../../common/constants'
import InfoIcon from '@/public/images/notifications/info.svg'
import useSafeInfo from '@/hooks/useSafeInfo'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { RecoverAccountFlowProps } from '.'
import { type AddressInfo } from '@safe-global/store/gateway/AUTO_GENERATED/safes'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import { maybePlural } from '@safe-global/utils/utils/formatters'

export function _isSameSetup({
  oldOwners,
  oldThreshold,
  newOwners,
  newThreshold,
}: {
  oldOwners: Array<AddressInfo>
  oldThreshold: number
  newOwners: Array<AddressInfo>
  newThreshold: number
}): boolean {
  if (oldThreshold !== newThreshold) {
    return false
  }

  if (oldOwners.length !== newOwners.length) {
    return false
  }

  return oldOwners.every((oldOwner) => {
    return newOwners.some((newOwner) => sameAddress(oldOwner.value, newOwner.value))
  })
}

export function RecoverAccountFlowSetup({
  params,
  onSubmit,
}: {
  params: RecoverAccountFlowProps
  onSubmit: (formData: RecoverAccountFlowProps) => void
}): ReactElement {
  const { safeAddress, safe } = useSafeInfo()

  const formMethods = useForm<RecoverAccountFlowProps>({
    defaultValues: params,
    mode: 'onChange',
  })

  const newOwners = formMethods.watch(RecoverAccountFlowFields.owners)
  const newThreshold = formMethods.watch(RecoverAccountFlowFields.threshold)

  const { fields, append, remove } = useFieldArray({
    control: formMethods.control,
    name: RecoverAccountFlowFields.owners,
  })

  const isSameSetup = _isSameSetup({
    oldOwners: safe.owners,
    oldThreshold: safe.threshold,
    newOwners,
    newThreshold: Number(newThreshold),
  })

  return (
    <FormProvider {...formMethods}>
      <form onSubmit={formMethods.handleSubmit(onSubmit)} className={commonCss.form}>
        <TxCard>
          <div>
            <Typography
              variant="h6"
              gutterBottom
              sx={{
                fontWeight: 700,
              }}
            >
              Add signer(s)
            </Typography>

            <Typography
              variant="body2"
              sx={{
                mb: 1,
              }}
            >
              Set the new signer wallet(s) of this Safe Account and how many need to confirm a transaction before it can
              be executed.
            </Typography>
          </div>

          <Grid container spacing={3} direction="row">
            {fields.map((field, index) => (
              <Fragment key={index}>
                <Grid item xs={11}>
                  <AddressBookInput
                    label={`Signer ${index + 1}`}
                    name={`${RecoverAccountFlowFields.owners}.${index}.value`}
                    required
                    fullWidth
                    key={field.id}
                    validate={(value) => {
                      if (sameAddress(value, safeAddress)) {
                        return 'The Safe Account cannot own itself'
                      }

                      const isDuplicate = newOwners.filter((owner) => owner.value === value).length > 1
                      if (isDuplicate) {
                        return 'Already designated to be a signer'
                      }
                    }}
                  />
                </Grid>

                <Grid
                  item
                  xs={1}
                  sx={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >
                  {index > 0 && (
                    <IconButton onClick={() => remove(index)}>
                      <SvgIcon component={DeleteIcon} inheritViewBox />
                    </IconButton>
                  )}
                </Grid>
              </Fragment>
            ))}
          </Grid>

          <Button
            onClick={() => append({ value: '' })}
            variant="text"
            startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
            sx={{ alignSelf: 'flex-start', my: 1 }}
          >
            Add new signer
          </Button>

          <Divider className={commonCss.nestedDivider} />

          <div>
            <Typography
              variant="h6"
              gutterBottom
              sx={{
                fontWeight: 700,
              }}
            >
              Threshold
              <Tooltip title={TOOLTIP_TITLES.THRESHOLD} arrow placement="top">
                <span>
                  <SvgIcon
                    component={InfoIcon}
                    inheritViewBox
                    color="border"
                    fontSize="small"
                    sx={{
                      verticalAlign: 'middle',
                      ml: 0.5,
                    }}
                  />
                </span>
              </Tooltip>
            </Typography>

            <Typography
              variant="body2"
              sx={{
                mb: 1,
              }}
            >
              After recovery, Safe Account transactions will require:
            </Typography>
          </div>

          <Grid
            container
            direction="row"
            sx={{
              alignItems: 'center',
              gap: 2,
              mb: 1,
            }}
          >
            <Grid item>
              <Controller
                control={formMethods.control}
                name={RecoverAccountFlowFields.threshold}
                render={({ field }) => (
                  <TextField select {...field}>
                    {fields.map((_, index) => {
                      const value = index + 1
                      return (
                        <MenuItem key={index} value={value}>
                          {value}
                        </MenuItem>
                      )
                    })}
                  </TextField>
                )}
              />
            </Grid>

            <Grid item>
              <Typography>
                out of {fields.length} signer{maybePlural(fields)}
              </Typography>
            </Grid>
          </Grid>

          {isSameSetup && (
            <Alert severity="error" sx={{ border: 'unset' }}>
              The proposed Account setup is the same as the current one.
            </Alert>
          )}

          <Divider className={commonCss.nestedDivider} />

          <CardActions sx={{ mt: '0 !important' }}>
            <Button data-testid="next-btn" variant="contained" type="submit" sx={{ mt: 1 }} disabled={isSameSetup}>
              Next
            </Button>
          </CardActions>
        </TxCard>
      </form>
    </FormProvider>
  )
}
</file>

<file path="src/components/tx-flow/flows/RecoveryAttempt/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import RecoveryAttemptReview from './RecoveryAttemptReview'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

const RecoveryAttemptFlow = ({ item }: { item: RecoveryQueueItem }) => {
  return (
    <TxLayout title="Recovery" subtitle="Execute recovery" icon={SaveAddressIcon} step={0} hideNonce>
      <RecoveryAttemptReview item={item} />
    </TxLayout>
  )
}

export default RecoveryAttemptFlow
</file>

<file path="src/components/tx-flow/flows/RecoveryAttempt/RecoveryAttemptReview.tsx">
import { type SyntheticEvent, useContext, useCallback, useEffect } from 'react'
import { CircularProgress, CardActions, Button, Typography, Stack, Divider } from '@mui/material'
import CheckWallet from '@/components/common/CheckWallet'
import { Errors, trackError } from '@/services/exceptions'
import { dispatchRecoveryExecution } from '@/features/recovery/services/recovery-sender'
import useWallet from '@/hooks/wallets/useWallet'
import useSafeInfo from '@/hooks/useSafeInfo'
import ErrorMessage from '@/components/tx/ErrorMessage'
import TxCard from '@/components/tx-flow/common/TxCard'
import { TxModalContext } from '@/components/tx-flow'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import { RecoveryValidationErrors } from '@/features/recovery/components/RecoveryValidationErrors'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import { RecoveryDescription } from '@/features/recovery/components/RecoveryDescription'
import { useAsyncCallback } from '@safe-global/utils/hooks/useAsync'
import FieldsGrid from '@/components/tx/FieldsGrid'
import EthHashInfo from '@/components/common/EthHashInfo'
import { SafeTxContext } from '../../SafeTxProvider'

type RecoveryAttemptReviewProps = {
  item: RecoveryQueueItem
}

const RecoveryAttemptReview = ({ item }: RecoveryAttemptReviewProps) => {
  const { asyncCallback, isLoading, error } = useAsyncCallback(dispatchRecoveryExecution)
  const wallet = useWallet()
  const { safe } = useSafeInfo()
  const { setTxFlow } = useContext(TxModalContext)
  const { setNonceNeeded } = useContext(SafeTxContext)

  const onFormSubmit = useCallback(
    async (e: SyntheticEvent) => {
      e.preventDefault()

      if (!wallet) return

      try {
        await asyncCallback({
          provider: wallet.provider,
          chainId: safe.chainId,
          args: item.args,
          delayModifierAddress: item.address,
          signerAddress: wallet.address,
        })
        setTxFlow(undefined)
      } catch (err) {
        trackError(Errors._812, err)
      }
    },
    [asyncCallback, setTxFlow, wallet, safe, item.address, item.args],
  )

  useEffect(() => {
    setNonceNeeded(false)
  }, [setNonceNeeded])

  return (
    <TxCard>
      <form onSubmit={onFormSubmit}>
        <Stack
          sx={{
            gap: 3,
            mb: 2,
          }}
        >
          <Typography>Execute this transaction to finalize the recovery.</Typography>

          <FieldsGrid title="Initiator">
            <EthHashInfo address={item.executor} showName showCopyButton hasExplorer />
          </FieldsGrid>

          <Divider sx={{ mx: -3 }} />

          <RecoveryDescription item={item} />

          <NetworkWarning />

          <RecoveryValidationErrors item={item} />

          {error && <ErrorMessage error={error}>Error submitting the transaction.</ErrorMessage>}
        </Stack>

        <Divider sx={{ mx: -3, my: 3.5 }} />

        <CardActions>
          {/* Submit button, also available to non-owner role members */}
          <CheckWallet allowNonOwner>
            {(isOk) => (
              <Button
                data-testid="execute-through-role-form-btn"
                variant="contained"
                type="submit"
                disabled={!isOk || isLoading}
                sx={{ minWidth: '112px' }}
              >
                {isLoading ? <CircularProgress size={20} /> : 'Execute'}
              </Button>
            )}
          </CheckWallet>
        </CardActions>
      </form>
    </TxCard>
  )
}

export default RecoveryAttemptReview
</file>

<file path="src/components/tx-flow/flows/RejectTx/index.tsx">
import { useMemo, type ReactElement } from 'react'
import TxLayout from '../../common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import RejectTx from './RejectTx'
import useTxStepper from '../../useTxStepper'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

type RejectTxProps = {
  txNonce: number
}

const RejectTxFlow = ({ txNonce }: RejectTxProps): ReactElement => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.REJECT_TX)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <RejectTx key={0} txNonce={txNonce} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={1} onSubmit={() => {}} isRejection />,
      },
    ],
    [nextStep, txNonce],
  )

  return (
    <TxLayout subtitle="Reject" step={step} onBack={prevStep} {...(steps?.[step]?.txLayoutProps || {})}>
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default RejectTxFlow
</file>

<file path="src/components/tx-flow/flows/RejectTx/RejectTx.tsx">
import type { ReactElement } from 'react'
import { Typography } from '@mui/material'
import { createRejectTx } from '@/services/tx/tx-sender'
import { useContext, useEffect } from 'react'
import { SafeTxContext } from '../../SafeTxProvider'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

type RejectTxProps = {
  txNonce: number
  onSubmit: () => void
}

const RejectTx = ({ txNonce, onSubmit }: RejectTxProps): ReactElement => {
  const { setSafeTx, setSafeTxError, setNonce } = useContext(SafeTxContext)

  useEffect(() => {
    setNonce(txNonce)

    createRejectTx(txNonce).then(setSafeTx).catch(setSafeTxError)
  }, [txNonce, setNonce, setSafeTx, setSafeTxError])

  return (
    <ReviewTransaction isBatchable={false} onSubmit={onSubmit} isRejection>
      <Typography mb={2}>
        To reject the transaction, a separate rejection transaction will be created to replace the original one.
      </Typography>

      <Typography mb={2}>
        Transaction nonce: <b>{txNonce}</b>
      </Typography>

      <Typography mb={2}>
        You will need to confirm the rejection transaction with your currently connected wallet.
      </Typography>
    </ReviewTransaction>
  )
}

export default RejectTx
</file>

<file path="src/components/tx-flow/flows/RemoveGuard/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import { ReviewRemoveGuard } from '@/components/tx-flow/flows/RemoveGuard/ReviewRemoveGuard'
import useTxStepper from '../../useTxStepper'
import { useMemo } from 'react'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

// TODO: This can possibly be combined with the remove module type
export type RemoveGuardFlowProps = {
  address: string
}

const RemoveGuardFlow = ({ address }: RemoveGuardFlowProps) => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.REMOVE_GUARD)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewRemoveGuard key={0} params={{ address }} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, address],
  )

  return (
    <TxLayout subtitle="Remove guard" step={step} onBack={prevStep} {...(steps?.[step]?.txLayoutProps || {})}>
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default RemoveGuardFlow
</file>

<file path="src/components/tx-flow/flows/RemoveGuard/ReviewRemoveGuard.tsx">
import { useCallback, useContext, useEffect } from 'react'
import { Typography } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import { Errors, logError } from '@/services/exceptions'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import { createRemoveGuardTx } from '@/services/tx/tx-sender'
import { type RemoveGuardFlowProps } from '.'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const ReviewRemoveGuard = ({ params, onSubmit }: { params: RemoveGuardFlowProps; onSubmit: () => void }) => {
  const { setSafeTx, safeTxError, setSafeTxError } = useContext(SafeTxContext)

  useEffect(() => {
    createRemoveGuardTx().then(setSafeTx).catch(setSafeTxError)
  }, [setSafeTx, setSafeTxError])

  useEffect(() => {
    if (safeTxError) {
      logError(Errors._807, safeTxError.message)
    }
  }, [safeTxError])

  const onFormSubmit = useCallback(() => {
    trackEvent(SETTINGS_EVENTS.MODULES.REMOVE_GUARD)
    onSubmit()
  }, [onSubmit])

  return (
    <ReviewTransaction onSubmit={onFormSubmit}>
      <Typography sx={({ palette }) => ({ color: palette.primary.light })}>Transaction guard</Typography>

      <EthHashInfo address={params.address} showCopyButton hasExplorer shortAddress={false} />

      <Typography my={2}>
        Once the transaction guard has been removed, checks by the transaction guard will not be conducted before or
        after any subsequent transactions.
      </Typography>
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/RemoveModule/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import { ReviewRemoveModule } from './ReviewRemoveModule'
import { useMemo } from 'react'
import useTxStepper from '../../useTxStepper'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

export type RemoveModuleFlowProps = {
  address: string
}

const RemoveModuleFlow = ({ address }: RemoveModuleFlowProps) => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.REMOVE_MODULE)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewRemoveModule key={0} params={{ address }} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={1} onSubmit={() => {}} />,
      },
    ],
    [nextStep, address],
  )

  return (
    <TxLayout subtitle="Remove module" step={step} onBack={prevStep} {...(steps?.[step]?.txLayoutProps || {})}>
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default RemoveModuleFlow
</file>

<file path="src/components/tx-flow/flows/RemoveModule/ReviewRemoveModule.tsx">
import { Grid, Typography } from '@mui/material'
import { useCallback, useContext, useEffect } from 'react'
import { Errors, logError } from '@/services/exceptions'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import { createRemoveModuleTx } from '@/services/tx/tx-sender'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { type RemoveModuleFlowProps } from '.'
import EthHashInfo from '@/components/common/EthHashInfo'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const ReviewRemoveModule = ({ params, onSubmit }: { params: RemoveModuleFlowProps; onSubmit: () => void }) => {
  const { setSafeTx, safeTxError, setSafeTxError } = useContext(SafeTxContext)

  useEffect(() => {
    createRemoveModuleTx(params.address).then(setSafeTx).catch(setSafeTxError)
  }, [params.address, setSafeTx, setSafeTxError])

  useEffect(() => {
    if (safeTxError) {
      logError(Errors._806, safeTxError.message)
    }
  }, [safeTxError])

  const onFormSubmit = useCallback(() => {
    trackEvent(SETTINGS_EVENTS.MODULES.REMOVE_MODULE)
    onSubmit()
  }, [onSubmit])

  return (
    <ReviewTransaction onSubmit={onFormSubmit}>
      <Grid
        container
        sx={{
          gap: 1,
          alignItems: 'center',
        }}
      >
        <Grid item xs={2}>
          Module
        </Grid>
        <Typography variant="body2" component="div">
          <EthHashInfo address={params.address} shortAddress={false} hasExplorer showCopyButton />
        </Typography>
      </Grid>
      <Typography
        sx={{
          my: 2,
        }}
      >
        After removing this module, any feature or app that uses this module might no longer work. If this Safe Account
        requires more then one signature, the module removal will have to be confirmed by other signers as well.
      </Typography>
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/RemoveOwner/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import useSafeInfo from '@/hooks/useSafeInfo'
import useTxStepper from '../../useTxStepper'
import { ReviewRemoveOwner } from './ReviewRemoveOwner'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import { SetThreshold } from './SetThreshold'
import { useMemo } from 'react'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

type Owner = {
  address: string
  name?: string
}

export type RemoveOwnerFlowProps = {
  removedOwner: Owner
  threshold: number
}

const RemoveOwnerFlow = (props: Owner) => {
  const { safe } = useSafeInfo()

  const defaultValues: RemoveOwnerFlowProps = {
    removedOwner: props,
    threshold: Math.min(safe.threshold, safe.owners.length - 1),
  }

  const { data, step, nextStep, prevStep } = useTxStepper<RemoveOwnerFlowProps>(defaultValues, TxFlowType.REMOVE_OWNER)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'New transaction' },
        content: (
          <SetThreshold key={0} params={data} onSubmit={(formData: any) => nextStep({ ...data, ...formData })} />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewRemoveOwner key={1} params={data} onSubmit={() => nextStep(data)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, data],
  )

  return (
    <TxLayout
      subtitle="Remove signer"
      icon={SaveAddressIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default RemoveOwnerFlow
</file>

<file path="src/components/tx-flow/flows/RemoveOwner/ReviewRemoveOwner.tsx">
import { useCallback, useContext, useEffect } from 'react'
import { Typography, Divider, Box, Paper, SvgIcon } from '@mui/material'
import type { ReactElement } from 'react'

import useAddressBook from '@/hooks/useAddressBook'
import useSafeInfo from '@/hooks/useSafeInfo'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import { createRemoveOwnerTx } from '@/services/tx/tx-sender'
import MinusIcon from '@/public/images/common/minus.svg'
import { SafeTxContext } from '../../SafeTxProvider'
import type { RemoveOwnerFlowProps } from '.'
import EthHashInfo from '@/components/common/EthHashInfo'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import { ChangeSignerSetupWarning } from '@/features/multichain/components/SignerSetupWarning/ChangeSignerSetupWarning'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const ReviewRemoveOwner = ({
  params,
  onSubmit,
}: {
  params: RemoveOwnerFlowProps
  onSubmit: () => void
}): ReactElement => {
  const addressBook = useAddressBook()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const { safe } = useSafeInfo()
  const { removedOwner, threshold } = params

  useEffect(() => {
    createRemoveOwnerTx({ ownerAddress: removedOwner.address, threshold }).then(setSafeTx).catch(setSafeTxError)
  }, [removedOwner.address, setSafeTx, setSafeTxError, threshold])

  const newOwnerLength = safe.owners.length - 1

  const onFormSubmit = useCallback(() => {
    trackEvent({ ...SETTINGS_EVENTS.SETUP.THRESHOLD, label: safe.threshold })
    trackEvent({ ...SETTINGS_EVENTS.SETUP.OWNERS, label: safe.owners.length })
    onSubmit()
  }, [onSubmit, safe.threshold, safe.owners])

  return (
    <ReviewTransaction onSubmit={onFormSubmit}>
      <Paper sx={{ backgroundColor: ({ palette }) => palette.warning.background, p: 2 }}>
        <Typography color="text.secondary" mb={2} display="flex" alignItems="center">
          <SvgIcon component={MinusIcon} inheritViewBox fontSize="small" sx={{ mr: 1 }} />
          Selected signer
        </Typography>
        <EthHashInfo
          address={removedOwner.address}
          name={addressBook[removedOwner.address]}
          shortAddress={false}
          showCopyButton
          hasExplorer
        />
      </Paper>
      <ChangeSignerSetupWarning />

      <Divider className={commonCss.nestedDivider} />
      <Box m={1}>
        <Typography variant="body2" color="text.secondary" mb={0.5}>
          Any transaction requires the confirmation of:
        </Typography>
        <Typography>
          <b>{threshold}</b> out of <b>{newOwnerLength}</b> signer{maybePlural(newOwnerLength)}
        </Typography>
      </Box>
      <Divider className={commonCss.nestedDivider} />
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/RemoveOwner/SetThreshold.tsx">
import { useState } from 'react'
import { Button, Box, CardActions, Divider, Grid, MenuItem, Select, Typography, SvgIcon, Tooltip } from '@mui/material'
import type { ReactElement, SyntheticEvent } from 'react'
import type { SelectChangeEvent } from '@mui/material'

import EthHashInfo from '@/components/common/EthHashInfo'
import useSafeInfo from '@/hooks/useSafeInfo'
import TxCard from '../../common/TxCard'
import InfoIcon from '@/public/images/notifications/info.svg'
import { TOOLTIP_TITLES } from '@/components/tx-flow/common/constants'
import type { RemoveOwnerFlowProps } from '.'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import { maybePlural } from '@safe-global/utils/utils/formatters'

export const SetThreshold = ({
  params,
  onSubmit,
}: {
  params: RemoveOwnerFlowProps
  onSubmit: (data: RemoveOwnerFlowProps) => void
}): ReactElement => {
  const { safe } = useSafeInfo()
  const [selectedThreshold, setSelectedThreshold] = useState<number>(params.threshold ?? 1)

  const handleChange = (event: SelectChangeEvent<number>) => {
    setSelectedThreshold(parseInt(event.target.value.toString()))
  }

  const onSubmitHandler = (e: SyntheticEvent) => {
    e.preventDefault()
    onSubmit({ ...params, threshold: selectedThreshold })
  }

  const newNumberOfOwners = safe ? safe.owners.length - 1 : 1

  return (
    <TxCard>
      <form onSubmit={onSubmitHandler}>
        <Box
          sx={{
            mb: 3,
          }}
        >
          <Typography
            sx={{
              mb: 2,
            }}
          >
            Review the signer you want to remove from the active Safe Account:
          </Typography>
          {/* TODO: Update the EthHashInfo style from the replace owner PR */}
          <EthHashInfo address={params.removedOwner.address} shortAddress={false} showCopyButton hasExplorer />
        </Box>

        <Divider className={commonCss.nestedDivider} />

        <Box
          sx={{
            my: 3,
          }}
        >
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
            }}
          >
            Threshold
            <Tooltip title={TOOLTIP_TITLES.THRESHOLD} arrow placement="top">
              <span>
                <SvgIcon
                  component={InfoIcon}
                  inheritViewBox
                  color="border"
                  fontSize="small"
                  sx={{
                    verticalAlign: 'middle',
                    ml: 0.5,
                  }}
                />
              </span>
            </Tooltip>
          </Typography>
          <Typography>Any transaction requires the confirmation of:</Typography>
          <Grid
            container
            direction="row"
            sx={{
              alignItems: 'center',
              gap: 1,
              mt: 2,
            }}
          >
            <Grid item xs={1.5}>
              <Select data-testid="threshold-selector" value={selectedThreshold} onChange={handleChange} fullWidth>
                {safe.owners.slice(1).map((_, idx) => (
                  <MenuItem key={idx + 1} value={idx + 1}>
                    {idx + 1}
                  </MenuItem>
                ))}
              </Select>
            </Grid>
            <Grid item>
              <Typography>
                out of {newNumberOfOwners} signer{maybePlural(newNumberOfOwners)}
              </Typography>
            </Grid>
          </Grid>
        </Box>

        <Divider className={commonCss.nestedDivider} />

        <CardActions>
          <Button data-testid="next-btn" variant="contained" type="submit">
            Next
          </Button>
        </CardActions>
      </form>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/RemoveOwner/styles.module.css">
.action {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
}
</file>

<file path="src/components/tx-flow/flows/RemoveRecovery/index.tsx">
import { useMemo, type ReactElement } from 'react'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import RecoveryPlus from '@/public/images/common/recovery-plus.svg'
import useTxStepper from '../../useTxStepper'
import { RemoveRecoveryFlowOverview } from './RemoveRecoveryFlowOverview'
import { RemoveRecoveryFlowReview } from './RemoveRecoveryFlowReview'
import type { RecoveryStateItem } from '@/features/recovery/services/recovery-state'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

export type RecoveryFlowProps = {
  delayModifier: RecoveryStateItem
}

function RemoveRecoveryFlow({ delayModifier }: RecoveryFlowProps): ReactElement {
  const { step, nextStep, prevStep } = useTxStepper<undefined>(undefined, TxFlowType.REMOVE_RECOVERY)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Remove Account recovery' },
        content: (
          <RemoveRecoveryFlowOverview key={0} delayModifier={delayModifier} onSubmit={() => nextStep(undefined)} />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: (
          <RemoveRecoveryFlowReview key={1} delayModifier={delayModifier} onSubmit={() => nextStep(undefined)} />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
      },
    ],
    [nextStep, delayModifier],
  )

  return (
    <TxLayout
      subtitle="Remove Recoverer"
      icon={RecoveryPlus}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default RemoveRecoveryFlow
</file>

<file path="src/components/tx-flow/flows/RemoveRecovery/RemoveRecoveryFlowOverview.tsx">
import { Button, CardActions, Divider, Typography } from '@mui/material'
import type { ReactElement } from 'react'

import EthHashInfo from '@/components/common/EthHashInfo'
import TxCard from '../../common/TxCard'
import type { RecoveryFlowProps } from '.'

import commonCss from '@/components/tx-flow/common/styles.module.css'

export function RemoveRecoveryFlowOverview({
  delayModifier,
  onSubmit,
}: RecoveryFlowProps & { onSubmit: () => void }): ReactElement {
  return (
    <TxCard>
      <Typography variant="body2">
        This transaction will remove the recovery module from your Safe Account. You will no longer be able to recover
        your Safe Account.
      </Typography>

      <Typography variant="body2">
        This Recoverer will not be able to initiate the recovery process once this transaction is executed.
      </Typography>

      <div data-testid="remove-recoverer-section">
        <Typography variant="body2" color="text.secondary" mb={1}>
          Removing Recoverer
        </Typography>

        {delayModifier.recoverers.map((recoverer) => (
          <EthHashInfo
            avatarSize={32}
            key={recoverer}
            shortAddress={false}
            address={recoverer}
            hasExplorer
            showCopyButton
          />
        ))}
      </div>

      <Divider className={commonCss.nestedDivider} />

      <CardActions sx={{ mt: '0 !important' }}>
        <Button data-testid="next-btn" variant="contained" onClick={onSubmit}>
          Next
        </Button>
      </CardActions>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/RemoveRecovery/RemoveRecoveryFlowReview.tsx">
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Typography } from '@mui/material'
import { useCallback, useContext, useEffect } from 'react'
import type { ReactElement } from 'react'

import { createRemoveModuleTx } from '@/services/tx/tx-sender'
import { OwnerList } from '../../common/OwnerList'
import { SafeTxContext } from '../../SafeTxProvider'
import type { RecoveryFlowProps } from '.'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export function RemoveRecoveryFlowReview({
  delayModifier,
  onSubmit,
}: RecoveryFlowProps & { onSubmit: () => void }): ReactElement {
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)

  useEffect(() => {
    createRemoveModuleTx(delayModifier.address).then(setSafeTx).catch(setSafeTxError)
  }, [delayModifier.address, setSafeTx, setSafeTxError])

  const onFormSubmit = useCallback(() => {
    trackEvent({ ...RECOVERY_EVENTS.SUBMIT_RECOVERY_REMOVE })
    onSubmit()
  }, [onSubmit])

  return (
    <ReviewTransaction onSubmit={onFormSubmit}>
      <Typography>
        This transaction will remove the recovery module from your Safe Account. You will no longer be able to recover
        your Safe Account once this transaction is executed.
      </Typography>

      <OwnerList
        title="Removing Recoverer"
        owners={delayModifier.recoverers.map((recoverer) => ({ value: recoverer }))}
        sx={{ bgcolor: ({ palette }) => `${palette.warning.background} !important` }}
      />
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/RemoveSpendingLimit/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import { RemoveSpendingLimit } from './RemoveSpendingLimit'
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import { useMemo } from 'react'
import useTxStepper from '../../useTxStepper'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

const RemoveSpendingLimitFlow = ({ spendingLimit }: { spendingLimit: SpendingLimitState }) => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.REMOVE_SPENDING_LIMIT)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <RemoveSpendingLimit params={spendingLimit} key={0} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={1} onSubmit={() => {}} />,
      },
    ],
    [nextStep, spendingLimit],
  )

  return (
    <TxLayout
      subtitle="Remove spending limit"
      icon={SaveAddressIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default RemoveSpendingLimitFlow
</file>

<file path="src/components/tx-flow/flows/RemoveSpendingLimit/RemoveSpendingLimit.tsx">
import {
  getSpendingLimitInterface,
  getDeployedSpendingLimitModuleAddress,
} from '@/services/contracts/spendingLimitContracts'
import useChainId from '@/hooks/useChainId'
import { useCallback, useContext, useEffect } from 'react'
import { SafeTxContext } from '../../SafeTxProvider'
import EthHashInfo from '@/components/common/EthHashInfo'
import { Grid, Typography } from '@mui/material'
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import { relativeTime } from '@safe-global/utils/utils/date'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import useBalances from '@/hooks/useBalances'
import SendAmountBlock from '@/components/tx-flow/flows/TokenTransfer/SendAmountBlock'
import SpendingLimitLabel from '@/components/common/SpendingLimitLabel'
import { createTx } from '@/services/tx/tx-sender'
import useSafeInfo from '@/hooks/useSafeInfo'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const RemoveSpendingLimit = ({ params, onSubmit }: { params: SpendingLimitState; onSubmit: () => void }) => {
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  const chainId = useChainId()
  const { safe } = useSafeInfo()
  const { balances } = useBalances()
  const token = balances.items.find((item) => item.tokenInfo.address === params.token.address)

  const amountInWei = params.amount

  useEffect(() => {
    if (!safe.modules?.length) return

    const spendingLimitAddress = getDeployedSpendingLimitModuleAddress(chainId, safe.modules)
    if (!spendingLimitAddress) return

    const spendingLimitInterface = getSpendingLimitInterface()
    const txData = spendingLimitInterface.encodeFunctionData('deleteAllowance', [
      params.beneficiary,
      params.token.address,
    ])

    const txParams = {
      to: spendingLimitAddress,
      value: '0',
      data: txData,
    }

    createTx(txParams).then(setSafeTx).catch(setSafeTxError)
  }, [chainId, params.beneficiary, params.token, setSafeTx, setSafeTxError, safe.modules])

  const onFormSubmit = useCallback(() => {
    trackEvent(SETTINGS_EVENTS.SPENDING_LIMIT.LIMIT_REMOVED)
    onSubmit()
  }, [onSubmit])

  return (
    <ReviewTransaction onSubmit={onFormSubmit}>
      {token && <SendAmountBlock amountInWei={amountInWei} tokenInfo={token.tokenInfo} title="Amount" />}
      <Grid
        container
        sx={{
          gap: 1,
          alignItems: 'center',
        }}
      >
        <Grid item md>
          <Typography
            variant="body2"
            sx={{
              color: 'text.secondary',
            }}
          >
            Beneficiary
          </Typography>
        </Grid>
        <Grid item md={10}>
          <EthHashInfo
            address={params.beneficiary}
            showCopyButton
            hasExplorer
            shortAddress={false}
            showAvatar={false}
          />
        </Grid>
      </Grid>
      <Grid
        container
        sx={{
          gap: 1,
          alignItems: 'center',
        }}
      >
        <Grid item md>
          <Typography
            variant="body2"
            sx={{
              color: 'text.secondary',
            }}
          >
            Reset time
          </Typography>
        </Grid>
        <Grid item md={10}>
          <SpendingLimitLabel
            label={relativeTime(params.lastResetMin, params.resetTimeMin)}
            isOneTime={params.resetTimeMin === '0'}
          />
        </Grid>
      </Grid>
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/ReplaceOwner/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import useTxStepper from '@/components/tx-flow/useTxStepper'
import useSafeInfo from '@/hooks/useSafeInfo'
import { ReviewOwner } from '../AddOwner/ReviewOwner'
import { ChooseOwner, ChooseOwnerMode } from '../AddOwner/ChooseOwner'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

type Owner = {
  address: string
  name?: string
}

export type ReplaceOwnerFlowProps = {
  newOwner: Owner
  removedOwner: Owner
  threshold: number
}

const ReplaceOwnerFlow = ({ address }: { address: string }) => {
  const { safe } = useSafeInfo()

  const defaultValues: ReplaceOwnerFlowProps = {
    newOwner: { address: '' },
    removedOwner: { address },
    threshold: safe.threshold,
  }

  const { data, step, nextStep, prevStep } = useTxStepper<ReplaceOwnerFlowProps>(
    defaultValues,
    TxFlowType.REPLACE_OWNER,
  )

  const steps: TxStep[] = [
    {
      txLayoutProps: { title: 'New transaction' },
      content: (
        <ChooseOwner
          key={0}
          params={data}
          onSubmit={(formData) => nextStep({ ...data, ...formData })}
          mode={ChooseOwnerMode.REPLACE}
        />
      ),
    },
    {
      txLayoutProps: { title: 'Confirm transaction' },
      content: <ReviewOwner key={1} params={data} onSubmit={() => nextStep(data)} />,
    },
    {
      txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
      content: <ConfirmTxDetails key={2} onSubmit={() => {}} />,
    },
  ]

  return (
    <TxLayout
      subtitle="Replace signer"
      icon={SaveAddressIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default ReplaceOwnerFlow
</file>

<file path="src/components/tx-flow/flows/ReplaceTx/DeleteTxModal.tsx">
import useWallet from '@/hooks/wallets/useWallet'
import { useState } from 'react'
import {
  Dialog,
  DialogTitle,
  Typography,
  IconButton,
  Divider,
  DialogContent,
  DialogActions,
  Button,
  Box,
  SvgIcon,
  CircularProgress,
} from '@mui/material'
import { Close } from '@mui/icons-material'
import madProps from '@/utils/mad-props'
import useChainId from '@/hooks/useChainId'
import useSafeAddress from '@/hooks/useSafeAddress'
import { deleteTx } from '@/utils/gateway'
import { getAssertedChainSigner } from '@/services/tx/tx-sender/sdk'
import InfoIcon from '@/public/images/notifications/info.svg'
import ErrorMessage from '@/components/tx/ErrorMessage'
import ExternalLink from '@/components/common/ExternalLink'
import ChainIndicator from '@/components/common/ChainIndicator'
import { txDispatch, TxEvent } from '@/services/tx/txEvents'
import { REJECT_TX_EVENTS } from '@/services/analytics/events/reject-tx'
import { trackEvent } from '@/services/analytics'
import { isWalletRejection } from '@/utils/wallets'
import CheckWallet from '@/components/common/CheckWallet'
import ChainSwitcher from '@/components/common/ChainSwitcher'

type DeleteTxModalProps = {
  safeTxHash: string
  onClose: () => void
  onSuccess: () => void
  wallet: ReturnType<typeof useWallet>
  chainId: ReturnType<typeof useChainId>
  safeAddress: ReturnType<typeof useSafeAddress>
}

const InternalDeleteTxModal = ({
  safeTxHash,
  onSuccess,
  onClose,
  wallet,
  safeAddress,
  chainId,
}: DeleteTxModalProps) => {
  const [error, setError] = useState<Error>()
  const [isLoading, setIsLoading] = useState<boolean>(false)

  const onConfirm = async () => {
    setError(undefined)
    setIsLoading(true)
    trackEvent(REJECT_TX_EVENTS.DELETE_CONFIRM)

    if (!wallet?.provider || !safeAddress || !chainId || !safeTxHash) {
      setIsLoading(false)
      setError(new Error('Please connect your wallet first'))
      trackEvent(REJECT_TX_EVENTS.DELETE_FAIL)
      return
    }

    try {
      const signer = await getAssertedChainSigner(wallet.provider)

      await deleteTx({
        safeTxHash,
        safeAddress,
        chainId,
        signer,
      })
    } catch (error) {
      setIsLoading(false)
      setError(error as Error)
      trackEvent(isWalletRejection(error as Error) ? REJECT_TX_EVENTS.DELETE_CANCEL : REJECT_TX_EVENTS.DELETE_FAIL)
      return
    }

    setIsLoading(false)
    txDispatch(TxEvent.DELETED, { safeTxHash })
    onSuccess()
    trackEvent(REJECT_TX_EVENTS.DELETE_SUCCESS)
  }

  const onCancel = () => {
    trackEvent(REJECT_TX_EVENTS.DELETE_CANCEL)
    onClose()
  }

  return (
    <Dialog open onClose={onClose}>
      <DialogTitle>
        <Box data-testid="untrusted-token-warning" display="flex" alignItems="center">
          <Typography variant="h6" fontWeight={700} sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <SvgIcon component={InfoIcon} inheritViewBox color="error" />
            Delete this transaction?
          </Typography>

          <Box flexGrow={1} />

          <ChainIndicator chainId={chainId} />

          <IconButton aria-label="close" onClick={onClose} sx={{ marginLeft: 'auto' }}>
            <Close />
          </IconButton>
        </Box>
      </DialogTitle>

      <Divider />

      <DialogContent>
        <Box>
          Are you sure you want to delete this transaction? This will permanently remove it from the queue but the
          already given signatures will remain valid.
        </Box>

        <Box mt={2}>
          Make sure that you are aware of the{' '}
          <ExternalLink href="https://help.safe.global/en/articles/40836-why-do-i-need-to-pay-for-cancelling-a-transaction">
            potential risks
          </ExternalLink>{' '}
          related to deleting a transaction off-chain.
        </Box>

        <Box mt={2}>
          <ChainSwitcher />
        </Box>

        {error && (
          <Box mt={2}>
            <ErrorMessage error={error}>Error deleting transaction</ErrorMessage>
          </Box>
        )}
      </DialogContent>

      <Divider />

      <DialogActions sx={{ padding: 3, justifyContent: 'space-between' }}>
        <Button size="small" variant="text" onClick={onCancel}>
          Keep it
        </Button>

        <CheckWallet checkNetwork>
          {(isOk) => (
            <Button
              data-testid="delete-tx-btn"
              size="small"
              variant="contained"
              color="primary"
              onClick={onConfirm}
              disabled={!isOk || isLoading}
              sx={{ minWidth: '122px', minHeight: '36px' }}
            >
              {isLoading ? <CircularProgress size={20} /> : 'Yes, delete'}
            </Button>
          )}
        </CheckWallet>
      </DialogActions>
    </Dialog>
  )
}

const DeleteTxModal = madProps(InternalDeleteTxModal, {
  wallet: useWallet,
  chainId: useChainId,
  safeAddress: useSafeAddress,
})

export default DeleteTxModal
</file>

<file path="src/components/tx-flow/flows/ReplaceTx/index.tsx">
import { useContext, useState } from 'react'
import { type NextRouter, useRouter } from 'next/router'
import { Box, Tooltip, Typography } from '@mui/material'
import DeleteIcon from '@/public/images/common/delete.svg'
import CancelIcon from '@/public/images/common/cancel.svg'
import ReplaceTxIcon from '@/public/images/transactions/replace-tx.svg'
import CachedIcon from '@mui/icons-material/Cached'
import { useQueuedTxByNonce } from '@/hooks/useTxQueue'
import { isCustomTxInfo } from '@/utils/transaction-guards'

import css from './styles.module.css'
import { TxModalContext } from '../..'
import TokenTransferFlow from '../TokenTransfer'
import RejectTx from '../RejectTx'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import TxCard from '@/components/tx-flow/common/TxCard'
import DeleteTxModal from './DeleteTxModal'
import ExternalLink from '@/components/common/ExternalLink'
import ChoiceButton from '@/components/common/ChoiceButton'
import useWallet from '@/hooks/wallets/useWallet'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { AppRoutes } from '@/config/routes'
import { useHasFeature } from '@/hooks/useChains'
import Track from '@/components/common/Track'
import { REJECT_TX_EVENTS } from '@/services/analytics/events/reject-tx'
import { useRecommendedNonce } from '@/components/tx/SignOrExecuteForm/hooks'
import { FEATURES } from '@safe-global/utils/utils/chains'

const goToQueue = (router: NextRouter) => {
  if (router.pathname === AppRoutes.transactions.tx) {
    router.push({
      pathname: AppRoutes.transactions.queue,
      query: { safe: router.query.safe },
    })
  }
}

/**
 * To avoid nonce gaps in the queue, we allow deleting the last transaction in the queue or duplicates.
 * The recommended nonce is used to calculate the last transaction in the queue.
 */
const useIsNonceDeletable = (txNonce: number) => {
  const queuedTxsByNonce = useQueuedTxByNonce(txNonce)
  const recommendedNonce = useRecommendedNonce() || 0
  const duplicateCount = queuedTxsByNonce?.length || 0
  return duplicateCount > 1 || txNonce === recommendedNonce - 1
}

const DeleteTxButton = ({
  safeTxHash,
  txNonce,
  onSuccess,
}: {
  safeTxHash: string
  txNonce: number
  onSuccess: () => void
}) => {
  const router = useRouter()
  const isDeletable = useIsNonceDeletable(txNonce)
  const [isDeleting, setIsDeleting] = useState(false)

  const onDeleteSuccess = () => {
    setIsDeleting(false)
    goToQueue(router)
    onSuccess()
  }
  const onDeleteClose = () => setIsDeleting(false)

  return (
    <>
      <Typography variant="overline" className={css.or}>
        or
      </Typography>

      <Typography variant="body2" mb={0.5}>
        Don’t want to have this transaction anymore? Remove it permanently from the queue.
      </Typography>

      <Tooltip
        arrow
        placement="top"
        title={isDeletable ? '' : 'You can only delete the last transaction in the queue, or a duplicate transaction.'}
      >
        <span style={{ width: '100%' }}>
          <Track {...REJECT_TX_EVENTS.DELETE_OFFCHAIN_BUTTON} as="div">
            <ChoiceButton
              icon={DeleteIcon}
              iconColor="error"
              onClick={() => setIsDeleting(true)}
              title="Delete from the queue"
              description="Remove this transaction from the off-chain queue"
              disabled={!isDeletable}
            />
          </Track>
        </span>
      </Tooltip>

      {safeTxHash && isDeleting && (
        <DeleteTxModal onSuccess={onDeleteSuccess} onClose={onDeleteClose} safeTxHash={safeTxHash} />
      )}
    </>
  )
}

const ReplaceTxMenu = ({
  txNonce,
  safeTxHash,
  proposer,
}: {
  txNonce: number
  safeTxHash?: string
  proposer?: string
}) => {
  const wallet = useWallet()
  const { setTxFlow } = useContext(TxModalContext)
  const queuedTxsByNonce = useQueuedTxByNonce(txNonce)
  const canCancel = !queuedTxsByNonce?.some(
    (item) => isCustomTxInfo(item.transaction.txInfo) && item.transaction.txInfo.isCancellation,
  )

  const isDeleteEnabled = useHasFeature(FEATURES.DELETE_TX)
  const canDelete = safeTxHash && isDeleteEnabled && proposer && wallet && sameAddress(wallet.address, proposer)

  return (
    <TxLayout title={`Reject transaction #${txNonce}`} step={0} hideNonce isReplacement>
      <TxCard>
        <Box mt={2} textAlign="center">
          <ReplaceTxIcon />
        </Box>

        <Typography variant="body2" mt={-1} mb={1}>
          You can replace or reject this transaction on-chain. It requires gas fees and your signature.{' '}
          <Track {...REJECT_TX_EVENTS.READ_MORE}>
            <ExternalLink href="https://help.safe.global/en/articles/40836-why-do-i-need-to-pay-for-cancelling-a-transaction">
              Read more
            </ExternalLink>
          </Track>
        </Typography>

        <Box display="flex" flexDirection="column" gap={2}>
          <Track {...REJECT_TX_EVENTS.REPLACE_TX_BUTTON} as="div">
            <ChoiceButton
              icon={CachedIcon}
              onClick={() => setTxFlow(<TokenTransferFlow txNonce={txNonce} />)}
              title="Replace with another transaction"
              description="Propose a new transaction with the same nonce to overwrite this one"
              chip="Recommended"
            />
          </Track>

          <Tooltip
            arrow
            placement="top"
            title={canCancel ? '' : `Transaction with nonce ${txNonce} already has a reject transaction`}
          >
            <span style={{ width: '100%' }}>
              <Track {...REJECT_TX_EVENTS.REJECT_ONCHAIN_BUTTON} as="div">
                <ChoiceButton
                  icon={CancelIcon}
                  iconColor="warning"
                  onClick={() => setTxFlow(<RejectTx txNonce={txNonce} />)}
                  disabled={!canCancel}
                  title="Reject transaction"
                  description="Propose an on-chain cancellation transaction with the same nonce"
                  chip={canDelete ? 'Recommended' : undefined}
                />
              </Track>
            </span>
          </Tooltip>

          {canDelete && (
            <DeleteTxButton
              data-testid="delete-tx"
              safeTxHash={safeTxHash}
              txNonce={txNonce}
              onSuccess={() => setTxFlow(undefined)}
            />
          )}
        </Box>
      </TxCard>
    </TxLayout>
  )
}

export default ReplaceTxMenu
</file>

<file path="src/components/tx-flow/flows/ReplaceTx/styles.module.css">
.container {
}

.redCircle {
  border: 3px solid var(--color-error-main);
}

.circle {
  border: 2px solid var(--color-border-light);
}

.circle,
.redCircle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 50%;
}

.stepper {
  padding-top: var(--space-3);
  gap: var(--space-2);
}

.stepper :global .MuiStepConnector-root {
  left: -8px;
  transform: translateX(-50%);
  width: calc(100% - 40px);
}

.stepper :global .MuiStepConnector-line {
  border: 1px solid var(--color-border-main);
}

.stepper :global .MuiStep-root:not(:nth-of-type(2)) .MuiStepConnector-line {
  border-color: var(--color-border-light);
}

.or {
  text-align: center;
  padding: var(--space-2) var(--space-3);
  color: var(--color-text-secondary);
  text-transform: uppercase;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: var(--space-1);
  padding: var(--space-1) 0;
  font-weight: 700;
}

.or:before,
.or:after {
  content: '';
  flex: 1;
  display: block;
  border-top: 1px solid var(--color-border-light);
}

@media (max-width: 599.95px) {
  .container {
    padding: var(--space-3) !important;
  }

  .stepper {
    gap: 0;
  }

  .stepper :global .MuiStep-root {
    padding: 0 !important;
    flex-shrink: 0;
    flex-grow: 0;
    flex-basis: 25%;
    width: 25%;
  }

  .stepper :global .MuiTypography-root {
    font-size: 11px;
    line-height: 16px;
    letter-spacing: 0.4px;
  }

  .stepper :global .MuiStepConnector-root {
    left: 0;
    width: calc(100% - 50px);
  }

  .or {
    padding: var(--space-1) var(--space-2);
  }

  .buttons {
    flex-direction: column;
  }
}
</file>

<file path="src/components/tx-flow/flows/SafeAppsTx/ConfirmSafeAppsTxDetails.tsx">
import { useCallback, useContext, useEffect } from 'react'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { SafeTxContext } from '../../SafeTxProvider'
import type { SignOrExecuteProps } from '@/components/tx/SignOrExecuteForm/SignOrExecuteFormV2'
import useWallet from '@/hooks/wallets/useWallet'
import useOnboard from '@/hooks/wallets/useOnboard'
import { dispatchSafeAppsTx } from '@/services/tx/tx-sender'
import { trackSafeAppTxCount } from '@/services/safe-apps/track-app-usage-count'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import type { SafeAppsTxParams } from '.'

export const ConfirmSafeAppsTxDetails = ({
  onSubmit,
  safeAppsTx: { requestId, appId },
  ...props
}: Omit<SignOrExecuteProps, 'onSubmit'> & {
  safeAppsTx: SafeAppsTxParams
  onSubmit?: (txId: string, safeTxHash: string) => void
}) => {
  const { txOrigin, setTxOrigin, safeTx, setSafeTxError } = useContext(SafeTxContext)
  const onboard = useOnboard()
  const wallet = useWallet()

  const handleSubmit = useCallback(
    async (txId: string) => {
      if (!safeTx || !onboard || !wallet?.provider) return
      trackSafeAppTxCount(Number(appId))

      let safeTxHash = ''
      try {
        safeTxHash = await dispatchSafeAppsTx(safeTx, requestId, wallet.provider, txId)
      } catch (error) {
        setSafeTxError(asError(error))
      }

      onSubmit?.(txId, safeTxHash)
    },
    [safeTx, appId, requestId, onboard, wallet?.provider, setSafeTxError, onSubmit],
  )

  useEffect(() => {
    return () => setTxOrigin(undefined)
  }, [setTxOrigin])

  return <ConfirmTxDetails origin={txOrigin} onSubmit={handleSubmit} {...props} />
}
</file>

<file path="src/components/tx-flow/flows/SafeAppsTx/index.tsx">
import type { BaseTransaction, RequestId, SendTransactionRequestParams } from '@safe-global/safe-apps-sdk'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import ReviewSafeAppsTx from './ReviewSafeAppsTx'
import { AppTitle } from '@/components/tx-flow/flows/SignMessage'
import useTxStepper from '../../useTxStepper'
import { useMemo } from 'react'
import { getTxOrigin } from '@/utils/transactions'
import { ConfirmSafeAppsTxDetails } from './ConfirmSafeAppsTxDetails'
import { TxFlowType } from '@/services/analytics'

export type SafeAppsTxParams = {
  appId?: string
  app?: Partial<SafeAppData>
  requestId: RequestId
  txs: BaseTransaction[]
  params?: SendTransactionRequestParams
}

const SafeAppsTxFlow = ({
  data,
  onSubmit,
}: {
  data: SafeAppsTxParams
  onSubmit?: (txId: string, safeTxHash: string) => void
}) => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.SAFE_APPS_TX)

  const origin = useMemo(() => getTxOrigin(data.app), [data.app])

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm transaction' },
        content: <ReviewSafeAppsTx key={0} safeAppsTx={data} origin={origin} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmSafeAppsTxDetails key={1} safeAppsTx={data} onSubmit={onSubmit} />,
      },
    ],
    [nextStep, data, onSubmit, origin],
  )
  return (
    <TxLayout
      subtitle={<AppTitle name={data.app?.name} logoUri={data.app?.iconUrl} txs={data.txs} />}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default SafeAppsTxFlow
</file>

<file path="src/components/tx-flow/flows/SafeAppsTx/ReviewSafeAppsTx.tsx">
import { useContext, useEffect } from 'react'
import type { ReactElement } from 'react'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import type { SafeAppsTxParams } from '.'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import useHighlightHiddenTab from '@/hooks/useHighlightHiddenTab'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { isTxValid } from '@/components/safe-apps/utils'
import ErrorMessage from '@/components/tx/ErrorMessage'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

type ReviewSafeAppsTxProps = {
  safeAppsTx: SafeAppsTxParams
  onSubmit: () => void
  origin?: string
}

const ReviewSafeAppsTx = ({ safeAppsTx: { txs, params }, onSubmit, origin }: ReviewSafeAppsTxProps): ReactElement => {
  const { setSafeTx, safeTxError, setSafeTxError } = useContext(SafeTxContext)

  useHighlightHiddenTab()

  useEffect(() => {
    const createSafeTx = async (): Promise<SafeTransaction> => {
      const isMultiSend = txs.length > 1
      const tx = isMultiSend ? await createMultiSendCallOnlyTx(txs) : await createTx(txs[0])

      if (params?.safeTxGas !== undefined) {
        // FIXME: do it properly via the Core SDK
        // @ts-expect-error safeTxGas readonly
        tx.data.safeTxGas = params.safeTxGas
      }

      return tx
    }

    createSafeTx().then(setSafeTx).catch(setSafeTxError)
  }, [txs, setSafeTx, setSafeTxError, params])

  const error = !isTxValid(txs)

  return (
    <ReviewTransaction onSubmit={onSubmit} origin={origin}>
      {error ? (
        <ErrorMessage error={safeTxError}>
          This Safe App initiated a transaction which cannot be processed. Please get in touch with the developer of
          this Safe App for more information.
        </ErrorMessage>
      ) : null}
    </ReviewTransaction>
  )
}

export default ReviewSafeAppsTx
</file>

<file path="src/components/tx-flow/flows/SignMessage/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import SignMessage, { type SignMessageProps } from '@/components/tx-flow/flows/SignMessage/SignMessage'
import { getSwapTitle } from '@/features/swap'
import { selectSwapParams } from '@/features/swap/store/swapParamsSlice'
import { useAppSelector } from '@/store'
import { Box, Typography } from '@mui/material'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import { ErrorBoundary } from '@sentry/react'
import { type BaseTransaction } from '@safe-global/safe-apps-sdk'
import { SWAP_TITLE } from '@/features/swap/constants'
import { STAKE_TITLE } from '@/features/stake/constants'
import { getStakeTitle } from '@/features/stake/helpers/utils'

const APP_LOGO_FALLBACK_IMAGE = '/images/apps/apps-icon.svg'
const APP_NAME_FALLBACK = 'Sign message'

export const AppTitle = ({
  name,
  logoUri,
  txs,
}: {
  name?: string | null
  logoUri?: string | null
  txs?: BaseTransaction[]
}) => {
  const swapParams = useAppSelector(selectSwapParams)

  const appName = name || APP_NAME_FALLBACK
  const appLogo = logoUri || APP_LOGO_FALLBACK_IMAGE

  let title = appName
  if (name === SWAP_TITLE) {
    title = getSwapTitle(swapParams.tradeType, txs) || title
  }

  if (name === STAKE_TITLE) {
    title = getStakeTitle(txs) || title
  }

  return (
    <Box display="flex" alignItems="center">
      <SafeAppIconCard src={appLogo} alt={name || 'The icon of the application'} width={32} height={32} />
      <Typography variant="h4" pl={2} fontWeight="bold">
        {title}
      </Typography>
    </Box>
  )
}

const SignMessageFlow = ({ ...props }: SignMessageProps) => {
  return (
    <TxLayout
      title="Confirm message"
      subtitle={<AppTitle name={props.name} logoUri={props.logoUri} />}
      step={0}
      hideNonce
      isMessage
    >
      <ErrorBoundary fallback={<div>Error signing message</div>}>
        <SignMessage {...props} />
      </ErrorBoundary>
    </TxLayout>
  )
}

export default SignMessageFlow
</file>

<file path="src/components/tx-flow/flows/SignMessage/SignMessage.tsx">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import {
  Grid,
  Button,
  Box,
  Typography,
  SvgIcon,
  CardContent,
  CardActions,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Link,
} from '@mui/material'
import { useTheme } from '@mui/material/styles'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import { useContext, useEffect } from 'react'
import type { ReactElement } from 'react'
import type { RequestId } from '@safe-global/safe-apps-sdk'
import EthHashInfo from '@/components/common/EthHashInfo'
import RequiredIcon from '@/public/images/messages/required.svg'
import useSafeInfo from '@/hooks/useSafeInfo'

import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import ErrorMessage from '@/components/tx/ErrorMessage'
import useWallet from '@/hooks/wallets/useWallet'
import useSafeMessage from '@/hooks/messages/useSafeMessage'
import useOnboard, { switchWallet } from '@/hooks/wallets/useOnboard'
import { TxModalContext } from '@/components/tx-flow'
import CopyButton from '@/components/common/CopyButton'
import MsgSigners from '@/components/safe-messages/MsgSigners'
import useDecodedSafeMessage from '@/hooks/messages/useDecodedSafeMessage'
import useSyncSafeMessageSigner from '@/hooks/messages/useSyncSafeMessageSigner'
import SuccessMessage from '@/components/tx/SuccessMessage'
import useHighlightHiddenTab from '@/hooks/useHighlightHiddenTab'
import InfoBox from '@/components/safe-messages/InfoBox'
import { DecodedMsg } from '@/components/safe-messages/DecodedMsg'
import TxCard from '@/components/tx-flow/common/TxCard'
import { dispatchPreparedSignature } from '@/services/safe-messages/safeMsgNotifications'
import { trackEvent } from '@/services/analytics'
import { TX_EVENTS, TX_TYPES } from '@/services/analytics/events/transactions'
import { SafeTxContext } from '../../SafeTxProvider'
import RiskConfirmationError from '@/components/tx/SignOrExecuteForm/RiskConfirmationError'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'
import { isBlindSigningPayload, isEIP712TypedData } from '@safe-global/utils/utils/safe-messages'
import ApprovalEditor from '@/components/tx/ApprovalEditor'
import { ErrorBoundary } from '@sentry/react'
import { isWalletRejection } from '@/utils/wallets'
import { useAppSelector } from '@/store'
import { selectBlindSigning } from '@/store/settingsSlice'
import NextLink from 'next/link'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'
import MsgShareLink from '@/components/safe-messages/MsgShareLink'
import LinkIcon from '@/public/images/messages/link.svg'
import { Blockaid } from '@/components/tx/security/blockaid'
import CheckWallet from '@/components/common/CheckWallet'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import { getDomainHash, getSafeMessageMessageHash } from '@/utils/safe-hashes'
import type { SafeVersion } from '@safe-global/safe-core-sdk-types'

const createSkeletonMessage = (confirmationsRequired: number): MessageItem => {
  return {
    confirmations: [],
    confirmationsRequired,
    confirmationsSubmitted: 0,
    creationTimestamp: 0,
    message: '',
    logoUri: null,
    messageHash: '',
    modifiedTimestamp: 0,
    name: null,
    proposedBy: {
      value: '',
    },
    status: 'NEEDS_CONFIRMATION',
    type: 'MESSAGE',
  }
}

const MessageHashField = ({ label, hashValue }: { label: string; hashValue: string }) => (
  <>
    <Typography
      variant="body2"
      sx={{
        fontWeight: 700,
        mt: 2,
      }}
    >
      {label}:
    </Typography>
    <Typography data-testid="message-hash" variant="body2" component="div">
      <EthHashInfo address={hashValue} showAvatar={false} shortAddress={false} showCopyButton />
    </Typography>
  </>
)

const DialogHeader = ({ threshold }: { threshold: number }) => (
  <>
    <Box
      sx={{
        textAlign: 'center',
        mb: 2,
      }}
    >
      <SvgIcon component={RequiredIcon} viewBox="0 0 32 32" fontSize="large" />
    </Box>
    <Typography
      variant="h4"
      gutterBottom
      sx={{
        textAlign: 'center',
      }}
    >
      Confirm message
    </Typography>
    {threshold > 1 && (
      <Typography
        variant="body1"
        sx={{
          textAlign: 'center',
          mb: 2,
        }}
      >
        To sign this message, collect signatures from <b>{threshold} signers</b> of your Safe Account.
      </Typography>
    )}
  </>
)

const MessageDialogError = ({ isOwner, submitError }: { isOwner: boolean; submitError: Error | undefined }) => {
  const wallet = useWallet()
  const onboard = useOnboard()

  const errorMessage =
    !wallet || !onboard
      ? 'No wallet is connected.'
      : !isOwner
        ? "You are currently not a signer of this Safe Account and won't be able to confirm this message."
        : submitError && isWalletRejection(submitError)
          ? 'User rejected signing.'
          : submitError
            ? 'Error confirming the message. Please try again.'
            : null

  if (errorMessage) {
    return <ErrorMessage>{errorMessage}</ErrorMessage>
  }
  return null
}

const AlreadySignedByOwnerMessage = ({ hasSigned }: { hasSigned: boolean }) => {
  const onboard = useOnboard()

  const handleSwitchWallet = () => {
    if (onboard) {
      switchWallet(onboard)
    }
  }
  if (!hasSigned) {
    return null
  }
  return (
    <SuccessMessage>
      <Grid
        container
        direction="row"
        sx={{
          justifyContent: 'space-between',
        }}
      >
        <Grid item xs={7}>
          Your connected wallet has already signed this message.
        </Grid>
        <Grid item xs={4}>
          <Button variant="contained" size="small" onClick={handleSwitchWallet} fullWidth>
            Switch wallet
          </Button>
        </Grid>
      </Grid>
    </SuccessMessage>
  )
}

const BlindSigningWarning = ({
  isBlindSigningEnabled,
  isBlindSigningPayload,
}: {
  isBlindSigningEnabled: boolean
  isBlindSigningPayload: boolean
}) => {
  const router = useRouter()
  const query = router.query.safe ? { safe: router.query.safe } : undefined

  if (!isBlindSigningPayload) {
    return null
  }

  return (
    <ErrorMessage level={isBlindSigningEnabled ? 'warning' : 'error'}>
      This request involves{' '}
      <Link component={NextLink} href={{ pathname: AppRoutes.settings.security, query }}>
        blind signing
      </Link>
      , which can lead to unpredictable outcomes.
      <br />
      {isBlindSigningEnabled ? (
        'Proceed with caution.'
      ) : (
        <>
          If you wish to proceed, you must first{' '}
          <Link component={NextLink} href={{ pathname: AppRoutes.settings.security, query }}>
            enable blind signing
          </Link>
          .
        </>
      )}
    </ErrorMessage>
  )
}

const SuccessCard = ({ safeMessage, onContinue }: { safeMessage: MessageItem; onContinue: () => void }) => {
  return (
    <TxCard>
      <Typography
        variant="h4"
        gutterBottom
        sx={{
          textAlign: 'center',
        }}
      >
        Message successfully signed
      </Typography>
      <MsgSigners msg={safeMessage} showOnlyConfirmations showMissingSignatures />
      <CardActions>
        <Button variant="contained" color="primary" onClick={onContinue} disabled={!safeMessage.preparedSignature}>
          Continue
        </Button>
      </CardActions>
    </TxCard>
  )
}

type BaseProps = Pick<MessageItem, 'logoUri' | 'name' | 'message'>

export type SignMessageProps = BaseProps & {
  origin?: string
  requestId?: RequestId
}

const SignMessage = ({ message, origin, requestId }: SignMessageProps): ReactElement => {
  // Hooks & variables
  const { setTxFlow } = useContext(TxModalContext)
  const { setSafeMessage: setContextSafeMessage } = useContext(SafeTxContext)
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = useContext(TxSecurityContext)
  const { palette } = useTheme()
  const { safe } = useSafeInfo()
  const isOwner = useIsSafeOwner()
  const wallet = useWallet()
  useHighlightHiddenTab()

  const { decodedMessage, safeMessageMessage, safeMessageHash } = useDecodedSafeMessage(message, safe)
  const [safeMessage, setSafeMessage] = useSafeMessage(safeMessageHash)
  const domainHash = getDomainHash({
    chainId: safe.chainId,
    safeAddress: safe.address.value,
    safeVersion: safe.version as SafeVersion,
  })
  const messageHash = getSafeMessageMessageHash({ message: decodedMessage, safeVersion: safe.version as SafeVersion })
  const isPlainTextMessage = typeof decodedMessage === 'string'
  const decodedMessageAsString = isPlainTextMessage ? decodedMessage : JSON.stringify(decodedMessage, null, 2)
  const signedByCurrentSafe = !!safeMessage?.confirmations.some(({ owner }) => owner.value === wallet?.address)
  const hasSignature = safeMessage?.confirmations && safeMessage.confirmations.length > 0
  const isFullySigned = !!safeMessage?.preparedSignature
  const isEip712 = isEIP712TypedData(decodedMessage)
  const isBlindSigningRequest = isBlindSigningPayload(decodedMessage)
  const isBlindSigningEnabled = useAppSelector(selectBlindSigning)
  const isDisabled =
    !isOwner || signedByCurrentSafe || !safe.deployed || (!isBlindSigningEnabled && isBlindSigningRequest)

  const { onSign, submitError } = useSyncSafeMessageSigner(
    safeMessage,
    decodedMessage,
    safeMessageHash,
    requestId,
    origin,
    () => setTxFlow(undefined),
  )

  const handleSign = async () => {
    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    const updatedMessage = await onSign()

    if (updatedMessage) {
      setSafeMessage(updatedMessage)
    }

    // Track first signature as creation
    const isCreation = updatedMessage?.confirmations.length === 1
    trackEvent({ ...(isCreation ? TX_EVENTS.CREATE : TX_EVENTS.CONFIRM), label: TX_TYPES.typed_message })
  }

  const onContinue = async () => {
    if (!safeMessage) {
      return
    }
    await dispatchPreparedSignature(safeMessage, safeMessageHash, () => setTxFlow(undefined), requestId)
  }

  // Set message for redefine scan
  useEffect(() => {
    if (typeof message !== 'string') {
      setContextSafeMessage(message)
    }
  }, [message, setContextSafeMessage])

  return (
    <>
      <TxCard>
        <CardContent>
          <DialogHeader threshold={safe.threshold} />

          {isEip712 && (
            <ErrorBoundary fallback={<div>Error parsing data</div>}>
              <ApprovalEditor safeMessage={decodedMessage} />
            </ErrorBoundary>
          )}

          <BlindSigningWarning
            isBlindSigningEnabled={isBlindSigningEnabled}
            isBlindSigningPayload={isBlindSigningRequest}
          />

          <Typography
            sx={{
              fontWeight: 700,
              mt: 2,
              mb: 1,
            }}
          >
            Message: <CopyButton text={decodedMessageAsString} />
          </Typography>
          <DecodedMsg message={decodedMessage} isInModal />

          <Accordion sx={{ mt: 2 }}>
            <AccordionSummary data-testid="message-details" expandIcon={<ExpandMoreIcon />}>
              SafeMessage details
            </AccordionSummary>
            <AccordionDetails>
              <MessageHashField label="SafeMessage" hashValue={safeMessageMessage} />
              <MessageHashField label="SafeMessage hash" hashValue={safeMessageHash} />
              <MessageHashField label="Domain hash" hashValue={domainHash} />
              <MessageHashField label="Message hash" hashValue={messageHash} />
            </AccordionDetails>
          </Accordion>

          <Box sx={{ '&:not(:empty)': { mt: 2 } }}>
            <Blockaid />
          </Box>
        </CardContent>
      </TxCard>
      {isFullySigned ? (
        <SuccessCard onContinue={onContinue} safeMessage={safeMessage} />
      ) : (
        <>
          <TxCard>
            <AlreadySignedByOwnerMessage hasSigned={signedByCurrentSafe} />

            <InfoBox
              title="Collect all the confirmations"
              message={
                requestId && !hasSignature
                  ? 'Please keep this modal open until all signers confirm this message. Closing the modal will abort the signing request.'
                  : 'The signature will be submitted to the requesting app when the message is fully signed.'
              }
            >
              <MsgSigners
                msg={safeMessage ?? createSkeletonMessage(safe.threshold)}
                showOnlyConfirmations
                showMissingSignatures
                backgroundColor={palette.info.background}
              />
            </InfoBox>

            {hasSignature && (
              <InfoBox
                title="Share the link with other owners"
                message={
                  <>
                    <Typography
                      sx={{
                        mb: 2,
                      }}
                    >
                      The owners will receive a notification about signing the message. You can also share the link with
                      them to speed up the process.
                    </Typography>
                    <MsgShareLink safeMessageHash={safeMessageHash} button />
                  </>
                }
                icon={LinkIcon}
              />
            )}

            <NetworkWarning />

            <MessageDialogError isOwner={isOwner} submitError={submitError} />

            <RiskConfirmationError />

            {!safe.deployed && <ErrorMessage>Your Safe Account is not activated yet.</ErrorMessage>}
          </TxCard>
          <TxCard>
            <CardActions>
              <CheckWallet checkNetwork={!isDisabled}>
                {(isOk) => (
                  <Button variant="contained" color="primary" onClick={handleSign} disabled={!isOk || isDisabled}>
                    Sign
                  </Button>
                )}
              </CheckWallet>
            </CardActions>
          </TxCard>
        </>
      )}
    </>
  )
}

export default SignMessage
</file>

<file path="src/components/tx-flow/flows/SignMessageOnChain/ConfirmSignMessageOnChainDetails.tsx">
import useWallet from '@/hooks/wallets/useWallet'
import type { ReactElement } from 'react'
import { useContext } from 'react'
import { type RequestId } from '@safe-global/safe-apps-sdk'
import { dispatchSafeAppsTx } from '@/services/tx/tx-sender'
import useOnboard from '@/hooks/wallets/useOnboard'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import type { SignOrExecuteProps } from '@/components/tx/SignOrExecuteForm/SignOrExecuteFormV2'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'

export const ConfirmSignMessageOnChainDetails = ({
  requestId,
  ...props
}: SignOrExecuteProps & { requestId: RequestId }): ReactElement => {
  const onboard = useOnboard()
  const wallet = useWallet()
  const { safeTx, setSafeTxError } = useContext(SafeTxContext)

  const handleSubmit = async () => {
    if (!safeTx || !onboard || !wallet) return

    try {
      await dispatchSafeAppsTx(safeTx, requestId, wallet.provider)
    } catch (error) {
      setSafeTxError(asError(error))
    }
  }

  return <ConfirmTxDetails {...props} onSubmit={handleSubmit} />
}
</file>

<file path="src/components/tx-flow/flows/SignMessageOnChain/index.tsx">
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import { AppTitle } from '@/components/tx-flow/flows/SignMessage'
import ReviewSignMessageOnChain, {
  type SignMessageOnChainProps,
} from '@/components/tx-flow/flows/SignMessageOnChain/ReviewSignMessageOnChain'
import { useMemo } from 'react'
import useTxStepper from '../../useTxStepper'
import { ConfirmSignMessageOnChainDetails } from './ConfirmSignMessageOnChainDetails'
import { TxFlowType } from '@/services/analytics'

const SignMessageOnChainFlow = ({ props }: { props: Omit<SignMessageOnChainProps, 'onSubmit'> }) => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.SIGN_MESSAGE_ON_CHAIN)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Confirm message' },
        content: <ReviewSignMessageOnChain {...props} key={0} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm message details', fixedNonce: true },
        content: <ConfirmSignMessageOnChainDetails requestId={props.requestId} key={1} />,
      },
    ],
    [nextStep, props],
  )

  return (
    <TxLayout
      subtitle={<AppTitle name={props.app?.name} logoUri={props.app?.iconUrl} />}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default SignMessageOnChainFlow
</file>

<file path="src/components/tx-flow/flows/SignMessageOnChain/ReviewSignMessageOnChain.tsx">
import type { ReactElement } from 'react'
import { useContext, useEffect, useState } from 'react'
import { useMemo } from 'react'
import { hashMessage, TypedDataEncoder } from 'ethers'
import { Box } from '@mui/system'
import { Typography, SvgIcon } from '@mui/material'
import WarningIcon from '@/public/images/notifications/warning.svg'
import { type EIP712TypedData, Methods, type RequestId } from '@safe-global/safe-apps-sdk'
import { OperationType } from '@safe-global/safe-core-sdk-types'

import SendFromBlock from '@/components/tx/SendFromBlock'
import { InfoDetails } from '@/components/transactions/InfoDetails'
import EthHashInfo from '@/components/common/EthHashInfo'
import { getReadOnlySignMessageLibContract } from '@/services/contracts/safeContracts'
import { DecodedMsg } from '@/components/safe-messages/DecodedMsg'
import CopyButton from '@/components/common/CopyButton'
import { getDecodedMessage } from '@/components/safe-apps/utils'
import { createTx } from '@/services/tx/tx-sender'
import useSafeInfo from '@/hooks/useSafeInfo'
import useHighlightHiddenTab from '@/hooks/useHighlightHiddenTab'
import { type SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { isEIP712TypedData } from '@safe-global/utils/utils/safe-messages'
import ApprovalEditor from '@/components/tx/ApprovalEditor'
import { ErrorBoundary } from '@sentry/react'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { HexEncodedData } from '@/components/transactions/HexEncodedData'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export type SignMessageOnChainProps = {
  app?: SafeAppData
  requestId: RequestId
  message: string | EIP712TypedData
  method: Methods.signMessage | Methods.signTypedMessage
  onSubmit: () => void
}

const ReviewSignMessageOnChain = ({ message, method, onSubmit }: SignMessageOnChainProps): ReactElement => {
  const { safe } = useSafeInfo()
  const { safeTx, setSafeTx, setSafeTxError } = useContext(SafeTxContext)
  useHighlightHiddenTab()

  const isTextMessage = method === Methods.signMessage && typeof message === 'string'
  const isTypedMessage = method === Methods.signTypedMessage && isEIP712TypedData(message)

  const [readOnlySignMessageLibContract] = useAsync(
    async () => getReadOnlySignMessageLibContract(safe.version),
    [safe.version],
  )

  const [signMessageAddress, setSignMessageAddress] = useState<string>('')

  useEffect(() => {
    if (!readOnlySignMessageLibContract) return
    readOnlySignMessageLibContract.getAddress().then(setSignMessageAddress)
  }, [readOnlySignMessageLibContract])

  const [decodedMessage, readableMessage] = useMemo(() => {
    if (isTextMessage) {
      const decoded = getDecodedMessage(message)
      return [decoded, decoded]
    } else if (isTypedMessage) {
      return [message, JSON.stringify(message, null, 2)]
    }
    return []
  }, [isTextMessage, isTypedMessage, message])

  useEffect(() => {
    let txData

    if (!readOnlySignMessageLibContract) return

    if (isTextMessage) {
      txData = readOnlySignMessageLibContract.encode('signMessage', [hashMessage(getDecodedMessage(message))])
    } else if (isTypedMessage) {
      const typesCopy = { ...message.types }

      // We need to remove the EIP712Domain type from the types object
      // Because it's a part of the JSON-RPC payload, but for the `.hash` in ethers.js
      // The types are not allowed to be recursive, so ever type must either be used by another type, or be
      // the primary type. And there must only be one type that is not used by any other type.
      delete typesCopy.EIP712Domain
      txData = readOnlySignMessageLibContract.encode('signMessage', [
        // @ts-ignore
        TypedDataEncoder.hash(message.domain, typesCopy, message.message),
      ])
    }

    const params = {
      to: signMessageAddress,
      value: '0',
      data: txData ?? '0x',
      operation: OperationType.DelegateCall,
    }
    createTx(params).then(setSafeTx).catch(setSafeTxError)
  }, [
    isTextMessage,
    isTypedMessage,
    message,
    readOnlySignMessageLibContract,
    setSafeTx,
    setSafeTxError,
    signMessageAddress,
  ])

  return (
    <ReviewTransaction onSubmit={onSubmit}>
      <SendFromBlock />

      <InfoDetails title="Interact with SignMessageLib">
        <EthHashInfo address={signMessageAddress} shortAddress={false} showCopyButton hasExplorer />
      </InfoDetails>

      {isEIP712TypedData(decodedMessage) && (
        <ErrorBoundary fallback={<div>Error parsing data</div>}>
          <ApprovalEditor safeMessage={decodedMessage} />
        </ErrorBoundary>
      )}

      {safeTx && (
        <Box pb={1}>
          <HexEncodedData title="Data:" hexData={safeTx.data.data} />
        </Box>
      )}

      <Typography my={1}>
        <b>Signing method:</b> <code>{method}</code>
      </Typography>

      <Typography my={2}>
        <b>Signing message:</b> {readableMessage && <CopyButton text={readableMessage} />}
      </Typography>
      <DecodedMsg message={decodedMessage} isInModal />

      <Box display="flex" alignItems="center" my={2}>
        <SvgIcon component={WarningIcon} inheritViewBox color="warning" />
        <Typography ml={1}>
          Signing a message with your Safe Account requires a transaction on the blockchain
        </Typography>
      </Box>
    </ReviewTransaction>
  )
}

export default ReviewSignMessageOnChain
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/statuses/DefaultStatus.tsx">
import { Box, Typography } from '@mui/material'
import classNames from 'classnames'
import css from '@/components/tx-flow/flows/SuccessScreen/styles.module.css'
import { isTimeoutError } from '@/utils/ethers-utils'

const TRANSACTION_FAILED = 'Transaction failed'
const NESTED_SAFE_SUCCESSFUL = 'Nested Safe was created'
const TRANSACTION_SUCCESSFUL = 'Transaction was successful'

type Props = {
  error: undefined | Error
  willDeploySafe: boolean
}
export const DefaultStatus = ({ error, willDeploySafe: isCreatingSafe }: Props) => (
  <Box px={3} mt={3}>
    <Typography data-testid="transaction-status" variant="h6" mt={2} fontWeight={700}>
      {error ? TRANSACTION_FAILED : !isCreatingSafe ? TRANSACTION_SUCCESSFUL : NESTED_SAFE_SUCCESSFUL}
    </Typography>
    {error && (
      <Box className={classNames(css.instructions, error ? css.errorBg : css.infoBg)}>
        <Typography variant="body2">
          {error ? (isTimeoutError(error) ? 'Transaction timed out' : error.message) : ''}
        </Typography>
      </Box>
    )}
  </Box>
)
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/statuses/IndexingStatus.tsx">
import { Box, Typography } from '@mui/material'
import classNames from 'classnames'
import css from '@/components/tx-flow/flows/SuccessScreen/styles.module.css'

export const IndexingStatus = ({ willDeploySafe: isCreatingSafe }: { willDeploySafe: boolean }) => (
  <Box px={3} mt={3}>
    <Typography data-testid="transaction-status" variant="h6" mt={2} fontWeight={700}>
      {!isCreatingSafe ? 'Transaction' : 'Nested Safe'} was processed
    </Typography>
    <Box className={classNames(css.instructions, css.infoBg)}>
      <Typography variant="body2"> It is now being indexed.</Typography>
    </Box>
  </Box>
)
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/statuses/ProcessingStatus.tsx">
// Extract status handling into separate components
import { Box, Typography } from '@mui/material'
import { SpeedUpMonitor } from '@/features/speedup/components/SpeedUpMonitor'
import { PendingStatus, type PendingTx } from '@/store/pendingTxsSlice'

type Props = {
  txId: string
  pendingTx: PendingTx
  willDeploySafe: boolean
}
export const ProcessingStatus = ({ txId, pendingTx, willDeploySafe: isCreatingSafe }: Props) => (
  <Box px={3} mt={3}>
    <Typography data-testid="transaction-status" variant="h6" mt={2} fontWeight={700}>
      {!isCreatingSafe ? 'Transaction is now processing' : 'Nested Safe is now being created'}
    </Typography>
    <Typography variant="body2" mb={3}>
      {!isCreatingSafe ? 'The transaction' : 'Your Nested Safe'} was confirmed and is now being processed.
    </Typography>
    <Box>
      {pendingTx.status === PendingStatus.PROCESSING && (
        <SpeedUpMonitor txId={txId} pendingTx={pendingTx} modalTrigger="alertBox" />
      )}
    </Box>
  </Box>
)
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/index.tsx">
import StatusStepper from './StatusStepper'
import { Button, Container, Divider, Paper } from '@mui/material'
import classnames from 'classnames'
import Link from 'next/link'
import css from './styles.module.css'
import { useAppSelector } from '@/store'
import { PendingStatus, selectPendingTxById } from '@/store/pendingTxsSlice'
import { useCallback, useContext, useEffect, useState } from 'react'
import { useCurrentChain } from '@/hooks/useChains'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'
import useSafeInfo from '@/hooks/useSafeInfo'
import { TxModalContext } from '../..'
import LoadingSpinner, { SpinnerStatus } from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner'
import { ProcessingStatus } from '@/components/tx-flow/flows/SuccessScreen/statuses/ProcessingStatus'
import { IndexingStatus } from '@/components/tx-flow/flows/SuccessScreen/statuses/IndexingStatus'
import { DefaultStatus } from '@/components/tx-flow/flows/SuccessScreen/statuses/DefaultStatus'
import { isSwapTransferOrderTxInfo } from '@/utils/transaction-guards'
import { getTxLink } from '@/utils/tx-link'
import useTxDetails from '@/hooks/useTxDetails'
import { usePredictSafeAddressFromTxDetails } from '@/hooks/usePredictSafeAddressFromTxDetails'
import { AppRoutes } from '@/config/routes'
import { NESTED_SAFE_EVENTS, NESTED_SAFE_LABELS } from '@/services/analytics/events/nested-safes'
import Track from '@/components/common/Track'

interface Props {
  /** The ID assigned to the transaction in the client-gateway */
  txId?: string
  /** For module transaction, pass the transaction hash while the `txId` is not yet available */
  txHash?: string
}

const SuccessScreen = ({ txId, txHash }: Props) => {
  const [localTxHash, setLocalTxHash] = useState<string | undefined>(txHash)
  const [error, setError] = useState<Error>()
  const { setTxFlow } = useContext(TxModalContext)
  const chain = useCurrentChain()
  const pendingTx = useAppSelector((state) => (txId ? selectPendingTxById(state, txId) : undefined))
  const { safeAddress } = useSafeInfo()
  const status = !txId && txHash ? PendingStatus.INDEXING : pendingTx?.status
  const pendingTxHash = pendingTx && 'txHash' in pendingTx ? pendingTx.txHash : undefined
  const txLink = chain && txId && getTxLink(txId, chain, safeAddress)
  const [txDetails] = useTxDetails(txId)
  const isSwapOrder = txDetails && isSwapTransferOrderTxInfo(txDetails.txInfo)
  const [predictedSafeAddress] = usePredictSafeAddressFromTxDetails(txDetails)

  useEffect(() => {
    if (!pendingTxHash) return

    setLocalTxHash(pendingTxHash)
  }, [pendingTxHash])

  useEffect(() => {
    const unsubFns: Array<() => void> = ([TxEvent.FAILED, TxEvent.REVERTED] as const).map((event) =>
      txSubscribe(event, (detail) => {
        if (detail.txId === txId && pendingTx) setError(detail.error)
      }),
    )

    return () => unsubFns.forEach((unsubscribe) => unsubscribe())
  }, [txId, pendingTx])

  const onClose = useCallback(() => {
    setTxFlow(undefined)
  }, [setTxFlow])

  const isSuccess = status === undefined
  const spinnerStatus = error ? SpinnerStatus.ERROR : isSuccess ? SpinnerStatus.SUCCESS : SpinnerStatus.PROCESSING

  let StatusComponent
  switch (status) {
    case PendingStatus.PROCESSING:
    case PendingStatus.RELAYING:
      // status can only have these values if txId & pendingTx are defined
      StatusComponent = <ProcessingStatus txId={txId!} pendingTx={pendingTx!} willDeploySafe={!!predictedSafeAddress} />
      break
    case PendingStatus.INDEXING:
      StatusComponent = <IndexingStatus willDeploySafe={!!predictedSafeAddress} />
      break
    default:
      StatusComponent = <DefaultStatus error={error} willDeploySafe={!!predictedSafeAddress} />
  }

  return (
    <Container
      component={Paper}
      disableGutters
      sx={{
        textAlign: 'center',
        maxWidth: `${900 - 75}px`, // md={11}
      }}
      maxWidth={false}
    >
      <div className={css.row}>
        <LoadingSpinner status={spinnerStatus} />
        {StatusComponent}
      </div>

      {!error && (
        <>
          <Divider />
          <div className={css.row}>
            <StatusStepper status={status} txHash={localTxHash} />
          </div>
        </>
      )}

      <Divider />

      <div className={classnames(css.row, css.buttons)}>
        {isSwapOrder && (
          <Button data-testid="finish-transaction-btn" variant="outlined" size="small" onClick={onClose}>
            Back to swaps
          </Button>
        )}

        {txLink && (
          <Link {...txLink} passHref target="_blank" rel="noreferrer" legacyBehavior>
            <Button
              data-testid="view-transaction-btn"
              variant={isSwapOrder ? 'contained' : 'outlined'}
              size="small"
              onClick={onClose}
            >
              View transaction
            </Button>
          </Link>
        )}

        {!isSwapOrder &&
          (predictedSafeAddress ? (
            <Track {...NESTED_SAFE_EVENTS.OPEN_NESTED_SAFE} label={NESTED_SAFE_LABELS.success_screen}>
              <Link
                href={{ pathname: AppRoutes.home, query: { safe: `${chain?.shortName}:${predictedSafeAddress}` } }}
                passHref
                legacyBehavior
              >
                <Button
                  data-testid="open-nested-safe-btn"
                  variant="contained"
                  size="small"
                  onClick={onClose}
                  disabled={!isSuccess}
                >
                  Go to Nested Safe
                </Button>
              </Link>
            </Track>
          ) : (
            <Button data-testid="finish-transaction-btn" variant="contained" size="small" onClick={onClose}>
              Finish
            </Button>
          ))}
      </div>
    </Container>
  )
}

export default SuccessScreen
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/StatusMessage.tsx">
import { isTimeoutError } from '@/utils/ethers-utils'
import classNames from 'classnames'
import { Box, Typography } from '@mui/material'
import LoadingSpinner, { SpinnerStatus } from '@/components/new-safe/create/steps/StatusStep/LoadingSpinner'
import { PendingStatus } from '@/store/pendingTxsSlice'
import css from './styles.module.css'

const getStep = (status: PendingStatus, error?: Error) => {
  switch (status) {
    case PendingStatus.PROCESSING:
    case PendingStatus.RELAYING:
      return {
        description: 'Transaction is now processing',
        instruction: 'The transaction was confirmed and is now being processed.',
        classNames: '',
      }
    case PendingStatus.INDEXING:
      return {
        description: 'Transaction was processed',
        instruction: 'It is now being indexed.',
        classNames: classNames(css.instructions, error ? css.errorBg : css.infoBg),
      }
    default:
      return {
        description: error ? 'Transaction failed' : 'Transaction was successful',
        instruction: error ? (isTimeoutError(error) ? 'Transaction timed out' : error.message) : '',
        classNames: classNames(css.instructions, error ? css.errorBg : css.infoBg),
      }
  }
}

const StatusMessage = ({ status, error }: { status: PendingStatus; error?: Error }) => {
  const stepInfo = getStep(status, error)

  const isSuccess = status === undefined
  const spinnerStatus = error ? SpinnerStatus.ERROR : isSuccess ? SpinnerStatus.SUCCESS : SpinnerStatus.PROCESSING

  return (
    <>
      <Box px={3} mt={3}>
        <LoadingSpinner status={spinnerStatus} />
        <Typography data-testid="transaction-status" variant="h6" mt={2} fontWeight={700}>
          {stepInfo.description}
        </Typography>
      </Box>
      {stepInfo.instruction && (
        <Box className={stepInfo.classNames}>
          <Typography variant="body2">{stepInfo.instruction}</Typography>
        </Box>
      )}
    </>
  )
}

export default StatusMessage
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/StatusStepper.tsx">
import { Box, Step, StepConnector, Stepper, Typography } from '@mui/material'
import css from '@/components/new-safe/create/steps/StatusStep/styles.module.css'
import EthHashInfo from '@/components/common/EthHashInfo'
import StatusStep from '@/components/new-safe/create/steps/StatusStep/StatusStep'
import useSafeInfo from '@/hooks/useSafeInfo'
import { PendingStatus } from '@/store/pendingTxsSlice'

const StatusStepper = ({ status, txHash }: { status?: PendingStatus; txHash?: string }) => {
  const { safeAddress } = useSafeInfo()

  const isProcessing = status === PendingStatus.PROCESSING || status === PendingStatus.INDEXING || status === undefined
  const isProcessed = status === PendingStatus.INDEXING || status === undefined
  const isSuccess = status === undefined

  return (
    <Stepper orientation="vertical" nonLinear connector={<StepConnector className={css.connector} />}>
      <Step>
        <StatusStep isLoading={!isProcessing} safeAddress={safeAddress}>
          <Box>
            <Typography variant="body2" fontWeight="700">
              Your transaction
            </Typography>
            {txHash && (
              <EthHashInfo
                address={txHash}
                hasExplorer
                showCopyButton
                showName={false}
                shortAddress={false}
                showAvatar={false}
              />
            )}
          </Box>
        </StatusStep>
      </Step>
      <Step>
        <StatusStep isLoading={!isProcessed} safeAddress={safeAddress}>
          <Box>
            <Typography variant="body2" fontWeight="700">
              {isProcessed ? 'Processed' : 'Processing'}
            </Typography>
          </Box>
        </StatusStep>
      </Step>
      <Step>
        <StatusStep isLoading={!isSuccess} safeAddress={safeAddress}>
          <Typography variant="body2" fontWeight="700">
            {isSuccess ? 'Indexed' : 'Indexing'}
          </Typography>
        </StatusStep>
      </Step>
      <Step>
        <StatusStep isLoading={!isSuccess} safeAddress={safeAddress}>
          <Typography variant="body2" fontWeight="700">
            Transaction is executed
          </Typography>
        </StatusStep>
      </Step>
    </Stepper>
  )
}

export default StatusStepper
</file>

<file path="src/components/tx-flow/flows/SuccessScreen/styles.module.css">
.row {
  width: 100%;
  padding: var(--space-4) var(--space-7);
}

@media (max-width: 599.95px) {
  .row {
    padding: var(--space-2);
  }
}

.buttons {
  display: flex;
  justify-content: center;
  gap: var(--space-2);
  font-size: 14px;
}

.instructions {
  padding: var(--space-3);
  margin-top: var(--space-4);
  border-style: solid;
  border-width: 1px;
  border-radius: 6px;
}

.errorBg {
  background-color: var(--color-error-background);
  border-color: var(--color-error-light);
}

.infoBg {
  background-color: var(--color-info-background);
  border-color: var(--color-info-light);
}
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/CSVAirdropAppModal/index.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import { AppRoutes } from '@/config/routes'
import CSVAirdropLogo from '@/public/images/apps/csv-airdrop-app-logo.svg'
import { Button, DialogActions, DialogContent, Grid, Typography } from '@mui/material'
import Link from 'next/link'
import { useRouter } from 'next/router'
import type { ReactElement } from 'react'

const CSVAirdropAppModal = ({ onClose, appUrl }: { onClose: () => void; appUrl?: string }): ReactElement => {
  const router = useRouter()

  return (
    <ModalDialog
      data-testid="csvairdrop-dialog"
      open
      onClose={onClose}
      dialogTitle="Limit reached"
      hideChainIndicator
      maxWidth="xs"
    >
      <DialogContent sx={{ mt: 3, textAlign: 'center' }}>
        <Grid>
          <CSVAirdropLogo />
          <Typography fontWeight="bold" sx={{ mt: 2, mb: 2 }}>
            Use CSV Airdrop
          </Typography>
          <Typography variant="body2">
            You&apos;ve reached the limit of 5 recipients. To add more use CSV Airdrop, where you can simply upload you
            CSV file and send to endless number of recipients.
          </Typography>
        </Grid>
      </DialogContent>
      {appUrl && (
        <DialogActions style={{ textAlign: 'center', display: 'block' }}>
          <Link
            href={{
              pathname: AppRoutes.apps.open,
              query: {
                safe: router.query.safe,
                appUrl,
              },
            }}
            passHref
          >
            <Button variant="contained" data-testid="open-app-btn">
              Open CSV Airdrop
            </Button>
          </Link>
        </DialogActions>
      )}
    </ModalDialog>
  )
}

export default CSVAirdropAppModal
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/RecipientRow/index.tsx">
import AddressBookInput from '@/components/common/AddressBookInput'
import TokenAmountInput from '@/components/common/TokenAmountInput'
import { useVisibleBalances } from '@/hooks/useVisibleBalances'
import DeleteIcon from '@/public/images/common/delete.svg'
import { Box, Button, FormControl, Stack, SvgIcon } from '@mui/material'
import { get, useFormContext } from 'react-hook-form'
import type { FieldArrayPath, FieldPath } from 'react-hook-form'
import type { MultiTokenTransferParams, TokenTransferParams } from '..'
import { MultiTokenTransferFields, TokenTransferFields, TokenTransferType } from '..'
import { useTokenAmount } from '../utils'
import { useHasPermission } from '@/permissions/hooks/useHasPermission'
import { Permission } from '@/permissions/config'
import { useCallback, useContext, useEffect, useMemo } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import SpendingLimitRow from '../SpendingLimitRow'
import { useSelector } from 'react-redux'
import { selectSpendingLimits } from '@/store/spendingLimitsSlice'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'

const getFieldName = (
  field: keyof TokenTransferParams,
  { name, index }: RecipientRowProps['fieldArray'],
): FieldPath<MultiTokenTransferParams> => `${name}.${index}.${field}`

type RecipientRowProps = {
  disableSpendingLimit: boolean
  fieldArray: { name: FieldArrayPath<MultiTokenTransferParams>; index: number }
  removable?: boolean
  remove?: (index: number) => void
}

export const RecipientRow = ({ fieldArray, removable = true, remove, disableSpendingLimit }: RecipientRowProps) => {
  const { balances } = useVisibleBalances()
  const spendingLimits = useSelector(selectSpendingLimits)

  const {
    formState: { errors },
    trigger,
    watch,
  } = useFormContext<MultiTokenTransferParams>()

  const { setNonceNeeded } = useContext(SafeTxContext)

  const recipientFieldName = getFieldName(TokenTransferFields.recipient, fieldArray)

  const recipients = watch(MultiTokenTransferFields.recipients)
  const type = watch(MultiTokenTransferFields.type)
  const recipient = watch(recipientFieldName)
  const tokenAddress = watch(getFieldName(TokenTransferFields.tokenAddress, fieldArray))

  const selectedToken = balances.items.find((item) => sameAddress(item.tokenInfo.address, tokenAddress))

  const { totalAmount, spendingLimitAmount } = useTokenAmount(selectedToken)

  const isAddressValid = !!recipient && !get(errors, recipientFieldName)

  const canCreateSpendingLimitTxWithToken = useHasPermission(Permission.CreateSpendingLimitTransaction, {
    tokenAddress,
  })

  const isSpendingLimitType = type === TokenTransferType.spendingLimit

  const spendingLimitBalances = useMemo(
    () =>
      balances.items.filter(({ tokenInfo }) =>
        spendingLimits.find((sl) => sameAddress(sl.token.address, tokenInfo.address)),
      ),
    [balances.items, spendingLimits],
  )

  const maxAmount = isSpendingLimitType && totalAmount > spendingLimitAmount ? spendingLimitAmount : totalAmount

  const deps = useMemo(
    () =>
      recipients.map((_, index) =>
        getFieldName(TokenTransferFields.amount, { name: MultiTokenTransferFields.recipients, index }),
      ),
    [recipients],
  )

  const onRemove = useCallback(() => {
    remove?.(fieldArray.index)
    trigger(deps)
  }, [remove, fieldArray.index, trigger, deps])

  useEffect(() => {
    setNonceNeeded(!isSpendingLimitType || spendingLimitAmount === 0n)
  }, [setNonceNeeded, isSpendingLimitType, spendingLimitAmount])

  return (
    <>
      <Stack spacing={1}>
        <Stack spacing={2}>
          <FormControl fullWidth>
            <AddressBookInput name={recipientFieldName} canAdd={isAddressValid} />
          </FormControl>

          <FormControl fullWidth>
            <TokenAmountInput
              fieldArray={fieldArray}
              balances={isSpendingLimitType ? spendingLimitBalances : balances.items}
              selectedToken={selectedToken}
              maxAmount={maxAmount}
              deps={deps}
            />
          </FormControl>

          {!disableSpendingLimit && canCreateSpendingLimitTxWithToken && (
            <FormControl fullWidth>
              <SpendingLimitRow availableAmount={spendingLimitAmount} selectedToken={selectedToken?.tokenInfo} />
            </FormControl>
          )}
        </Stack>

        {removable && (
          <Box>
            <Track {...MODALS_EVENTS.REMOVE_RECIPIENT}>
              <Button
                data-testid="remove-recipient-btn"
                onClick={onRemove}
                aria-label="Remove recipient"
                variant="text"
                startIcon={<SvgIcon component={DeleteIcon} inheritViewBox fontSize="small" />}
                size="compact"
              >
                Remove recipient
              </Button>
            </Track>
          </Box>
        )}
      </Stack>
    </>
  )
}

export default RecipientRow
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/SpendingLimitRow/index.tsx">
import { FormControl, FormControlLabel, InputLabel, Radio, RadioGroup, SvgIcon, Tooltip } from '@mui/material'
import { Controller, useFormContext } from 'react-hook-form'
import classNames from 'classnames'
import { safeFormatUnits } from '@safe-global/utils/utils/formatters'
import type { TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { MultiTransfersFields, TokenTransferType } from '@/components/tx-flow/flows/TokenTransfer'
import InfoIcon from '@/public/images/notifications/info.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle } from '@/config/constants'

import css from './styles.module.css'
import { TokenAmountFields } from '@/components/common/TokenAmountInput'
import { useContext, useEffect } from 'react'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useHasPermission } from '@/permissions/hooks/useHasPermission'
import { Permission } from '@/permissions/config'

const SpendingLimitRow = ({
  availableAmount,
  selectedToken,
}: {
  availableAmount: bigint
  selectedToken: TokenInfo | undefined
}) => {
  const { control, trigger, resetField } = useFormContext()
  const canCreateStandardTx = useHasPermission(Permission.CreateTransaction)
  const canCreateSpendingLimitTx = useHasPermission(Permission.CreateSpendingLimitTransaction, {
    tokenAddress: selectedToken?.address,
  })
  const { setNonceNeeded } = useContext(SafeTxContext)

  const formattedAmount = safeFormatUnits(availableAmount, selectedToken?.decimals)

  useEffect(() => {
    return () => {
      // reset the field value to default when the component is unmounted
      resetField(MultiTransfersFields.type)
    }
  }, [resetField])

  return (
    <FormControl>
      <InputLabel shrink required sx={{ backgroundColor: 'background.paper', px: '6px', mx: '-6px' }}>
        Send as
      </InputLabel>
      <Controller
        rules={{ required: true }}
        control={control}
        name={MultiTransfersFields.type}
        render={({ field: { onChange, ...field } }) => (
          <RadioGroup
            row
            onChange={(e) => {
              onChange(e)

              setNonceNeeded(e.target.value === TokenTransferType.multiSig)

              // Validate only after the field is changed
              setTimeout(() => {
                trigger(TokenAmountFields.amount)
              }, 10)
            }}
            {...field}
            defaultValue={TokenTransferType.multiSig}
            className={css.group}
          >
            {canCreateStandardTx && (
              <FormControlLabel
                data-testid="standard-tx"
                value={TokenTransferType.multiSig}
                label={
                  <>
                    Standard transaction
                    <Tooltip
                      title={
                        <>
                          A standard transaction requires the signatures of other signers before the specified funds can
                          be transferred.&nbsp;
                          <ExternalLink
                            href={HelpCenterArticle.SPENDING_LIMITS}
                            title="Learn more about spending limits"
                          >
                            Learn more about spending limits
                          </ExternalLink>
                          .
                        </>
                      }
                      arrow
                      placement="top"
                    >
                      <span>
                        <SvgIcon
                          component={InfoIcon}
                          inheritViewBox
                          color="border"
                          fontSize="small"
                          sx={{
                            verticalAlign: 'middle',
                            ml: 0.5,
                          }}
                        />
                      </span>
                    </Tooltip>
                  </>
                }
                control={<Radio />}
                componentsProps={{ typography: { variant: 'body2' } }}
                className={css.label}
              />
            )}
            {canCreateSpendingLimitTx && (
              <FormControlLabel
                data-testid="spending-limit-tx"
                value={TokenTransferType.spendingLimit}
                label={
                  <>
                    Spending limit <b>{`(${formattedAmount} ${selectedToken?.symbol})`}</b>
                    <Tooltip
                      title={
                        <>
                          A spending limit transaction allows you to transfer the specified funds without the need to
                          collect the signatures of other signers.&nbsp;
                          <ExternalLink
                            href={HelpCenterArticle.SPENDING_LIMITS}
                            title="Learn more about spending limits"
                          >
                            Learn more about spending limits
                          </ExternalLink>
                          .
                        </>
                      }
                      arrow
                      placement="top"
                    >
                      <span>
                        <SvgIcon
                          component={InfoIcon}
                          inheritViewBox
                          color="border"
                          fontSize="small"
                          sx={{
                            verticalAlign: 'middle',
                            ml: 0.5,
                          }}
                        />
                      </span>
                    </Tooltip>
                  </>
                }
                control={<Radio />}
                componentsProps={{ typography: { variant: 'body2' } }}
                className={classNames(css.label, { [css.spendingLimit]: canCreateStandardTx })}
              />
            )}
          </RadioGroup>
        )}
      />
    </FormControl>
  )
}

export default SpendingLimitRow
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/SpendingLimitRow/styles.module.css">
.group {
  border: 1px solid var(--color-border-main);
  border-radius: 4px;
  display: flex;
}

.label {
  margin: 0;
  padding: 12px 3px;
  flex: 1;
}

.spendingLimit {
  border-left: 1px solid var(--color-border-main);
}
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/CreateTokenTransfer.tsx">
import { useVisibleTokens } from '@/components/tx-flow/flows/TokenTransfer/utils'
import { type ReactElement, useContext, useEffect, useMemo, useState } from 'react'
import { type TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { FormProvider, useFieldArray, useForm } from 'react-hook-form'
import {
  Alert,
  AlertTitle,
  Box,
  Button,
  CardActions,
  Divider,
  Grid,
  Link,
  Stack,
  SvgIcon,
  Typography,
} from '@mui/material'
import TokenIcon from '@/components/common/TokenIcon'
import AddIcon from '@/public/images/common/add.svg'
import {
  type MultiTokenTransferParams,
  TokenTransferFields,
  MultiTokenTransferFields,
  TokenTransferType,
  MultiTransfersFields,
} from '.'
import TxCard from '../../common/TxCard'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import commonCss from '@/components/tx-flow/common/styles.module.css'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useHasPermission } from '@/permissions/hooks/useHasPermission'
import { Permission } from '@/permissions/config'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import RecipientRow from './RecipientRow'
import { SafeAppsName } from '@/config/constants'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'
import CSVAirdropAppModal from './CSVAirdropAppModal'
import { InsufficientFundsValidationError } from '@/components/common/TokenAmountInput'
import { useHasFeature } from '@/hooks/useChains'
import Track from '@/components/common/Track'
import { MODALS_EVENTS } from '@/services/analytics'
import { FEATURES } from '@safe-global/utils/utils/chains'
import { TxFlowContext, type TxFlowContextType } from '../../TxFlowProvider'

export const AutocompleteItem = (item: { tokenInfo: TokenInfo; balance: string }): ReactElement => (
  <Grid
    container
    sx={{
      alignItems: 'center',
      gap: 1,
    }}
  >
    <TokenIcon logoUri={item.tokenInfo.logoUri} key={item.tokenInfo.address} tokenSymbol={item.tokenInfo.symbol} />

    <Grid item xs data-testid="token-item">
      <Typography
        variant="body2"
        sx={{
          whiteSpace: 'normal',
        }}
      >
        {item.tokenInfo.name}
      </Typography>

      <Typography variant="caption" component="p">
        {formatVisualAmount(item.balance, item.tokenInfo.decimals)} {item.tokenInfo.symbol}
      </Typography>
    </Grid>
  </Grid>
)

const MAX_RECIPIENTS = 5

export type CreateTokenTransferProps = {
  txNonce?: number
}

export const CreateTokenTransfer = ({ txNonce }: CreateTokenTransferProps): ReactElement => {
  const disableSpendingLimit = txNonce !== undefined
  const [csvAirdropModalOpen, setCsvAirdropModalOpen] = useState<boolean>(false)
  const [maxRecipientsInfo, setMaxRecipientsInfo] = useState<boolean>(false)
  const canCreateStandardTx = useHasPermission(Permission.CreateTransaction)
  const canCreateSpendingLimitTx = useHasPermission(Permission.CreateSpendingLimitTransaction)
  const balancesItems = useVisibleTokens()
  const { setNonce } = useContext(SafeTxContext)
  const [safeApps] = useRemoteSafeApps({ name: SafeAppsName.CSV })
  const isMassPayoutsEnabled = useHasFeature(FEATURES.MASS_PAYOUTS)
  const { onNext, data } = useContext(TxFlowContext) as TxFlowContextType<MultiTokenTransferParams>

  useEffect(() => {
    if (txNonce !== undefined) {
      setNonce(txNonce)
    }
  }, [setNonce, txNonce])

  const formMethods = useForm<MultiTokenTransferParams>({
    defaultValues: {
      ...data,
      [MultiTransfersFields.type]: disableSpendingLimit
        ? TokenTransferType.multiSig
        : canCreateSpendingLimitTx && !canCreateStandardTx
          ? TokenTransferType.spendingLimit
          : data?.type,
      recipients:
        data?.recipients.map(({ tokenAddress, ...rest }) => ({
          ...rest,
          [TokenTransferFields.tokenAddress]:
            canCreateSpendingLimitTx && !canCreateStandardTx ? balancesItems[0]?.tokenInfo.address : tokenAddress,
        })) || [],
    },
    mode: 'onChange',
    delayError: 500,
  })

  const { handleSubmit, control, watch, formState } = formMethods

  const hasInsufficientFunds = useMemo(
    () =>
      !!formState.errors.recipients &&
      formState.errors.recipients.some?.((item) => item?.amount?.message === InsufficientFundsValidationError),
    [formState],
  )

  const type = watch(MultiTransfersFields.type)

  const {
    fields: recipientFields,
    append,
    remove,
  } = useFieldArray({ control, name: MultiTokenTransferFields.recipients })

  const canAddMoreRecipients = useMemo(() => recipientFields.length < MAX_RECIPIENTS, [recipientFields])

  const addRecipient = (): void => {
    if (!canAddMoreRecipients) {
      setCsvAirdropModalOpen(true)
      return
    }

    if (recipientFields.length === 1) {
      setMaxRecipientsInfo(true)
    }

    append({
      recipient: '',
      tokenAddress: ZERO_ADDRESS,
      amount: '',
    })
  }

  const removeRecipient = (index: number): void => {
    if (recipientFields.length > 1) {
      remove(index)
    }
  }

  const csvAirdropAppUrl = safeApps?.[0]?.url

  const CsvAirdropLink = () => (
    <Link sx={{ cursor: 'pointer' }} onClick={() => setCsvAirdropModalOpen(true)}>
      CSV Airdrop
    </Link>
  )

  const canBatch = isMassPayoutsEnabled && type === TokenTransferType.multiSig

  return (
    <TxCard>
      <FormProvider {...formMethods}>
        <form onSubmit={handleSubmit(onNext)} className={commonCss.form}>
          <Stack spacing={3}>
            <Stack spacing={8}>
              {recipientFields.map((field, index) => (
                <RecipientRow
                  key={field.id}
                  removable={recipientFields.length > 1}
                  fieldArray={{ name: MultiTokenTransferFields.recipients, index }}
                  remove={removeRecipient}
                  disableSpendingLimit={disableSpendingLimit || recipientFields.length > 1}
                />
              ))}
            </Stack>

            {canBatch && (
              <>
                <Stack direction="row" alignItems="center" justifyContent="space-between" mb={4}>
                  <Track {...MODALS_EVENTS.ADD_RECIPIENT}>
                    <Button
                      data-testid="add-recipient-btn"
                      variant="text"
                      onClick={addRecipient}
                      disabled={!canAddMoreRecipients}
                      startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
                      size="large"
                    >
                      Add recipient
                    </Button>
                  </Track>
                  <Typography
                    data-testid="recipients-count"
                    variant="body2"
                    color={canAddMoreRecipients ? 'primary' : 'error.main'}
                  >{`${recipientFields.length}/${MAX_RECIPIENTS}`}</Typography>
                </Stack>

                {hasInsufficientFunds && (
                  <Alert data-testid="insufficient-balance-error" severity="error">
                    <AlertTitle>Insufficient balance</AlertTitle>
                    <Typography variant="body2">
                      The total amount assigned to all recipients exceeds your available balance. Please adjust the
                      amounts you want to send.
                    </Typography>
                  </Alert>
                )}

                {canAddMoreRecipients && maxRecipientsInfo && !!csvAirdropAppUrl && (
                  <Alert severity="info" onClose={() => setMaxRecipientsInfo(false)}>
                    <Typography variant="body2">
                      If you want to add more than {MAX_RECIPIENTS} recipients, use <CsvAirdropLink />
                    </Typography>
                  </Alert>
                )}

                {!canAddMoreRecipients && (
                  <Alert data-testid="max-recipients-reached" severity="warning">
                    <Typography variant="body2">
                      No more recipients can be added.
                      {!!csvAirdropAppUrl && (
                        <>
                          <br />
                          Please use <CsvAirdropLink />
                        </>
                      )}
                    </Typography>
                  </Alert>
                )}

                {csvAirdropModalOpen && (
                  <CSVAirdropAppModal onClose={() => setCsvAirdropModalOpen(false)} appUrl={csvAirdropAppUrl} />
                )}
              </>
            )}

            <Box>
              <Divider className={commonCss.nestedDivider} />

              <CardActions>
                <Button variant="contained" type="submit">
                  Next
                </Button>
              </CardActions>
            </Box>
          </Stack>
        </form>
      </FormProvider>
    </TxCard>
  )
}

export default CreateTokenTransfer
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/index.tsx">
import CreateTokenTransfer from './CreateTokenTransfer'
import ReviewTokenTx from '@/components/tx-flow/flows/TokenTransfer/ReviewTokenTx'
import AssetsIcon from '@/public/images/sidebar/assets.svg'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { TokenAmountFields } from '@/components/common/TokenAmountInput'
import { useMemo } from 'react'
import { TxFlowType } from '@/services/analytics'
import { TxFlow } from '../../TxFlow'
import { TxFlowStep } from '../../TxFlowStep'

export enum TokenTransferType {
  multiSig = 'multiSig',
  spendingLimit = 'spendingLimit',
}

enum Fields {
  recipient = 'recipient',
}

export const TokenTransferFields = { ...Fields, ...TokenAmountFields }

export type TokenTransferParams = {
  [TokenTransferFields.recipient]: string
  [TokenTransferFields.tokenAddress]: string
  [TokenTransferFields.amount]: string
}

export enum MultiTransfersFields {
  recipients = 'recipients',
  type = 'type',
}

export const MultiTokenTransferFields = { ...MultiTransfersFields }

export type MultiTokenTransferParams = {
  [MultiTransfersFields.recipients]: TokenTransferParams[]
  [MultiTransfersFields.type]: TokenTransferType
}

type MultiTokenTransferFlowProps = {
  recipients?: Partial<TokenTransferParams>[]
  txNonce?: number
}

const defaultParams: MultiTokenTransferParams = {
  recipients: [
    {
      recipient: '',
      tokenAddress: ZERO_ADDRESS,
      amount: '',
    },
  ],
  type: TokenTransferType.multiSig,
}

const TokenTransferFlow = ({ txNonce, ...params }: MultiTokenTransferFlowProps) => {
  const initialData = useMemo<MultiTokenTransferParams>(
    () => ({
      ...defaultParams,
      recipients: params.recipients
        ? params.recipients.map((recipient) => ({
            ...defaultParams.recipients[0],
            ...recipient,
          }))
        : defaultParams.recipients,
    }),
    [params.recipients],
  )

  return (
    <TxFlow
      initialData={initialData}
      icon={AssetsIcon}
      subtitle="Send tokens"
      eventCategory={TxFlowType.TOKEN_TRANSFER}
      ReviewTransactionComponent={ReviewTokenTx}
    >
      <TxFlowStep title="New transaction">
        <CreateTokenTransfer txNonce={txNonce} />
      </TxFlowStep>
    </TxFlow>
  )
}

export default TokenTransferFlow
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/ReviewRecipientRow.tsx">
import { useMemo } from 'react'
import useBalances from '@/hooks/useBalances'
import SendAmountBlock from '@/components/tx-flow/flows/TokenTransfer/SendAmountBlock'
import SendToBlock from '@/components/tx/SendToBlock'
import type { TokenTransferParams } from '.'
import { safeParseUnits } from '@safe-global/utils/utils/formatters'
import { Stack } from '@mui/material'
import { sameAddress } from '@safe-global/utils/utils/addresses'

const ReviewRecipientRow = ({ params, name }: { params: TokenTransferParams; name: string }) => {
  const { balances } = useBalances()

  const token = useMemo(
    () => balances.items.find(({ tokenInfo }) => sameAddress(tokenInfo.address, params.tokenAddress)),
    [balances.items, params.tokenAddress],
  )

  const amountInWei = useMemo(
    () => safeParseUnits(params.amount, token?.tokenInfo.decimals)?.toString() || '0',
    [params.amount, token?.tokenInfo.decimals],
  )

  return (
    <Stack gap={2}>
      {token && <SendAmountBlock amountInWei={amountInWei} tokenInfo={token.tokenInfo} />}
      <SendToBlock address={params.recipient} name={name} avatarSize={32} />
    </Stack>
  )
}

export default ReviewRecipientRow
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/ReviewSpendingLimitTx.tsx">
import useWallet from '@/hooks/wallets/useWallet'
import type { ReactElement, SyntheticEvent } from 'react'
import { useContext, useMemo, useState } from 'react'
import { type BigNumberish, type BytesLike } from 'ethers'
import { Button, CardActions, Typography } from '@mui/material'
import SendToBlock from '@/components/tx/SendToBlock'
import { type TokenTransferParams } from '@/components/tx-flow/flows/TokenTransfer/index'
import SendAmountBlock from '@/components/tx-flow/flows/TokenTransfer/SendAmountBlock'
import useBalances from '@/hooks/useBalances'
import useSpendingLimit from '@/hooks/useSpendingLimit'
import useSpendingLimitGas from '@/hooks/useSpendingLimitGas'
import AdvancedParams, { useAdvancedParams } from '@/components/tx/AdvancedParams'
import { EMPTY_DATA, ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import useSafeInfo from '@/hooks/useSafeInfo'
import { Errors, logError } from '@/services/exceptions'
import ErrorMessage from '@/components/tx/ErrorMessage'
import WalletRejectionError from '@/components/tx/SignOrExecuteForm/WalletRejectionError'
import { useCurrentChain } from '@/hooks/useChains'
import { dispatchSpendingLimitTxExecution } from '@/services/tx/tx-sender'
import { getTxOptions } from '@/utils/transactions'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import useOnboard from '@/hooks/wallets/useOnboard'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import TxCard from '@/components/tx-flow/common/TxCard'
import { TxModalContext } from '@/components/tx-flow'
import { type SubmitCallback } from '@/components/tx/SignOrExecuteForm/SignOrExecuteFormV2'
import { TX_EVENTS, TX_TYPES } from '@/services/analytics/events/transactions'
import { isWalletRejection } from '@/utils/wallets'
import { safeParseUnits } from '@safe-global/utils/utils/formatters'
import CheckWallet from '@/components/common/CheckWallet'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'

export type SpendingLimitTxParams = {
  safeAddress: string
  token: string
  to: string
  amount: BigNumberish
  paymentToken: string
  payment: BigNumberish
  delegate: string
  signature: BytesLike
}

const ReviewSpendingLimitTx = ({
  params,
  onSubmit,
}: {
  params: TokenTransferParams
  onSubmit: SubmitCallback
}): ReactElement => {
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [submitError, setSubmitError] = useState<Error | undefined>()
  const [isRejectedByUser, setIsRejectedByUser] = useState<Boolean>(false)
  const { setTxFlow } = useContext(TxModalContext)
  const currentChain = useCurrentChain()
  const onboard = useOnboard()
  const wallet = useWallet()
  const { safe, safeAddress } = useSafeInfo()
  const { balances } = useBalances()
  const token = balances.items.find((item) => item.tokenInfo.address === params.tokenAddress)
  const spendingLimit = useSpendingLimit(token?.tokenInfo)

  const amountInWei = useMemo(
    () => safeParseUnits(params.amount, token?.tokenInfo.decimals)?.toString() || '0',
    [params.amount, token?.tokenInfo.decimals],
  )

  const txParams: SpendingLimitTxParams = useMemo(
    () => ({
      safeAddress,
      token: spendingLimit?.token.address || ZERO_ADDRESS,
      to: params.recipient,
      amount: amountInWei,
      paymentToken: ZERO_ADDRESS,
      payment: 0,
      delegate: spendingLimit?.beneficiary || ZERO_ADDRESS,
      signature: EMPTY_DATA,
    }),
    [amountInWei, params.recipient, safeAddress, spendingLimit?.beneficiary, spendingLimit?.token],
  )

  const { gasLimit, gasLimitLoading } = useSpendingLimitGas(txParams)

  const [advancedParams, setManualParams] = useAdvancedParams(gasLimit)

  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()
    if (!onboard || !wallet) return

    trackEvent(MODALS_EVENTS.USE_SPENDING_LIMIT)

    setIsSubmittable(false)
    setSubmitError(undefined)
    setIsRejectedByUser(false)

    const txOptions = getTxOptions(advancedParams, currentChain)

    try {
      await dispatchSpendingLimitTxExecution(
        txParams,
        txOptions,
        wallet.provider,
        safe.chainId,
        safeAddress,
        safe.modules,
      )
      onSubmit('', true)
      setTxFlow(undefined)
    } catch (_err) {
      const err = asError(_err)
      if (isWalletRejection(err)) {
        setIsRejectedByUser(true)
      } else {
        logError(Errors._801, err)
        setSubmitError(err)
      }
      setIsSubmittable(true)
      return
    }

    trackEvent({ ...TX_EVENTS.CREATE_VIA_SPENDING_LIMTI, label: TX_TYPES.transfer_token })
    trackEvent({ ...TX_EVENTS.EXECUTE_VIA_SPENDING_LIMIT, label: TX_TYPES.transfer_token })
  }

  const submitDisabled = !isSubmittable || gasLimitLoading

  return (
    <form onSubmit={handleSubmit}>
      <TxCard>
        <Typography variant="body2">
          Spending limit transactions only appear in the interface once they are successfully processed and indexed.
          Pending transactions can only be viewed in your signer wallet application or under your wallet address on a
          Blockchain Explorer.
        </Typography>

        {token && <SendAmountBlock amountInWei={amountInWei} tokenInfo={token.tokenInfo} />}

        <SendToBlock address={params.recipient} />

        <AdvancedParams params={advancedParams} willExecute={true} onFormSubmit={setManualParams} />

        <NetworkWarning />

        {submitError && (
          <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
        )}

        {isRejectedByUser && <WalletRejectionError />}

        <Typography variant="body2" color="primary.light" textAlign="center">
          You&apos;re about to create a transaction and will need to confirm it with your currently connected wallet.
        </Typography>

        <CardActions>
          <CheckWallet allowNonOwner checkNetwork={!submitDisabled}>
            {(isOk) => (
              <Button variant="contained" type="submit" disabled={!isOk || submitDisabled}>
                Execute
              </Button>
            )}
          </CheckWallet>
        </CardActions>
      </TxCard>
    </form>
  )
}

export default ReviewSpendingLimitTx
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/ReviewTokenTransfer.tsx">
import { type PropsWithChildren, useContext, useEffect, useMemo } from 'react'
import useBalances from '@/hooks/useBalances'
import { createTokenTransferParams } from '@/services/tx/tokenTransferParams'
import { createMultiSendCallOnlyTx } from '@/services/tx/tx-sender'
import type { MultiTokenTransferParams } from '.'
import { SafeTxContext } from '../../SafeTxProvider'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'
import { Divider, Stack } from '@mui/material'
import ReviewRecipientRow from './ReviewRecipientRow'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import ReviewTransaction from '@/components/tx/ReviewTransactionV2'

const ReviewTokenTransfer = ({
  params,
  onSubmit,
  txNonce,
  children,
}: PropsWithChildren<{
  params?: MultiTokenTransferParams
  onSubmit: () => void
  txNonce?: number
}>) => {
  const { setSafeTx, setSafeTxError, setNonce, setIsMassPayout } = useContext(SafeTxContext)
  const { balances } = useBalances()

  const recipients = useMemo(() => params?.recipients || [], [params?.recipients])

  useEffect(() => {
    setIsMassPayout(recipients.length > 1)
  }, [recipients, setIsMassPayout])

  useEffect(() => {
    if (txNonce !== undefined) {
      setNonce(txNonce)
    }

    const calls = recipients
      .map((recipient) => {
        const token = balances.items.find((item) => sameAddress(item.tokenInfo.address, recipient.tokenAddress))

        if (!token) return

        return createTokenTransferParams(
          recipient.recipient,
          recipient.amount,
          token?.tokenInfo.decimals,
          recipient.tokenAddress,
        )
      })
      .filter((transfer): transfer is MetaTransactionData => !!transfer)

    createMultiSendCallOnlyTx(calls).then(setSafeTx).catch(setSafeTxError)
  }, [recipients, txNonce, setNonce, balances, setSafeTx, setSafeTxError])

  return (
    <ReviewTransaction onSubmit={onSubmit}>
      {recipients.length > 1 && (
        <Stack divider={<Divider />} gap={2}>
          {recipients.map((recipient, index) => (
            <ReviewRecipientRow
              params={recipient}
              key={`${recipient.recipient}_${index}`}
              name={`Recipient ${index + 1}`}
            />
          ))}
        </Stack>
      )}

      {recipients.length > 1 && <Divider />}

      {children}
    </ReviewTransaction>
  )
}

export default ReviewTokenTransfer
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/ReviewTokenTx.tsx">
import { useContext, type ReactElement, type PropsWithChildren } from 'react'
import { type MultiTokenTransferParams, TokenTransferType } from '@/components/tx-flow/flows/TokenTransfer/index'
import ReviewTokenTransfer from '@/components/tx-flow/flows/TokenTransfer/ReviewTokenTransfer'
import ReviewSpendingLimitTx from '@/components/tx-flow/flows/TokenTransfer/ReviewSpendingLimitTx'
import { TxFlowContext, type TxFlowContextType } from '../../TxFlowProvider'

const ReviewTokenTx = (props: PropsWithChildren<{ onSubmit: () => void; txNonce?: number }>): ReactElement => {
  const { data } = useContext(TxFlowContext) as TxFlowContextType<MultiTokenTransferParams>
  const isSpendingLimitTx = data?.type === TokenTransferType.spendingLimit

  return isSpendingLimitTx && data?.recipients.length === 1 ? (
    // TODO: Allow batched spending limit txs
    <ReviewSpendingLimitTx params={data.recipients[0]} onSubmit={props.onSubmit} />
  ) : (
    <ReviewTokenTransfer params={data} {...props} />
  )
}

export default ReviewTokenTx
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/SendAmountBlock.tsx">
import { type ReactNode } from 'react'
import { type TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { Box, Typography } from '@mui/material'
import TokenIcon from '@/components/common/TokenIcon'
import FieldsGrid from '@/components/tx/FieldsGrid'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'

const SendAmountBlock = ({
  amountInWei,
  tokenInfo,
  children,
  title = 'Send',
}: {
  /** Amount in WEI */
  amountInWei: number | string
  tokenInfo: Omit<TokenInfo, 'name' | 'logoUri'> & { logoUri?: string }
  children?: ReactNode
  title?: string
}) => {
  return (
    <FieldsGrid title={title}>
      <Box display="flex" alignItems="center" gap={1}>
        <TokenIcon logoUri={tokenInfo.logoUri} tokenSymbol={tokenInfo.symbol} />

        <Typography variant="body2" fontWeight="bold">
          {tokenInfo.symbol}
        </Typography>

        {children}

        <Typography variant="body2" data-testid="token-amount">
          {formatVisualAmount(amountInWei, tokenInfo.decimals, tokenInfo.decimals ?? 0)}
        </Typography>
      </Box>
    </FieldsGrid>
  )
}

export default SendAmountBlock
</file>

<file path="src/components/tx-flow/flows/TokenTransfer/utils.ts">
import useIsOnlySpendingLimitBeneficiary from '@/hooks/useIsOnlySpendingLimitBeneficiary'
import useSpendingLimit from '@/hooks/useSpendingLimit'
import { useVisibleBalances } from '@/hooks/useVisibleBalances'
import useWallet from '@/hooks/wallets/useWallet'
import { useAppSelector } from '@/store'
import { selectSpendingLimits } from '@/store/spendingLimitsSlice'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { type SafeBalanceResponse } from '@safe-global/safe-gateway-typescript-sdk'

export const useTokenAmount = (selectedToken: SafeBalanceResponse['items'][0] | undefined) => {
  const spendingLimit = useSpendingLimit(selectedToken?.tokenInfo)

  const spendingLimitAmount = BigInt(spendingLimit?.amount || 0) - BigInt(spendingLimit?.spent || 0)
  const totalAmount = BigInt(selectedToken?.balance || 0)

  return { totalAmount, spendingLimitAmount }
}

export const useVisibleTokens = () => {
  const isOnlySpendingLimitBeneficiary = useIsOnlySpendingLimitBeneficiary()
  const { balances } = useVisibleBalances()
  const spendingLimits = useAppSelector(selectSpendingLimits)
  const wallet = useWallet()

  if (isOnlySpendingLimitBeneficiary) {
    return balances.items.filter(({ tokenInfo }) => {
      return spendingLimits?.some(({ beneficiary, token }) => {
        return sameAddress(beneficiary, wallet?.address) && sameAddress(tokenInfo.address, token.address)
      })
    })
  }

  return balances.items
}
</file>

<file path="src/components/tx-flow/flows/UpdateSafe/index.tsx">
import { useMemo } from 'react'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '@/components/tx-flow/common/TxLayout'
import { UpdateSafeReview } from './UpdateSafeReview'
import SettingsIcon from '@/public/images/sidebar/settings.svg'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import useTxStepper from '../../useTxStepper'
import { TxFlowType } from '@/services/analytics'

const UpdateSafeFlow = () => {
  const { step, nextStep, prevStep } = useTxStepper(undefined, TxFlowType.UPDATE_SAFE)

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: { title: 'Review transaction' },
        content: <UpdateSafeReview key={0} onSubmit={() => nextStep(undefined)} />,
      },
      {
        txLayoutProps: { title: 'Confirm transaction details', fixedNonce: true },
        content: <ConfirmTxDetails key={1} onSubmit={() => {}} />,
      },
    ],
    [nextStep],
  )

  return (
    <TxLayout
      subtitle="Update Safe Account version"
      icon={SettingsIcon}
      step={step}
      onBack={prevStep}
      {...(steps?.[step]?.txLayoutProps || {})}
    >
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default UpdateSafeFlow
</file>

<file path="src/components/tx-flow/flows/UpdateSafe/UpdateSafeReview.tsx">
import { useContext } from 'react'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { createUpdateSafeTxs } from '@/services/tx/safeUpdateParams'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import { SafeTxContext } from '../../SafeTxProvider'
import useAsync from '@safe-global/utils/hooks/useAsync'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

export const UpdateSafeReview = ({ onSubmit }: { onSubmit: () => void }) => {
  const { safe, safeLoaded } = useSafeInfo()
  const chain = useCurrentChain()
  const { setSafeTx, setSafeTxError } = useContext(SafeTxContext)

  useAsync(async () => {
    if (!chain || !safeLoaded) return

    const txs = await createUpdateSafeTxs(safe, chain)
    const safeTxPromise = txs.length > 1 ? createMultiSendCallOnlyTx(txs) : createTx(txs[0])

    safeTxPromise.then(setSafeTx).catch(setSafeTxError)
  }, [safe, safeLoaded, chain, setSafeTx, setSafeTxError])

  return <ReviewTransaction onSubmit={onSubmit} />
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/index.tsx">
import { useMemo, type ReactElement } from 'react'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import type { TxStep } from '../../common/TxLayout'
import RecoveryPlus from '@/public/images/common/recovery-plus.svg'
import useTxStepper from '../../useTxStepper'
import { UpsertRecoveryFlowReview as UpsertRecoveryFlowReview } from './UpsertRecoveryFlowReview'
import { UpsertRecoveryFlowSettings as UpsertRecoveryFlowSettings } from './UpsertRecoveryFlowSettings'
import { UpsertRecoveryFlowIntro as UpsertRecoveryFlowIntro } from './UpsertRecoveryFlowIntro'
import { DAY_IN_SECONDS } from './useRecoveryPeriods'
import type { RecoveryState } from '@/features/recovery/services/recovery-state'
import { ConfirmTxDetails } from '@/components/tx/ConfirmTxDetails'
import { TxFlowType } from '@/services/analytics'

export enum UpsertRecoveryFlowFields {
  recoverer = 'recoverer',
  delay = 'delay',
  customDelay = 'customDelay',
  selectedDelay = 'selectedDelay',
  expiry = 'expiry',
}

export type UpsertRecoveryFlowProps = {
  [UpsertRecoveryFlowFields.recoverer]: string
  [UpsertRecoveryFlowFields.delay]: string
  [UpsertRecoveryFlowFields.customDelay]: string
  [UpsertRecoveryFlowFields.selectedDelay]: string
  [UpsertRecoveryFlowFields.expiry]: string
}

function UpsertRecoveryFlow({ delayModifier }: { delayModifier?: RecoveryState[number] }): ReactElement {
  const { data, step, nextStep, prevStep } = useTxStepper<UpsertRecoveryFlowProps>(
    {
      [UpsertRecoveryFlowFields.recoverer]: delayModifier?.recoverers?.[0] ?? '',
      [UpsertRecoveryFlowFields.delay]: '',
      [UpsertRecoveryFlowFields.selectedDelay]: delayModifier?.delay?.toString() ?? `${DAY_IN_SECONDS * 28}`, // 28 days in seconds
      [UpsertRecoveryFlowFields.customDelay]: '',
      [UpsertRecoveryFlowFields.expiry]: delayModifier?.expiry?.toString() ?? '0',
    },
    TxFlowType.SETUP_RECOVERY,
  )

  const steps = useMemo<TxStep[]>(
    () => [
      {
        txLayoutProps: {
          title: 'Account recovery',
          subtitle: 'How does recovery work?',
          hideNonce: true,
          hideProgress: true,
        },
        content: <UpsertRecoveryFlowIntro key={0} onSubmit={() => nextStep(data)} />,
      },
      {
        txLayoutProps: { title: 'Account recovery', subtitle: 'Set up recovery settings', icon: RecoveryPlus },
        content: (
          <UpsertRecoveryFlowSettings
            key={1}
            params={data}
            delayModifier={delayModifier}
            onSubmit={(formData) => nextStep({ ...data, ...formData })}
          />
        ),
      },
      {
        txLayoutProps: { title: 'Confirm transaction', subtitle: 'Set up account recovery', icon: RecoveryPlus },
        content: (
          <UpsertRecoveryFlowReview
            key={2}
            params={data}
            moduleAddress={delayModifier?.address}
            onSubmit={() => nextStep(data)}
          />
        ),
      },
      {
        txLayoutProps: {
          title: 'Confirm transaction details',
          subtitle: 'Set up account recovery',
          icon: RecoveryPlus,
          fixedNonce: true,
        },
        content: <ConfirmTxDetails key={3} onSubmit={() => {}} />,
      },
    ],
    [nextStep, data, delayModifier],
  )

  return (
    <TxLayout step={step} onBack={prevStep} {...(steps?.[step]?.txLayoutProps || {})}>
      {steps.map(({ content }) => content)}
    </TxLayout>
  )
}

export default UpsertRecoveryFlow
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/RecovererSmartContractWarning.tsx">
import { SvgIcon, Typography } from '@mui/material'
import { getSafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useState, useEffect } from 'react'
import { useWatch } from 'react-hook-form'
import { isAddress } from 'ethers'
import type { ReactElement } from 'react'

import InfoIcon from '@/public/images/notifications/info.svg'
import { isSmartContractWallet } from '@/utils/wallets'
import useDebounce from '@/hooks/useDebounce'
import useSafeInfo from '@/hooks/useSafeInfo'
import { UpsertRecoveryFlowFields } from '.'
import { sameAddress } from '@safe-global/utils/utils/addresses'

import addressBookInputCss from '@/components/common/AddressBookInput/styles.module.css'

export function RecovererWarning(): ReactElement | null {
  const { safe, safeAddress } = useSafeInfo()
  const [warning, setWarning] = useState<string>()

  const recoverer = useWatch({ name: UpsertRecoveryFlowFields.recoverer })
  const debouncedRecoverer = useDebounce(recoverer, 500)

  useEffect(() => {
    setWarning(undefined)

    if (!isAddress(debouncedRecoverer) || sameAddress(debouncedRecoverer, safeAddress)) {
      return
    }

    ;(async () => {
      let isSmartContract = false

      try {
        isSmartContract = await isSmartContractWallet(safe.chainId, debouncedRecoverer)
      } catch {
        return
      }

      // EOA
      if (!isSmartContract) {
        return
      }

      try {
        await getSafeInfo(safe.chainId, debouncedRecoverer)
      } catch {
        setWarning('The given address is a smart contract. Please ensure that it can sign transactions.')
      }
    })()
  }, [debouncedRecoverer, safe.chainId, safeAddress])

  if (!warning) {
    return null
  }

  return (
    <Typography
      variant="body2"
      className={addressBookInputCss.unknownAddress}
      sx={({ palette }) => ({
        bgcolor: `${palette.warning.background} !important`,
        color: `${palette.warning.main} !important`,
      })}
    >
      <SvgIcon component={InfoIcon} fontSize="small" />
      {warning}
    </Typography>
  )
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/styles.module.css">
.advanced {
  display: flex;
  align-items: center;
  cursor: pointer;
  color: var(--color-primary-light);
}

.icon {
  position: relative;
  padding: 6px;
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--color-background-paper);
}

.connector::before {
  content: '';
  position: absolute;
  border-left: 1px dashed var(--color-border-light);
  left: 66px;
  height: 70%;
  margin-top: var(--space-1);
}

.recommended {
  color: var(--color-text-primary);
  display: flex;
  padding: var(--space-1) var(--space-2);
  position: absolute;
  right: var(--space-4);
  border-radius: 0px 0px 4px 4px;
  background: var(--color-info-light);
  margin-top: calc(var(--space-3) * -1);
  align-items: center;
}

[data-theme='dark'] .recommended {
  color: var(--color-text-primary);
  background: var(--color-info-dark);
}

.poweredBy {
  display: flex;
  align-items: center;
  gap: calc(var(--space-1) / 2);
  color: var(--color-text-secondary);
}

.tenderly {
  width: 65px;
  height: 15px;
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/UpsertRecoveryFlowIntro.tsx">
import { Button, CardActions, Divider, Grid, Typography } from '@mui/material'
import type { ReactElement } from 'react'

import TxCard from '../../common/TxCard'
import RecoveryRecoverers from '@/public/images/settings/spending-limit/beneficiary.svg'
import RecoveryRecoverer from '@/public/images/transactions/recovery-recoverer.svg'
import RecoveryDelay from '@/public/images/settings/spending-limit/time.svg'
import RecoveryExecution from '@/public/images/transactions/recovery-execution.svg'

import css from './styles.module.css'
import commonCss from '@/components/tx-flow/common/styles.module.css'

const RecoverySteps = [
  {
    Icon: RecoveryRecoverers,
    title: 'Choose a Recoverer and set a review window',
    subtitle:
      'Only your chosen Recoverer can initiate the recovery process. The process can be cancelled at any time during the review window.',
  },
  {
    Icon: RecoveryRecoverer,
    title: 'Lost access? Let the Recoverer connect',
    subtitle: 'The recovery process can be initiated by a trusted Recoverer when connected to your Safe Account.',
  },
  {
    Icon: RecoveryDelay,
    title: 'Start the recovery process',
    subtitle: 'Your Recoverer initiates the recovery process by proposing a new Safe Account setup on-chain.',
  },
  {
    Icon: RecoveryExecution,
    title: 'All done! The Account is yours again',
    subtitle:
      'Once the review window has passed, you can execute the recovery proposal and regain access to your Safe Account.',
  },
]

export function UpsertRecoveryFlowIntro({ onSubmit }: { onSubmit: () => void }): ReactElement {
  return (
    <TxCard>
      <Grid
        container
        className={css.connector}
        sx={{
          display: 'flex',
          gap: 4,
        }}
      >
        {RecoverySteps.map(({ Icon, title, subtitle }, index) => (
          <Grid item xs={12} key={index}>
            <Grid
              container
              sx={{
                display: 'flex',
                gap: 3,
              }}
            >
              <Grid item className={css.icon}>
                <Icon />
              </Grid>
              <Grid item xs>
                <Typography
                  variant="h5"
                  sx={{
                    mb: 0.5,
                  }}
                >
                  {title}
                </Typography>
                <Typography variant="body2">{subtitle}</Typography>
              </Grid>
            </Grid>
          </Grid>
        ))}
      </Grid>
      <Divider className={commonCss.nestedDivider} />
      <CardActions sx={{ mt: 'var(--space-1) !important' }}>
        <Button data-testid="next-btn" variant="contained" onClick={onSubmit}>
          Next
        </Button>
      </CardActions>
    </TxCard>
  )
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/UpsertRecoveryFlowReview.tsx">
import { SvgIcon, Tooltip, Typography } from '@mui/material'
import { getSafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useContext, useEffect } from 'react'
import type { ReactElement } from 'react'

import EthHashInfo from '@/components/common/EthHashInfo'
import { TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import useSafeInfo from '@/hooks/useSafeInfo'
import InfoIcon from '@/public/images/notifications/info.svg'
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Errors, logError } from '@/services/exceptions'
import { getRecoveryUpsertTransactions } from '@/features/recovery/services/setup'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { createMultiSendCallOnlyTx, createTx } from '@/services/tx/tx-sender'
import { isSmartContractWallet } from '@/utils/wallets'
import { UpsertRecoveryFlowFields } from '.'
import { TOOLTIP_TITLES } from '../../common/constants'
import { useRecoveryPeriods } from './useRecoveryPeriods'
import type { UpsertRecoveryFlowProps } from '.'
import { isCustomDelaySelected } from './utils'
import ReviewTransaction from '@/components/tx/ReviewTransaction'

enum AddressType {
  EOA = 'EOA',
  Safe = 'Safe',
  Other = 'Other',
}

const getAddressType = async (address: string, chainId: string) => {
  const isSmartContract = await isSmartContractWallet(chainId, address)
  if (!isSmartContract) return AddressType.EOA

  const isSafeContract = await getSafeInfo(chainId, address)
  if (isSafeContract) return AddressType.Safe

  return AddressType.Other
}

export function UpsertRecoveryFlowReview({
  params,
  moduleAddress,
  onSubmit,
}: {
  params: UpsertRecoveryFlowProps
  moduleAddress?: string
  onSubmit: () => void
}): ReactElement {
  const web3ReadOnly = useWeb3ReadOnly()
  const { safe, safeAddress } = useSafeInfo()
  const { setSafeTx, safeTxError, setSafeTxError } = useContext(SafeTxContext)
  const periods = useRecoveryPeriods()

  const { recoverer, expiry, delay, customDelay, selectedDelay } = params
  const isCustomDelay = isCustomDelaySelected(selectedDelay)

  const expiryLabel = periods.expiration.find(({ value }) => value === params[UpsertRecoveryFlowFields.expiry])!.label
  const delayLabel = isCustomDelay
    ? `${customDelay} days`
    : periods.delay.find(({ value }) => value === selectedDelay)?.label

  useEffect(() => {
    if (!web3ReadOnly) {
      return
    }

    getRecoveryUpsertTransactions({
      ...params,
      provider: web3ReadOnly,
      chainId: safe.chainId,
      safeAddress,
      moduleAddress,
    })
      .then((transactions) => {
        return transactions.length > 1 ? createMultiSendCallOnlyTx(transactions) : createTx(transactions[0])
      })
      .then(setSafeTx)
      .catch(setSafeTxError)
  }, [moduleAddress, params, safe.chainId, safeAddress, setSafeTx, setSafeTxError, web3ReadOnly])

  useEffect(() => {
    if (safeTxError) {
      logError(Errors._809, safeTxError.message)
    }
  }, [safeTxError])

  const handleSubmit = async (
    isEdit: boolean,
    params: Omit<UpsertRecoveryFlowProps, 'customDelay' | 'selectedDelay'>,
    chainId: string,
  ) => {
    const addressType = await getAddressType(params.recoverer, chainId)
    const creationEvent = isEdit ? RECOVERY_EVENTS.SUBMIT_RECOVERY_EDIT : RECOVERY_EVENTS.SUBMIT_RECOVERY_CREATE
    const settings = `delay_${params.delay},expiry_${params.expiry},type_${addressType}`

    trackEvent({ ...creationEvent })
    trackEvent({ ...RECOVERY_EVENTS.RECOVERY_SETTINGS, label: settings })

    onSubmit()
  }

  const isEdit = !!moduleAddress

  return (
    <ReviewTransaction onSubmit={() => handleSubmit(isEdit, { recoverer, expiry, delay }, safe.chainId)}>
      <Typography>
        This transaction will {moduleAddress ? 'update' : 'enable'} the Account recovery feature once executed.
      </Typography>

      <TxDataRow title="Trusted Recoverer">
        <EthHashInfo address={recoverer} showName={false} hasExplorer showCopyButton avatarSize={24} />
      </TxDataRow>

      <TxDataRow
        title={
          <>
            Review window
            <Tooltip placement="top" title={TOOLTIP_TITLES.REVIEW_WINDOW}>
              <span>
                <SvgIcon
                  component={InfoIcon}
                  inheritViewBox
                  fontSize="small"
                  color="border"
                  sx={{ verticalAlign: 'middle', ml: 0.5 }}
                />
              </span>
            </Tooltip>
          </>
        }
      >
        {delayLabel}
      </TxDataRow>

      {expiryLabel !== '0' && (
        <TxDataRow
          title={
            <>
              Proposal expiry
              <Tooltip placement="top" title={TOOLTIP_TITLES.PROPOSAL_EXPIRY}>
                <span>
                  <SvgIcon
                    component={InfoIcon}
                    inheritViewBox
                    fontSize="small"
                    color="border"
                    sx={{ verticalAlign: 'middle', ml: 0.5 }}
                  />
                </span>
              </Tooltip>
            </>
          }
        >
          {expiryLabel}
        </TxDataRow>
      )}
    </ReviewTransaction>
  )
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/UpsertRecoveryFlowSettings.tsx">
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import {
  Divider,
  CardActions,
  Button,
  Typography,
  SvgIcon,
  MenuItem,
  TextField,
  Collapse,
  Checkbox,
  FormControlLabel,
  Tooltip,
  Alert,
  Box,
} from '@mui/material'
import ExpandLessIcon from '@mui/icons-material/ExpandLess'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import { useForm, FormProvider, Controller } from 'react-hook-form'
import { useState } from 'react'
import type { ReactElement } from 'react'

import TxCard from '../../common/TxCard'
import { useRecoveryPeriods } from './useRecoveryPeriods'
import { UpsertRecoveryFlowFields, type UpsertRecoveryFlowProps } from '.'
import AddressBookInput from '@/components/common/AddressBookInput'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import useSafeInfo from '@/hooks/useSafeInfo'
import InfoIcon from '@/public/images/notifications/info.svg'
import { RecovererWarning } from './RecovererSmartContractWarning'
import ExternalLink from '@/components/common/ExternalLink'
import { BRAND_NAME, HelpCenterArticle, HelperCenterArticleTitles } from '@/config/constants'
import { TOOLTIP_TITLES } from '../../common/constants'
import Track from '@/components/common/Track'
import type { RecoveryStateItem } from '@/features/recovery/services/recovery-state'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import css from './styles.module.css'
import NumberField from '@/components/common/NumberField'
import { getDelay, isCustomDelaySelected } from './utils'

export function UpsertRecoveryFlowSettings({
  params,
  delayModifier,
  onSubmit,
}: {
  params: UpsertRecoveryFlowProps
  delayModifier?: RecoveryStateItem
  onSubmit: (formData: UpsertRecoveryFlowProps) => void
}): ReactElement {
  const { safeAddress } = useSafeInfo()
  const [showAdvanced, setShowAdvanced] = useState(params[UpsertRecoveryFlowFields.expiry] !== '0')
  const [understandsRisk, setUnderstandsRisk] = useState(false)
  const periods = useRecoveryPeriods()

  const formMethods = useForm<UpsertRecoveryFlowProps>({
    defaultValues: params,
    mode: 'onChange',
  })

  const recoverer = formMethods.watch(UpsertRecoveryFlowFields.recoverer)
  const expiry = formMethods.watch(UpsertRecoveryFlowFields.expiry)
  const selectedDelay = formMethods.watch(UpsertRecoveryFlowFields.selectedDelay)
  const customDelay = formMethods.watch(UpsertRecoveryFlowFields.customDelay)
  const customDelayState = formMethods.getFieldState(UpsertRecoveryFlowFields.customDelay)

  const delay = getDelay(customDelay, selectedDelay)

  // RHF's dirty check is tempermental with our address input dropdown
  const isDirty = delayModifier
    ? // Updating settings
      !sameAddress(recoverer, delayModifier.recoverers[0]) ||
      delayModifier.delay !== BigInt(delay) ||
      delayModifier.expiry !== BigInt(expiry)
    : // Setting up recovery
      recoverer && delay && expiry

  const validateRecoverer = (recoverer: string) => {
    if (sameAddress(recoverer, safeAddress)) {
      return 'The Safe Account cannot be a Recoverer of itself'
    }
  }

  const validateCustomDelay = (delay: string) => {
    if (!delay) return ''
    if (delay === '0' || !Number.isInteger(Number(delay))) {
      return 'Invalid number'
    }
  }

  const onShowAdvanced = () => {
    setShowAdvanced((prev) => !prev)
    trackEvent(RECOVERY_EVENTS.SHOW_ADVANCED)
  }

  const isDisabled = !understandsRisk || !isDirty || !!customDelayState.error

  const handleSubmit = () => {
    onSubmit({ expiry, delay, customDelay, selectedDelay, recoverer })
  }

  return (
    <>
      <FormProvider {...formMethods}>
        <form onSubmit={formMethods.handleSubmit(handleSubmit)} className={commonCss.form}>
          <TxCard>
            <Alert severity="warning" sx={{ border: 'unset' }}>
              Your Recoverer will be able to reset your Account setup. Only select an address that you trust.{' '}
              <Track {...RECOVERY_EVENTS.LEARN_MORE} label="recover-setup-flow">
                <ExternalLink href={HelpCenterArticle.RECOVERY} title={HelperCenterArticleTitles.RECOVERY}>
                  Learn more
                </ExternalLink>
              </Track>
            </Alert>
            <div>
              <Typography variant="h5" gutterBottom>
                Trusted Recoverer
              </Typography>

              <Typography variant="body2">
                Choose a Recoverer, such as a hardware wallet or a Safe Account controlled by family or friends, that
                can initiate the recovery process in the future.
              </Typography>
            </div>
            <div>
              <AddressBookInput
                label="Recoverer address or ENS"
                name={UpsertRecoveryFlowFields.recoverer}
                required
                fullWidth
                validate={validateRecoverer}
              />
              <RecovererWarning />
            </div>
            <div>
              <Typography variant="h5" gutterBottom>
                Review window
                <Tooltip placement="top" arrow title={TOOLTIP_TITLES.REVIEW_WINDOW}>
                  <span>
                    <SvgIcon
                      component={InfoIcon}
                      inheritViewBox
                      fontSize="small"
                      color="border"
                      sx={{ verticalAlign: 'middle', ml: 0.5 }}
                    />
                  </span>
                </Tooltip>
              </Typography>

              <Typography variant="body2">
                The recovery proposal will be available for execution after this period of time. You can cancel any
                recovery proposal when it is not needed or wanted during this period.
              </Typography>
            </div>
            <Box
              sx={{
                display: 'flex',
                gap: 2,
              }}
            >
              <Controller
                control={formMethods.control}
                name={UpsertRecoveryFlowFields.selectedDelay}
                render={({ field: { ref, ...field } }) => (
                  <TextField
                    data-testid="recovery-delay-select"
                    fullWidth
                    inputRef={ref}
                    {...field}
                    select
                    sx={{ width: '55%', maxWidth: '240px' }}
                  >
                    {periods.delay.map(({ label, value }, index) => (
                      <MenuItem key={index} value={value}>
                        {label}
                      </MenuItem>
                    ))}
                  </TextField>
                )}
              />
              <Box
                sx={{
                  display: 'flex',
                  flex: '1',
                  gap: 2,
                  maxWidth: '180px',
                  minWidth: '140px',
                }}
              >
                {isCustomDelaySelected(selectedDelay) && (
                  <>
                    <Controller
                      control={formMethods.control}
                      name={UpsertRecoveryFlowFields.customDelay}
                      rules={{ validate: validateCustomDelay }}
                      render={({ field: { ref, ...field }, fieldState }) => (
                        <NumberField
                          label={fieldState.error?.message}
                          error={!!fieldState.error}
                          inputRef={ref}
                          {...field}
                          required
                          placeholder="E.g. 100"
                        />
                      )}
                    />
                    <Typography
                      sx={{
                        my: 'auto',
                      }}
                    >
                      days.
                    </Typography>
                  </>
                )}
              </Box>
            </Box>
            <Typography
              data-testid="advanced-btn"
              variant="body2"
              onClick={onShowAdvanced}
              role="button"
              className={css.advanced}
            >
              Advanced {showAdvanced ? <ExpandLessIcon /> : <ExpandMoreIcon />}
            </Typography>
            <Collapse in={showAdvanced}>
              <div>
                <Typography variant="h5" gutterBottom>
                  Proposal expiry
                  <Tooltip placement="top" arrow title={TOOLTIP_TITLES.PROPOSAL_EXPIRY}>
                    <span>
                      <SvgIcon
                        component={InfoIcon}
                        inheritViewBox
                        fontSize="small"
                        color="border"
                        sx={{ verticalAlign: 'middle', ml: 0.5 }}
                      />
                    </span>
                  </Tooltip>
                </Typography>

                <Typography
                  variant="body2"
                  sx={{
                    mb: 2,
                  }}
                >
                  Set a period of time after which the recovery proposal will expire and can no longer be executed.
                </Typography>
              </div>

              <Controller
                control={formMethods.control}
                name={UpsertRecoveryFlowFields.expiry}
                // Don't reset value if advanced section is collapsed
                shouldUnregister={false}
                render={({ field: { ref, ...field } }) => (
                  <TextField
                    data-testid="recovery-expiry-select"
                    inputRef={ref}
                    {...field}
                    fullWidth
                    select
                    sx={{ width: '55%', maxWidth: '240px' }}
                  >
                    {periods.expiration.map(({ label, value }, index) => (
                      <MenuItem key={index} value={value}>
                        {label}
                      </MenuItem>
                    ))}
                  </TextField>
                )}
              />
            </Collapse>
          </TxCard>

          <TxCard>
            <FormControlLabel
              data-testid="warning-section"
              label={`I understand that the Recoverer will be able to initiate recovery of this Safe Account and that I will only be informed within the ${BRAND_NAME}.`}
              control={<Checkbox checked={understandsRisk} onChange={(_, checked) => setUnderstandsRisk(checked)} />}
              sx={{ pl: 2 }}
            />

            <Divider className={commonCss.nestedDivider} />

            <CardActions sx={{ mt: '0 !important' }}>
              <Button data-testid="next-btn" variant="contained" type="submit" disabled={isDisabled}>
                Next
              </Button>
            </CardActions>
          </TxCard>
        </form>
      </FormProvider>
    </>
  )
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/useRecoveryPeriods.ts">
import chains from '@/config/chains'
import { useCurrentChain } from '@/hooks/useChains'

export const DAY_IN_SECONDS = 60 * 60 * 24

type Periods = Array<{ label: string; value: string | number }>

const ExpirationPeriods: Periods = [
  {
    label: '2 days',
    value: `${DAY_IN_SECONDS * 2}`,
  },
  {
    label: '7 days',
    value: `${DAY_IN_SECONDS * 7}`,
  },
  {
    label: '14 days',
    value: `${DAY_IN_SECONDS * 14}`,
  },
  {
    label: '28 days',
    value: `${DAY_IN_SECONDS * 28}`,
  },
  {
    label: '56 days',
    value: `${DAY_IN_SECONDS * 56}`,
  },
]

const TestPeriods: Periods = [
  {
    label: '1 minute',
    value: '60',
  },
  {
    label: '5 minutes',
    value: `${60 * 5}`,
  },
  {
    label: '1 hour',
    value: `${60 * 60}`,
  },
]

const DefaultRecoveryDelayPeriods: Periods = [
  {
    label: 'Custom period',
    value: '0',
  },
  ...ExpirationPeriods,
]

const DefaultRecoveryExpirationPeriods: Periods = [
  {
    label: 'Never',
    value: '0',
  },
  ...ExpirationPeriods,
]

const TestRecoveryDelayPeriods: Periods = [
  {
    label: 'Custom period',
    value: '0',
  },
  ...TestPeriods,
  ...ExpirationPeriods,
]

const TestRecoveryExpirationPeriods: Periods = [
  {
    label: 'Never',
    value: '0',
  },
  ...TestPeriods,
  ...ExpirationPeriods,
]

export function useRecoveryPeriods(): { delay: Periods; expiration: Periods } {
  const chain = useCurrentChain()
  const isTestChain = chain && [chains.gor, chains.sep].includes(chain.chainId)

  // TODO: Remove constant before release

  if (isTestChain) {
    return {
      delay: TestRecoveryDelayPeriods,
      expiration: TestRecoveryExpirationPeriods,
    }
  }

  return {
    delay: DefaultRecoveryDelayPeriods,
    expiration: DefaultRecoveryExpirationPeriods,
  }
}
</file>

<file path="src/components/tx-flow/flows/UpsertRecovery/utils.ts">
import { DAY_IN_SECONDS } from './useRecoveryPeriods'

export const isCustomDelaySelected = (selectedDelay: string) => {
  return !Number(selectedDelay)
}

export const getDelay = (customDelay: string, selectedDelay: string) => {
  const isCustom = isCustomDelaySelected(selectedDelay)
  if (!isCustom) return selectedDelay
  return customDelay ? `${Number(customDelay) * DAY_IN_SECONDS}` : ''
}
</file>

<file path="src/components/tx-flow/flows/index.ts">
import dynamic from 'next/dynamic'

export const AddOwnerFlow = dynamic(() => import('./AddOwner'))
export const CancelRecoveryFlow = dynamic(() => import('./CancelRecovery'))
export const ChangeThresholdFlow = dynamic(() => import('./ChangeThreshold'))
export const ConfirmBatchFlow = dynamic(() => import('./ConfirmBatch'))
export const ConfirmTxFlow = dynamic(() => import('./ConfirmTx'))
export const ExecuteBatchFlow = dynamic(() => import('./ExecuteBatch'))
export const NewSpendingLimitFlow = dynamic(() => import('./NewSpendingLimit'))
export const NewTxFlow = dynamic(() => import('./NewTx'))
export const NftTransferFlow = dynamic(() => import('./NftTransfer'))
export const RecoverAccountFlow = dynamic(() => import('./RecoverAccount'))
export const RejectTxFlow = dynamic(() => import('./RejectTx'))
export const RemoveGuardFlow = dynamic(() => import('./RemoveGuard'))
export const RemoveModuleFlow = dynamic(() => import('./RemoveModule'))
export const RemoveOwnerFlow = dynamic(() => import('./RemoveOwner'))
export const RemoveRecoveryFlow = dynamic(() => import('./RemoveRecovery'))
export const RemoveSpendingLimitFlow = dynamic(() => import('./RemoveSpendingLimit'))
export const ReplaceOwnerFlow = dynamic(() => import('./ReplaceOwner'))
export const ReplaceTxFlow = dynamic(() => import('./ReplaceTx'))
export const SafeAppsTxFlow = dynamic(() => import('./SafeAppsTx'))
export const SignMessageFlow = dynamic(() => import('./SignMessage'))
export const SignMessageOnChainFlow = dynamic(() => import('./SignMessageOnChain'))
export const SuccessScreenFlow = dynamic(() => import('./SuccessScreen'))
export const NestedTxSuccessScreenFlow = dynamic(() => import('./NestedTxSuccessScreen'))
export const TokenTransferFlow = dynamic(() => import('./TokenTransfer'))
export const UpdateSafeFlow = dynamic(() => import('./UpdateSafe'))
export const MigrateSafeL2Flow = dynamic(() => import('./MigrateSafeL2'))
export const UpsertRecoveryFlow = dynamic(() => import('./UpsertRecovery'))
export const RecoveryAttemptFlow = dynamic(() => import('./RecoveryAttempt'))
</file>

<file path="src/components/tx-flow/slots/hooks/index.ts">
export * from './useRegisterSlot'
export * from './useSlotContext'
export * from './useSlot'
export * from './useSlotIds'
</file>

<file path="src/components/tx-flow/slots/hooks/useRegisterSlot.ts">
import { useEffect } from 'react'
import type { SlotItem, SlotName } from '../SlotProvider'
import { useSlotContext } from './useSlotContext'

export type UseRegisterSlotProps<T extends SlotName> = {
  slotName: T
  id: string
  Component: SlotItem<T>['Component']
  label?: SlotItem<T>['label']
  condition?: boolean
}

/**
 * Custom hook to register a slot with a condition.
 * This is useful for conditionally rendering components in specific slots.
 */
export const useRegisterSlot = <T extends SlotName>({
  slotName,
  id,
  Component,
  label,
  condition = true,
}: UseRegisterSlotProps<T>) => {
  const { registerSlot, unregisterSlot } = useSlotContext()

  useEffect(() => {
    if (condition) {
      registerSlot({ slotName, id, Component, label })
    } else {
      unregisterSlot(slotName, id)
    }

    return () => {
      unregisterSlot(slotName, id)
    }
  }, [condition, registerSlot, unregisterSlot, slotName, Component, label, id])
}
</file>

<file path="src/components/tx-flow/slots/hooks/useSlot.ts">
import { useMemo } from 'react'
import type { SlotName, SlotItem } from '../SlotProvider'
import { useSlotContext } from './useSlotContext'

export const useSlot = <T extends SlotName>(slotName: T, id?: string): SlotItem<T>[] => {
  const { getSlot } = useSlotContext()
  const slot = useMemo(() => getSlot(slotName, id), [getSlot, slotName, id])
  return slot
}
</file>

<file path="src/components/tx-flow/slots/hooks/useSlotContext.ts">
import { useContext } from 'react'
import { SlotContext } from '../SlotProvider'

export const useSlotContext = () => {
  const context = useContext(SlotContext)
  if (!context) {
    throw new Error('useSlotContext must be used within a SlotProvider')
  }
  return context
}
</file>

<file path="src/components/tx-flow/slots/hooks/useSlotIds.ts">
import { useMemo } from 'react'
import type { SlotName } from '../SlotProvider'
import { useSlotContext } from './useSlotContext'

export const useSlotIds = <T extends SlotName>(slotName: T): string[] => {
  const { getSlotIds } = useSlotContext()
  const slotIds = useMemo(() => getSlotIds(slotName), [getSlotIds, slotName])
  return slotIds
}
</file>

<file path="src/components/tx-flow/slots/index.ts">
export * from './Slot'
export * from './SlotProvider'
export * from './hooks'
export * from './withSlot'
</file>

<file path="src/components/tx-flow/slots/Slot.tsx">
import type { PropsWithChildren, ReactElement } from 'react'
import { type SlotComponentProps, type SlotName, useSlot } from '@/components/tx-flow/slots'

export type SlotProps<T extends SlotName> = PropsWithChildren<
  {
    name: T
    id?: string
  } & Omit<SlotComponentProps<T>, 'slotId'>
>

/**
 * Slot component for rendering components in specific slots.
 * It takes a slot name and an optional id to identify the slot.
 * If there are registered components for the slot, it renders them.
 * Otherwise, it renders the children passed to it as fallback.
 */
export const Slot = <T extends SlotName>({ name, id, children, ...rest }: SlotProps<T>): ReactElement => {
  const slotItems = useSlot(name, id)

  if (slotItems.length === 0) {
    return <>{children}</>
  }

  const props = { ...rest, slotId: id } as unknown as SlotComponentProps<T>

  return (
    <>
      {slotItems.map(({ Component, id }, i) => (
        <Component {...props} key={`slot-${name}-${i}-${id}`} />
      ))}
    </>
  )
}
</file>

<file path="src/components/tx-flow/slots/SlotProvider.tsx">
import React, {
  createContext,
  type ReactNode,
  type ComponentType,
  useState,
  useCallback,
  type PropsWithChildren,
} from 'react'
import type { SubmitCallback } from '../TxFlow'

export enum SlotName {
  Submit = 'submit',
  ComboSubmit = 'combo-submit',
  Feature = 'feature',
  Footer = 'footer',
  Sidebar = 'sidebar',
}

type SlotComponentPropsMap = {
  [SlotName.Submit]: PropsWithChildren<{
    onSubmit?: () => void
    onSubmitSuccess?: SubmitCallback
  }>
  [SlotName.ComboSubmit]: PropsWithChildren<{
    onSubmit?: () => void
    onSubmitSuccess?: SubmitCallback
    options: { label: string; id: string }[]
    onChange: (option: string) => void
    disabled?: boolean
  }>
}

type BaseSlotComponentProps = {
  slotId: string
}

export type SlotComponentProps<T extends SlotName> = T extends keyof SlotComponentPropsMap
  ? SlotComponentPropsMap[T] & BaseSlotComponentProps
  : BaseSlotComponentProps

type SlotContextType = {
  registerSlot: <T extends SlotName>(args: {
    slotName: T
    id: string
    Component: SlotItem<T>['Component']
    label?: SlotItem<T>['label']
  }) => void
  unregisterSlot: (slotName: SlotName, id: string) => void
  getSlot: <T extends SlotName>(slotName: T, id?: string) => SlotItem<T>[]
  getSlotIds: (slotName: SlotName) => string[]
}

export type SlotItem<S extends SlotName> = {
  Component: ComponentType<SlotComponentProps<S>>
  id: string
  label: string
}

type SlotStore = {
  [K in SlotName]?: {
    [id: string]: SlotItem<K> | null
  }
}

export const SlotContext = createContext<SlotContextType | null>(null)

/**
 * SlotProvider is a context provider for managing slots in the transaction flow.
 * It allows components to register and unregister themselves in specific slots,
 * and provides a way to retrieve the components registered in a slot.
 */
export const SlotProvider = ({ children }: { children: ReactNode }) => {
  const [slots, setSlots] = useState<SlotStore>({})

  const registerSlot = useCallback<SlotContextType['registerSlot']>(({ slotName, id, Component, label }) => {
    setSlots((prevSlots) => ({
      ...prevSlots,
      [slotName]: { ...prevSlots[slotName], [id]: { Component, label: label || id, id } },
    }))
  }, [])

  const unregisterSlot = useCallback((slotName: SlotName, id: string) => {
    setSlots((prevSlots) => ({
      ...prevSlots,
      [slotName]: { ...prevSlots[slotName], [id]: null },
    }))
  }, [])

  const getSlot = useCallback(
    <T extends SlotName>(slotName: T, id?: string): SlotItem<T>[] => {
      const slot = slots[slotName]

      if (id) {
        const slotItem = slot?.[id]
        if (slotItem) {
          return [slotItem]
        }
      }

      return Object.values(slot || {}).filter((component) => !!component) as SlotItem<T>[]
    },
    [slots],
  )

  const getSlotIds = useCallback(
    (slotName: SlotName): string[] => {
      const slot = slots[slotName]
      if (!slot) return []
      return Object.keys(slot).filter((id) => !!slot?.[id])
    },
    [slots],
  )

  return (
    <SlotContext.Provider value={{ registerSlot, unregisterSlot, getSlot, getSlotIds }}>
      {children}
    </SlotContext.Provider>
  )
}
</file>

<file path="src/components/tx-flow/slots/withSlot.tsx">
import type { PropsWithChildren } from 'react'
import type { SlotName } from './SlotProvider'
import { useRegisterSlot, type UseRegisterSlotProps } from './hooks'

/**
 * Higher-order component to register a slot with a condition.
 * This is useful for conditionally rendering components in specific slots.
 */
export const withSlot = <T extends SlotName>({
  Component,
  label,
  slotName,
  id,
  useSlotCondition = () => true,
}: Omit<UseRegisterSlotProps<T>, 'condition'> & {
  useSlotCondition: () => boolean
}) => {
  return ({ children }: PropsWithChildren) => {
    const shouldRegisterSlot = useSlotCondition()
    useRegisterSlot({ slotName, id, Component, label, condition: shouldRegisterSlot })
    return children
  }
}
</file>

<file path="src/components/tx-flow/index.tsx">
import { createContext, type ReactElement, type ReactNode, useState, useEffect, useCallback, useRef } from 'react'
import { usePathname } from 'next/navigation'
import TxModalDialog from '@/components/common/TxModalDialog'
import { SuccessScreenFlow, NestedTxSuccessScreenFlow } from './flows'
import useChainId from '@/hooks/useChainId'
import { useWalletContext } from '@/hooks/wallets/useWallet'
import { useSafeAddressFromUrl } from '@/hooks/useSafeAddressFromUrl'

const noop = () => {}

export type TxModalContextType = {
  txFlow: ReactElement | undefined
  setTxFlow: (txFlow: TxModalContextType['txFlow'], onClose?: () => void, shouldWarn?: boolean) => void
  setFullWidth: (fullWidth: boolean) => void
}

export const TxModalContext = createContext<TxModalContextType>({
  txFlow: undefined,
  setTxFlow: noop,
  setFullWidth: noop,
})

// TODO: Rename TxModalProvider, setTxFlow, TxModalDialog to not contain Tx since it can be used for any type of modal as a global provider
const confirmClose = () => {
  return confirm('Closing this window will discard your current progress.')
}

export const TxModalProvider = ({ children }: { children: ReactNode }): ReactElement => {
  const [txFlow, setFlow] = useState<TxModalContextType['txFlow']>(undefined)
  const [fullWidth, setFullWidth] = useState<boolean>(false)
  const shouldWarn = useRef<boolean>(true)
  const onClose = useRef<() => void>(noop)
  const safeId = useChainId() + useSafeAddressFromUrl()
  const prevSafeId = useRef<string>(safeId ?? '')
  const pathname = usePathname()
  const prevPathname = useRef<string | null>(pathname)
  const { setSignerAddress } = useWalletContext() ?? {}

  const handleModalClose = useCallback(() => {
    if (shouldWarn.current && !confirmClose()) {
      return
    }
    onClose.current()
    onClose.current = noop
    setFlow(undefined)

    setSignerAddress?.(undefined)
  }, [setSignerAddress])

  // Open a new tx flow, close the previous one if any
  const setTxFlow = useCallback(
    (newTxFlow: TxModalContextType['txFlow'], newOnClose?: () => void, newShouldWarn?: boolean) => {
      setFlow((prev) => {
        if (prev === newTxFlow) return prev

        // If a new flow is triggered, close the current one
        if (prev && newTxFlow && newTxFlow.type !== SuccessScreenFlow && newTxFlow.type !== NestedTxSuccessScreenFlow) {
          if (shouldWarn.current && !confirmClose()) {
            return prev
          }
          onClose.current()
        }

        onClose.current = newOnClose ?? noop
        shouldWarn.current = newShouldWarn ?? true

        return newTxFlow
      })
    },
    [],
  )

  // Close the modal when the user navigates to a different Safe or route
  useEffect(() => {
    if (safeId === prevSafeId.current && pathname === prevPathname.current) return

    prevSafeId.current = safeId
    prevPathname.current = pathname

    if (txFlow) {
      handleModalClose()
    }
  }, [txFlow, safeId, pathname, handleModalClose])

  return (
    <TxModalContext.Provider value={{ txFlow, setTxFlow, setFullWidth }}>
      {children}

      <TxModalDialog open={!!txFlow} onClose={handleModalClose} fullWidth={fullWidth}>
        {txFlow}
      </TxModalDialog>
    </TxModalContext.Provider>
  )
}
</file>

<file path="src/components/tx-flow/SafeTxProvider.tsx">
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { createContext, useState, useEffect } from 'react'
import type { Dispatch, ReactNode, SetStateAction, ReactElement } from 'react'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { createTx } from '@/services/tx/tx-sender'
import { useRecommendedNonce, useSafeTxGas } from '../tx/SignOrExecuteForm/hooks'
import { Errors, logError } from '@/services/exceptions'

export type SafeTxContextParams = {
  safeTx?: SafeTransaction
  setSafeTx: Dispatch<SetStateAction<SafeTransaction | undefined>>

  safeMessage?: TypedData
  setSafeMessage: Dispatch<SetStateAction<TypedData | undefined>>

  safeTxError?: Error
  setSafeTxError: Dispatch<SetStateAction<Error | undefined>>

  nonce?: number
  setNonce: Dispatch<SetStateAction<number | undefined>>
  nonceNeeded?: boolean
  setNonceNeeded: Dispatch<SetStateAction<boolean>>

  safeTxGas?: string
  setSafeTxGas: Dispatch<SetStateAction<string | undefined>>

  recommendedNonce?: number

  txOrigin?: string
  setTxOrigin: Dispatch<SetStateAction<string | undefined>>

  isMassPayout?: boolean
  setIsMassPayout: Dispatch<SetStateAction<boolean | undefined>>
}

export const SafeTxContext = createContext<SafeTxContextParams>({
  setSafeTx: () => {},
  setSafeMessage: () => {},
  setSafeTxError: () => {},
  setNonce: () => {},
  setNonceNeeded: () => {},
  setSafeTxGas: () => {},
  setTxOrigin: () => {},
  setIsMassPayout: () => {},
})

const SafeTxProvider = ({ children }: { children: ReactNode }): ReactElement => {
  const [safeTx, setSafeTx] = useState<SafeTransaction>()
  const [safeMessage, setSafeMessage] = useState<TypedData>()
  const [safeTxError, setSafeTxError] = useState<Error>()
  const [nonce, setNonce] = useState<number>()
  const [nonceNeeded, setNonceNeeded] = useState<boolean>(true)
  const [safeTxGas, setSafeTxGas] = useState<string>()
  const [txOrigin, setTxOrigin] = useState<string>()
  const [isMassPayout, setIsMassPayout] = useState<boolean>()

  // Signed txs cannot be updated
  const isSigned = safeTx && safeTx.signatures.size > 0

  // Recommended nonce and safeTxGas
  const recommendedNonce = useRecommendedNonce()
  const recommendedSafeTxGas = useSafeTxGas(safeTx)

  // Priority to external nonce, then to the recommended one
  const finalNonce = isSigned ? safeTx?.data.nonce : (nonce ?? recommendedNonce ?? safeTx?.data.nonce)
  const finalSafeTxGas = isSigned
    ? safeTx?.data.safeTxGas
    : (safeTxGas ?? recommendedSafeTxGas ?? safeTx?.data.safeTxGas)

  // Update the tx when the nonce or safeTxGas change
  useEffect(() => {
    if (isSigned || !safeTx?.data) return
    if (safeTx.data.nonce === finalNonce && safeTx.data.safeTxGas === finalSafeTxGas) return

    setSafeTxError(undefined)

    createTx({ ...safeTx.data, safeTxGas: String(finalSafeTxGas) }, finalNonce)
      .then((tx) => {
        setSafeTx(tx)
      })
      .catch(setSafeTxError)
  }, [isSigned, finalNonce, finalSafeTxGas, safeTx?.data])

  // Log errors
  useEffect(() => {
    safeTxError && logError(Errors._103, safeTxError)
  }, [safeTxError])

  return (
    <SafeTxContext.Provider
      value={{
        safeTx,
        safeTxError,
        setSafeTx,
        setSafeTxError,
        safeMessage,
        setSafeMessage,
        nonce: finalNonce,
        setNonce,
        nonceNeeded,
        setNonceNeeded,
        safeTxGas: finalSafeTxGas,
        setSafeTxGas,
        recommendedNonce,
        txOrigin,
        setTxOrigin,
        isMassPayout,
        setIsMassPayout,
      }}
    >
      {children}
    </SafeTxContext.Provider>
  )
}

export default SafeTxProvider
</file>

<file path="src/components/tx-flow/TxFlow.tsx">
import React, { useCallback, useMemo, type ReactNode } from 'react'
import useTxStepper from './useTxStepper'
import SafeTxProvider from './SafeTxProvider'
import { TxInfoProvider } from './TxInfoProvider'
import { TxSecurityProvider } from '../tx/security/shared/TxSecurityContext'
import TxFlowProvider, { type TxFlowContextType } from './TxFlowProvider'
import { TxFlowContent } from './common/TxFlowContent'
import ReviewTransaction from '../tx/ReviewTransactionV2'
import { ConfirmTxReceipt } from '../tx/ConfirmTxReceipt'
import { TxChecks, TxNote, SignerSelect } from './features'
import { Batching, ComboSubmit, Counterfactual, Execute, ExecuteThroughRole, Propose, Sign } from './actions'
import { SlotProvider } from './slots'

type SubmitCallbackProps = { txId?: string; isExecuted?: boolean }
export type SubmitCallback = (args?: SubmitCallbackProps) => void
export type SubmitCallbackWithData<T> = (args: SubmitCallbackProps & { data?: T }) => void

type TxFlowProps<T extends unknown> = {
  children?: ReactNode[] | ReactNode
  initialData?: T
  txId?: string
  onSubmit?: SubmitCallbackWithData<T>
  onlyExecute?: boolean
  isExecutable?: boolean
  isRejection?: boolean
  ReviewTransactionComponent?: typeof ReviewTransaction
  eventCategory?: string
} & TxFlowContextType['txLayoutProps']

/**
 * TxFlow component is a wrapper for the transaction flow, providing context and state management.
 * It uses various providers to manage the transaction state and security context.
 * The component also handles the transaction steps and progress.
 * It accepts children components to be rendered within the flow.
 */
export const TxFlow = <T extends unknown>({
  children = [],
  initialData,
  txId,
  onSubmit,
  onlyExecute,
  isExecutable,
  isRejection,
  ReviewTransactionComponent = ReviewTransaction,
  eventCategory,
  ...txLayoutProps
}: TxFlowProps<T>) => {
  const { step, data, nextStep, prevStep } = useTxStepper(initialData, eventCategory)

  const childrenArray = Array.isArray(children) ? children : [children]

  const progress = useMemo(
    () => Math.round(((step + 1) / (childrenArray.length + 2)) * 100),
    [step, childrenArray.length],
  )

  const handleFlowSubmit = useCallback<SubmitCallback>(
    (props) => {
      onSubmit?.({ ...props, data })
    },
    [onSubmit, data],
  )

  const submit = (
    <>
      <Counterfactual />
      <ExecuteThroughRole />

      <ComboSubmit>
        <Sign />
        <Execute />
        <Batching />
      </ComboSubmit>

      <Propose />
    </>
  )

  return (
    <SafeTxProvider>
      <TxInfoProvider>
        <TxSecurityProvider>
          <SlotProvider>
            <TxFlowProvider
              step={step}
              data={data}
              nextStep={nextStep}
              prevStep={prevStep}
              progress={progress}
              txId={txId}
              txLayoutProps={txLayoutProps}
              onlyExecute={onlyExecute}
              isExecutable={isExecutable}
              isRejection={isRejection}
            >
              <TxFlowContent>
                {...childrenArray}

                <ReviewTransactionComponent onSubmit={handleFlowSubmit}>
                  <TxChecks />
                  <TxNote />
                  <SignerSelect />

                  {submit}
                </ReviewTransactionComponent>

                <ConfirmTxReceipt onSubmit={handleFlowSubmit}>{submit}</ConfirmTxReceipt>
              </TxFlowContent>
            </TxFlowProvider>
          </SlotProvider>
        </TxSecurityProvider>
      </TxInfoProvider>
    </SafeTxProvider>
  )
}
</file>

<file path="src/components/tx-flow/TxFlowProvider.tsx">
import { createContext, useCallback, useContext, useState } from 'react'
import type { ReactNode, ReactElement, SetStateAction, Dispatch, ComponentType } from 'react'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useIsWalletProposer } from '@/hooks/useProposers'
import { useImmediatelyExecutable, useValidateNonce } from '@/components/tx/SignOrExecuteForm/hooks'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'
import {
  findAllowingRole,
  findMostLikelyRole,
  type Role,
  useRoles,
} from '@/components/tx-flow/actions/ExecuteThroughRole/ExecuteThroughRoleForm/hooks'
import { SafeTxContext } from '../tx-flow/SafeTxProvider'
import { useLazyGetTransactionDetailsQuery } from '@/store/slices'
import { trackTxEvents } from '../tx/SignOrExecuteForm/tracking'
import { useSigner } from '@/hooks/wallets/useWallet'
import useChainId from '@/hooks/useChainId'
import useIsCounterfactualSafe from '@/features/counterfactual/hooks/useIsCounterfactualSafe'
import useTxDetails from '@/hooks/useTxDetails'
import type { TransactionDetails, TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'

export type TxFlowContextType<T extends unknown = any> = {
  step: number
  progress: number
  data?: T
  onPrev: () => void
  onNext: (data?: T) => void

  txLayoutProps: {
    title?: ReactNode
    subtitle?: ReactNode
    icon?: ComponentType
    txSummary?: TransactionSummary
    hideNonce?: boolean
    fixedNonce?: boolean
    hideProgress?: boolean
    isReplacement?: boolean
    isMessage?: boolean
  }
  updateTxLayoutProps: (props: TxFlowContextType['txLayoutProps']) => void
  trackTxEvent: (txId: string, isExecuted?: boolean, isRoleExecution?: boolean, isProposerCreation?: boolean) => void

  txId?: string
  isCreation: boolean
  isRejection: boolean
  onlyExecute: boolean
  isProposing: boolean
  willExecute: boolean
  isExecutable: boolean
  canExecute: boolean
  shouldExecute: boolean
  setShouldExecute: Dispatch<SetStateAction<boolean>>

  isSubmittable: boolean
  setIsSubmittable: Dispatch<SetStateAction<boolean>>
  submitError?: Error
  setSubmitError: Dispatch<SetStateAction<Error | undefined>>
  isRejectedByUser: boolean
  setIsRejectedByUser: Dispatch<SetStateAction<boolean>>

  willExecuteThroughRole: boolean
  canExecuteThroughRole: boolean
  txDetails?: TransactionDetails
  txDetailsLoading?: boolean
  isBatch: boolean
  role?: Role
}

export const initialContext: TxFlowContextType = {
  step: 0,
  progress: 0,
  data: undefined,
  onPrev: () => {},
  onNext: () => {},

  txLayoutProps: {},
  updateTxLayoutProps: () => {},
  trackTxEvent: () => {},

  isCreation: false,
  isRejection: false,
  onlyExecute: false,
  isProposing: false,
  willExecute: false,
  isExecutable: false,
  canExecute: false,
  shouldExecute: false,
  setShouldExecute: () => {},

  isSubmittable: true,
  setIsSubmittable: () => {},
  submitError: undefined,
  setSubmitError: () => {},
  isRejectedByUser: false,
  setIsRejectedByUser: () => {},

  willExecuteThroughRole: false,
  canExecuteThroughRole: false,
  isBatch: false,
}

export const TxFlowContext = createContext<TxFlowContextType>(initialContext)

export type TxFlowProviderProps<T extends unknown> = {
  children: ReactNode
  step: number
  data: T
  prevStep: () => void
  nextStep: (data: T) => void
  progress?: number
  txId?: string
  isExecutable?: boolean
  onlyExecute?: TxFlowContextType['onlyExecute']
  isRejection?: TxFlowContextType['isRejection']
  txLayoutProps?: TxFlowContextType['txLayoutProps']
  isBatch?: TxFlowContextType['isBatch']
}

const TxFlowProvider = <T extends unknown>({
  children,
  step,
  data,
  nextStep,
  prevStep,
  progress = 0,
  txId,
  isExecutable = false,
  onlyExecute = initialContext.onlyExecute,
  txLayoutProps: defaultTxLayoutProps = initialContext.txLayoutProps,
  isRejection = initialContext.isRejection,
  isBatch = initialContext.isBatch,
}: TxFlowProviderProps<T>): ReactElement => {
  const signer = useSigner()
  const isSafeOwner = useIsSafeOwner()
  const isProposer = useIsWalletProposer()
  const chainId = useChainId()
  const { safeTx, txOrigin, isMassPayout } = useContext(SafeTxContext)
  const isCorrectNonce = useValidateNonce(safeTx)
  const { transactionExecution } = useAppSelector(selectSettings)
  const [shouldExecute, setShouldExecute] = useState<boolean>(transactionExecution)
  const [isSubmittable, setIsSubmittable] = useState<boolean>(initialContext.isSubmittable)
  const [submitError, setSubmitError] = useState<Error | undefined>(initialContext.submitError)
  const [isRejectedByUser, setIsRejectedByUser] = useState<boolean>(initialContext.isRejectedByUser)
  const [txLayoutProps, setTxLayoutProps] = useState<TxFlowContextType['txLayoutProps']>(defaultTxLayoutProps)
  const [trigger] = useLazyGetTransactionDetailsQuery()
  const isCounterfactualSafe = useIsCounterfactualSafe()
  const [txDetails, , txDetailsLoading] = useTxDetails(txId)

  const isCreation = !txId
  const isNewExecutableTx = useImmediatelyExecutable() && isCreation

  const isProposing = !!isProposer && !isSafeOwner && isCreation

  // Check if a Zodiac Roles mod is enabled and if the user is a member of any role that allows the transaction
  const roles = useRoles(
    !isCounterfactualSafe && isCreation && !(isNewExecutableTx && isSafeOwner) ? safeTx : undefined,
  )
  const allowingRole = findAllowingRole(roles)
  const mostLikelyRole = findMostLikelyRole(roles)
  const canExecuteThroughRole = !!allowingRole || (!!mostLikelyRole && !isSafeOwner)
  const preferThroughRole = canExecuteThroughRole && !isSafeOwner // execute through role if a non-owner role member wallet is connected

  // If checkbox is checked and the transaction is executable, execute it, otherwise sign it
  const canExecute = isCorrectNonce && (isExecutable || isNewExecutableTx)
  const willExecute = (onlyExecute || shouldExecute) && canExecute && !preferThroughRole
  const willExecuteThroughRole =
    (onlyExecute || shouldExecute) && canExecuteThroughRole && (!canExecute || preferThroughRole)

  const updateTxLayoutProps = useCallback((props: TxFlowContextType['txLayoutProps']) => {
    setTxLayoutProps({ ...defaultTxLayoutProps, ...props })
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const trackTxEvent = useCallback(
    async (txId: string, isExecuted = false, isRoleExecution = false, isProposerCreation = false) => {
      const { data: details } = await trigger({ chainId, txId })
      // Track tx event
      trackTxEvents(
        details,
        !!isCreation,
        isExecuted,
        isRoleExecution,
        isProposerCreation,
        !!signer?.isSafe,
        txOrigin,
        isMassPayout,
      )
    },
    [chainId, isCreation, trigger, signer?.isSafe, txOrigin, isMassPayout],
  )

  const value = {
    step,
    progress,
    data,
    onPrev: prevStep,
    onNext: nextStep,

    txLayoutProps,
    updateTxLayoutProps,
    trackTxEvent,

    txId,
    isCreation,
    isRejection,
    onlyExecute,
    isProposing,
    isExecutable,
    canExecute,
    willExecute,
    shouldExecute,
    setShouldExecute,

    isSubmittable,
    setIsSubmittable,
    submitError,
    setSubmitError,
    isRejectedByUser,
    setIsRejectedByUser,

    willExecuteThroughRole,
    canExecuteThroughRole,
    role: allowingRole || mostLikelyRole,
    txDetails,
    txDetailsLoading,
    isBatch,
  }

  return <TxFlowContext.Provider value={value}>{children}</TxFlowContext.Provider>
}

export default TxFlowProvider
</file>

<file path="src/components/tx-flow/TxFlowStep.tsx">
import React, { type ReactNode, useContext, useEffect } from 'react'
import { TxFlowContext, type TxFlowContextType } from '../tx-flow/TxFlowProvider'

export type TxFlowStepProps = TxFlowContextType['txLayoutProps'] & { children?: ReactNode }

/**
 * TxFlowStep is a component that allows you to set the layout properties for a transaction flow step.
 * It uses the TxFlowContext to update the layout properties when the component is mounted.
 */
export const TxFlowStep = ({ children, ...txLayoutProps }: TxFlowStepProps) => {
  const { updateTxLayoutProps } = useContext(TxFlowContext)

  useEffect(() => {
    updateTxLayoutProps(txLayoutProps)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return <>{children}</>
}
</file>

<file path="src/components/tx-flow/TxInfoProvider.tsx">
import { createContext, type ReactElement } from 'react'

import { useSimulation } from '@/components/tx/security/tenderly/useSimulation'
import { FETCH_STATUS, type TenderlySimulation } from '@safe-global/utils/components/tx/security/tenderly/types'
import type { UseSimulationReturn } from '@safe-global/utils/components/tx/security/tenderly/useSimulation'

const getCallTraceErrors = (simulation?: TenderlySimulation) => {
  if (!simulation || !simulation.simulation.status) {
    return []
  }

  return simulation.transaction.call_trace.filter((call) => call.error)
}

type SimulationStatus = {
  isLoading: boolean
  isFinished: boolean
  isSuccess: boolean
  isCallTraceError: boolean
  isError: boolean
}

export const TxInfoContext = createContext<{
  simulation: UseSimulationReturn
  status: SimulationStatus
}>({
  simulation: {
    simulateTransaction: () => {},
    simulation: undefined,
    _simulationRequestStatus: FETCH_STATUS.NOT_ASKED,
    simulationLink: '',
    requestError: undefined,
    resetSimulation: () => {},
  },
  status: {
    isLoading: false,
    isFinished: false,
    isSuccess: false,
    isCallTraceError: false,
    isError: false,
  },
})

export const TxInfoProvider = ({ children }: { children: ReactElement }) => {
  const simulation = useSimulation()

  const isLoading = simulation._simulationRequestStatus === FETCH_STATUS.LOADING

  const isFinished =
    simulation._simulationRequestStatus === FETCH_STATUS.SUCCESS ||
    simulation._simulationRequestStatus === FETCH_STATUS.ERROR

  const isSuccess = simulation.simulation?.simulation.status || false

  // Safe can emit failure event even though Tenderly simulation succeeds
  const isCallTraceError = isSuccess && getCallTraceErrors(simulation.simulation).length > 0
  const isError = simulation._simulationRequestStatus === FETCH_STATUS.ERROR

  const status = {
    isLoading,
    isFinished,
    isSuccess,
    isCallTraceError,
    isError,
  }

  return <TxInfoContext.Provider value={{ simulation, status }}>{children}</TxInfoContext.Provider>
}
</file>

<file path="src/components/tx-flow/useTxStepper.tsx">
import { MODAL_NAVIGATION, trackEvent } from '@/services/analytics'
import { useCallback, useState } from 'react'

const useTxStepper = <T extends unknown>(initialData: T, eventCategory?: string) => {
  const [step, setStep] = useState(0)
  const [data, setData] = useState<T>(initialData)

  const nextStep = useCallback(
    (entireData?: T) => {
      if (entireData) setData(entireData)

      setStep((prevStep) => {
        if (eventCategory) {
          trackEvent({ action: MODAL_NAVIGATION.Next, category: eventCategory, label: prevStep })
        }

        return prevStep + 1
      })
    },
    [eventCategory],
  )

  const prevStep = useCallback(() => {
    setStep((prevStep) => {
      if (eventCategory) {
        trackEvent({ action: MODAL_NAVIGATION.Back, category: eventCategory, label: prevStep })
      }
      return prevStep - 1
    })
  }, [eventCategory])

  return { step, data, nextStep, prevStep }
}

export default useTxStepper
</file>

<file path="src/components/welcome/WelcomeLogin/index.tsx">
import { AppRoutes } from '@/config/routes'
import { Paper, SvgIcon, Typography, Divider, Box, Button, Link } from '@mui/material'
import SafeLogo from '@/public/images/logo-text.svg'
import css from './styles.module.css'
import { useRouter } from 'next/router'
import { CREATE_SAFE_EVENTS } from '@/services/analytics/events/createLoadSafe'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS, trackEvent } from '@/services/analytics'
import useWallet from '@/hooks/wallets/useWallet'
import useHasSafes from '@/features/myAccounts/hooks/useHasSafes'
import Track from '@/components/common/Track'
import { useCallback, useEffect, useState } from 'react'
import WalletLogin from './WalletLogin'

const WelcomeLogin = () => {
  const router = useRouter()
  const wallet = useWallet()
  const { isLoaded, hasSafes } = useHasSafes()
  const [shouldRedirect, setShouldRedirect] = useState(false)

  const redirect = useCallback(() => {
    if (wallet) {
      if (isLoaded && !hasSafes) {
        trackEvent(CREATE_SAFE_EVENTS.OPEN_SAFE_CREATION)
        router.push({ pathname: AppRoutes.newSafe.create, query: router.query })
      } else {
        router.push({ pathname: AppRoutes.welcome.accounts, query: router.query })
      }
    }
  }, [hasSafes, isLoaded, router, wallet])

  const onLogin = useCallback(() => {
    setShouldRedirect(true)
  }, [])

  useEffect(() => {
    if (!shouldRedirect) return
    redirect()
  }, [redirect, shouldRedirect])

  return (
    <Paper className={css.loginCard} data-testid="welcome-login">
      <Box className={css.loginContent}>
        <SvgIcon component={SafeLogo} inheritViewBox sx={{ height: '24px', width: '80px', ml: '-8px' }} />

        <Typography variant="h6" mt={6} fontWeight={700}>
          Get started
        </Typography>

        <Typography mb={2} textAlign="center">
          {wallet
            ? 'Open your existing Safe Accounts or create a new one'
            : 'Connect your wallet to create a new Safe Account or open an existing one'}
        </Typography>

        <Track {...OVERVIEW_EVENTS.OPEN_ONBOARD} label={OVERVIEW_LABELS.welcome_page}>
          <WalletLogin onLogin={onLogin} onContinue={redirect} />
        </Track>

        {!wallet && (
          <>
            <Divider sx={{ mt: 2, mb: 2, width: '100%' }}>
              <Typography color="text.secondary" fontWeight={700} variant="overline">
                or
              </Typography>
            </Divider>
            {hasSafes ? (
              <Link href={AppRoutes.welcome.accounts}>
                <Button disableElevation size="small">
                  View my accounts
                </Button>
              </Link>
            ) : (
              <Link href={AppRoutes.newSafe.load}>
                <Button disableElevation size="small">
                  Watch any account
                </Button>
              </Link>
            )}
          </>
        )}
      </Box>
    </Paper>
  )
}

export default WelcomeLogin
</file>

<file path="src/components/welcome/WelcomeLogin/styles.module.css">
.loginCard {
  width: 100%;
  height: 100%;
  display: flex;
  border-radius: 6px;
  justify-content: center;
  align-items: center;
  padding: var(--space-2);
}

.loginContent {
  display: flex;
  height: 100%;
  width: 320px;
  gap: var(--space-1);
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
</file>

<file path="src/components/welcome/WelcomeLogin/WalletLogin.tsx">
import useConnectWallet from '@/components/common/ConnectWallet/useConnectWallet'
import useWallet from '@/hooks/wallets/useWallet'
import { Box, Button, Typography } from '@mui/material'
import EthHashInfo from '@/components/common/EthHashInfo'
import WalletIcon from '@/components/common/WalletIcon'

const WalletLogin = ({
  onLogin,
  onContinue,
  buttonText,
}: {
  onLogin: () => void
  onContinue: () => void
  buttonText?: string
}) => {
  const wallet = useWallet()
  const connectWallet = useConnectWallet()

  const onConnectWallet = () => {
    connectWallet()
    onLogin()
  }

  if (wallet !== null) {
    return (
      <Button variant="contained" sx={{ padding: '8px 16px' }} onClick={onContinue}>
        <Box justifyContent="space-between" display="flex" flexDirection="row" alignItems="center" gap={1}>
          <Box display="flex" flexDirection="column" alignItems="flex-start">
            <Typography variant="subtitle2" fontWeight={700}>
              {buttonText || 'Continue with'} {wallet.label}
            </Typography>
            {wallet.address && (
              <EthHashInfo address={wallet.address} shortAddress avatarSize={16} showName={false} copyAddress={false} />
            )}
          </Box>
          {wallet.icon && <WalletIcon icon={wallet.icon} provider={wallet.label} width={24} height={24} />}
        </Box>
      </Button>
    )
  }

  return (
    <Button onClick={onConnectWallet} sx={{ minHeight: '42px' }} variant="contained" size="small" disableElevation>
      Connect wallet
    </Button>
  )
}

export default WalletLogin
</file>

<file path="src/components/welcome/NewSafe.tsx">
import React from 'react'
import { Grid, SvgIcon, Typography } from '@mui/material'
import css from './styles.module.css'
import CheckFilled from '@/public/images/common/check-filled.svg'

import WelcomeLogin from './WelcomeLogin'

const BulletListItem = ({ text }: { text: string }) => (
  <li>
    <SvgIcon className={css.checkIcon} component={CheckFilled} inheritViewBox />
    <Typography
      sx={{
        color: 'static.main',
        fontWeight: 700,
      }}
    >
      {text}
    </Typography>
  </li>
)

const NewSafe = () => {
  return (
    <>
      <Grid
        container
        spacing={3}
        direction="row-reverse"
        sx={{
          p: 3,
          pb: 0,
          flex: 1,
        }}
      >
        <Grid item xs={12} lg={6}>
          <WelcomeLogin />
        </Grid>
        <Grid
          item
          xs={12}
          lg={6}
          sx={{
            flex: 1,
          }}
        >
          <div className={css.content}>
            <Typography
              variant="h1"
              sx={{
                fontSize: [44, null, 52],
                lineHeight: 1,
                letterSpacing: -1.5,
                color: 'static.main',
              }}
            >
              Unlock a new way of ownership
            </Typography>

            <Typography
              sx={{
                mb: 1,
                color: 'static.main',
              }}
            >
              The most trusted decentralized custody protocol and collective asset management platform.
            </Typography>

            <ul className={css.bulletList}>
              <BulletListItem text="Stealth security with multiple signers" />
              <BulletListItem text="Make it yours with modules and guards" />
              <BulletListItem text="Access 130+ ecosystem apps" />
            </ul>
          </div>
        </Grid>
      </Grid>
    </>
  )
}

export default NewSafe
</file>

<file path="src/components/welcome/styles.module.css">
.bulletList {
  list-style: none;
  margin-bottom: auto;
  padding: 0;
}

.bulletList li {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  align-items: center;
  margin-bottom: var(--space-2);
}

.numberList {
  margin: var(--space-5) 0;
  padding: 0;
  list-style: none;
}

.numberList li {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  align-items: center;
  margin-bottom: var(--space-2);
  counter-increment: item;
}

.numberList li:before {
  margin-right: var(--space-1);
  content: counter(item);
  background: var(--color-static-main);
  border-radius: 100%;
  color: white;
  width: 32px;
  height: 32px;
  line-height: 32px;
  font-size: 18px;
  text-align: center;
  flex-shrink: 0;
}

.marquee {
  display: flex;
  overflow: hidden;
  user-select: none;
  gap: var(--space-6);
  background-color: var(--color-static-main);
  color: white;
  padding: 20px;
  margin: var(--space-3) calc(-1 * var(--space-9)) calc(-1 * var(--space-3));
}

.marqueeContent {
  margin: 0;
  padding: 0;
  flex-shrink: 0;
  display: flex;
  justify-content: space-around;
  min-width: 100%;
  gap: var(--space-6);
  animation: scroll 10s linear infinite;
}

.marqueeItem {
  font-size: 18px;
  display: flex;
  align-items: center;
}

.marqueeItem img {
  margin: 0 var(--space-1);
}

.content {
  background: linear-gradient(-90deg, #10ff84, #5fddff);
  background-size: 200% 200%;
  animation: gradient 15s ease infinite;
  border-radius: 6px;
  padding: var(--space-9);
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: var(--space-2);
  width: 100%;
  height: 100%;
}

.checkIcon {
  color: var(--color-static-main);
}

.button {
  color: var(--color-static-main);
}

@media (max-width: 899.95px) {
  .content {
    padding: var(--space-6);
  }

  .marquee {
    margin: var(--space-3) calc(-1 * var(--space-6)) calc(-1 * var(--space-3));
  }
}

@media (max-width: 599.95px) {
  .content {
    padding: var(--space-4);
  }

  .marquee {
    margin: var(--space-3) calc(-1 * var(--space-4)) 0;
  }
}

@keyframes gradient {
  0% {
    background-position: 0 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0 50%;
  }
}

@keyframes scroll {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(calc(-100% - var(--space-6)));
  }
}
</file>

<file path="src/components/wrappers/DisclaimerWrapper/index.tsx">
import { Stack } from '@mui/material'
import type { ReactElement } from 'react'

import Disclaimer from '@/components/common/Disclaimer'
import WidgetDisclaimer from '@/components/common/WidgetDisclaimer'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import madProps from '@/utils/mad-props'

// TODO: Use with swaps/staking
export function _DisclaimerWrapper({
  children,
  localStorageKey,
  widgetName,
  getLocalStorage,
}: {
  children: ReactElement
  localStorageKey: string
  widgetName: string
  getLocalStorage: typeof useLocalStorage
}): ReactElement | null {
  const [hasConsented = false, setHasConsented] = getLocalStorage<boolean>(localStorageKey)

  const onAccept = () => {
    setHasConsented(true)
  }

  if (!hasConsented) {
    return (
      <Stack direction="column" alignItems="center" justifyContent="center" flex={1}>
        <Disclaimer
          title="Note"
          content={<WidgetDisclaimer widgetName={widgetName} />}
          onAccept={onAccept}
          buttonText="Continue"
        />
      </Stack>
    )
  }

  return children
}

export const DisclaimerWrapper = madProps(_DisclaimerWrapper, {
  getLocalStorage: () => useLocalStorage,
})
</file>

<file path="src/components/wrappers/FeatureWrapper/index.tsx">
import type { ReactElement } from 'react'

import { Navigate } from '@/components/common/Navigate'
import { useHasFeature } from '@/hooks/useChains'
import madProps from '@/utils/mad-props'

import type { FEATURES } from '@safe-global/utils/utils/chains'

// TODO: Use with swaps/staking
export function _FeatureWrapper({
  children,
  feature,
  fallbackRoute,
  isFeatureEnabled,
}: {
  children: ReactElement
  feature: FEATURES
  fallbackRoute: string
  isFeatureEnabled: typeof useHasFeature
}): ReactElement | null {
  const isEnabled = isFeatureEnabled(feature)

  if (isEnabled === undefined) {
    return null
  }

  if (isEnabled === false) {
    return <Navigate to={fallbackRoute} replace />
  }

  return children
}

export const FeatureWrapper = madProps(_FeatureWrapper, {
  isFeatureEnabled: () => useHasFeature,
})
</file>

<file path="src/components/wrappers/SanctionWrapper/index.tsx">
import { Stack } from '@mui/material'
import { skipToken } from '@reduxjs/toolkit/query'
import type { ReactElement } from 'react'

import BlockedAddress from '@/components/common/BlockedAddress'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWallet from '@/hooks/wallets/useWallet'
import { useGetIsSanctionedQuery } from '@/store/api/ofac'
import { getKeyWithTrueValue } from '@/utils/helpers'
import madProps from '@/utils/mad-props'

// TODO: Use with swaps/staking
export function _SanctionWrapper({
  children,
  featureTitle,
  getSafeInfo,
  getWallet,
  isSanctioned,
}: {
  children: ReactElement
  featureTitle: string
  getSafeInfo: typeof useSafeInfo
  getWallet: typeof useWallet
  isSanctioned: typeof useGetIsSanctionedQuery
}): ReactElement | null {
  const { safeAddress } = getSafeInfo()
  const wallet = getWallet()

  const { data: isSafeAddressBlocked = false } = isSanctioned(safeAddress || skipToken)
  const { data: isWalletAddressBlocked = false } = isSanctioned(wallet?.address || skipToken)

  const blockedAddress = getKeyWithTrueValue({
    [safeAddress]: !!isSafeAddressBlocked,
    [wallet?.address || '']: !!isWalletAddressBlocked,
  })

  if (blockedAddress) {
    return (
      <Stack direction="column" alignItems="center" justifyContent="center" flex={1}>
        <BlockedAddress address={blockedAddress} featureTitle={featureTitle} />
      </Stack>
    )
  }

  return children
}

export const SanctionWrapper = madProps(_SanctionWrapper, {
  getWallet: () => useWallet,
  getSafeInfo: () => useSafeInfo,
  isSanctioned: () => useGetIsSanctionedQuery,
})
</file>

<file path="src/config/chains.ts">
import { networks } from '@safe-global/protocol-kit/dist/src/utils/eip-3770/config'

/**
 * A static shortName<->chainId dictionary
 * E.g.:
 *
 * {
 *   eth: '1',
 *   gor: '5',
 *   ...
 * }
 */
type Chains = Record<string, string>

const chains = networks.reduce<Chains>((result, { shortName, chainId }) => {
  result[shortName] = chainId.toString()
  return result
}, {})

export default chains
</file>

<file path="src/config/constants.ts">
import chains from './chains'

export const IS_PRODUCTION = process.env.NEXT_PUBLIC_IS_PRODUCTION === 'true'
export const IS_DEV = process.env.NODE_ENV === 'development'

// default chain ID's as provided to the environment
export const DEFAULT_TESTNET_CHAIN_ID = +(process.env.NEXT_PUBLIC_DEFAULT_TESTNET_CHAIN_ID ?? chains.sep)
export const DEFAULT_MAINNET_CHAIN_ID = +(process.env.NEXT_PUBLIC_DEFAULT_MAINNET_CHAIN_ID ?? chains.eth)

// default chain ID used in the application
export const DEFAULT_CHAIN_ID = IS_PRODUCTION ? DEFAULT_MAINNET_CHAIN_ID : DEFAULT_TESTNET_CHAIN_ID

export const GATEWAY_URL_PRODUCTION =
  process.env.NEXT_PUBLIC_GATEWAY_URL_PRODUCTION || 'https://safe-client.safe.global'
export const GATEWAY_URL_STAGING = process.env.NEXT_PUBLIC_GATEWAY_URL_STAGING || 'https://safe-client.staging.5afe.dev'

// Magic numbers
export const POLLING_INTERVAL = 15_000
export const BASE_TX_GAS = 21_000
export const LS_NAMESPACE = 'SAFE_v2__'

export const SENTRY_DSN = process.env.NEXT_PUBLIC_SENTRY_DSN || ''
export const BEAMER_ID = process.env.NEXT_PUBLIC_BEAMER_ID || ''
export const DATADOG_CLIENT_TOKEN = process.env.NEXT_PUBLIC_DATADOG_CLIENT_TOKEN || ''

// Wallets
export const WC_PROJECT_ID = process.env.NEXT_PUBLIC_WC_PROJECT_ID || ''
export const TREZOR_APP_URL = 'app.safe.global'
export const TREZOR_EMAIL = 'support@safe.global'

// Safe Token
export const SAFE_TOKEN_ADDRESSES: { [chainId: string]: string } = {
  [chains.eth]: '0x5aFE3855358E112B5647B952709E6165e1c1eEEe',
  [chains.sep]: '0xd16d9C09d13E9Cf77615771eADC5d51a1Ae92a26',
}

export const SAFE_LOCKING_ADDRESS: { [chainId: string]: string } = {
  [chains.eth]: '0x0a7CB434f96f65972D46A5c1A64a9654dC9959b2',
  [chains.sep]: '0xb161ccb96b9b817F9bDf0048F212725128779DE9',
}

export const SAFE_APPS_THIRD_PARTY_COOKIES_CHECK_URL = 'https://third-party-cookies-check.gnosis-safe.com'
export const SAFE_APPS_DEMO_SAFE_MAINNET = 'eth:0xfF501B324DC6d78dC9F983f140B9211c3EdB4dc7'
export const SAFE_APPS_SDK_DOCS_URL =
  'https://help.safe.global/en/articles/145503-how-to-create-a-safe-app-with-safe-apps-sdk-and-list-it'

// Google Analytics
export const PROD_GA_TRACKING_ID = process.env.NEXT_PUBLIC_PROD_GA_TRACKING_ID || ''
export const TEST_GA_TRACKING_ID = process.env.NEXT_PUBLIC_TEST_GA_TRACKING_ID || ''
export const SAFE_APPS_GA_TRACKING_ID = process.env.NEXT_PUBLIC_SAFE_APPS_GA_TRACKING_ID || ''
export const GA_TRACKING_ID = IS_PRODUCTION ? PROD_GA_TRACKING_ID : TEST_GA_TRACKING_ID

// Safe Apps tags
export enum SafeAppsTag {
  NFT = 'nft',
  TX_BUILDER = 'transaction-builder',
  SAFE_GOVERNANCE_APP = 'safe-governance-app',
  ONRAMP = 'onramp',
  RECOVERY_SYGNUM = 'recovery-sygnum',
}

// Safe Apps names
export enum SafeAppsName {
  CSV = 'CSV Airdrop',
}

// Help Center
export const HELP_CENTER_URL = 'https://help.safe.global'
export const HelpCenterArticle = {
  ADDRESS_BOOK_DATA: `${HELP_CENTER_URL}/en/articles/40811-address-book-export-and-import`,
  ADVANCED_PARAMS: `${HELP_CENTER_URL}/en/articles/40837-advanced-transaction-parameters`,
  CANCELLING_TRANSACTIONS: `${HELP_CENTER_URL}/en/articles/40836-why-do-i-need-to-pay-for-cancelling-a-transaction`,
  COOKIES: `${HELP_CENTER_URL}/en/articles/40797-why-do-i-need-to-enable-third-party-cookies-for-safe-apps`,
  CONFLICTING_TRANSACTIONS: `${HELP_CENTER_URL}/en/articles/40839-why-are-transactions-with-the-same-nonce-conflicting-with-each-other`,
  FALLBACK_HANDLER: `${HELP_CENTER_URL}/en/articles/40838-what-is-a-fallback-handler-and-how-does-it-relate-to-safe`,
  MOBILE_SAFE: `${HELP_CENTER_URL}/en/articles/40801-connect-to-web-with-mobile-safe`,
  RECOVERY: `${HELP_CENTER_URL}/en/articles/110656-account-recovery-in-safe-wallet`,
  RELAYING: `${HELP_CENTER_URL}/en/articles/59203-what-is-gas-fee-sponsoring`,
  SAFE_SETUP: `${HELP_CENTER_URL}/en/articles/40835-what-safe-setup-should-i-use`,
  SIGNED_MESSAGES: `${HELP_CENTER_URL}/en/articles/40783-what-are-signed-messages`,
  SPAM_TOKENS: `${HELP_CENTER_URL}/en/articles/40784-default-token-list-local-hiding-of-spam-tokens`,
  SPENDING_LIMITS: `${HELP_CENTER_URL}/en/articles/40842-set-up-and-use-spending-limits`,
  TRANSACTION_GUARD: `${HELP_CENTER_URL}/en/articles/40809-what-is-a-transaction-guard`,
  UNEXPECTED_DELEGATE_CALL: `${HELP_CENTER_URL}/en/articles/40794-why-do-i-see-an-unexpected-delegate-call-warning-in-my-transaction`,
  PROPOSERS: `${HELP_CENTER_URL}/en/articles/235770-proposers`,
  PUSH_NOTIFICATIONS: `${HELP_CENTER_URL}/en/articles/99197-how-to-start-receiving-web-push-notifications-in-the-web-wallet`,
  SWAP_WIDGET_FEES: `${HELP_CENTER_URL}/en/articles/178530-how-does-the-widget-fee-work-for-native-swaps`,
  VERIFY_TX_DETAILS: `${HELP_CENTER_URL}/en/articles/276343-how-to-perform-basic-transactions-checks-on-safe-wallet`,
} as const
export const HelperCenterArticleTitles = {
  RECOVERY: 'Learn more about the Account recovery process',
}

export const RECOVERY_FEEDBACK_FORM =
  'https://noteforms.com/forms/safe-feedback-form-hk16ds?notionforms=1&utm_source=notionforms'

// Social
export const DISCORD_URL = 'https://chat.safe.global'
export const TWITTER_URL = 'https://twitter.com/safe'

// Legal
export const IS_OFFICIAL_HOST = process.env.NEXT_PUBLIC_IS_OFFICIAL_HOST === 'true'
export const OFFICIAL_HOSTS = /app\.safe\.global|.+\.5afe\.dev|localhost:3000/
export const IPFS_HOSTS = /\.ipfs\.dweb\.link|\.ipfs\.w3s\.link|\.ipfs\.inbrowser\.link/
export const BRAND_NAME = process.env.NEXT_PUBLIC_BRAND_NAME || (IS_OFFICIAL_HOST ? 'Safe{Wallet}' : 'Wallet fork')
export const BRAND_LOGO = process.env.NEXT_PUBLIC_BRAND_LOGO || ''

export const REDEFINE_ARTICLE = 'https://safe.mirror.xyz/rInLWZwD_sf7enjoFerj6FIzCYmVMGrrV8Nhg4THdwI'

export const CHAINALYSIS_OFAC_CONTRACT = '0x40c57923924b5c5c5455c48d93317139addac8fb'

export const SAFE_PASS_URL = 'community.safe.global'
export const ECOSYSTEM_ID_ADDRESS =
  process.env.NEXT_PUBLIC_ECOSYSTEM_ID_ADDRESS || '0x0000000000000000000000000000000000000000'
export const MULTICHAIN_HELP_ARTICLE = `${HELP_CENTER_URL}/en/articles/222612-multi-chain-safe`
</file>

<file path="src/config/gateway.ts">
import { GATEWAY_URL_PRODUCTION, GATEWAY_URL_STAGING, IS_PRODUCTION } from '@/config/constants'
import { localItem } from '@/services/local-storage/local'

export const LS_KEY = 'debugProdCgw'
export const cgwDebugStorage = localItem<boolean>(LS_KEY)
export const GATEWAY_URL = IS_PRODUCTION || cgwDebugStorage.get() ? GATEWAY_URL_PRODUCTION : GATEWAY_URL_STAGING
</file>

<file path="src/config/routes.ts">
export const AppRoutes = {
  '403': '/403',
  '404': '/404',
  wc: '/wc',
  userSettings: '/user-settings',
  terms: '/terms',
  swap: '/swap',
  stake: '/stake',
  privacy: '/privacy',
  licenses: '/licenses',
  index: '/',
  imprint: '/imprint',
  home: '/home',
  cookie: '/cookie',
  bridge: '/bridge',
  addressBook: '/address-book',
  addOwner: '/addOwner',
  _offline: '/_offline',
  apps: {
    open: '/apps/open',
    index: '/apps',
    custom: '/apps/custom',
    bookmarked: '/apps/bookmarked',
  },
  balances: {
    nfts: '/balances/nfts',
    index: '/balances',
  },
  newSafe: {
    load: '/new-safe/load',
    create: '/new-safe/create',
    advancedCreate: '/new-safe/advanced-create',
  },
  settings: {
    setup: '/settings/setup',
    security: '/settings/security',
    notifications: '/settings/notifications',
    modules: '/settings/modules',
    index: '/settings',
    environmentVariables: '/settings/environment-variables',
    data: '/settings/data',
    cookies: '/settings/cookies',
    appearance: '/settings/appearance',
    safeApps: {
      index: '/settings/safe-apps',
    },
  },
  share: {
    safeApp: '/share/safe-app',
  },
  spaces: {
    settings: '/spaces/settings',
    safeAccounts: '/spaces/safe-accounts',
    members: '/spaces/members',
    index: '/spaces',
  },
  transactions: {
    tx: '/transactions/tx',
    queue: '/transactions/queue',
    msg: '/transactions/msg',
    messages: '/transactions/messages',
    index: '/transactions',
    history: '/transactions/history',
  },
  welcome: {
    spaces: '/welcome/spaces',
    index: '/welcome',
    accounts: '/welcome/accounts',
  },
}
</file>

<file path="src/config/securityHeaders.ts">
import { IS_PRODUCTION } from './constants'

const isCypress = Boolean(typeof window !== 'undefined' && window.Cypress)

/**
 * CSP Header notes:
 * For safe apps we have to allow img-src * and frame-src *
 * connect-src * because the RPCs are configurable (config service)
 * style-src unsafe-inline for our styled components
 * script-src unsafe-eval is needed by next.js in dev mode, otherwise only self
 * frame-ancestors can not be set via meta tag
 */
export const ContentSecurityPolicy = `
 default-src 'self';
 connect-src 'self' *;
 script-src 'self' 'unsafe-inline' https://*.getbeamer.com https://www.googletagmanager.com https://*.ingest.sentry.io https://sentry.io ${
   !IS_PRODUCTION || isCypress
     ? "'unsafe-eval'" // Dev server and cypress need unsafe-eval
     : "'wasm-unsafe-eval'"
 };
 frame-src http: https:;
 style-src 'self' 'unsafe-inline' https://*.getbeamer.com https://*.googleapis.com;
 font-src 'self' data:;
 worker-src 'self' blob:;
 img-src * data:;
`
  .replace(/\s{2,}/g, ' ')
  .trim()

export const StrictTransportSecurity = 'max-age=31536000; includeSubDomains'
</file>

<file path="src/features/bridge/components/Bridge/index.tsx">
import dynamic from 'next/dynamic'

import { AppRoutes } from '@/config/routes'
import { FeatureWrapper } from '@/components/wrappers/FeatureWrapper'
import { SanctionWrapper } from '@/components/wrappers/SanctionWrapper'
import { DisclaimerWrapper } from '@/components/wrappers/DisclaimerWrapper'
import { FEATURES } from '@safe-global/utils/utils/chains'

const LOCAL_STORAGE_CONSENT_KEY = 'bridgeConsent'

const BridgeWidget = dynamic(
  () => import('@/features/bridge/components/BridgeWidget').then((module) => module.BridgeWidget),
  {
    ssr: false,
  },
)

export function Bridge() {
  return (
    <FeatureWrapper feature={FEATURES.BRIDGE} fallbackRoute={AppRoutes.home}>
      <SanctionWrapper featureTitle="bridge feature with LI.FI">
        <DisclaimerWrapper localStorageKey={LOCAL_STORAGE_CONSENT_KEY} widgetName="Bridging Widget by LI.FI">
          <BridgeWidget />
        </DisclaimerWrapper>
      </SanctionWrapper>
    </FeatureWrapper>
  )
}
</file>

<file path="src/features/bridge/components/BridgeWidget/index.tsx">
import { useMemo } from 'react'
import type { ReactElement } from 'react'

import AppFrame from '@/components/safe-apps/AppFrame'
import { getEmptySafeApp } from '@/components/safe-apps/utils'
import useChains from '@/hooks/useChains'
import { useDarkMode } from '@/hooks/useDarkMode'
import type { SafeAppDataWithPermissions } from '@/components/safe-apps/types'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

export const BRIDGE_WIDGET_URL = 'https://iframe.jumper.exchange'

export function BridgeWidget(): ReactElement {
  const isDarkMode = useDarkMode()
  const { configs } = useChains()

  const appData = useMemo((): SafeAppDataWithPermissions => {
    return _getAppData(isDarkMode, configs)
  }, [configs, isDarkMode])

  return (
    <AppFrame
      appUrl={appData.url}
      allowedFeaturesList="clipboard-read; clipboard-write"
      safeAppFromManifest={appData}
      isNativeEmbed
    />
  )
}

export function _getAppData(isDarkMode: boolean, chains?: Array<ChainInfo>): SafeAppDataWithPermissions {
  const theme = isDarkMode ? 'dark' : 'light'
  return {
    ...getEmptySafeApp(),
    name: 'Bridge',
    iconUrl: '/images/common/bridge.svg',
    chainIds: getChainIds(chains),
    url: `${BRIDGE_WIDGET_URL}/?theme=${theme}`,
  }
}

function getChainIds(chains?: Array<ChainInfo>): Array<string> {
  if (!chains) {
    return []
  }
  return chains.reduce<Array<string>>((acc, cur) => {
    if (hasFeature(cur, FEATURES.BRIDGE)) {
      acc.push(cur.chainId)
    }
    return acc
  }, [])
}
</file>

<file path="src/features/bridge/hooks/useIsBridgeFeatureEnabled.ts">
import { useIsGeoblockedFeatureEnabled } from '@/hooks/useIsGeoblockedFeatureEnabled'

import { FEATURES } from '@safe-global/utils/utils/chains'

export function useIsBridgeFeatureEnabled() {
  return useIsGeoblockedFeatureEnabled(FEATURES.BRIDGE)
}
</file>

<file path="src/features/counterfactual/hooks/useDeployGasLimit.ts">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import useOnboard from '@/hooks/wallets/useOnboard'
import useWallet from '@/hooks/wallets/useWallet'
import { getSafeSDKWithSigner } from '@/services/tx/tx-sender/sdk'
import { estimateSafeDeploymentGas, estimateTxBaseGas } from '@safe-global/protocol-kit'
import type Safe from '@safe-global/protocol-kit'

import { OperationType, type SafeTransaction } from '@safe-global/safe-core-sdk-types'
import {
  getCompatibilityFallbackHandlerContract,
  getSimulateTxAccessorContract,
} from '@safe-global/protocol-kit/dist/src/contracts/safeDeploymentContracts'

import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'

type DeployGasLimitProps = {
  safeTxGas: bigint
  safeDeploymentGas: string
  totalGas: bigint
}

const useDeployGasLimit = (safeTx?: SafeTransaction) => {
  const onboard = useOnboard()
  const wallet = useWallet()
  const chainId = useChainId()

  const [gasLimit, gasLimitError, gasLimitLoading] = useAsync<DeployGasLimitProps | undefined>(async () => {
    if (!wallet || !onboard) return

    const sdk = await getSafeSDKWithSigner(wallet.provider)

    const [baseGas, batchTxGas, safeDeploymentGas] = await Promise.all([
      safeTx ? estimateTxBaseGas(sdk, safeTx) : '0',
      safeTx ? estimateBatchDeploymentTransaction(safeTx, sdk, chainId) : '0',
      estimateSafeDeploymentGas(sdk),
    ])

    const totalGas = safeTx ? BigInt(baseGas) + BigInt(batchTxGas) : BigInt(safeDeploymentGas)
    const safeTxGas = totalGas - BigInt(safeDeploymentGas)

    return { safeTxGas, safeDeploymentGas, totalGas }
  }, [onboard, wallet, chainId, safeTx])

  return { gasLimit, gasLimitError, gasLimitLoading }
}

/**
 * Estimates batch transaction containing the safe deployment and the first transaction.
 *
 * This estimation is done by calling `eth_estimateGas` with a MultiSendCallOnly batch transaction that
 *   1. Calls the SafeProxyFactory to deploy the SafeProxy
 *   2. Call the `simulate` function on the now deployed SafeProxy with the first transaction data.
 * Then we substract a flat gas amount for the overhead of simulating the transaction.
 *
 * Note: To have a more accurate estimation the base gas of a Safe Transaction has to be added to the result
 * @param safeTransaction - first SafeTransaction that should be batched with the deployment
 * @param sdk - predicted Safe instance
 * @param chainId - chainId of the Safe
 * @returns the gas estimation for the batch (as `bigint`)
 */
export const estimateBatchDeploymentTransaction = async (
  safeTransaction: SafeTransaction,
  sdk: Safe,
  chainId: string,
) => {
  const customContracts = sdk.getContractManager().contractNetworks?.[chainId]
  const safeVersion = await sdk.getContractVersion()
  const safeProvider = sdk.getSafeProvider()
  const fallbackHandlerContract = await getCompatibilityFallbackHandlerContract({
    safeProvider,
    safeVersion,
    customContracts,
  })

  const simulateTxAccessorContract = await getSimulateTxAccessorContract({
    safeProvider,
    safeVersion,
    customContracts,
  })

  // 1. Get Deploy tx
  const safeDeploymentTransaction = await sdk.createSafeDeploymentTransaction()
  const safeDeploymentBatchTransaction = {
    to: safeDeploymentTransaction.to,
    value: safeDeploymentTransaction.value,
    data: safeDeploymentTransaction.data,
    operation: OperationType.Call,
  }

  // 2. Add a simulate call to the predicted SafeProxy as second transaction
  const transactionDataToEstimate: string = simulateTxAccessorContract.encode('simulate', [
    safeTransaction.data.to,
    BigInt(safeTransaction.data.value),
    safeTransaction.data.data,
    safeTransaction.data.operation,
  ])

  const safeFunctionToEstimate: string = fallbackHandlerContract.encode('simulate', [
    await simulateTxAccessorContract.getAddress(),
    transactionDataToEstimate,
  ])

  const simulateBatchTransaction = {
    to: await sdk.getAddress(),
    value: '0',
    data: safeFunctionToEstimate,
    operation: OperationType.Call,
  }

  const safeDeploymentBatch = await sdk.createTransactionBatch([
    safeDeploymentBatchTransaction,
    simulateBatchTransaction,
  ])

  const signerAddress = await safeProvider.getSignerAddress()

  // estimate the entire batch
  const safeTxGas = await safeProvider.estimateGas({
    ...safeDeploymentBatch,
    from: signerAddress || ZERO_ADDRESS, // This address should not really matter
  })

  // Substract ~20k gas for the simulation overhead
  return BigInt(safeTxGas) - 20_000n
}

export default useDeployGasLimit
</file>

<file path="src/features/counterfactual/hooks/useIsCounterfactualSafe.ts">
import { selectIsUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useAppSelector } from '@/store'

const useIsCounterfactualSafe = () => {
  const {
    safeAddress,
    safe: { chainId },
  } = useSafeInfo()
  return useAppSelector((state) => selectIsUndeployedSafe(state, chainId, safeAddress))
}

export default useIsCounterfactualSafe
</file>

<file path="src/features/counterfactual/hooks/usePendingSafeNotifications.ts">
import { SafeCreationEvent, safeCreationSubscribe } from '@/features/counterfactual/services/safeCreationEvents'
import useWallet from '@/hooks/wallets/useWallet'
import { useGetAllOwnedSafesQuery } from '@/store/api/gateway'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import { skipToken } from '@reduxjs/toolkit/query'
import { useEffect } from 'react'
import { formatError } from '@safe-global/utils/utils/formatters'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeAddress from '@/hooks/useSafeAddress'
import { isWalletRejection } from '@/utils/wallets'

const SafeCreationNotifications = {
  [SafeCreationEvent.PROCESSING]: 'Validating...',
  [SafeCreationEvent.RELAYING]: 'Validating...',
  [SafeCreationEvent.INDEXED]: 'Successfully executed.',
  [SafeCreationEvent.FAILED]: 'Failed.',
  [SafeCreationEvent.REVERTED]: 'Reverted. Please check your gas settings.',
}

enum Variant {
  INFO = 'info',
  SUCCESS = 'success',
  ERROR = 'error',
}

const usePendingSafeNotifications = (): void => {
  const dispatch = useAppDispatch()
  const chain = useCurrentChain()
  const safeAddress = useSafeAddress()
  const { address = '' } = useWallet() || {}
  const { refetch } = useGetAllOwnedSafesQuery(address === '' ? skipToken : { walletAddress: address })

  useEffect(() => {
    if (!chain) return

    const entries = Object.entries(SafeCreationNotifications) as [keyof typeof SafeCreationNotifications, string][]

    const unsubFns = entries.map(([event, baseMessage]) =>
      safeCreationSubscribe(event, async (detail) => {
        const isError = 'error' in detail
        if (isError && isWalletRejection(detail.error)) return

        const isSuccess = event === SafeCreationEvent.INDEXED
        const message = isError ? `${baseMessage} ${formatError(detail.error)}` : baseMessage
        const txHash = 'txHash' in detail ? detail.txHash : undefined
        const groupKey = 'groupKey' in detail && detail.groupKey ? detail.groupKey : txHash || ''
        const link = chain && txHash ? getBlockExplorerLink(chain, txHash) : undefined

        // Fetch all owned safes after the Safe has been deployed
        if (isSuccess) {
          refetch()
        }

        dispatch(
          showNotification({
            title: 'Safe Account activation',
            message,
            detailedMessage: isError ? detail.error.message : undefined,
            groupKey,
            variant: isError ? Variant.ERROR : isSuccess ? Variant.SUCCESS : Variant.INFO,
            link,
          }),
        )
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [dispatch, safeAddress, chain, refetch])
}

export default usePendingSafeNotifications
</file>

<file path="src/features/counterfactual/hooks/usePendingSafeStatuses.ts">
import { pollSafeInfo } from '@/components/new-safe/create/logic'
import {
  safeCreationDispatch,
  SafeCreationEvent,
  safeCreationSubscribe,
} from '@/features/counterfactual/services/safeCreationEvents'
import {
  removeUndeployedSafe,
  selectUndeployedSafes,
  updateUndeployedSafeStatus,
} from '@/features/counterfactual/store/undeployedSafesSlice'
import { checkSafeActionViaRelay, checkSafeActivation } from '@/features/counterfactual/utils'
import useChainId from '@/hooks/useChainId'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { CREATE_SAFE_EVENTS, trackEvent } from '@/services/analytics'
import { useAppDispatch, useAppSelector } from '@/store'
import { useEffect, useRef } from 'react'
import { isSmartContract } from '@/utils/wallets'
import { gtmSetSafeAddress } from '@/services/analytics/gtm'
import { PendingSafeStatus } from '@safe-global/utils/features/counterfactual/store/types'
import { PayMethod } from '@safe-global/utils/features/counterfactual/types'

export const safeCreationPendingStatuses: Partial<Record<SafeCreationEvent, PendingSafeStatus | null>> = {
  [SafeCreationEvent.AWAITING_EXECUTION]: PendingSafeStatus.AWAITING_EXECUTION,
  [SafeCreationEvent.PROCESSING]: PendingSafeStatus.PROCESSING,
  [SafeCreationEvent.RELAYING]: PendingSafeStatus.RELAYING,
  [SafeCreationEvent.SUCCESS]: null,
  [SafeCreationEvent.INDEXED]: null,
  [SafeCreationEvent.FAILED]: null,
  [SafeCreationEvent.REVERTED]: null,
}

const usePendingSafeMonitor = (): void => {
  const undeployedSafesByChain = useAppSelector(selectUndeployedSafes)
  const provider = useWeb3ReadOnly()
  const dispatch = useAppDispatch()

  // Prevent monitoring the same safe more than once
  const monitoredSafes = useRef<{ [safeAddress: string]: boolean }>({})

  // Monitor pending safe creation mining/validating progress
  useEffect(() => {
    Object.entries(undeployedSafesByChain).forEach(([chainId, undeployedSafes]) => {
      Object.entries(undeployedSafes).forEach(([safeAddress, undeployedSafe]) => {
        if (undeployedSafe?.status.status === PendingSafeStatus.AWAITING_EXECUTION) {
          monitoredSafes.current[safeAddress] = false
        }

        if (!provider || !undeployedSafe || undeployedSafe.status.status === PendingSafeStatus.AWAITING_EXECUTION) {
          return
        }

        const monitorPendingSafe = async () => {
          const {
            status: { status, txHash, taskId, startBlock, type },
          } = undeployedSafe

          const isProcessing = status === PendingSafeStatus.PROCESSING && txHash !== undefined
          const isRelaying = status === PendingSafeStatus.RELAYING && taskId !== undefined
          const isMonitored = monitoredSafes.current[safeAddress]

          if ((!isProcessing && !isRelaying) || isMonitored) return

          monitoredSafes.current[safeAddress] = true

          if (isProcessing) {
            checkSafeActivation(provider, txHash, safeAddress, type, chainId, startBlock)
          }

          if (isRelaying) {
            checkSafeActionViaRelay(taskId, safeAddress, type, chainId)
          }
        }

        monitorPendingSafe()
      })
    })
  }, [dispatch, provider, undeployedSafesByChain])
}

const usePendingSafeStatus = (): void => {
  const dispatch = useAppDispatch()
  const { safe, safeAddress } = useSafeInfo()
  const chainId = useChainId()
  const provider = useWeb3ReadOnly()

  usePendingSafeMonitor()

  // Clear undeployed safe state if already deployed
  useEffect(() => {
    if (!provider || !safeAddress) return

    const checkDeploymentStatus = async () => {
      // In case the safe info hasn't been updated yet when switching safes
      const { chainId } = await provider.getNetwork()
      if (chainId !== BigInt(safe.chainId)) return

      const isContractDeployed = await isSmartContract(safeAddress)

      if (isContractDeployed) {
        dispatch(removeUndeployedSafe({ chainId: safe.chainId, address: safeAddress }))
      }
    }

    checkDeploymentStatus()
  }, [safe.chainId, dispatch, provider, safeAddress])

  // Subscribe to pending safe statuses
  useEffect(() => {
    const unsubFns = Object.entries(safeCreationPendingStatuses).map(([event, status]) =>
      safeCreationSubscribe(event as SafeCreationEvent, async (detail) => {
        const creationChainId = 'chainId' in detail ? detail.chainId : chainId

        if (event === SafeCreationEvent.SUCCESS) {
          gtmSetSafeAddress(detail.safeAddress)

          // TODO: Possible to add a label with_tx, without_tx?
          trackEvent(CREATE_SAFE_EVENTS.ACTIVATED_SAFE)

          // Not a counterfactual deployment
          if ('type' in detail && detail.type === PayMethod.PayNow) {
            trackEvent(CREATE_SAFE_EVENTS.CREATED_SAFE)
          }

          pollSafeInfo(creationChainId, detail.safeAddress).finally(() => {
            safeCreationDispatch(SafeCreationEvent.INDEXED, {
              groupKey: detail.groupKey,
              safeAddress: detail.safeAddress,
              chainId: creationChainId,
            })
          })
          return
        }

        if (event === SafeCreationEvent.INDEXED) {
          dispatch(removeUndeployedSafe({ chainId: creationChainId, address: detail.safeAddress }))
        }

        if (status === null) {
          dispatch(
            updateUndeployedSafeStatus({
              chainId: creationChainId,
              address: detail.safeAddress,
              status: {
                status: PendingSafeStatus.AWAITING_EXECUTION,
                startBlock: undefined,
                txHash: undefined,
                submittedAt: undefined,
              },
            }),
          )
          return
        }

        dispatch(
          updateUndeployedSafeStatus({
            chainId: creationChainId,
            address: detail.safeAddress,
            status: {
              status,
              txHash: 'txHash' in detail ? detail.txHash : undefined,
              taskId: 'taskId' in detail ? detail.taskId : undefined,
              startBlock: await provider?.getBlockNumber(),
              submittedAt: Date.now(),
            },
          }),
        )
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [chainId, dispatch, provider])
}

export default usePendingSafeStatus
</file>

<file path="src/features/counterfactual/services/safeCreationEvents.ts">
import EventBus from '@/services/EventBus'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { PayMethod } from '@safe-global/utils/features/counterfactual/types'

export enum SafeCreationEvent {
  AWAITING_EXECUTION = 'AWAITING_EXECUTION',
  PROCESSING = 'PROCESSING',
  RELAYING = 'RELAYING',
  SUCCESS = 'SUCCESS',
  FAILED = 'FAILED',
  REVERTED = 'REVERTED',
  INDEXED = 'INDEXED',
}

export interface SafeCreationEvents {
  [SafeCreationEvent.AWAITING_EXECUTION]: {
    groupKey: string
    safeAddress: string
    networks: ChainInfo[]
  }
  [SafeCreationEvent.PROCESSING]: {
    groupKey: string
    txHash: string
    safeAddress: string
  }
  [SafeCreationEvent.RELAYING]: {
    groupKey: string
    taskId: string
    safeAddress: string
  }
  [SafeCreationEvent.SUCCESS]: {
    groupKey: string
    safeAddress: string
    type: PayMethod
    chainId: string
  }
  [SafeCreationEvent.INDEXED]: {
    groupKey: string
    safeAddress: string
    chainId: string
  }
  [SafeCreationEvent.FAILED]: {
    groupKey: string
    error: Error
    safeAddress: string
  }
  [SafeCreationEvent.REVERTED]: {
    groupKey: string
    error: Error
    safeAddress: string
  }
}

const SafeCreationEventBus = new EventBus<SafeCreationEvents>()

export const safeCreationDispatch = SafeCreationEventBus.dispatch.bind(SafeCreationEventBus)

export const safeCreationSubscribe = SafeCreationEventBus.subscribe.bind(SafeCreationEventBus)

// Log all events
Object.values(SafeCreationEvent).forEach((event: SafeCreationEvent) => {
  safeCreationSubscribe<SafeCreationEvent>(event, (detail) => {
    console.info(`[Safe creation]: ${event}`, detail)
  })
})
</file>

<file path="src/features/counterfactual/store/undeployedSafesSlice.ts">
import { type RootState } from '@/store'
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'
import type { PredictedSafeProps } from '@safe-global/protocol-kit'
import { selectChainIdAndSafeAddress, selectSafeAddress } from '@/store/common'
import type {
  ReplayedSafeProps,
  UndeployedSafe,
  UndeployedSafesState,
  UndeployedSafeStatus,
} from '@safe-global/utils/features/counterfactual/store/types'
import { PendingSafeStatus } from '@safe-global/utils/features/counterfactual/store/types'
import type { PayMethod } from '@safe-global/utils/features/counterfactual/types'

const initialState: UndeployedSafesState = {}

export const undeployedSafesSlice = createSlice({
  name: 'undeployedSafes',
  initialState,
  reducers: {
    addUndeployedSafe: (
      state,
      action: PayloadAction<{
        chainId: string
        address: string
        type: PayMethod
        safeProps: PredictedSafeProps | ReplayedSafeProps
      }>,
    ) => {
      const { chainId, address, type, safeProps } = action.payload

      if (!state[chainId]) {
        state[chainId] = {}
      }

      state[chainId][address] = {
        props: safeProps,
        status: {
          status: PendingSafeStatus.AWAITING_EXECUTION,
          type,
        },
      }
    },

    addUndeployedSafes: (_, { payload }: PayloadAction<UndeployedSafesState>) => {
      // We must return as we are overwriting the entire state
      return payload
    },

    updateUndeployedSafeStatus: (
      state,
      action: PayloadAction<{ chainId: string; address: string; status: Omit<UndeployedSafeStatus, 'type'> }>,
    ) => {
      const { chainId, address, status } = action.payload

      if (!state[chainId]?.[address]) return state

      state[chainId][address] = {
        props: state[chainId][address].props,
        status: {
          ...state[chainId][address].status,
          ...status,
        },
      }
    },

    removeUndeployedSafe: (state, action: PayloadAction<{ chainId: string; address: string }>) => {
      const { chainId, address } = action.payload
      if (!state[chainId]) return state

      delete state[chainId][address]

      if (Object.keys(state[chainId]).length > 0) return state

      delete state[chainId]
    },
  },
})

export const { removeUndeployedSafe, addUndeployedSafe, updateUndeployedSafeStatus } = undeployedSafesSlice.actions

export const selectUndeployedSafes = (state: RootState): UndeployedSafesState => {
  return state[undeployedSafesSlice.name]
}

export const selectUndeployedSafe = createSelector(
  [selectUndeployedSafes, selectChainIdAndSafeAddress],
  (undeployedSafes, [chainId, address]): UndeployedSafe | undefined => {
    return undeployedSafes[chainId]?.[address]
  },
)

export const selectUndeployedSafesByAddress = createSelector(
  [selectUndeployedSafes, selectSafeAddress],
  (undeployedSafes, [address]): UndeployedSafe[] => {
    return Object.values(undeployedSafes)
      .flatMap((value) => value[address])
      .filter(Boolean)
  },
)

export const selectIsUndeployedSafe = createSelector([selectUndeployedSafe], (undeployedSafe) => {
  return !!undeployedSafe
})
</file>

<file path="src/features/counterfactual/ActivateAccountButton.tsx">
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import dynamic from 'next/dynamic'
import React, { useContext } from 'react'
import { Button, CircularProgress, Tooltip, Typography } from '@mui/material'
import { TxModalContext } from '@/components/tx-flow'
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useAppSelector } from '@/store'
import CheckWallet from '@/components/common/CheckWallet'
import { PendingSafeStatus } from '@safe-global/utils/features/counterfactual/store/types'

const ActivateAccountFlow = dynamic(() => import('./ActivateAccountFlow'))

const ActivateAccountButton = () => {
  const { safe, safeAddress } = useSafeInfo()
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, safe.chainId, safeAddress))
  const { setTxFlow } = useContext(TxModalContext)

  const isProcessing = undeployedSafe?.status.status !== PendingSafeStatus.AWAITING_EXECUTION

  const activateAccount = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'activate_now' })
    setTxFlow(<ActivateAccountFlow />)
  }

  return (
    <Tooltip title={isProcessing ? 'The safe activation is already in process' : undefined}>
      <span>
        <CheckWallet allowNonOwner allowUndeployedSafe>
          {(isOk) => (
            <Button
              data-testid="activate-account-btn-cf"
              variant="contained"
              size="small"
              fullWidth
              onClick={activateAccount}
              disabled={isProcessing || !isOk}
              sx={{ minHeight: '40px' }}
            >
              {isProcessing ? (
                <>
                  <Typography variant="body2" component="span" mr={1}>
                    Processing
                  </Typography>
                  <CircularProgress size={16} />
                </>
              ) : (
                'Activate now'
              )}
            </Button>
          )}
        </CheckWallet>
      </span>
    </Tooltip>
  )
}

export default ActivateAccountButton
</file>

<file path="src/features/counterfactual/ActivateAccountFlow.tsx">
import { createNewSafe, relaySafeCreation } from '@/components/new-safe/create/logic'
import { NetworkFee, SafeSetupOverview } from '@/components/new-safe/create/steps/ReviewStep'
import ReviewRow from '@/components/new-safe/ReviewRow'
import { TxModalContext } from '@/components/tx-flow'
import TxCard from '@/components/tx-flow/common/TxCard'
import TxLayout from '@/components/tx-flow/common/TxLayout'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { ExecutionMethod, ExecutionMethodSelector } from '@/components/tx/ExecutionMethodSelector'
import { safeCreationDispatch, SafeCreationEvent } from '@/features/counterfactual/services/safeCreationEvents'
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import { CF_TX_GROUP_KEY, extractCounterfactualSafeSetup, isPredictedSafeProps } from '@/features/counterfactual/utils'
import useChainId from '@/hooks/useChainId'
import { useCurrentChain } from '@/hooks/useChains'
import useGasPrice, { getTotalFeeFormatted } from '@/hooks/useGasPrice'
import { useLeastRemainingRelays } from '@/hooks/useRemainingRelays'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWalletCanPay from '@/hooks/useWalletCanPay'
import useWallet from '@/hooks/wallets/useWallet'
import { OVERVIEW_EVENTS, trackEvent, WALLET_EVENTS } from '@/services/analytics'
import { TX_EVENTS, TX_TYPES } from '@/services/analytics/events/transactions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { useAppSelector } from '@/store'
import { hasRemainingRelays } from '@/utils/relaying'
import { Box, Button, CircularProgress, Divider, Grid, Typography } from '@mui/material'
import type { DeploySafeProps } from '@safe-global/protocol-kit'
import React, { useContext, useMemo, useState } from 'react'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { useEstimateSafeCreationGas } from '@/components/new-safe/create/useEstimateSafeCreationGas'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import CheckWallet from '@/components/common/CheckWallet'
import { getSafeToL2SetupDeployment } from '@safe-global/safe-deployments'
import { FEATURES, getLatestSafeVersion, hasFeature } from '@safe-global/utils/utils/chains'
import type { UndeployedSafe } from '@safe-global/utils/features/counterfactual/store/types'

const useActivateAccount = (undeployedSafe: UndeployedSafe | undefined) => {
  const chain = useCurrentChain()
  const [gasPrice] = useGasPrice()
  const safeVersion =
    undeployedSafe &&
    (isPredictedSafeProps(undeployedSafe?.props)
      ? undeployedSafe?.props.safeDeploymentConfig?.safeVersion
      : undeployedSafe?.props.safeVersion)

  const { gasLimit } = useEstimateSafeCreationGas(undeployedSafe?.props, safeVersion)

  const isEIP1559 = chain && hasFeature(chain, FEATURES.EIP1559)
  const maxFeePerGas = gasPrice?.maxFeePerGas
  const maxPriorityFeePerGas = gasPrice?.maxPriorityFeePerGas

  const options: DeploySafeProps['options'] = isEIP1559
    ? {
        maxFeePerGas: maxFeePerGas?.toString(),
        maxPriorityFeePerGas: maxPriorityFeePerGas?.toString(),
        gasLimit: gasLimit?.toString(),
      }
    : { gasPrice: maxFeePerGas?.toString(), gasLimit: gasLimit?.toString() }

  const totalFee = getTotalFeeFormatted(maxFeePerGas, gasLimit, chain)
  const walletCanPay = useWalletCanPay({ gasLimit, maxFeePerGas })

  return { options, totalFee, walletCanPay }
}

const ActivateAccountFlow = () => {
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [submitError, setSubmitError] = useState<Error | undefined>()
  const [executionMethod, setExecutionMethod] = useState(ExecutionMethod.RELAY)

  const chain = useCurrentChain()
  const chainId = useChainId()
  const { safeAddress } = useSafeInfo()
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, chainId, safeAddress))
  const { setTxFlow } = useContext(TxModalContext)
  const wallet = useWallet()
  const { options, totalFee, walletCanPay } = useActivateAccount(undeployedSafe)
  const isWrongChain = useIsWrongChain()

  const undeployedSafeSetup = useMemo(
    () => extractCounterfactualSafeSetup(undeployedSafe, chainId),
    [undeployedSafe, chainId],
  )

  const safeAccountConfig =
    undeployedSafe && isPredictedSafeProps(undeployedSafe?.props) ? undeployedSafe?.props.safeAccountConfig : undefined

  const ownerAddresses = undeployedSafeSetup?.owners || []
  const [minRelays] = useLeastRemainingRelays(ownerAddresses)

  // Every owner has remaining relays and relay method is selected
  const canRelay = hasRemainingRelays(minRelays)
  const willRelay = canRelay && executionMethod === ExecutionMethod.RELAY

  if (!undeployedSafe || !undeployedSafeSetup) return null

  const { owners, threshold, safeVersion } = undeployedSafeSetup

  const safeToL2SetupDeployment = getSafeToL2SetupDeployment({ version: '1.4.1', network: chain?.chainId })
  const safeToL2SetupAddress = safeToL2SetupDeployment?.defaultAddress
  const isMultichainSafe = sameAddress(safeAccountConfig?.to, safeToL2SetupAddress)

  const onSubmit = (txHash?: string) => {
    trackEvent({ ...TX_EVENTS.CREATE, label: TX_TYPES.activate_without_tx })
    trackEvent({ ...TX_EVENTS.EXECUTE, label: TX_TYPES.activate_without_tx })
    trackEvent(WALLET_EVENTS.ONCHAIN_INTERACTION)

    if (txHash) {
      safeCreationDispatch(SafeCreationEvent.PROCESSING, { groupKey: CF_TX_GROUP_KEY, txHash, safeAddress })
    }
    setTxFlow(undefined)
  }

  const createSafe = async () => {
    if (!wallet || !chain) return

    trackEvent({ ...OVERVIEW_EVENTS.PROCEED_WITH_TX, label: TX_TYPES.activate_without_tx })

    setIsSubmittable(false)
    setSubmitError(undefined)

    try {
      if (willRelay) {
        const taskId = await relaySafeCreation(chain, undeployedSafe.props)
        safeCreationDispatch(SafeCreationEvent.RELAYING, { groupKey: CF_TX_GROUP_KEY, taskId, safeAddress })

        onSubmit()
      } else {
        await createNewSafe(
          wallet.provider,
          undeployedSafe.props,
          safeVersion ?? getLatestSafeVersion(chain),
          chain,
          options,
          onSubmit,
          isMultichainSafe ? true : undefined,
        )
      }
    } catch (_err) {
      const err = asError(_err)
      setIsSubmittable(true)
      setSubmitError(err)
      return
    }
  }

  const submitDisabled = !isSubmittable || isWrongChain

  return (
    <TxLayout title="Activate account" hideNonce>
      <TxCard>
        <Typography>
          You&apos;re about to deploy this Safe Account and will have to confirm the transaction with your connected
          wallet.
        </Typography>

        <Divider sx={{ mx: -3, my: 2 }} />

        <SafeSetupOverview
          owners={owners.map((owner) => ({ name: '', address: owner }))}
          threshold={threshold}
          networks={chain ? [chain] : []}
        />

        <Divider sx={{ mx: -3, mt: 2, mb: 1 }} />
        <Box display="flex" flexDirection="column" gap={3}>
          {canRelay && (
            <Grid container spacing={3}>
              <ReviewRow
                name="Execution method"
                value={
                  <ExecutionMethodSelector
                    executionMethod={executionMethod}
                    setExecutionMethod={setExecutionMethod}
                    relays={minRelays}
                  />
                }
              />
            </Grid>
          )}

          <Grid data-testid="network-fee-section" container spacing={3}>
            <ReviewRow
              name="Est. network fee"
              value={
                <>
                  <NetworkFee totalFee={totalFee} isWaived={willRelay || isWrongChain} chain={chain} />

                  {!willRelay && (
                    <Typography variant="body2" color="text.secondary" mt={1}>
                      {isWrongChain
                        ? `Switch your connected wallet to ${chain?.chainName} to see the correct estimated network fee`
                        : 'You will have to confirm a transaction with your connected wallet.'}
                    </Typography>
                  )}
                </>
              }
            />
          </Grid>

          {submitError && (
            <Box mt={1}>
              <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
            </Box>
          )}
          {isWrongChain && <NetworkWarning />}
          {!walletCanPay && !willRelay && (
            <ErrorMessage>
              Your connected wallet doesn&apos;t have enough funds to execute this transaction
            </ErrorMessage>
          )}
        </Box>

        <Divider sx={{ mx: -3, mt: 2, mb: 1 }} />

        <Box display="flex" flexDirection="row" justifyContent="flex-end" gap={3}>
          <CheckWallet checkNetwork={!submitDisabled} allowNonOwner allowUndeployedSafe>
            {(isOk) => (
              <Button
                data-testid="activate-account-flow-btn"
                onClick={createSafe}
                variant="contained"
                size="stretched"
                disabled={!isOk || submitDisabled}
              >
                {!isSubmittable ? <CircularProgress size={20} /> : 'Activate'}
              </Button>
            )}
          </CheckWallet>
        </Box>
      </TxCard>
    </TxLayout>
  )
}

export default ActivateAccountFlow
</file>

<file path="src/features/counterfactual/CheckBalance.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import ActivateAccountButton from '@/features/counterfactual/ActivateAccountButton'
import Track from '@/components/common/Track'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { COUNTERFACTUAL_EVENTS } from '@/services/analytics/events/counterfactual'
import { getBlockExplorerLink } from '@safe-global/utils/utils/chains'
import { Alert, Typography } from '@mui/material'

const CheckBalance = () => {
  const { safe, safeAddress } = useSafeInfo()
  const chain = useCurrentChain()

  if (safe.deployed) return null

  const blockExplorerLink = chain ? getBlockExplorerLink(chain, safeAddress) : undefined

  return (
    <Alert
      data-testid="no-tokens-alert"
      icon={false}
      severity="info"
      sx={{ display: 'flex', maxWidth: '600px', mt: 3, px: 3, py: 2, mx: 'auto' }}
    >
      <Typography fontWeight="bold" mb={1}>
        Don&apos;t see your tokens?
      </Typography>
      <Typography variant="body2" mb={2}>
        Your Safe Account is not activated yet so we can only display your native balance. Non-native tokens may not
        show up immediately after the Safe is deployed. Finish the onboarding to deploy your account onchain and unlock
        all features.{' '}
        {blockExplorerLink && (
          <>
            You can always view all of your assets on the{' '}
            <Track {...COUNTERFACTUAL_EVENTS.CHECK_BALANCES}>
              <ExternalLink href={blockExplorerLink.href}>Block Explorer</ExternalLink>
            </Track>
          </>
        )}
      </Typography>

      <ActivateAccountButton />
    </Alert>
  )
}

export default CheckBalance
</file>

<file path="src/features/counterfactual/CounterfactualForm.tsx">
import { TxModalContext } from '@/components/tx-flow'
import useDeployGasLimit from '@/features/counterfactual/hooks/useDeployGasLimit'
import { deploySafeAndExecuteTx } from '@/features/counterfactual/utils'
import { getTotalFeeFormatted } from '@/hooks/useGasPrice'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWalletCanPay from '@/hooks/useWalletCanPay'
import useWallet from '@/hooks/wallets/useWallet'
import { OVERVIEW_EVENTS, trackEvent, WALLET_EVENTS } from '@/services/analytics'
import { TX_EVENTS, TX_TYPES } from '@/services/analytics/events/transactions'
import madProps from '@/utils/mad-props'
import React, { type ReactElement, type SyntheticEvent, useContext, useState } from 'react'
import { CircularProgress, Box, Button, CardActions, Divider, Alert } from '@mui/material'
import classNames from 'classnames'

import ErrorMessage from '@/components/tx/ErrorMessage'
import { trackError, Errors } from '@/services/exceptions'
import { useCurrentChain } from '@/hooks/useChains'
import { getTxOptions } from '@/utils/transactions'
import CheckWallet from '@/components/common/CheckWallet'
import { useIsExecutionLoop } from '@/components/tx/SignOrExecuteForm/hooks'
import type { SignOrExecuteProps } from '@/components/tx/SignOrExecuteForm/SignOrExecuteFormV2'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import AdvancedParams, { useAdvancedParams } from '@/components/tx/AdvancedParams'
import { asError } from '@safe-global/utils/services/exceptions/utils'

import commonCss from '@/components/tx-flow/common/styles.module.css'
import { TxSecurityContext } from '@/components/tx/security/shared/TxSecurityContext'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import NonOwnerError from '@/components/tx/SignOrExecuteForm/NonOwnerError'

export const CounterfactualForm = ({
  safeTx,
  disableSubmit = false,
  onlyExecute,
  isCreation,
  isOwner,
  isExecutionLoop,
  txSecurity,
  onSubmit,
}: SignOrExecuteProps & {
  isOwner: ReturnType<typeof useIsSafeOwner>
  isExecutionLoop: ReturnType<typeof useIsExecutionLoop>
  txSecurity: ReturnType<typeof useTxSecurityContext>
  safeTx?: SafeTransaction
  isCreation?: boolean
}): ReactElement => {
  const wallet = useWallet()
  const chain = useCurrentChain()
  const { safeAddress } = useSafeInfo()

  // Form state
  const [isSubmittable, setIsSubmittable] = useState<boolean>(true)
  const [submitError, setSubmitError] = useState<Error | undefined>()

  // Hooks
  const currentChain = useCurrentChain()
  const { needsRiskConfirmation, isRiskConfirmed, setIsRiskIgnored } = txSecurity
  const { setTxFlow } = useContext(TxModalContext)

  // Estimate gas limit
  const { gasLimit, gasLimitError } = useDeployGasLimit(safeTx)
  const [advancedParams, setAdvancedParams] = useAdvancedParams(gasLimit?.totalGas)

  // On modal submit
  const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault()
    onSubmit?.(Math.random().toString())

    if (needsRiskConfirmation && !isRiskConfirmed) {
      setIsRiskIgnored(true)
      return
    }

    setIsSubmittable(false)
    setSubmitError(undefined)

    const txOptions = getTxOptions(advancedParams, currentChain)

    try {
      trackEvent({ ...OVERVIEW_EVENTS.PROCEED_WITH_TX, label: TX_TYPES.activate_with_tx })

      await deploySafeAndExecuteTx(txOptions, wallet, safeAddress, safeTx, wallet?.provider)

      trackEvent({ ...TX_EVENTS.CREATE, label: TX_TYPES.activate_with_tx })
      trackEvent({ ...TX_EVENTS.EXECUTE, label: TX_TYPES.activate_with_tx })
      trackEvent(WALLET_EVENTS.ONCHAIN_INTERACTION)
    } catch (_err) {
      const err = asError(_err)
      trackError(Errors._804, err)
      setIsSubmittable(true)
      setSubmitError(err)
      return
    }

    setTxFlow(undefined)
  }

  const walletCanPay = useWalletCanPay({
    gasLimit: gasLimit?.totalGas,
    maxFeePerGas: advancedParams.maxFeePerGas,
  })

  const cannotPropose = !isOwner && !onlyExecute
  const submitDisabled =
    !safeTx ||
    !isSubmittable ||
    disableSubmit ||
    isExecutionLoop ||
    cannotPropose ||
    (needsRiskConfirmation && !isRiskConfirmed)

  return (
    <>
      <form onSubmit={handleSubmit}>
        <Alert severity="info" sx={{ mb: 2, border: 0 }}>
          Executing this transaction will activate your account.
          <br />
          <ul style={{ margin: 0, padding: '4px 16px 0' }}>
            <li>
              Base fee: &asymp;{' '}
              <strong>
                {getTotalFeeFormatted(advancedParams.maxFeePerGas, BigInt(gasLimit?.safeTxGas || '0'), chain)}{' '}
                {chain?.nativeCurrency.symbol}
              </strong>
            </li>
            <li>
              One-time activation fee: &asymp;{' '}
              <strong>
                {getTotalFeeFormatted(advancedParams.maxFeePerGas, BigInt(gasLimit?.safeDeploymentGas || '0'), chain)}{' '}
                {chain?.nativeCurrency.symbol}
              </strong>
            </li>
          </ul>
        </Alert>

        <div className={classNames(commonCss.params)}>
          <AdvancedParams
            willExecute
            params={advancedParams}
            recommendedGasLimit={gasLimit?.totalGas}
            onFormSubmit={setAdvancedParams}
            gasLimitError={gasLimitError}
            willRelay={false}
          />
        </div>

        {/* Error messages */}
        {cannotPropose ? (
          <NonOwnerError />
        ) : isExecutionLoop ? (
          <ErrorMessage>
            Cannot execute a transaction from the Safe Account itself, please connect a different account.
          </ErrorMessage>
        ) : !walletCanPay ? (
          <ErrorMessage>Your connected wallet doesn&apos;t have enough funds to execute this transaction.</ErrorMessage>
        ) : (
          gasLimitError && (
            <ErrorMessage error={gasLimitError}>
              This transaction will most likely fail.
              {` To save gas costs, ${isCreation ? 'avoid creating' : 'reject'} this transaction.`}
            </ErrorMessage>
          )
        )}

        {submitError && (
          <Box mt={1}>
            <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
          </Box>
        )}

        <Divider className={commonCss.nestedDivider} sx={{ pt: 3 }} />

        <CardActions>
          {/* Submit button */}
          <CheckWallet allowNonOwner={onlyExecute} checkNetwork={!submitDisabled}>
            {(isOk) => (
              <Button variant="contained" type="submit" disabled={!isOk || submitDisabled} sx={{ minWidth: '112px' }}>
                {!isSubmittable ? <CircularProgress size={20} /> : 'Execute'}
              </Button>
            )}
          </CheckWallet>
        </CardActions>
      </form>
    </>
  )
}

const useTxSecurityContext = () => useContext(TxSecurityContext)

export default madProps(CounterfactualForm, {
  isOwner: useIsSafeOwner,
  isExecutionLoop: useIsExecutionLoop,
  txSecurity: useTxSecurityContext,
})
</file>

<file path="src/features/counterfactual/CounterfactualHooks.tsx">
import CounterfactualSuccessScreen from '@/features/counterfactual/CounterfactualSuccessScreen'
import dynamic from 'next/dynamic'

const LazyCounterfactual = dynamic(() => import('./LazyCounterfactual'))

function CounterfactualHooks() {
  return (
    <>
      <CounterfactualSuccessScreen />
      <LazyCounterfactual />
    </>
  )
}

export default CounterfactualHooks
</file>

<file path="src/features/counterfactual/CounterfactualStatusButton.tsx">
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import useSafeInfo from '@/hooks/useSafeInfo'
import InfoIcon from '@/public/images/notifications/info.svg'
import { useAppSelector } from '@/store'
import AutorenewRoundedIcon from '@mui/icons-material/AutorenewRounded'
import { IconButton, Tooltip, type SvgIconProps } from '@mui/material'
import classnames from 'classnames'
import css from './styles.module.css'

export const LoopIcon = (props: SvgIconProps) => {
  return (
    <AutorenewRoundedIcon
      {...props}
      sx={{
        ...props.sx,
        animation: 'spin 2s linear infinite',
        '@keyframes spin': {
          '0%': {
            transform: 'rotate(0)',
          },
          '100%': {
            transform: 'rotate(360deg)',
          },
        },
      }}
    />
  )
}

const CounterfactualStatusButton = () => {
  const { safe, safeAddress } = useSafeInfo()
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, safe.chainId, safeAddress))

  if (safe.deployed) return null

  const isActivating = undeployedSafe?.status.status !== 'AWAITING_EXECUTION'

  return (
    <Tooltip
      placement="right"
      title={isActivating ? 'Safe Account is being activated' : 'Safe Account is not activated'}
      arrow
    >
      <IconButton
        data-testid="pending-activation-icon"
        className={classnames(css.statusButton, { [css.processing]: isActivating })}
        size="small"
        color={isActivating ? 'info' : 'warning'}
        disableRipple
      >
        {isActivating ? <LoopIcon /> : <InfoIcon />}
      </IconButton>
    </Tooltip>
  )
}

export default CounterfactualStatusButton
</file>

<file path="src/features/counterfactual/CounterfactualSuccessScreen.tsx">
import EthHashInfo from '@/components/common/EthHashInfo'
import { safeCreationPendingStatuses } from '@/features/counterfactual/hooks/usePendingSafeStatuses'
import { SafeCreationEvent, safeCreationSubscribe } from '@/features/counterfactual/services/safeCreationEvents'
import { useChain, useCurrentChain } from '@/hooks/useChains'
import { useEffect, useState } from 'react'
import { Box, Button, Dialog, DialogContent, Typography } from '@mui/material'
import CheckRoundedIcon from '@mui/icons-material/CheckRounded'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import NetworkLogosList from '../multichain/components/NetworkLogosList'
import useAllAddressBooks from '@/hooks/useAllAddressBooks'

const CounterfactualSuccessScreen = () => {
  const [open, setOpen] = useState<boolean>(false)
  const [safeAddress, setSafeAddress] = useState<string>()
  const [chainId, setChainId] = useState<string>()
  const [event, setEvent] = useState<SafeCreationEvent>()
  const currentChain = useCurrentChain()
  const chain = useChain(chainId || currentChain?.chainId || '')
  const [networks, setNetworks] = useState<ChainInfo[]>([])
  const addressBooks = useAllAddressBooks()
  const safeName = safeAddress && chain ? addressBooks?.[chain.chainId]?.[safeAddress] : ''
  const isCFCreation = event === SafeCreationEvent.AWAITING_EXECUTION
  const isMultiChain = networks.length > 1
  const chainName = isMultiChain ? '' : isCFCreation ? networks[0].chainName : chain?.chainName

  useEffect(() => {
    const unsubFns = Object.entries(safeCreationPendingStatuses).map(([event]) =>
      safeCreationSubscribe(event as SafeCreationEvent, async (detail) => {
        setEvent(event as SafeCreationEvent)

        if (event === SafeCreationEvent.INDEXED) {
          if ('chainId' in detail) {
            setChainId(detail.chainId)
            setNetworks((prev) => prev.filter((network) => network.chainId === detail.chainId))
          }

          setSafeAddress(detail.safeAddress)
          setOpen(true)
        }
        if (event === SafeCreationEvent.AWAITING_EXECUTION) {
          if ('networks' in detail) setNetworks(detail.networks)
          setSafeAddress(detail.safeAddress)
          setOpen(true)
        }
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [])

  const onClose = () => {
    setChainId(undefined)
    setOpen(false)
  }

  return (
    <Dialog open={open}>
      <DialogContent
        sx={{
          py: 10,
          px: 6,
          display: 'flex',
          justifyContent: 'center',
          flexDirection: 'column',
          alignItems: 'center',
          gap: 3,
        }}
      >
        <Box
          sx={{
            backgroundColor: ({ palette }) => palette.success.background,
            padding: 3,
            borderRadius: '50%',
            display: 'inline-flex',
          }}
        >
          <CheckRoundedIcon sx={{ width: 50, height: 50 }} color="success" />
        </Box>

        <Box
          data-testid="safe-activation-message"
          sx={{
            textAlign: 'center',
          }}
        >
          <Typography
            data-testid="account-success-message"
            variant="h3"
            sx={{
              fontWeight: 'bold',
              mb: 1,
            }}
          >
            {isCFCreation ? 'Your account is almost set!' : 'Your account is all set!'}
          </Typography>
          <Typography variant="body2">
            {isCFCreation
              ? `Activate the account ${isMultiChain ? 'per network' : ''} to unlock all features of your smart wallet.`
              : 'Start your journey to the smart account security now.'}
          </Typography>
          <Typography variant="body2">
            {isCFCreation && isMultiChain
              ? `You can use the address below to receive funds on the selected ${
                  isMultiChain ? 'networks' : 'network'
                }.`
              : `Use your address to receive funds ${chainName ? `on ${chainName}` : ''}`}
          </Typography>
        </Box>

        {safeAddress && (
          <Box
            data-testid="safe-info"
            sx={{
              p: 2,
              bgcolor: 'background.main',
              borderRadius: 1,
              fontSize: 14,
            }}
          >
            <NetworkLogosList networks={networks.length > 0 ? networks : chain ? [chain] : []} />
            <Typography
              variant="h5"
              sx={{
                mt: 2,
              }}
            >
              {safeName}
            </Typography>
            <EthHashInfo
              address={safeAddress}
              showCopyButton
              shortAddress={false}
              showAvatar={false}
              showName={false}
              showPrefix={false}
            />
          </Box>
        )}

        <Button variant="contained" onClick={onClose} data-testid="cf-creation-lets-go-btn">
          Let&apos;s go
        </Button>
      </DialogContent>
    </Dialog>
  )
}

export default CounterfactualSuccessScreen
</file>

<file path="src/features/counterfactual/FirstTxFlow.tsx">
import { AppRoutes } from '@/config/routes'
import { useIsRecoverySupported } from '@/features/recovery/hooks/useIsRecoverySupported'
import useRecovery from '@/features/recovery/hooks/useRecovery'
import dynamic from 'next/dynamic'
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import { useRouter } from 'next/router'
import { useContext } from 'react'
import { Grid } from '@mui/material'
import ModalDialog from '@/components/common/ModalDialog'
import ChoiceButton from '@/components/common/ChoiceButton'
import { TxModalContext } from '@/components/tx-flow'
import { AddOwnerFlow, TokenTransferFlow, UpsertRecoveryFlow } from '@/components/tx-flow/flows'
const ActivateAccountFlow = dynamic(() => import('./ActivateAccountFlow'))
import { useTxBuilderApp } from '@/hooks/safe-apps/useTxBuilderApp'
import AssetsIcon from '@/public/images/sidebar/assets.svg'
import SaveAddressIcon from '@/public/images/common/save-address.svg'
import RecoveryPlus from '@/public/images/common/recovery-plus.svg'
import SwapIcon from '@/public/images/common/swap.svg'
import SafeLogo from '@/public/images/logo-no-text.svg'
import HandymanOutlinedIcon from '@mui/icons-material/HandymanOutlined'
import useIsSwapFeatureEnabled from '../swap/hooks/useIsSwapFeatureEnabled'

const FirstTxFlow = ({ open, onClose }: { open: boolean; onClose: () => void }) => {
  const txBuilder = useTxBuilderApp()
  const router = useRouter()
  const { setTxFlow } = useContext(TxModalContext)
  const supportsRecovery = useIsRecoverySupported()
  const [recovery] = useRecovery()
  const isSwapFeatureEnabled = useIsSwapFeatureEnabled()

  const handleClick = (onClick: () => void) => {
    onClose()
    onClick()
  }

  const onSendToken = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'send_token' })
    setTxFlow(<TokenTransferFlow />)
  }

  const onActivateSafe = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'activate_safe' })
    setTxFlow(<ActivateAccountFlow />)
  }

  const onAddSigner = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'add_signer' })
    setTxFlow(<AddOwnerFlow />)
  }

  const onRecovery = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'setup_recovery' })
    setTxFlow(<UpsertRecoveryFlow />)
  }

  const onSwap = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'swap' })
    router.push(
      isSwapFeatureEnabled
        ? { pathname: AppRoutes.swap, query: router.query }
        : { pathname: AppRoutes.apps.index, query: { ...router.query, categories: 'Aggregator' } },
    )
  }

  const onCustomTransaction = () => {
    if (!txBuilder) return

    trackEvent({ ...OVERVIEW_EVENTS.CHOOSE_TRANSACTION_TYPE, label: 'tx_builder' })
    router.push(txBuilder.link)
  }

  const showRecoveryOption = supportsRecovery && !recovery

  return (
    <ModalDialog open={open} dialogTitle="Create new transaction" hideChainIndicator onClose={onClose}>
      <Grid
        container
        spacing={2}
        sx={{
          justifyContent: 'center',
          flexDirection: 'column',
          p: 3,
        }}
      >
        <Grid item>
          <ChoiceButton
            title="Activate Safe now"
            description="Pay a one-time network fee to deploy your safe onchain"
            icon={SafeLogo}
            onClick={() => handleClick(onActivateSafe)}
          />
        </Grid>

        <Grid item>
          <ChoiceButton
            title="Add another signer"
            description="Improve the security of your Safe Account"
            icon={SaveAddressIcon}
            onClick={() => handleClick(onAddSigner)}
          />
        </Grid>

        {showRecoveryOption && (
          <Grid item>
            <ChoiceButton
              title="Set up recovery"
              description="Ensure you never lose access to your funds"
              icon={RecoveryPlus}
              onClick={() => handleClick(onRecovery)}
            />
          </Grid>
        )}

        <Grid item>
          <ChoiceButton
            title="Swap tokens"
            description="Explore Safe Apps and trade any token"
            icon={SwapIcon}
            onClick={() => handleClick(onSwap)}
          />
        </Grid>

        {txBuilder && (
          <Grid item>
            <ChoiceButton
              title="Custom transaction"
              description="Compose custom contract interactions"
              icon={HandymanOutlinedIcon}
              onClick={() => handleClick(onCustomTransaction)}
            />
          </Grid>
        )}

        <Grid item>
          <ChoiceButton title="Send token" icon={AssetsIcon} onClick={() => handleClick(onSendToken)} />
        </Grid>
      </Grid>
    </ModalDialog>
  )
}

export default FirstTxFlow
</file>

<file path="src/features/counterfactual/LazyCounterfactual.tsx">
import usePendingSafeNotifications from '@/features/counterfactual/hooks/usePendingSafeNotifications'
import usePendingSafeStatus from '@/features/counterfactual/hooks/usePendingSafeStatuses'

const LazyCounterfactual = () => {
  usePendingSafeStatus()
  usePendingSafeNotifications()

  return null
}

export default LazyCounterfactual
</file>

<file path="src/features/counterfactual/PayNowPayLater.tsx">
import type { ChangeEvent, Dispatch, SetStateAction } from 'react'
import classnames from 'classnames'
import { useCurrentChain } from '@/hooks/useChains'
import CheckRoundedIcon from '@mui/icons-material/CheckRounded'
import {
  FormControl,
  FormControlLabel,
  List,
  ListItem,
  ListItemIcon,
  Radio,
  RadioGroup,
  Typography,
} from '@mui/material'

import css from './styles.module.css'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { PayMethod } from '@safe-global/utils/features/counterfactual/types'

const PayNowPayLater = ({
  totalFee,
  canRelay,
  isMultiChain,
  payMethod,
  setPayMethod,
}: {
  totalFee: string
  canRelay: boolean
  isMultiChain: boolean
  payMethod: PayMethod
  setPayMethod: Dispatch<SetStateAction<PayMethod>>
}) => {
  const chain = useCurrentChain()

  const onChoosePayMethod = (_: ChangeEvent<HTMLInputElement>, newPayMethod: string) => {
    setPayMethod(newPayMethod as PayMethod)
  }

  return (
    <>
      <Typography variant="h4" fontWeight="bold">
        Before we continue...
      </Typography>
      {isMultiChain && (
        <ErrorMessage level="info">
          You will need to <b>activate your account</b> separately on each network. Make sure you have funds on your
          wallet to pay the network fee.
        </ErrorMessage>
      )}
      <List>
        {isMultiChain && (
          <ListItem disableGutters>
            <ListItemIcon className={css.listItem}>
              <CheckRoundedIcon fontSize="small" color="inherit" />
            </ListItemIcon>
            <Typography variant="body2">
              Start exploring the accounts now, and activate them later to start making transactions
            </Typography>
          </ListItem>
        )}
        <ListItem disableGutters>
          <ListItemIcon className={css.listItem}>
            <CheckRoundedIcon fontSize="small" color="inherit" />
          </ListItemIcon>
          <Typography variant="body2">There will be a one-time activation fee</Typography>
        </ListItem>
        {!isMultiChain && (
          <ListItem disableGutters>
            <ListItemIcon className={css.listItem}>
              <CheckRoundedIcon fontSize="small" color="inherit" />
            </ListItemIcon>
            <Typography variant="body2">
              If you choose to pay later, the fee will be included with the first transaction you make.
            </Typography>
          </ListItem>
        )}
        <ListItem disableGutters>
          <ListItemIcon className={css.listItem}>
            <CheckRoundedIcon fontSize="small" color="inherit" />
          </ListItemIcon>
          <Typography variant="body2">Safe doesn&apos;t profit from the fees.</Typography>
        </ListItem>
      </List>
      {!isMultiChain && (
        <FormControl fullWidth>
          <RadioGroup row value={payMethod} onChange={onChoosePayMethod} className={css.radioGroup}>
            <FormControlLabel
              data-testid="pay-now-execution-method"
              sx={{ flex: 1 }}
              value={PayMethod.PayNow}
              className={classnames(css.radioContainer, { [css.active]: payMethod === PayMethod.PayNow })}
              label={
                <>
                  <Typography className={css.radioTitle}>Pay now</Typography>
                  <Typography className={css.radioSubtitle} variant="body2" color="text.secondary">
                    {canRelay ? (
                      'Sponsored free transaction'
                    ) : (
                      <>
                        &asymp; {totalFee} {chain?.nativeCurrency.symbol}
                      </>
                    )}
                  </Typography>
                </>
              }
              control={<Radio />}
            />

            <FormControlLabel
              data-testid="connected-wallet-execution-method"
              sx={{ flex: 1 }}
              value={PayMethod.PayLater}
              className={classnames(css.radioContainer, { [css.active]: payMethod === PayMethod.PayLater })}
              label={
                <>
                  <Typography className={css.radioTitle}>Pay later</Typography>
                  <Typography className={css.radioSubtitle} variant="body2" color="text.secondary">
                    with the first transaction
                  </Typography>
                </>
              }
              control={<Radio />}
            />
          </RadioGroup>
        </FormControl>
      )}
    </>
  )
}

export default PayNowPayLater
</file>

<file path="src/features/counterfactual/styles.module.css">
.radioContainer {
  border: 1px solid var(--color-border-light);
  margin: 0;
  border-radius: 6px;
  height: 72px;
  flex-basis: 72px;
  padding: 0 var(--space-1);
}

.radioGroup {
  gap: var(--space-2);
  flex-wrap: wrap;
}

.active {
  outline: 1px solid var(--color-primary-main);
  border-color: var(--color-primary-main);
}

.active .radioTitle {
  font-weight: bold;
}

.listItem {
  min-width: 0;
  margin-right: var(--space-1);
  color: var(--color-primary-main);
}

.active .radioSubtitle {
  color: var(--color-text-primary);
}

.statusButton {
  border-radius: 4px;
  padding: 6px;
  width: 32px;
  height: 32px;
  background: var(--color-warning-background);
  justify-self: flex-end;
  margin-left: auto;
}

.statusButton.processing {
  background: var(--color-info-background);
}

@media (max-width: 400px) {
  .radioGroup {
    flex-direction: column;
  }
}
</file>

<file path="src/features/counterfactual/useCounterfactualBalances.ts">
import { type SafeBalanceResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { getCounterfactualBalance } from '@/features/counterfactual/utils'
import { useWeb3 } from '@/hooks/wallets/web3'
import type { ExtendedSafeInfo } from '@safe-global/store/slices/SafeInfo/types'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { useCurrentChain } from '@/hooks/useChains'

export function useCounterfactualBalances(safe: ExtendedSafeInfo) {
  const web3 = useWeb3()
  const chain = useCurrentChain()
  const safeAddress = safe.address.value
  const isCounterfactual = !safe.deployed

  return useAsync<SafeBalanceResponse | undefined>(() => {
    if (!chain || !isCounterfactual || !safeAddress) return
    return getCounterfactualBalance(safeAddress, web3, chain)
  }, [chain, safeAddress, web3, isCounterfactual])
}
</file>

<file path="src/features/counterfactual/utils.ts">
import { POLLING_INTERVAL } from '@/config/constants'
import { safeCreationDispatch, SafeCreationEvent } from '@/features/counterfactual/services/safeCreationEvents'
import { addUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import { type ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { getWeb3ReadOnly } from '@/hooks/wallets/web3'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { getSafeSDKWithSigner, getUncheckedSigner, tryOffChainTxSigning } from '@/services/tx/tx-sender/sdk'
import { getRelayTxStatus, TaskState } from '@/services/tx/txMonitor'
import type { AppDispatch } from '@/store'
import { defaultSafeInfo } from '@safe-global/store/slices/SafeInfo/utils'
import { didRevert, type EthersError } from '@/utils/ethers-utils'
import { assertProvider, assertTx, assertWallet } from '@/utils/helpers'
import { type DeploySafeProps, type PredictedSafeProps } from '@safe-global/protocol-kit'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import type { SafeTransaction, SafeVersion, TransactionOptions } from '@safe-global/safe-core-sdk-types'
import {
  type ChainInfo,
  ImplementationVersionState,
  type SafeBalanceResponse,
  TokenType,
} from '@safe-global/safe-gateway-typescript-sdk'
import type { BrowserProvider, ContractTransactionResponse, Eip1193Provider, Provider } from 'ethers'
import { getSafeL2SingletonDeployments, getSafeSingletonDeployments } from '@safe-global/safe-deployments'
import { sameAddress } from '@safe-global/utils/utils/addresses'

import { encodeSafeCreationTx } from '@/components/new-safe/create/logic'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'
import type {
  ReplayedSafeProps,
  UndeployedSafe,
  UndeployedSafeProps,
} from '@safe-global/utils/features/counterfactual/store/types'
import { PendingSafeStatus } from '@safe-global/utils/features/counterfactual/store/types'
import type { PayMethod } from '@safe-global/utils/features/counterfactual/types'

export const getUndeployedSafeInfo = (undeployedSafe: UndeployedSafe, address: string, chain: ChainInfo) => {
  const safeSetup = extractCounterfactualSafeSetup(undeployedSafe, chain.chainId)

  if (!safeSetup) {
    throw Error('Could not determine Safe Setup.')
  }
  const latestSafeVersion = getLatestSafeVersion(chain)

  return {
    ...defaultSafeInfo,
    address: { value: address },
    chainId: chain.chainId,
    owners: safeSetup.owners.map((owner) => ({ value: owner })),
    nonce: 0,
    threshold: safeSetup.threshold,
    implementationVersionState: ImplementationVersionState.UP_TO_DATE,
    fallbackHandler: { value: safeSetup.fallbackHandler! },
    version: safeSetup?.safeVersion || latestSafeVersion,
    deployed: false,
  }
}

export const CF_TX_GROUP_KEY = 'cf-tx'

export const dispatchTxExecutionAndDeploySafe = async (
  safeTx: SafeTransaction,
  txOptions: TransactionOptions,
  provider: Eip1193Provider,
  safeAddress: string,
) => {
  const sdk = await getSafeSDKWithSigner(provider)
  const eventParams = { groupKey: CF_TX_GROUP_KEY }

  let result: ContractTransactionResponse | undefined
  try {
    const signedTx = await tryOffChainTxSigning(safeTx, sdk)
    const signer = await getUncheckedSigner(provider)

    const deploymentTx = await sdk.wrapSafeTransactionIntoDeploymentBatch(signedTx, txOptions)

    // We need to estimate the actual gasLimit after the user has signed since it is more accurate than what useDeployGasLimit returns
    const gas = await signer.estimateGas({ data: deploymentTx.data, value: deploymentTx.value, to: deploymentTx.to })

    // @ts-ignore TODO: Check why TransactionResponse type doesn't work
    result = await signer.sendTransaction({ ...deploymentTx, gasLimit: gas })
  } catch (error) {
    safeCreationDispatch(SafeCreationEvent.FAILED, { ...eventParams, error: asError(error), safeAddress })
    throw error
  }

  safeCreationDispatch(SafeCreationEvent.PROCESSING, { ...eventParams, txHash: result!.hash, safeAddress })

  return result!.hash
}

export const deploySafeAndExecuteTx = async (
  txOptions: TransactionOptions,
  wallet: ConnectedWallet | null,
  safeAddress: string,
  safeTx?: SafeTransaction,
  provider?: Eip1193Provider,
) => {
  assertTx(safeTx)
  assertWallet(wallet)
  assertProvider(provider)

  return dispatchTxExecutionAndDeploySafe(safeTx, txOptions, provider, safeAddress)
}

export const getCounterfactualBalance = async (safeAddress: string, provider?: BrowserProvider, chain?: ChainInfo) => {
  let balance: bigint | undefined

  if (!chain) return undefined

  // Fetch balance via the connected wallet.
  // If there is no wallet connected we fetch and cache the balance instead
  if (provider) {
    balance = await provider.getBalance(safeAddress)
  } else {
    balance = (await getWeb3ReadOnly()?.getBalance(safeAddress)) ?? 0n
  }

  return <SafeBalanceResponse>{
    fiatTotal: '0',
    items: [
      {
        tokenInfo: {
          type: TokenType.NATIVE_TOKEN,
          address: ZERO_ADDRESS,
          ...chain?.nativeCurrency,
        },
        balance: balance?.toString(),
        fiatBalance: '0',
        fiatConversion: '0',
      },
    ],
  }
}

export const replayCounterfactualSafeDeployment = (
  chainId: string,
  safeAddress: string,
  replayedSafeProps: ReplayedSafeProps,
  name: string,
  dispatch: AppDispatch,
  payMethod: PayMethod,
) => {
  const undeployedSafe = {
    chainId,
    address: safeAddress,
    type: payMethod,
    safeProps: replayedSafeProps,
  }

  const setup = extractCounterfactualSafeSetup(
    {
      props: replayedSafeProps,
      status: {
        status: PendingSafeStatus.AWAITING_EXECUTION,
        type: payMethod,
      },
    },
    chainId,
  )
  if (!setup) {
    throw Error('Safe Setup could not be decoded')
  }

  dispatch(addUndeployedSafe(undeployedSafe))
}

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

/**
 * Calling getTransaction too fast sometimes fails because the txHash hasn't been
 * picked up by any node yet so we should retry a few times with short delays to
 * make sure the transaction really does/does not exist
 * @param provider
 * @param txHash
 * @param maxAttempts
 */
async function retryGetTransaction(provider: Provider, txHash: string, maxAttempts = 8) {
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const txResponse = await provider.getTransaction(txHash)
    if (txResponse !== null) {
      return txResponse
    }
    if (attempt < maxAttempts - 1) {
      const exponentialDelay = 2 ** attempt * 1000 // 1000, 2000, 4000, 8000, 16000, 32000
      await delay(exponentialDelay)
    }
  }
  throw new Error('Transaction not found')
}

export const checkSafeActivation = async (
  provider: Provider,
  txHash: string,
  safeAddress: string,
  type: PayMethod,
  chainId: string,
  startBlock?: number,
) => {
  try {
    const txResponse = await retryGetTransaction(provider, txHash)

    const replaceableTx = startBlock ? txResponse.replaceableTransaction(startBlock) : txResponse
    const receipt = await replaceableTx?.wait(1)

    /** The receipt should always be non-null as we require 1 confirmation */
    if (receipt === null) {
      throw new Error('Transaction should have a receipt, but got null instead.')
    }

    if (didRevert(receipt)) {
      safeCreationDispatch(SafeCreationEvent.REVERTED, {
        groupKey: CF_TX_GROUP_KEY,
        error: new Error('Transaction reverted'),
        safeAddress,
      })
    }

    safeCreationDispatch(SafeCreationEvent.SUCCESS, {
      groupKey: CF_TX_GROUP_KEY,
      safeAddress,
      type,
      chainId,
    })
  } catch (err) {
    const _err = err as EthersError

    if (_err.reason === 'replaced' || _err.reason === 'repriced') {
      safeCreationDispatch(SafeCreationEvent.SUCCESS, {
        groupKey: CF_TX_GROUP_KEY,
        safeAddress,
        type,
        chainId,
      })
      return
    }

    if (didRevert(_err.receipt)) {
      safeCreationDispatch(SafeCreationEvent.REVERTED, {
        groupKey: CF_TX_GROUP_KEY,
        error: new Error('Transaction reverted'),
        safeAddress,
      })
      return
    }

    safeCreationDispatch(SafeCreationEvent.FAILED, {
      groupKey: CF_TX_GROUP_KEY,
      error: _err,
      safeAddress,
    })
  }
}

export const checkSafeActionViaRelay = (taskId: string, safeAddress: string, type: PayMethod, chainId: string) => {
  const TIMEOUT_TIME = 2 * 60 * 1000 // 2 minutes

  let intervalId: NodeJS.Timeout
  let failAfterTimeoutId: NodeJS.Timeout

  intervalId = setInterval(async () => {
    const status = await getRelayTxStatus(taskId)

    // 404
    if (!status) return

    switch (status.task.taskState) {
      case TaskState.ExecSuccess:
        safeCreationDispatch(SafeCreationEvent.SUCCESS, {
          groupKey: CF_TX_GROUP_KEY,
          safeAddress,
          type,
          chainId,
        })
        break
      case TaskState.ExecReverted:
      case TaskState.Blacklisted:
      case TaskState.Cancelled:
      case TaskState.NotFound:
        safeCreationDispatch(SafeCreationEvent.FAILED, {
          groupKey: CF_TX_GROUP_KEY,
          error: new Error('Transaction failed'),
          safeAddress,
        })
        break
      default:
        // Don't clear interval as we're still waiting for the tx to be relayed
        return
    }

    clearTimeout(failAfterTimeoutId)
    clearInterval(intervalId)
  }, POLLING_INTERVAL)

  failAfterTimeoutId = setTimeout(() => {
    safeCreationDispatch(SafeCreationEvent.FAILED, {
      groupKey: CF_TX_GROUP_KEY,
      error: new Error('Transaction failed'),
      safeAddress,
    })

    clearInterval(intervalId)
  }, TIMEOUT_TIME)
}

export const isReplayedSafeProps = (props: UndeployedSafeProps): props is ReplayedSafeProps =>
  'safeAccountConfig' in props && 'masterCopy' in props && 'factoryAddress' in props && 'saltNonce' in props

export const isPredictedSafeProps = (props: UndeployedSafeProps): props is PredictedSafeProps =>
  'safeAccountConfig' in props && !('masterCopy' in props)

export const determineMasterCopyVersion = (masterCopy: string, chainId: string): SafeVersion | undefined => {
  const SAFE_VERSIONS: SafeVersion[] = ['1.4.1', '1.3.0', '1.2.0', '1.1.1', '1.0.0']
  return SAFE_VERSIONS.find((version) => {
    const isL1Singleton = () => {
      const deployments = getSafeSingletonDeployments({ version })?.networkAddresses[chainId]

      if (Array.isArray(deployments)) {
        return deployments.some((deployment) => sameAddress(masterCopy, deployment))
      }
      return sameAddress(masterCopy, deployments)
    }

    const isL2Singleton = () => {
      const deployments = getSafeL2SingletonDeployments({ version })?.networkAddresses[chainId]

      if (Array.isArray(deployments)) {
        return deployments.some((deployment) => sameAddress(masterCopy, deployment))
      }
      return sameAddress(masterCopy, deployments)
    }

    return isL1Singleton() || isL2Singleton()
  })
}

export const extractCounterfactualSafeSetup = (
  undeployedSafe: UndeployedSafe | undefined,
  chainId: string | undefined,
):
  | {
      owners: string[]
      threshold: number
      fallbackHandler: string | undefined
      safeVersion: SafeVersion | undefined
      saltNonce: string | undefined
    }
  | undefined => {
  if (!undeployedSafe || !chainId || !undeployedSafe.props.safeAccountConfig) {
    return undefined
  }
  const { owners, threshold, fallbackHandler } = undeployedSafe.props.safeAccountConfig
  const { safeVersion, saltNonce } = isPredictedSafeProps(undeployedSafe.props)
    ? (undeployedSafe.props.safeDeploymentConfig ?? {})
    : undeployedSafe.props

  return {
    owners,
    threshold: Number(threshold),
    fallbackHandler,
    safeVersion,
    saltNonce,
  }
}

export const activateReplayedSafe = async (
  chain: ChainInfo,
  props: ReplayedSafeProps,
  provider: BrowserProvider,
  options: DeploySafeProps['options'],
) => {
  const data = encodeSafeCreationTx(props, chain)

  return (await provider.getSigner()).sendTransaction({
    ...options,
    to: props.factoryAddress,
    data,
    value: '0',
  })
}
</file>

<file path="src/features/multichain/components/CreateSafeOnNewChain/index.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import NetworkInput from '@/components/common/NetworkInput'
import { updateAddressBook } from '@/components/new-safe/create/logic/address-book'
import ErrorMessage from '@/components/tx/ErrorMessage'
import useAddressBook from '@/hooks/useAddressBook'
import { CREATE_SAFE_CATEGORY, CREATE_SAFE_EVENTS, OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import { gtmSetChainId } from '@/services/analytics/gtm'
import { showNotification } from '@/store/notificationsSlice'
import { Box, Button, CircularProgress, DialogActions, DialogContent, Stack, Typography } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import { useSafeCreationData } from '../../hooks/useSafeCreationData'
import { replayCounterfactualSafeDeployment } from '@/features/counterfactual/utils'

import useChains from '@/hooks/useChains'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectRpc } from '@/store/settingsSlice'
import { createWeb3ReadOnly } from '@/hooks/wallets/web3'
import { hasMultiChainAddNetworkFeature, predictAddressBasedOnReplayData } from '@/features/multichain/utils/utils'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import ExternalLink from '@/components/common/ExternalLink'
import { useRouter } from 'next/router'
import ChainIndicator from '@/components/common/ChainIndicator'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useMemo, useState } from 'react'
import { useCompatibleNetworks } from '../../hooks/useCompatibleNetworks'
import { MULTICHAIN_HELP_ARTICLE } from '@/config/constants'
import { PayMethod } from '@safe-global/utils/features/counterfactual/types'

type CreateSafeOnNewChainForm = {
  chainId: string
}

type ReplaySafeDialogProps = {
  safeAddress: string
  safeCreationResult: ReturnType<typeof useSafeCreationData>
  replayableChains?: ReturnType<typeof useCompatibleNetworks>
  chain?: ChainInfo
  currentName: string | undefined
  open: boolean
  onClose: () => void
  isUnsupportedSafeCreationVersion?: boolean
}

const ReplaySafeDialog = ({
  safeAddress,
  chain,
  currentName,
  open,
  onClose,
  safeCreationResult,
  replayableChains,
  isUnsupportedSafeCreationVersion,
}: ReplaySafeDialogProps) => {
  const formMethods = useForm<CreateSafeOnNewChainForm>({
    mode: 'all',
    defaultValues: {
      chainId: chain?.chainId || '',
    },
  })
  const { handleSubmit, formState } = formMethods
  const router = useRouter()
  const addressBook = useAddressBook()

  const customRpc = useAppSelector(selectRpc)
  const dispatch = useAppDispatch()
  const [creationError, setCreationError] = useState<Error>()
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false)

  // Load some data
  const [safeCreationData, safeCreationDataError, safeCreationDataLoading] = safeCreationResult

  const onCancel = () => {
    trackEvent({ ...OVERVIEW_EVENTS.CANCEL_ADD_NEW_NETWORK })
    onClose()
  }

  const onFormSubmit = handleSubmit(async (data) => {
    setIsSubmitting(true)

    try {
      const selectedChain = chain ?? replayableChains?.find((config) => config.chainId === data.chainId)
      if (!safeCreationData || !selectedChain) {
        return
      }

      // We need to create a readOnly provider of the deployed chain
      const customRpcUrl = selectedChain ? customRpc?.[selectedChain.chainId] : undefined
      const provider = createWeb3ReadOnly(selectedChain, customRpcUrl)
      if (!provider) {
        return
      }

      // 1. Double check that the creation Data will lead to the correct address
      const predictedAddress = await predictAddressBasedOnReplayData(safeCreationData, provider)
      if (!sameAddress(safeAddress, predictedAddress)) {
        setCreationError(new Error('The replayed Safe leads to an unexpected address'))
        return
      }

      gtmSetChainId(selectedChain.chainId)

      trackEvent({ ...OVERVIEW_EVENTS.SUBMIT_ADD_NEW_NETWORK, label: selectedChain.chainId })

      // 2. Replay Safe creation and add it to the counterfactual Safes
      replayCounterfactualSafeDeployment(
        selectedChain.chainId,
        safeAddress,
        safeCreationData,
        currentName || '',
        dispatch,
        PayMethod.PayLater,
      )

      trackEvent({ ...OVERVIEW_EVENTS.PROCEED_WITH_TX, label: 'counterfactual', category: CREATE_SAFE_CATEGORY })
      trackEvent({ ...CREATE_SAFE_EVENTS.CREATED_SAFE, label: 'counterfactual' })

      router.push({
        query: {
          safe: `${selectedChain.shortName}:${safeAddress}`,
        },
      })

      trackEvent({ ...OVERVIEW_EVENTS.SWITCH_NETWORK, label: selectedChain.chainId })

      dispatch(
        updateAddressBook(
          [selectedChain.chainId],
          safeAddress,
          currentName || '',
          safeCreationData.safeAccountConfig.owners.map((owner) => ({
            address: owner,
            name: addressBook[owner] || '',
          })),
          safeCreationData.safeAccountConfig.threshold,
        ),
      )

      dispatch(
        showNotification({
          variant: 'success',
          groupKey: 'replay-safe-success',
          message: `Successfully added your account on ${selectedChain.chainName}`,
        }),
      )
    } catch (err) {
      console.error(err)
    } finally {
      setIsSubmitting(false)

      // Close modal
      onClose()
    }
  })

  const submitDisabled =
    isUnsupportedSafeCreationVersion ||
    !!safeCreationDataError ||
    safeCreationDataLoading ||
    !formState.isValid ||
    isSubmitting

  const noChainsAvailable =
    !chain && safeCreationData && replayableChains && replayableChains.filter((chain) => chain.available).length === 0

  return (
    <ModalDialog open={open} onClose={onClose} dialogTitle="Add another network" hideChainIndicator>
      <form onSubmit={onFormSubmit} id="recreate-safe">
        <DialogContent data-testid="add-chain-dialog">
          <FormProvider {...formMethods}>
            <Stack spacing={2}>
              <Typography>Add this Safe to another network with the same address.</Typography>

              {chain && (
                <Box
                  data-testid="added-network"
                  sx={{
                    p: 2,
                    backgroundColor: 'background.main',
                    borderRadius: '6px',
                  }}
                >
                  <ChainIndicator chainId={chain.chainId} />
                </Box>
              )}

              <ErrorMessage level="info">
                The Safe will use the initial setup of the copied Safe. Any changes to owners, threshold, modules or the
                Safe&apos;s version will not be reflected in the copy.
              </ErrorMessage>

              {safeCreationDataLoading ? (
                <Stack
                  direction="column"
                  sx={{
                    alignItems: 'center',
                    gap: 1,
                  }}
                >
                  <CircularProgress />
                  <Typography variant="body2">Loading Safe data</Typography>
                </Stack>
              ) : safeCreationDataError ? (
                <ErrorMessage error={safeCreationDataError} level="error">
                  Could not determine the Safe creation parameters.
                </ErrorMessage>
              ) : isUnsupportedSafeCreationVersion ? (
                <ErrorMessage>
                  This account was created from an outdated mastercopy. Adding another network is not possible.
                </ErrorMessage>
              ) : noChainsAvailable ? (
                <ErrorMessage level="error">This Safe cannot be replayed on any chains.</ErrorMessage>
              ) : (
                <>{!chain && <NetworkInput required name="chainId" chainConfigs={replayableChains ?? []} />}</>
              )}

              {creationError && (
                <ErrorMessage error={creationError} level="error">
                  The Safe could not be created with the same address.
                </ErrorMessage>
              )}
            </Stack>
          </FormProvider>
        </DialogContent>
        <DialogActions>
          {isUnsupportedSafeCreationVersion ? (
            <Box
              sx={{
                display: 'flex',
                width: '100%',
                alignItems: 'center',
                justifyContent: 'space-between',
              }}
            >
              <ExternalLink sx={{ flexGrow: 1 }} href={MULTICHAIN_HELP_ARTICLE}>
                Read more
              </ExternalLink>
              <Button variant="contained" onClick={onClose}>
                Got it
              </Button>
            </Box>
          ) : (
            <>
              <Button onClick={onCancel}>Cancel</Button>
              <Button data-testid="modal-add-network-btn" type="submit" variant="contained" disabled={submitDisabled}>
                {isSubmitting ? <CircularProgress size={20} /> : 'Add network'}
              </Button>
            </>
          )}
        </DialogActions>
      </form>
    </ModalDialog>
  )
}

export const CreateSafeOnNewChain = ({
  safeAddress,
  deployedChainIds,
  ...props
}: Omit<
  ReplaySafeDialogProps,
  'safeCreationResult' | 'replayableChains' | 'chain' | 'isUnsupportedSafeCreationVersion'
> & {
  deployedChainIds: string[]
}) => {
  const { configs } = useChains()
  const deployedChains = useMemo(
    () => configs.filter((config) => config.chainId === deployedChainIds[0]),
    [configs, deployedChainIds],
  )

  const safeCreationResult = useSafeCreationData(safeAddress, deployedChains)
  const allCompatibleChains = useCompatibleNetworks(safeCreationResult[0])
  const isUnsupportedSafeCreationVersion = Boolean(!allCompatibleChains?.length)
  const replayableChains = useMemo(
    () =>
      allCompatibleChains?.filter(
        (config) => !deployedChainIds.includes(config.chainId) && hasMultiChainAddNetworkFeature(config),
      ) || [],
    [allCompatibleChains, deployedChainIds],
  )

  return (
    <ReplaySafeDialog
      safeCreationResult={safeCreationResult}
      replayableChains={replayableChains}
      safeAddress={safeAddress}
      isUnsupportedSafeCreationVersion={isUnsupportedSafeCreationVersion}
      {...props}
    />
  )
}

export const CreateSafeOnSpecificChain = ({ ...props }: Omit<ReplaySafeDialogProps, 'replayableChains'>) => {
  return <ReplaySafeDialog {...props} isUnsupportedSafeCreationVersion={false} />
}
</file>

<file path="src/features/multichain/components/NetworkLogosList/index.tsx">
import ChainIndicator from '@/components/common/ChainIndicator'
import { Box } from '@mui/material'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import css from './styles.module.css'

const NetworkLogosList = ({
  networks,
  showHasMore = false,
}: {
  networks: Pick<ChainInfo, 'chainId'>[]
  showHasMore?: boolean
}) => {
  const MAX_NUM_VISIBLE_CHAINS = 4
  const visibleChains = showHasMore ? networks.slice(0, MAX_NUM_VISIBLE_CHAINS) : networks

  return (
    <Box className={css.networks}>
      {visibleChains.map((chain) => (
        <ChainIndicator key={chain.chainId} chainId={chain.chainId} onlyLogo inline />
      ))}
      {showHasMore && networks.length > MAX_NUM_VISIBLE_CHAINS && (
        <Box className={css.moreChainsIndicator}>+{networks.length - MAX_NUM_VISIBLE_CHAINS}</Box>
      )}
    </Box>
  )
}

export default NetworkLogosList
</file>

<file path="src/features/multichain/components/NetworkLogosList/styles.module.css">
.networks {
  display: flex;
  flex-wrap: wrap;
  margin-left: 6px;
  row-gap: 4px;
}

.networks img {
  margin-left: -6px;
  outline: 2px solid var(--color-background-paper);
  border-radius: 50%;
}

.moreChainsIndicator {
  margin-left: -5px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background-color: var(--color-border-light);
  outline: 2px solid var(--color-background-paper);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
}
</file>

<file path="src/features/multichain/components/SignerSetupWarning/ChangeSignerSetupWarning.tsx">
import { Alert } from '@mui/material'
import { useIsMultichainSafe } from '../../hooks/useIsMultichainSafe'
import { useCurrentChain } from '@/hooks/useChains'

export const ChangeSignerSetupWarning = () => {
  const isMultichainSafe = useIsMultichainSafe()
  const currentChain = useCurrentChain()

  if (!isMultichainSafe) return

  return (
    <Alert severity="info" sx={{ border: 'none', mt: 0, mb: 0 }}>
      {`Signers are not consistent across networks on this account. Changing signers will only affect the account on ${currentChain?.chainName}`}
    </Alert>
  )
}
</file>

<file path="src/features/multichain/components/SignerSetupWarning/InconsistentSignerSetupWarning.tsx">
import { useIsMultichainSafe } from '../../hooks/useIsMultichainSafe'
import useChains, { useCurrentChain } from '@/hooks/useChains'
import ErrorMessage from '@/components/tx/ErrorMessage'
import useSafeAddress from '@/hooks/useSafeAddress'
import { useAppSelector } from '@/store'
import { selectCurrency, selectUndeployedSafes, useGetMultipleSafeOverviewsQuery } from '@/store/slices'
import { useAllSafesGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { useMemo } from 'react'
import { getDeviatingSetups, getSafeSetups } from '@/features/multichain/utils/utils'
import { Box, Typography } from '@mui/material'
import ChainIndicator from '@/components/common/ChainIndicator'

const ChainIndicatorList = ({ chainIds }: { chainIds: string[] }) => {
  const { configs } = useChains()

  return (
    <>
      {chainIds.map((chainId, index) => {
        const chain = configs.find((chain) => chain.chainId === chainId)
        return (
          <Box key={chainId} display="inline-flex" flexWrap="wrap" position="relative" top={5}>
            <ChainIndicator key={chainId} chainId={chainId} showUnknown={false} onlyLogo={true} />
            <Typography position="relative" mx={0.5} top={2}>
              {chain && chain.chainName}
              {index === chainIds.length - 1 ? '.' : ','}
            </Typography>
          </Box>
        )
      })}
    </>
  )
}

export const InconsistentSignerSetupWarning = () => {
  const isMultichainSafe = useIsMultichainSafe()
  const safeAddress = useSafeAddress()
  const currentChain = useCurrentChain()
  const currency = useAppSelector(selectCurrency)
  const undeployedSafes = useAppSelector(selectUndeployedSafes)
  const { allMultiChainSafes } = useAllSafesGrouped()

  const multiChainGroupSafes = useMemo(
    () => allMultiChainSafes?.find((account) => sameAddress(safeAddress, account.safes[0].address))?.safes ?? [],
    [allMultiChainSafes, safeAddress],
  )
  const deployedSafes = useMemo(
    () => multiChainGroupSafes.filter((safe) => undeployedSafes[safe.chainId]?.[safe.address] === undefined),
    [multiChainGroupSafes, undeployedSafes],
  )
  const { data: safeOverviews } = useGetMultipleSafeOverviewsQuery({ safes: deployedSafes, currency })

  const safeSetups = useMemo(
    () => getSafeSetups(multiChainGroupSafes, safeOverviews ?? [], undeployedSafes),
    [multiChainGroupSafes, safeOverviews, undeployedSafes],
  )
  const deviatingSetups = getDeviatingSetups(safeSetups, currentChain?.chainId)
  const deviatingChainIds = deviatingSetups.map((setup) => setup?.chainId)

  if (!isMultichainSafe || !deviatingChainIds.length) return

  return (
    <ErrorMessage level="warning" title="Signers are not consistent">
      <Typography display="inline" mr={1}>
        Signers are different on these networks of this account:
      </Typography>
      <ChainIndicatorList chainIds={deviatingChainIds} />
      <Typography display="inline">
        To manage your account easier and to prevent lose of funds, we recommend keeping the same signers.
      </Typography>
    </ErrorMessage>
  )
}
</file>

<file path="src/features/multichain/components/UnsupportedMastercopyWarning/UnsupportedMasterCopyWarning.tsx">
import { TxModalContext } from '@/components/tx-flow'
import { MigrateSafeL2Flow } from '@/components/tx-flow/flows'
import ErrorMessage from '@/components/tx/ErrorMessage'
import useSafeInfo from '@/hooks/useSafeInfo'
import { isMigrationToL2Possible } from '@/services/contracts/safeContracts'
import { Button, Stack, Typography } from '@mui/material'
import { useCallback, useContext } from 'react'
import { isValidMasterCopy } from '@safe-global/utils/services/contracts/safeContracts'

export const UnsupportedMastercopyWarning = () => {
  const { safe } = useSafeInfo()

  const showWarning = !isValidMasterCopy(safe.implementationVersionState) && isMigrationToL2Possible(safe)

  const { setTxFlow } = useContext(TxModalContext)

  const openUpgradeModal = useCallback(() => setTxFlow(<MigrateSafeL2Flow />), [setTxFlow])

  if (!showWarning) return

  return (
    <ErrorMessage level="warning" title="Base contract is not supported">
      <Stack spacing={2}>
        <Typography display="inline" mr={1}>
          Your Safe Account&apos;s base contract is not supported. You should migrate it to a compatible version.
        </Typography>
        <div>
          <Button variant="contained" onClick={openUpgradeModal}>
            Migrate
          </Button>
        </div>
      </Stack>
    </ErrorMessage>
  )
}
</file>

<file path="src/features/multichain/hooks/useCompatibleNetworks.ts">
import useChains from '@/hooks/useChains'
import { hasCanonicalDeployment, hasMatchingDeployment } from '@safe-global/utils/services/contracts/deployments'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { type SafeVersion } from '@safe-global/safe-core-sdk-types'
import {
  getCompatibilityFallbackHandlerDeployments,
  getProxyFactoryDeployments,
  getSafeL2SingletonDeployments,
  getSafeSingletonDeployments,
  getSafeToL2MigrationDeployments,
  getSafeToL2SetupDeployments,
} from '@safe-global/safe-deployments'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReplayedSafeProps } from '@safe-global/utils/features/counterfactual/store/types'

const SUPPORTED_VERSIONS: SafeVersion[] = ['1.4.1', '1.3.0']

/**
 * Returns all chains where the creations's masterCopy and factory are deployed.
 * @param creation
 */
export const useCompatibleNetworks = (
  creation: ReplayedSafeProps | undefined,
): (ChainInfo & { available: boolean })[] => {
  const { configs } = useChains()

  if (!creation) {
    return []
  }

  const { masterCopy, factoryAddress, safeAccountConfig } = creation

  const { fallbackHandler, to } = safeAccountConfig

  return configs.map((config) => {
    const isL1MasterCopy = hasMatchingDeployment(
      getSafeSingletonDeployments,
      masterCopy,
      config.chainId,
      SUPPORTED_VERSIONS,
    )
    const isL2MasterCopy = hasMatchingDeployment(
      getSafeL2SingletonDeployments,
      masterCopy,
      config.chainId,
      SUPPORTED_VERSIONS,
    )
    const masterCopyExists = isL1MasterCopy || isL2MasterCopy

    const proxyFactoryExists = hasMatchingDeployment(
      getProxyFactoryDeployments,
      factoryAddress,
      config.chainId,
      SUPPORTED_VERSIONS,
    )
    const fallbackHandlerExists = hasMatchingDeployment(
      getCompatibilityFallbackHandlerDeployments,
      fallbackHandler,
      config.chainId,
      SUPPORTED_VERSIONS,
    )

    // We only need to check that it is nonzero as useSafeCreationData already validates that it is the setupToL2 call otherwise
    const includesSetupToL2 = to !== ZERO_ADDRESS

    // If the creation includes the setupToL2 call, the contract needs to be deployed on the chain
    const areSetupToL2ConditionsMet =
      !includesSetupToL2 ||
      hasCanonicalDeployment(getSafeToL2SetupDeployments({ network: config.chainId, version: '1.4.1' }), config.chainId)

    // If the masterCopy is L1 on a L2 chain, includes the setupToL2 Call or the Migration contract exists
    const isMigrationRequired = isL1MasterCopy && !includesSetupToL2 && config.l2
    const isMigrationPossible = hasCanonicalDeployment(
      getSafeToL2MigrationDeployments({ network: config.chainId, version: '1.4.1' }),
      config.chainId,
    )
    const areMigrationConditionsMet = !isMigrationRequired || isMigrationPossible

    return {
      ...config,
      available:
        masterCopyExists &&
        proxyFactoryExists &&
        fallbackHandlerExists &&
        areSetupToL2ConditionsMet &&
        areMigrationConditionsMet,
    }
  })
}
</file>

<file path="src/features/multichain/hooks/useIsMultichainSafe.ts">
import { useAllSafesGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import useSafeAddress from '@/hooks/useSafeAddress'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { useMemo } from 'react'

export const useIsMultichainSafe = () => {
  const safeAddress = useSafeAddress()
  const { allMultiChainSafes } = useAllSafesGrouped()

  return useMemo(
    () => allMultiChainSafes?.some((account) => sameAddress(safeAddress, account.safes[0].address)),
    [allMultiChainSafes, safeAddress],
  )
}
</file>

<file path="src/features/multichain/hooks/useSafeCreationData.ts">
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { createWeb3ReadOnly } from '@/hooks/wallets/web3'
import { selectRpc, selectUndeployedSafes } from '@/store/slices'
import { type UndeployedSafe, type ReplayedSafeProps } from '@safe-global/utils/features/counterfactual/store/types'
import { Safe__factory, Safe_proxy_factory__factory } from '@safe-global/utils/types/contracts'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { getCreationTransaction } from '@safe-global/safe-client-gateway-sdk'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useAppSelector } from '@/store'
import { determineMasterCopyVersion, isPredictedSafeProps } from '@/features/counterfactual/utils'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import semverSatisfies from 'semver/functions/satisfies'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { getSafeToL2SetupDeployment } from '@safe-global/safe-deployments'
import { type SafeAccountConfig } from '@safe-global/protocol-kit'

export const SAFE_CREATION_DATA_ERRORS = {
  TX_NOT_FOUND: 'The Safe creation transaction could not be found. Please retry later.',
  NO_CREATION_DATA: 'The Safe creation information for this Safe could not be found or is incomplete.',
  UNSUPPORTED_SAFE_CREATION: 'The method this Safe was created with is not supported.',
  NO_PROVIDER: 'The RPC provider for the origin network is not available.',
  LEGACY_COUNTERFATUAL: 'This undeployed Safe cannot be replayed. Please activate the Safe first.',
  PAYMENT_SAFE: 'The Safe creation used reimbursement. Adding networks to such Safes is not supported.',
  UNSUPPORTED_IMPLEMENTATION:
    'The Safe was created using an unsupported or outdated implementation. Adding networks to this Safe is not possible.',
  UNKNOWN_SETUP_MODULES: 'The Safe creation is using an unknown internal call',
}

export const decodeSetupData = (setupData: string): ReplayedSafeProps['safeAccountConfig'] => {
  const [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver] =
    Safe__factory.createInterface().decodeFunctionData('setup', setupData)

  return {
    owners: [...owners],
    threshold: Number(threshold),
    to,
    data,
    fallbackHandler,
    paymentToken,
    payment: Number(payment),
    paymentReceiver,
  }
}

const getUndeployedSafeCreationData = async (undeployedSafe: UndeployedSafe): Promise<ReplayedSafeProps> => {
  if (isPredictedSafeProps(undeployedSafe.props)) {
    throw new Error(SAFE_CREATION_DATA_ERRORS.LEGACY_COUNTERFATUAL)
  }

  // We already have a replayed Safe. In this case we can return the identical data
  return undeployedSafe.props
}

const validateAccountConfig = (safeAccountConfig: SafeAccountConfig) => {
  // Safes that used the reimbursement logic are not supported
  if (
    (safeAccountConfig.payment && safeAccountConfig.payment > 0) ||
    (safeAccountConfig.paymentToken && safeAccountConfig.paymentToken !== ZERO_ADDRESS)
  ) {
    throw new Error(SAFE_CREATION_DATA_ERRORS.PAYMENT_SAFE)
  }

  const setupToL2Address = getSafeToL2SetupDeployment({ version: '1.4.1' })?.defaultAddress
  if (safeAccountConfig.to !== ZERO_ADDRESS && !sameAddress(safeAccountConfig.to, setupToL2Address)) {
    // Unknown setupModules calls cannot be replayed as the target contract is likely not deployed across chains
    throw new Error(SAFE_CREATION_DATA_ERRORS.UNKNOWN_SETUP_MODULES)
  }
}

const proxyFactoryInterface = Safe_proxy_factory__factory.createInterface()
const createProxySelector = proxyFactoryInterface.getFunction('createProxyWithNonce').selector

/**
 * Loads the creation data from the CGW or infers it from an undeployed Safe.
 *
 * Throws errors for the reasons in {@link SAFE_CREATION_DATA_ERRORS}.
 * Checking the cheap cases not requiring RPC calls first.
 */
const getCreationDataForChain = async (
  chain: ChainInfo,
  undeployedSafe: UndeployedSafe,
  safeAddress: string,
  customRpc: { [chainId: string]: string },
): Promise<ReplayedSafeProps> => {
  // 1. The safe is counterfactual
  if (undeployedSafe) {
    const undeployedCreationData = await getUndeployedSafeCreationData(undeployedSafe)
    validateAccountConfig(undeployedCreationData.safeAccountConfig)

    return undeployedCreationData
  }

  const creation = await getCreationTransaction({
    params: {
      path: {
        chainId: chain.chainId,
        safeAddress,
      },
    },
  })

  if (!creation || !creation.masterCopy || !creation.setupData || creation.setupData === '0x') {
    throw new Error(SAFE_CREATION_DATA_ERRORS.NO_CREATION_DATA)
  }

  // Safes that were deployed with an unknown mastercopy or < 1.3.0 are not supported.
  const safeVersion = determineMasterCopyVersion(creation.masterCopy, chain.chainId)
  if (!safeVersion || semverSatisfies(safeVersion, '<1.3.0')) {
    throw new Error(SAFE_CREATION_DATA_ERRORS.UNSUPPORTED_IMPLEMENTATION)
  }

  const safeAccountConfig = decodeSetupData(creation.setupData)

  validateAccountConfig(safeAccountConfig)

  // We need to create a readOnly provider of the deployed chain
  const customRpcUrl = chain ? customRpc?.[chain.chainId] : undefined
  const provider = createWeb3ReadOnly(chain, customRpcUrl)

  if (!provider) {
    throw new Error(SAFE_CREATION_DATA_ERRORS.NO_PROVIDER)
  }

  // Fetch saltNonce by fetching the transaction from the RPC.
  const tx = await provider.getTransaction(creation.transactionHash)
  if (!tx) {
    throw new Error(SAFE_CREATION_DATA_ERRORS.TX_NOT_FOUND)
  }
  const txData = tx.data
  const startOfTx = txData.indexOf(createProxySelector.slice(2, 10))
  if (startOfTx === -1) {
    throw new Error(SAFE_CREATION_DATA_ERRORS.UNSUPPORTED_SAFE_CREATION)
  }

  // decode tx
  const [masterCopy, initializer, saltNonce] = proxyFactoryInterface.decodeFunctionData(
    'createProxyWithNonce',
    `0x${txData.slice(startOfTx)}`,
  )

  const txMatches =
    sameAddress(masterCopy, creation.masterCopy) &&
    (initializer as string)?.toLowerCase().includes(creation.setupData?.toLowerCase())

  if (!txMatches) {
    // We found the wrong tx. This tx seems to deploy multiple Safes at once. This is not supported yet.
    throw new Error(SAFE_CREATION_DATA_ERRORS.UNSUPPORTED_SAFE_CREATION)
  }

  return {
    factoryAddress: creation.factoryAddress,
    masterCopy: creation.masterCopy,
    safeAccountConfig,
    saltNonce: saltNonce.toString(),
    safeVersion,
  }
}

/**
 * Fetches the data with which the given Safe was originally created.
 * Useful to replay a Safe creation.
 */
export const useSafeCreationData = (safeAddress: string, chains: ChainInfo[]): AsyncResult<ReplayedSafeProps> => {
  const customRpc = useAppSelector(selectRpc)

  const undeployedSafes = useAppSelector(selectUndeployedSafes)

  return useAsync<ReplayedSafeProps | undefined>(async () => {
    let lastError: Error | undefined = undefined
    try {
      for (const chain of chains) {
        const undeployedSafe = undeployedSafes[chain.chainId]?.[safeAddress]

        try {
          return await getCreationDataForChain(chain, undeployedSafe, safeAddress, customRpc)
        } catch (err) {
          lastError = asError(err)
        }
      }
      if (lastError) {
        // We want to know why the creation was not possible by throwing one of the errors
        throw lastError
      }
    } catch (err) {
      logError(ErrorCodes._816, err)
      throw err
    }
  }, [chains, customRpc, safeAddress, undeployedSafes])
}
</file>

<file path="src/features/multichain/utils/utils.ts">
import type { DecodedDataResponse, ChainInfo, SafeOverview } from '@safe-global/safe-gateway-typescript-sdk'
import semverSatisfies from 'semver/functions/satisfies'
import memoize from 'lodash/memoize'
import { keccak256, ethers, solidityPacked, getCreate2Address, type Provider } from 'ethers'

import {
  type UndeployedSafesState,
  type ReplayedSafeProps,
} from '@safe-global/utils/features/counterfactual/store/types'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { Safe_proxy_factory__factory } from '@safe-global/utils/types/contracts'
import { extractCounterfactualSafeSetup } from '@/features/counterfactual/utils'
import { encodeSafeSetupCall } from '@/components/new-safe/create/logic'
import { type SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import { type MultiChainSafeItem } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { LATEST_SAFE_VERSION } from '@safe-global/utils/config/constants'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

type SafeSetup = {
  owners: string[]
  threshold: number
  chainId: string
}

export const isChangingSignerSetup = (decodedData: DecodedDataResponse | undefined) => {
  return decodedData?.method === 'addOwnerWithThreshold' || decodedData?.method === 'removeOwner'
}

export const isMultiChainSafeItem = (safe: SafeItem | MultiChainSafeItem): safe is MultiChainSafeItem => {
  if ('safes' in safe && 'address' in safe) {
    return true
  }
  return false
}

export const isSafeItem = (safe: SafeItem | MultiChainSafeItem): safe is SafeItem => {
  return !isMultiChainSafeItem(safe)
}

const areOwnersMatching = (owners1: string[], owners2: string[]) =>
  owners1.length === owners2.length && owners1.every((owner) => owners2.some((owner2) => sameAddress(owner, owner2)))

export const getSafeSetups = (
  safes: SafeItem[],
  safeOverviews: SafeOverview[],
  undeployedSafes: UndeployedSafesState,
): (SafeSetup | undefined)[] => {
  const safeSetups = safes.map((safeItem) => {
    const undeployedSafe = undeployedSafes?.[safeItem.chainId]?.[safeItem.address]
    if (undeployedSafe) {
      const counterfactualSetup = extractCounterfactualSafeSetup(undeployedSafe, safeItem.chainId)
      if (!counterfactualSetup) return undefined
      return {
        owners: counterfactualSetup.owners,
        threshold: counterfactualSetup.threshold,
        chainId: safeItem.chainId,
      }
    }
    const foundOverview = safeOverviews?.find(
      (overview) => overview.chainId === safeItem.chainId && sameAddress(overview.address.value, safeItem.address),
    )
    if (!foundOverview) return undefined
    return {
      owners: foundOverview.owners.map((owner) => owner.value),
      threshold: foundOverview.threshold,
      chainId: safeItem.chainId,
    }
  })
  return safeSetups
}

export const getSharedSetup = (safeSetups: (SafeSetup | undefined)[]): Omit<SafeSetup, 'chainId'> | undefined => {
  const comparisonSetup = safeSetups[0]

  if (!comparisonSetup) return undefined

  const allMatching = safeSetups.every(
    (setup) =>
      setup && areOwnersMatching(setup.owners, comparisonSetup.owners) && setup.threshold === comparisonSetup.threshold,
  )

  const { owners, threshold } = comparisonSetup
  return allMatching ? { owners, threshold } : undefined
}

export const getDeviatingSetups = (
  safeSetups: (SafeSetup | undefined)[],
  currentChainId: string | undefined,
): SafeSetup[] => {
  const currentSafeSetup = safeSetups.find((setup) => setup?.chainId === currentChainId)
  if (!currentChainId || !currentSafeSetup) return []

  const deviatingSetups = safeSetups
    .filter((setup): setup is SafeSetup => Boolean(setup))
    .filter((setup) => {
      return (
        setup &&
        (!areOwnersMatching(setup.owners, currentSafeSetup.owners) || setup.threshold !== currentSafeSetup.threshold)
      )
    })
  return deviatingSetups
}

const memoizedGetProxyCreationCode = memoize(
  async (factoryAddress: string, provider: Provider) => {
    return Safe_proxy_factory__factory.connect(factoryAddress, provider).proxyCreationCode()
  },
  async (factoryAddress, provider) => `${factoryAddress}${(await provider.getNetwork()).chainId}`,
)

export const predictSafeAddress = async (
  setupData: { initializer: string; saltNonce: string; singleton: string },
  factoryAddress: string,
  provider: Provider,
) => {
  // Step 1: Hash the initializer
  const initializerHash = keccak256(setupData.initializer)

  // Step 2: Encode the initializerHash and saltNonce using abi.encodePacked equivalent
  const encoded = ethers.concat([initializerHash, solidityPacked(['uint256'], [setupData.saltNonce])])

  // Step 3: Hash the encoded value to get the final salt
  const salt = keccak256(encoded)

  // Get Proxy creation code
  const proxyCreationCode = await memoizedGetProxyCreationCode(factoryAddress, provider)

  const initCode = proxyCreationCode + solidityPacked(['uint256'], [setupData.singleton]).slice(2)
  return getCreate2Address(factoryAddress, salt, keccak256(initCode))
}

export const predictAddressBasedOnReplayData = async (safeCreationData: ReplayedSafeProps, provider: Provider) => {
  const initializer = encodeSafeSetupCall(safeCreationData.safeAccountConfig)
  return predictSafeAddress(
    { initializer, saltNonce: safeCreationData.saltNonce, singleton: safeCreationData.masterCopy },
    safeCreationData.factoryAddress,
    provider,
  )
}

const canMultichain = (chain: ChainInfo) => {
  const MIN_SAFE_VERSION = '1.4.1'
  return hasFeature(chain, FEATURES.COUNTERFACTUAL) && semverSatisfies(LATEST_SAFE_VERSION, `>=${MIN_SAFE_VERSION}`)
}

export const hasMultiChainCreationFeatures = (chain: ChainInfo): boolean => {
  return hasFeature(chain, FEATURES.MULTI_CHAIN_SAFE_CREATION) && canMultichain(chain)
}

export const hasMultiChainAddNetworkFeature = (chain: ChainInfo | undefined): boolean => {
  if (!chain) return false
  return hasFeature(chain, FEATURES.MULTI_CHAIN_SAFE_ADD_NETWORK) && canMultichain(chain)
}
</file>

<file path="src/features/myAccounts/components/AccountInfoChips/index.tsx">
import { Box, Chip, Typography, useMediaQuery, useTheme } from '@mui/material'
import VisibilityIcon from '@mui/icons-material/Visibility'
import { LoopIcon } from '@/features/counterfactual/CounterfactualStatusButton'
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline'
import css from './styles.module.css'
import QueueActions from '../QueueActions'
import type { ChainInfo, SafeOverview } from '@safe-global/safe-gateway-typescript-sdk'
import type { UrlObject } from 'url'
import Link from 'next/link'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS } from '@/services/analytics'

const AccountStatusChip = ({ isActivating }: { isActivating: boolean }) => {
  return (
    <Chip
      className={css.chip}
      sx={{
        backgroundColor: isActivating ? 'var(--color-info-light)' : 'var(--color-warning-background)',
      }}
      size="small"
      label={isActivating ? 'Activating account' : 'Not activated'}
      icon={
        isActivating ? (
          <LoopIcon fontSize="small" className={css.pendingLoopIcon} sx={{ mr: '-4px', ml: '4px' }} />
        ) : (
          <ErrorOutlineIcon fontSize="small" color="warning" />
        )
      }
    />
  )
}

const ReadOnlyChip = () => {
  return (
    <Chip
      data-testid="read-only-chip"
      className={css.chip}
      sx={{ color: 'var(--color-primary-light)', borderColor: 'var(--color-border-light)' }}
      variant="outlined"
      size="small"
      icon={<VisibilityIcon className={css.visibilityIcon} />}
      label={
        <Typography variant="caption" display="flex" alignItems="center" gap={0.5}>
          Read-only
        </Typography>
      }
    />
  )
}

export const AccountInfoChips = ({
  isActivating,
  isReadOnly,
  undeployedSafe,
  isVisible,
  safeOverview,
  chain,
  href,
  onLinkClick,
  trackingLabel,
}: {
  isActivating: boolean
  isReadOnly: boolean
  isVisible: boolean
  undeployedSafe: boolean
  safeOverview: SafeOverview | null
  chain: ChainInfo | undefined
  href: UrlObject | string
  onLinkClick: (() => void) | undefined
  trackingLabel: string
}) => {
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))
  const showQueueActions = isVisible && !undeployedSafe && !isReadOnly

  return (
    <Box sx={{ width: '100%', mt: 0.3 }}>
      {undeployedSafe ? (
        <>
          {isMobile ? (
            <Track {...OVERVIEW_EVENTS.OPEN_SAFE} label={trackingLabel}>
              <Link onClick={onLinkClick} href={href}>
                <AccountStatusChip isActivating={isActivating} />
              </Link>
            </Track>
          ) : (
            // For larger screens, the Chip is within the parent Link
            <AccountStatusChip isActivating={isActivating} />
          )}
        </>
      ) : isReadOnly ? (
        <>
          {isMobile ? (
            <Track {...OVERVIEW_EVENTS.OPEN_SAFE} label={trackingLabel}>
              <Link onClick={onLinkClick} href={href}>
                <ReadOnlyChip />
              </Link>
            </Track>
          ) : (
            // For larger screens, the Chip is within the parent Link
            <ReadOnlyChip />
          )}
        </>
      ) : showQueueActions && safeOverview ? (
        <QueueActions
          isMobile={isMobile}
          queued={safeOverview?.queued || 0}
          awaitingConfirmation={safeOverview?.awaitingConfirmation || 0}
          safeAddress={safeOverview?.address.value}
          chainShortName={chain?.shortName || ''}
        />
      ) : null}
    </Box>
  )
}
</file>

<file path="src/features/myAccounts/components/AccountInfoChips/styles.module.css">
.chip {
  border-radius: var(--space-2);
  padding-left: 4px;
  padding-right: 4px;
}

.visibilityIcon {
  font-size: 16px !important;
  color: var(--color-border-main) !important;
}

.pendingLoopIcon {
  color: var(--color-info-dark) !important;
}

@media (max-width: 600px) {
  .chip {
    margin: 0 var(--space-2) var(--space-2) var(--space-2);
  }
}
</file>

<file path="src/features/myAccounts/components/AccountItems/MultiAccountItem.tsx">
import { selectUndeployedSafes } from '@/features/counterfactual/store/undeployedSafesSlice'
import NetworkLogosList from '@/features/multichain/components/NetworkLogosList'
import type { SafeListProps } from '@/features/myAccounts/components/SafesList'
import SpaceSafeContextMenu from '@/features/spaces/components/SafeAccounts/SpaceSafeContextMenu'
import { showNotification } from '@/store/notificationsSlice'
import SingleAccountItem from '@/features/myAccounts/components/AccountItems/SingleAccountItem'
import type { SafeOverview } from '@safe-global/safe-gateway-typescript-sdk'
import { useCallback, useMemo, useState } from 'react'
import {
  ListItemButton,
  Box,
  Typography,
  Skeleton,
  Accordion,
  AccordionDetails,
  AccordionSummary,
  Divider,
  Tooltip,
  SvgIcon,
  IconButton,
  useMediaQuery,
} from '@mui/material'
import SafeIcon from '@/components/common/SafeIcon'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS, PIN_SAFE_LABELS, trackEvent } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import { useAppDispatch, useAppSelector } from '@/store'
import css from './styles.module.css'
import useSafeAddress from '@/hooks/useSafeAddress'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import classnames from 'classnames'
import { useRouter } from 'next/router'
import FiatValue from '@/components/common/FiatValue'
import { type MultiChainSafeItem } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import { type SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import { getSafeSetups, getSharedSetup, hasMultiChainAddNetworkFeature } from '@/features/multichain/utils/utils'
import { AddNetworkButton } from '../AddNetworkButton'
import { isPredictedSafeProps } from '@/features/counterfactual/utils'
import ChainIndicator from '@/components/common/ChainIndicator'
import MultiAccountContextMenu from '@/components/sidebar/SafeListContextMenu/MultiAccountContextMenu'
import { useGetMultipleSafeOverviewsQuery } from '@/store/api/gateway'
import useWallet from '@/hooks/wallets/useWallet'
import { selectCurrency } from '@/store/settingsSlice'
import { selectChains } from '@/store/chainsSlice'
import BookmarkIcon from '@/public/images/apps/bookmark.svg'
import BookmarkedIcon from '@/public/images/apps/bookmarked.svg'
import { addOrUpdateSafe, pinSafe, selectAllAddedSafes, unpinSafe } from '@/store/addedSafesSlice'
import { defaultSafeInfo } from '@safe-global/store/slices/SafeInfo/utils'
import { selectOrderByPreference } from '@/store/orderByPreferenceSlice'
import { getComparator } from '@/features/myAccounts/utils/utils'
import { useIsSpaceRoute } from '@/hooks/useIsSpaceRoute'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useTheme } from '@mui/material/styles'

export const MultichainIndicator = ({ safes }: { safes: SafeItem[] }) => {
  return (
    <Box className={css.multiChains}>
      <Tooltip
        title={
          <Box data-testid="multichain-tooltip">
            <Typography fontSize="14px">Multichain account on:</Typography>
            {safes.map((safeItem) => (
              <Box key={safeItem.chainId} sx={{ p: '4px 0px' }}>
                <ChainIndicator chainId={safeItem.chainId} />
              </Box>
            ))}
          </Box>
        }
        arrow
      >
        <Box>
          <NetworkLogosList networks={safes} showHasMore />
        </Box>
      </Tooltip>
    </Box>
  )
}

function useMultiAccountItemData(multiSafeAccountItem: MultiChainSafeItem) {
  const { address, safes, isPinned, name } = multiSafeAccountItem

  const router = useRouter()
  const isWelcomePage = router.pathname === AppRoutes.welcome.accounts
  const isSpaceRoute = useIsSpaceRoute()
  const safeAddress = useSafeAddress()
  const isCurrentSafe = sameAddress(safeAddress, address)

  const { orderBy } = useAppSelector(selectOrderByPreference)
  const sortComparator = useMemo(() => getComparator(orderBy), [orderBy])
  const sortedSafes = useMemo(() => [...safes].sort(sortComparator), [safes, sortComparator])

  const undeployedSafes = useAppSelector(selectUndeployedSafes)
  const deployedSafes = useMemo(
    () => sortedSafes.filter((safe) => !undeployedSafes[safe.chainId]?.[safe.address]),
    [sortedSafes, undeployedSafes],
  )

  const currency = useAppSelector(selectCurrency)
  const { address: walletAddress = '' } = useWallet() || {}

  const { data: safeOverviews } = useGetMultipleSafeOverviewsQuery({ currency, walletAddress, safes: deployedSafes })

  const safeSetups = useMemo(
    () => getSafeSetups(sortedSafes, safeOverviews ?? [], undeployedSafes),
    [safeOverviews, sortedSafes, undeployedSafes],
  )
  const sharedSetup = useMemo(() => getSharedSetup(safeSetups), [safeSetups])

  const totalFiatValue = useMemo(
    () => safeOverviews?.reduce((sum, overview) => sum + Number(overview.fiatTotal), 0),
    [safeOverviews],
  )

  const chains = useAppSelector(selectChains)
  const hasReplayableSafe = useMemo(() => {
    return sortedSafes.some((safeItem) => {
      const undeployedSafe = undeployedSafes[safeItem.chainId]?.[safeItem.address]
      const chain = chains.data.find((chain) => chain.chainId === safeItem.chainId)
      const addNetworkFeatureEnabled = hasMultiChainAddNetworkFeature(chain)
      // Replayable if deployed or new counterfactual safe and the chain supports add network
      return (!undeployedSafe || !isPredictedSafeProps(undeployedSafe.props)) && addNetworkFeatureEnabled
    })
  }, [chains.data, sortedSafes, undeployedSafes])

  const isReadOnly = useMemo(() => sortedSafes.every((safe) => safe.isReadOnly), [sortedSafes])

  const deployedChainIds = useMemo(() => sortedSafes.map((safe) => safe.chainId), [sortedSafes])

  return {
    address,
    name,
    sortedSafes,
    safeOverviews,
    sharedSetup,
    totalFiatValue,
    hasReplayableSafe,
    isPinned,
    isCurrentSafe,
    isReadOnly,
    isWelcomePage,
    deployedChainIds,
    isSpaceRoute,
  }
}

function usePinActions(
  address: string,
  name: string | undefined,
  safes: SafeItem[],
  safeOverviews: SafeOverview[] | undefined,
) {
  const dispatch = useAppDispatch()
  const allAddedSafes = useAppSelector(selectAllAddedSafes)

  const findOverview = useCallback(
    (item: SafeItem) => {
      return safeOverviews?.find(
        (overview) => item.chainId === overview.chainId && sameAddress(overview.address.value, item.address),
      )
    },
    [safeOverviews],
  )

  const addToPinnedList = useCallback(() => {
    const isGroupAdded = safes.every((safe) => allAddedSafes[safe.chainId]?.[safe.address])
    if (isGroupAdded) {
      for (const safe of safes) {
        dispatch(pinSafe({ chainId: safe.chainId, address: safe.address }))
      }
    } else {
      for (const safe of safes) {
        const overview = findOverview(safe)
        dispatch(
          addOrUpdateSafe({
            safe: {
              ...defaultSafeInfo,
              chainId: safe.chainId,
              address: { value: address },
              owners: overview ? overview.owners : defaultSafeInfo.owners,
              threshold: overview ? overview.threshold : defaultSafeInfo.threshold,
            },
          }),
        )
        dispatch(pinSafe({ chainId: safe.chainId, address: safe.address }))
      }
    }

    dispatch(
      showNotification({
        title: 'Pinned multi-chain Safe',
        message: name ?? shortenAddress(address),
        groupKey: `pin-safe-success-${address}`,
        variant: 'success',
      }),
    )

    trackEvent({ ...OVERVIEW_EVENTS.PIN_SAFE, label: PIN_SAFE_LABELS.pin })
  }, [name, safes, allAddedSafes, dispatch, findOverview, address])

  const removeFromPinnedList = useCallback(() => {
    for (const safe of safes) {
      dispatch(unpinSafe({ chainId: safe.chainId, address: safe.address }))
    }

    dispatch(
      showNotification({
        title: 'Unpinned multi-chain Safe',
        message: name ?? shortenAddress(address),
        groupKey: `unpin-safe-success-${address}`,
        variant: 'success',
      }),
    )

    trackEvent({ ...OVERVIEW_EVENTS.PIN_SAFE, label: PIN_SAFE_LABELS.unpin })
  }, [dispatch, name, address, safes])

  return { addToPinnedList, removeFromPinnedList }
}

type MultiAccountItemProps = {
  multiSafeAccountItem: MultiChainSafeItem
  safeOverviews?: SafeOverview[]
  onLinkClick?: SafeListProps['onLinkClick']
  isSpaceSafe?: boolean
}

const MultiAccountItem = ({ onLinkClick, multiSafeAccountItem, isSpaceSafe = false }: MultiAccountItemProps) => {
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))

  const {
    address,
    name,
    sortedSafes,
    safeOverviews,
    sharedSetup,
    totalFiatValue,
    hasReplayableSafe,
    isPinned,
    isCurrentSafe,
    isReadOnly,
    isWelcomePage,
    deployedChainIds,
    isSpaceRoute,
  } = useMultiAccountItemData(multiSafeAccountItem)
  const { addToPinnedList, removeFromPinnedList } = usePinActions(address, name, sortedSafes, safeOverviews)

  const [expanded, setExpanded] = useState(isCurrentSafe)
  const trackingLabel = isWelcomePage ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar

  const toggleExpand = () => {
    setExpanded((prev) => {
      if (!prev && !isSpaceRoute) {
        trackEvent({ ...OVERVIEW_EVENTS.EXPAND_MULTI_SAFE, label: trackingLabel })
      }
      return !prev
    })
  }

  return (
    <ListItemButton
      data-testid="safe-list-item"
      selected={isCurrentSafe}
      className={classnames(css.multiListItem, css.listItem, { [css.currentListItem]: isCurrentSafe })}
      sx={{ p: 0 }}
    >
      <Accordion data-testid="multichain-item-summary" expanded={expanded} sx={{ border: 'none' }}>
        <AccordionSummary
          onClick={toggleExpand}
          sx={{
            pl: 0,
            '& .MuiAccordionSummary-content': { m: '0 !important', alignItems: 'center' },
            '&.Mui-expanded': { backgroundColor: 'transparent !important' },
          }}
          component="div"
        >
          <Box className={classnames(css.multiSafeLink, css.safeLink)} width="100%">
            <Box sx={{ pr: 2.5 }} data-testid="group-safe-icon">
              <SafeIcon address={address} owners={sharedSetup?.owners.length} threshold={sharedSetup?.threshold} />
            </Box>

            <Typography variant="body2" component="div" className={css.safeAddress}>
              <EthHashInfo
                address={address}
                name={multiSafeAccountItem.name}
                shortAddress
                showPrefix={false}
                showAvatar={false}
                copyPrefix={false}
                copyAddress={!isMobile}
              />
            </Typography>
            <MultichainIndicator safes={sortedSafes} />
            <Typography
              data-testid="group-balance"
              variant="body2"
              sx={{
                fontWeight: 'bold',
                textAlign: 'right',
                pl: 2,
              }}
            >
              {totalFiatValue !== undefined ? (
                <FiatValue value={totalFiatValue} />
              ) : (
                <Skeleton variant="text" sx={{ ml: 'auto' }} />
              )}
            </Typography>
          </Box>

          {!isSpaceSafe && (
            <IconButton
              data-testid="bookmark-icon"
              edge="end"
              size="medium"
              sx={{ mx: 1 }}
              onClick={(event) => {
                event.stopPropagation()
                isPinned ? removeFromPinnedList() : addToPinnedList()
              }}
            >
              <SvgIcon
                component={isPinned ? BookmarkedIcon : BookmarkIcon}
                inheritViewBox
                color={isPinned ? 'primary' : undefined}
                fontSize="small"
              />
            </IconButton>
          )}

          {isSpaceSafe ? (
            <>
              <Box width="40px" /> {/* Spacer for the send button */}
              <SpaceSafeContextMenu safeItem={multiSafeAccountItem} />
            </>
          ) : (
            <MultiAccountContextMenu
              name={multiSafeAccountItem.name ?? ''}
              address={address}
              chainIds={deployedChainIds}
              addNetwork={hasReplayableSafe}
            />
          )}
        </AccordionSummary>
        <AccordionDetails sx={{ padding: '0px 12px' }}>
          <Box data-testid="subacounts-container">
            {sortedSafes.map((safeItem) => (
              <SingleAccountItem
                onLinkClick={onLinkClick}
                safeItem={safeItem}
                key={`${safeItem.chainId}:${safeItem.address}`}
                isMultiChainItem
                isSpaceSafe={isSpaceSafe}
              />
            ))}
          </Box>
          {!isReadOnly && hasReplayableSafe && !isSpaceSafe && (
            <>
              <Divider sx={{ ml: '-12px', mr: '-12px' }} />
              <Box
                sx={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  ml: '-12px',
                  mr: '-12px',
                }}
              >
                <AddNetworkButton
                  currentName={multiSafeAccountItem.name ?? ''}
                  safeAddress={address}
                  deployedChains={sortedSafes.map((safe) => safe.chainId)}
                />
              </Box>
            </>
          )}
        </AccordionDetails>
      </Accordion>
    </ListItemButton>
  )
}

export default MultiAccountItem
</file>

<file path="src/features/myAccounts/components/AccountItems/SingleAccountItem.tsx">
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import type { SafeListProps } from '@/features/myAccounts/components/SafesList'
import SpaceSafeContextMenu from '@/features/spaces/components/SafeAccounts/SpaceSafeContextMenu'
import { type SafeOverview } from '@safe-global/safe-gateway-typescript-sdk'
import { useMemo, useRef } from 'react'
import { ListItemButton, Box, Typography, IconButton, SvgIcon, Skeleton, useTheme, useMediaQuery } from '@mui/material'
import Link from 'next/link'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS, PIN_SAFE_LABELS, trackEvent } from '@/services/analytics'
import { AppRoutes } from '@/config/routes'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectChainById } from '@/store/chainsSlice'
import ChainIndicator from '@/components/common/ChainIndicator'
import css from './styles.module.css'
import { selectAllAddressBooks } from '@/store/addressBookSlice'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import SafeListContextMenu from '@/components/sidebar/SafeListContextMenu'
import useSafeAddress from '@/hooks/useSafeAddress'
import useChainId from '@/hooks/useChainId'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import classnames from 'classnames'
import { useRouter } from 'next/router'
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import { useGetHref } from '@/features/myAccounts/hooks/useGetHref'
import { extractCounterfactualSafeSetup, isPredictedSafeProps } from '@/features/counterfactual/utils'
import useWallet from '@/hooks/wallets/useWallet'
import { hasMultiChainAddNetworkFeature } from '@/features/multichain/utils/utils'
import BookmarkIcon from '@/public/images/apps/bookmark.svg'
import BookmarkedIcon from '@/public/images/apps/bookmarked.svg'
import { addOrUpdateSafe, unpinSafe } from '@/store/addedSafesSlice'
import SafeIcon from '@/components/common/SafeIcon'
import useOnceVisible from '@/hooks/useOnceVisible'
import { skipToken } from '@reduxjs/toolkit/query'
import { showNotification, useGetSafeOverviewQuery } from '@/store/slices'
import { defaultSafeInfo } from '@safe-global/store/slices/SafeInfo/utils'
import FiatValue from '@/components/common/FiatValue'
import { AccountInfoChips } from '../AccountInfoChips'
import SendTransactionButton from '@/features/spaces/components/SafeAccounts/SendTransactionButton'
import EthHashInfo from '@/components/common/EthHashInfo'

type AccountItemProps = {
  safeItem: SafeItem
  safeOverview?: SafeOverview
  onLinkClick?: SafeListProps['onLinkClick']
  isMultiChainItem?: boolean
  isSpaceSafe?: boolean
}

const SingleAccountItem = ({
  onLinkClick,
  safeItem,
  isMultiChainItem = false,
  isSpaceSafe = false,
}: AccountItemProps) => {
  const { chainId, address, isReadOnly, isPinned } = safeItem
  const chain = useAppSelector((state) => selectChainById(state, chainId))
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, chainId, address))
  const safeAddress = useSafeAddress()
  const currChainId = useChainId()
  const router = useRouter()
  const isCurrentSafe = chainId === currChainId && sameAddress(safeAddress, address)
  const isWelcomePage = router.pathname === AppRoutes.welcome.accounts
  const { address: walletAddress } = useWallet() ?? {}
  const elementRef = useRef<HTMLDivElement>(null)
  const isVisible = useOnceVisible(elementRef)
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))

  const dispatch = useAppDispatch()

  const trackingLabel = isWelcomePage
    ? OVERVIEW_LABELS.login_page
    : isSpaceSafe
      ? OVERVIEW_LABELS.space_page
      : OVERVIEW_LABELS.sidebar

  const getHref = useGetHref(router)

  const href = useMemo(() => {
    return chain ? getHref(chain, address) : ''
  }, [chain, getHref, address])

  const name = useAppSelector(selectAllAddressBooks)[chainId]?.[address]

  const isActivating = undeployedSafe?.status.status !== 'AWAITING_EXECUTION'

  const counterfactualSetup = undeployedSafe
    ? extractCounterfactualSafeSetup(undeployedSafe, chain?.chainId)
    : undefined

  const addNetworkFeatureEnabled = hasMultiChainAddNetworkFeature(chain)
  const isReplayable =
    addNetworkFeatureEnabled && !isReadOnly && (!undeployedSafe || !isPredictedSafeProps(undeployedSafe.props))

  const { data: safeOverview } = useGetSafeOverviewQuery(
    undeployedSafe || !isVisible
      ? skipToken
      : {
          chainId: safeItem.chainId,
          safeAddress: safeItem.address,
          walletAddress,
        },
  )

  const safeThreshold = safeOverview?.threshold ?? counterfactualSetup?.threshold ?? defaultSafeInfo.threshold
  const safeOwners =
    safeOverview?.owners ?? counterfactualSetup?.owners.map((address) => ({ value: address })) ?? defaultSafeInfo.owners

  const addToPinnedList = () => {
    dispatch(
      addOrUpdateSafe({
        safe: {
          ...defaultSafeInfo,
          chainId,
          address: { value: address },
          owners: safeOwners,
          threshold: safeThreshold,
        },
      }),
    )

    dispatch(
      showNotification({
        title: 'Pinned Safe',
        message: name ?? shortenAddress(address),
        groupKey: `pin-safe-success-${address}`,
        variant: 'success',
      }),
    )

    trackEvent({ ...OVERVIEW_EVENTS.PIN_SAFE, label: PIN_SAFE_LABELS.pin })
  }

  const removeFromPinnedList = () => {
    dispatch(unpinSafe({ chainId, address }))

    dispatch(
      showNotification({
        title: 'Unpinned Safe',
        message: name ?? shortenAddress(address),
        groupKey: `unpin-safe-success-${address}`,
        variant: 'success',
      }),
    )

    trackEvent({ ...OVERVIEW_EVENTS.PIN_SAFE, label: PIN_SAFE_LABELS.unpin })
  }

  const content = (
    <>
      <Box
        sx={{
          pr: 2.5,
        }}
      >
        <SafeIcon
          address={address}
          owners={safeOwners.length > 0 ? safeOwners.length : undefined}
          threshold={safeThreshold > 0 ? safeThreshold : undefined}
          isMultiChainItem={isMultiChainItem}
          chainId={chainId}
        />
      </Box>

      <Typography variant="body2" component="div" className={css.safeAddress}>
        {isMultiChainItem ? (
          <Typography
            component="span"
            sx={{
              color: 'var(--color-primary-light)',
              fontSize: 'inherit',
            }}
          >
            {chain?.chainName}
          </Typography>
        ) : (
          <EthHashInfo
            address={address}
            name={name}
            shortAddress
            chainId={chain?.chainId}
            showAvatar={false}
            copyAddress={!isMobile}
          />
        )}
        {!isMobile && (
          <AccountInfoChips
            isActivating={isActivating}
            isReadOnly={isReadOnly}
            undeployedSafe={!!undeployedSafe}
            isVisible={isVisible}
            safeOverview={safeOverview ?? null}
            chain={chain}
            href={href}
            onLinkClick={onLinkClick}
            trackingLabel={trackingLabel}
          />
        )}
      </Typography>

      {!isMultiChainItem ? (
        <ChainIndicator chainId={chainId} responsive onlyLogo className={css.chainIndicator} />
      ) : (
        <div />
      )}

      <Typography variant="body2" sx={{ fontWeight: 'bold', textAlign: 'right', pl: 2 }}>
        {undeployedSafe ? null : safeOverview ? (
          <FiatValue value={safeOverview.fiatTotal} />
        ) : (
          <Skeleton variant="text" sx={{ ml: 'auto' }} />
        )}
      </Typography>
    </>
  )

  const actions = (
    <>
      {!isMultiChainItem && !isSpaceSafe && (
        <IconButton
          data-testid="bookmark-icon"
          edge="end"
          size="medium"
          sx={{ mx: 1 }}
          onClick={isPinned ? removeFromPinnedList : addToPinnedList}
        >
          <SvgIcon
            component={isPinned ? BookmarkedIcon : BookmarkIcon}
            inheritViewBox
            color={isPinned ? 'primary' : undefined}
            fontSize="small"
          />
        </IconButton>
      )}

      {isSpaceSafe ? (
        <>
          {safeOverview && <SendTransactionButton safe={safeOverview} />}
          <SpaceSafeContextMenu safeItem={safeItem} />
        </>
      ) : (
        !isMultiChainItem && (
          <SafeListContextMenu
            name={name}
            address={address}
            chainId={chainId}
            addNetwork={isReplayable}
            rename
            undeployedSafe={!!undeployedSafe}
            onClose={onLinkClick}
          />
        )
      )}

      {isMobile && (
        <AccountInfoChips
          isActivating={isActivating}
          isReadOnly={isReadOnly}
          undeployedSafe={!!undeployedSafe}
          isVisible={isVisible}
          safeOverview={safeOverview ?? null}
          chain={chain}
          href={href}
          onLinkClick={onLinkClick}
          trackingLabel={trackingLabel}
        />
      )}
    </>
  )

  return (
    <ListItemButton
      ref={elementRef}
      data-testid="safe-list-item"
      selected={isCurrentSafe}
      className={classnames(css.listItem, { [css.currentListItem]: isCurrentSafe })}
    >
      <Track {...OVERVIEW_EVENTS.OPEN_SAFE} label={trackingLabel}>
        <Link onClick={onLinkClick} href={href} className={css.safeLink}>
          {content}
        </Link>
      </Track>

      {actions}
    </ListItemButton>
  )
}

export default SingleAccountItem
</file>

<file path="src/features/myAccounts/components/AccountItems/styles.module.css">
.listItem {
  border: 1px solid var(--color-border-light);
  border-radius: var(--space-1);
  margin-bottom: 12px;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 0;
  flex-wrap: wrap;
}

.currentListItem {
  border: 1px solid var(--color-secondary-light);
  border-left-width: 6px;
  background-color: var(--color-background-light) !important;
}

.currentListItem.multiListItem {
  border: 1px solid var(--color-border-light);
  background-color: none;
}

.listItem :global .MuiAccordion-root,
.listItem :global .MuiAccordion-root:hover > .MuiAccordionSummary-root {
  background-color: transparent;
}

.listItem :global .MuiAccordion-root.Mui-expanded {
  background-color: var(--color-background-paper);
}

.listItem {
  background-color: var(--color-background-paper);
}

.listItem.subItem {
  margin-bottom: 8px;
}

.subItem .borderLeft {
  top: 0;
  bottom: 0;
  position: absolute;
  border-radius: 6px;
  border: 1px solid var(--color-border-light);
}

.subItem.currentListItem .borderLeft {
  border-left: 4px solid var(--color-secondary-light);
}

.listItem > :first-child {
  flex: 1;
  width: 90%;
}

.safeLink {
  display: grid;
  padding: var(--space-2) var(--space-1) var(--space-2) var(--space-2);
  grid-template-columns: 60px 10fr 2fr 3fr;
  align-items: center;
}

.multiSafeLink {
  grid-template-columns: 60px 8fr 5fr 3fr;
}

.safeSubLink {
  grid-template-columns: 60px 3fr minmax(auto, 2fr);
}

.safeName,
.safeAddress {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.safeAddress :global .ethHashInfo-name {
  font-weight: bold;
}

.listHeader {
  display: flex;
}

.listHeader svg path {
  stroke: var(--color-text-primary);
}

.multiChains {
  display: flex;
  justify-content: flex-end;
}

.multiChains > span {
  margin-left: -5px;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  outline: 2px solid var(--color-background-paper);
}

.chainIndicator {
  justify-content: flex-end;
}

.chipSection {
  width: 100%;
}

.chipSection:empty {
  display: none;
}

@media (max-width: 899.95px) {
  .safeLink {
    padding-right: 0;
  }
}

@media (max-width: 599.95px) {
  .safeLink {
    grid-template-columns: auto 1fr auto;
    grid-template-areas:
      'a b d'
      'a c d';
  }

  .safeLink :nth-child(1) {
    grid-area: a;
  }
  .safeLink :nth-child(2) {
    grid-area: b;
  }
  .safeLink :nth-child(3) {
    grid-area: c;
    text-align: left;
  }
  .safeLink :nth-child(4) {
    grid-area: d;
  }

  .multiChains {
    justify-content: flex-start;
  }

  .chainIndicator {
    justify-content: flex-start;
  }
}
</file>

<file path="src/features/myAccounts/components/AccountListFilters/index.tsx">
import { useAppDispatch, useAppSelector } from '@/store'
import { type OrderByOption, selectOrderByPreference, setOrderByPreference } from '@/store/orderByPreferenceSlice'
import debounce from 'lodash/debounce'
import { type Dispatch, type SetStateAction, useCallback } from 'react'
import OrderByButton from '@/features/myAccounts/components/OrderByButton'
import css from '@/features/myAccounts/styles.module.css'
import SearchIcon from '@/public/images/common/search.svg'
import { Box, InputAdornment, Paper, SvgIcon, TextField } from '@mui/material'

const AccountListFilters = ({ setSearchQuery }: { setSearchQuery: Dispatch<SetStateAction<string>> }) => {
  const dispatch = useAppDispatch()
  const { orderBy } = useAppSelector(selectOrderByPreference)

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const handleSearch = useCallback(debounce(setSearchQuery, 300), [])

  const handleOrderByChange = (orderBy: OrderByOption) => {
    dispatch(setOrderByPreference({ orderBy }))
  }

  return (
    <Paper sx={{ px: 2, py: 1 }}>
      <Box display="flex" justifyContent="space-between" width="100%" gap={1}>
        <TextField
          id="search-by-name"
          placeholder="Search by name, ENS, address, or chain"
          aria-label="Search Safe list by name"
          variant="filled"
          hiddenLabel
          onChange={(e) => {
            handleSearch(e.target.value)
          }}
          className={css.search}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SvgIcon
                  component={SearchIcon}
                  inheritViewBox
                  fontWeight="bold"
                  fontSize="small"
                  sx={{
                    color: 'var(--color-border-main)',
                    '.MuiInputBase-root.Mui-focused &': { color: 'var(--color-text-primary)' },
                  }}
                />
              </InputAdornment>
            ),
            disableUnderline: true,
          }}
          fullWidth
          size="small"
        />
        <OrderByButton orderBy={orderBy} onOrderByChange={handleOrderByChange} />
      </Box>
    </Paper>
  )
}

export default AccountListFilters
</file>

<file path="src/features/myAccounts/components/AccountsHeader/index.tsx">
import ConnectWalletButton from '@/components/common/ConnectWallet/ConnectWalletButton'
import Track from '@/components/common/Track'
import { AppRoutes } from '@/config/routes'
import AccountsNavigation from '@/features/myAccounts/components/AccountsNavigation'
import CreateButton from '@/features/myAccounts/components/CreateButton'
import css from '@/features/myAccounts/styles.module.css'
import { useHasFeature } from '@/hooks/useChains'
import useWallet from '@/hooks/wallets/useWallet'
import AddIcon from '@/public/images/common/add.svg'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { FEATURES } from '@safe-global/utils/utils/chains'
import { Box, Button, Link, SvgIcon, Typography } from '@mui/material'
import classNames from 'classnames'
import { useRouter } from 'next/router'

const AddSafeButton = ({ trackingLabel, onLinkClick }: { trackingLabel: string; onLinkClick?: () => void }) => {
  return (
    <Track {...OVERVIEW_EVENTS.ADD_TO_WATCHLIST} label={trackingLabel}>
      <Link href={AppRoutes.newSafe.load}>
        <Button
          data-testid="add-safe-button"
          disableElevation
          variant="outlined"
          size="small"
          onClick={onLinkClick}
          startIcon={<SvgIcon component={AddIcon} inheritViewBox fontSize="small" />}
          sx={{ height: '36px', width: '100%', px: 2 }}
        >
          <Box mt="1px">Add</Box>
        </Button>
      </Link>
    </Track>
  )
}

const AccountsHeader = ({ isSidebar, onLinkClick }: { isSidebar: boolean; onLinkClick?: () => void }) => {
  const wallet = useWallet()
  const router = useRouter()
  const isSpacesFeatureEnabled = useHasFeature(FEATURES.SPACES)
  const isLoginPage = router.pathname === AppRoutes.welcome.accounts
  const trackingLabel = isLoginPage ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar

  return (
    <Box className={classNames(css.header, { [css.sidebarHeader]: isSidebar })}>
      {isSidebar || !isSpacesFeatureEnabled ? (
        <Typography variant="h1" fontWeight={700} className={css.title}>
          Accounts
        </Typography>
      ) : (
        <AccountsNavigation />
      )}

      <Box className={css.headerButtons}>
        <AddSafeButton trackingLabel={trackingLabel} onLinkClick={onLinkClick} />

        {wallet ? (
          <Track {...OVERVIEW_EVENTS.CREATE_NEW_SAFE} label={trackingLabel}>
            <CreateButton isPrimary />
          </Track>
        ) : (
          <Box sx={{ '& button': { height: '36px' } }}>
            <ConnectWalletButton small={true} />
          </Box>
        )}
      </Box>
    </Box>
  )
}

export default AccountsHeader
</file>

<file path="src/features/myAccounts/components/AccountsList/index.tsx">
import FilteredSafes from '@/features/myAccounts/components/FilteredSafes'
import PinnedSafes from '@/features/myAccounts/components/PinnedSafes'
import CurrentSafe from '@/features/myAccounts/components/CurrentSafe'
import type { AllSafeItems, AllSafeItemsGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import AllSafes from '@/features/myAccounts/components/AllSafes'
import { getComparator } from '@/features/myAccounts/utils/utils'
import { useAppSelector } from '@/store'
import { selectOrderByPreference } from '@/store/orderByPreferenceSlice'
import { useMemo } from 'react'

const AccountsList = ({
  searchQuery,
  safes,
  onLinkClick,
  isSidebar,
}: {
  searchQuery: string
  safes: AllSafeItemsGrouped
  onLinkClick?: () => void
  isSidebar: boolean
}) => {
  const { orderBy } = useAppSelector(selectOrderByPreference)
  const sortComparator = getComparator(orderBy)

  const allSafes = useMemo<AllSafeItems>(
    () => [...(safes.allMultiChainSafes ?? []), ...(safes.allSingleSafes ?? [])].sort(sortComparator),
    [safes.allMultiChainSafes, safes.allSingleSafes, sortComparator],
  )

  if (searchQuery) {
    return <FilteredSafes searchQuery={searchQuery} allSafes={allSafes} onLinkClick={onLinkClick} />
  }

  return (
    <>
      <CurrentSafe allSafes={allSafes} onLinkClick={onLinkClick} />
      <PinnedSafes allSafes={allSafes} onLinkClick={onLinkClick} />
      <AllSafes allSafes={allSafes} onLinkClick={onLinkClick} isSidebar={isSidebar} />
    </>
  )
}

export default AccountsList
</file>

<file path="src/features/myAccounts/components/AccountsNavigation/index.tsx">
import { AppRoutes } from '@/config/routes'
import css from '@/features/myAccounts/styles.module.css'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import { Chip, Stack, Typography } from '@mui/material'
import classNames from 'classnames'
import { useRouter } from 'next/router'
import Link from 'next/link'
import { trackEvent } from '@/services/analytics'

const AccountsNavigation = () => {
  const router = useRouter()

  const isActiveNavigation = (pathname: string) => {
    return router.pathname === pathname
  }

  const trackSpacesClick = () => {
    if (!isActiveNavigation(AppRoutes.welcome.spaces)) {
      trackEvent({ ...SPACE_EVENTS.OPEN_SPACE_LIST_PAGE, label: SPACE_LABELS.accounts_page })
    }
  }

  return (
    <Stack direction="row" gap={2} flexWrap="wrap">
      <Typography variant="h1" fontWeight={700} className={css.title}>
        <Link
          href={AppRoutes.welcome.accounts}
          className={classNames(css.link, { [css.active]: isActiveNavigation(AppRoutes.welcome.accounts) })}
        >
          Accounts
        </Link>
      </Typography>

      <Typography variant="h1" fontWeight={700} className={css.title}>
        <Link
          onClick={trackSpacesClick}
          href={AppRoutes.welcome.spaces}
          className={classNames(css.link, { [css.active]: isActiveNavigation(AppRoutes.welcome.spaces) })}
        >
          Spaces
          <Chip label="Beta" size="small" sx={{ ml: 1, fontWeight: 'normal', borderRadius: '4px' }} />
        </Link>
      </Typography>
    </Stack>
  )
}

export default AccountsNavigation
</file>

<file path="src/features/myAccounts/components/AddNetworkButton/index.tsx">
import Track from '@/components/common/Track'
import { CreateSafeOnNewChain } from '@/features/multichain/components/CreateSafeOnNewChain'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import { Button } from '@mui/material'
import { useState } from 'react'
import PlusIcon from '@/public/images/common/plus.svg'

export const AddNetworkButton = ({
  safeAddress,
  currentName,
  deployedChains,
}: {
  safeAddress: string
  currentName: string | undefined
  deployedChains: string[]
}) => {
  const [open, setOpen] = useState(false)

  return (
    <>
      <Track {...OVERVIEW_EVENTS.ADD_NEW_NETWORK} label={OVERVIEW_LABELS.sidebar}>
        <Button data-testid="add-network-btn" variant="text" fullWidth onClick={() => setOpen(true)}>
          <PlusIcon /> Add another network
        </Button>
      </Track>

      {open && (
        <CreateSafeOnNewChain
          open={open}
          onClose={() => setOpen(false)}
          currentName={currentName}
          safeAddress={safeAddress}
          deployedChainIds={deployedChains}
        />
      )}
    </>
  )
}
</file>

<file path="src/features/myAccounts/components/AllSafes/index.tsx">
import ConnectWalletButton from '@/components/common/ConnectWallet/ConnectWalletButton'
import Track from '@/components/common/Track'
import { AppRoutes } from '@/config/routes'
import SafesList from '@/features/myAccounts/components/SafesList'
import type { AllSafeItems } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import css from '@/features/myAccounts/styles.module.css'
import useWallet from '@/hooks/wallets/useWallet'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import { Accordion, AccordionDetails, AccordionSummary, Box, Typography } from '@mui/material'
import { useRouter } from 'next/router'

const AllSafes = ({
  allSafes,
  onLinkClick,
  isSidebar,
}: {
  allSafes: AllSafeItems
  onLinkClick?: () => void
  isSidebar: boolean
}) => {
  const wallet = useWallet()
  const router = useRouter()

  const isLoginPage = router.pathname === AppRoutes.welcome.accounts
  const trackingLabel = isLoginPage ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar

  return (
    <Accordion sx={{ border: 'none' }} defaultExpanded={!isSidebar} slotProps={{ transition: { unmountOnExit: true } }}>
      <AccordionSummary
        data-testid="expand-safes-list"
        expandIcon={<ExpandMoreIcon sx={{ '& path': { fill: 'var(--color-text-secondary)' } }} />}
        sx={{
          padding: 0,
          '& .MuiAccordionSummary-content': { margin: '0 !important', mb: 1, flexGrow: 0 },
        }}
        component="div"
      >
        <div className={css.listHeader}>
          <Typography variant="h5" fontWeight={700}>
            Accounts
            {allSafes && allSafes.length > 0 && (
              <Typography component="span" color="text.secondary" fontSize="inherit" fontWeight="normal" mr={1}>
                {' '}
                ({allSafes.length})
              </Typography>
            )}
          </Typography>
        </div>
      </AccordionSummary>
      <AccordionDetails data-testid="accounts-list" sx={{ padding: 0 }}>
        {allSafes.length > 0 ? (
          <Box mt={1}>
            <SafesList safes={allSafes} onLinkClick={onLinkClick} />
          </Box>
        ) : (
          <Typography
            data-testid="empty-account-list"
            component="div"
            variant="body2"
            color="text.secondary"
            textAlign="center"
            py={3}
            mx="auto"
            width={250}
          >
            {!wallet ? (
              <>
                <Box mb={2}>Connect a wallet to view your Safe Accounts or to create a new one</Box>
                <Track {...OVERVIEW_EVENTS.OPEN_ONBOARD} label={trackingLabel}>
                  <ConnectWalletButton text="Connect a wallet" contained />
                </Track>
              </>
            ) : (
              "You don't have any safes yet"
            )}
          </Typography>
        )}
      </AccordionDetails>
    </Accordion>
  )
}

export default AllSafes
</file>

<file path="src/features/myAccounts/components/CreateButton/index.tsx">
import { Button } from '@mui/material'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'

const buttonSx = { width: ['100%', 'auto'], height: '36px', px: 2 }

const CreateButton = ({ isPrimary }: { isPrimary: boolean }) => {
  return (
    <Link href={AppRoutes.newSafe.create} passHref legacyBehavior>
      <Button
        data-testid="create-safe-btn"
        disableElevation
        size="small"
        variant={isPrimary ? 'contained' : 'outlined'}
        sx={buttonSx}
        component="a"
      >
        Create account
      </Button>
    </Link>
  )
}

export default CreateButton
</file>

<file path="src/features/myAccounts/components/CurrentSafe/index.tsx">
import { Box, Typography } from '@mui/material'
import useSafeInfo from '@/hooks/useSafeInfo'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { AllSafeItems } from '../../hooks/useAllSafesGrouped'
import { useMemo } from 'react'
import useAddressBook from '@/hooks/useAddressBook'
import SingleAccountItem from '../AccountItems/SingleAccountItem'

function CurrentSafeList({
  safeAddress,
  chainId,
  isReadOnly,
  onLinkClick,
}: {
  safeAddress: string
  chainId: string
  isReadOnly: boolean
  onLinkClick?: () => void
}) {
  const addressBook = useAddressBook()
  const safeName = addressBook[safeAddress]

  const safeItem = useMemo(
    () => ({
      chainId,
      address: safeAddress,
      isReadOnly,
      isPinned: false,
      lastVisited: -1,
      name: safeName,
    }),
    [chainId, safeAddress, isReadOnly, safeName],
  )

  return (
    <Box data-testid="current-safe-section" mb={3}>
      <Typography variant="h5" fontWeight={700} mb={2}>
        Current Safe Account
      </Typography>

      <SingleAccountItem onLinkClick={onLinkClick} safeItem={safeItem} />
    </Box>
  )
}

function CurrentSafe({ allSafes, onLinkClick }: { allSafes: AllSafeItems; onLinkClick?: () => void }) {
  const { safe, safeAddress } = useSafeInfo()

  const safeInList = useMemo(
    () => (safeAddress ? allSafes?.find((s) => sameAddress(s.address, safeAddress)) : undefined),
    [allSafes, safeAddress],
  )
  if (!safeAddress || safeInList?.isPinned) return null

  return (
    <CurrentSafeList
      onLinkClick={onLinkClick}
      safeAddress={safeAddress}
      chainId={safe.chainId}
      isReadOnly={!safeInList}
    />
  )
}

export default CurrentSafe
</file>

<file path="src/features/myAccounts/components/DataWidget/index.tsx">
import { Button, SvgIcon, Card, CardHeader, CardContent, Tooltip, Box } from '@mui/material'
import { useState } from 'react'
import type { ReactElement } from 'react'

import { useAppSelector } from '@/store'
import { selectAllAddedSafes } from '@/store/addedSafesSlice'
import { selectAllAddressBooks } from '@/store/addressBookSlice'
import ExportIcon from '@/public/images/common/export.svg'
import ImportIcon from '@/public/images/common/import.svg'
import { exportAppData } from '@/components/settings/DataManagement'
import { ImportDialog } from '@/components/settings/DataManagement/ImportDialog'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS } from '@/services/analytics'
import Track from '@/components/common/Track'
import InfoIcon from '@/public/images/notifications/info.svg'

import css from './styles.module.css'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'

export const DataWidget = (): ReactElement => {
  const [importModalOpen, setImportModalOpen] = useState(false)
  const [fileName, setFileName] = useState<string>()
  const [jsonData, setJsonData] = useState<string>()
  const addressBook = useAppSelector(selectAllAddressBooks)
  const addedSafes = useAppSelector(selectAllAddedSafes)
  const router = useRouter()
  const hasData = Object.keys(addressBook).length > 0 || Object.keys(addedSafes).length > 0
  const trackingLabel =
    router.pathname === AppRoutes.welcome.accounts ? OVERVIEW_LABELS.login_page : OVERVIEW_LABELS.sidebar

  const onImport = () => {
    setImportModalOpen(true)
  }

  const onClose = () => {
    setImportModalOpen(false)
  }

  return (
    <Card className={css.card}>
      <CardHeader
        className={css.cardHeader}
        title={
          <>
            <b>{hasData ? 'Export or import your Safe data' : 'Import your Safe data'}</b>
            <Tooltip
              title="Download or upload your local data with your added Safe Accounts, address book and settings."
              placement="top"
              arrow
            >
              <span>
                <InfoIcon className={css.infoIcon} />
              </span>
            </Tooltip>
          </>
        }
      />
      <CardContent>
        <Box display="flex" gap={2} justifyContent="center" sx={{ maxWidth: 240, margin: 'auto' }}>
          {hasData && (
            <Track {...OVERVIEW_EVENTS.EXPORT_DATA} label={trackingLabel}>
              <Button
                variant="outlined"
                size="small"
                onClick={exportAppData}
                startIcon={<SvgIcon component={ExportIcon} inheritViewBox fontSize="small" />}
                sx={{ width: '100%', py: 0.5, px: 2, mt: 2 }}
              >
                Export
              </Button>
            </Track>
          )}
          <Track {...OVERVIEW_EVENTS.IMPORT_DATA} label={trackingLabel}>
            <Button
              data-testid="import-btn"
              variant="outlined"
              size="small"
              onClick={onImport}
              startIcon={<SvgIcon component={ImportIcon} inheritViewBox fontSize="small" />}
              sx={{ width: '100%', py: 0.5, px: 2, mt: 2 }}
            >
              Import
            </Button>
          </Track>
        </Box>
      </CardContent>
      {importModalOpen && (
        <ImportDialog
          fileName={fileName}
          setFileName={setFileName}
          jsonData={jsonData}
          setJsonData={setJsonData}
          onClose={onClose}
        />
      )}
    </Card>
  )
}
</file>

<file path="src/features/myAccounts/components/DataWidget/styles.module.css">
.cardHeader {
  text-align: center;
}

.card {
  margin: auto;
  padding: var(--space-3);
  display: flex;
  flex-direction: column;
  background-color: transparent;
}

.card :global .MuiCardHeader-root,
.card :global .MuiCardContent-root {
  padding: 0;
}

.infoIcon {
  vertical-align: middle;
  width: 1rem;
  height: 1rem;
  margin: 4px;
  color: var(--color-text-secondary);
}
</file>

<file path="src/features/myAccounts/components/FilteredSafes/index.tsx">
import SafesList from '@/features/myAccounts/components/SafesList'
import type { AllSafeItems } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { useSafesSearch } from '@/features/myAccounts/hooks/useSafesSearch'
import { maybePlural } from '@safe-global/utils/utils/formatters'
import { OVERVIEW_EVENTS } from '@/services/analytics'
import { trackEvent } from '@/services/analytics'
import { Box, Typography } from '@mui/material'
import { useEffect } from 'react'

const FilteredSafes = ({
  searchQuery,
  allSafes,
  onLinkClick,
}: {
  searchQuery: string
  allSafes: AllSafeItems
  onLinkClick?: () => void
}) => {
  const filteredSafes = useSafesSearch(allSafes ?? [], searchQuery)

  useEffect(() => {
    if (searchQuery) {
      trackEvent({ category: OVERVIEW_EVENTS.SEARCH.category, action: OVERVIEW_EVENTS.SEARCH.action })
    }
  }, [searchQuery])

  return (
    <>
      <Typography variant="h5" fontWeight="normal" mb={2} color="primary.light">
        Found {filteredSafes.length} result{maybePlural(filteredSafes)}
      </Typography>
      <Box mt={1}>
        <SafesList safes={filteredSafes} onLinkClick={onLinkClick} />
      </Box>
    </>
  )
}

export default FilteredSafes
</file>

<file path="src/features/myAccounts/components/OrderByButton/index.tsx">
import { useState } from 'react'
import { Box, Button, ListItemText, MenuItem, SvgIcon, Typography } from '@mui/material'
import ContextMenu from '@/components/common/ContextMenu'
import TransactionsIcon from '@/public/images/transactions/transactions.svg'
import CheckIcon from '@/public/images/common/check.svg'
import { OrderByOption } from '@/store/orderByPreferenceSlice'
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'

type OrderByButtonProps = {
  orderBy: OrderByOption
  onOrderByChange: (orderBy: OrderByOption) => void
}

const orderByLabels = {
  [OrderByOption.LAST_VISITED]: 'Most recent',
  [OrderByOption.NAME]: 'Name',
}

const OrderByButton = ({ orderBy: orderBy, onOrderByChange: onOrderByChange }: OrderByButtonProps) => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | undefined>()

  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget)
  }

  const handleClose = () => {
    setAnchorEl(undefined)
  }

  const handleOrderByChange = (newOrderBy: OrderByOption) => {
    trackEvent({ ...OVERVIEW_EVENTS.SORT_SAFES, label: orderByLabels[newOrderBy] })
    onOrderByChange(newOrderBy)
    handleClose()
  }

  return (
    <Box display="flex">
      <Button
        data-testid="sortby-button"
        onClick={handleClick}
        startIcon={<SvgIcon component={TransactionsIcon} inheritViewBox />}
        sx={{ color: 'primary.light', fontWeight: 'normal' }}
        size="small"
      >
        <Typography variant="body2" noWrap>
          Sort by: {orderByLabels[orderBy]}
        </Typography>
      </Button>

      <ContextMenu
        anchorEl={anchorEl}
        open={!!anchorEl}
        onClose={handleClose}
        sx={{
          '& .MuiPaper-root': { minWidth: '250px' },
          '& .Mui-selected, & .Mui-selected:hover': {
            backgroundColor: `background.paper`,
          },
        }}
      >
        <MenuItem disabled>
          <ListItemText>Sort by</ListItemText>
        </MenuItem>
        <MenuItem
          data-testid="last-visited-option"
          sx={{ borderRadius: 0 }}
          onClick={() => handleOrderByChange(OrderByOption.LAST_VISITED)}
          selected={orderBy === OrderByOption.LAST_VISITED}
        >
          <ListItemText sx={{ mr: 2 }}>{orderByLabels[OrderByOption.LAST_VISITED]}</ListItemText>
          {orderBy === OrderByOption.LAST_VISITED && <CheckIcon sx={{ ml: 1 }} />}
        </MenuItem>
        <MenuItem
          data-testid="name-option"
          onClick={() => handleOrderByChange(OrderByOption.NAME)}
          selected={orderBy === OrderByOption.NAME}
        >
          <ListItemText>{orderByLabels[OrderByOption.NAME]}</ListItemText>
          {orderBy === OrderByOption.NAME && <CheckIcon sx={{ ml: 1 }} />}
        </MenuItem>
      </ContextMenu>
    </Box>
  )
}

export default OrderByButton
</file>

<file path="src/features/myAccounts/components/PinnedSafes/index.tsx">
import SafesList from '@/features/myAccounts/components/SafesList'
import type { AllSafeItems } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import css from '@/features/myAccounts/styles.module.css'
import BookmarkIcon from '@/public/images/apps/bookmark.svg'
import { Box, SvgIcon, Typography } from '@mui/material'
import { useMemo } from 'react'

const PinnedSafes = ({ allSafes, onLinkClick }: { allSafes: AllSafeItems; onLinkClick?: () => void }) => {
  const pinnedSafes = useMemo<AllSafeItems>(() => [...(allSafes?.filter(({ isPinned }) => isPinned) ?? [])], [allSafes])

  return (
    <Box data-testid="pinned-accounts" mb={2} minHeight="170px">
      <div className={css.listHeader}>
        <SvgIcon component={BookmarkIcon} inheritViewBox fontSize="small" sx={{ mt: '2px', mr: 1, strokeWidth: 2 }} />
        <Typography variant="h5" fontWeight={700} mb={2}>
          Pinned
        </Typography>
      </div>
      {pinnedSafes.length > 0 ? (
        <SafesList safes={pinnedSafes} onLinkClick={onLinkClick} />
      ) : (
        <Box data-testid="empty-pinned-list" className={css.noPinnedSafesMessage}>
          <Typography color="text.secondary" variant="body2" maxWidth="350px" textAlign="center">
            Personalize your account list by clicking the
            <SvgIcon
              component={BookmarkIcon}
              inheritViewBox
              fontSize="small"
              sx={{ mx: '4px', color: 'text.secondary', position: 'relative', top: '2px' }}
            />
            icon on the accounts most important to you.
          </Typography>
        </Box>
      )}
    </Box>
  )
}

export default PinnedSafes
</file>

<file path="src/features/myAccounts/components/QueueActions/index.tsx">
import classnames from 'classnames'
import { useRouter } from 'next/router'
import { type ReactNode, useCallback, type MouseEvent } from 'react'
import { Chip, Typography, SvgIcon } from '@mui/material'
import CheckIcon from '@mui/icons-material/Check'
import TransactionsIcon from '@/public/images/transactions/transactions.svg'
import Track from '@/components/common/Track'
import { OVERVIEW_EVENTS } from '@/services/analytics/events/overview'
import { AppRoutes } from '@/config/routes'
import css from './styles.module.css'

const ChipLink = ({ children, color }: { children: ReactNode; color?: string }) => (
  <Chip
    size="small"
    sx={{ backgroundColor: `${color}.background` }}
    label={
      <Typography
        variant="caption"
        sx={{
          display: 'flex',
          alignItems: 'center',
          gap: 0.5,
        }}
      >
        {children}
      </Typography>
    }
  />
)

const QueueActions = ({
  safeAddress,
  chainShortName,
  queued,
  awaitingConfirmation,
  isMobile = false,
}: {
  safeAddress: string
  chainShortName: string
  queued: number
  awaitingConfirmation: number
  isMobile?: boolean
}) => {
  const router = useRouter()

  const onQueueClick = useCallback(
    (e: MouseEvent<HTMLButtonElement>) => {
      e.preventDefault()
      router.push({
        pathname: AppRoutes.transactions.queue,
        query: { ...router.query, safe: `${chainShortName}:${safeAddress}` },
      })
    },
    [chainShortName, router, safeAddress],
  )

  if (!queued && !awaitingConfirmation) {
    return null
  }

  return (
    <Track {...OVERVIEW_EVENTS.OPEN_MISSING_SIGNATURES}>
      <button onClick={onQueueClick} className={classnames(css.queueButton, { [css.isMobile]: isMobile })}>
        {queued > 0 && (
          <ChipLink>
            <SvgIcon component={TransactionsIcon} inheritViewBox sx={{ fontSize: 'small' }} />
            {queued} pending
          </ChipLink>
        )}

        {awaitingConfirmation > 0 && (
          <ChipLink color="warning">
            <SvgIcon component={CheckIcon} inheritViewBox sx={{ fontSize: 'small', color: 'warning' }} />
            {awaitingConfirmation} to confirm
          </ChipLink>
        )}
      </button>
    </Track>
  )
}

export default QueueActions
</file>

<file path="src/features/myAccounts/components/QueueActions/styles.module.css">
.queueButton {
  display: flex;
  gap: var(--space-1);
  align-items: center;
  padding: 0;
  border: 0;
  cursor: pointer;
  position: relative;
  z-index: 1;
  background: transparent;
}

.isMobile {
  padding: 0 var(--space-2) var(--space-2);
}
</file>

<file path="src/features/myAccounts/components/SafesList/index.tsx">
import SingleAccountItem from '@/features/myAccounts/components/AccountItems/SingleAccountItem'
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import type { AllSafeItems, MultiChainSafeItem } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import MultiAccountItem from '@/features/myAccounts/components/AccountItems/MultiAccountItem'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'

export type SafeListProps = {
  safes?: AllSafeItems
  onLinkClick?: () => void
  isSpaceSafe?: boolean
}

const renderSafeItem = (
  item: SafeItem | MultiChainSafeItem,
  onLinkClick?: SafeListProps['onLinkClick'],
  isSpaceSafe = false,
) => {
  return isMultiChainSafeItem(item) ? (
    <MultiAccountItem onLinkClick={onLinkClick} multiSafeAccountItem={item} isSpaceSafe={isSpaceSafe} />
  ) : (
    <SingleAccountItem onLinkClick={onLinkClick} safeItem={item} isSpaceSafe={isSpaceSafe} />
  )
}

const SafesList = ({ safes, onLinkClick, isSpaceSafe = false }: SafeListProps) => {
  if (!safes || safes.length === 0) {
    return null
  }

  return safes.map((item) => <div key={item.address}>{renderSafeItem(item, onLinkClick, isSpaceSafe)}</div>)
}

export default SafesList
</file>

<file path="src/features/myAccounts/hooks/__tests__/useAllSafesGrouped.ts">
import * as allSafes from '@/features/myAccounts/hooks/useAllSafes'
import { _getMultiChainAccounts, useAllSafesGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { safeItemBuilder } from '@/tests/builders/safeItem'
import { renderHook } from '@/tests/test-utils'
import { faker } from '@faker-js/faker'

describe('useAllSafesGrouped', () => {
  describe('hook', () => {
    beforeEach(() => {
      jest.clearAllMocks()
    })

    it('returns an object with empty arrays if there are no safes', () => {
      jest.spyOn(allSafes, 'default').mockReturnValue(undefined)

      const { result } = renderHook(() => useAllSafesGrouped())

      expect(result.current).toEqual({ allMultiChainSafes: undefined, allSingleSafes: undefined })
    })
  })

  describe('_getMultiChainAccounts', () => {
    it('returns an empty array if there are no multichain safes', () => {
      const safes = [safeItemBuilder().build(), safeItemBuilder().build()]
      const result = _getMultiChainAccounts(safes)

      expect(result).toEqual([])
    })

    it('returns an empty array if there is only one safe', () => {
      const safes = [safeItemBuilder().build()]
      const result = _getMultiChainAccounts(safes)

      expect(result).toEqual([])
    })

    it('returns a multichain safe item in case there are safes with the same address', () => {
      const mockSafeAddress = faker.finance.ethereumAddress()

      const mockFirstSafe = safeItemBuilder().with({ address: mockSafeAddress }).build()
      const mockSecondSafe = safeItemBuilder().with({ address: mockSafeAddress }).build()

      const safes = [mockFirstSafe, mockSecondSafe]
      const result = _getMultiChainAccounts(safes)

      expect(result.length).toEqual(1)
      expect(result[0].address).toEqual(mockSafeAddress)
      expect(result[0].safes.length).toEqual(2)
    })
  })
})
</file>

<file path="src/features/myAccounts/hooks/useAllOwnedSafes.ts">
import type { AllOwnedSafes } from '@safe-global/safe-gateway-typescript-sdk'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { useGetAllOwnedSafesQuery } from '@/store/api/gateway'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { skipToken } from '@reduxjs/toolkit/query'

const useAllOwnedSafes = (address: string): AsyncResult<AllOwnedSafes> => {
  const { data, error, isLoading } = useGetAllOwnedSafesQuery(address === '' ? skipToken : { walletAddress: address })

  return [address ? data : undefined, asError(error), isLoading]
}

export default useAllOwnedSafes
</file>

<file path="src/features/myAccounts/hooks/useAllSafes.ts">
import type { AllOwnedSafes } from '@safe-global/safe-gateway-typescript-sdk'
import { useMemo } from 'react'
import { useAppSelector } from '@/store'
import type { AddedSafesState } from '@/store/addedSafesSlice'
import { selectAllAddedSafes } from '@/store/addedSafesSlice'
import useChains from '@/hooks/useChains'
import useWallet from '@/hooks/wallets/useWallet'
import type { AddressBookState, VisitedSafesState } from '@/store/slices'
import type { UndeployedSafesState } from '@safe-global/utils/features/counterfactual/store/types'
import { selectAllAddressBooks, selectAllVisitedSafes, selectUndeployedSafes } from '@/store/slices'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import useAllOwnedSafes from './useAllOwnedSafes'

export type SafeItem = {
  chainId: string
  address: string
  isReadOnly: boolean
  isPinned: boolean
  lastVisited: number
  name: string | undefined
}

export type SafeItems = SafeItem[]

export const _prepareAddresses = (
  chainId: string,
  allAdded: AddedSafesState,
  allOwned: AllOwnedSafes,
  allUndeployed: UndeployedSafesState,
): string[] => {
  const addedOnChain = Object.keys(allAdded[chainId] || {})
  const ownedOnChain = allOwned[chainId] || []
  const undeployedOnChain = Object.keys(allUndeployed[chainId] || {})

  const combined = [...addedOnChain, ...ownedOnChain, ...undeployedOnChain]

  // We need to sort to prevent potential jumps when pinning safes
  return [...new Set(combined)].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
}

export const _buildSafeItem = (
  chainId: string,
  address: string,
  walletAddress: string,
  allAdded: AddedSafesState,
  allOwned: AllOwnedSafes,
  allUndeployed: UndeployedSafesState,
  allVisitedSafes: VisitedSafesState,
  allSafeNames: AddressBookState,
): SafeItem => {
  const addedSafe = allAdded[chainId]?.[address]
  const isPinned = Boolean(addedSafe) // Pinning a safe means adding it to the added safes storage
  const undeployedSafeOwners = allUndeployed[chainId]?.[address]?.props.safeAccountConfig.owners || []

  // Determine if the user is an owner
  const isOwnerFromCF = undeployedSafeOwners.some((ownedAddress) => sameAddress(walletAddress, ownedAddress))
  const isOwnedSafe = (allOwned[chainId] || []).includes(address)
  const isOwned = isOwnedSafe || isOwnerFromCF

  const lastVisited = allVisitedSafes[chainId]?.[address]?.lastVisited || 0
  const name = allSafeNames[chainId]?.[address]

  return {
    chainId,
    address,
    isReadOnly: !isOwned,
    isPinned,
    lastVisited,
    name,
  }
}

const useAllSafes = (): SafeItems | undefined => {
  const { address: walletAddress = '' } = useWallet() || {}
  const [allOwned = {}] = useAllOwnedSafes(walletAddress)
  const { configs } = useChains()
  const allAdded = useAppSelector(selectAllAddedSafes)
  const allUndeployed = useAppSelector(selectUndeployedSafes)
  const allVisitedSafes = useAppSelector(selectAllVisitedSafes)
  const allSafeNames = useAppSelector(selectAllAddressBooks)

  return useMemo<SafeItems>(() => {
    const allChainIds = configs.map((config) => config.chainId)

    return allChainIds.flatMap((chainId) => {
      const uniqueAddresses = _prepareAddresses(chainId, allAdded, allOwned, allUndeployed)

      return uniqueAddresses.map((address) => {
        return _buildSafeItem(
          chainId,
          address,
          walletAddress,
          allAdded,
          allOwned,
          allUndeployed,
          allVisitedSafes,
          allSafeNames,
        )
      })
    })
  }, [allAdded, allOwned, allUndeployed, configs, walletAddress, allVisitedSafes, allSafeNames])
}

export default useAllSafes
</file>

<file path="src/features/myAccounts/hooks/useAllSafesGrouped.ts">
import groupBy from 'lodash/groupBy'
import useAllSafes, { type SafeItem, type SafeItems } from './useAllSafes'
import { useMemo } from 'react'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { type AddressBookState, selectAllAddressBooks } from '@/store/addressBookSlice'
import useWallet from '@/hooks/wallets/useWallet'
import useAllOwnedSafes from '@/features/myAccounts/hooks/useAllOwnedSafes'
import { useAppSelector } from '@/store'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'
import type { AllOwnedSafes } from '@safe-global/safe-gateway-typescript-sdk'

export type MultiChainSafeItem = {
  address: string
  safes: SafeItem[]
  isPinned: boolean
  lastVisited: number
  name: string | undefined
}

export type AllSafeItemsGrouped = {
  allSingleSafes: SafeItems | undefined
  allMultiChainSafes: MultiChainSafeItem[] | undefined
}

export type AllSafeItems = Array<SafeItem | MultiChainSafeItem>

export const _buildMultiChainSafeItem = (address: string, safes: SafeItems): MultiChainSafeItem => {
  const isPinned = safes.some((safe) => safe.isPinned)
  const lastVisited = safes.reduce((acc, safe) => Math.max(acc, safe.lastVisited || 0), 0)
  const name = safes.find((safe) => safe.name !== undefined)?.name

  return { address, safes, isPinned, lastVisited, name }
}

export function _buildSafeItems(
  safes: Record<string, string[]>,
  allSafeNames: AddressBookState,
  allOwned?: AllOwnedSafes,
): SafeItem[] {
  const result: SafeItem[] = []

  for (const chainId in safes) {
    const addresses = safes[chainId]

    addresses.forEach((address) => {
      const isReadOnly = !!allOwned && !(allOwned[chainId] || []).includes(address)
      const name = allSafeNames[chainId]?.[address]

      result.push({
        chainId,
        address,
        isReadOnly,
        isPinned: false,
        lastVisited: 0,
        name,
      })
    })
  }

  return result
}

export function flattenSafeItems(items: Array<SafeItem | MultiChainSafeItem>): SafeItem[] {
  return items.flatMap((item) => (isMultiChainSafeItem(item) ? item.safes : [item]))
}

export const _getMultiChainAccounts = (safes: SafeItems): MultiChainSafeItem[] => {
  const groupedByAddress = groupBy(safes, (safe) => safe.address)

  return Object.entries(groupedByAddress)
    .filter((entry) => entry[1].length > 1)
    .map((entry) => {
      const [address, safes] = entry

      return _buildMultiChainSafeItem(address, safes)
    })
}

export const _getSingleChainAccounts = (safes: SafeItems, allMultiChainSafes: MultiChainSafeItem[]) => {
  return safes.filter((safe) => !allMultiChainSafes.some((multiSafe) => sameAddress(multiSafe.address, safe.address)))
}

export const useAllSafesGrouped = (customSafes?: SafeItems) => {
  const safes = useAllSafes()
  const allSafes = customSafes ?? safes

  return useMemo<AllSafeItemsGrouped>(() => {
    if (!allSafes) {
      return { allMultiChainSafes: undefined, allSingleSafes: undefined }
    }

    const allMultiChainSafes = _getMultiChainAccounts(allSafes)
    const allSingleSafes = _getSingleChainAccounts(allSafes, allMultiChainSafes)

    return {
      allMultiChainSafes,
      allSingleSafes,
    }
  }, [allSafes])
}

export const useOwnedSafesGrouped = () => {
  const { address: walletAddress = '' } = useWallet() || {}
  const [allOwned = {}] = useAllOwnedSafes(walletAddress)
  const allSafeNames = useAppSelector(selectAllAddressBooks)
  const safeItems = _buildSafeItems(allOwned, allSafeNames)

  return useAllSafesGrouped(safeItems)
}
</file>

<file path="src/features/myAccounts/hooks/useGetHref.ts">
import { AppRoutes } from '@/config/routes'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type NextRouter } from 'next/router'
import { useCallback } from 'react'
import { useIsSpaceRoute } from '@/hooks/useIsSpaceRoute'

/**
 * Navigate to the dashboard when selecting a safe on the welcome page,
 * navigate to the history when selecting a safe on a single tx page,
 * otherwise keep the current route
 */
export const useGetHref = (router: NextRouter) => {
  const isSpacePage = useIsSpaceRoute()
  const isWelcomePage = router.pathname === AppRoutes.welcome.accounts
  const isSingleTxPage = router.pathname === AppRoutes.transactions.tx

  return useCallback(
    (chain: ChainInfo, address: string) => {
      return {
        pathname:
          isWelcomePage || isSpacePage
            ? AppRoutes.home
            : isSingleTxPage
              ? AppRoutes.transactions.history
              : router.pathname,
        query: { ...(!isSpacePage && router.query), safe: `${chain.shortName}:${address}` },
      }
    },
    [isSingleTxPage, isWelcomePage, isSpacePage, router.pathname, router.query],
  )
}
</file>

<file path="src/features/myAccounts/hooks/useHasSafes.ts">
import useAllOwnedSafes from '@/features/myAccounts/hooks/useAllOwnedSafes'
import useWallet from '@/hooks/wallets/useWallet'
import { useAppSelector } from '@/store'
import { selectAllAddedSafes } from '@/store/addedSafesSlice'
import isEmpty from 'lodash/isEmpty'

const useHasSafes = () => {
  const { address = '' } = useWallet() || {}
  const allAdded = useAppSelector(selectAllAddedSafes)
  const hasAdded = !isEmpty(allAdded)
  const [allOwned] = useAllOwnedSafes(!hasAdded ? address : '') // pass an empty string to not fetch owned safes

  if (hasAdded) return { isLoaded: true, hasSafes: hasAdded }
  if (!allOwned) return { isLoaded: false }

  const hasOwned = !isEmpty(Object.values(allOwned).flat())
  return { isLoaded: true, hasSafes: hasOwned }
}

export default useHasSafes
</file>

<file path="src/features/myAccounts/hooks/useSafesSearch.ts">
import { useMemo } from 'react'
import Fuse from 'fuse.js'
import type { AllSafeItems } from './useAllSafesGrouped'
import { selectChains } from '@/store/chainsSlice'
import { useAppSelector } from '@/store'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'

const useSafesSearch = (safes: AllSafeItems, query: string): AllSafeItems => {
  const chains = useAppSelector(selectChains)

  // Include chain names in the search
  const safesWithChainNames = useMemo(
    () =>
      safes.map((safe) => {
        if (isMultiChainSafeItem(safe)) {
          const nestedSafeChains = safe.safes.map(
            (nestedSafe) => chains.data.find((chain) => chain.chainId === nestedSafe.chainId)?.chainName,
          )
          const nestedSafeNames = safe.safes.map((nestedSafe) => nestedSafe.name)
          return { ...safe, chainNames: nestedSafeChains, names: nestedSafeNames }
        }
        const chain = chains.data.find((chain) => chain.chainId === safe.chainId)
        return { ...safe, chainNames: [chain?.chainName], names: [safe.name] }
      }),
    [safes, chains.data],
  )

  const fuse = useMemo(
    () =>
      new Fuse(safesWithChainNames, {
        keys: [{ name: 'names' }, { name: 'address' }, { name: 'chainNames' }],
        threshold: 0.2,
        findAllMatches: true,
        ignoreLocation: true,
      }),
    [safesWithChainNames],
  )

  // Return results in the original format
  return useMemo(
    () =>
      query
        ? fuse.search(query).map((result) => {
            const { chainNames: _chainNames, names: _names, ...safe } = result.item
            return safe
          })
        : [],
    [fuse, query],
  )
}

export { useSafesSearch }
</file>

<file path="src/features/myAccounts/hooks/useTrackedSafesCount.ts">
import { AppRoutes } from '@/config/routes'
import { OVERVIEW_EVENTS, trackEvent } from '@/services/analytics'
import { useRouter } from 'next/router'
import { useEffect, useMemo } from 'react'
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { type SafeItem } from './useAllSafes'
import type { AllSafeItemsGrouped } from './useAllSafesGrouped'
import { type MultiChainSafeItem } from './useAllSafesGrouped'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'

let isOwnedSafesTracked = false
let isPinnedSafesTracked = false

const useTrackSafesCount = (safes: AllSafeItemsGrouped, wallet: ConnectedWallet | null) => {
  const router = useRouter()
  const isLoginPage = router.pathname === AppRoutes.welcome.accounts

  const ownedMultiChainSafes = useMemo(
    () => safes.allMultiChainSafes?.filter((account) => account.safes.some(({ isReadOnly }) => !isReadOnly)),
    [safes],
  )

  const ownedSafes = useMemo<(MultiChainSafeItem | SafeItem)[]>(
    () => [...(ownedMultiChainSafes ?? []), ...(safes.allSingleSafes?.filter(({ isReadOnly }) => !isReadOnly) ?? [])],
    [safes, ownedMultiChainSafes],
  )

  // TODO: This is computed here and inside PinnedSafes now. Find a way to optimize it
  const pinnedSafes = useMemo<(MultiChainSafeItem | SafeItem)[]>(
    () => [
      ...(safes.allSingleSafes?.filter(({ isPinned }) => isPinned) ?? []),
      ...(safes.allMultiChainSafes?.filter(({ isPinned }) => isPinned) ?? []),
    ],
    [safes],
  )

  // Reset tracking for new wallet
  useEffect(() => {
    isOwnedSafesTracked = false
  }, [wallet?.address])

  useEffect(() => {
    const totalSafesOwned = ownedSafes?.reduce(
      (prev, current) => prev + (isMultiChainSafeItem(current) ? current.safes.length : 1),
      0,
    )
    if (wallet && !isOwnedSafesTracked && ownedSafes && ownedSafes.length > 0 && isLoginPage) {
      trackEvent({ ...OVERVIEW_EVENTS.TOTAL_SAFES_OWNED, label: totalSafesOwned })
      isOwnedSafesTracked = true
    }
  }, [isLoginPage, ownedSafes, wallet])

  useEffect(() => {
    const totalSafesPinned = pinnedSafes?.reduce(
      (prev, current) => prev + (isMultiChainSafeItem(current) ? current.safes.length : 1),
      0,
    )
    if (!isPinnedSafesTracked && pinnedSafes && pinnedSafes.length > 0 && isLoginPage) {
      trackEvent({ ...OVERVIEW_EVENTS.TOTAL_SAFES_PINNED, label: totalSafesPinned })
      isPinnedSafesTracked = true
    }
  }, [isLoginPage, pinnedSafes])
}

export default useTrackSafesCount
</file>

<file path="src/features/myAccounts/hooks/useVisitedSafes.ts">
import { useRouter } from 'next/router'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useAppDispatch } from '@/store'
import { useCallback, useEffect } from 'react'
import { upsertVisitedSafe } from '@/store/visitedSafesSlice'

export const useVisitedSafes = () => {
  const router = useRouter()
  const { safe } = useSafeInfo()
  const dispatch = useAppDispatch()

  const handleRouteChange = useCallback(() => {
    const { query } = router
    if (query.safe && safe.address.value) {
      const visitedSafe = {
        chainId: safe.chainId,
        address: safe.address.value,
        lastVisited: Date.now(),
      }
      dispatch(upsertVisitedSafe(visitedSafe))
    }
  }, [router, safe.address.value, safe.chainId, dispatch])

  useEffect(() => {
    if (router.query.safe) {
      handleRouteChange()
    }
  }, [handleRouteChange, router.query.safe])
}
</file>

<file path="src/features/myAccounts/utils/utils.ts">
import { OrderByOption } from '@/store/orderByPreferenceSlice'
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import type { MultiChainSafeItem } from '@/features/myAccounts/hooks/useAllSafesGrouped'

export const nameComparator = (a: SafeItem | MultiChainSafeItem, b: SafeItem | MultiChainSafeItem) => {
  // Put undefined names last
  if (!a.name && !b.name) return 0
  if (!a.name) return 1
  if (!b.name) return -1
  return a.name.localeCompare(b.name)
}

export const lastVisitedComparator = (a: SafeItem | MultiChainSafeItem, b: SafeItem | MultiChainSafeItem) => {
  return b.lastVisited - a.lastVisited
}

export const getComparator = (orderBy: OrderByOption) => {
  return orderBy === OrderByOption.NAME ? nameComparator : lastVisitedComparator
}
</file>

<file path="src/features/myAccounts/index.tsx">
import AccountListFilters from 'src/features/myAccounts/components/AccountListFilters'
import AccountsHeader from '@/features/myAccounts/components/AccountsHeader'
import AccountsList from '@/features/myAccounts/components/AccountsList'
import { useState } from 'react'
import { Box, Divider, Paper } from '@mui/material'
import madProps from '@/utils/mad-props'
import css from '@/features/myAccounts/styles.module.css'
import useWallet from '@/hooks/wallets/useWallet'
import { type AllSafeItemsGrouped, useAllSafesGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import classNames from 'classnames'
import useTrackSafesCount from '@/features/myAccounts/hooks/useTrackedSafesCount'
import { DataWidget } from '@/features/myAccounts/components/DataWidget'

type MyAccountsProps = {
  safes: AllSafeItemsGrouped
  isSidebar?: boolean
  onLinkClick?: () => void
}

const MyAccounts = ({ safes, onLinkClick, isSidebar = false }: MyAccountsProps) => {
  const wallet = useWallet()
  const [searchQuery, setSearchQuery] = useState('')
  useTrackSafesCount(safes, wallet)

  return (
    <Box data-testid="sidebar-safe-container" className={css.container}>
      <Box className={classNames(css.myAccounts, { [css.sidebarAccounts]: isSidebar })}>
        <AccountsHeader isSidebar={isSidebar} onLinkClick={onLinkClick} />

        <Paper sx={{ padding: 0 }}>
          <AccountListFilters setSearchQuery={setSearchQuery} />

          {isSidebar && <Divider />}

          <Paper className={css.safeList}>
            <AccountsList searchQuery={searchQuery} safes={safes} isSidebar={isSidebar} onLinkClick={onLinkClick} />
          </Paper>
        </Paper>

        {isSidebar && <Divider />}
        <DataWidget />
      </Box>
    </Box>
  )
}

export default madProps(MyAccounts, {
  safes: useAllSafesGrouped,
})
</file>

<file path="src/features/myAccounts/styles.module.css">
.container {
  container-type: inline-size;
  container-name: my-accounts-container;
  display: flex;
  justify-content: center;
}

.myAccounts {
  width: 100vw;
  max-width: 750px;
  margin: var(--space-2);
}

.sidebarAccounts {
  margin: 0 !important;
}

.safeList {
  padding: var(--space-2) var(--space-2) var(--space-3);
  margin-bottom: var(--space-1);
}

.header {
  display: flex;
  justify-content: space-between;
  padding: var(--space-3) 0;
  gap: var(--space-2);
}

.sidebarHeader {
  padding: var(--space-3) var(--space-2);
  border-bottom: 1px solid var(--color-border-light);
}

.sidebarHeader > h1 {
  font-size: 24px;
}

.headerButtons {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
}

.noPinnedSafesMessage {
  display: flex;
  justify-content: center;
  border: 1px solid var(--color-border-light);
  padding: var(--space-3);
  border-radius: var(--space-1);
  border-style: dashed;
}

.listHeader {
  display: flex;
}

.listHeader svg path {
  stroke: var(--color-text-primary);
}

.link {
  text-decoration: none;
  color: var(--color-text-secondary);
}

.link:hover {
  color: var(--color-text-primary);
}

.active {
  pointer-events: none;
  color: var(--color-text-primary);
}

@media (max-width: 899.95px) {
  .container {
    width: auto;
  }
}

.safeList :global .MuiAccordionSummary-root {
  background: var(--color-background-paper) !important;
  padding-left: 0;
  min-height: 0;
  justify-content: left;
  vertical-align: middle;
}

.search :global .MuiInputBase-root {
  border: 1px solid transparent !important;
}

@media (max-width: 599.95px) {
  .header {
    flex-direction: column;
  }

  .headerButtons > span {
    flex: 1;
  }

  .headerButtons > span > a {
    width: 100%;
  }
}
</file>

<file path="src/features/proposers/components/DeleteProposerDialog.tsx">
import CheckWallet from '@/components/common/CheckWallet'
import Track from '@/components/common/Track'
import { signProposerData, signProposerTypedData } from '@/features/proposers/utils/utils'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import useWallet from '@/hooks/wallets/useWallet'
import DeleteIcon from '@/public/images/common/delete.svg'
import { SETTINGS_EVENTS, trackEvent } from '@/services/analytics'
import { useAppDispatch } from '@/store'
import { useDeleteProposerMutation } from '@/store/api/gateway'
import { showNotification } from '@/store/notificationsSlice'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import { isEthSignWallet } from '@/utils/wallets'
import type { Delegate } from '@safe-global/safe-gateway-typescript-sdk/dist/types/delegates'
import React, { useState } from 'react'
import {
  Dialog,
  DialogTitle,
  Typography,
  IconButton,
  Divider,
  DialogContent,
  DialogActions,
  Button,
  Box,
  CircularProgress,
  SvgIcon,
  Tooltip,
} from '@mui/material'
import { Close } from '@mui/icons-material'
import madProps from '@/utils/mad-props'
import useChainId from '@/hooks/useChainId'
import useSafeAddress from '@/hooks/useSafeAddress'
import { getAssertedChainSigner } from '@/services/tx/tx-sender/sdk'
import ErrorMessage from '@/components/tx/ErrorMessage'

type DeleteProposerProps = {
  wallet: ReturnType<typeof useWallet>
  safeAddress: ReturnType<typeof useSafeAddress>
  chainId: ReturnType<typeof useChainId>
  proposer: Delegate
}

const InternalDeleteProposer = ({ wallet, safeAddress, chainId, proposer }: DeleteProposerProps) => {
  const [open, setOpen] = useState<boolean>(false)
  const [error, setError] = useState<Error>()
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [deleteProposer] = useDeleteProposerMutation()
  const dispatch = useAppDispatch()

  const onConfirm = async () => {
    setError(undefined)
    setIsLoading(true)

    if (!wallet?.provider || !safeAddress || !chainId) {
      setIsLoading(false)
      setError(new Error('Please connect your wallet first'))
      return
    }

    try {
      const shouldEthSign = isEthSignWallet(wallet)
      const signer = await getAssertedChainSigner(wallet.provider)
      const signature = shouldEthSign
        ? await signProposerData(proposer.delegate, signer)
        : await signProposerTypedData(chainId, proposer.delegate, signer)

      await deleteProposer({
        chainId,
        delegateAddress: proposer.delegate,
        delegator: proposer.delegator,
        safeAddress,
        signature,
        shouldEthSign,
      })

      trackEvent(SETTINGS_EVENTS.PROPOSERS.SUBMIT_REMOVE_PROPOSER)

      dispatch(
        showNotification({
          variant: 'success',
          groupKey: 'delete-proposer-success',
          title: 'Proposer deleted successfully!',
          message: `${shortenAddress(proposer.delegate)} can not suggest transactions anymore.`,
        }),
      )
    } catch (error) {
      setIsLoading(false)
      setError(error as Error)
      return
    }

    setIsLoading(false)
    setOpen(false)
  }

  const onCancel = () => {
    trackEvent(SETTINGS_EVENTS.PROPOSERS.CANCEL_REMOVE_PROPOSER)
    setOpen(false)
    setIsLoading(false)
    setError(undefined)
  }

  const canDelete = wallet?.address === proposer.delegate || wallet?.address === proposer.delegator

  return (
    <>
      <CheckWallet>
        {(isOk) => (
          <Track {...SETTINGS_EVENTS.PROPOSERS.REMOVE_PROPOSER}>
            <Tooltip
              title={
                isOk && canDelete
                  ? 'Delete proposer'
                  : isOk && !canDelete
                    ? 'Only the owner of this proposer or the proposer itself can delete them'
                    : undefined
              }
            >
              <span>
                <IconButton
                  data-testid="delete-proposer-btn"
                  onClick={() => setOpen(true)}
                  color="error"
                  size="small"
                  disabled={!isOk || !canDelete}
                >
                  <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
                </IconButton>
              </span>
            </Tooltip>
          </Track>
        )}
      </CheckWallet>

      <Dialog open={open} onClose={onCancel}>
        <DialogTitle>
          <Box display="flex" alignItems="center">
            <Typography variant="h6" fontWeight={700} sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              Delete this proposer?
            </Typography>

            <Box flexGrow={1} />

            <IconButton aria-label="close" onClick={onCancel} sx={{ marginLeft: 'auto' }}>
              <Close />
            </IconButton>
          </Box>
        </DialogTitle>

        <Divider />

        <DialogContent>
          <Box mb={2}>
            <Typography>
              Deleting this proposer will permanently remove the address, and it won&apos;t be able to suggest
              transactions anymore.
              <br />
              <br />
              To complete this action, confirm it with your connected wallet signature.
            </Typography>
          </Box>

          {error && (
            <Box mt={2}>
              <ErrorMessage error={error}>Error deleting proposer</ErrorMessage>
            </Box>
          )}

          <NetworkWarning action="sign" />
        </DialogContent>

        <Divider />

        <DialogActions sx={{ padding: 3, justifyContent: 'space-between' }}>
          <Button data-testid="reject-delete-proposer-btn" size="small" variant="text" onClick={onCancel}>
            No, keep it
          </Button>

          <CheckWallet checkNetwork={!isLoading}>
            {(isOk) => (
              <Button
                data-testid="confirm-delete-proposer-btn"
                size="small"
                variant="danger"
                onClick={onConfirm}
                disabled={!isOk || isLoading || !canDelete}
                sx={{
                  minWidth: '122px',
                  minHeight: '36px',
                }}
              >
                {isLoading ? <CircularProgress size={20} /> : 'Yes, delete'}
              </Button>
            )}
          </CheckWallet>
        </DialogActions>
      </Dialog>
    </>
  )
}

const DeleteProposerDialog = madProps(InternalDeleteProposer, {
  wallet: useWallet,
  chainId: useChainId,
  safeAddress: useSafeAddress,
})

export default DeleteProposerDialog
</file>

<file path="src/features/proposers/components/EditProposerDialog.tsx">
import CheckWallet from '@/components/common/CheckWallet'
import Track from '@/components/common/Track'
import UpsertProposer from '@/features/proposers/components/UpsertProposer'
import useWallet from '@/hooks/wallets/useWallet'
import EditIcon from '@/public/images/common/edit.svg'
import { SETTINGS_EVENTS } from '@/services/analytics'
import { IconButton, SvgIcon, Tooltip } from '@mui/material'
import type { Delegate } from '@safe-global/safe-gateway-typescript-sdk/dist/types/delegates'
import React, { useState } from 'react'

const EditProposerDialog = ({ proposer }: { proposer: Delegate }) => {
  const [open, setOpen] = useState<boolean>(false)
  const wallet = useWallet()

  const canEdit = wallet?.address === proposer.delegator

  return (
    <>
      <CheckWallet allowProposer={false}>
        {(isOk) => (
          <Track {...SETTINGS_EVENTS.PROPOSERS.EDIT_PROPOSER}>
            <Tooltip
              title={
                isOk && canEdit
                  ? 'Edit proposer'
                  : isOk && !canEdit
                    ? 'Only the owner of this proposer can edit them'
                    : undefined
              }
            >
              <span>
                <IconButton
                  data-testid="edit-proposer-btn"
                  onClick={() => setOpen(true)}
                  size="small"
                  disabled={!isOk || !canEdit}
                >
                  <SvgIcon component={EditIcon} inheritViewBox color="border" fontSize="small" />
                </IconButton>
              </span>
            </Tooltip>
          </Track>
        )}
      </CheckWallet>

      {open && <UpsertProposer onClose={() => setOpen(false)} onSuccess={() => setOpen(false)} proposer={proposer} />}
    </>
  )
}

export default EditProposerDialog
</file>

<file path="src/features/proposers/components/TxProposalChip.tsx">
import { Chip, SvgIcon, Tooltip, Typography } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'

const TxProposalChip = () => {
  return (
    <Tooltip title="This transaction was created by a Proposer. Reject or confirm it to proceed.">
      <span>
        <Chip
          sx={{ backgroundColor: 'background.main', color: 'primary.light' }}
          size="small"
          label={
            <Typography
              variant="caption"
              fontWeight="bold"
              display="flex"
              alignItems="center"
              justifyContent="center"
              gap={0.7}
            >
              <SvgIcon component={InfoIcon} inheritViewBox fontSize="small" />
              <Typography data-testid="proposal-status" variant="caption" fontWeight="bold">
                Proposal
              </Typography>
            </Typography>
          }
        />
      </span>
    </Tooltip>
  )
}

export default TxProposalChip
</file>

<file path="src/features/proposers/components/UpsertProposer.tsx">
import AddressBookInput from '@/components/common/AddressBookInput'
import CheckWallet from '@/components/common/CheckWallet'
import EthHashInfo from '@/components/common/EthHashInfo'
import NameInput from '@/components/common/NameInput'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { signProposerData, signProposerTypedData } from '@/features/proposers/utils/utils'
import useChainId from '@/hooks/useChainId'
import useSafeAddress from '@/hooks/useSafeAddress'
import useWallet from '@/hooks/wallets/useWallet'
import { SETTINGS_EVENTS, trackEvent } from '@/services/analytics'
import { getAssertedChainSigner } from '@/services/tx/tx-sender/sdk'
import { useAppDispatch } from '@/store'
import { useAddProposerMutation } from '@/store/api/gateway'
import { showNotification } from '@/store/notificationsSlice'
import { shortenAddress } from '@safe-global/utils/utils/formatters'
import { addressIsNotCurrentSafe } from '@safe-global/utils/utils/validation'
import { isEthSignWallet } from '@/utils/wallets'
import { Close } from '@mui/icons-material'
import {
  Alert,
  Box,
  Button,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  IconButton,
  Typography,
} from '@mui/material'
import type { Delegate } from '@safe-global/safe-gateway-typescript-sdk/dist/types/delegates'
import { type BaseSyntheticEvent, useState } from 'react'
import { FormProvider, useForm } from 'react-hook-form'

type UpsertProposerProps = {
  onClose: () => void
  onSuccess: () => void
  proposer?: Delegate
}

enum ProposerEntryFields {
  address = 'address',
  name = 'name',
}

type ProposerEntry = {
  [ProposerEntryFields.name]: string
  [ProposerEntryFields.address]: string
}

const UpsertProposer = ({ onClose, onSuccess, proposer }: UpsertProposerProps) => {
  const [error, setError] = useState<Error>()
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [addProposer] = useAddProposerMutation()
  const dispatch = useAppDispatch()

  const chainId = useChainId()
  const wallet = useWallet()
  const safeAddress = useSafeAddress()

  const methods = useForm<ProposerEntry>({
    defaultValues: {
      [ProposerEntryFields.address]: proposer?.delegate,
      [ProposerEntryFields.name]: proposer?.label,
    },
    mode: 'onChange',
  })

  const notCurrentSafe = addressIsNotCurrentSafe(safeAddress, 'Cannot add Safe Account itself as proposer')

  const { handleSubmit, formState } = methods

  const onConfirm = handleSubmit(async (data: ProposerEntry) => {
    if (!wallet) return

    setError(undefined)
    setIsLoading(true)

    try {
      const shouldEthSign = isEthSignWallet(wallet)
      const signer = await getAssertedChainSigner(wallet.provider)
      const signature = shouldEthSign
        ? await signProposerData(data.address, signer)
        : await signProposerTypedData(chainId, data.address, signer)

      await addProposer({
        chainId,
        delegator: wallet.address,
        signature,
        label: data.name,
        delegate: data.address,
        safeAddress,
        shouldEthSign,
      })

      trackEvent(
        isEditing ? SETTINGS_EVENTS.PROPOSERS.SUBMIT_EDIT_PROPOSER : SETTINGS_EVENTS.PROPOSERS.SUBMIT_ADD_PROPOSER,
      )

      dispatch(
        showNotification({
          variant: 'success',
          groupKey: 'add-proposer-success',
          title: 'Proposer added successfully!',
          message: `${shortenAddress(data.address)} can now suggest transactions for this account.`,
        }),
      )
    } catch (error) {
      setIsLoading(false)
      setError(error as Error)
      return
    }

    setIsLoading(false)
    onSuccess()
  })

  const onSubmit = (e: BaseSyntheticEvent) => {
    e.stopPropagation()
    onConfirm(e)
  }

  const onCancel = () => {
    trackEvent(
      isEditing ? SETTINGS_EVENTS.PROPOSERS.CANCEL_EDIT_PROPOSER : SETTINGS_EVENTS.PROPOSERS.CANCEL_ADD_PROPOSER,
    )
    onClose()
  }

  const isEditing = !!proposer
  const canEdit = wallet?.address === proposer?.delegator

  return (
    <Dialog open onClose={onCancel}>
      <FormProvider {...methods}>
        <form onSubmit={onSubmit}>
          <DialogTitle>
            <Box data-testid="untrusted-token-warning" display="flex" alignItems="center">
              <Typography variant="h6" fontWeight={700} sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                {isEditing ? 'Edit' : 'Add'} proposer
              </Typography>

              <Box flexGrow={1} />

              <IconButton aria-label="close" onClick={onCancel} sx={{ marginLeft: 'auto' }}>
                <Close />
              </IconButton>
            </Box>
          </DialogTitle>

          <Divider />

          <DialogContent>
            <Box mb={2}>
              <Typography variant="body2">
                You&apos;re about to grant this address the ability to propose transactions. To complete the setup,
                confirm with a signature from your connected wallet.
              </Typography>
            </Box>

            <Alert severity="info">Proposer’s name and address are publicly visible.</Alert>

            <Box my={2}>
              {isEditing ? (
                <Box mb={3}>
                  <EthHashInfo address={proposer?.delegate} showCopyButton hasExplorer shortAddress={false} />
                </Box>
              ) : (
                <AddressBookInput
                  name="address"
                  label="Address"
                  validate={notCurrentSafe}
                  variant="outlined"
                  fullWidth
                  required
                />
              )}
            </Box>

            <Box mb={2}>
              <NameInput name="name" label="Name" required />
            </Box>

            {error && (
              <Box mt={2}>
                <ErrorMessage error={error}>Error adding proposer</ErrorMessage>
              </Box>
            )}

            <NetworkWarning action="sign" />
          </DialogContent>

          <Divider />

          <DialogActions sx={{ padding: 3, justifyContent: 'space-between' }}>
            <Button size="small" variant="text" onClick={onCancel}>
              Cancel
            </Button>

            <CheckWallet checkNetwork={!isLoading} allowProposer={false}>
              {(isOk) => (
                <Button
                  data-testid="submit-proposer-btn"
                  size="small"
                  variant="contained"
                  color="primary"
                  type="submit"
                  disabled={!isOk || isLoading || (isEditing && !canEdit) || !formState.isValid}
                  sx={{ minWidth: '122px', minHeight: '36px' }}
                >
                  {isLoading ? <CircularProgress size={20} /> : 'Continue'}
                </Button>
              )}
            </CheckWallet>
          </DialogActions>
        </form>
      </FormProvider>
    </Dialog>
  )
}

export default UpsertProposer
</file>

<file path="src/features/proposers/utils/utils.ts">
import { signTypedData } from '@safe-global/utils/utils/web3'
import { SigningMethod } from '@safe-global/protocol-kit'
import { adjustVInSignature } from '@safe-global/protocol-kit/dist/src/utils/signatures'
import type { JsonRpcSigner } from 'ethers'

const getProposerDataV2 = (chainId: string, proposerAddress: string) => {
  const totp = Math.floor(Date.now() / 1000 / 3600)

  const domain = {
    name: 'Safe Transaction Service',
    version: '1.0',
    chainId: Number(chainId),
  }

  const types = {
    Delegate: [
      { name: 'delegateAddress', type: 'address' },
      { name: 'totp', type: 'uint256' },
    ],
  }

  const message = {
    delegateAddress: proposerAddress,
    totp,
  }

  return {
    domain,
    types,
    message,
    primaryType: 'Delegate',
  }
}

export const signProposerTypedData = async (chainId: string, proposerAddress: string, signer: JsonRpcSigner) => {
  const typedData = getProposerDataV2(chainId, proposerAddress)
  return signTypedData(signer, typedData)
}

const getProposerDataV1 = (proposerAddress: string) => {
  const totp = Math.floor(Date.now() / 1000 / 3600)

  return `${proposerAddress}${totp}`
}

export const signProposerData = async (proposerAddress: string, signer: JsonRpcSigner) => {
  const data = getProposerDataV1(proposerAddress)

  const signature = await signer.signMessage(data)

  return adjustVInSignature(SigningMethod.ETH_SIGN_TYPED_DATA, signature)
}
</file>

<file path="src/features/recovery/components/CancelRecoveryButton/index.tsx">
import useWallet from '@/hooks/wallets/useWallet'
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Button } from '@mui/material'
import { useContext } from 'react'
import type { SyntheticEvent, ReactElement } from 'react'

import CheckWallet from '@/components/common/CheckWallet'
import { TxModalContext } from '@/components/tx-flow'
import { CancelRecoveryFlow } from '@/components/tx-flow/flows'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { dispatchRecoverySkipExpired } from '@/features/recovery/services/recovery-sender'
import useSafeInfo from '@/hooks/useSafeInfo'
import { trackError, Errors } from '@/services/exceptions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { useRecoveryTxState } from '@/features/recovery/hooks/useRecoveryTxState'
import { RecoveryListItemContext } from '../RecoveryListItem/RecoveryListItemContext'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function CancelRecoveryButton({
  recovery,
  compact = false,
}: {
  recovery: RecoveryQueueItem
  compact?: boolean
}): ReactElement {
  const { setSubmitError } = useContext(RecoveryListItemContext)
  const isOwner = useIsSafeOwner()
  const { isExpired, isPending } = useRecoveryTxState(recovery)
  const { setTxFlow } = useContext(TxModalContext)
  const wallet = useWallet()
  const { safe } = useSafeInfo()

  const onClick = async (e: SyntheticEvent) => {
    e.stopPropagation()
    e.preventDefault()

    trackEvent(RECOVERY_EVENTS.CANCEL_RECOVERY)
    if (isOwner) {
      setTxFlow(<CancelRecoveryFlow recovery={recovery} />)
    } else if (wallet) {
      try {
        await dispatchRecoverySkipExpired({
          provider: wallet.provider,
          chainId: safe.chainId,
          delayModifierAddress: recovery.address,
          recoveryTxHash: recovery.args.txHash,
          signerAddress: wallet.address,
        })
      } catch (_err) {
        const err = asError(_err)

        trackError(Errors._813, err)
        setSubmitError(err)
      }
    }
  }

  return (
    <CheckWallet allowNonOwner checkNetwork>
      {(isOk) => {
        const isDisabled = isPending || (isOwner ? !isOk : !isOk || !isExpired)

        return (
          <Button
            data-testid="cancel-recovery-btn"
            onClick={onClick}
            variant="danger"
            disabled={isDisabled}
            size={compact ? 'small' : 'stretched'}
          >
            Cancel
          </Button>
        )
      }}
    </CheckWallet>
  )
}
</file>

<file path="src/features/recovery/components/ExecuteRecoveryButton/index.tsx">
import { Button, Tooltip } from '@mui/material'
import { useContext } from 'react'
import type { SyntheticEvent, ReactElement } from 'react'

import CheckWallet from '@/components/common/CheckWallet'
import { useRecoveryTxState } from '@/features/recovery/hooks/useRecoveryTxState'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import useIsWrongChain from '@/hooks/useIsWrongChain'
import { useCurrentChain } from '@/hooks/useChains'
import { TxModalContext } from '@/components/tx-flow'
import { RecoveryAttemptFlow } from '@/components/tx-flow/flows'

export function ExecuteRecoveryButton({
  recovery,
  compact = false,
}: {
  recovery: RecoveryQueueItem
  compact?: boolean
}): ReactElement {
  const { isExecutable, isNext, isPending } = useRecoveryTxState(recovery)
  const isDisabled = !isExecutable || isPending
  const isWrongChain = useIsWrongChain()
  const chain = useCurrentChain()
  const { setTxFlow } = useContext(TxModalContext)

  const onClick = async (e: SyntheticEvent) => {
    e.stopPropagation()
    e.preventDefault()

    setTxFlow(<RecoveryAttemptFlow item={recovery} />)
  }

  return (
    <CheckWallet allowNonOwner checkNetwork={!isDisabled}>
      {(isOk) => {
        return (
          <Tooltip
            title={
              !isOk || isDisabled
                ? isWrongChain
                  ? `Switch your wallet network to ${chain?.chainName} to execute this transaction`
                  : isNext
                    ? 'You can execute the recovery after the specified review window'
                    : 'Previous recovery proposals must be executed or cancelled first'
                : null
            }
          >
            <span>
              <Button
                data-testid="execute-btn"
                onClick={onClick}
                variant="contained"
                disabled={!isOk || isDisabled}
                sx={{ minWidth: '106.5px', py: compact ? 0.8 : undefined }}
                size={compact ? 'small' : 'stretched'}
              >
                Execute
              </Button>
            </span>
          </Tooltip>
        )
      }}
    </CheckWallet>
  )
}
</file>

<file path="src/features/recovery/components/GroupedRecoveryListItems/index.tsx">
import Track from '@/components/common/Track'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Box, Paper, Typography } from '@mui/material'
import partition from 'lodash/partition'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import type { Transaction } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'

import { isRecoveryQueueItem } from '@/utils/transaction-guards'
import ExpandableTransactionItem from '@/components/transactions/TxListItem/ExpandableTransactionItem'
import { RecoveryListItem } from '../RecoveryListItem'
import ExternalLink from '@/components/common/ExternalLink'
import { HelpCenterArticle, HelperCenterArticleTitles } from '@/config/constants'

import css from '@/components/transactions/GroupedTxListItems/styles.module.css'
import customCss from './styles.module.css'

function Disclaimer({ isMalicious }: { isMalicious: boolean }): ReactElement {
  return (
    <Box
      className={css.disclaimerContainer}
      sx={{ bgcolor: ({ palette }) => `${palette.warning.background} !important` }}
    >
      <Typography>
        <Typography component="span" fontWeight={700}>
          Cancelling {isMalicious ? 'malicious transaction' : 'Account recovery'}.
        </Typography>{' '}
        You will need to execute the cancellation.{' '}
        <Track {...RECOVERY_EVENTS.LEARN_MORE} label="tx-queue">
          <ExternalLink href={HelpCenterArticle.RECOVERY} title={HelperCenterArticleTitles.RECOVERY}>
            Learn more
          </ExternalLink>
        </Track>
      </Typography>
    </Box>
  )
}

export function GroupedRecoveryListItems({ items }: { items: Array<Transaction | RecoveryQueueItem> }): ReactElement {
  const [recoveries, cancellations] = partition(items, isRecoveryQueueItem)

  // Should only be one recovery item but check array in case
  const isMalicious = recoveries.some((recovery) => recovery.isMalicious)

  return (
    <Paper className={[css.container, customCss.recoveryGroupContainer].join(' ')}>
      <Box gridArea="warning" className={css.disclaimerContainer}>
        <Disclaimer isMalicious={isMalicious} />
      </Box>

      <Box gridArea="line" className={css.line} />

      <Box gridArea="items" className={css.txItems}>
        {cancellations.map((tx) => (
          <div key={tx.transaction.id}>
            <ExpandableTransactionItem item={tx} />
          </div>
        ))}

        {recoveries.map((recovery) => (
          <RecoveryListItem key={recovery.transactionHash} item={recovery} />
        ))}
      </Box>
    </Paper>
  )
}
</file>

<file path="src/features/recovery/components/GroupedRecoveryListItems/styles.module.css">
.recoveryGroupContainer {
  grid-template-areas:
    'warning warning warning warning warning warning'
    'line items items items items items';
}
</file>

<file path="src/features/recovery/components/Recovery/index.tsx">
import dynamic from 'next/dynamic'
import { useIsRecoverySupported } from '../../hooks/useIsRecoverySupported'

const LazyRecovery = dynamic(() => import('./LazyRecovery'))

function Recovery() {
  const isSupported = useIsRecoverySupported()
  return isSupported ? <LazyRecovery /> : null
}

export default Recovery
</file>

<file path="src/features/recovery/components/Recovery/LazyRecovery.tsx">
import { RecoveryModal } from '@/features/recovery/components/RecoveryModal'
import { useRecoveryTxNotifications } from '@/features/recovery/hooks/useRecoveryTxNotification'
import RecoveryContextHooks from '../RecoveryContext/RecoveryContextHooks'

function LazyRecovery() {
  useRecoveryTxNotifications()

  return (
    <>
      <RecoveryContextHooks />
      <RecoveryModal />
    </>
  )
}

export default LazyRecovery
</file>

<file path="src/features/recovery/components/RecoveryCards/RecoveryInProgressCard.tsx">
import Track from '@/components/common/Track'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Button, Card, Divider, Grid, Typography } from '@mui/material'
import { useRouter } from 'next/dist/client/router'
import type { ReactElement } from 'react'

import { useRecoveryTxState } from '@/features/recovery/hooks/useRecoveryTxState'
import { Countdown } from '@/components/common/Countdown'
import RecoveryPending from '@/public/images/common/recovery-pending.svg'
import ExternalLink from '@/components/common/ExternalLink'
import { AppRoutes } from '@/config/routes'
import { HelpCenterArticle, HelperCenterArticleTitles } from '@/config/constants'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

import css from './styles.module.css'

type Props =
  | {
      orientation?: 'vertical'
      onClose: () => void
      recovery: RecoveryQueueItem
    }
  | {
      orientation: 'horizontal'
      onClose?: never
      recovery: RecoveryQueueItem
    }

export function RecoveryInProgressCard({ orientation = 'vertical', onClose, recovery }: Props): ReactElement {
  const { isExecutable, isExpired, remainingSeconds } = useRecoveryTxState(recovery)
  const router = useRouter()

  const onClick = async () => {
    await router.push({
      pathname: AppRoutes.transactions.queue,
      query: router.query,
    })
    onClose?.()
  }

  const icon = <RecoveryPending />
  const title = isExecutable
    ? 'Account can be recovered'
    : isExpired
      ? 'Account recovery expired'
      : 'Account recovery in progress'
  const desc = isExecutable
    ? 'The review window has passed and it is now possible to execute the recovery proposal.'
    : isExpired
      ? 'The pending recovery proposal has expired and needs to be cancelled before a new one can be created.'
      : 'The recovery process has started. This Account will be ready to recover in:'

  const link = (
    <Track {...RECOVERY_EVENTS.LEARN_MORE} label="in-progress-card">
      <ExternalLink href={HelpCenterArticle.RECOVERY} title={HelperCenterArticleTitles.RECOVERY}>
        Learn more
      </ExternalLink>
    </Track>
  )

  if (orientation === 'horizontal') {
    return (
      <Card sx={{ py: 3, px: 4 }}>
        <Grid
          container
          sx={{
            display: 'flex',
            alignItems: { xs: 'flex-start', md: 'center' },
            gap: 3,
            flexDirection: { xs: 'column', md: 'row' },
          }}
        >
          <Grid item>{icon}</Grid>

          <Grid item xs>
            <Typography
              variant="h6"
              sx={{
                fontWeight: 700,
                mb: 1,
              }}
            >
              {title}
            </Typography>

            <Typography
              sx={{
                color: 'primary.light',
                mb: 1,
              }}
            >
              {desc}
            </Typography>

            <Countdown seconds={remainingSeconds} />
          </Grid>

          <Grid item>{link}</Grid>
        </Grid>
      </Card>
    )
  }

  return (
    <Card elevation={0} className={css.card}>
      <Grid
        container
        sx={{
          display: 'flex',
          flexDirection: 'column',
          gap: 4,
        }}
      >
        <Grid
          item
          xs={12}
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          {icon}

          {link}
        </Grid>

        <Grid item xs={12}>
          <Typography
            variant="h6"
            sx={{
              fontWeight: 700,
              mb: 2,
            }}
          >
            {title}
          </Typography>

          <Typography
            sx={{
              mb: 2,
            }}
          >
            {desc}
          </Typography>

          <Countdown seconds={remainingSeconds} />
        </Grid>

        <Divider flexItem sx={{ mx: -4 }} />

        <Track {...RECOVERY_EVENTS.CHECK_RECOVERY_PROPOSAL}>
          <Button data-testid="queue-btn" variant="contained" onClick={onClick} sx={{ alignSelf: 'flex-end' }}>
            Go to queue
          </Button>
        </Track>
      </Grid>
    </Card>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryCards/RecoveryProposalCard.tsx">
import Track from '@/components/common/Track'
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Button, Card, Divider, Grid, Typography } from '@mui/material'
import { useContext } from 'react'
import type { ReactElement } from 'react'

import { useDarkMode } from '@/hooks/useDarkMode'
import ExternalLink from '@/components/common/ExternalLink'
import { RecoverAccountFlow } from '@/components/tx-flow/flows'
import useSafeInfo from '@/hooks/useSafeInfo'
import madProps from '@/utils/mad-props'
import { TxModalContext } from '@/components/tx-flow'
import { HelpCenterArticle, HelperCenterArticleTitles } from '@/config/constants'
import type { TxModalContextType } from '@/components/tx-flow'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'

import css from './styles.module.css'
import { maybePlural } from '@safe-global/utils/utils/formatters'

type Props =
  | {
      orientation?: 'vertical'
      onClose: () => void
      safe: SafeState
      setTxFlow: TxModalContextType['setTxFlow']
    }
  | {
      orientation: 'horizontal'
      onClose?: never
      safe: SafeState
      setTxFlow: TxModalContextType['setTxFlow']
    }

export function InternalRecoveryProposalCard({
  orientation = 'vertical',
  onClose,
  safe,
  setTxFlow,
}: Props): ReactElement {
  const isDarkMode = useDarkMode()

  const onRecover = async () => {
    onClose?.()
    setTxFlow(<RecoverAccountFlow />)
    trackEvent({ ...RECOVERY_EVENTS.START_RECOVERY, label: orientation === 'vertical' ? 'pop-up' : 'dashboard' })
  }

  const icon = (
    <img
      src={`/images/common/propose-recovery-${isDarkMode ? 'dark' : 'light'}.svg`}
      alt="An arrow surrounding a circle containing a vault"
    />
  )
  const title = 'Recover this Account'
  const desc = `The connected wallet was chosen as a trusted Recoverer. You can help the owner${maybePlural(safe.owners)} regain access by resetting the Account setup.`

  const link = (
    <Track {...RECOVERY_EVENTS.LEARN_MORE} label="proposal-card">
      <ExternalLink href={HelpCenterArticle.RECOVERY} title={HelperCenterArticleTitles.RECOVERY}>
        Learn more
      </ExternalLink>
    </Track>
  )

  const recoveryButton = (
    <Button data-testid="start-recovery-btn" variant="contained" onClick={onRecover} className={css.button}>
      Start recovery
    </Button>
  )

  if (orientation === 'horizontal') {
    return (
      <Card data-testid="recovery-proposal-hr" sx={{ py: 3, px: 4 }}>
        <Grid
          container
          sx={{
            display: 'flex',
            alignItems: { xs: 'flex-start', md: 'center' },
            gap: 3,
            flexDirection: { xs: 'column', md: 'row' },
          }}
        >
          <Grid item>{icon}</Grid>

          <Grid item xs>
            <Typography
              variant="h6"
              sx={{
                fontWeight: 700,
                mb: 1,
              }}
            >
              {title}
            </Typography>

            <Typography
              sx={{
                color: 'primary.light',
                mb: 1,
              }}
            >
              {desc}
            </Typography>

            <Typography>{link}</Typography>
          </Grid>

          {recoveryButton}
        </Grid>
      </Card>
    )
  }

  return (
    <Card data-testid="recovery-proposal" elevation={0} className={css.card}>
      <Grid
        container
        sx={{
          display: 'flex',
          flexDirection: 'column',
          gap: 4,
        }}
      >
        <Grid
          item
          xs={12}
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          {icon}

          {link}
        </Grid>

        <Grid item xs={12}>
          <Typography
            variant="h6"
            sx={{
              fontWeight: 700,
              mb: 2,
            }}
          >
            {title}
          </Typography>

          <Typography
            sx={{
              color: 'primary.light',
              mb: 2,
            }}
          >
            {desc}
          </Typography>
        </Grid>

        <Divider flexItem sx={{ mx: -4 }} />

        <Grid
          item
          container
          sx={{
            justifyContent: 'flex-end',
            gap: { md: 1 },
          }}
        >
          <Button
            data-testid="postpone-recovery-btn"
            onClick={() => {
              trackEvent(RECOVERY_EVENTS.DISMISS_PROPOSAL_CARD)
              onClose?.()
            }}
          >
            I&apos;ll do it later
          </Button>
          {recoveryButton}
        </Grid>
      </Grid>
    </Card>
  )
}

// Appease TypeScript
const InternalUseSafe = () => useSafeInfo().safe
const InternalUseSetTxFlow = () => useContext(TxModalContext).setTxFlow

export const RecoveryProposalCard = madProps(InternalRecoveryProposalCard, {
  safe: InternalUseSafe,
  setTxFlow: InternalUseSetTxFlow,
})
</file>

<file path="src/features/recovery/components/RecoveryCards/styles.module.css">
.card {
  max-width: 576px;
  padding: var(--space-2);
  margin: var(--space-2);
}

.button {
  width: 100%;
}

@media (min-width: 600px) {
  .card {
    padding: var(--space-4);
  }

  .button {
    width: auto;
  }
}

/* To center the card when the sidebar is visible */
@media (min-width: 900px) {
  .card {
    margin-left: 230px;
  }
}
</file>

<file path="src/features/recovery/components/RecoveryContext/index.tsx">
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import type { PendingRecoveryTransactions } from './useRecoveryPendingTxs'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import type { RecoveryState } from '@/features/recovery/services/recovery-state'

export type RecoveryContextType = {
  state: AsyncResult<RecoveryState>
  pending: PendingRecoveryTransactions
}

const recoveryStore = new ExternalStore<RecoveryContextType>({
  state: [undefined, undefined, false],
  pending: {},
})

export default recoveryStore
</file>

<file path="src/features/recovery/components/RecoveryContext/RecoveryContextHooks.tsx">
import { useEffect } from 'react'
import { useRecoveryState } from './useRecoveryState'
import { useRecoveryDelayModifiers } from './useRecoveryDelayModifiers'
import { useRecoveryPendingTxs } from './useRecoveryPendingTxs'
import { useRecoverySuccessEvents } from './useRecoverySuccessEvents'
import store from '.'

function RecoveryContextHooks(): null {
  const [delayModifiers, delayModifiersError, delayModifiersLoading] = useRecoveryDelayModifiers()
  const [recoveryState, recoveryStateError, recoveryStateLoading] = useRecoveryState(delayModifiers)
  const pending = useRecoveryPendingTxs()

  useRecoverySuccessEvents(pending, recoveryState)

  const data = recoveryState
  const error = delayModifiersError || recoveryStateError
  const loading = delayModifiersLoading || recoveryStateLoading

  useEffect(() => {
    store.setStore({
      state: [data, error, loading],
      pending,
    })
  }, [data, error, loading, pending])

  return null
}

export default RecoveryContextHooks
</file>

<file path="src/features/recovery/components/RecoveryContext/useRecoveryDelayModifiers.ts">
import type { Delay } from '@gnosis.pm/zodiac'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'

import { getRecoveryDelayModifiers } from '@/features/recovery/services/delay-modifier'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { getDeployedSpendingLimitModuleAddress } from '@/services/contracts/spendingLimitContracts'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { useIsRecoverySupported } from '../../hooks/useIsRecoverySupported'

function isOnlySpendingLimitEnabled(chainId: string, modules: SafeState['modules']) {
  if (modules && modules.length > 1) return false
  const spendingLimit = getDeployedSpendingLimitModuleAddress(chainId, modules)
  return !!spendingLimit
}

export function useRecoveryDelayModifiers(): AsyncResult<Delay[]> {
  const supportsRecovery = useIsRecoverySupported()
  const web3ReadOnly = useWeb3ReadOnly()
  const { safe, safeAddress } = useSafeInfo()

  return useAsync<Array<Delay>>(
    () => {
      // Don't fetch if only spending limit module is enabled
      if (
        supportsRecovery &&
        web3ReadOnly &&
        safe.modules &&
        safe.modules.length > 0 &&
        !isOnlySpendingLimitEnabled(safe.chainId, safe.modules)
      ) {
        return getRecoveryDelayModifiers(safe.chainId, safe.modules, web3ReadOnly)
      }
    },
    // Only fetch delay modifiers again if the chain or enabled modules of current Safe changes
    // Need to check length of modules array to prevent new request every time Safe info polls
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [safeAddress, safe.chainId, safe.modules?.length, web3ReadOnly, supportsRecovery],
    false,
  )
}
</file>

<file path="src/features/recovery/components/RecoveryContext/useRecoveryPendingTxs.ts">
import { useEffect, useState } from 'react'

import { RecoveryEvent, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'
import type { RecoveryTxType } from '@/features/recovery/services/recoveryEvents'

export type PendingRecoveryTransactions = {
  [recoveryTxHash: string]: {
    status: RecoveryEvent
    txType: RecoveryTxType
  }
}

const pendingStatuses: { [_key in RecoveryEvent]: RecoveryEvent | null } = {
  [RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET]: null,
  [RecoveryEvent.PROCESSING]: RecoveryEvent.PROCESSING,
  [RecoveryEvent.PROCESSED]: RecoveryEvent.PROCESSED,
  [RecoveryEvent.SUCCESS]: null,
  [RecoveryEvent.REVERTED]: null,
  [RecoveryEvent.FAILED]: null,
}

export function useRecoveryPendingTxs() {
  const [pending, setPending] = useState<PendingRecoveryTransactions>({})

  useEffect(() => {
    const unsubFns = Object.entries(pendingStatuses).map(([event, status]) =>
      recoverySubscribe(event as RecoveryEvent, (detail) => {
        const recoveryTxHash = 'recoveryTxHash' in detail && detail.recoveryTxHash

        if (!recoveryTxHash) {
          return
        }

        setPending((prev) => {
          if (status === null) {
            const { [recoveryTxHash]: _, ...rest } = prev
            return rest
          }

          return {
            ...prev,
            [recoveryTxHash]: {
              txType: detail.txType,
              status,
            },
          }
        })
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [])

  return pending
}
</file>

<file path="src/features/recovery/components/RecoveryContext/useRecoveryState.ts">
import { useCallback, useEffect, useState } from 'react'
import type { Delay } from '@gnosis.pm/zodiac'

import useAsync from '@safe-global/utils/hooks/useAsync'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import useIntervalCounter from '@/hooks/useIntervalCounter'
import { getRecoveryState } from '@/features/recovery/services/recovery-state'
import { useAppDispatch } from '@/store'
import { isCustomTxInfo, isMultiSendTxInfo, isTransactionListItem } from '@/utils/transaction-guards'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { addListener } from '@reduxjs/toolkit'
import { txHistorySlice } from '@/store/txHistorySlice'
import { RecoveryEvent, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import type { RecoveryState } from '@/features/recovery/services/recovery-state'

const REFRESH_DELAY = 5 * 60 * 1_000 // 5 minutes

export function useRecoveryState(delayModifiers?: Array<Delay>): AsyncResult<RecoveryState> {
  const web3ReadOnly = useWeb3ReadOnly()
  const chain = useCurrentChain()
  const { safe, safeAddress } = useSafeInfo()
  const dispatch = useAppDispatch()

  // Reload recovery data every REFRESH_DELAY
  const [counter] = useIntervalCounter(REFRESH_DELAY)

  // Reload recovery data when manually triggered
  const [refetchDep, setRefetchDep] = useState(false)
  const refetch = useCallback(() => {
    setRefetchDep((prev) => !prev)
  }, [])

  // Reload recovery data when a Recoverer transaction occurs
  useEffect(() => {
    return recoverySubscribe(RecoveryEvent.PROCESSED, refetch)
  }, [refetch])

  // Reload recovery data when a Delay Modifier is interacted with
  useEffect(() => {
    if (!delayModifiers || delayModifiers.length === 0) {
      return
    }

    // We leverage a listener instead of useAsync dependencies because there are
    // that need be loaded before we can initially fetch the recovery state
    const listener = dispatch(
      addListener({
        // Listen to history polls (only occuring when the txHistoryTag changes)
        actionCreator: txHistorySlice.actions.set,
        effect: async (action) => {
          // Get the most recent transaction
          const [latestTx] = action.payload.data?.results.filter(isTransactionListItem) ?? []

          if (!latestTx) {
            return
          }

          const { txInfo } = latestTx.transaction

          const isDelayModiferTx = (
            await Promise.all(
              delayModifiers.map(async (delayModifier) => {
                const address = await delayModifier.getAddress()
                return isCustomTxInfo(txInfo) && sameAddress(txInfo.to.value, address)
              }),
            )
          ).some(Boolean)

          // Refetch if the most recent transaction was with a Delay Modifier or MultiSend
          // (Multiple Delay Modifier settings changes are batched into a MultiSend)
          if (isDelayModiferTx || isMultiSendTxInfo(txInfo)) {
            refetch()
          }
        },
      }),
    )

    // Types are incorrect, but this ensures type safety
    const unsubscribe =
      listener instanceof Function
        ? (listener as unknown as typeof listener.payload.unsubscribe)
        : listener.payload.unsubscribe

    return unsubscribe
  }, [safe.chainId, delayModifiers, refetch, dispatch])

  return useAsync<RecoveryState>(
    () => {
      if (!delayModifiers || delayModifiers.length === 0 || !chain?.transactionService || !web3ReadOnly) {
        return
      }

      return getRecoveryState({
        delayModifiers,
        transactionService: chain.transactionService,
        safeAddress,
        provider: web3ReadOnly,
        chainId: safe.chainId,
        version: safe.version,
      })
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      delayModifiers,
      counter,
      refetchDep,
      chain?.transactionService,
      web3ReadOnly,
      safeAddress,
      safe.chainId,
      safe.version,
    ],
    false,
  )
}
</file>

<file path="src/features/recovery/components/RecoveryContext/useRecoverySuccessEvents.ts">
import { useEffect } from 'react'

import { RecoveryEvent, RecoveryTxType, recoveryDispatch } from '@/features/recovery/services/recoveryEvents'
import type { RecoveryState } from '@/features/recovery/services/recovery-state'
import type { useRecoveryPendingTxs } from './useRecoveryPendingTxs'

export function useRecoverySuccessEvents(
  pending: ReturnType<typeof useRecoveryPendingTxs>,
  recoveryState?: RecoveryState,
): void {
  useEffect(() => {
    const pendingEntries = Object.entries(pending)

    if (!recoveryState || recoveryState.length === 0 || pendingEntries.length === 0) {
      return
    }

    pendingEntries.forEach(([recoveryTxHash, { txType, status }]) => {
      // Transaction successfully executed, waiting for recovery state to be loaded again
      if (status !== RecoveryEvent.PROCESSED) {
        return
      }

      const isQueued = recoveryState.some(({ queue }) => queue.some(({ args }) => args.txHash === recoveryTxHash))

      // Only queued proposals or executions/cancellations removed from the queue
      if (isQueued && txType !== RecoveryTxType.PROPOSAL) {
        return
      }

      recoveryDispatch(RecoveryEvent.SUCCESS, {
        recoveryTxHash,
        txType,
      })
    })
  }, [pending, recoveryState])
}
</file>

<file path="src/features/recovery/components/RecoveryDescription/index.tsx">
import { Typography } from '@mui/material'
import { useMemo } from 'react'
import type { ReactElement } from 'react'

import EthHashInfo from '@/components/common/EthHashInfo'
import { InfoDetails } from '@/components/transactions/InfoDetails'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { useIsRecoverer } from '@/features/recovery/hooks/useIsRecoverer'
import useSafeInfo from '@/hooks/useSafeInfo'
import { logError, Errors } from '@/services/exceptions'
import { getRecoveredSafeInfo } from '@/features/recovery/services/transaction-list'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function RecoveryDescription({ item }: { item: RecoveryQueueItem }): ReactElement {
  const { args, isMalicious } = item
  const { safe } = useSafeInfo()
  const isRecoverer = useIsRecoverer()

  const newSetup = useMemo(() => {
    try {
      return getRecoveredSafeInfo(safe, {
        to: args.to,
        value: args.value.toString(),
        data: args.data,
      })
    } catch (e) {
      logError(Errors._811, e)
    }
    // We only render the threshold and owners
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [args.data, args.to, args.value, safe.threshold, safe.owners])

  if (isMalicious) {
    return (
      <ErrorMessage>This transaction potentially calls malicious actions. We recommend cancelling it.</ErrorMessage>
    )
  }

  // TODO: Improve by using Tenderly to check if the proposal will fail
  if (!newSetup || newSetup.owners.length === 0) {
    return (
      <ErrorMessage>
        This recovery proposal will fail as the owner structure has since been modified. We recommend cancelling it
        {isRecoverer ? ' and trying again' : ''}.
      </ErrorMessage>
    )
  }

  return (
    <InfoDetails title="Add signer(s):">
      {newSetup.owners.map((owner) => (
        <EthHashInfo key={owner.value} address={owner.value} shortAddress={false} showCopyButton hasExplorer />
      ))}

      <div>
        <Typography fontWeight={700} gutterBottom>
          Required confirmations for new transactions:
        </Typography>
        <Typography>
          {newSetup.threshold} out of {newSetup.owners.length} owner(s)
        </Typography>
      </div>
    </InfoDetails>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryDetails/index.tsx">
import { Link } from '@mui/material'
import { useState } from 'react'
import { Operation } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'

import { dateString } from '@safe-global/utils/utils/formatters'
import { generateDataRowValue, TxDataRow } from '@/components/transactions/TxDetails/Summary/TxDataRow'
import { RecoverySigners } from '../RecoverySigners'
import { RecoveryDescription } from '../RecoveryDescription'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

import txDetailsCss from '@/components/transactions/TxDetails/styles.module.css'

export function RecoveryDetails({ item }: { item: RecoveryQueueItem }): ReactElement {
  const { transactionHash, timestamp, validFrom, expiresAt, args, address } = item

  const [expanded, setExpanded] = useState(false)

  const toggleExpanded = () => {
    setExpanded((prev) => !prev)
  }

  return (
    <div className={txDetailsCss.container}>
      <div className={txDetailsCss.details}>
        <div className={txDetailsCss.txData}>
          <RecoveryDescription item={item} />
        </div>

        <div className={txDetailsCss.txSummary}>
          <TxDataRow title="Transaction hash">{generateDataRowValue(transactionHash, 'hash', true)}</TxDataRow>
          <TxDataRow title="Created:">{dateString(Number(timestamp))}</TxDataRow>
          <TxDataRow title="Executable:">{dateString(Number(validFrom))}</TxDataRow>

          {expiresAt !== null && <TxDataRow title="Expires:">{dateString(Number(expiresAt))}</TxDataRow>}

          <Link onClick={toggleExpanded} component="button" variant="body1">
            Advanced details
          </Link>

          {expanded && (
            <>
              <TxDataRow title="Module:">{generateDataRowValue(address, 'address', true)}</TxDataRow>
              <TxDataRow title="Value:">{args.value.toString()}</TxDataRow>
              <TxDataRow title="Operation:">{`${Number(args.operation)} (${Operation[
                Number(args.operation)
              ].toLowerCase()})`}</TxDataRow>
              <TxDataRow title="Raw data:">{generateDataRowValue(args.data, 'rawData')}</TxDataRow>
            </>
          )}
        </div>
      </div>

      <div className={txDetailsCss.txSigners}>
        <RecoverySigners item={item} />
      </div>
    </div>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryHeader/index.tsx">
import { Grid } from '@mui/material'
import { useEffect, useState } from 'react'
import type { ReactElement } from 'react'

import { useRecoveryQueue } from '@/features/recovery/hooks/useRecoveryQueue'
import { useIsRecoverer } from '@/features/recovery/hooks/useIsRecoverer'
import madProps from '@/utils/mad-props'
import { RecoveryProposalCard } from '@/features/recovery/components/RecoveryCards/RecoveryProposalCard'
import { RecoveryInProgressCard } from '@/features/recovery/components/RecoveryCards/RecoveryInProgressCard'
import { WidgetContainer, WidgetBody } from '@/components/dashboard/styled'
import { RecoveryEvent, RecoveryTxType, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function InternalRecoveryHeader({
  isProposalInProgress,
  isRecoverer,
  queue,
}: {
  isProposalInProgress: boolean
  isRecoverer: boolean
  queue: Array<RecoveryQueueItem>
}): ReactElement | null {
  const next = queue[0]

  const modal = next ? (
    <RecoveryInProgressCard orientation="horizontal" recovery={next} />
  ) : isRecoverer && !isProposalInProgress ? (
    <RecoveryProposalCard orientation="horizontal" />
  ) : null

  if (modal) {
    return (
      <Grid item xs={12}>
        <WidgetContainer>
          <WidgetBody>{modal}</WidgetBody>
        </WidgetContainer>
      </Grid>
    )
  }
  return null
}

export function useIsProposalInProgress(): boolean {
  const [isProposalSubmitting, setIsProposalSubmitting] = useState(false)
  const queue = useRecoveryQueue()

  useEffect(() => {
    const unsubFns = Object.values(RecoveryEvent).map((event) =>
      recoverySubscribe(event, (detail) => {
        const isProposal = 'txType' in detail && detail.txType === RecoveryTxType.PROPOSAL
        const isProcessing = event === RecoveryEvent.PROCESSING
        const isLoaded = queue.some((item) => item.args.txHash === detail?.recoveryTxHash)

        setIsProposalSubmitting(isProposal && (isProcessing || !isLoaded))
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [queue])

  return isProposalSubmitting
}

const RecoveryHeader = madProps(InternalRecoveryHeader, {
  isProposalInProgress: useIsProposalInProgress,
  isRecoverer: useIsRecoverer,
  queue: useRecoveryQueue,
})

export default RecoveryHeader
</file>

<file path="src/features/recovery/components/RecoveryInfo/index.tsx">
import { SvgIcon, Tooltip } from '@mui/material'
import type { ReactElement } from 'react'

import WarningIcon from '@/public/images/notifications/warning.svg'

export const RecoveryInfo = ({ isMalicious }: { isMalicious: boolean }): ReactElement | null => {
  if (!isMalicious) {
    return null
  }

  return (
    <Tooltip title="Suspicious activity" placement="top" arrow>
      <span>
        <SvgIcon component={WarningIcon} inheritViewBox color="error" />
      </span>
    </Tooltip>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryList/index.tsx">
import dynamic from 'next/dynamic'
import { useIsRecoverySupported } from '../../hooks/useIsRecoverySupported'

const LazyRecoveryList = dynamic(() => import('./LazyRecoveryList'))

const RecoveryList = () => {
  const supportsRecovery = useIsRecoverySupported()
  return supportsRecovery ? <LazyRecoveryList /> : null
}

export default RecoveryList
</file>

<file path="src/features/recovery/components/RecoveryList/LazyRecoveryList.tsx">
import { useMemo } from 'react'
import type { ReactElement } from 'react'

import { TxListGrid } from '@/components/transactions/TxList'
import { RecoveryListItem } from '@/features/recovery/components/RecoveryListItem'
import { useRecoveryQueue } from '@/features/recovery/hooks/useRecoveryQueue'
import { groupRecoveryTransactions } from '@/utils/tx-list'
import useTxQueue from '@/hooks/useTxQueue'
import { GroupedRecoveryListItems } from '../GroupedRecoveryListItems'
import { isRecoveryQueueItem } from '@/utils/transaction-guards'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

import labelCss from '@/components/transactions/GroupLabel/styles.module.css'

// Conditional hook
function InternalRecoveryList({ recoveryQueue }: { recoveryQueue: Array<RecoveryQueueItem> }): ReactElement {
  const queue = useTxQueue()

  const groupedItems = useMemo(() => {
    if (!queue?.page?.results || queue.page.results.length === 0) {
      return recoveryQueue
    }
    return groupRecoveryTransactions(queue.page.results, recoveryQueue)
  }, [queue, recoveryQueue])

  const transactions = useMemo(() => {
    return groupedItems.map((item, index) => {
      if (Array.isArray(item)) {
        return <GroupedRecoveryListItems items={item} key={index} />
      }

      if (isRecoveryQueueItem(item)) {
        return <RecoveryListItem item={item} key={item.transactionHash} />
      }

      // Will never have non-recovery transactions here
      return null
    })
  }, [groupedItems])

  return <TxListGrid>{transactions}</TxListGrid>
}

function LazyRecoveryList(): ReactElement | null {
  const recoveryQueue = useRecoveryQueue()

  if (recoveryQueue.length === 0) {
    return null
  }

  return (
    <>
      <div className={labelCss.container}>Pending recovery</div>

      <TxListGrid>
        <InternalRecoveryList recoveryQueue={recoveryQueue} />
      </TxListGrid>
    </>
  )
}

export default LazyRecoveryList
</file>

<file path="src/features/recovery/components/RecoveryListItem/index.tsx">
import { Accordion, AccordionDetails, AccordionSummary } from '@mui/material'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import { useContext, useState } from 'react'
import type { ComponentProps, ReactElement } from 'react'

import { RecoverySummary } from '../RecoverySummary'
import { RecoveryDetails } from '../RecoveryDetails'
import { RecoveryListItemContext, RecoveryListItemProvider } from './RecoveryListItemContext'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

function ProvidedRecoveryListItem({ item }: { item: RecoveryQueueItem }): ReactElement {
  const { submitError, setSubmitError } = useContext(RecoveryListItemContext)
  const [expanded, setExpanded] = useState(false)

  const isExpanded = !!submitError || expanded

  const onChange = () => {
    if (isExpanded) {
      setExpanded(false)
      setSubmitError(undefined)
    } else {
      setExpanded(true)
    }
  }

  return (
    <Accordion disableGutters elevation={0} expanded={isExpanded} onChange={onChange}>
      <AccordionSummary expandIcon={<ExpandMoreIcon />} sx={{ justifyContent: 'flex-start', overflowX: 'auto' }}>
        <RecoverySummary item={item} />
      </AccordionSummary>

      <AccordionDetails sx={{ p: 0 }}>
        <RecoveryDetails item={item} />
      </AccordionDetails>
    </Accordion>
  )
}

export function RecoveryListItem(props: ComponentProps<typeof ProvidedRecoveryListItem>): ReactElement {
  return (
    <RecoveryListItemProvider>
      <ProvidedRecoveryListItem {...props} />
    </RecoveryListItemProvider>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryListItem/RecoveryListItemContext.tsx">
import { createContext, useState } from 'react'
import type { Dispatch, ReactElement, SetStateAction } from 'react'

type SubmitError = Error | undefined

export const RecoveryListItemContext = createContext<{
  submitError: SubmitError
  setSubmitError: Dispatch<SetStateAction<SubmitError>>
}>({
  submitError: undefined,
  setSubmitError: () => {},
})

export function RecoveryListItemProvider({ children }: { children: ReactElement }): ReactElement {
  const [submitError, setSubmitError] = useState<SubmitError>(undefined)

  return (
    <RecoveryListItemContext.Provider value={{ submitError, setSubmitError }}>
      {children}
    </RecoveryListItemContext.Provider>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryModal/index.tsx">
import { Backdrop, Fade } from '@mui/material'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useRouter } from 'next/router'
import type { ReactElement } from 'react'

import { useRecoveryQueue } from '@/features/recovery/hooks/useRecoveryQueue'
import { RecoveryInProgressCard } from '../RecoveryCards/RecoveryInProgressCard'
import { RecoveryProposalCard } from '../RecoveryCards/RecoveryProposalCard'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useIsRecoverer } from '@/features/recovery/hooks/useIsRecoverer'
import madProps from '@/utils/mad-props'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import useWallet from '@/hooks/wallets/useWallet'
import useSafeInfo from '@/hooks/useSafeInfo'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { useIsSidebarRoute } from '@/hooks/useIsSidebarRoute'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function InternalRecoveryModal({
  isOwner,
  isRecoverer,
  queue,
  wallet,
  isSidebarRoute = true,
}: {
  isOwner: boolean
  isRecoverer: boolean
  queue: Array<RecoveryQueueItem>
  wallet: ReturnType<typeof useWallet>
  isSidebarRoute?: boolean
}): ReactElement {
  const { wasProposalDismissed, dismissProposal } = useDidDismissProposal()
  const { wasInProgressDismissed, dismissInProgress } = useDidDismissInProgress()

  const [modal, setModal] = useState<ReactElement | null>(null)
  const router = useRouter()

  const next = queue[0]

  // Close modal
  const onClose = () => {
    setModal(null)
  }

  // Trigger modal
  useEffect(() => {
    if (!isSidebarRoute) {
      return
    }

    setModal(() => {
      if (next && (isOwner || isRecoverer) && !wasInProgressDismissed(next.transactionHash)) {
        const onCloseWithDismiss = () => {
          dismissInProgress(next.transactionHash)
          onClose()
        }

        return <RecoveryInProgressCard onClose={onCloseWithDismiss} recovery={next} />
      }

      if (wallet?.address && isRecoverer && !wasProposalDismissed(wallet.address)) {
        const onCloseWithDismiss = () => {
          dismissProposal(wallet.address)
          onClose()
        }

        return <RecoveryProposalCard onClose={onCloseWithDismiss} />
      }

      return null
    })
  }, [
    dismissInProgress,
    dismissProposal,
    isRecoverer,
    isOwner,
    next,
    queue.length,
    router.pathname,
    wallet,
    wasInProgressDismissed,
    wasProposalDismissed,
    isSidebarRoute,
  ])

  // Close modal on navigation
  useEffect(() => {
    router.events.on('routeChangeComplete', onClose)
    return () => {
      router.events.off('routeChangeComplete', onClose)
    }
  }, [router])

  return (
    <Fade in={!!modal}>
      <Backdrop open={!!modal} sx={{ zIndex: 3, bgcolor: ({ palette }) => palette.background.main }}>
        {modal}
      </Backdrop>
    </Fade>
  )
}

const useSidebar = () => {
  const [isSidebarRoute] = useIsSidebarRoute()
  return isSidebarRoute
}

export const RecoveryModal = madProps(InternalRecoveryModal, {
  isOwner: useIsSafeOwner,
  isRecoverer: useIsRecoverer,
  queue: useRecoveryQueue,
  wallet: useWallet,
  isSidebarRoute: useSidebar,
})

export function useDidDismissProposal() {
  const LS_KEY = 'dismissedRecoveryProposals'

  type Recoverer = string
  type DismissedProposalCache = { [chainId: string]: { [safeAddress: string]: Recoverer } }

  const { safe, safeAddress } = useSafeInfo()
  const chainId = safe.chainId

  const [dismissedProposals, setDismissedProposals] = useLocalStorage<DismissedProposalCache>(LS_KEY)

  // Cache dismissal of proposal modal
  const dismissProposal = useCallback(
    (recovererAddress: string) => {
      const dismissed = dismissedProposals?.[chainId] ?? {}

      setDismissedProposals({
        ...(dismissedProposals ?? {}),
        [chainId]: {
          ...dismissed,
          [safeAddress]: recovererAddress,
        },
      })
    },
    [dismissedProposals, chainId, safeAddress, setDismissedProposals],
  )

  const wasProposalDismissed = useCallback(
    (recovererAddress: string) => {
      // If no proposals, is recoverer and didn't ever dismiss
      return sameAddress(dismissedProposals?.[chainId]?.[safeAddress], recovererAddress)
    },
    [chainId, dismissedProposals, safeAddress],
  )

  return { wasProposalDismissed, dismissProposal }
}

export function useDidDismissInProgress() {
  type TxHash = string
  type DismissedInProgressCache = { [chainId: string]: { [safeAddress: string]: TxHash } }

  const { safe, safeAddress } = useSafeInfo()
  const chainId = safe.chainId

  const dismissedInProgress = useRef<DismissedInProgressCache>({})

  // Cache dismissal of in-progress modal
  const dismissInProgress = useCallback(
    (txHash: string) => {
      const dismissed = dismissedInProgress.current?.[chainId] ?? {}

      dismissedInProgress.current = {
        ...dismissedInProgress.current,
        [chainId]: {
          ...dismissed,
          [safeAddress]: txHash,
        },
      }
    },
    [chainId, safeAddress],
  )

  const wasInProgressDismissed = useCallback(
    (txHash: string) => {
      // If proposal and did not notify during current session of Safe
      return sameAddress(txHash, dismissedInProgress.current?.[chainId]?.[safeAddress])
    },
    [chainId, safeAddress],
  )

  return { wasInProgressDismissed, dismissInProgress }
}
</file>

<file path="src/features/recovery/components/RecoverySettings/ChooseRecoveryMethodModal.tsx">
import Track from '@/components/common/Track'
import { RECOVERY_FEEDBACK_FORM, HelpCenterArticle, SafeAppsTag } from '@/config/constants'
import { trackEvent } from '@/services/analytics'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { type ChangeEvent, type ReactElement, useContext, useState, useCallback } from 'react'
import { Controller, useForm } from 'react-hook-form'
import Link from 'next/link'
import {
  Box,
  Button,
  Dialog,
  DialogContent,
  DialogContentText,
  FormControl,
  FormControlLabel,
  IconButton,
  List,
  ListItem,
  Radio,
  RadioGroup,
  Typography,
} from '@mui/material'
import CloseIcon from '@mui/icons-material/Close'

import { UpsertRecoveryFlow } from '@/components/tx-flow/flows'
import ExternalLink from '@/components/common/ExternalLink'
import RecoveryCustomIcon from '@/public/images/common/recovery_custom.svg'
import RecoverySygnumIcon from '@/public/images/common/recovery_sygnum.svg'
import RecoveryZkEmailIcon from '@/public/images/common/zkemail-logo.svg'
import { TxModalContext } from '@/components/tx-flow'
import css from './styles.module.css'
import CheckIcon from '@/public/images/common/check.svg'
import { AppRoutes } from '@/config/routes'
import { useSearchParams } from 'next/navigation'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'
import TxStatusChip from '@/components/transactions/TxStatusChip'
import { ZkEmailFakeDoorModal } from './ZkEmailFakeDoorModal'

enum RecoveryMethod {
  SelfCustody = 'SelfCustody',
  Sygnum = 'Sygnum',
  ZkEmail = 'ZkEmail',
}

enum FieldNames {
  recoveryMethod = 'recoveryMethod',
}

type Fields = {
  [FieldNames.recoveryMethod]: RecoveryMethod
}

export function ChooseRecoveryMethodModal({ open, onClose }: { open: boolean; onClose: () => void }): ReactElement {
  const { setTxFlow } = useContext(TxModalContext)
  const [openZkEmailModal, setOpenZkEmailModal] = useState(false)
  const querySafe = useSearchParams().get('safe')
  const [matchingApps] = useRemoteSafeApps({ tag: SafeAppsTag.RECOVERY_SYGNUM })
  const hasSygnumApp = Boolean(matchingApps?.length)

  const methods = useForm<Fields>({
    defaultValues: {
      recoveryMethod: RecoveryMethod.SelfCustody,
    },
    mode: 'onChange',
  })
  const { watch, control } = methods

  const currentType = watch(FieldNames.recoveryMethod)

  const trackOptionChoice = (e: ChangeEvent<HTMLInputElement>) => {
    trackEvent({ ...RECOVERY_EVENTS.SELECT_RECOVERY_METHOD, label: e.target.value })
  }

  const handleSetupClick = useCallback(() => {
    switch (currentType) {
      case RecoveryMethod.SelfCustody:
        setTxFlow(<UpsertRecoveryFlow />)
        break
      case RecoveryMethod.ZkEmail:
        setOpenZkEmailModal(true)
        break
    }
    onClose()
  }, [onClose, setTxFlow, currentType])

  return (
    <>
      <Dialog open={open} onClose={onClose} className={css.dialog}>
        <DialogContent dividers sx={{ py: 2, px: 3 }}>
          <Typography
            variant="h2"
            sx={{
              mb: 1,
            }}
          >
            Set up Account Recovery
          </Typography>
          <IconButton onClick={onClose} className={css.closeIcon}>
            <CloseIcon />
          </IconButton>
          <DialogContentText color="text.primary" mb={4}>
            Ensure that you never lose access to your funds by selecting one of the options below. Want to know how
            recovery works? Learn more in our{' '}
            <Track {...RECOVERY_EVENTS.LEARN_MORE} label="method-modal">
              <ExternalLink href={HelpCenterArticle.RECOVERY}>Help Center</ExternalLink>
            </Track>
          </DialogContentText>
          <FormControl>
            <Controller
              control={control}
              name={FieldNames.recoveryMethod}
              render={({ field }) => (
                <RadioGroup
                  {...field}
                  className={css.buttonGroup}
                  onChange={(e) => {
                    field.onChange(e)
                    trackOptionChoice(e)
                  }}
                >
                  <FormControlLabel
                    value={RecoveryMethod.SelfCustody}
                    control={<Radio />}
                    label={
                      <div className={css.method}>
                        <RecoveryCustomIcon style={{ display: 'block' }} />
                        <Typography
                          sx={{
                            fontWeight: 'bold',
                            mb: 1,
                            mt: 2,
                          }}
                        >
                          Self Custodial Recovery
                        </Typography>
                        <List className={css.checkList}>
                          <ListItem>
                            <CheckIcon />
                            Fully own your recovery setup
                          </ListItem>
                          <ListItem>
                            <CheckIcon />
                            Nominate anyone including friends, family or yourself
                          </ListItem>
                          <ListItem>
                            <CheckIcon />
                            No additional cost and ensured privacy
                          </ListItem>
                        </List>
                      </div>
                    }
                  />

                  <FormControlLabel
                    value={RecoveryMethod.Sygnum}
                    control={<Radio />}
                    disabled={!hasSygnumApp}
                    label={
                      <div className={css.method}>
                        <RecoverySygnumIcon style={{ display: 'block' }} />

                        <Typography
                          sx={{
                            fontWeight: 'bold',
                            mb: 1,
                            mt: 2,
                          }}
                        >
                          Sygnum Web3 Recovery
                        </Typography>
                        <List className={css.checkList}>
                          <ListItem>
                            <CheckIcon />
                            Your key. Your crypto. Your recovery
                          </ListItem>
                          <ListItem>
                            <CheckIcon />
                            Account recovery by your identity
                          </ListItem>
                          <ListItem>
                            <CheckIcon />
                            Regulated Swiss digital asset bank
                          </ListItem>
                        </List>

                        {!hasSygnumApp && (
                          <Box
                            sx={{
                              mt: 2.5,
                              oopacity: 0.75,
                            }}
                          >
                            <TxStatusChip color="primary">Not available on this network</TxStatusChip>
                          </Box>
                        )}
                      </div>
                    }
                  />

                  <FormControlLabel
                    value={RecoveryMethod.ZkEmail}
                    control={<Radio />}
                    label={
                      <div className={css.method}>
                        <RecoveryZkEmailIcon style={{ display: 'block' }} width={45} height={45} />

                        <Typography
                          sx={{
                            fontWeight: 'bold',
                            mb: 1,
                            mt: 2,
                          }}
                        >
                          Email Recovery
                        </Typography>
                        <List className={css.checkList}>
                          <ListItem>
                            <CheckIcon />
                            Free: no fees, no gas cost
                          </ListItem>
                          <ListItem>
                            <CheckIcon />
                            Easy to use: just respond to an email to recover Safe
                          </ListItem>
                          <ListItem>
                            <CheckIcon />
                            Anonymous: thanks to zero knowledge tech the email is never exposed
                          </ListItem>
                        </List>
                      </div>
                    }
                  />
                </RadioGroup>
              )}
            />
          </FormControl>
          <Typography
            sx={{
              color: 'primary.light',
              mt: '12px',
            }}
          >
            Unhappy with the provided options?{' '}
            <Track {...RECOVERY_EVENTS.GIVE_US_FEEDBACK} label="method-modal">
              <ExternalLink href={RECOVERY_FEEDBACK_FORM}>Give us feedback</ExternalLink>
            </Track>
          </Typography>
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'center',
              mt: 3,
            }}
          >
            {[RecoveryMethod.SelfCustody, RecoveryMethod.ZkEmail].includes(currentType) ? (
              <Track {...RECOVERY_EVENTS.CONTINUE_WITH_RECOVERY} label={currentType}>
                <Button data-testid="setup-btn" variant="contained" onClick={handleSetupClick}>
                  Set up
                </Button>
              </Track>
            ) : (
              <Track {...RECOVERY_EVENTS.SYGNUM_APP} label={currentType}>
                <Link
                  href={{
                    pathname: AppRoutes.apps.open,
                    query: {
                      safe: querySafe,
                      appUrl: matchingApps?.[0]?.url,
                    },
                  }}
                  passHref
                >
                  <Button variant="contained">Open App</Button>
                </Link>
              </Track>
            )}
          </Box>
        </DialogContent>
      </Dialog>

      <ZkEmailFakeDoorModal open={openZkEmailModal} onClose={() => setOpenZkEmailModal(false)} />
    </>
  )
}
</file>

<file path="src/features/recovery/components/RecoverySettings/DelayModifierRow.tsx">
import Track from '@/components/common/Track'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { IconButton, SvgIcon, Tooltip } from '@mui/material'
import { useContext } from 'react'
import type { ReactElement } from 'react'

import { TxModalContext } from '@/components/tx-flow'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import DeleteIcon from '@/public/images/common/delete.svg'
import EditIcon from '@/public/images/common/edit.svg'
import CheckWallet from '@/components/common/CheckWallet'
import { RemoveRecoveryFlow, UpsertRecoveryFlow } from '@/components/tx-flow/flows'
import type { RecoveryStateItem } from '@/features/recovery/services/recovery-state'

export function DelayModifierRow({ delayModifier }: { delayModifier: RecoveryStateItem }): ReactElement | null {
  const { setTxFlow } = useContext(TxModalContext)
  const isOwner = useIsSafeOwner()

  if (!isOwner) {
    return null
  }

  const onEdit = () => {
    setTxFlow(<UpsertRecoveryFlow delayModifier={delayModifier} />)
  }

  const onDelete = () => {
    setTxFlow(<RemoveRecoveryFlow delayModifier={delayModifier} />)
  }

  return (
    <CheckWallet>
      {(isOk) => (
        <>
          <Tooltip title={isOk ? 'Edit recovery setup' : undefined}>
            <span>
              <Track {...RECOVERY_EVENTS.EDIT_RECOVERY}>
                <IconButton data-testid="edit-recoverer-btn" onClick={onEdit} size="small" disabled={!isOk}>
                  <SvgIcon component={EditIcon} inheritViewBox color="border" fontSize="small" />
                </IconButton>
              </Track>
            </span>
          </Tooltip>

          <Tooltip title={isOk ? 'Remove recovery' : undefined}>
            <span>
              <Track {...RECOVERY_EVENTS.REMOVE_RECOVERY}>
                <IconButton data-testid="remove-recoverer-btn" onClick={onDelete} size="small" disabled={!isOk}>
                  <SvgIcon component={DeleteIcon} inheritViewBox color="error" fontSize="small" />
                </IconButton>
              </Track>
            </span>
          </Tooltip>
        </>
      )}
    </CheckWallet>
  )
}
</file>

<file path="src/features/recovery/components/RecoverySettings/index.tsx">
import Track from '@/components/common/Track'
import { ChooseRecoveryMethodModal } from './ChooseRecoveryMethodModal'
import { RECOVERY_EVENTS } from '@/services/analytics/events/recovery'
import { Box, Button, Grid, Paper, SvgIcon, Tooltip, Typography } from '@mui/material'
import { type ReactElement, useMemo, useState } from 'react'

import ExternalLink from '@/components/common/ExternalLink'
import { DelayModifierRow } from './DelayModifierRow'
import useRecovery from '@/features/recovery/hooks/useRecovery'
import EthHashInfo from '@/components/common/EthHashInfo'
import EnhancedTable from '@/components/common/EnhancedTable'
import InfoIcon from '@/public/images/notifications/info.svg'
import CheckWallet from '@/components/common/CheckWallet'
import { getPeriod } from '@safe-global/utils/utils/date'
import { HelpCenterArticle, HelperCenterArticleTitles } from '@/config/constants'
import { TOOLTIP_TITLES } from '@/components/tx-flow/common/constants'

import tableCss from '@/components/common/EnhancedTable/styles.module.css'

enum HeadCells {
  Recoverer = 'recoverer',
  Delay = 'delay',
  Expiry = 'expiry',
  Actions = 'actions',
}

const headCells = [
  { id: HeadCells.Recoverer, label: 'Recoverer' },
  {
    id: HeadCells.Delay,
    label: (
      <>
        Review window{' '}
        <Tooltip title={TOOLTIP_TITLES.REVIEW_WINDOW}>
          <span>
            <SvgIcon
              component={InfoIcon}
              inheritViewBox
              color="border"
              fontSize="small"
              sx={{ verticalAlign: 'middle', ml: 0.5 }}
            />
          </span>
        </Tooltip>
      </>
    ),
  },
  {
    id: HeadCells.Expiry,
    label: (
      <>
        Proposal expiry{' '}
        <Tooltip title={TOOLTIP_TITLES.PROPOSAL_EXPIRY}>
          <span>
            <SvgIcon
              component={InfoIcon}
              inheritViewBox
              color="border"
              fontSize="small"
              sx={{ verticalAlign: 'middle', ml: 0.5 }}
            />
          </span>
        </Tooltip>
      </>
    ),
  },
  { id: HeadCells.Actions, label: '', sticky: true },
]

function RecoverySettings(): ReactElement {
  const [recovery] = useRecovery()

  const isRecoveryEnabled = recovery && recovery.length > 0

  const rows = useMemo(() => {
    return recovery?.flatMap((delayModifier) => {
      const { recoverers, delay, expiry } = delayModifier

      return recoverers.map((recoverer) => {
        const delaySeconds = Number(delay)
        const expirySeconds = Number(expiry)

        return {
          cells: {
            [HeadCells.Recoverer]: {
              rawValue: recoverer,
              content: <EthHashInfo address={recoverer} showCopyButton hasExplorer />,
            },
            [HeadCells.Delay]: {
              rawValue: delaySeconds,
              content: <Typography>{delaySeconds === 0 ? 'none' : getPeriod(delaySeconds)}</Typography>,
            },
            [HeadCells.Expiry]: {
              rawValue: expirySeconds,
              content: <Typography>{expirySeconds === 0 ? 'never' : getPeriod(expirySeconds)}</Typography>,
            },
            [HeadCells.Actions]: {
              rawValue: '',
              sticky: true,
              content: (
                <div className={tableCss.actions}>
                  <DelayModifierRow delayModifier={delayModifier} />
                </div>
              ),
            },
          },
        }
      })
    })
  }, [recovery])

  return (
    <Paper sx={{ p: 4 }}>
      <Grid container spacing={3}>
        <Grid item lg={4} xs={12}>
          <Box display="flex" alignItems="center" gap={1} mb={1}>
            <Typography variant="h4" fontWeight="bold">
              Account recovery
            </Typography>
          </Box>
        </Grid>

        <Grid item xs>
          <Typography mb={2}>
            {isRecoveryEnabled
              ? 'The trusted Recoverer will be able to recover your Safe Account if you ever lose access. You can change Recoverers or alter your recovery setup at any time.'
              : 'Choose a trusted Recoverer to recover your Safe Account if you ever lose access. Enabling the Account recovery module will require a transaction.'}{' '}
            <Track {...RECOVERY_EVENTS.LEARN_MORE} label="settings">
              <ExternalLink href={HelpCenterArticle.RECOVERY} title={HelperCenterArticleTitles.RECOVERY}>
                Learn more
              </ExternalLink>
            </Track>
          </Typography>

          {!isRecoveryEnabled ? (
            <SetupRecoveryButton eventLabel="settings" />
          ) : rows ? (
            <EnhancedTable rows={rows} headCells={headCells} />
          ) : null}
        </Grid>
      </Grid>
    </Paper>
  )
}

export const SetupRecoveryButton = ({ eventLabel }: { eventLabel: string }) => {
  const [open, setOpen] = useState<boolean>(false)

  return (
    <>
      <CheckWallet>
        {(isOk) => (
          <Track {...RECOVERY_EVENTS.SETUP_RECOVERY} label={eventLabel}>
            <Button
              data-testid="setup-recovery-btn"
              variant="contained"
              disabled={!isOk}
              onClick={() => setOpen(true)}
              sx={{ mt: 2 }}
            >
              Set up recovery
            </Button>
          </Track>
        )}
      </CheckWallet>

      <ChooseRecoveryMethodModal open={open} onClose={() => setOpen(false)} />
    </>
  )
}

export default RecoverySettings
</file>

<file path="src/features/recovery/components/RecoverySettings/styles.module.css">
.dialog :global .MuiPaper-root {
  max-width: 600px;
}

.dialog h2 {
  font-weight: bold;
}

.dialog :global .MuiDialogContent-root {
  border: 0;
  padding: var(--space-3);
}

.method {
  border: 2px solid var(--color-border-light);
  padding: var(--space-3);
  border-radius: 6px;
}

.buttonGroup :global .MuiRadio-root {
  display: none;
}

.buttonGroup :global .MuiRadio-root.Mui-checked + span > div {
  border-color: var(--color-primary-main);
}

.buttonGroup :global .MuiFormControlLabel-root {
  margin: 0;
  width: 100%;
}

.buttonGroup {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.buttonGroup :global .MuiFormControlLabel-root span,
.buttonGroup :global .MuiFormControlLabel-root span > div {
  height: 100%;
  width: 100%;
}

.closeIcon {
  position: absolute;
  top: var(--space-1);
  right: var(--space-1);
  color: var(--color-text-secondary);
  margin-left: auto;
}

.checkList {
  padding: 0;
}

.checkList svg {
  flex-shrink: 0;
}

.checkList li {
  padding: 0;
  gap: 8px;
  margin-bottom: var(--space-1);
}

.checkList li:last-child {
  margin-bottom: 0;
}

@media (min-width: 900px) {
  .dialog :global .MuiPaper-root {
    max-width: 1000px;
  }

  .buttonGroup :global .MuiFormControlLabel-root {
    margin: 0;
    flex: 1;
  }

  .dialog :global .MuiDialogContent-root {
    padding: var(--space-8);
  }

  .dialog h2 {
    font-size: 32px;
  }

  .buttonGroup {
    flex-wrap: nowrap;
  }

  .closeIcon {
    top: var(--space-3);
    right: var(--space-3);
  }
}
</file>

<file path="src/features/recovery/components/RecoverySettings/ZkEmailFakeDoorModal.tsx">
import { type ReactElement } from 'react'
import { Dialog, DialogContent, IconButton, Stack, Typography } from '@mui/material'
import CloseIcon from '@mui/icons-material/Close'

import RecoveryZkEmailIcon from '@/public/images/common/zkemail-logo.svg'
import css from './styles.module.css'

export function ZkEmailFakeDoorModal({ open, onClose }: { open: boolean; onClose: () => void }): ReactElement {
  return (
    <Dialog open={open} onClose={onClose} className={css.dialog}>
      <DialogContent>
        <IconButton onClick={onClose} className={css.closeIcon}>
          <CloseIcon />
        </IconButton>

        <Stack spacing={4}>
          <RecoveryZkEmailIcon style={{ display: 'block' }} width={60} height={60} />

          <Stack spacing={2}>
            <Typography variant="h2">Feature is coming soon</Typography>

            <Typography variant="body1">
              Thanks for showing interest in email recovery. We are currently measuring demand for it, so your click on
              this option made the release one step closer.
            </Typography>

            <Typography variant="body1">Stay tuned!</Typography>
          </Stack>
        </Stack>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="src/features/recovery/components/RecoverySigners/index.tsx">
import { Box, List, ListItem, ListItemIcon, ListItemText, SvgIcon, Typography } from '@mui/material'
import type { ReactElement } from 'react'

import CircleIcon from '@/public/images/common/circle.svg'
import CheckIcon from '@/public/images/common/circle-check.svg'
import EthHashInfo from '@/components/common/EthHashInfo'
import { Countdown } from '@/components/common/Countdown'
import { ExecuteRecoveryButton } from '../ExecuteRecoveryButton'
import { CancelRecoveryButton } from '../CancelRecoveryButton'
import { useRecoveryTxState } from '@/features/recovery/hooks/useRecoveryTxState'
import { formatDateTime } from '@safe-global/utils/utils/date'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

import txSignersCss from '@/components/transactions/TxSigners/styles.module.css'

export function RecoverySigners({ item }: { item: RecoveryQueueItem }): ReactElement {
  const { isExecutable, isExpired, isNext, remainingSeconds } = useRecoveryTxState(item)

  const desc = isExecutable ? (
    item.expiresAt !== null ? (
      <>
        The recovery proposal can be executed{' '}
        <Typography
          sx={{
            color: 'primary.main',
          }}
        >
          until {formatDateTime(Number(item.expiresAt))}.
        </Typography>
      </>
    ) : (
      'The recovery proposal can be executed now.'
    )
  ) : isExpired ? (
    'The recovery proposal has expired and needs to be cancelled before a new one can be created.'
  ) : (
    'The recovery proposal can be executed after the review window has passed:'
  )

  return (
    <>
      <List className={txSignersCss.signers}>
        <ListItem>
          <ListItemIcon>
            <SvgIcon
              component={CheckIcon}
              inheritViewBox
              className={txSignersCss.icon}
              sx={{
                '& path:last-of-type': { fill: ({ palette }) => palette.background.paper },
              }}
            />
          </ListItemIcon>
          <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>Created</ListItemText>
        </ListItem>
        <ListItem sx={{ py: 0, pb: 1, ml: 4 }}>
          <EthHashInfo address={item.executor} hasExplorer showCopyButton />
        </ListItem>
        <ListItem sx={{ py: 0 }}>
          <ListItemIcon>
            <SvgIcon
              component={CircleIcon}
              inheritViewBox
              className={txSignersCss.icon}
              sx={{ color: ({ palette }) => palette.border.main }}
            />
          </ListItemIcon>
          <ListItemText primaryTypographyProps={{ fontWeight: 700 }}>Can be executed</ListItemText>
        </ListItem>
      </List>
      <Box className={txSignersCss.listFooter}>
        <Typography sx={({ palette }) => ({ color: palette.border.main, mb: 1 })}>{desc}</Typography>

        {isNext && <Countdown seconds={remainingSeconds} />}
      </Box>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: 1,
          mt: 2,
        }}
      >
        <ExecuteRecoveryButton recovery={item} />
        <CancelRecoveryButton recovery={item} />
      </Box>
    </>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryStatus/index.tsx">
import { CircularProgress, SvgIcon } from '@mui/material'
import type { ReactElement } from 'react'

import ClockIcon from '@/public/images/common/clock.svg'
import { useRecoveryTxState } from '@/features/recovery/hooks/useRecoveryTxState'
import { RecoveryEvent } from '@/features/recovery/services/recoveryEvents'
import store from '../RecoveryContext'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import TxStatusChip from '@/components/transactions/TxStatusChip'

const STATUS_LABELS: Partial<Record<RecoveryEvent, string>> = {
  [RecoveryEvent.PROCESSING]: 'Processing',
  [RecoveryEvent.PROCESSED]: 'Loading',
}

export const RecoveryStatus = ({ recovery }: { recovery: RecoveryQueueItem }): ReactElement => {
  const { isExecutable, isExpired } = useRecoveryTxState(recovery)
  const pending = store.useStore()?.pending

  const pendingTxStatus = pending?.[recovery.args.txHash]?.status

  const status = pendingTxStatus ? (
    <>
      <CircularProgress size={14} color="inherit" />
      {STATUS_LABELS[pendingTxStatus]}
    </>
  ) : isExecutable ? (
    'Awaiting execution'
  ) : isExpired ? (
    'Expired'
  ) : (
    <>
      <SvgIcon component={ClockIcon} inheritViewBox fontSize="inherit" />
      Pending
    </>
  )

  return <TxStatusChip color={isExpired ? 'error' : 'warning'}>{status}</TxStatusChip>
}
</file>

<file path="src/features/recovery/components/RecoverySummary/index.tsx">
import { Box } from '@mui/material'
import type { ReactElement } from 'react'

import { RecoveryType } from '../RecoveryType'
import { RecoveryInfo } from '../RecoveryInfo'
import { RecoveryStatus } from '../RecoveryStatus'
import { ExecuteRecoveryButton } from '../ExecuteRecoveryButton'
import useWallet from '@/hooks/wallets/useWallet'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import css from '@/components/transactions/TxSummary/styles.module.css'
import { useRecoveryTxState } from '@/features/recovery/hooks/useRecoveryTxState'
import DateTime from '@/components/common/DateTime'

export function RecoverySummary({ item }: { item: RecoveryQueueItem }): ReactElement {
  const wallet = useWallet()
  const { isExecutable, isPending } = useRecoveryTxState(item)
  const { isMalicious } = item

  return (
    <Box className={css.gridContainer}>
      <Box gridArea="type">
        <RecoveryType isMalicious={isMalicious} />
      </Box>

      <Box gridArea="info">
        <RecoveryInfo isMalicious={isMalicious} />
      </Box>

      <Box gridArea="date" data-testid="tx-date" className={css.date}>
        <DateTime value={Number(item.timestamp)} />
      </Box>

      {!isExecutable || isPending ? (
        <Box gridArea="status">
          <RecoveryStatus recovery={item} />
        </Box>
      ) : (
        <Box gridArea="actions" mr={2} display="flex" justifyContent="center">
          {!isMalicious && wallet && <ExecuteRecoveryButton recovery={item} compact />}
        </Box>
      )}
    </Box>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryType/index.tsx">
import { Box, SvgIcon, Typography } from '@mui/material'
import type { ReactElement } from 'react'

import RecoveryPlusIcon from '@/public/images/common/recovery-plus.svg'

import txTypeCss from '@/components/transactions/TxType/styles.module.css'

export function RecoveryType({ isMalicious }: { isMalicious: boolean }): ReactElement {
  return (
    <Box className={txTypeCss.txType}>
      <SvgIcon
        component={RecoveryPlusIcon}
        inheritViewBox
        fontSize="inherit"
        sx={{ '& path': { fill: ({ palette }) => palette.warning.main } }}
      />
      <Typography color={isMalicious ? 'error.main' : undefined}>
        {isMalicious ? 'Malicious transaction' : 'Account recovery'}
      </Typography>
    </Box>
  )
}
</file>

<file path="src/features/recovery/components/RecoveryValidationErrors/index.tsx">
import { useContext } from 'react'
import type { ReactElement } from 'react'

import ErrorMessage from '@/components/tx/ErrorMessage'
import {
  useIsValidRecoveryExecuteNextTx,
  useIsValidRecoverySkipExpired,
} from '@/features/recovery/hooks/useIsValidRecoveryExecution'
import { RecoveryListItemContext } from '../RecoveryListItem/RecoveryListItemContext'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function RecoveryValidationErrors({ item }: { item: RecoveryQueueItem }): ReactElement | null {
  const { submitError } = useContext(RecoveryListItemContext)
  const [, executeNextTxError] = useIsValidRecoveryExecuteNextTx(item)
  const [, executeSkipExpiredError] = useIsValidRecoverySkipExpired(item)

  // There can never be both errors as they are dependent on validity/expiration
  const validationError = executeNextTxError ?? executeSkipExpiredError

  if (!submitError && !validationError) {
    return null
  }

  return (
    <>
      {validationError && (
        <ErrorMessage error={validationError}>
          This transaction will most likely fail. To save gas costs, avoid executing the transaction.
        </ErrorMessage>
      )}

      {submitError && (
        <ErrorMessage error={submitError}>Error submitting the transaction. Please try again.</ErrorMessage>
      )}
    </>
  )
}
</file>

<file path="src/features/recovery/hooks/useIsRecoverer.ts">
import { selectDelayModifierByRecoverer } from '@/features/recovery/services/selectors'
import useWallet from '@/hooks/wallets/useWallet'
import useRecovery from '@/features/recovery/hooks/useRecovery'

export function useIsRecoverer() {
  const [recovery] = useRecovery()
  const wallet = useWallet()
  return Boolean(wallet?.address && recovery && selectDelayModifierByRecoverer(recovery, wallet.address))
}
</file>

<file path="src/features/recovery/hooks/useIsRecoveryEnabled.ts">
import useRecovery from '@/features/recovery/hooks/useRecovery'

export function useIsRecoveryEnabled(): boolean {
  const [recovery] = useRecovery()
  return !!recovery && recovery.length > 0
}
</file>

<file path="src/features/recovery/hooks/useIsRecoverySupported.ts">
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

export function useIsRecoverySupported(): boolean {
  return useHasFeature(FEATURES.RECOVERY) ?? false
}
</file>

<file path="src/features/recovery/hooks/useIsValidRecoveryExecution.ts">
import { getModuleInstance, KnownContracts } from '@gnosis.pm/zodiac'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'

import useWallet from '../../../hooks/wallets/useWallet'
import { useWeb3ReadOnly } from '../../../hooks/wallets/web3'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '../../../hooks/useSafeInfo'
import { getPatchedSignerProvider } from '../../../hooks/useIsValidExecution'
import { useRecoveryTxState } from './useRecoveryTxState'
import { useIsRecoverer } from './useIsRecoverer'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function useIsValidRecoveryExecTransactionFromModule(
  delayModifierAddress?: string,
  safeTx?: SafeTransaction,
): AsyncResult<boolean> {
  const wallet = useWallet()
  const { safe } = useSafeInfo()
  const web3ReadOnly = useWeb3ReadOnly()
  const isRecoverer = useIsRecoverer()

  return useAsync(async () => {
    if (!isRecoverer || !safeTx || !wallet || !web3ReadOnly || !delayModifierAddress) {
      return
    }

    const provider = getPatchedSignerProvider(wallet, safe.chainId, web3ReadOnly)
    const delayModifier = getModuleInstance(KnownContracts.DELAY, delayModifierAddress, provider)

    const signer = await provider.getSigner()
    const contract = delayModifier.connect(signer)

    return contract.execTransactionFromModule.staticCall(
      safeTx.data.to,
      safeTx.data.value,
      safeTx.data.data,
      safeTx.data.operation,
    )
  }, [isRecoverer, safeTx, wallet, web3ReadOnly, safe.chainId, delayModifierAddress])
}

export function useIsValidRecoveryExecuteNextTx(recovery: RecoveryQueueItem): AsyncResult<boolean> {
  const wallet = useWallet()
  const { safe } = useSafeInfo()
  const web3ReadOnly = useWeb3ReadOnly()
  const { isExecutable } = useRecoveryTxState(recovery)

  return useAsync(async () => {
    if (!isExecutable || !wallet?.address || !web3ReadOnly) {
      return
    }

    const provider = getPatchedSignerProvider(wallet, safe.chainId, web3ReadOnly)
    const delayModifier = getModuleInstance(KnownContracts.DELAY, recovery.address, provider)

    const signer = await provider.getSigner()
    const contract = delayModifier.connect(signer)

    const { to, value, data, operation } = recovery.args

    await contract.executeNextTx.staticCall(to, value, data, operation)

    return true
  }, [isExecutable, recovery.address, recovery.args, safe.chainId, wallet, web3ReadOnly])
}

export function useIsValidRecoverySkipExpired(recovery: RecoveryQueueItem): AsyncResult<boolean> {
  const wallet = useWallet()
  const { safe } = useSafeInfo()
  const web3ReadOnly = useWeb3ReadOnly()
  const { isExpired } = useRecoveryTxState(recovery)

  return useAsync(async () => {
    if (!isExpired || !wallet?.address || !web3ReadOnly) {
      return
    }

    const provider = getPatchedSignerProvider(wallet, safe.chainId, web3ReadOnly)
    const delayModifier = getModuleInstance(KnownContracts.DELAY, recovery.address, provider)

    const signer = await provider.getSigner()
    const contract = delayModifier.connect(signer)

    await contract.skipExpired.staticCall()

    return true
  }, [isExpired, recovery.address, safe.chainId, wallet, web3ReadOnly])
}
</file>

<file path="src/features/recovery/hooks/useRecovery.ts">
import store, { type RecoveryContextType } from '../components/RecoveryContext'

function useRecovery(): RecoveryContextType['state'] {
  return store.useStore()?.state || [undefined, undefined, false]
}

export default useRecovery
</file>

<file path="src/features/recovery/hooks/useRecoveryQueue.ts">
import { selectRecoveryQueues } from '@/features/recovery/services/selectors'
import useRecovery from '@/features/recovery/hooks/useRecovery'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function useRecoveryQueue(): Array<RecoveryQueueItem> {
  const [recovery] = useRecovery()
  const queue = recovery && selectRecoveryQueues(recovery)
  return queue ?? []
}
</file>

<file path="src/features/recovery/hooks/useRecoveryTxNotification.ts">
import { useEffect } from 'react'

import { formatError } from '@safe-global/utils/utils/formatters'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'
import useSafeAddress from '../../../hooks/useSafeAddress'
import { RecoveryEvent, RecoveryTxType, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'
import { useCurrentChain } from '../../../hooks/useChains'
import { isWalletRejection } from '@/utils/wallets'
import { getExplorerLink } from '@safe-global/utils/utils/gateway'

const SUCCESS_EVENTS = [
  RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET,
  RecoveryEvent.PROCESSED,
  RecoveryEvent.SUCCESS,
]

const RecoveryTxNotifications = {
  [RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET]: 'Confirm the execution in your wallet.',
  [RecoveryEvent.PROCESSING]: 'Validating...',
  [RecoveryEvent.PROCESSED]: 'Successfully validated. Loading...',
  [RecoveryEvent.REVERTED]: 'Reverted. Please check your gas settings.',
  [RecoveryEvent.FAILED]: 'Failed.',
  [RecoveryEvent.SUCCESS]: 'Successfully executed.',
}

const RecoveryTxNotificationTitles = {
  [RecoveryTxType.PROPOSAL]: 'Account recovery proposal',
  [RecoveryTxType.EXECUTION]: 'Account recovery',
  [RecoveryTxType.SKIP_EXPIRED]: 'Account recovery cancellation',
}

export function useRecoveryTxNotifications(): void {
  const dispatch = useAppDispatch()
  const chain = useCurrentChain()
  const safeAddress = useSafeAddress()

  /**
   * Show notifications of a recovery transaction's lifecycle
   */

  useEffect(() => {
    if (!chain?.blockExplorerUriTemplate) {
      return
    }

    const entries = Object.entries(RecoveryTxNotifications) as Array<[keyof typeof RecoveryTxNotifications, string]>

    const unsubFns = entries.map(([event, notification]) =>
      recoverySubscribe(event, async (detail) => {
        const isSuccess = SUCCESS_EVENTS.includes(event)
        const isError = 'error' in detail
        if (isError && isWalletRejection(detail.error)) return

        const txHash = 'txHash' in detail ? detail.txHash : undefined
        const recoveryTxHash = 'recoveryTxHash' in detail ? detail.recoveryTxHash : undefined
        const groupKey = txHash || recoveryTxHash || ''

        const title = RecoveryTxNotificationTitles[detail.txType]
        const message = isError ? `${notification} ${formatError(detail.error)}` : notification

        const link = txHash ? getExplorerLink(txHash, chain.blockExplorerUriTemplate) : undefined

        dispatch(
          showNotification({
            title,
            message,
            detailedMessage: isError ? detail.error.message : undefined,
            groupKey,
            variant: isError ? 'error' : isSuccess ? 'success' : 'info',
            link,
          }),
        )
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [dispatch, safeAddress, chain?.blockExplorerUriTemplate])
}
</file>

<file path="src/features/recovery/hooks/useRecoveryTxState.ts">
import { useClock } from '../../../hooks/useClock'
import { selectDelayModifierByTxHash } from '@/features/recovery/services/selectors'
import recoveryStore from '@/features/recovery/components/RecoveryContext'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

export function useRecoveryTxState({ validFrom, expiresAt, transactionHash, args, address }: RecoveryQueueItem): {
  isNext: boolean
  isExecutable: boolean
  isExpired: boolean
  isPending: boolean
  remainingSeconds: number
} {
  const { state, pending } = recoveryStore.useStore() || {}
  const recovery = state?.[0]
  const delayModifier = recovery && selectDelayModifierByTxHash(recovery, transactionHash)

  // We don't display seconds in the interface, so we can use a 60s interval
  const timestamp = useClock(60_000)
  const remainingMs = Number(validFrom) - timestamp

  const isValid = remainingMs <= 0
  const isExpired = expiresAt !== null ? Number(expiresAt) <= Date.now() : false

  // Check module address in case multiple Delay Modifiers enabled
  const isNext =
    !delayModifier ||
    (sameAddress(delayModifier.address, address) && BigInt(args.queueNonce) === BigInt(delayModifier.txNonce))
  const isExecutable = isNext && isValid && !isExpired
  const isPending = !!pending?.[args.txHash]

  const remainingSeconds = isValid ? 0 : Math.ceil(remainingMs / 1_000)

  return { isNext, isExecutable, isExpired, remainingSeconds, isPending }
}
</file>

<file path="src/features/recovery/services/delay-modifier.ts">
import { ContractVersions, getModuleInstance, KnownContracts } from '@gnosis.pm/zodiac'
import { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import type { Delay, SupportedNetworks } from '@gnosis.pm/zodiac'
import { type JsonRpcProvider, isAddress } from 'ethers'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'

import { sameAddress } from '@safe-global/utils/utils/addresses'
import { getGenericProxyMasterCopy, getGnosisProxyMasterCopy, isGenericProxy, isGnosisProxy } from './proxies'
import { MAX_RECOVERER_PAGE_SIZE } from './recovery-state'

export async function _getZodiacContract(
  chainId: string,
  moduleAddress: string,
  provider: JsonRpcProvider,
): Promise<string | undefined> {
  if (!isAddress(moduleAddress)) return

  const bytecode = await provider.getCode(moduleAddress)

  if (isGenericProxy(bytecode)) {
    const masterCopy = getGenericProxyMasterCopy(bytecode)
    return await _getZodiacContract(chainId, masterCopy, provider)
  }

  if (isGnosisProxy(bytecode)) {
    const masterCopy = await getGnosisProxyMasterCopy(moduleAddress, provider)
    return await _getZodiacContract(chainId, masterCopy, provider)
  }

  const zodiacChainContracts = ContractVersions[Number(chainId) as SupportedNetworks]
  const zodiacContract = Object.entries(zodiacChainContracts).find(([, addresses]) => {
    return Object.values(addresses).some((address) => {
      return sameAddress(address, moduleAddress)
    })
  })

  return zodiacContract?.[0]
}

async function isOfficialDelayModifier(chainId: string, moduleAddress: string, provider: JsonRpcProvider) {
  const zodiacContract = await _getZodiacContract(chainId, moduleAddress, provider)
  return zodiacContract === KnownContracts.DELAY
}

export async function _isOfficialRecoveryDelayModifier(
  chainId: string,
  delayModifier: Delay,
  provider: JsonRpcProvider,
) {
  // Zodiac-deployed Delay Modifiers only have other Zodiac contracts added as modules
  // If Delay Modifier only has non-Zodiac contracts as modules, it's a recovery-specific Delay Modifier
  const [modules] = await delayModifier.getModulesPaginated(SENTINEL_ADDRESS, MAX_RECOVERER_PAGE_SIZE)

  if (modules.length === 0) {
    return false
  }

  const types = await Promise.all(modules.map((module) => _getZodiacContract(chainId, module, provider)))

  const knownContracts = Object.values(KnownContracts)
  return types.every((type) => !knownContracts.includes(type as KnownContracts))
}

export async function getRecoveryDelayModifiers(
  chainId: string,
  modules: SafeState['modules'],
  provider: JsonRpcProvider,
): Promise<Array<Delay>> {
  if (!modules) {
    return []
  }

  const delayModifiers = await Promise.all(
    modules.map(async ({ value }) => {
      const isDelayModifier = await isOfficialDelayModifier(chainId, value, provider)
      return isDelayModifier && getModuleInstance(KnownContracts.DELAY, value, provider)
    }),
  ).then((instances) => instances.filter(Boolean) as Array<Delay>)

  const recoveryDelayModifiers = await Promise.all(
    delayModifiers.map(async (delayModifier) => {
      // TODO: Fetches "recoverers" of Delay Modifier, but we later fetch them again
      // in useRecoveryState. Could optimise this by returning the recoverers here
      const isRecoveryDelayModifier = await _isOfficialRecoveryDelayModifier(chainId, delayModifier, provider)
      return isRecoveryDelayModifier && delayModifier
    }),
  ).then((instances) => instances.filter(Boolean) as Array<Delay>)

  return recoveryDelayModifiers
}
</file>

<file path="src/features/recovery/services/proxies.ts">
import type { JsonRpcProvider } from 'ethers'
import { Contract } from 'ethers'

// zodiac-safe-app used as reference for proxy detection
// @see https://github.com/gnosis/zodiac-safe-app/blob/e5d6d3d251d128245104ddc638e26d290689bb14/packages/app/src/utils/modulesValidation.ts

export function isGenericProxy(bytecode: string): boolean {
  if (bytecode.length !== 92) {
    return false
  }

  return bytecode.startsWith('0x363d3d373d3d3d363d73') && bytecode.endsWith('5af43d82803e903d91602b57fd5bf3')
}

export function getGenericProxyMasterCopy(bytecode: string): string {
  return '0x' + bytecode.slice(22, 62)
}

export function isGnosisProxy(bytecode: string): boolean {
  return (
    bytecode.toLowerCase() ===
    '0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032'
  )
}

export async function getGnosisProxyMasterCopy(address: string, provider: JsonRpcProvider): Promise<string> {
  const gnosisProxyAbi = ['function masterCopy() external view returns (address)']
  const gnosisProxyContract = new Contract(address, gnosisProxyAbi, provider)

  const [masterCopy] = await gnosisProxyContract.masterCopy()

  return masterCopy
}
</file>

<file path="src/features/recovery/services/recovery-sender.ts">
import { getModuleInstance, KnownContracts } from '@gnosis.pm/zodiac'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import type { TransactionAddedEvent } from '@gnosis.pm/zodiac/dist/cjs/types/Delay'
import type { Eip1193Provider, TransactionResponse } from 'ethers'

import { didReprice, didRevert } from '@/utils/ethers-utils'
import { recoveryDispatch, RecoveryEvent, RecoveryTxType } from './recoveryEvents'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { getUncheckedSigner } from '../../../services/tx/tx-sender/sdk'
import { isSmartContractWallet } from '@/utils/wallets'

async function getDelayModifierContract({
  provider,
  chainId,
  delayModifierAddress,
  signerAddress,
}: {
  provider: Eip1193Provider
  chainId: string
  delayModifierAddress: string
  signerAddress: string
}) {
  const isSmartContract = await isSmartContractWallet(chainId, signerAddress)

  const signer = await getUncheckedSigner(provider)
  const delayModifier = getModuleInstance(KnownContracts.DELAY, delayModifierAddress, signer).connect(signer)

  return {
    isUnchecked: isSmartContract,
    delayModifier,
  }
}

function waitForRecoveryTx({
  tx,
  ...payload
}: {
  moduleAddress: string
  recoveryTxHash: string
  tx: TransactionResponse
  txType: RecoveryTxType
}) {
  const event = {
    ...payload,
    txHash: tx.hash,
  }

  recoveryDispatch(RecoveryEvent.PROCESSING, event)
  tx.wait()
    .then((receipt) => {
      if (didRevert(receipt!)) {
        recoveryDispatch(RecoveryEvent.REVERTED, {
          ...event,
          error: new Error('Transaction reverted by EVM'),
        })
      } else {
        recoveryDispatch(RecoveryEvent.PROCESSED, event)
      }
    })
    .catch((error) => {
      if (didReprice(error)) {
        recoveryDispatch(RecoveryEvent.PROCESSED, event)
      } else {
        recoveryDispatch(RecoveryEvent.FAILED, {
          ...event,
          error: asError(error),
        })
      }
    })
}

export async function dispatchRecoveryProposal({
  provider,
  safe,
  safeTx,
  delayModifierAddress,
  signerAddress,
}: {
  provider: Eip1193Provider
  safe: SafeState
  safeTx: SafeTransaction
  delayModifierAddress: string
  signerAddress: string
}) {
  const { delayModifier, isUnchecked } = await getDelayModifierContract({
    provider,
    chainId: safe.chainId,
    delayModifierAddress,
    signerAddress,
  })

  const txType = RecoveryTxType.PROPOSAL
  let recoveryTxHash: string | undefined

  try {
    // Get recovery tx hash as a form of ID for FAILED event in event bus
    recoveryTxHash = await delayModifier.getTransactionHash(
      safeTx.data.to,
      safeTx.data.value,
      safeTx.data.data,
      safeTx.data.operation,
    )

    const tx = await delayModifier.execTransactionFromModule(
      safeTx.data.to,
      safeTx.data.value,
      safeTx.data.data,
      safeTx.data.operation,
    )

    if (isUnchecked) {
      recoveryDispatch(RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET, {
        moduleAddress: delayModifierAddress,
        recoveryTxHash,
        txType,
        txHash: tx.hash,
      })
    } else {
      waitForRecoveryTx({
        moduleAddress: delayModifierAddress,
        recoveryTxHash,
        txType,
        tx,
      })
    }
  } catch (error) {
    recoveryDispatch(RecoveryEvent.FAILED, {
      moduleAddress: delayModifierAddress,
      recoveryTxHash,
      txType,
      error: asError(error),
    })

    throw error
  }
}

export async function dispatchRecoveryExecution({
  provider,
  chainId,
  args,
  delayModifierAddress,
  signerAddress,
}: {
  provider: Eip1193Provider
  chainId: string
  args: TransactionAddedEvent.Log['args']
  delayModifierAddress: string
  signerAddress: string
}) {
  const { delayModifier, isUnchecked } = await getDelayModifierContract({
    provider,
    chainId,
    delayModifierAddress,
    signerAddress,
  })

  const txType = RecoveryTxType.EXECUTION

  try {
    const tx = await delayModifier.executeNextTx(args.to, args.value, args.data, args.operation)

    if (isUnchecked) {
      recoveryDispatch(RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET, {
        moduleAddress: delayModifierAddress,
        recoveryTxHash: args.txHash,
        txType,
        txHash: tx.hash,
      })
    } else {
      waitForRecoveryTx({
        moduleAddress: delayModifierAddress,
        recoveryTxHash: args.txHash,
        txType,
        tx,
      })
    }
  } catch (error) {
    recoveryDispatch(RecoveryEvent.FAILED, {
      moduleAddress: delayModifierAddress,
      recoveryTxHash: args.txHash,
      txType,
      error: asError(error),
    })

    throw error
  }
}

export async function dispatchRecoverySkipExpired({
  provider,
  chainId,
  delayModifierAddress,
  recoveryTxHash,
  signerAddress,
}: {
  provider: Eip1193Provider
  chainId: string
  delayModifierAddress: string
  recoveryTxHash: string
  signerAddress: string
}) {
  const { delayModifier, isUnchecked } = await getDelayModifierContract({
    provider,
    chainId,
    delayModifierAddress,
    signerAddress,
  })

  const txType = RecoveryTxType.SKIP_EXPIRED

  try {
    const tx = await delayModifier.skipExpired()

    if (isUnchecked) {
      recoveryDispatch(RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET, {
        moduleAddress: delayModifierAddress,
        recoveryTxHash,
        txType,
        txHash: tx.hash,
      })
    } else {
      waitForRecoveryTx({
        moduleAddress: delayModifierAddress,
        recoveryTxHash,
        txType,
        tx,
      })
    }
  } catch (error) {
    recoveryDispatch(RecoveryEvent.FAILED, {
      moduleAddress: delayModifierAddress,
      recoveryTxHash,
      txType,
      error: asError(error),
    })

    throw error
  }
}
</file>

<file path="src/features/recovery/services/recovery-state.ts">
import { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import memoize from 'lodash/memoize'
import { getMultiSendCallOnlyDeployment } from '@safe-global/safe-deployments'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import type { Delay } from '@gnosis.pm/zodiac'
import type { TransactionAddedEvent } from '@gnosis.pm/zodiac/dist/cjs/types/Delay'
import { toBeHex, type JsonRpcProvider, type TransactionReceipt } from 'ethers'
import { trimTrailingSlash } from '@/utils/url'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { isMultiSendCalldata } from '@/utils/transaction-calldata'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'

export const MAX_RECOVERER_PAGE_SIZE = 100

type AddedEvent = TransactionAddedEvent.Log
export type RecoveryQueueItem = AddedEvent & {
  timestamp: bigint
  validFrom: bigint
  expiresAt: bigint | null
  isMalicious: boolean
  executor: string
}

export type RecoveryStateItem = {
  address: string
  recoverers: Array<string>
  expiry: bigint
  delay: bigint
  txNonce: bigint
  queueNonce: bigint
  queue: Array<RecoveryQueueItem>
}

export type RecoveryState = Array<RecoveryStateItem>

export function _isMaliciousRecovery({
  chainId,
  version,
  safeAddress,
  transaction,
}: {
  chainId: string
  version: SafeState['version']
  safeAddress: string
  transaction: Pick<AddedEvent['args'], 'to' | 'data'>
}) {
  const BASE_MULTI_SEND_CALL_ONLY_VERSION = '1.3.0'

  const isMultiSend = isMultiSendCalldata(transaction.data)
  const transactions = isMultiSend ? decodeMultiSendData(transaction.data) : [transaction]

  if (!isMultiSend) {
    // Calling the Safe itself
    return !sameAddress(transaction.to, safeAddress)
  }

  const multiSendDeployment =
    getMultiSendCallOnlyDeployment({ network: chainId, version: version ?? undefined }) ??
    getMultiSendCallOnlyDeployment({ network: chainId, version: BASE_MULTI_SEND_CALL_ONLY_VERSION })

  if (!multiSendDeployment) {
    return true
  }

  const multiSendAddress = multiSendDeployment.networkAddresses[chainId] ?? multiSendDeployment.defaultAddress

  // Calling official MultiSend contract with a batch of transactions to the Safe itself
  return (
    !sameAddress(transaction.to, multiSendAddress) ||
    transactions.some((transaction) => !sameAddress(transaction.to, safeAddress))
  )
}

export const _getRecoveryQueueItemTimestamps = async ({
  delayModifier,
  transactionAdded,
  delay,
  expiry,
}: {
  delayModifier: Delay
  transactionAdded: AddedEvent
  delay: bigint
  expiry: bigint
}): Promise<Pick<RecoveryQueueItem, 'timestamp' | 'validFrom' | 'expiresAt'>> => {
  const timestamp = BigInt(await delayModifier.txCreatedAt(transactionAdded.args.queueNonce))
  const validFrom = timestamp + delay
  const expiresAt =
    expiry === BigInt(0)
      ? null // Never expires
      : (validFrom + expiry) * BigInt(1000)

  return {
    timestamp: timestamp * BigInt(1000),
    validFrom: validFrom * BigInt(1000),
    expiresAt,
  }
}

export const _getSafeCreationReceipt = memoize(
  async ({
    transactionService,
    safeAddress,
    provider,
  }: {
    transactionService: string
    safeAddress: string
    provider: JsonRpcProvider
  }): Promise<TransactionReceipt | null> => {
    const url = `${trimTrailingSlash(transactionService)}/api/v1/safes/${safeAddress}/creation/`

    const { transactionHash } = await fetch(url).then((res) => {
      if (res.ok && res.status === 200) {
        return res.json() as Promise<{ transactionHash: string } & unknown>
      } else {
        throw new Error('Error fetching Safe creation details')
      }
    })

    return provider.getTransactionReceipt(transactionHash)
  },
  ({ transactionService, safeAddress }) => transactionService + safeAddress,
)

const queryAddedTransactions = async (
  delayModifier: Delay,
  queueNonce: bigint,
  txNonce: bigint,
  transactionService: string,
  provider: JsonRpcProvider,
  safeAddress: string,
) => {
  if (queueNonce === txNonce) {
    // There are no queued txs
    return []
  }

  // We filter for the valid nonces while fetching the event logs.
  // The nonce has to be one between the current queueNonce and the txNonce.
  const diff = queueNonce - txNonce
  const queryNonces = Array.from({ length: Number(diff) }, (_, idx) => {
    return toBeHex(BigInt(txNonce + BigInt(idx)), 32)
  })

  const transactionAddedFilter = delayModifier.filters.TransactionAdded() as TransactionAddedEvent.Filter

  const topics = await transactionAddedFilter.getTopicFilter()
  topics[1] = queryNonces

  const { blockNumber } = (await _getSafeCreationReceipt({ transactionService, provider, safeAddress }))!

  // @ts-expect-error
  return await delayModifier.queryFilter(topics, blockNumber, 'latest')
}

const getRecoveryQueueItem = async ({
  delayModifier,
  transactionAdded,
  delay,
  expiry,
  provider,
  chainId,
  version,
  safeAddress,
}: {
  delayModifier: Delay
  transactionAdded: AddedEvent
  delay: bigint
  expiry: bigint
  provider: JsonRpcProvider
  chainId: string
  version: SafeState['version']
  safeAddress: string
}): Promise<RecoveryQueueItem> => {
  const [timestamps, receipt] = await Promise.all([
    _getRecoveryQueueItemTimestamps({
      delayModifier,
      transactionAdded,
      delay,
      expiry,
    }),
    provider.getTransactionReceipt(transactionAdded.transactionHash),
  ])

  const isMalicious = _isMaliciousRecovery({
    chainId,
    version,
    safeAddress,
    transaction: transactionAdded.args,
  })

  return {
    ...transactionAdded,
    ...timestamps,
    isMalicious,
    executor: receipt!.from,
  }
}

export const _getRecoveryStateItem = async ({
  delayModifier,
  transactionService,
  safeAddress,
  provider,
  chainId,
  version,
}: {
  delayModifier: Delay
  transactionService: string
  safeAddress: string
  provider: JsonRpcProvider
  chainId: string
  version: SafeState['version']
}): Promise<RecoveryStateItem> => {
  const [[recoverers], expiry, delay, txNonce, queueNonce] = await Promise.all([
    delayModifier.getModulesPaginated(SENTINEL_ADDRESS, MAX_RECOVERER_PAGE_SIZE),
    delayModifier.txExpiration(),
    delayModifier.txCooldown(),
    delayModifier.txNonce(),
    delayModifier.queueNonce(),
  ])

  const queuedTransactionsAdded = await queryAddedTransactions(
    delayModifier,
    BigInt(queueNonce),
    BigInt(txNonce),
    transactionService,
    provider,
    safeAddress,
  )

  const queue = await Promise.all(
    queuedTransactionsAdded.map((transactionAdded) => {
      return getRecoveryQueueItem({
        delayModifier,
        transactionAdded,
        delay: BigInt(delay),
        expiry: BigInt(expiry),
        provider,
        chainId,
        version,
        safeAddress,
      })
    }),
  )

  return {
    address: await delayModifier.getAddress(),
    recoverers,
    expiry: BigInt(expiry),
    delay: BigInt(delay),
    txNonce: BigInt(txNonce),
    queueNonce: BigInt(queueNonce),
    queue: queue.filter((item) => !item.removed),
  }
}

export function getRecoveryState({
  delayModifiers,
  ...rest
}: {
  delayModifiers: Array<Delay>
  transactionService: string
  safeAddress: string
  provider: JsonRpcProvider
  chainId: string
  version: SafeState['version']
}): Promise<RecoveryState> {
  return Promise.all(delayModifiers.map((delayModifier) => _getRecoveryStateItem({ delayModifier, ...rest })))
}
</file>

<file path="src/features/recovery/services/recoveryEvents.ts">
import EventBus from '../../../services/EventBus'

export enum RecoveryEvent {
  PROCESSING_BY_SMART_CONTRACT_WALLET = 'PROCESSING_BY_SMART_CONTRACT_WALLET',
  PROCESSING = 'PROCESSING', // Submitted to the blockchain
  PROCESSED = 'PROCESSED', // Executed on the blockchain
  SUCCESS = 'SUCCESS', // Loaded from the blockchain
  FAILED = 'FAILED',
  REVERTED = 'REVERTED',
}

export enum RecoveryTxType {
  PROPOSAL = 'PROPOSAL',
  EXECUTION = 'EXECUTION',
  SKIP_EXPIRED = 'SKIP_EXPIRED',
}

export interface RecoveryEvents {
  [RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET]: {
    moduleAddress: string
    txHash: string
    recoveryTxHash: string
    txType: RecoveryTxType
  }
  [RecoveryEvent.PROCESSING]: {
    moduleAddress: string
    txHash: string
    recoveryTxHash: string
    txType: RecoveryTxType
  }
  [RecoveryEvent.REVERTED]: {
    moduleAddress: string
    txHash: string
    recoveryTxHash: string
    error: Error
    txType: RecoveryTxType
  }
  [RecoveryEvent.PROCESSED]: {
    moduleAddress: string
    txHash: string
    recoveryTxHash: string
    txType: RecoveryTxType
  }
  [RecoveryEvent.FAILED]: {
    moduleAddress: string
    txHash?: string
    recoveryTxHash?: string
    error: Error
    txType: RecoveryTxType
  }
  [RecoveryEvent.SUCCESS]: {
    recoveryTxHash: string
    txType: RecoveryTxType
  }
}

const recoveryEventBus = new EventBus<RecoveryEvents>()

export const recoveryDispatch = recoveryEventBus.dispatch.bind(recoveryEventBus)

export const recoverySubscribe = recoveryEventBus.subscribe.bind(recoveryEventBus)

// Log all events
Object.values(RecoveryEvent).forEach((event: RecoveryEvent) => {
  recoverySubscribe<RecoveryEvent>(event, (detail) => {
    console.info(`Recovery ${event} event received`, detail)
  })
})
</file>

<file path="src/features/recovery/services/selectors.ts">
import { createSelector } from '@reduxjs/toolkit'

import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { RecoveryState } from '@/features/recovery/services/recovery-state'

// Identity function to help with type inference
function selectRecovery<T extends RecoveryState | undefined>(state: T): T {
  return state
}

export const selectDelayModifierByRecoverer = createSelector(
  [selectRecovery, (_: RecoveryState, walletAddress: string) => walletAddress],
  (recovery, walletAddress) => {
    return recovery?.find(({ recoverers }) => recoverers.some((recoverer) => sameAddress(recoverer, walletAddress)))
  },
)

export const selectRecoveryQueues = createSelector([selectRecovery], (recovery) => {
  return recovery?.flatMap(({ queue }) => queue).sort((a, b) => Number(a.timestamp - b.timestamp))
})

export const selectDelayModifierByTxHash = createSelector(
  [selectRecovery, (_: RecoveryState, txHash: string) => txHash],
  (recovery, txHash) => {
    return recovery?.find(({ queue }) => queue.some((item) => item.transactionHash === txHash))
  },
)

export const selectDelayModifierByAddress = createSelector(
  [selectRecovery, (_: RecoveryState, moduleAddress: string) => moduleAddress],
  (recovery, moduleAddress) => {
    return recovery?.find(({ address }) => sameAddress(address, moduleAddress))
  },
)
</file>

<file path="src/features/recovery/services/setup.ts">
import { OperationType } from '@safe-global/safe-core-sdk-types'
import { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { getModuleInstance, KnownContracts, deployAndSetUpModule } from '@gnosis.pm/zodiac'
import { Interface } from 'ethers'
import type { JsonRpcProvider } from 'ethers'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'

import { sameAddress } from '@safe-global/utils/utils/addresses'
import { MAX_RECOVERER_PAGE_SIZE } from './recovery-state'
import type { UpsertRecoveryFlowProps } from '@/components/tx-flow/flows/UpsertRecovery'

export async function _getRecoverySetupTransactions({
  delay,
  expiry,
  recoverers,
  chainId,
  safeAddress,
  provider,
}: {
  delay: string
  expiry: string
  recoverers: Array<string>
  chainId: string
  safeAddress: string
  provider: JsonRpcProvider
}): Promise<{ expectedModuleAddress: string; transactions: Array<MetaTransactionData> }> {
  const setupArgs: Parameters<typeof deployAndSetUpModule>[1] = {
    types: ['address', 'address', 'address', 'uint256', 'uint256'],
    values: [
      safeAddress, // address _owner
      safeAddress, // address _avatar
      safeAddress, // address _target
      delay, // uint256 _cooldown
      expiry, // uint256 _expiration
    ],
  }

  const saltNonce: Parameters<typeof deployAndSetUpModule>[4] = Date.now().toString()

  const { transaction, expectedModuleAddress } = await deployAndSetUpModule(
    KnownContracts.DELAY,
    setupArgs,
    provider,
    Number(chainId),
    saltNonce,
  )

  const transactions: Array<MetaTransactionData> = []

  // Deploy Delay Modifier
  const deployDeplayModifier: MetaTransactionData = {
    ...transaction,
    value: transaction.value.toString(),
  }

  transactions.push(deployDeplayModifier)

  const safeAbi = ['function enableModule(address module)']
  const safeInterface = new Interface(safeAbi)

  // Enable Delay Modifier on Safe
  const enableDelayModifier: MetaTransactionData = {
    to: safeAddress,
    value: '0',
    data: safeInterface.encodeFunctionData('enableModule', [expectedModuleAddress]),
  }

  transactions.push(enableDelayModifier)

  const delayModifierContract = getModuleInstance(KnownContracts.DELAY, expectedModuleAddress, provider)

  // Add recoverers to Delay Modifier
  const enableDelayModifierModules: Array<MetaTransactionData> = recoverers.map((recoverer) => {
    return {
      to: expectedModuleAddress,
      data: delayModifierContract.interface.encodeFunctionData('enableModule', [recoverer]),
      value: '0',
    }
  })

  transactions.push(...enableDelayModifierModules)

  return {
    expectedModuleAddress,
    transactions,
  }
}

export async function _getEditRecoveryTransactions({
  newDelay,
  newExpiry,
  newRecoverers,
  moduleAddress,
  provider,
}: {
  newDelay: string
  newExpiry: string
  newRecoverers: Array<string>
  moduleAddress: string
  provider: JsonRpcProvider
}): Promise<Array<MetaTransactionData>> {
  const delayModifierContract = getModuleInstance(KnownContracts.DELAY, moduleAddress, provider)

  const [oldExpiry, oldDelay, [recoverers]] = await Promise.all([
    delayModifierContract.txExpiration(),
    delayModifierContract.txCooldown(),
    delayModifierContract.getModulesPaginated(SENTINEL_ADDRESS, MAX_RECOVERER_PAGE_SIZE),
  ])

  // Recovery management transaction data
  const txData: Array<string> = []

  // Update cooldown
  if (oldDelay !== BigInt(newDelay)) {
    const setTxCooldown = delayModifierContract.interface.encodeFunctionData('setTxCooldown', [newDelay])
    txData.push(setTxCooldown)
  }

  // Update expiration
  if (oldExpiry !== BigInt(newExpiry)) {
    const setTxExpiration = delayModifierContract.interface.encodeFunctionData('setTxExpiration', [newExpiry])
    txData.push(setTxExpiration)
  }

  // Cache recoverer changes to determine prevModule
  let _recoverers = [...recoverers]

  // Don't add/remove same owners
  const recoverersToAdd = newRecoverers.filter(
    (newRecoverer) => !_recoverers.some((oldRecoverer) => sameAddress(oldRecoverer, newRecoverer)),
  )
  const recoverersToRemove = _recoverers.filter(
    (oldRecoverer) => !newRecoverers.some((newRecoverer) => sameAddress(newRecoverer, oldRecoverer)),
  )

  for (const recovererToRemove of recoverersToRemove) {
    const prevModule = (() => {
      const recovererIndex = _recoverers.findIndex((recoverer) => sameAddress(recoverer, recovererToRemove))
      return recovererIndex === 0 ? SENTINEL_ADDRESS : _recoverers[recovererIndex - 1]
    })()
    const disableModule = delayModifierContract.interface.encodeFunctionData('disableModule', [
      prevModule,
      recovererToRemove,
    ])
    txData.push(disableModule)

    // Remove recoverer from cache
    _recoverers = _recoverers.filter((recoverer) => !sameAddress(recoverer, recovererToRemove))
  }

  for (const recovererToAdd of recoverersToAdd) {
    const enableModule = delayModifierContract.interface.encodeFunctionData('enableModule', [recovererToAdd])
    txData.push(enableModule)

    // Need not add recoverer to cache as not relevant for prevModule
  }

  return txData.map((data) => ({
    to: moduleAddress,
    value: '0',
    operation: OperationType.Call,
    data,
  }))
}

export async function getRecoveryUpsertTransactions({
  delay,
  expiry,
  recoverer,
  provider,
  moduleAddress,
  chainId,
  safeAddress,
}: UpsertRecoveryFlowProps & {
  moduleAddress?: string
  provider: JsonRpcProvider
  chainId: string
  safeAddress: string
}): Promise<Array<MetaTransactionData>> {
  if (moduleAddress) {
    return _getEditRecoveryTransactions({
      moduleAddress,
      newDelay: delay,
      newExpiry: expiry,
      newRecoverers: [recoverer],
      provider,
    })
  }

  const { transactions } = await _getRecoverySetupTransactions({
    delay,
    expiry,
    recoverers: [recoverer],
    chainId,
    safeAddress,
    provider,
  })

  return transactions
}
</file>

<file path="src/features/recovery/services/transaction-list.ts">
import { sameAddress } from '@safe-global/utils/utils/addresses'
import {
  isSwapOwnerCalldata,
  isAddOwnerWithThresholdCalldata,
  isRemoveOwnerCalldata,
  isChangeThresholdCalldata,
  isMultiSendCalldata,
} from '@/utils/transaction-calldata'
import { getSafeSingletonDeployment } from '@safe-global/safe-deployments'
import { Interface } from 'ethers'
import type { BaseTransaction } from '@safe-global/safe-apps-sdk'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'

function decodeOwnerManagementTransaction(safe: SafeState, transaction: BaseTransaction): SafeState {
  const safeDeployment = getSafeSingletonDeployment({ network: safe.chainId, version: safe.version ?? undefined })

  if (!safeDeployment) {
    throw new Error('No Safe deployment found')
  }

  const safeInterface = new Interface(safeDeployment.abi)

  let _owners = safe.owners
  let _threshold = safe.threshold

  if (isSwapOwnerCalldata(transaction.data)) {
    const [, ownerToRemove, ownerToAdd] = safeInterface.decodeFunctionData('swapOwner', transaction.data)

    _owners = safe.owners.map((owner) => (sameAddress(owner.value, ownerToRemove) ? { value: ownerToAdd } : owner))
  } else if (isAddOwnerWithThresholdCalldata(transaction.data)) {
    const [ownerToAdd, newThreshold] = safeInterface.decodeFunctionData('addOwnerWithThreshold', transaction.data)

    _owners = _owners.concat({ value: ownerToAdd })
    _threshold = Number(newThreshold)
  } else if (isRemoveOwnerCalldata(transaction.data)) {
    const [, ownerToRemove, newThreshold] = safeInterface.decodeFunctionData('removeOwner', transaction.data)

    _owners = safe.owners.filter((owner) => !sameAddress(owner.value, ownerToRemove))
    _threshold = Number(newThreshold)
  } else if (isChangeThresholdCalldata(transaction.data)) {
    const [newThreshold] = safeInterface.decodeFunctionData('changeThreshold', transaction.data)

    _threshold = Number(newThreshold)
  } else {
    throw new Error('Unexpected transaction')
  }

  return {
    ...safe,
    owners: _owners,
    threshold: _threshold,
  }
}

export function getRecoveredSafeInfo(safe: SafeState, transaction: BaseTransaction): SafeState {
  const transactions = isMultiSendCalldata(transaction.data) ? decodeMultiSendData(transaction.data) : [transaction]

  return transactions.reduce((acc, cur) => {
    return decodeOwnerManagementTransaction(acc, cur)
  }, safe)
}
</file>

<file path="src/features/recovery/services/transaction.ts">
import { Interface } from 'ethers'
import { getSafeSingletonDeployment } from '@safe-global/safe-deployments'
import { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { OperationType } from '@safe-global/safe-core-sdk-types'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { getModuleInstance, KnownContracts } from '@gnosis.pm/zodiac'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'
import { type SafeState, type AddressInfo } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import type { Provider } from 'ethers'

export function getRecoveryProposalTransactions({
  safe,
  newThreshold,
  newOwners,
}: {
  safe: SafeState
  newThreshold: number
  newOwners: Array<AddressInfo>
}): Array<MetaTransactionData> {
  const safeDeployment = getSafeSingletonDeployment({ network: safe.chainId, version: safe.version ?? undefined })

  if (!safeDeployment) {
    throw new Error('Safe deployment not found')
  }

  const safeInterface = new Interface(safeDeployment.abi)

  // Cache owner changes to determine prevOwner
  let _owners = safe.owners.map((owner) => owner.value)

  // Don't add/remove same owners
  const ownersToAdd = newOwners
    .filter((newOwner) => !_owners.some((oldOwner) => sameAddress(oldOwner, newOwner.value)))
    .map((owner) => owner.value)
  const ownersToRemove = _owners.filter(
    (oldOwner) => !newOwners.some((newOwner) => sameAddress(newOwner.value, oldOwner)),
  )

  // Check whether threshold should be changed after owner management
  let changeThreshold = newThreshold !== safe.threshold

  // Owner management transaction data
  const txData: Array<string> = []

  // Iterate of existing/new owners and swap, add, remove accordingly
  for (let index = 0; index < Math.max(ownersToAdd.length, ownersToRemove.length); index++) {
    const ownerToAdd = ownersToAdd[index]
    const ownerToRemove = ownersToRemove[index]

    const prevOwner = (() => {
      const ownerIndex = _owners.findIndex((owner) => sameAddress(owner, ownerToRemove))
      return ownerIndex === 0 ? SENTINEL_ADDRESS : _owners[ownerIndex - 1]
    })()

    // Swap existing owner with new one
    if (ownerToRemove && ownerToAdd) {
      const swapOwner = safeInterface.encodeFunctionData('swapOwner', [prevOwner, ownerToRemove, ownerToAdd])
      txData.push(swapOwner)

      // Swap owner in cache
      _owners = _owners.map((owner) => (sameAddress(owner, ownerToRemove) ? ownersToAdd[index] : owner))
    }
    // Add new owner and set threshold
    else if (ownerToAdd) {
      const threshold = Math.min(newThreshold, _owners.length + 1)

      const addOwnerWithThreshold = safeInterface.encodeFunctionData('addOwnerWithThreshold', [ownerToAdd, threshold])
      txData.push(addOwnerWithThreshold)

      changeThreshold = false

      // Add owner to cache
      _owners.push(ownerToAdd)
    }
    // Remove existing owner and set threshold
    else if (ownerToRemove) {
      const threshold = Math.min(newThreshold, _owners.length - 1)

      const removeOwner = safeInterface.encodeFunctionData('removeOwner', [prevOwner, ownerToRemove, threshold])
      txData.push(removeOwner)

      changeThreshold = false

      // Remove owner from cache
      _owners = _owners.filter((owner) => !sameAddress(owner, ownerToRemove))
    }
  }

  // Only swapOwner will be called
  if (changeThreshold) {
    txData.push(safeInterface.encodeFunctionData('changeThreshold', [newThreshold]))
  }

  return txData.map((data) => ({
    to: safe.address.value,
    value: '0',
    operation: OperationType.Call,
    data,
  }))
}

export async function getRecoverySkipTransaction(
  recovery: RecoveryQueueItem,
  provider: Provider,
): Promise<MetaTransactionData> {
  const delayModifier = getModuleInstance(KnownContracts.DELAY, recovery.address, provider)

  const newTxNonce = recovery.args.queueNonce + 1n

  return {
    to: await delayModifier.getAddress(),
    value: '0',
    operation: OperationType.Call,
    data: delayModifier.interface.encodeFunctionData('setTxNonce', [newTxNonce]),
  }
}
</file>

<file path="src/features/spaces/components/AddAccounts/AddManually.tsx">
import AddressInput from '@/components/common/AddressInput'
import ChainIndicator from '@/components/common/ChainIndicator'
import ModalDialog from '@/components/common/ModalDialog'
import networkSelectorCss from '@/components/common/NetworkSelector/styles.module.css'
import chains from '@/config/chains'
import css from './styles.module.css'
import useChains from '@/hooks/useChains'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import { Button, DialogActions, DialogContent, MenuItem, Select, Stack, Box } from '@mui/material'
import { getSafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import React, { useCallback, useState } from 'react'
import { FormProvider, useForm } from 'react-hook-form'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'

export type AddManuallyFormValues = {
  address: string
  chainId: string
}

const AddManually = ({ handleAddSafe }: { handleAddSafe: (data: AddManuallyFormValues) => void }) => {
  const [addManuallyOpen, setAddManuallyOpen] = useState(false)
  const { configs } = useChains()

  const formMethods = useForm<AddManuallyFormValues>({
    mode: 'onChange',
    defaultValues: {
      address: '',
      chainId: chains.eth,
    },
  })

  const { handleSubmit, watch, register, reset, formState } = formMethods

  const chainId = watch('chainId')
  const selectedChain = configs.find((chain) => chain.chainId === chainId)

  const onSubmit = handleSubmit((data) => {
    trackEvent({ ...SPACE_EVENTS.ADD_ACCOUNT_MANUALLY })
    handleAddSafe(data)
    onClose()
  })

  const onClose = () => {
    reset()
    setAddManuallyOpen(false)
  }

  const validateSafeAddress = async (address: string) => {
    try {
      await getSafeInfo(chainId, address)
    } catch (error) {
      return 'Address given is not a valid Safe Account address'
    }
  }

  const renderMenuItem = useCallback(
    (chainId: string, isSelected: boolean) => {
      const chain = configs.find((chain) => chain.chainId === chainId)
      if (!chain) return null

      return (
        <MenuItem
          data-testid="network-item"
          key={chainId}
          value={chainId}
          sx={{ '&:hover': { backgroundColor: isSelected ? 'transparent' : 'inherit' } }}
          disableRipple={isSelected}
        >
          <ChainIndicator chainId={chainId} />
        </MenuItem>
      )
    },
    [configs],
  )

  const chainIdField = register('chainId')

  return (
    <>
      <Button data-testid="add-manually-button" size="compact" onClick={() => setAddManuallyOpen(true)}>
        + Add manually
      </Button>
      <ModalDialog
        open={addManuallyOpen}
        dialogTitle="Add safe account"
        onClose={onClose}
        hideChainIndicator
        PaperProps={{ sx: { maxWidth: '760px' } }}
      >
        <FormProvider {...formMethods}>
          <form
            onSubmit={(e) => {
              e.stopPropagation()
              return onSubmit(e)
            }}
          >
            <DialogContent>
              <Stack direction={{ xs: 'column', md: 'row' }} spacing={2}>
                <AddressInput
                  data-testid="add-address-input"
                  label="Safe Account"
                  chain={selectedChain}
                  validate={validateSafeAddress}
                  name="address"
                  deps={chainId}
                />
                <Box data-testid="network-selector" className={css.selectWrapper}>
                  <Select
                    {...chainIdField}
                    value={chainId}
                    size="small"
                    className={networkSelectorCss.select}
                    variant="standard"
                    sx={{ width: '100%' }}
                    IconComponent={ExpandMoreIcon}
                    renderValue={(value) => renderMenuItem(value, true)}
                    MenuProps={{
                      transitionDuration: 0,
                      slotProps: { paper: { sx: { overflow: 'auto' } } },
                    }}
                  >
                    {configs.map((chain) => renderMenuItem(chain.chainId, false))}
                  </Select>
                </Box>
              </Stack>
            </DialogContent>
            <DialogActions>
              <Button onClick={onClose}>Cancel</Button>
              <Button
                data-testid="add-space-account-manually-button"
                variant="contained"
                disabled={!formState.isValid}
                type="submit"
              >
                Add
              </Button>
            </DialogActions>
          </form>
        </FormProvider>
      </ModalDialog>
    </>
  )
}

export default AddManually
</file>

<file path="src/features/spaces/components/AddAccounts/index.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import type { SafeItem, SafeItems } from '@/features/myAccounts/hooks/useAllSafes'
import { useSafesSearch } from '@/features/myAccounts/hooks/useSafesSearch'
import AddManually, { type AddManuallyFormValues } from '@/features/spaces/components/AddAccounts/AddManually'
import SafesList, { getSafeId } from '@/features/spaces/components/AddAccounts/SafesList'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import SearchIcon from '@/public/images/common/search.svg'
import { useSpaceSafesCreateV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'

import debounce from 'lodash/debounce'
import css from './styles.module.css'
import {
  type AllSafeItems,
  flattenSafeItems,
  useOwnedSafesGrouped,
} from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { getComparator } from '@/features/myAccounts/utils/utils'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectOrderByPreference } from '@/store/orderByPreferenceSlice'
import {
  Alert,
  Box,
  Button,
  Card,
  Container,
  DialogActions,
  DialogContent,
  InputAdornment,
  SvgIcon,
  TextField,
  Tooltip,
  Typography,
} from '@mui/material'
import React, { useCallback, useEffect, useMemo, useState } from 'react'
import { FormProvider, useForm } from 'react-hook-form'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import { useSpaceSafes } from '@/features/spaces/hooks/useSpaceSafes'
import { showNotification } from '@/store/notificationsSlice'

export type AddAccountsFormValues = {
  selectedSafes: Record<string, boolean>
}

function getSelectedSafes(safes: AddAccountsFormValues['selectedSafes'], spaceSafes: AllSafeItems) {
  const flatSafeItems = flattenSafeItems(spaceSafes)

  return Object.entries(safes).filter(
    ([key, isSelected]) =>
      isSelected &&
      !key.startsWith('multichain_') &&
      !flatSafeItems.some((spaceSafe) => {
        const [chainId, address] = key.split(':')
        return spaceSafe.address === address && spaceSafe.chainId === chainId
      }),
  )
}

const SAFE_ACCOUNTS_LIMIT = 10

const AddAccounts = () => {
  const isAdmin = useIsAdmin()
  const [open, setOpen] = useState<boolean>(false)
  const [searchQuery, setSearchQuery] = useState('')
  const [error, setError] = useState<string>()
  const [manualSafes, setManualSafes] = useState<SafeItems>([])

  const { orderBy } = useAppSelector(selectOrderByPreference)
  const dispatch = useAppDispatch()
  const { allSafes: spaceSafes } = useSpaceSafes()
  const safes = useOwnedSafesGrouped()
  const sortComparator = getComparator(orderBy)
  const [addSafesToSpace] = useSpaceSafesCreateV1Mutation()
  const spaceId = useCurrentSpaceId()

  const allSafes = useMemo<AllSafeItems>(
    () => [...manualSafes, ...(safes.allMultiChainSafes ?? []), ...(safes.allSingleSafes ?? [])].sort(sortComparator),
    [manualSafes, safes.allMultiChainSafes, safes.allSingleSafes, sortComparator],
  )

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const handleSearch = useCallback(debounce(setSearchQuery, 300), [])
  const filteredSafes = useSafesSearch(allSafes ?? [], searchQuery)

  const formMethods = useForm<AddAccountsFormValues>({
    mode: 'onChange',
    defaultValues: {
      selectedSafes: {},
    },
  })

  const { handleSubmit, watch, setValue } = formMethods

  const selectedSafes = watch(`selectedSafes`)
  const selectedSafesLength = getSelectedSafes(selectedSafes, spaceSafes).length

  const onSubmit = handleSubmit(async (data) => {
    trackEvent({ ...SPACE_EVENTS.ADD_ACCOUNTS })
    const safesToAdd = getSelectedSafes(data.selectedSafes, spaceSafes).map(([key]) => {
      const [chainId, address] = key.split(':')
      return { chainId, address }
    })

    try {
      const result = await addSafesToSpace({
        spaceId: Number(spaceId),
        createSpaceSafesDto: { safes: safesToAdd },
      })

      if (result.error) {
        // @ts-ignore
        setError(result.error?.data?.message || 'Something went wrong adding one or more Safe Accounts.')
        return
      }

      dispatch(
        showNotification({
          message: `Added safe account(s) to space`,
          variant: 'success',
          groupKey: 'add-safe-account-success',
        }),
      )

      handleClose()
    } catch (e) {
      console.log(e)
    }
  })

  const handleAddSafe = (data: AddManuallyFormValues) => {
    const alreadyExists = allSafes.some((safe) => safe.address === data.address)

    const newSafeItem: SafeItem = {
      ...data,
      isReadOnly: false,
      isPinned: false,
      lastVisited: 0,
      name: '',
    }

    if (!alreadyExists) {
      setManualSafes((prev) => [newSafeItem, ...prev])
    }

    const safeId = getSafeId(newSafeItem)
    setValue(`selectedSafes.${safeId}`, true, { shouldValidate: true })
  }

  const handleClose = () => {
    setError(undefined)
    setSearchQuery('')
    setValue('selectedSafes', {}) // Reset doesn't seem to work consistently with an object
    setOpen(false)
  }

  useEffect(() => {
    if (searchQuery) {
      trackEvent({ ...SPACE_EVENTS.SEARCH_ACCOUNTS, label: SPACE_LABELS.add_accounts_modal })
    }
  }, [searchQuery])

  return (
    <>
      <Tooltip title={!isAdmin ? 'You need to be an Admin to add accounts' : ''} placement="top">
        <Box component="span">
          <Button
            data-testid="add-space-account-button"
            variant="contained"
            onClick={() => setOpen(true)}
            disabled={!isAdmin}
            sx={{ whiteSpace: 'nowrap' }}
          >
            Add accounts
          </Button>
        </Box>
      </Tooltip>

      <ModalDialog
        open={open}
        fullScreen
        hideChainIndicator
        PaperProps={{ sx: { backgroundColor: 'border.background' } }}
      >
        <DialogContent sx={{ display: 'flex', alignItems: 'center' }}>
          <Container fixed maxWidth="sm" disableGutters>
            <Typography component="div" variant="h1" mb={1}>
              Add Safe Accounts
            </Typography>
            <Typography mb={2}>
              You can add any Safe Account to your Space. This is currently limited to {SAFE_ACCOUNTS_LIMIT} Safe
              Accounts.
            </Typography>
            <Card>
              <FormProvider {...formMethods}>
                <form onSubmit={onSubmit}>
                  <Box mt={2} mx={2}>
                    <TextField
                      id="search-by-name"
                      placeholder="Search"
                      aria-label="Search Safe list by name"
                      variant="filled"
                      hiddenLabel
                      onChange={(e) => {
                        handleSearch(e.target.value)
                      }}
                      className={css.search}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <SvgIcon
                              component={SearchIcon}
                              inheritViewBox
                              fontWeight="bold"
                              fontSize="small"
                              sx={{
                                color: 'var(--color-border-main)',
                                '.MuiInputBase-root.Mui-focused &': { color: 'var(--color-text-primary)' },
                              }}
                            />
                          </InputAdornment>
                        ),
                        disableUnderline: true,
                      }}
                      fullWidth
                      size="small"
                    />
                  </Box>

                  {searchQuery ? <SafesList safes={filteredSafes} /> : <SafesList safes={allSafes} />}

                  <Box p={2}>
                    <Track {...SPACE_EVENTS.ADD_ACCOUNT_MANUALLY_MODAL}>
                      <AddManually handleAddSafe={handleAddSafe} />
                    </Track>
                  </Box>

                  {error && (
                    <Alert severity="error" sx={{ m: 2, mt: 0 }}>
                      {error}
                    </Alert>
                  )}

                  <DialogActions>
                    <Button onClick={handleClose}>Cancel</Button>
                    <Button
                      data-testid="add-accounts-button"
                      variant="contained"
                      disabled={selectedSafesLength === 0}
                      type="submit"
                    >
                      Add Accounts ({selectedSafesLength})
                    </Button>
                  </DialogActions>
                </form>
              </FormProvider>
            </Card>
          </Container>
        </DialogContent>
      </ModalDialog>
    </>
  )
}

export default AddAccounts
</file>

<file path="src/features/spaces/components/AddAccounts/SafesList.tsx">
import ChainIndicator from '@/components/common/ChainIndicator'
import EthHashInfo from '@/components/common/EthHashInfo'
import { ChainIcon } from '@/components/common/SafeIcon'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'
import { MultichainIndicator } from '@/features/myAccounts/components/AccountItems/MultiAccountItem'
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import {
  type AllSafeItems,
  flattenSafeItems,
  type MultiChainSafeItem,
} from '@/features/myAccounts/hooks/useAllSafesGrouped'
import type { AddAccountsFormValues } from '@/features/spaces/components/AddAccounts/index'
import css from '@/features/spaces/components/AddAccounts/styles.module.css'
import { useChain } from '@/hooks/useChains'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import {
  Accordion,
  AccordionDetails,
  AccordionSummary,
  Box,
  Checkbox,
  List,
  ListItem,
  Stack,
  Typography,
} from '@mui/material'
import ListItemButton from '@mui/material/ListItemButton'
import ListItemIcon from '@mui/material/ListItemIcon'
import ListItemText from '@mui/material/ListItemText'
import { Controller, useFormContext } from 'react-hook-form'
import { useSpaceSafes } from '@/features/spaces/hooks/useSpaceSafes'
import isEqual from 'lodash/isEqual'

const ChainItem = ({ chainId }: { chainId: string }) => {
  const chainConfig = useChain(chainId)

  if (!chainConfig) return null

  return (
    <Stack alignItems="center" direction="row" gap={1}>
      <ChainIcon chainId={chainId} />
      <Typography
        component="span"
        sx={{
          color: 'var(--color-primary-light)',
          fontSize: 'inherit',
        }}
      >
        {chainConfig.chainName}
      </Typography>
    </Stack>
  )
}

export const getSafeId = (safeItem: SafeItem) => {
  return `${safeItem.chainId}:${safeItem.address}`
}

function getMultiChainSafeId(mcSafe: MultiChainSafeItem) {
  return `multichain_${mcSafe.address}`
}

const SafesList = ({ safes }: { safes: AllSafeItems }) => {
  const { watch, setValue, control } = useFormContext<AddAccountsFormValues>()
  const { allSafes: spaceSafes } = useSpaceSafes()
  const flatSafeItems = flattenSafeItems(spaceSafes)
  const multiChainSpaceSafes = spaceSafes.filter(isMultiChainSafeItem)

  return (
    <List
      sx={{ p: 2, display: 'flex', flexDirection: 'column', gap: 1, maxHeight: 400, minHeight: 400, overflow: 'auto' }}
    >
      {safes.map((safe, index) => {
        if (isMultiChainSafeItem(safe)) {
          const parentSafeId = getMultiChainSafeId(safe)
          const subSafeIds = safe.safes.map(getSafeId)
          const watchedSubSafeIds = subSafeIds.map((id) => `selectedSafes.${id}`)

          // @ts-ignore TODO: Check why this overload is not supported https://react-hook-form.com/docs/useform/watch
          const subSafeValues = watch(watchedSubSafeIds)

          const totalSubSafes = safe.safes.length
          const checkedCount = subSafeValues.filter(Boolean).length
          const allChecked = checkedCount === totalSubSafes && totalSubSafes > 0
          const someChecked = checkedCount > 0 && checkedCount < totalSubSafes
          const alreadyAdded = multiChainSpaceSafes.some((spaceSafe) => isEqual(spaceSafe.safes, safe.safes))

          const handleHeaderCheckboxChange = (checked: boolean) => {
            setValue(`selectedSafes.${parentSafeId}`, checked, { shouldValidate: true })

            subSafeIds.forEach((id) => {
              setValue(`selectedSafes.${id}`, checked, { shouldValidate: true })
            })
          }

          return (
            <Accordion key={index} disableGutters sx={{ flexShrink: '0' }}>
              <AccordionSummary
                expandIcon={<ExpandMoreIcon />}
                sx={{
                  '& .MuiAccordionSummary-expandIconWrapper': { position: 'absolute', right: '16px' },
                }}
              >
                <Checkbox
                  checked={Boolean(allChecked) || alreadyAdded}
                  indeterminate={someChecked}
                  onChange={(e) => handleHeaderCheckboxChange(e.target.checked)}
                  onClick={(e) => e.stopPropagation()}
                  onFocus={(e) => e.stopPropagation()}
                  sx={{ mr: 2 }}
                  disabled={alreadyAdded}
                />
                <Box className={css.safeRow}>
                  <EthHashInfo address={safe.address} copyAddress={false} showPrefix={false} />
                  <Box sx={{ justifySelf: 'flex-start' }}>
                    <MultichainIndicator safes={safe.safes} />
                  </Box>
                </Box>
              </AccordionSummary>

              <AccordionDetails sx={{ p: 0 }}>
                <List disablePadding>
                  {safe.safes.map((subSafe) => {
                    const subSafeId = getSafeId(subSafe)
                    const alreadyAdded = flatSafeItems.some((spaceSafe) => {
                      return spaceSafe.chainId === subSafe.chainId && spaceSafe.address === subSafe.address
                    })

                    return (
                      <Controller
                        key={`${subSafeId}`}
                        name={`selectedSafes.${subSafeId}`}
                        control={control}
                        render={({ field }) => {
                          const handleItemClick = () => {
                            field.onChange(!field.value)
                          }

                          return (
                            <ListItem disablePadding>
                              <ListItemButton onClick={handleItemClick} disabled={alreadyAdded}>
                                <ListItemIcon onClick={(e) => e.stopPropagation()}>
                                  <Checkbox
                                    checked={Boolean(field.value) || alreadyAdded}
                                    onClick={(e) => e.stopPropagation()}
                                    onFocus={(e) => e.stopPropagation()}
                                    onChange={(e) => field.onChange(e.target.checked)}
                                  />
                                </ListItemIcon>
                                <ListItemText primary={<ChainItem chainId={subSafe.chainId} />} />
                              </ListItemButton>
                            </ListItem>
                          )
                        }}
                      />
                    )
                  })}
                </List>
              </AccordionDetails>
            </Accordion>
          )
        }

        const safeId = getSafeId(safe)
        const alreadyAdded = flatSafeItems.some(
          (spaceSafe) => spaceSafe.address === safe.address && spaceSafe.chainId === safe.chainId,
        )

        return (
          <Controller
            key={`${safeId}`}
            name={`selectedSafes.${safeId}`}
            control={control}
            render={({ field }) => {
              const handleItemClick = () => {
                field.onChange(!field.value)
              }

              return (
                <ListItem className={css.safeItem} disablePadding>
                  <ListItemButton onClick={handleItemClick} disabled={alreadyAdded}>
                    <ListItemIcon onClick={(e) => e.stopPropagation()}>
                      <Checkbox
                        checked={Boolean(field.value) || alreadyAdded}
                        onChange={(event) => field.onChange(event.target.checked)}
                      />
                    </ListItemIcon>
                    <ListItemText
                      primary={
                        <Box className={css.safeRow}>
                          <EthHashInfo address={safe.address} chainId={safe.chainId} copyAddress={false} />
                          <ChainIndicator chainId={safe.chainId} responsive onlyLogo />
                        </Box>
                      }
                    />
                  </ListItemButton>
                </ListItem>
              )
            }}
          />
        )
      })}
    </List>
  )
}

export default SafesList
</file>

<file path="src/features/spaces/components/AddAccounts/styles.module.css">
.safeRow {
  display: grid;
  grid-template-columns: 8fr 3fr;
  align-items: center;
  width: 100%;
}

.safeItem {
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
}

.search :global .MuiInputBase-root {
  border: 1px solid transparent !important;
}

.selectWrapper {
  display: flex;
  align-items: center;
  border-radius: 8px;
  border: 1px solid var(--color-border-light);
  height: 66px;
}
</file>

<file path="src/features/spaces/components/AddMemberModal/index.tsx">
import { type ReactElement, useState } from 'react'
import {
  Alert,
  Box,
  Button,
  CircularProgress,
  DialogActions,
  DialogContent,
  Stack,
  SvgIcon,
  Typography,
} from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import ModalDialog from '@/components/common/ModalDialog'
import memberIcon from '@/public/images/spaces/member.svg'
import adminIcon from '@/public/images/spaces/admin.svg'
import AddressInput from '@/components/common/AddressInput'
import CheckIcon from '@mui/icons-material/Check'
import css from './styles.module.css'
import { useMembersInviteUserV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useCurrentSpaceId } from 'src/features/spaces/hooks/useCurrentSpaceId'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import { MemberRole } from '@/features/spaces/hooks/useSpaceMembers'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { useAppDispatch } from '@/store'
import { showNotification } from '@/store/notificationsSlice'
import MemberInfoForm from '@/features/spaces/components/AddMemberModal/MemberInfoForm'

type MemberField = {
  name: string
  address: string
  role: MemberRole
}

export const RoleMenuItem = ({
  role,
  hasDescription = false,
  selected = false,
}: {
  role: MemberRole
  hasDescription?: boolean
  selected?: boolean
}): ReactElement => {
  const isAdmin = role === MemberRole.ADMIN

  return (
    <Box width="100%" alignItems="center" className={css.roleMenuItem}>
      <Box sx={{ gridArea: 'icon', display: 'flex', alignItems: 'center' }}>
        <SvgIcon mr={1} component={isAdmin ? adminIcon : memberIcon} inheritViewBox fontSize="small" />
      </Box>
      <Typography gridArea="title" fontWeight={hasDescription ? 'bold' : undefined}>
        {isAdmin ? 'Admin' : 'Member'}
      </Typography>
      {hasDescription && (
        <>
          <Box gridArea="description">
            <Typography variant="body2" sx={{ maxWidth: '300px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
              {isAdmin ? 'Admins can create and delete spaces, invite members, and more.' : 'Can view the space data.'}
            </Typography>
          </Box>
          <Box gridArea="checkIcon" sx={{ visibility: selected ? 'visible' : 'hidden', mx: 1 }}>
            <CheckIcon fontSize="small" sx={{ color: 'text.primary' }} />
          </Box>
        </>
      )}
    </Box>
  )
}

const AddMemberModal = ({ onClose }: { onClose: () => void }): ReactElement => {
  const spaceId = useCurrentSpaceId()
  const router = useRouter()
  const dispatch = useAppDispatch()
  const [error, setError] = useState<string>()
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [inviteMembers] = useMembersInviteUserV1Mutation()

  const methods = useForm<MemberField>({
    mode: 'onChange',
    defaultValues: {
      name: '',
      address: '',
      role: MemberRole.MEMBER,
    },
  })

  const { handleSubmit, formState } = methods

  const onSubmit = handleSubmit(async (data) => {
    setError(undefined)

    if (!spaceId) {
      setError('Something went wrong. Please try again.')
      return
    }

    try {
      setIsSubmitting(true)
      trackEvent({ ...SPACE_EVENTS.ADD_MEMBER })
      const response = await inviteMembers({
        spaceId: Number(spaceId),
        inviteUsersDto: { users: [{ address: data.address, role: data.role, name: data.name }] },
      })

      if (response.data) {
        if (router.pathname !== AppRoutes.spaces.members) {
          router.push({ pathname: AppRoutes.spaces.members, query: { spaceId } })
        }

        dispatch(
          showNotification({
            message: `Invited ${data.name} to space`,
            variant: 'success',
            groupKey: 'invite-member-success',
          }),
        )

        onClose()
      }
      if (response.error) {
        // @ts-ignore
        const errorMessage = response.error?.data?.message || 'Invite failed. Please try again.'
        setError(errorMessage)
      }
    } catch (e) {
      console.error(e)
      setError('Something went wrong. Please try again.')
    } finally {
      setIsSubmitting(false)
    }
  })

  return (
    <ModalDialog open onClose={onClose} dialogTitle="Add member" hideChainIndicator>
      <FormProvider {...methods}>
        <form onSubmit={onSubmit}>
          <DialogContent sx={{ py: 2 }}>
            <Typography mb={2}>
              Invite a signer of the Safe Accounts, or any other wallet address. Anyone in the space can see their name.
            </Typography>

            <Stack spacing={3}>
              <MemberInfoForm />

              <AddressInput
                data-testid="member-address-input"
                name="address"
                label="Address"
                required
                showPrefix={false}
              />
            </Stack>

            {error && (
              <Alert severity="error" sx={{ mt: 2 }}>
                {error}
              </Alert>
            )}
          </DialogContent>

          <DialogActions>
            <Button data-testid="cancel-btn" onClick={onClose}>
              Cancel
            </Button>
            <Button
              data-testid="add-member-modal-button"
              type="submit"
              variant="contained"
              disabled={!formState.isValid}
              disableElevation
            >
              {isSubmitting ? <CircularProgress size={20} /> : 'Add member'}
            </Button>
          </DialogActions>
        </form>
      </FormProvider>
    </ModalDialog>
  )
}

export default AddMemberModal
</file>

<file path="src/features/spaces/components/AddMemberModal/MemberInfoForm.tsx">
import NameInput from '@/components/common/NameInput'
import { Controller, useFormContext } from 'react-hook-form'
import { MenuItem, Select, Stack } from '@mui/material'
import { RoleMenuItem } from '@/features/spaces/components/AddMemberModal/index'
import { MemberRole } from '@/features/spaces/hooks/useSpaceMembers'

const MemberInfoForm = ({ isEdit = false }: { isEdit?: boolean }) => {
  const { control } = useFormContext()

  return (
    <Stack direction="row" spacing={2} alignItems="center">
      <NameInput data-testid="member-name-input" name="name" label="Name" required disabled={isEdit} />

      <Controller
        control={control}
        name="role"
        defaultValue={MemberRole.MEMBER}
        render={({ field: { value, onChange, ...field } }) => (
          <Select
            {...field}
            value={value}
            onChange={onChange}
            required
            sx={{ minWidth: '150px', py: 0.5 }}
            renderValue={(role) => <RoleMenuItem role={role as MemberRole} />}
          >
            <MenuItem value={MemberRole.ADMIN}>
              <RoleMenuItem role={MemberRole.ADMIN} hasDescription selected={value === MemberRole.ADMIN} />
            </MenuItem>
            <MenuItem value={MemberRole.MEMBER}>
              <RoleMenuItem role={MemberRole.MEMBER} hasDescription selected={value === MemberRole.MEMBER} />
            </MenuItem>
          </Select>
        )}
      />
    </Stack>
  )
}

export default MemberInfoForm
</file>

<file path="src/features/spaces/components/AddMemberModal/styles.module.css">
.roleMenuItem {
  display: grid;
  grid-template-columns: auto 1fr auto;
  grid-template-areas:
    'icon      title       checkIcon'
    '.         description checkIcon';
  column-gap: var(--space-1);
}
</file>

<file path="src/features/spaces/components/AuthState/index.tsx">
import { type ReactNode, useEffect } from 'react'
import SignedOutState from '@/features/spaces/components/SignedOutState'
import { isUnauthorized } from '@/features/spaces/utils'
import UnauthorizedState from '@/features/spaces/components/UnauthorizedState'
import LoadingState from '@/features/spaces/components/LoadingState'
import { useAppDispatch, useAppSelector } from '@/store'
import { isAuthenticated, setLastUsedSpace } from '@/store/authSlice'
import { useSpacesGetOneV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import { MemberStatus } from '@/features/spaces/hooks/useSpaceMembers'
import { useHasFeature } from '@/hooks/useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'
import useFeatureFlagRedirect from '@/features/spaces/hooks/useFeatureFlagRedirect'

const AuthState = ({ spaceId, children }: { spaceId: string; children: ReactNode }) => {
  const dispatch = useAppDispatch()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData: currentUser } = useUsersGetWithWalletsV1Query(undefined, { skip: !isUserSignedIn })
  const { currentData, error, isLoading } = useSpacesGetOneV1Query({ id: Number(spaceId) }, { skip: !isUserSignedIn })
  const isSpacesFeatureEnabled = useHasFeature(FEATURES.SPACES)
  useFeatureFlagRedirect()

  const isCurrentUserDeclined = currentData?.members.some(
    (member) => member.user.id === currentUser?.id && member.status === MemberStatus.DECLINED,
  )

  useEffect(() => {
    dispatch(setLastUsedSpace(spaceId))
  }, [dispatch, spaceId])

  if (!isSpacesFeatureEnabled) return null

  if (isLoading) return <LoadingState />

  if (!isUserSignedIn) return <SignedOutState />

  if (isUnauthorized(error) || isCurrentUserDeclined) return <UnauthorizedState />

  return children
}

export default AuthState
</file>

<file path="src/features/spaces/components/Dashboard/AddAccountsCard.tsx">
import AddAccounts from '@/features/spaces/components/AddAccounts'
import Image from 'next/image'
import { Typography, Paper, Box, Stack } from '@mui/material'
import EmptyDashboard from '@/public/images/spaces/empty_dashboard.png'
import EmptyDashboardDark from '@/public/images/spaces/empty_dashboard_dark.png'

import css from './styles.module.css'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { useDarkMode } from '@/hooks/useDarkMode'

const AddAccountsCard = () => {
  const isDarkMode = useDarkMode()

  return (
    <Paper sx={{ p: 3, display: 'flex', gap: 3 }}>
      <Stack direction={{ xs: 'column-reverse', md: 'row' }} alignItems="center" spacing={3}>
        <Box sx={{ flex: 2 }}>
          <Typography variant="h4" fontWeight={700} mb={2}>
            Add your Safe Accounts
          </Typography>

          <Typography variant="body1" color="text.secondary" mb={2}>
            Start by adding Safe Accounts to your space. Any accounts that are linked to your connected wallet can be
            added to the space.
          </Typography>

          <Track {...SPACE_EVENTS.ADD_ACCOUNTS_MODAL} label={SPACE_LABELS.space_dashboard_card}>
            <AddAccounts />
          </Track>
        </Box>

        <Box>
          <Image
            className={css.image}
            src={isDarkMode ? EmptyDashboardDark : EmptyDashboard}
            alt="Illustration of two safes with their thresholds"
            width={375}
            height={200}
          />
        </Box>
      </Stack>
    </Paper>
  )
}

export default AddAccountsCard
</file>

<file path="src/features/spaces/components/Dashboard/AggregatedBalances.tsx">
import { useChain } from '@/hooks/useChains'
import { Card, Grid2, Skeleton, Stack, Typography } from '@mui/material'
import css from '@/features/spaces/components/Dashboard/styles.module.css'
import FiatValue from '@/components/common/FiatValue'
import { useAppSelector } from '@/store'
import { selectCurrency } from '@/store/settingsSlice'
import { useGetMultipleSafeOverviewsQuery } from '@/store/api/gateway'
import type { SafeOverview } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import ChainIndicator from '@/components/common/ChainIndicator'

type FiatTotalByChain = {
  chainId: string
  total: number
  percentage: number
}

function aggregateFiatTotalsByChainId(items: SafeOverview[]): FiatTotalByChain[] {
  const totals: Record<string, number> = {}

  for (const item of items) {
    const fiatValue = Number(item.fiatTotal) || 0
    totals[item.chainId] = (totals[item.chainId] || 0) + fiatValue
  }

  const grandTotal = Object.values(totals).reduce((sum, val) => sum + val, 0)

  const result = Object.entries(totals).map(([chainId, total]) => {
    const percentage = grandTotal ? (total / grandTotal) * 100 : 0

    return {
      chainId,
      total,
      percentage: parseFloat(percentage.toFixed(2)),
    }
  })

  result.sort((a, b) => b.total - a.total)

  return result
}

function getTopFiatTotals(chainTotals: FiatTotalByChain[]): FiatTotalByChain[] {
  const MAX_NETWORKS = 5
  if (chainTotals.length <= MAX_NETWORKS) {
    return chainTotals
  }

  const topTotals = chainTotals.slice(0, MAX_NETWORKS - 1)
  const rest = chainTotals.slice(MAX_NETWORKS - 1)

  const otherTotal = rest.reduce((sum, item) => sum + item.total, 0)
  const percentage = rest.reduce((sum, item) => sum + item.percentage, 0)

  const otherItem: FiatTotalByChain = {
    chainId: 'Other',
    total: otherTotal,
    percentage,
  }

  return [...topTotals, otherItem]
}

const AggregatedBalanceByChain = ({ fiatTotalByChain }: { fiatTotalByChain: FiatTotalByChain }) => {
  const chain = useChain(fiatTotalByChain.chainId)

  return (
    <Stack>
      <Typography component="div" variant="body2" color="primary.light" mb={0.5} height="24px">
        {fiatTotalByChain.chainId === 'Other' ? 'Other' : <ChainIndicator chainId={fiatTotalByChain.chainId} />}
      </Typography>

      <Typography variant="h3" fontWeight="700" mb={0.5}>
        <FiatValue value={fiatTotalByChain.total.toString()} maxLength={20} precise />
      </Typography>

      <div className={css.chainIndicator}>
        <Typography
          component="span"
          className={css.chainIndicatorColor}
          bgcolor={chain?.theme.backgroundColor || '#dddee0'}
          width={`${fiatTotalByChain.percentage}%`}
        />
      </div>
    </Stack>
  )
}

const AggregatedBalance = ({ safeItems }: { safeItems: SafeItem[] }) => {
  const currency = useAppSelector(selectCurrency)

  const { data: safeOverviews, isLoading } = useGetMultipleSafeOverviewsQuery({ safes: safeItems, currency })
  const aggregatedBalance = safeOverviews ? safeOverviews.reduce((prev, next) => prev + Number(next.fiatTotal), 0) : 0
  const fiatTotalByChainId = safeOverviews ? aggregateFiatTotalsByChainId(safeOverviews) : []
  const topTotals = getTopFiatTotals(fiatTotalByChainId)

  if (isLoading) return <AggregatedBalanceSkeleton />

  return (
    <Card sx={{ p: 2, mb: 2 }}>
      <Typography variant="body2" fontWeight="bold" mb={1} color="primary.light">
        Aggregated balance
      </Typography>
      <Typography
        component="div"
        variant="h1"
        sx={{
          fontSize: 44,
          lineHeight: '40px',
        }}
      >
        <FiatValue value={aggregatedBalance.toString()} maxLength={20} precise />
      </Typography>

      {topTotals && (
        <Grid2 container mt={3} spacing={2}>
          {topTotals.map((fiatTotal) => {
            return (
              <Grid2 key={fiatTotal.chainId} size={{ xs: 12, md: 'grow' }} maxWidth={{ xs: 1, md: '20%' }}>
                <AggregatedBalanceByChain fiatTotalByChain={fiatTotal} />
              </Grid2>
            )
          })}
        </Grid2>
      )}
    </Card>
  )
}

const AggregatedBalanceSkeleton = () => {
  return (
    <Card sx={{ p: 2, mb: 2 }}>
      <Skeleton variant="rounded" width={100} height={20} sx={{ mb: 1 }} />
      <Skeleton variant="rounded" width={160} height={40} sx={{ mb: 3 }} />
      <Skeleton variant="rounded" width={200} height={58} />
    </Card>
  )
}

export default AggregatedBalance
</file>

<file path="src/features/spaces/components/Dashboard/DashboardMembersList.tsx">
import { Button, Box, Stack } from '@mui/material'
import type { Member } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import PlusIcon from '@/public/images/common/plus.svg'
import { useState } from 'react'
import AddMemberModal from '../AddMemberModal'
import MemberName from '../MembersList/MemberName'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'

const DashboardMembersList = ({ members }: { members: Member[] }) => {
  const [openAddMembersModal, setOpenAddMembersModal] = useState(false)
  const isAdmin = useIsAdmin()

  return (
    <>
      <Stack spacing={2}>
        {members.map((member) => (
          <Box key={member.id}>
            <MemberName key={member.id} member={member} />
          </Box>
        ))}
      </Stack>
      {isAdmin && (
        <Box display="flex" justifyContent="center" mt={2}>
          <Track {...SPACE_EVENTS.ADD_MEMBER_MODAL} label={SPACE_LABELS.space_dashboard}>
            <Button size="small" variant="text" startIcon={<PlusIcon />} onClick={() => setOpenAddMembersModal(true)}>
              Add member
            </Button>
          </Track>
        </Box>
      )}
      {openAddMembersModal && <AddMemberModal onClose={() => setOpenAddMembersModal(false)} />}
    </>
  )
}

export default DashboardMembersList
</file>

<file path="src/features/spaces/components/Dashboard/index.tsx">
import MembersCard from '@/features/spaces/components/Dashboard/MembersCard'
import NewFeaturesCard from '@/features/spaces/components/Dashboard/NewFeaturesCard'
import SpacesCTACard from '@/features/spaces/components/Dashboard/SpacesCTACard'
import { Card, Grid2, Stack, Typography } from '@mui/material'
import Grid from '@mui/material/Grid2'
import { useSpaceSafes } from '@/features/spaces/hooks/useSpaceSafes'
import SafesList from '@/features/myAccounts/components/SafesList'
import AddAccountsCard from './AddAccountsCard'
import { AppRoutes } from '@/config/routes'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import type { LinkProps } from 'next/link'
import NextLink from 'next/link'
import { Link } from '@mui/material'
import ChevronRightIcon from '@mui/icons-material/ChevronRight'
import DashboardMembersList from '@/features/spaces/components/Dashboard/DashboardMembersList'
import { useSpaceMembersByStatus, useIsInvited } from '@/features/spaces/hooks/useSpaceMembers'
import PreviewInvite from '../InviteBanner/PreviewInvite'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import AggregatedBalance from '@/features/spaces/components/Dashboard/AggregatedBalances'
import useTrackSpace from '@/features/spaces/hooks/useTrackSpace'
import { flattenSafeItems } from '@/features/myAccounts/hooks/useAllSafesGrouped'

const ViewAllLink = ({ url }: { url: LinkProps['href'] }) => {
  return (
    <NextLink href={url} passHref legacyBehavior>
      <Link
        sx={{
          display: 'flex',
          alignItems: 'center',
          gap: 1,
          textDecoration: 'none',
          fontSize: '14px',
          color: 'primary.main',
        }}
      >
        View all <ChevronRightIcon fontSize="small" />
      </Link>
    </NextLink>
  )
}

const DASHBOARD_LIST_DISPLAY_LIMIT = 5

const SpaceDashboard = () => {
  const { allSafes: safes } = useSpaceSafes()
  const safeItems = flattenSafeItems(safes)
  const spaceId = useCurrentSpaceId()
  const { activeMembers } = useSpaceMembersByStatus()
  const isInvited = useIsInvited()
  useTrackSpace(safes, activeMembers)

  const safesToDisplay = safes.slice(0, DASHBOARD_LIST_DISPLAY_LIMIT)
  const membersToDisplay = activeMembers.slice(0, DASHBOARD_LIST_DISPLAY_LIMIT)

  return (
    <>
      {isInvited && <PreviewInvite />}

      {safeItems.length > 0 ? (
        <>
          <Grid container>
            <Grid size={12}>
              <AggregatedBalance safeItems={safeItems} />
            </Grid>
          </Grid>

          <Grid container spacing={3}>
            <Grid size={{ xs: 12, md: 8 }}>
              <Card data-testid="dashboard-safe-list" sx={{ p: 2 }}>
                <Stack direction="row" justifyContent="space-between" alignItems="center" mb={2}>
                  <Typography variant="h5">Safe Accounts ({safeItems.length})</Typography>
                  {spaceId && (
                    <Track {...SPACE_EVENTS.VIEW_ALL_ACCOUNTS}>
                      <ViewAllLink url={{ pathname: AppRoutes.spaces.safeAccounts, query: { spaceId } }} />
                    </Track>
                  )}
                </Stack>
                <SafesList safes={safesToDisplay} isSpaceSafe />
              </Card>
            </Grid>
            <Grid size={{ xs: 12, md: 4 }}>
              <Card sx={{ p: 2 }}>
                <Stack direction="row" justifyContent="space-between" alignItems="center" mb={2}>
                  <Typography variant="h5">Members ({activeMembers.length})</Typography>

                  {spaceId && (
                    <Track {...SPACE_EVENTS.VIEW_ALL_MEMBERS}>
                      <ViewAllLink url={{ pathname: AppRoutes.spaces.members, query: { spaceId } }} />
                    </Track>
                  )}
                </Stack>
                <DashboardMembersList members={membersToDisplay} />
              </Card>
            </Grid>
          </Grid>
        </>
      ) : (
        <>
          <Typography variant="h1" fontWeight={700} mb={4}>
            Getting started
          </Typography>

          <Grid container spacing={3}>
            <Grid size={12}>
              <AddAccountsCard />
            </Grid>
            <Grid size={{ xs: 12, md: 4 }}>
              <MembersCard />
            </Grid>

            <Grid2 size={{ xs: 12, md: 4 }}>
              <SpacesCTACard />
            </Grid2>

            <Grid2 size={{ xs: 12, md: 4 }}>
              <NewFeaturesCard />
            </Grid2>
          </Grid>
        </>
      )}
    </>
  )
}

export default SpaceDashboard
</file>

<file path="src/features/spaces/components/Dashboard/MembersCard.tsx">
import css from '@/features/spaces/components/Dashboard/styles.module.css'
import MemberIcon from '@/public/images/spaces/member.svg'
import { Typography, Paper, Box, Button, SvgIcon, Tooltip } from '@mui/material'
import { useState } from 'react'
import { useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import AddMemberModal from '../AddMemberModal'
import { SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'

const MembersCard = () => {
  const [openAddMembersModal, setOpenAddMembersModal] = useState(false)
  const isAdmin = useIsAdmin()
  const isButtonDisabled = !isAdmin

  const handleInviteClick = () => {
    setOpenAddMembersModal(true)
  }

  return (
    <>
      <Paper sx={{ p: 3, borderRadius: '12px' }}>
        <Box position="relative" width={1}>
          <Box className={css.iconBG}>
            <SvgIcon component={MemberIcon} inheritViewBox />
          </Box>
          <Tooltip title={isButtonDisabled ? 'You need to be an Admin to add members' : ''} placement="top">
            <Box component="span" sx={{ position: 'absolute', top: 0, right: 0 }}>
              <Track {...SPACE_EVENTS.ADD_MEMBER_MODAL} label={SPACE_LABELS.space_dashboard_card}>
                <Button
                  data-testid="add-member-button"
                  onClick={handleInviteClick}
                  variant={isButtonDisabled ? 'contained' : 'outlined'}
                  size="compact"
                  aria-label="Invite team members"
                  disabled={isButtonDisabled}
                >
                  Add members
                </Button>
              </Track>
            </Box>
          </Tooltip>
        </Box>
        <Box>
          <Typography variant="body1" color="text.primary" fontWeight={700} mb={1}>
            Add members
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Invite team members to help manage your Safe Accounts. You can add both Safe Account signers and external
            collaborators.
          </Typography>
        </Box>
      </Paper>
      {openAddMembersModal && <AddMemberModal onClose={() => setOpenAddMembersModal(false)} />}
    </>
  )
}

export default MembersCard
</file>

<file path="src/features/spaces/components/Dashboard/NewFeaturesCard.tsx">
import WhatsNewIcon from '@/public/images/common/whatsnew.svg'
import { Typography, Paper, Box, SvgIcon, Chip } from '@mui/material'
import css from './styles.module.css'

const NewFeaturesCard = () => {
  return (
    <Paper sx={{ p: 3, borderRadius: '12px' }}>
      <Box position="relative" width={1}>
        <Box className={css.iconBG}>
          <SvgIcon component={WhatsNewIcon} inheritViewBox />
        </Box>

        <Chip label="Coming soon" size="small" sx={{ position: 'absolute', top: 0, right: 0, fontWeight: 'bold' }} />
      </Box>
      <Box>
        <Typography variant="body1" color="text.primary" fontWeight={700} mb={1}>
          New exciting features
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Address book sharing, viewing transactions across accounts and more is coming soon. Stay tuned for updates!
        </Typography>
      </Box>
    </Paper>
  )
}

export default NewFeaturesCard
</file>

<file path="src/features/spaces/components/Dashboard/SpacesCTACard.tsx">
import css from '@/features/spaces/components/Dashboard/styles.module.css'
import LightbulbIcon from '@/public/images/common/lightbulb.svg'
import { Typography, Paper, Box, Button, SvgIcon } from '@mui/material'
import SpaceInfoModal from '../SpaceInfoModal'
import { useState } from 'react'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'

const SpacesCTACard = () => {
  const [isInfoOpen, setIsInfoOpen] = useState<boolean>(false)

  const handleLearnMore = () => {
    trackEvent({ ...SPACE_EVENTS.INFO_MODAL, label: SPACE_LABELS.space_dashboard_card })
    setIsInfoOpen(true)
  }

  return (
    <>
      <Paper sx={{ p: 3, borderRadius: '12px', height: '100%' }}>
        <Box position="relative" width={1}>
          <Box className={css.iconBG}>
            <SvgIcon component={LightbulbIcon} inheritViewBox />
          </Box>

          <Button
            onClick={handleLearnMore}
            variant="outlined"
            size="compact"
            sx={{
              position: 'absolute',
              top: 0,
              right: 0,
            }}
            aria-label="Invite team members"
          >
            Learn more
          </Button>
        </Box>
        <Box>
          <Typography variant="body1" color="text.primary" fontWeight={700} mb={1}>
            Explore spaces
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Seamlessly use your Safe Accounts from one place and collaborate with your team members.
          </Typography>
        </Box>
      </Paper>
      {isInfoOpen && <SpaceInfoModal showButtons={false} onClose={() => setIsInfoOpen(false)} />}
    </>
  )
}

export default SpacesCTACard
</file>

<file path="src/features/spaces/components/Dashboard/styles.module.css">
.content {
  min-height: calc(100vh - 100px); /* Header + padding height */
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.contentWrapper {
  position: relative;
  z-index: 1;
}

.contentInner {
  background-color: var(--color-background-paper);
  max-width: 500px;
  padding: var(--space-5);
  border-radius: var(--space-1);
}

.iconBG {
  width: 40px;
  height: 40px;
  background-color: var(--color-background-main);
  border-radius: 50%;
  margin-bottom: var(--space-2);
  display: flex;
  align-items: center;
  justify-content: center;
}

.image {
  max-width: 100%;
  height: auto;
}

.chainIndicator {
  width: 100%;
  height: 4px;
  background-color: var(--color-background-main);
  border-radius: 5px;
}

.chainIndicatorColor {
  display: block;
  height: 100%;
  border-radius: 5px;
}
</file>

<file path="src/features/spaces/components/InitialsAvatar/index.tsx">
import { Box, hslToRgb } from '@mui/material'
import css from 'src/features/spaces/components/InitialsAvatar/styles.module.css'

/**
 * Returns a deterministic "random" color (in Hex format) based on a string.
 * The color is constrained so it won't be too dark or too light or too saturated.
 */
export function getDeterministicColor(str: string): string {
  const sum = [...str].reduce((acc, char) => acc + char.charCodeAt(0), 0)

  const hue = sum % 360
  const saturation = 40 + (sum % 31)
  const lightness = 40 + (sum % 31)

  return hslToRgb(`hsl(${hue}, ${saturation}, ${lightness})`)
}

const InitialsAvatar = ({
  name,
  size = 'large',
  rounded = false,
}: {
  name: string
  size?: 'xsmall' | 'small' | 'medium' | 'large'
  rounded?: boolean
}) => {
  const logoLetters = name.slice(0, 1)
  const logoColor = getDeterministicColor(name)
  const dimensions = {
    xsmall: { width: 20, height: 20, fontSize: '12px !important' },
    small: { width: 24, height: 24, fontSize: '12px !important' },
    medium: { width: 32, height: 32, fontSize: '16px !important' },
    large: { width: 48, height: 48, fontSize: '20px !important' },
  }

  const { width, height, fontSize } = dimensions[size]

  return (
    <Box
      className={css.initialsAvatar}
      bgcolor={logoColor}
      width={width}
      height={height}
      fontSize={fontSize}
      borderRadius={rounded ? '50%' : '6px'}
    >
      {logoLetters}
    </Box>
  )
}

export default InitialsAvatar
</file>

<file path="src/features/spaces/components/InitialsAvatar/styles.module.css">
.initialsAvatar {
  grid-area: logo;
  text-transform: uppercase;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  justify-self: start;
}
</file>

<file path="src/features/spaces/components/InviteBanner/AcceptButton.tsx">
import { useState } from 'react'
import { Button } from '@mui/material'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import AcceptInviteDialog from './AcceptInviteDialog'
import css from './styles.module.css'

type AcceptButtonProps = {
  space: GetSpaceResponse
}

const AcceptButton = ({ space }: AcceptButtonProps) => {
  const [inviteOpen, setInviteOpen] = useState(false)

  const handleAcceptInvite = (e: React.MouseEvent) => {
    e.stopPropagation()
    e.preventDefault()
    setInviteOpen(true)
  }

  const handleCloseInviteDialog = () => {
    setInviteOpen(false)
  }

  return (
    <>
      <Button
        data-testid="accept-invite-button"
        className={css.inviteButton}
        variant="contained"
        onClick={handleAcceptInvite}
        aria-label="Accept invitation"
      >
        Accept
      </Button>
      {inviteOpen && <AcceptInviteDialog space={space} onClose={handleCloseInviteDialog} />}
    </>
  )
}

export default AcceptButton
</file>

<file path="src/features/spaces/components/InviteBanner/AcceptInviteDialog.tsx">
import {
  type GetSpaceResponse,
  useMembersAcceptInviteV1Mutation,
} from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useRouter } from 'next/router'
import { type ReactElement, useState } from 'react'
import { Alert, Box, Button, CircularProgress, DialogActions, DialogContent, Typography } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import ModalDialog from '@/components/common/ModalDialog'
import NameInput from '@/components/common/NameInput'
import { AppRoutes } from '@/config/routes'
import { useAppDispatch, useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'
import { showNotification } from '@/store/notificationsSlice'
import ExternalLink from '@/components/common/ExternalLink'

function AcceptInviteDialog({ space, onClose }: { space: GetSpaceResponse; onClose: () => void }): ReactElement {
  const [error, setError] = useState<string>()
  const [isSubmitting, setIsSubmitting] = useState(false)

  const dispatch = useAppDispatch()
  const router = useRouter()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { data: currentUser } = useUsersGetWithWalletsV1Query(undefined, { skip: !isUserSignedIn })
  const [acceptInvite] = useMembersAcceptInviteV1Mutation()
  const memberName = space.members.find((member) => member.user.id === currentUser?.id)?.name

  const methods = useForm<{ name: string }>({ mode: 'onChange', defaultValues: { name: memberName } })
  const { handleSubmit, formState } = methods

  const onSubmit = handleSubmit(async (data) => {
    setError(undefined)
    trackEvent({ ...SPACE_EVENTS.ACCEPT_INVITE_SUBMIT })

    try {
      setIsSubmitting(true)
      const response = await acceptInvite({ spaceId: space.id, acceptInviteDto: { name: data.name } })

      if (response.error) {
        throw response.error
      }

      if (router.pathname === AppRoutes.welcome.spaces) {
        router.push({ pathname: AppRoutes.spaces.index, query: { spaceId: space.id } })
      }

      onClose()

      dispatch(
        showNotification({
          message: `Accepted invite to ${space.name}`,
          variant: 'success',
          groupKey: 'accept-invite-success',
        }),
      )
    } catch (e) {
      setError('Failed accepting the invite. Please try again.')
    } finally {
      setIsSubmitting(false)
    }
  })

  return (
    <ModalDialog open onClose={onClose} dialogTitle="Accept invite" hideChainIndicator>
      <FormProvider {...methods}>
        <form onSubmit={onSubmit}>
          <DialogContent sx={{ py: 2 }}>
            <Box mb={2}>
              <NameInput data-testid="invite-name-input" label="Name" autoFocus name="name" required />
            </Box>
            <Typography variant="body2" color="text.secondary">
              How is my data processed? Read our <ExternalLink href={AppRoutes.privacy}>privacy policy</ExternalLink>
            </Typography>

            {error && (
              <Alert severity="error" sx={{ mt: 2 }}>
                {error}
              </Alert>
            )}
          </DialogContent>

          <DialogActions>
            <Button data-testid="cancel-btn" onClick={onClose}>
              Cancel
            </Button>
            <Button
              data-testid="confirm-accept-invite-button"
              type="submit"
              variant="contained"
              disabled={!formState.isValid}
              disableElevation
            >
              {isSubmitting ? <CircularProgress size={20} /> : 'Accept invite'}
            </Button>
          </DialogActions>
        </form>
      </FormProvider>
    </ModalDialog>
  )
}

export default AcceptInviteDialog
</file>

<file path="src/features/spaces/components/InviteBanner/DeclineButton.tsx">
import { useState } from 'react'
import { Button } from '@mui/material'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import DeclineInviteDialog from './DeclineInviteDialog'
import css from './styles.module.css'

type DeclineButtonProps = {
  space: GetSpaceResponse
}

const DeclineButton = ({ space }: DeclineButtonProps) => {
  const [declineOpen, setDeclineOpen] = useState(false)

  const handleDeclineInvite = (e: React.MouseEvent) => {
    e.stopPropagation()
    e.preventDefault()
    setDeclineOpen(true)
  }

  const handleCloseDeclineDialog = () => {
    setDeclineOpen(false)
  }

  return (
    <>
      <Button
        className={css.inviteButton}
        variant="outlined"
        onClick={handleDeclineInvite}
        aria-label="Decline invitation"
      >
        Decline
      </Button>
      {declineOpen && <DeclineInviteDialog space={space} onClose={handleCloseDeclineDialog} />}
    </>
  )
}

export default DeclineButton
</file>

<file path="src/features/spaces/components/InviteBanner/DeclineInviteDialog.tsx">
import { useState } from 'react'
import { Typography } from '@mui/material'
import { DialogContent, DialogActions, Button } from '@mui/material'
import ModalDialog from '@/components/common/ModalDialog'
import ErrorMessage from '@/components/tx/ErrorMessage'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useMembersDeclineInviteV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'

type DeclineInviteDialogProps = {
  space: GetSpaceResponse
  onClose: () => void
}

const DeclineInviteDialog = ({ space, onClose }: DeclineInviteDialogProps) => {
  const [errorMessage, setErrorMessage] = useState<string>('')
  const [declineInvite] = useMembersDeclineInviteV1Mutation()
  const dispatch = useAppDispatch()

  const handleConfirm = async () => {
    setErrorMessage('')
    trackEvent({ ...SPACE_EVENTS.DECLINE_INVITE_SUBMIT })
    try {
      const { error } = await declineInvite({ spaceId: space.id })

      if (error) {
        throw error
      }

      onClose()

      dispatch(
        showNotification({
          message: `Declined invite to ${space.name}`,
          variant: 'success',
          groupKey: 'decline-invite-success',
        }),
      )
    } catch (e) {
      setErrorMessage('An unexpected error occurred while declining the invitation.')
    }
  }

  return (
    <ModalDialog open onClose={onClose} dialogTitle="Decline invitation" hideChainIndicator>
      <DialogContent sx={{ p: '24px !important' }}>
        <Typography>
          Are you sure you want to decline the invitation to <b>{space.name}</b>?
        </Typography>
        {errorMessage && <ErrorMessage>{errorMessage}</ErrorMessage>}
      </DialogContent>

      <DialogActions>
        <Button data-testid="cancel-btn" onClick={onClose}>
          Cancel
        </Button>
        <Button data-testid="decline-btn" onClick={handleConfirm} variant="danger" disableElevation>
          Decline
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}

export default DeclineInviteDialog
</file>

<file path="src/features/spaces/components/InviteBanner/index.tsx">
import { Card, Box, Typography, Link as MUILink, Stack } from '@mui/material'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { SpaceSummary } from '../SpaceCard'
import { useSpaceSafeCount } from '@/features/spaces/hooks/useSpaceSafeCount'
import InitialsAvatar from '../InitialsAvatar'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'
import css from './styles.module.css'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import AcceptButton from './AcceptButton'
import DeclineButton from './DeclineButton'
import { trackEvent } from '@/services/analytics'
import { MemberStatus } from '@/features/spaces/hooks/useSpaceMembers'

type SpaceListInvite = {
  space: GetSpaceResponse
}

const SpaceListInvite = ({ space }: SpaceListInvite) => {
  const { id, name, members } = space
  const { currentData: currentUser } = useUsersGetWithWalletsV1Query()
  const numberOfAccounts = useSpaceSafeCount(id)
  const numberOfMembers = members.filter((member) => member.status === MemberStatus.ACTIVE).length

  const invitedBy = space.members.find((member) => member.user.id === currentUser?.id)?.invitedBy

  return (
    <Card sx={{ p: 2, mb: 2 }}>
      <Typography variant="h4" fontWeight={700} mb={2} color="primary.light">
        You were invited to join{' '}
        <Typography component="span" variant="h4" fontWeight={700} color="primary.main">
          {name}
        </Typography>
        {invitedBy && (
          <>
            {' '}
            by
            <Typography
              component="span"
              variant="h4"
              fontWeight={700}
              color="primary.main"
              position="relative"
              top="4px"
              ml="6px"
              display="inline-block"
              sx={{ '> div': { gap: '4px' } }}
            >
              <EthHashInfo address={invitedBy} avatarSize={24} showName={false} showPrefix={false} copyPrefix={false} />
            </Typography>
          </>
        )}
      </Typography>

      <Link href={{ pathname: AppRoutes.spaces.index, query: { spaceId: id } }} passHref legacyBehavior>
        <MUILink
          underline="none"
          sx={{ display: 'block' }}
          onClick={() => trackEvent({ ...SPACE_EVENTS.VIEW_INVITING_SPACE })}
        >
          <Card sx={{ p: 2, backgroundColor: 'background.main', '&:hover': { backgroundColor: 'background.light' } }}>
            <Box className={css.spacesListInviteContent}>
              <Stack direction="row" spacing={2} alignItems="center" flexGrow={1}>
                <Box>
                  <InitialsAvatar name={name} size="large" />
                </Box>

                <Box>
                  <SpaceSummary name={name} numberOfAccounts={numberOfAccounts} numberOfMembers={numberOfMembers} />
                </Box>
              </Stack>

              <Stack direction="row" spacing={1}>
                <Track {...SPACE_EVENTS.ACCEPT_INVITE} label={SPACE_LABELS.space_list_page}>
                  <AcceptButton space={space} />
                </Track>
                <Track {...SPACE_EVENTS.DECLINE_INVITE} label={SPACE_LABELS.space_list_page}>
                  <DeclineButton space={space} />
                </Track>
              </Stack>
            </Box>
          </Card>
        </MUILink>
      </Link>
    </Card>
  )
}

export default SpaceListInvite
</file>

<file path="src/features/spaces/components/InviteBanner/PreviewInvite.tsx">
import { Typography, Paper, Box, Stack } from '@mui/material'
import { useSpacesGetOneV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import InitialsAvatar from '../InitialsAvatar'
import css from './styles.module.css'
import { useCurrentSpaceId } from 'src/features/spaces/hooks/useCurrentSpaceId'
import { isAuthenticated } from '@/store/authSlice'
import { useAppSelector } from '@/store'
import AcceptButton from './AcceptButton'
import { SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import DeclineButton from './DeclineButton'
import EthHashInfo from '@/components/common/EthHashInfo'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import { useDarkMode } from '@/hooks/useDarkMode'

const PreviewInvite = () => {
  const isDarkMode = useDarkMode()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const spaceId = useCurrentSpaceId()
  const { currentData: currentUser } = useUsersGetWithWalletsV1Query()
  const { currentData: space } = useSpacesGetOneV1Query({ id: Number(spaceId) }, { skip: !isUserSignedIn || !spaceId })
  const invitedBy = space?.members.find((member) => member.user.id === currentUser?.id)?.invitedBy

  if (!space) return null

  return (
    <Paper sx={{ p: 2, mb: 4, backgroundColor: isDarkMode ? 'info.background' : 'info.light' }}>
      <Box className={css.previewInviteContent}>
        <InitialsAvatar name={space.name} size="medium" />
        <Typography variant="body1" color="text.primary" flexGrow={1}>
          You were invited to join <strong>{space.name}</strong>
          {invitedBy && (
            <>
              {' '}
              by
              <Typography
                component="span"
                variant="body1"
                fontWeight={700}
                color="primary.main"
                position="relative"
                top="4px"
                ml="6px"
                display="inline-block"
                sx={{ '> div': { gap: '4px' } }}
              >
                <EthHashInfo
                  address={invitedBy}
                  avatarSize={20}
                  showName={false}
                  showPrefix={false}
                  copyPrefix={false}
                />
              </Typography>
            </>
          )}
        </Typography>
        <Stack direction="row" spacing={1}>
          <Track {...SPACE_EVENTS.ACCEPT_INVITE} label={SPACE_LABELS.preview_banner}>
            <AcceptButton space={space} />
          </Track>
          <Track {...SPACE_EVENTS.DECLINE_INVITE} label={SPACE_LABELS.preview_banner}>
            <DeclineButton space={space} />
          </Track>
        </Stack>
      </Box>
    </Paper>
  )
}

export default PreviewInvite
</file>

<file path="src/features/spaces/components/InviteBanner/styles.module.css">
.previewInviteContent {
  display: flex;
  flex-direction: row;
  gap: var(--space-2);
}

.spacesListInviteContent {
  display: flex;
  flex-direction: row;
  gap: var(--space-2);
  align-items: center;
}

.inviteButtonContainer {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
}

.inviteButton {
  padding: 4px var(--space-2);
  min-height: 32px;
}

@media (max-width: 600px) {
  .previewInviteContent {
    flex-direction: column;
    gap: var(--space-1);
  }

  .spacesListInviteContent {
    flex-direction: column;
    gap: var(--space-1);
    align-items: flex-start;
  }

  .inviteButtonContainer {
    flex-direction: column;
    gap: var(--space-1);
    width: 100%;
  }

  .inviteButton {
    width: 100%;
    padding-top: var(--space-1);
    padding-bottom: var(--space-1);
    min-height: 40px;
  }
}
</file>

<file path="src/features/spaces/components/LoadingState/index.tsx">
import { Box, CircularProgress } from '@mui/material'

const LoadingState = () => {
  return (
    <Box display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
      <CircularProgress aria-label="Loading content" />
    </Box>
  )
}

export default LoadingState
</file>

<file path="src/features/spaces/components/Members/index.tsx">
import PlusIcon from '@/public/images/common/plus.svg'
import { Button, Stack, Typography } from '@mui/material'
import AddMemberModal from 'src/features/spaces/components/AddMemberModal'
import { useEffect, useState } from 'react'
import MembersList from '@/features/spaces/components/MembersList'
import { useMembersSearch } from '@/features/spaces/hooks/useMembersSearch'
import { useIsInvited, useSpaceMembersByStatus, useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import PreviewInvite from '../InviteBanner/PreviewInvite'
import { SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'
import SearchInput from '../SearchInput'

const SpaceMembers = () => {
  const [openAddMembersModal, setOpenAddMembersModal] = useState(false)
  const [searchQuery, setSearchQuery] = useState('')
  const { activeMembers, invitedMembers } = useSpaceMembersByStatus()
  const isAdmin = useIsAdmin()
  const isInvited = useIsInvited()

  const filteredMembers = useMembersSearch(activeMembers, searchQuery)
  const filteredInvites = useMembersSearch(invitedMembers, searchQuery)

  useEffect(() => {
    if (searchQuery) {
      trackEvent({ ...SPACE_EVENTS.SEARCH_MEMBERS })
    }
  }, [searchQuery])

  return (
    <>
      {isInvited && <PreviewInvite />}
      <Typography variant="h1" mb={3}>
        Members
      </Typography>
      <Stack
        direction="row"
        justifyContent="space-between"
        alignItems="flex-start"
        mb={3}
        flexWrap="nowrap"
        gap={2}
        flexDirection={{ xs: 'column-reverse', sm: 'row' }}
      >
        <SearchInput onSearch={setSearchQuery} />
        {isAdmin && (
          <Track {...SPACE_EVENTS.ADD_MEMBER_MODAL} label={SPACE_LABELS.members_page}>
            <Button
              data-testid="add-member-button"
              variant="contained"
              startIcon={<PlusIcon />}
              onClick={() => setOpenAddMembersModal(true)}
              sx={{ whiteSpace: 'nowrap' }}
            >
              Add member
            </Button>
          </Track>
        )}
      </Stack>
      <>
        {searchQuery && !filteredMembers.length && !filteredInvites.length && (
          <Typography variant="h5" fontWeight="normal" mb={2} color="primary.light">
            Found 0 results
          </Typography>
        )}
        {filteredInvites.length > 0 && (
          <>
            <Typography variant="h5" fontWeight={700} mb={2}>
              Pending invitations ({filteredInvites.length})
            </Typography>
            <MembersList members={filteredInvites} />
          </>
        )}
        {filteredMembers.length > 0 && (
          <>
            <Typography variant="h5" fontWeight={700} mb={2} mt={1}>
              All members ({filteredMembers.length})
            </Typography>
            <MembersList members={filteredMembers} />
          </>
        )}
      </>

      {openAddMembersModal && <AddMemberModal onClose={() => setOpenAddMembersModal(false)} />}
    </>
  )
}

export default SpaceMembers
</file>

<file path="src/features/spaces/components/MembersList/EditMemberDialog.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import { DialogContent, DialogActions, Button, Typography } from '@mui/material'
import { type Member, useMembersUpdateRoleV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { useState } from 'react'
import { FormProvider, useForm } from 'react-hook-form'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'
import MemberInfoForm from '@/features/spaces/components/AddMemberModal/MemberInfoForm'

type MemberField = {
  name: string
  role: Member['role']
}

const EditMemberDialog = ({ member, handleClose }: { member: Member; handleClose: () => void }) => {
  const spaceId = useCurrentSpaceId()
  const dispatch = useAppDispatch()
  const [editMember] = useMembersUpdateRoleV1Mutation()
  const [error, setError] = useState<string>()

  const methods = useForm<MemberField>({
    mode: 'onChange',
    defaultValues: {
      name: member.name,
      role: member.role,
    },
  })

  const { handleSubmit, formState } = methods

  const onSubmit = handleSubmit(async (data) => {
    setError(undefined)

    if (!spaceId) {
      setError('Something went wrong. Please try again.')
      return
    }

    try {
      const { error } = await editMember({
        spaceId: Number(spaceId),
        userId: member.user.id,
        updateRoleDto: {
          role: data.role,
        },
      })

      if (error) {
        throw error
      }

      dispatch(
        showNotification({
          message: `Updated role of ${data.name} to ${data.role}`,
          variant: 'success',
          groupKey: 'update-member-success',
        }),
      )

      handleClose()
    } catch (e) {
      setError('An unexpected error occurred while editing the member.')
    }
  })

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Edit member" hideChainIndicator>
      <FormProvider {...methods}>
        <form onSubmit={onSubmit}>
          <DialogContent sx={{ p: '24px !important' }}>
            <Typography mb={2}>
              Edit the role of <b>{`${member.name}`}</b> in this space.
            </Typography>

            <MemberInfoForm isEdit />
            {error && <ErrorMessage>{error}</ErrorMessage>}
          </DialogContent>

          <DialogActions>
            <Button data-testid="cancel-btn" onClick={handleClose}>
              Cancel
            </Button>
            <Button
              type="submit"
              data-testid="delete-btn"
              variant="danger"
              disableElevation
              disabled={!formState.isDirty}
            >
              Update
            </Button>
          </DialogActions>
        </form>
      </FormProvider>
    </ModalDialog>
  )
}

export default EditMemberDialog
</file>

<file path="src/features/spaces/components/MembersList/index.tsx">
import { Box, Chip, IconButton, Stack, SvgIcon, Tooltip } from '@mui/material'
import { type Member } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import EditIcon from '@/public/images/common/edit.svg'
import DeleteIcon from '@/public/images/common/delete.svg'
import EnhancedTable from '@/components/common/EnhancedTable'
import tableCss from '@/components/common/EnhancedTable/styles.module.css'
import MemberName from './MemberName'
import RemoveMemberDialog from './RemoveMemberDialog'
import { useState } from 'react'
import { MemberRole, useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import EditMemberDialog from '@/features/spaces/components/MembersList/EditMemberDialog'
import { MemberStatus } from '../../hooks/useSpaceMembers'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'

const headCells = [
  {
    id: 'name',
    label: 'Name',
    width: '70%',
  },
  {
    id: 'role',
    label: 'Role',
    width: '15%',
  },
  {
    id: 'actions',
    label: '',
    width: '15%',
    sticky: true,
  },
]

const EditButton = ({ member, disabled }: { member: Member; disabled: boolean }) => {
  const [open, setOpen] = useState(false)

  return (
    <>
      <Tooltip title={disabled ? 'Cannot edit role of last admin' : 'Edit member'} placement="top">
        <Box component="span">
          <IconButton onClick={() => setOpen(true)} size="small" disabled={disabled}>
            <SvgIcon component={EditIcon} inheritViewBox color="border" fontSize="small" />
          </IconButton>
        </Box>
      </Tooltip>
      {open && <EditMemberDialog member={member} handleClose={() => setOpen(false)} />}
    </>
  )
}

export const RemoveMemberButton = ({
  member,
  disabled,
  isInvite,
}: {
  member: Member
  disabled: boolean
  isInvite: boolean
}) => {
  const [openRemoveMemberDialog, setOpenRemoveMemberDialog] = useState(false)

  return (
    <>
      <Tooltip
        title={disabled ? 'Cannot remove last admin' : `Remove ${isInvite ? 'invitation' : 'member'}`}
        placement="top"
      >
        <Box component="span">
          <Track
            {...SPACE_EVENTS.REMOVE_MEMBER_MODAL}
            label={isInvite ? SPACE_LABELS.invite_list : SPACE_LABELS.member_list}
          >
            <IconButton disabled={disabled} onClick={() => setOpenRemoveMemberDialog(true)} size="small">
              <SvgIcon component={DeleteIcon} inheritViewBox color={disabled ? 'disabled' : 'error'} fontSize="small" />
            </IconButton>
          </Track>
        </Box>
      </Tooltip>
      {openRemoveMemberDialog && (
        <RemoveMemberDialog
          userId={member.user.id}
          memberName={member.name}
          handleClose={() => setOpenRemoveMemberDialog(false)}
          isInvite={isInvite}
        />
      )}
    </>
  )
}

const MembersList = ({ members }: { members: Member[] }) => {
  const isAdmin = useIsAdmin()
  const adminCount = members.filter((member) => member.role === MemberRole.ADMIN).length

  const rows = members.map((member) => {
    const isLastAdmin = adminCount === 1 && member.role === MemberRole.ADMIN
    const isInvite = member.status === MemberStatus.INVITED || member.status === MemberStatus.DECLINED
    const isDeclined = member.status === MemberStatus.DECLINED
    const isDisabled = isAdmin && isLastAdmin && !isInvite

    return {
      cells: {
        name: {
          rawValue: member.name,
          content: (
            <Stack direction="row" alignItems="center" justifyContent="left" gap={1}>
              <MemberName member={member} />
              {isDeclined && (
                <Chip
                  label="Declined"
                  size="small"
                  sx={{ backgroundColor: 'error.light', color: 'static.main', borderRadius: 0.5 }}
                />
              )}
            </Stack>
          ),
        },
        role: {
          rawValue: member.role,
          content: (
            <Chip
              size="small"
              label={member.role === MemberRole.ADMIN ? 'Admin' : 'Member'}
              sx={{ backgroundColor: 'background.lightgrey', borderRadius: 0.5 }}
            />
          ),
        },
        actions: {
          rawValue: '',
          sticky: true,
          content: isAdmin ? (
            <div className={tableCss.actions}>
              {!isInvite && <EditButton member={member} disabled={isDisabled} />}
              <RemoveMemberButton member={member} disabled={isDisabled} isInvite={isInvite} />
            </div>
          ) : null,
        },
      },
    }
  })

  if (!rows.length) {
    return null
  }

  return <EnhancedTable rows={rows} headCells={headCells} />
}

export default MembersList
</file>

<file path="src/features/spaces/components/MembersList/MemberName.tsx">
import InitialsAvatar from '../InitialsAvatar'
import { Stack, Typography } from '@mui/material'
import type { Member } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'

const MemberName = ({ member }: { member: Member }) => {
  const { currentData: user } = useUsersGetWithWalletsV1Query()
  const isCurrentUser = member.user.id === user?.id

  return (
    <Stack direction="row" spacing={1} alignItems="center" key={member.id}>
      <InitialsAvatar size="medium" name={member.name || ''} rounded />
      <Typography variant="body2">
        {member.name}{' '}
        {isCurrentUser && (
          <Typography variant="body2" component="span" color="text.secondary" ml={1}>
            you
          </Typography>
        )}
      </Typography>
    </Stack>
  )
}

export default MemberName
</file>

<file path="src/features/spaces/components/MembersList/RemoveMemberDialog.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import { DialogContent, DialogActions, Button, Typography } from '@mui/material'
import { useMembersRemoveUserV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import ErrorMessage from '@/components/tx/ErrorMessage'
import { useState } from 'react'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'

const RemoveMemberDialog = ({
  userId,
  memberName,
  handleClose,
  isInvite = false,
}: {
  userId: number
  memberName: string
  handleClose: () => void
  isInvite?: boolean
}) => {
  const spaceId = useCurrentSpaceId()
  const dispatch = useAppDispatch()
  const [deleteMember] = useMembersRemoveUserV1Mutation()
  const [errorMessage, setErrorMessage] = useState<string>('')

  const handleConfirm = async () => {
    setErrorMessage('')
    trackEvent({ ...SPACE_EVENTS.REMOVE_MEMBER, label: isInvite ? SPACE_LABELS.invite_list : SPACE_LABELS.member_list })
    try {
      const { error } = await deleteMember({ spaceId: Number(spaceId), userId })

      if (error) {
        throw error
      }

      dispatch(
        showNotification({
          message: `Removed ${memberName} from space`,
          variant: 'success',
          groupKey: 'remove-member-success',
        }),
      )

      handleClose()
    } catch (e) {
      setErrorMessage('An unexpected error occurred while removing the member.')
    }
  }

  return (
    <ModalDialog
      open
      onClose={handleClose}
      dialogTitle={isInvite ? 'Remove invitation' : 'Remove member'}
      hideChainIndicator
    >
      <DialogContent sx={{ p: '24px !important' }}>
        <Typography>
          {isInvite ? `Are you sure you want to remove the invitation for ` : `Are you sure you want to remove `}
          <b>{memberName}</b>
          {isInvite ? `` : ` from this space?`}
        </Typography>
        {errorMessage && <ErrorMessage>{errorMessage}</ErrorMessage>}
      </DialogContent>

      <DialogActions>
        <Button data-testid="cancel-btn" onClick={handleClose}>
          Cancel
        </Button>
        <Button data-testid="delete-btn" onClick={handleConfirm} variant="danger" disableElevation>
          Remove
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}

export default RemoveMemberDialog
</file>

<file path="src/features/spaces/components/SafeAccounts/EmptySafeAccounts.tsx">
import { Card, Typography } from '@mui/material'
import SafeAccountsIcon from '@/public/images/spaces/safe-accounts.svg'

const EmptySafeAccounts = () => {
  return (
    <>
      <Card sx={{ p: 5, textAlign: 'center' }}>
        <SafeAccountsIcon />

        <Typography color="text.secondary" mb={2}>
          Add existing Safe Accounts in your space to see them here.
        </Typography>
      </Card>
    </>
  )
}

export default EmptySafeAccounts
</file>

<file path="src/features/spaces/components/SafeAccounts/index.tsx">
import AddAccounts from '@/features/spaces/components/AddAccounts'
import EmptySafeAccounts from '@/features/spaces/components/SafeAccounts/EmptySafeAccounts'
import { Stack, Typography } from '@mui/material'
import { useEffect, useState } from 'react'
import SafesList from '@/features/myAccounts/components/SafesList'
import { useSpaceSafes } from '@/features/spaces/hooks/useSpaceSafes'
import { useSafesSearch } from '@/features/myAccounts/hooks/useSafesSearch'
import { useIsAdmin, useIsInvited } from '@/features/spaces/hooks/useSpaceMembers'
import PreviewInvite from '../InviteBanner/PreviewInvite'
import { SPACE_LABELS } from '@/services/analytics/events/spaces'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import { trackEvent } from '@/services/analytics'
import SearchInput from '../SearchInput'

const SpaceSafeAccounts = () => {
  const [searchQuery, setSearchQuery] = useState('')
  const { allSafes } = useSpaceSafes()
  const filteredSafes = useSafesSearch(allSafes ?? [], searchQuery)
  const isAdmin = useIsAdmin()
  const isInvited = useIsInvited()

  const safes = searchQuery ? filteredSafes : allSafes

  useEffect(() => {
    if (searchQuery) {
      trackEvent({ ...SPACE_EVENTS.SEARCH_ACCOUNTS, label: SPACE_LABELS.accounts_page })
    }
  }, [searchQuery])

  return (
    <>
      {isInvited && <PreviewInvite />}
      <Typography variant="h1" mb={3}>
        Safe Accounts
      </Typography>
      <Stack
        direction="row"
        justifyContent="space-between"
        alignItems="flex-start"
        gap={2}
        mb={3}
        flexWrap="nowrap"
        flexDirection={{ xs: 'column-reverse', md: 'row' }}
      >
        <SearchInput onSearch={setSearchQuery} />

        {isAdmin && (
          <Track {...SPACE_EVENTS.ADD_ACCOUNTS_MODAL} label={SPACE_LABELS.accounts_page}>
            <AddAccounts />
          </Track>
        )}
      </Stack>

      {searchQuery && filteredSafes.length === 0 ? (
        <Typography variant="h5" fontWeight="normal" mb={2} color="primary.light">
          Found 0 results
        </Typography>
      ) : safes.length === 0 ? (
        <EmptySafeAccounts />
      ) : (
        <SafesList safes={safes} isSpaceSafe />
      )}
    </>
  )
}

export default SpaceSafeAccounts
</file>

<file path="src/features/spaces/components/SafeAccounts/RemoveSafeDialog.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import type { MultiChainSafeItem } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { Alert } from '@mui/material'
import Button from '@mui/material/Button'
import DialogActions from '@mui/material/DialogActions'
import DialogContent from '@mui/material/DialogContent'
import Typography from '@mui/material/Typography'
import { useSpaceSafesDeleteV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useState } from 'react'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'

function getToBeDeletedSafeAccounts(safeItem: SafeItem | MultiChainSafeItem) {
  if (isMultiChainSafeItem(safeItem)) {
    return safeItem.safes.map((safe) => ({ chainId: safe.chainId, address: safe.address }))
  }

  return [{ chainId: safeItem.chainId, address: safeItem.address }]
}

const RemoveSafeDialog = ({
  safeItem,
  handleClose,
}: {
  safeItem: SafeItem | MultiChainSafeItem
  handleClose: () => void
}) => {
  const { address } = safeItem
  const spaceId = useCurrentSpaceId()
  const dispatch = useAppDispatch()
  const [removeSafeAccounts] = useSpaceSafesDeleteV1Mutation()
  const [error, setError] = useState('')

  const handleConfirm = async () => {
    const safeAccounts = getToBeDeletedSafeAccounts(safeItem)
    trackEvent({ ...SPACE_EVENTS.DELETE_ACCOUNT })

    try {
      const result = await removeSafeAccounts({
        spaceId: Number(spaceId),
        deleteSpaceSafesDto: { safes: safeAccounts },
      })

      if (result.error) {
        throw result.error
      }

      dispatch(
        showNotification({
          message: `Removed safe account from space`,
          variant: 'success',
          groupKey: 'remove-safe-account-success',
        }),
      )
    } catch (e) {
      setError('Error removing safe account.')
    }
  }

  return (
    <ModalDialog open onClose={handleClose} dialogTitle="Remove Safe Account" hideChainIndicator>
      <DialogContent sx={{ p: '24px !important' }}>
        <Typography>
          Are you sure you want to remove <b>{address}</b> from this space?
        </Typography>
        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {error}
          </Alert>
        )}
      </DialogContent>

      <DialogActions>
        <Button data-testid="cancel-btn" onClick={handleClose}>
          Cancel
        </Button>
        <Button data-testid="delete-btn" onClick={handleConfirm} variant="danger" disableElevation>
          Remove
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}

export default RemoveSafeDialog
</file>

<file path="src/features/spaces/components/SafeAccounts/SendTransactionButton.tsx">
import { useContext } from 'react'
import { IconButton, Tooltip } from '@mui/material'
import { useRouter } from 'next/router'
import ArrowOutwardIcon from '@/public/images/transactions/outgoing.svg'
import css from './styles.module.css'
import { TxModalContext } from '@/components/tx-flow'
import { TokenTransferFlow } from '@/components/tx-flow/flows'
import { networks } from '@safe-global/protocol-kit/dist/src/utils/eip-3770/config'
import type { SafeOverview } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import useWallet from '@/hooks/wallets/useWallet'
import { isOwner } from '@/utils/transaction-guards'
import type { AddressEx } from '@safe-global/safe-gateway-typescript-sdk'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'
import { gtmSetSafeAddress } from '@/services/analytics/gtm'

type Chains = Record<string, string>

const chains = networks.reduce<Chains>((result, { shortName, chainId }) => {
  result[chainId.toString()] = shortName.toString()
  return result
}, {})

const SendTransactionButton = ({ safe }: { safe: SafeOverview }) => {
  const router = useRouter()
  const wallet = useWallet()
  const canSend = isOwner(safe.owners as AddressEx[], wallet?.address)

  const { setTxFlow } = useContext(TxModalContext)

  const setActiveSafe = async () => {
    const shortname = chains[safe.chainId]

    await router.replace({
      pathname: router.pathname,
      query: {
        ...router.query,
        safe: `${shortname}:${safe.address.value}`,
        chain: shortname,
      },
    })
  }

  const resetActiveSafe = async () => {
    await router.replace({
      pathname: router.pathname,
      query: {
        ...router.query,
        safe: undefined,
        chain: undefined,
      },
    })
  }

  const onNewTxClick = async () => {
    await setActiveSafe()
    // We have to set it explicitly otherwise its missing in the trackEvent below
    gtmSetSafeAddress(safe.address.value)
    trackEvent(SPACE_EVENTS.CREATE_SPACE_TX)

    setTxFlow(<TokenTransferFlow />, resetActiveSafe, false)
  }

  return (
    <Tooltip placement="top" title={canSend ? 'Send tokens' : 'You are not a signer of this Safe Account'}>
      <span>
        <IconButton className={css.sendButton} size="medium" onClick={onNewTxClick} disabled={!canSend}>
          <ArrowOutwardIcon />
        </IconButton>
      </span>
    </Tooltip>
  )
}

export default SendTransactionButton
</file>

<file path="src/features/spaces/components/SafeAccounts/SpaceSafeContextMenu.tsx">
import type { SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import type { MultiChainSafeItem } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import RemoveSafeDialog from '@/features/spaces/components/SafeAccounts/RemoveSafeDialog'
import { type MouseEvent, useState } from 'react'
import MoreVertIcon from '@mui/icons-material/MoreVert'
import { SvgIcon } from '@mui/material'
import IconButton from '@mui/material/IconButton'
import ListItemIcon from '@mui/material/ListItemIcon'
import ListItemText from '@mui/material/ListItemText'
import MenuItem from '@mui/material/MenuItem'
import ContextMenu from '@/components/common/ContextMenu'
import DeleteIcon from '@/public/images/common/delete.svg'
import EditIcon from '@/public/images/common/edit.svg'
import EntryDialog from '@/components/address-book/EntryDialog'
import { useAppSelector } from '@/store'
import { selectAllAddressBooks } from '@/store/addressBookSlice'
import { isMultiChainSafeItem } from '@/features/multichain/utils/utils'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'
import { useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'

enum ModalType {
  RENAME = 'rename',
  REMOVE = 'remove',
}

const defaultOpen = { [ModalType.RENAME]: false, [ModalType.REMOVE]: false }

const SpaceSafeContextMenu = ({ safeItem }: { safeItem: SafeItem | MultiChainSafeItem }) => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | undefined>()
  const [open, setOpen] = useState<typeof defaultOpen>(defaultOpen)
  const isAdmin = useIsAdmin()

  const allAddressBooks = useAppSelector(selectAllAddressBooks)
  const chainIds = isMultiChainSafeItem(safeItem) ? safeItem.safes.map((safe) => safe.chainId) : [safeItem.chainId]
  const name = isMultiChainSafeItem(safeItem) ? safeItem.name : allAddressBooks[safeItem.chainId]?.[safeItem.address]
  const hasName = !!name

  const handleOpenContextMenu = (e: MouseEvent<HTMLButtonElement, globalThis.MouseEvent>) => {
    e.stopPropagation()
    setAnchorEl(e.currentTarget)
  }

  const handleCloseContextMenu = (e: Event) => {
    e.stopPropagation()
    setAnchorEl(undefined)
  }

  const handleOpenModal = (e: MouseEvent, type: keyof typeof open) => {
    e.stopPropagation()
    if (type === ModalType.REMOVE) trackEvent({ ...SPACE_EVENTS.DELETE_ACCOUNT_MODAL })
    setAnchorEl(undefined)
    setOpen((prev) => ({ ...prev, [type]: true }))
  }

  const handleCloseModal = () => {
    setOpen(defaultOpen)
  }

  return (
    <>
      <IconButton edge="end" size="small" onClick={handleOpenContextMenu}>
        <MoreVertIcon sx={({ palette }) => ({ color: palette.border.main })} />
      </IconButton>
      <ContextMenu anchorEl={anchorEl} open={!!anchorEl} onClose={handleCloseContextMenu}>
        <MenuItem onClick={(e) => handleOpenModal(e, ModalType.RENAME)}>
          <ListItemIcon>
            <SvgIcon component={EditIcon} inheritViewBox fontSize="small" color="success" />
          </ListItemIcon>
          <ListItemText>{hasName ? 'Rename' : 'Give name'}</ListItemText>
        </MenuItem>

        {isAdmin && (
          <MenuItem onClick={(e) => handleOpenModal(e, ModalType.REMOVE)}>
            <ListItemIcon>
              <SvgIcon component={DeleteIcon} inheritViewBox fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText>Remove</ListItemText>
          </MenuItem>
        )}
      </ContextMenu>

      {open[ModalType.RENAME] && (
        <EntryDialog
          handleClose={handleCloseModal}
          defaultValues={{ name: name || '', address: safeItem.address }}
          chainIds={chainIds}
          currentChainId={isMultiChainSafeItem(safeItem) ? undefined : chainIds[0]}
          disableAddressInput
        />
      )}

      {open[ModalType.REMOVE] && <RemoveSafeDialog safeItem={safeItem} handleClose={handleCloseModal} />}
    </>
  )
}

export default SpaceSafeContextMenu
</file>

<file path="src/features/spaces/components/SafeAccounts/styles.module.css">
.sendButton {
  background-color: var(--color-background-main);
  border-radius: 3px;
  margin: 0 var(--space-1);
}

.sendButton:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

[data-theme='dark'] .sendButton:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.sendButton svg path {
  fill: var(--color-text-primary);
}

.sendButton:global(.Mui-disabled) {
  background-color: var(--color-background-main);
}

.sendButton:global(.Mui-disabled) svg path {
  fill: var(--color-border-main);
}
</file>

<file path="src/features/spaces/components/SearchInput/index.tsx">
import { InputAdornment, SvgIcon, TextField } from '@mui/material'
import SearchIcon from '@/public/images/common/search.svg'
import { useCallback } from 'react'
import { debounce } from 'lodash'

interface SearchInputProps {
  placeholder?: string
  onSearch: (value: string) => void
  debounceTime?: number
}

const SearchInput = ({ onSearch, debounceTime = 300 }: SearchInputProps) => {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const handleSearch = useCallback(debounce(onSearch, debounceTime), [onSearch, debounceTime])

  return (
    <TextField
      aria-label="Search"
      placeholder="Search"
      variant="filled"
      hiddenLabel
      onChange={(e) => {
        handleSearch(e.target.value)
      }}
      InputProps={{
        startAdornment: (
          <InputAdornment position="start">
            <SvgIcon component={SearchIcon} inheritViewBox color="border" fontSize="small" data-testid="search-icon" />
          </InputAdornment>
        ),
        disableUnderline: true,
      }}
      size="small"
      sx={{
        transition: 'width 0.15s ease-in-out',
        width: { xs: '100%', sm: '250px' },
        '&:focus-within': {
          width: { xs: '100%', sm: '470px' },
        },
      }}
    />
  )
}

export default SearchInput
</file>

<file path="src/features/spaces/components/SignedOutState/index.tsx">
import { Box, Typography } from '@mui/material'
import css from '@/features/spaces/components/Dashboard/styles.module.css'
import SignInButton from '@/features/spaces/components/SignInButton'

const SignedOutState = () => {
  return (
    <Box className={css.content}>
      <Box textAlign="center" className={css.contentWrapper}>
        <Box className={css.contentInner}>
          <Typography fontWeight={700} mb={2}>
            Sign in to see content
          </Typography>

          <Typography color="text.secondary" mb={2}>
            To view and interact with spaces, you need to sign in with the wallet, that is a member of the space. Sign
            in to continue.
          </Typography>

          <SignInButton />
        </Box>
      </Box>
    </Box>
  )
}

export default SignedOutState
</file>

<file path="src/features/spaces/components/SignInButton/index.tsx">
import WalletLogin from '@/components/welcome/WelcomeLogin/WalletLogin'
import { OVERVIEW_EVENTS, OVERVIEW_LABELS, trackEvent } from '@/services/analytics'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import { useSiwe } from '@/services/siwe/useSiwe'
import { useAppDispatch } from '@/store'
import { setAuthenticated } from '@/store/authSlice'
import { showNotification } from '@/store/notificationsSlice'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'

const SignInButton = () => {
  const dispatch = useAppDispatch()
  const { signIn } = useSiwe()

  const handleLogin = () => {
    trackEvent({ ...OVERVIEW_EVENTS.OPEN_ONBOARD, label: OVERVIEW_LABELS.space_list_page })
  }

  const handleSignIn = async () => {
    trackEvent({ ...SPACE_EVENTS.SIGN_IN_BUTTON, label: SPACE_LABELS.space_list_page })

    try {
      const result = await signIn()

      if (result && result.error) {
        throw result.error
      }

      if (result) {
        const oneDayInMs = 24 * 60 * 60 * 1000
        dispatch(setAuthenticated(Date.now() + oneDayInMs))
      }
    } catch (error) {
      logError(ErrorCodes._640)

      dispatch(
        showNotification({
          message: `Something went wrong while trying to sign in`,
          variant: 'error',
          groupKey: 'sign-in-failed',
        }),
      )
    }
  }

  return <WalletLogin onLogin={handleLogin} onContinue={handleSignIn} buttonText="Sign in with" />
}

export default SignInButton
</file>

<file path="src/features/spaces/components/SpaceBreadcrumbs/index.tsx">
import { useRouter } from 'next/router'
import css from './styles.module.css'
import { IconButton, SvgIcon, Typography } from '@mui/material'
import { useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import SpaceIcon from '@/public/images/spaces/space.svg'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'
import { useSpaceSafesGetV1Query, useSpacesGetOneV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import InitialsAvatar from '@/features/spaces/components/InitialsAvatar'
import { BreadcrumbItem } from '@/components/common/Breadcrumbs/BreadcrumbItem'
import { useParentSafe } from '@/hooks/useParentSafe'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import { useHasFeature } from '@/hooks/useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'
import Track from '@/components/common/Track'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import { useSafeAddressFromUrl } from '@/hooks/useSafeAddressFromUrl'
import useChainId from '@/hooks/useChainId'
import { useMemo } from 'react'

const SpaceBreadcrumbs = () => {
  const isSpacesFeatureEnabled = useHasFeature(FEATURES.SPACES)
  const { pathname } = useRouter()
  const spaceId = useCurrentSpaceId()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData: space } = useSpacesGetOneV1Query({ id: Number(spaceId) }, { skip: !isUserSignedIn || !spaceId })
  const { currentData: safes } = useSpaceSafesGetV1Query(
    { spaceId: Number(spaceId) },
    { skip: !isUserSignedIn || !spaceId },
  )
  const safeAddress = useSafeAddressFromUrl()
  const chainId = useChainId()
  const parentSafe = useParentSafe()
  const isSpaceRoute = pathname.startsWith(AppRoutes.spaces.index) || pathname.startsWith(AppRoutes.welcome.spaces)

  const isSafePartOfSpace = useMemo(
    () => safes && Object.entries(safes.safes).some((safe) => safe[0] === chainId && safe[1].includes(safeAddress)),
    [chainId, safeAddress, safes],
  )

  if (!isUserSignedIn || !spaceId || isSpaceRoute || !space || !isSpacesFeatureEnabled || !isSafePartOfSpace) {
    return null
  }

  return (
    <>
      <Track {...SPACE_EVENTS.OPEN_SPACE_LIST_PAGE} label={SPACE_LABELS.space_breadcrumbs}>
        <Link href={{ pathname: AppRoutes.welcome.spaces }} passHref>
          <IconButton size="small">
            <SvgIcon component={SpaceIcon} inheritViewBox sx={{ fill: 'none' }} fontSize="small" color="primary" />
          </IconButton>
        </Link>
      </Track>

      <Typography variant="body2">/</Typography>

      <Track {...SPACE_EVENTS.OPEN_SPACE_DASHBOARD} label={SPACE_LABELS.space_breadcrumbs}>
        <Link href={{ pathname: AppRoutes.spaces.index, query: { spaceId } }} passHref className={css.spaceName}>
          <InitialsAvatar name={space.name} size="xsmall" />
          <Typography variant="body2" fontWeight="bold">
            {space.name}
          </Typography>
        </Link>
      </Track>

      <Typography variant="body2">/</Typography>

      {/* In case the nested breadcrumbs are not rendered we want to show the current safe address */}
      {!parentSafe && <BreadcrumbItem title="Current Safe" address={safeAddress} />}
    </>
  )
}

export default SpaceBreadcrumbs
</file>

<file path="src/features/spaces/components/SpaceBreadcrumbs/styles.module.css">
.spaceName {
  display: flex;
  gap: 4px;
  align-items: center;
}
</file>

<file path="src/features/spaces/components/SpaceCard/index.tsx">
import { AppRoutes } from '@/config/routes'
import { Box, Card, Stack, Typography } from '@mui/material'
import Link from 'next/link'

import css from './styles.module.css'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import classNames from 'classnames'
import { useSpaceSafeCount } from '@/features/spaces/hooks/useSpaceSafeCount'
import InitialsAvatar from '@/features/spaces/components/InitialsAvatar'
import SpaceContextMenu from '@/features/spaces/components/SpaceCard/SpaceContextMenu'
import { MemberStatus, useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import { maybePlural } from '@safe-global/utils/utils/formatters'

export const SpaceSummary = ({
  name,
  numberOfAccounts,
  numberOfMembers,
  isCompact = false,
}: {
  name: string
  numberOfAccounts: number
  numberOfMembers: number
  isCompact?: boolean
}) => {
  return (
    <Box className={css.spaceInfo}>
      <Typography variant="body2" fontWeight="bold">
        {name}
      </Typography>

      <Stack direction="row" spacing={1} alignItems="center" mt={isCompact ? 0 : 0.5}>
        <Typography variant="caption" color="text.secondary">
          {numberOfAccounts} Account{maybePlural(numberOfAccounts)}
        </Typography>

        <div className={css.dot} />

        <Typography variant="caption" color="text.secondary">
          {numberOfMembers} Member{maybePlural(numberOfMembers)}
        </Typography>
      </Stack>
    </Box>
  )
}

const SpaceCard = ({
  space,
  isCompact = false,
  isLink = true,
}: {
  space: GetSpaceResponse
  isCompact?: boolean
  isLink?: boolean
}) => {
  const { id, name, members } = space
  const numberOfMembers = members.filter((member) => member.status === MemberStatus.ACTIVE).length
  const numberOfAccounts = useSpaceSafeCount(id)
  const isAdmin = useIsAdmin(id)

  return (
    <Card data-testid="space-card" className={classNames(css.card, { [css.compact]: isCompact })}>
      {isLink && <Link className={css.cardLink} href={{ pathname: AppRoutes.spaces.index, query: { spaceId: id } }} />}

      <InitialsAvatar name={name} size={isCompact ? 'medium' : 'large'} />

      <SpaceSummary
        name={name}
        numberOfAccounts={numberOfAccounts}
        numberOfMembers={numberOfMembers}
        isCompact={isCompact}
      />

      {isAdmin && <SpaceContextMenu space={space} />}
    </Card>
  )
}

export default SpaceCard
</file>

<file path="src/features/spaces/components/SpaceCard/SpaceContextMenu.tsx">
import { type MouseEvent, useState } from 'react'
import MoreVertIcon from '@mui/icons-material/MoreVert'
import { SvgIcon } from '@mui/material'
import IconButton from '@mui/material/IconButton'
import ListItemIcon from '@mui/material/ListItemIcon'
import ListItemText from '@mui/material/ListItemText'
import MenuItem from '@mui/material/MenuItem'
import ContextMenu from '@/components/common/ContextMenu'
import DeleteIcon from '@/public/images/common/delete.svg'
import EditIcon from '@/public/images/common/edit.svg'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import css from './styles.module.css'
import DeleteSpaceDialog from '@/features/spaces/components/SpaceSettings/DeleteSpaceDialog'
import UpdateSpaceDialog from '@/features/spaces/components/SpaceSettings/UpdateSpaceDialog'
import Track from '@/components/common/Track'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'

enum ModalType {
  RENAME = 'rename',
  REMOVE = 'remove',
}

const defaultOpen = { [ModalType.RENAME]: false, [ModalType.REMOVE]: false }

const SpaceContextMenu = ({ space }: { space: GetSpaceResponse }) => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | undefined>()
  const [open, setOpen] = useState<typeof defaultOpen>(defaultOpen)

  const handleOpenContextMenu = (e: MouseEvent<HTMLButtonElement, globalThis.MouseEvent>) => {
    e.stopPropagation()
    setAnchorEl(e.currentTarget)
  }

  const handleCloseContextMenu = (e: Event) => {
    e.stopPropagation()
    setAnchorEl(undefined)
  }

  const handleOpenModal = (e: MouseEvent, type: keyof typeof open) => {
    e.stopPropagation()
    setAnchorEl(undefined)
    setOpen((prev) => ({ ...prev, [type]: true }))
  }

  const handleCloseModal = () => {
    setOpen(defaultOpen)
  }

  return (
    <>
      <IconButton className={css.spaceActions} size="small" onClick={handleOpenContextMenu}>
        <MoreVertIcon sx={({ palette }) => ({ color: palette.border.main })} />
      </IconButton>
      <ContextMenu anchorEl={anchorEl} open={!!anchorEl} onClose={handleCloseContextMenu}>
        <MenuItem onClick={(e) => handleOpenModal(e, ModalType.RENAME)}>
          <ListItemIcon>
            <SvgIcon component={EditIcon} inheritViewBox fontSize="small" color="success" />
          </ListItemIcon>
          <ListItemText>Rename</ListItemText>
        </MenuItem>

        <Track {...SPACE_EVENTS.DELETE_SPACE_MODAL} label={SPACE_LABELS.space_context_menu}>
          <MenuItem data-testid="remove-button" onClick={(e) => handleOpenModal(e, ModalType.REMOVE)}>
            <ListItemIcon>
              <SvgIcon component={DeleteIcon} inheritViewBox fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText>Remove</ListItemText>
          </MenuItem>
        </Track>
      </ContextMenu>

      {open[ModalType.RENAME] && <UpdateSpaceDialog space={space} onClose={handleCloseModal} />}

      {open[ModalType.REMOVE] && <DeleteSpaceDialog space={space} onClose={handleCloseModal} />}
    </>
  )
}

export default SpaceContextMenu
</file>

<file path="src/features/spaces/components/SpaceCard/styles.module.css">
.card {
  position: relative;
  flex-basis: 50%;
  display: grid;
  grid-template-areas:
    'logo logo actions'
    'info info actions';
  grid-template-columns: auto 1fr auto;
  gap: 8px;
  padding: var(--space-2);
}

.card.compact {
  grid-template-areas:
    'logo info actions'
    'logo info actions';
  grid-template-columns: auto 1fr auto;
  padding: var(--space-1);
  padding-left: 12px;
  border: 0;
}

.initialsAvatar {
  grid-area: logo;
  text-transform: uppercase;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  justify-self: start;
}

.spaceInfo {
  grid-area: info;
}

.dot {
  width: 2px;
  height: 2px;
  background-color: var(--color-border-main);
  border-radius: 50%;
}

.spaceActions {
  grid-area: actions;
  align-self: start;
}

.cardLink {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}
</file>

<file path="src/features/spaces/components/SpaceCreationModal/index.tsx">
import { useSpacesCreateWithUserV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useRouter } from 'next/router'
import { type ReactElement, useState } from 'react'
import { Alert, Box, Button, CircularProgress, DialogActions, DialogContent, SvgIcon, Typography } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import SpaceIcon from '@/public/images/spaces/space.svg'
import ModalDialog from '@/components/common/ModalDialog'
import NameInput from '@/components/common/NameInput'
import { AppRoutes } from '@/config/routes'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'
import ExternalLink from '@/components/common/ExternalLink'

function SpaceCreationModal({ onClose }: { onClose: () => void }): ReactElement {
  const [error, setError] = useState<string>()
  const [isSubmitting, setIsSubmitting] = useState(false)
  const router = useRouter()
  const dispatch = useAppDispatch()
  const methods = useForm<{ name: string }>({ mode: 'onChange' })
  const [createSpaceWithUser] = useSpacesCreateWithUserV1Mutation()
  const { handleSubmit, formState } = methods

  const onSubmit = handleSubmit(async (data) => {
    setError(undefined)

    try {
      setIsSubmitting(true)
      trackEvent({ ...SPACE_EVENTS.CREATE_SPACE })
      const response = await createSpaceWithUser({ createSpaceDto: { name: data.name } })

      if (response.data) {
        const spaceId = response.data.id.toString()
        router.push({ pathname: AppRoutes.spaces.index, query: { spaceId } })
        onClose()

        dispatch(
          showNotification({
            message: `Created space with name ${data.name}.`,
            variant: 'success',
            groupKey: 'create-space-success',
          }),
        )
      }

      if (response.error) {
        throw response.error
      }
    } catch (error) {
      // @ts-ignore
      const errorMessage = error?.data?.message || 'Failed creating the space. Please try again.'
      setError(errorMessage)
    } finally {
      setIsSubmitting(false)
    }
  })

  return (
    <ModalDialog
      open
      onClose={onClose}
      dialogTitle={
        <>
          <SvgIcon component={SpaceIcon} inheritViewBox sx={{ fill: 'none', mr: 1 }} />
          Create space
        </>
      }
      hideChainIndicator
    >
      <FormProvider {...methods}>
        <form onSubmit={onSubmit}>
          <DialogContent sx={{ py: 2 }}>
            <Box mb={2}>
              <NameInput data-testid="space-name-input" label="Name" autoFocus name="name" required />
            </Box>
            <Typography variant="body2" color="text.secondary">
              How is my data processed? Read our <ExternalLink href={AppRoutes.privacy}>privacy policy</ExternalLink>
            </Typography>

            {error && (
              <Alert severity="error" sx={{ mt: 2 }}>
                {error}
              </Alert>
            )}
          </DialogContent>

          <DialogActions>
            <Button data-testid="cancel-btn" onClick={onClose}>
              Cancel
            </Button>
            <Button
              data-testid="create-space-modal-button"
              type="submit"
              variant="contained"
              disabled={!formState.isValid || isSubmitting}
              disableElevation
              sx={{ minWidth: '200px' }}
            >
              {isSubmitting ? <CircularProgress size={20} /> : 'Create space'}
            </Button>
          </DialogActions>
        </form>
      </FormProvider>
    </ModalDialog>
  )
}

export default SpaceCreationModal
</file>

<file path="src/features/spaces/components/SpaceInfoModal/index.tsx">
import {
  Button,
  Chip,
  Dialog,
  DialogContent,
  Grid2,
  IconButton,
  List,
  ListItem,
  ListItemIcon,
  Stack,
  SvgIcon,
  Typography,
} from '@mui/material'
import CheckIcon from '@/public/images/common/check.svg'
import CloseIcon from '@mui/icons-material/Close'
import CreateSpaceInfo from '@/public/images/spaces/create_space_info.png'
import Image from 'next/image'
import { AppRoutes } from '@/config/routes'
import Link from 'next/link'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import ExternalLink from '@/components/common/ExternalLink'

const ListIcon = () => (
  <ListItemIcon
    sx={{
      alignSelf: 'flex-start',
      minWidth: '20px',
      marginRight: '16px',
      marginTop: '0',
      color: 'success.main',
      '& path:last-child': {
        fill: 'var(--color-success-main)',
      },
      backgroundColor: 'success.light',
      borderRadius: '50%',
      width: '20px',
      height: '20px',
      alignItems: 'center',
      justifyContent: 'center',
    }}
  >
    <SvgIcon component={CheckIcon} inheritViewBox fontSize="small" sx={{ width: '12px', height: '12px' }} />
  </ListItemIcon>
)

const SPACE_HELP_ARTICLE_LINK = 'https://help.safe.global/en/articles/285386-spaces'

const SpaceInfoModal = ({
  showButtons = true,
  onClose,
  onCreateSpace,
}: {
  showButtons?: boolean
  onClose: () => void
  onCreateSpace?: () => void
}) => {
  return (
    <Dialog open PaperProps={{ style: { width: '870px', maxWidth: '98%', borderRadius: '16px' } }} onClose={onClose}>
      <DialogContent dividers sx={{ p: 0, border: 0 }}>
        <Grid2 container>
          <Grid2 size={{ xs: 12, md: 6 }} p={5} display="flex" flexDirection="column">
            <Typography component="div" variant="h1" mb={1} position="relative">
              Introducing spaces
              <Chip
                label="Beta"
                size="small"
                sx={{ ml: 1, fontWeight: 'normal', position: 'absolute', top: '0', right: '0' }}
              />
            </Typography>

            <Typography mt={2} mb={3}>
              Collaborate seamlessly with your team and keep your treasury organized.
            </Typography>

            <List sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
              <ListItem disablePadding>
                <ListIcon />
                Bring all your Safe Accounts into one shared space.
              </ListItem>

              <ListItem disablePadding>
                <ListIcon />
                Invite team members with shared access—whether they’re signers or just viewers.
              </ListItem>

              <ListItem disablePadding>
                <ListIcon />
                Everyone sees the same account names, team members, and data.
              </ListItem>

              <ListItem disablePadding>
                <ListIcon />
                Aggregated balances and actions across multiple accounts are coming soon!
              </ListItem>
            </List>

            <Typography mt={1}>
              Read the <ExternalLink href={SPACE_HELP_ARTICLE_LINK}>Spaces help article</ExternalLink>
            </Typography>

            {showButtons && (
              <Stack gap={2} mt={{ xs: 3, md: 'auto' }}>
                {onCreateSpace ? (
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={() => {
                      trackEvent({ ...SPACE_EVENTS.CREATE_SPACE_MODAL, label: SPACE_LABELS.info_modal })
                      onClose()
                      onCreateSpace()
                    }}
                  >
                    Create a space
                  </Button>
                ) : (
                  <Link href={AppRoutes.welcome.spaces} passHref legacyBehavior>
                    <Button
                      variant="contained"
                      color="primary"
                      onClick={() =>
                        trackEvent({ ...SPACE_EVENTS.OPEN_SPACE_LIST_PAGE, label: SPACE_LABELS.info_modal })
                      }
                    >
                      Create a space
                    </Button>
                  </Link>
                )}

                <Button variant="text" color="primary" onClick={onClose}>
                  Maybe later
                </Button>
              </Stack>
            )}
          </Grid2>

          <Grid2 size={6} display={{ xs: 'none', md: 'flex' }} justifyContent="center" flex={1} bgcolor="#121312">
            <Image src={CreateSpaceInfo} style={{ width: '100%' }} alt="An illustration of multiple safe accounts" />
          </Grid2>
        </Grid2>

        <IconButton
          onClick={onClose}
          sx={{
            position: 'absolute',
            top: 0,
            right: 0,
            p: 1,
            m: 1,
            color: '#ffffff',
          }}
        >
          <CloseIcon />
        </IconButton>
      </DialogContent>
    </Dialog>
  )
}

export default SpaceInfoModal
</file>

<file path="src/features/spaces/components/SpacesDashboardWidget/index.tsx">
import { Box, Button, Chip, IconButton, Stack, Typography } from '@mui/material'
import Track from '@/components/common/Track'
import SpaceInfoModal from '../SpaceInfoModal'
import { useState } from 'react'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import CloseIcon from '@mui/icons-material/Close'

const gradientBg = {
  background: 'linear-gradient(225deg, rgba(95, 221, 255, 0.15) 12.5%, rgba(18, 255, 128, 0.15) 88.07%)',
}

const hideWidgetLocalStorageKey = 'hideSpacesDashboardWidget'

const SpacesDashboardWidget = () => {
  const [isInfoOpen, setIsInfoOpen] = useState<boolean>(false)
  const [widgetHidden = false, setWidgetHidden] = useLocalStorage<boolean>(hideWidgetLocalStorageKey)

  const onHide = () => {
    setWidgetHidden(true)
  }

  if (widgetHidden) return null

  return (
    <>
      <Stack direction="row" flexWrap="wrap" gap={2} p={3} sx={gradientBg} position="relative">
        <Box sx={{ position: 'absolute', right: 24, top: 16 }}>
          <Track {...SPACE_EVENTS.HIDE_DASHBOARD_WIDGET}>
            <IconButton aria-label="close" onClick={onHide} size="small">
              <CloseIcon fontSize="medium" />
            </IconButton>
          </Track>
        </Box>

        <Box flex={1} minWidth="60%">
          <Chip label="Beta" sx={{ backgroundColor: '#12FF80', borderRadius: '4px' }} size="small" />

          <Typography variant="h6" fontWeight="700" mb={2} mt={1}>
            Spaces are here!
          </Typography>

          <Typography variant="body2">
            Organize your Safe Accounts, all in one place. Collaborate efficiently with your team members and simplify
            treasury management.
            <br />
            Available now in beta.
          </Typography>
        </Box>

        <Stack direction="row" gap={2} alignItems="flex-end">
          <Track {...SPACE_EVENTS.INFO_MODAL} label={SPACE_LABELS.safe_dashboard_banner}>
            <Button variant="outlined" onClick={() => setIsInfoOpen(true)}>
              Learn more
            </Button>
          </Track>

          <Track {...SPACE_EVENTS.OPEN_SPACE_LIST_PAGE} label={SPACE_LABELS.safe_dashboard_banner}>
            <Link href={AppRoutes.welcome.spaces} passHref>
              <Button variant="contained" sx={{ minHeight: '48px' }}>
                Try now
              </Button>
            </Link>
          </Track>
        </Stack>
      </Stack>
      {isInfoOpen && <SpaceInfoModal onClose={() => setIsInfoOpen(false)} />}
    </>
  )
}

export default SpacesDashboardWidget
</file>

<file path="src/features/spaces/components/SpaceSettings/DeleteSpaceDialog.tsx">
import {
  Alert,
  Button,
  DialogActions,
  DialogContent,
  List,
  ListItem,
  ListItemIcon,
  SvgIcon,
  Typography,
} from '@mui/material'
import ModalDialog from '@/components/common/ModalDialog'
import { type GetSpaceResponse, useSpacesDeleteV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import CheckIcon from '@/public/images/common/check.svg'
import CloseIcon from '@/public/images/common/close.svg'
import css from './styles.module.css'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'
import { useState } from 'react'
import { showNotification } from '@/store/notificationsSlice'
import { useAppDispatch } from '@/store'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'

const ListIcon = ({ variant }: { variant: 'success' | 'danger' }) => {
  const Icon = variant === 'success' ? CheckIcon : CloseIcon

  return (
    <ListItemIcon className={variant === 'success' ? css.success : css.danger}>
      <SvgIcon component={Icon} inheritViewBox />
    </ListItemIcon>
  )
}

const DeleteSpaceDialog = ({ space, onClose }: { space: GetSpaceResponse | undefined; onClose: () => void }) => {
  const [error, setError] = useState<string>()
  const router = useRouter()
  const dispatch = useAppDispatch()
  const [deleteSpace] = useSpacesDeleteV1Mutation()

  const onDelete = async () => {
    if (!space) return

    setError(undefined)

    try {
      await deleteSpace({ id: space.id })

      onClose()

      trackEvent({ ...SPACE_EVENTS.DELETE_SPACE })
      dispatch(
        showNotification({
          message: `Deleted space ${space.name}.`,
          variant: 'success',
          groupKey: 'delete-space-success',
        }),
      )

      router.push({ pathname: AppRoutes.welcome.spaces })
    } catch (e) {
      console.error(e)
      setError('Error deleting the space. Please try again.')
    }
  }

  return (
    <ModalDialog dialogTitle="Delete space" hideChainIndicator open onClose={onClose}>
      <DialogContent sx={{ mt: 2 }}>
        <Typography mb={2}>
          Are you sure you want to delete <b>{space?.name}</b>? Deleting this space:
        </Typography>

        <List sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <ListItem disablePadding>
            <ListIcon variant="danger" />
            Will permanently revoke access to space data for you and its members
          </ListItem>
          <ListItem disablePadding>
            <ListIcon variant="danger" />
            Will remove members and Safe Accounts names from our database
          </ListItem>
          <ListItem disablePadding>
            <ListIcon variant="success" />
            Will keep access to the Safe Accounts added to this space. They will not be deleted.
          </ListItem>
        </List>

        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {error}
          </Alert>
        )}
      </DialogContent>

      <DialogActions>
        <Button onClick={onClose}>No, keep it</Button>
        <Button data-testid="space-confirm-delete-button" variant="danger" onClick={onDelete}>
          Permanently delete it
        </Button>
      </DialogActions>
    </ModalDialog>
  )
}

export default DeleteSpaceDialog
</file>

<file path="src/features/spaces/components/SpaceSettings/index.tsx">
import { useAppSelector } from '@/store'
import { Button, Card, Grid2, Typography } from '@mui/material'
import { useSpacesGetOneV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useState } from 'react'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import { isAuthenticated } from '@/store/authSlice'
import { useIsAdmin, useIsInvited } from '@/features/spaces/hooks/useSpaceMembers'
import PreviewInvite from '@/features/spaces/components/InviteBanner/PreviewInvite'
import DeleteSpaceDialog from '@/features/spaces/components/SpaceSettings/DeleteSpaceDialog'
import UpdateSpaceForm from '@/features/spaces/components/SpaceSettings/UpdateSpaceForm'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import ExternalLink from '@/components/common/ExternalLink'
import { AppRoutes } from '@/config/routes'

const SpaceSettings = () => {
  const [deleteSpaceOpen, setDeleteSpaceOpen] = useState(false)
  const isAdmin = useIsAdmin()
  const spaceId = useCurrentSpaceId()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData: space } = useSpacesGetOneV1Query({ id: Number(spaceId) }, { skip: !isUserSignedIn || !spaceId })
  const isInvited = useIsInvited()

  return (
    <div>
      {isInvited && <PreviewInvite />}
      <Typography variant="h2" mb={3}>
        Settings
      </Typography>
      <Card>
        <Grid2 container p={4} spacing={2}>
          <Grid2 size={{ xs: 12, md: 4 }}>
            <Typography fontWeight="bold">General</Typography>
          </Grid2>
          <Grid2 size={{ xs: 12, md: 8 }}>
            <Typography mb={2}>
              The space name is visible in the sidebar menu, headings to all its members. Usually it&apos;s a name of
              the company or a business. <ExternalLink href={AppRoutes.privacy}>How is this data stored?</ExternalLink>
            </Typography>

            <UpdateSpaceForm space={space} />
          </Grid2>
        </Grid2>

        <Grid2 container p={4} spacing={2}>
          <Grid2 size={{ xs: 12, md: 4 }}>
            <Typography fontWeight="bold">Danger Zone</Typography>
          </Grid2>
          <Grid2 size={{ xs: 12, md: 8 }}>
            <Typography mb={2}>This action cannot be undone.</Typography>

            <Button
              data-testid="space-delete-button"
              variant="danger"
              onClick={() => {
                setDeleteSpaceOpen(true)
                trackEvent({ ...SPACE_EVENTS.DELETE_SPACE_MODAL, label: SPACE_LABELS.space_settings })
              }}
              disabled={!isAdmin}
            >
              Delete space
            </Button>
          </Grid2>
        </Grid2>
      </Card>
      {deleteSpaceOpen && <DeleteSpaceDialog space={space} onClose={() => setDeleteSpaceOpen(false)} />}
    </div>
  )
}

export default SpaceSettings
</file>

<file path="src/features/spaces/components/SpaceSettings/styles.module.css">
.success {
  align-self: flex-start;
  min-width: 20px;
  margin-right: 16px;
  margin-top: 0;
  color: var(--color-success-main);
  background-color: var(--color-success-light);
  border-radius: 50%;
  width: 20px;
  height: 20px;
  align-items: center;
  justify-content: center;
}

.success path:last-child {
  fill: var(--color-success-main);
}

.success svg {
  width: 12px;
  height: 12px;
}

.danger {
  align-self: flex-start;
  min-width: 20px;
  margin-right: 16px;
  margin-top: 0;
  color: var(--color-error-main);
  background-color: var(--color-error-light);
  border-radius: 50%;
  width: 20px;
  height: 20px;
  align-items: center;
  justify-content: center;
}

.danger path:last-child {
  fill: var(--color-error-main);
}

.danger svg {
  width: 10px;
  height: 10px;
}
</file>

<file path="src/features/spaces/components/SpaceSettings/UpdateSpaceDialog.tsx">
import ModalDialog from '@/components/common/ModalDialog'
import DialogContent from '@mui/material/DialogContent'
import UpdateSpaceForm from '@/features/spaces/components/SpaceSettings/UpdateSpaceForm'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { Typography } from '@mui/material'
import { AppRoutes } from '@/config/routes'
import ExternalLink from '@/components/common/ExternalLink'

const UpdateSpaceDialog = ({ space, onClose }: { space: GetSpaceResponse; onClose: () => void }) => {
  return (
    <ModalDialog dialogTitle="Update space" hideChainIndicator open onClose={onClose}>
      <DialogContent sx={{ mt: 2 }}>
        <Typography mb={2}>
          The space name is visible in the sidebar menu, headings to all its members. Usually it&apos;s a name of the
          company or a business. <ExternalLink href={AppRoutes.privacy}>How is this data stored?</ExternalLink>
        </Typography>
        <UpdateSpaceForm space={space} />
      </DialogContent>
    </ModalDialog>
  )
}

export default UpdateSpaceDialog
</file>

<file path="src/features/spaces/components/SpaceSettings/UpdateSpaceForm.tsx">
import { Alert, Button, TextField } from '@mui/material'
import { FormProvider, useForm } from 'react-hook-form'
import { showNotification } from '@/store/notificationsSlice'
import { type GetSpaceResponse, useSpacesUpdateV1Mutation } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useAppDispatch } from '@/store'
import { useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import { useState } from 'react'

type UpdateSpaceFormData = {
  name: string
}

const UpdateSpaceForm = ({ space }: { space: GetSpaceResponse | undefined }) => {
  const [error, setError] = useState<string>()
  const dispatch = useAppDispatch()
  const [updateSpace] = useSpacesUpdateV1Mutation()
  const isAdmin = useIsAdmin(space?.id)

  const formMethods = useForm<UpdateSpaceFormData>({
    mode: 'onChange',
    values: {
      name: space?.name || '',
    },
  })

  const { register, handleSubmit, watch } = formMethods

  const formName = watch('name')
  const isNameChanged = formName !== space?.name

  const onSubmit = handleSubmit(async (data) => {
    setError(undefined)

    if (!space) return

    try {
      await updateSpace({ id: space.id, updateSpaceDto: { name: data.name } })

      dispatch(
        showNotification({
          variant: 'success',
          message: 'Updated space name',
          groupKey: 'space-update-name',
        }),
      )
    } catch (e) {
      console.error(e)
      setError('Error updating the space. Please try again.')
    }
  })

  return (
    <FormProvider {...formMethods}>
      <form onSubmit={onSubmit}>
        <TextField
          {...register('name')}
          label="Space name"
          fullWidth
          slotProps={{ inputLabel: { shrink: true } }}
          onKeyDown={(e) => e.stopPropagation()}
        />

        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {error}
          </Alert>
        )}

        <Button
          data-testid="space-save-button"
          variant="contained"
          type="submit"
          sx={{ mt: 2 }}
          disabled={!isNameChanged || !isAdmin}
        >
          Save
        </Button>
      </form>
    </FormProvider>
  )
}

export default UpdateSpaceForm
</file>

<file path="src/features/spaces/components/SpaceSidebar/index.tsx">
import { type ReactElement } from 'react'

import css from './styles.module.css'
import SpaceSidebarNavigation from '@/features/spaces/components/SpaceSidebarNavigation'
import SpaceSidebarSelector from '@/features/spaces/components/SpaceSidebarSelector'

const SpaceSidebar = (): ReactElement => {
  return (
    <div className={css.container}>
      <SpaceSidebarSelector />
      <SpaceSidebarNavigation />
    </div>
  )
}

export default SpaceSidebar
</file>

<file path="src/features/spaces/components/SpaceSidebar/styles.module.css">
.container {
  height: 100vh;
  padding-top: var(--header-height);
  display: flex;
  overflow: hidden;
  flex-direction: column;
  background-color: var(--color-background-paper);
  width: 230px;
}
</file>

<file path="src/features/spaces/components/SpaceSidebarNavigation/config.tsx">
import { Chip } from '@/components/common/Chip'
import ABIcon from '@/public/images/sidebar/address-book.svg'
import TransactionIcon from '@/public/images/sidebar/transactions.svg'
import React, { type ReactElement } from 'react'
import { AppRoutes } from '@/config/routes'
import HomeIcon from '@/public/images/sidebar/home.svg'
import SettingsIcon from '@/public/images/sidebar/settings.svg'
import MembersIcon from '@/public/images/sidebar/members.svg'
import AccountsIcon from '@/public/images/sidebar/wallet.svg'
import { SvgIcon } from '@mui/material'

export type DynamicNavItem = {
  label: string
  icon?: ReactElement
  href: string
  tag?: ReactElement
  disabled?: boolean
  adminOnly?: boolean
}

export const navItems: DynamicNavItem[] = [
  {
    label: 'Home',
    icon: <SvgIcon component={HomeIcon} inheritViewBox />,
    href: AppRoutes.spaces.index,
  },
  {
    label: 'Safe Accounts',
    icon: <SvgIcon component={AccountsIcon} inheritViewBox />,
    href: AppRoutes.spaces.safeAccounts,
  },
  {
    label: 'Transactions',
    icon: <SvgIcon component={TransactionIcon} inheritViewBox />,
    href: '', // TODO: Replace with empty page
    disabled: true,
    tag: <Chip label="Soon" sx={{ backgroundColor: 'background.main', color: 'primary.main' }} />,
  },
  {
    label: 'Members',
    icon: <SvgIcon component={MembersIcon} inheritViewBox />,
    href: AppRoutes.spaces.members,
  },
  {
    label: 'Address book',
    icon: <SvgIcon component={ABIcon} inheritViewBox />,
    href: '', // TODO: Replace with empty page
    disabled: true,
    tag: <Chip label="Soon" sx={{ backgroundColor: 'background.main', color: 'primary.main' }} />,
  },
  {
    label: 'Settings',
    icon: <SvgIcon component={SettingsIcon} inheritViewBox />,
    href: AppRoutes.spaces.settings,
    adminOnly: true,
  },
]
</file>

<file path="src/features/spaces/components/SpaceSidebarNavigation/index.tsx">
import React, { type ReactElement } from 'react'
import { useRouter } from 'next/router'
import { ListItemButton } from '@mui/material'

import {
  SidebarList,
  SidebarListItemButton,
  SidebarListItemIcon,
  SidebarListItemText,
} from '@/components/sidebar/SidebarList'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'
import { useIsAdmin } from '@/features/spaces/hooks/useSpaceMembers'
import { navItems } from './config'

const Navigation = (): ReactElement => {
  const router = useRouter()
  const spaceId = useCurrentSpaceId()
  const isAdmin = useIsAdmin()

  return (
    <SidebarList>
      {navItems.map((item) => {
        const hideItem = item.adminOnly && !isAdmin
        const isSelected = router.pathname === item.href

        if (hideItem) return null

        return (
          <div key={item.label}>
            <ListItemButton disabled={item.disabled} sx={{ padding: 0 }} selected={isSelected}>
              <SidebarListItemButton
                selected={isSelected}
                href={item.href ? { pathname: item.href, query: { spaceId } } : ''}
              >
                {item.icon && <SidebarListItemIcon>{item.icon}</SidebarListItemIcon>}

                <SidebarListItemText data-testid="sidebar-list-item" bold>
                  {item.label}
                  {item.tag}
                </SidebarListItemText>
              </SidebarListItemButton>
            </ListItemButton>
          </div>
        )
      })}
    </SidebarList>
  )
}

export default React.memo(Navigation)
</file>

<file path="src/features/spaces/components/SpaceSidebarSelector/index.tsx">
import { Box, Button, Divider, Menu, MenuItem, Typography } from '@mui/material'
import { type GetSpaceResponse, useSpacesGetV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useState } from 'react'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import CheckIcon from '@mui/icons-material/Check'
import SpaceCard from '../SpaceCard'
import InitialsAvatar from '../InitialsAvatar'

import css from './styles.module.css'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import SpaceCreationModal from '../SpaceCreationModal'
import { useCurrentSpaceId } from 'src/features/spaces/hooks/useCurrentSpaceId'
import { useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import { SPACE_LABELS } from '@/services/analytics/events/spaces'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'
import { getNonDeclinedSpaces } from '@/features/spaces/utils'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'

const SpaceSidebarSelector = () => {
  const [isCreationModalOpen, setIsCreationModalOpen] = useState(false)
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null)
  const router = useRouter()
  const open = Boolean(anchorEl)
  const spaceId = useCurrentSpaceId()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData: currentUser } = useUsersGetWithWalletsV1Query(undefined, { skip: !isUserSignedIn })
  const { currentData: spaces } = useSpacesGetV1Query(undefined, { skip: !isUserSignedIn })
  const selectedSpace = spaces?.find((space) => space.id === Number(spaceId))

  const nonDeclinedSpaces = getNonDeclinedSpaces(currentUser, spaces || [])

  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget)
  }

  const handleClose = () => {
    setAnchorEl(null)
  }

  const handleSelectSpace = (space: GetSpaceResponse) => {
    router.push({
      pathname: router.pathname,
      query: { ...router.query, spaceId: space.id.toString() },
    })

    handleClose()
  }

  if (!selectedSpace) return null

  return (
    <>
      <Box display="flex" width="100%">
        <Button
          data-testid="space-selector-button"
          id="space-selector-button"
          onClick={handleClick}
          endIcon={
            <ExpandMoreIcon
              className={css.expandIcon}
              sx={{
                transform: open ? 'rotate(180deg)' : undefined,
                color: 'border.main',
              }}
            />
          }
          fullWidth
          className={css.spaceSelectorButton}
        >
          <Box display="flex" alignItems="center" gap={1}>
            <InitialsAvatar name={selectedSpace.name} size="small" />
            <Typography
              variant="body2"
              fontWeight="bold"
              noWrap
              sx={{ maxWidth: '140px', textOverflow: 'ellipsis', overflow: 'hidden' }}
            >
              {selectedSpace.name}
            </Typography>
          </Box>
        </Button>

        <Menu
          data-testid="space-selector-menu"
          id="space-selector-menu"
          anchorEl={anchorEl}
          open={open}
          onClose={handleClose}
          sx={{ '& .MuiPaper-root': { minWidth: '260px !important' } }}
        >
          <SpaceCard space={selectedSpace} isCompact isLink={false} />

          <Divider sx={{ mb: 1 }} />

          {nonDeclinedSpaces.map((space) => (
            <MenuItem
              key={space.id}
              onClick={() => handleSelectSpace(space)}
              selected={space.id === selectedSpace.id}
              sx={{
                display: 'flex',
                justifyContent: 'space-between',
                gap: 1,
              }}
            >
              <Box display="flex" alignItems="center" gap={1}>
                <InitialsAvatar name={space.name} size="small" />
                <Typography variant="body2">{space.name}</Typography>
              </Box>
              {space.id === selectedSpace.id && <CheckIcon fontSize="small" color="primary" />}
            </MenuItem>
          ))}

          <Divider />

          <MenuItem
            onClick={() => {
              handleClose()
              setIsCreationModalOpen(true)
              trackEvent({ ...SPACE_EVENTS.CREATE_SPACE_MODAL, label: SPACE_LABELS.space_selector })
            }}
            sx={{ fontWeight: 700 }}
          >
            Create space
          </MenuItem>

          <MenuItem
            onClick={() => {
              handleClose()
              trackEvent({ ...SPACE_EVENTS.OPEN_SPACE_LIST_PAGE, label: SPACE_LABELS.space_selector })
              router.push(AppRoutes.welcome.spaces)
            }}
            sx={{ fontWeight: 700 }}
          >
            View spaces
          </MenuItem>
        </Menu>
      </Box>

      {isCreationModalOpen && <SpaceCreationModal onClose={() => setIsCreationModalOpen(false)} />}
    </>
  )
}

export default SpaceSidebarSelector
</file>

<file path="src/features/spaces/components/SpaceSidebarSelector/styles.module.css">
.spaceSelectorButton {
  justify-content: space-between;
  text-align: left;
  padding: var(--space-1);
  margin: var(--space-1);
  border: 1px solid var(--color-border-light);
  font-size: 14px;
}

.spaceSelectorButton:hover {
  border: 1px solid var(--color-border-light);
}
</file>

<file path="src/features/spaces/components/SpacesList/index.tsx">
import AccountsNavigation from '@/features/myAccounts/components/AccountsNavigation'
import SpaceCard from 'src/features/spaces/components/SpaceCard'
import SpaceCreationModal from '@/features/spaces/components/SpaceCreationModal'
import SignInButton from '@/features/spaces/components/SignInButton'
import SpacesIcon from '@/public/images/spaces/spaces.svg'
import { useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import { Box, Button, Card, Grid2, Link, Typography } from '@mui/material'
import { type GetSpaceResponse, useSpacesGetV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import SpaceListInvite from '../InviteBanner'
import { useState } from 'react'
import css from './styles.module.css'
import { MemberStatus } from '@/features/spaces/hooks/useSpaceMembers'
import useWallet from '@/hooks/wallets/useWallet'
import { SPACE_EVENTS, SPACE_LABELS } from '@/services/analytics/events/spaces'
import Track from '@/components/common/Track'
import SpaceInfoModal from '../SpaceInfoModal'
import { filterSpacesByStatus } from '@/features/spaces/utils'

const AddSpaceButton = () => {
  const [openCreationModal, setOpenCreationModal] = useState<boolean>(false)

  return (
    <>
      <Button
        data-testid="create-space-button"
        disableElevation
        variant="contained"
        size="small"
        onClick={() => setOpenCreationModal(true)}
        sx={{ height: '36px' }}
      >
        <Box mt="1px">Create space</Box>
      </Button>
      {openCreationModal && <SpaceCreationModal onClose={() => setOpenCreationModal(false)} />}
    </>
  )
}

const SignedOutState = () => {
  const wallet = useWallet()
  const [isInfoOpen, setIsInfoOpen] = useState<boolean>(false)

  return (
    <>
      <Card sx={{ p: 5, textAlign: 'center' }}>
        <SpacesIcon />

        <Box mb={3}>
          <Typography color="text.secondary" mb={1}>
            To view your space or create one,{' '}
            {!!wallet ? 'sign in with your connected wallet.' : 'connect your wallet.'}
            <br />
          </Typography>
          <Link onClick={() => setIsInfoOpen(true)} href="#">
            What are spaces?
          </Link>
        </Box>

        <SignInButton />
      </Card>
      {isInfoOpen && <SpaceInfoModal onClose={() => setIsInfoOpen(false)} showButtons={false} />}
    </>
  )
}

const NoSpacesState = () => {
  const [isInfoOpen, setIsInfoOpen] = useState<boolean>(false)
  const [openCreationModal, setOpenCreationModal] = useState<boolean>(false)

  return (
    <>
      <Card sx={{ p: 5, textAlign: 'center', width: 1 }}>
        <SpacesIcon />

        <Box mb={3}>
          <Typography color="text.secondary" mb={1}>
            No spaces found.
            <br />
          </Typography>
          <Link onClick={() => setIsInfoOpen(true)} href="#">
            What are spaces?
          </Link>
        </Box>
        <Track {...SPACE_EVENTS.CREATE_SPACE_MODAL} label={SPACE_LABELS.space_list_page}>
          <AddSpaceButton />
        </Track>
      </Card>
      {isInfoOpen && (
        <SpaceInfoModal onCreateSpace={() => setOpenCreationModal(true)} onClose={() => setIsInfoOpen(false)} />
      )}
      {openCreationModal && <SpaceCreationModal onClose={() => setOpenCreationModal(false)} />}
    </>
  )
}

const SpacesList = () => {
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData: currentUser } = useUsersGetWithWalletsV1Query(undefined, { skip: !isUserSignedIn })
  const { currentData: spaces } = useSpacesGetV1Query(undefined, { skip: !isUserSignedIn })

  const pendingInvites = filterSpacesByStatus(currentUser, spaces || [], MemberStatus.INVITED)
  const activeSpaces = filterSpacesByStatus(currentUser, spaces || [], MemberStatus.ACTIVE)

  return (
    <Box className={css.container}>
      <Box className={css.mySpaces}>
        <Box className={css.spacesHeader}>
          <AccountsNavigation />

          {isUserSignedIn && activeSpaces.length > 0 && (
            <Track {...SPACE_EVENTS.CREATE_SPACE_MODAL} label={SPACE_LABELS.space_list_page}>
              <AddSpaceButton />
            </Track>
          )}
        </Box>

        {isUserSignedIn &&
          pendingInvites.length > 0 &&
          pendingInvites.map((invitingSpace: GetSpaceResponse) => (
            <SpaceListInvite key={invitingSpace.id} space={invitingSpace} />
          ))}

        {isUserSignedIn ? (
          <Grid2 container spacing={2} flexWrap="wrap">
            {activeSpaces.length > 0 ? (
              activeSpaces.map((space) => (
                <Grid2 size={{ xs: 12, md: 6 }} key={space.name}>
                  <SpaceCard space={space} />
                </Grid2>
              ))
            ) : (
              <NoSpacesState />
            )}
          </Grid2>
        ) : (
          <SignedOutState />
        )}
      </Box>
    </Box>
  )
}

export default SpacesList
</file>

<file path="src/features/spaces/components/SpacesList/styles.module.css">
.container {
  container-type: inline-size;
  container-name: my-spaces-container;
  display: flex;
  justify-content: center;
}

.mySpaces {
  width: 100vw;
  max-width: 750px;
  margin: var(--space-2);
}

.spacesHeader {
  display: flex;
  justify-content: space-between;
  padding: var(--space-3) 0;
  gap: var(--space-2);
  flex-wrap: wrap;
}
</file>

<file path="src/features/spaces/components/UnauthorizedState/index.tsx">
import { Box, Typography } from '@mui/material'
import css from '@/features/spaces/components/Dashboard/styles.module.css'
import Button from '@mui/material/Button'
import Link from 'next/link'
import { AppRoutes } from '@/config/routes'

const UnauthorizedState = () => {
  return (
    <Box className={css.content}>
      <Box textAlign="center" className={css.contentWrapper}>
        <Box className={css.contentInner}>
          <Typography fontWeight={700} mb={2}>
            You don’t have permissions to this page
          </Typography>

          <Typography color="text.secondary" mb={2}>
            Sorry, you don’t have permissions to view this page, as your wallet is not a member of the space. Try to
            sign in with a different wallet or go back to the overview.
          </Typography>

          <Link href={AppRoutes.welcome.spaces} passHref>
            <Button variant="outlined">Back to overview</Button>
          </Link>
        </Box>
      </Box>
    </Box>
  )
}

export default UnauthorizedState
</file>

<file path="src/features/spaces/components/UserSettings/index.tsx">
import { Box, Typography, Card, Stack, Button, SvgIcon, Tooltip } from '@mui/material'
import { useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import EthHashInfo from '@/components/common/EthHashInfo'
import LinkIcon from '@/public/images/messages/link.svg'
import css from './styles.module.css'
import InfoBox from '@/components/safe-messages/InfoBox'
import SignedOutState from '@/features/spaces/components/SignedOutState'

const UserSettings = () => {
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData: user } = useUsersGetWithWalletsV1Query(undefined, { skip: !isUserSignedIn })

  if (!isUserSignedIn) return <SignedOutState />

  return (
    <Box className={css.container}>
      <Box className={css.userSettings}>
        <Typography variant="h1" mb={3} align="center">
          Manage Wallets
        </Typography>

        <Card sx={{ p: 4 }}>
          <Stack spacing={2}>
            <Typography variant="h3" fontWeight="bold">
              Linked wallets
            </Typography>
            <Typography variant="body1">
              A linked wallet allows you to sign in to your Safe Spaces while keeping all your data, such as account
              names and team members, consistent across all linked wallets.
            </Typography>

            <Box>
              {user?.wallets.map((wallet) => (
                <Stack
                  direction="row"
                  spacing={2}
                  key={wallet.address}
                  alignItems="center"
                  justifyContent="space-between"
                >
                  <EthHashInfo shortAddress={false} address={wallet.address} showCopyButton hasExplorer />
                </Stack>
              ))}
            </Box>
            <Tooltip title="Coming soon">
              <Typography component="span" sx={{ alignSelf: 'flex-start' }}>
                <Button
                  startIcon={<SvgIcon component={LinkIcon} inheritViewBox fontSize="medium" className={css.linkIcon} />}
                  variant="text"
                  color="primary"
                  sx={{ p: 1 }}
                  disabled
                >
                  Link another wallet
                </Button>
              </Typography>
            </Tooltip>
            <InfoBox
              title="How to link a wallet?"
              message={
                <>
                  <div className={css.steps}>
                    {[
                      'Add an address to your profile and confirm with a signature.',
                      'Sign in with the new address and confirm again',
                      'Your wallet now shares the same profile data!',
                    ].map((stepText, index) => (
                      <Typography key={index} className={css.step} variant="body1" display="flex" gap={1}>
                        <Box component="span" className={css.stepNumber}>
                          {index + 1}
                        </Box>
                        {stepText}
                      </Typography>
                    ))}
                  </div>
                </>
              }
            ></InfoBox>
          </Stack>
        </Card>
      </Box>
    </Box>
  )
}

export default UserSettings
</file>

<file path="src/features/spaces/components/UserSettings/styles.module.css">
.container {
  display: flex;
  justify-content: center;
}

.userSettings {
  max-width: 750px;
  margin-top: var(--space-3);
}

.linkIcon {
  width: 24px;
  height: 24px;
}

.step {
  font-size: 14px;
}

.stepNumber {
  margin-top: 2px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #d7f6ff;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  font-size: 12px;
}

@media (max-width: 599.95px) {
  .userSettings {
    margin: var(--space-2) 0 0 0;
  }
}
</file>

<file path="src/features/spaces/hooks/useCurrentSpaceId.ts">
import { useAppSelector } from '@/store'
import { lastUsedSpace } from '@/store/authSlice'

export const useCurrentSpaceId = () => {
  return useAppSelector(lastUsedSpace)
}
</file>

<file path="src/features/spaces/hooks/useFeatureFlagRedirect.ts">
import { useEffect } from 'react'
import { AppRoutes } from '@/config/routes'
import { useRouter } from 'next/router'
import { useHasFeature } from '@/hooks/useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'

const useFeatureFlagRedirect = () => {
  const router = useRouter()
  const isSpacesFeatureEnabled = useHasFeature(FEATURES.SPACES)

  useEffect(() => {
    if (isSpacesFeatureEnabled === false) {
      router.push({ pathname: AppRoutes.welcome.accounts })
    }
  }, [isSpacesFeatureEnabled, router])
}

export default useFeatureFlagRedirect
</file>

<file path="src/features/spaces/hooks/useMembersSearch.ts">
import { useMemo } from 'react'
import Fuse from 'fuse.js'
import type { Member } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'

const useMembersSearch = (members: Member[], query: string): Member[] => {
  const fuse = useMemo(
    () =>
      new Fuse(members, {
        keys: [{ name: 'name' }],
        threshold: 0.2,
        findAllMatches: true,
        ignoreLocation: true,
      }),
    [members],
  )

  return useMemo(() => (query ? fuse.search(query).map((result) => result.item) : members), [fuse, query, members])
}

export { useMembersSearch }
</file>

<file path="src/features/spaces/hooks/useSpaceMembers.tsx">
import { useMembersGetUsersV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useCurrentSpaceId } from 'src/features/spaces/hooks/useCurrentSpaceId'
import { useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import { useUsersGetWithWalletsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/users'

export enum MemberStatus {
  INVITED = 'INVITED',
  ACTIVE = 'ACTIVE',
  DECLINED = 'DECLINED',
}

export enum MemberRole {
  ADMIN = 'ADMIN',
  MEMBER = 'MEMBER',
}

const useAllMembers = (spaceId?: number) => {
  const currentSpaceId = useCurrentSpaceId()
  const actualSpaceId = spaceId ?? currentSpaceId
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { data: currentData } = useMembersGetUsersV1Query({ spaceId: Number(actualSpaceId) }, { skip: !isUserSignedIn })
  return currentData?.members || []
}

export const useSpaceMembersByStatus = () => {
  const allMembers = useAllMembers()

  const invitedMembers = allMembers.filter(
    (member) => member.status === MemberStatus.INVITED || member.status === MemberStatus.DECLINED,
  )
  const activeMembers = allMembers.filter((member) => member.status === MemberStatus.ACTIVE)

  return { activeMembers, invitedMembers }
}

const useCurrentMembership = (spaceId?: number) => {
  const allMembers = useAllMembers(spaceId)
  const { currentData: user } = useUsersGetWithWalletsV1Query()
  return allMembers.find((member) => member.user.id === user?.id)
}

export const useIsAdmin = (spaceId?: number) => {
  const currentMembership = useCurrentMembership(spaceId)
  return currentMembership?.role === MemberRole.ADMIN && currentMembership?.status === MemberStatus.ACTIVE
}

export const useIsInvited = () => {
  const currentMembership = useCurrentMembership()
  return currentMembership?.status === MemberStatus.INVITED
}
</file>

<file path="src/features/spaces/hooks/useSpaceSafeCount.tsx">
import { useAppSelector } from '@/store'
import { isAuthenticated } from '@/store/authSlice'
import { useSpaceSafesGetV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'

export const useSpaceSafeCount = (spaceId: number): number => {
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData } = useSpaceSafesGetV1Query({ spaceId }, { skip: !isUserSignedIn })
  const safes = currentData?.safes || {}

  return Object.values(safes).reduce((acc, safesOnChain) => acc + safesOnChain.length, 0)
}
</file>

<file path="src/features/spaces/hooks/useSpaceSafes.tsx">
import { useSpaceSafesGetV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useCurrentSpaceId } from 'src/features/spaces/hooks/useCurrentSpaceId'
import { _buildSafeItems, type AllSafeItems } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { useAllSafesGrouped } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import { useAppSelector } from '@/store'
import { selectOrderByPreference } from '@/store/orderByPreferenceSlice'
import { getComparator } from '@/features/myAccounts/utils/utils'
import { useMemo } from 'react'
import { selectAllAddressBooks } from '@/store/addressBookSlice'
import { isAuthenticated } from '@/store/authSlice'
import useAllOwnedSafes from '@/features/myAccounts/hooks/useAllOwnedSafes'
import useWallet from '@/hooks/wallets/useWallet'

export const useSpaceSafes = () => {
  const spaceId = useCurrentSpaceId()
  const isUserSignedIn = useAppSelector(isAuthenticated)
  const { currentData, isLoading } = useSpaceSafesGetV1Query({ spaceId: Number(spaceId) }, { skip: !isUserSignedIn })

  const allSafeNames = useAppSelector(selectAllAddressBooks)
  const { address: walletAddress = '' } = useWallet() || {}
  const [allOwned = {}] = useAllOwnedSafes(walletAddress)
  const safeItems = currentData ? _buildSafeItems(currentData.safes, allSafeNames, allOwned) : []
  const safes = useAllSafesGrouped(safeItems)
  const { orderBy } = useAppSelector(selectOrderByPreference)
  const sortComparator = getComparator(orderBy)

  const allSafes = useMemo<AllSafeItems>(
    () => [...(safes.allMultiChainSafes ?? []), ...(safes.allSingleSafes ?? [])].sort(sortComparator),
    [safes.allMultiChainSafes, safes.allSingleSafes, sortComparator],
  )

  return { allSafes, isLoading }
}
</file>

<file path="src/features/spaces/hooks/useTrackSpace.ts">
import type { AllSafeItems } from '@/features/myAccounts/hooks/useAllSafesGrouped'
import type { Member } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { useEffect } from 'react'
import { trackEvent } from '@/services/analytics'
import { SPACE_EVENTS } from '@/services/analytics/events/spaces'

let isTotalSafesTracked = false
let isTotalMembersTracked = false

const useTrackSpace = (safes: AllSafeItems, activeMembers: Member[]) => {
  useEffect(() => {
    if (isTotalSafesTracked) return

    trackEvent({ ...SPACE_EVENTS.TOTAL_SAFE_ACCOUNTS, label: safes.length })
    isTotalSafesTracked = true
  }, [safes.length])

  useEffect(() => {
    if (isTotalMembersTracked) return

    trackEvent({ ...SPACE_EVENTS.TOTAL_ACTIVE_MEMBERS, label: activeMembers.length })
    isTotalMembersTracked = true
  }, [activeMembers.length])
}

export default useTrackSpace
</file>

<file path="src/features/spaces/utils.ts">
import type { FetchBaseQueryError } from '@reduxjs/toolkit/query'
import type { SerializedError } from '@reduxjs/toolkit'
import type { UserWithWallets } from '@safe-global/store/gateway/AUTO_GENERATED/users'
import type { GetSpaceResponse } from '@safe-global/store/gateway/AUTO_GENERATED/spaces'
import { MemberStatus } from '@/features/spaces/hooks/useSpaceMembers'

// TODO: Currently also checks for 404 because the /v1/spaces/<orgId> endpoint does not return 401
export const isUnauthorized = (error: FetchBaseQueryError | SerializedError | undefined) => {
  return error && 'status' in error && (error.status === 401 || error.status === 404)
}

export const filterSpacesByStatus = (
  currentUser: UserWithWallets | undefined,
  spaces: GetSpaceResponse[],
  status: MemberStatus,
) => {
  return spaces.filter((space) => {
    return space.members.some((member) => member.user.id === currentUser?.id && member.status === status)
  })
}

export const getNonDeclinedSpaces = (currentUser: UserWithWallets | undefined, spaces: GetSpaceResponse[]) => {
  const pendingInvites = filterSpacesByStatus(currentUser, spaces || [], MemberStatus.INVITED)
  const activeSpaces = filterSpacesByStatus(currentUser, spaces || [], MemberStatus.ACTIVE)

  return [...pendingInvites, ...activeSpaces]
}
</file>

<file path="src/features/speedup/components/SpeedUpModal.tsx">
import useGasPrice from '@/hooks/useGasPrice'
import ModalDialog from '@/components/common/ModalDialog'
import DialogContent from '@mui/material/DialogContent'
import { Box, Button, CircularProgress, SvgIcon, Tooltip, Typography } from '@mui/material'
import RocketSpeedup from '@/public/images/common/ic-rocket-speedup.svg'
import DialogActions from '@mui/material/DialogActions'
import useWallet from '@/hooks/wallets/useWallet'
import useOnboard from '@/hooks/wallets/useOnboard'
import useSafeAddress from '@/hooks/useSafeAddress'
import { useAppDispatch } from '@/store'
import { createExistingTx, dispatchCustomTxSpeedUp, dispatchSafeTxSpeedUp } from '@/services/tx/tx-sender'
import { showNotification } from '@/store/notificationsSlice'
import { useCallback, useState } from 'react'
import GasParams from '@/components/tx/GasParams'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { getTxOptions } from '@/utils/transactions'
import { useCurrentChain, useHasFeature } from '@/hooks/useChains'
import { SimpleTxWatcher } from '@/utils/SimpleTxWatcher'
import { isWalletRejection } from '@/utils/wallets'
import { type TransactionOptions } from '@safe-global/safe-core-sdk-types'
import { PendingTxType, type PendingProcessingTx } from '@/store/pendingTxsSlice'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import { TX_EVENTS } from '@/services/analytics/events/transactions'
import { getTransactionTrackingType } from '@/services/analytics/tx-tracking'
import { trackError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import CheckWallet from '@/components/common/CheckWallet'
import { useLazyGetTransactionDetailsQuery } from '@/store/api/gateway'
import NetworkWarning from '@/components/new-safe/create/NetworkWarning'
import { FEATURES } from '@safe-global/utils/utils/chains'

type Props = {
  open: boolean
  handleClose: () => void
  pendingTx: PendingProcessingTx
  txId: string
  txHash: string
  signerAddress: string | undefined
  signerNonce: number
  gasLimit: string | number | undefined
}
export const SpeedUpModal = ({
  open,
  handleClose,
  pendingTx,
  txId,
  txHash,
  signerAddress,
  signerNonce,
  gasLimit,
}: Props) => {
  const [speedUpFee] = useGasPrice(true)
  const [waitingForConfirmation, setWaitingForConfirmation] = useState(false)
  const isEIP1559 = useHasFeature(FEATURES.EIP1559)

  const wallet = useWallet()
  const onboard = useOnboard()
  const chainInfo = useCurrentChain()
  const safeAddress = useSafeAddress()
  const hasActions = signerAddress && signerAddress === wallet?.address
  const dispatch = useAppDispatch()
  const [trigger] = useLazyGetTransactionDetailsQuery()
  const isDisabled = waitingForConfirmation || !wallet || !speedUpFee || !onboard
  const [safeTx] = useAsync(() => {
    if (!chainInfo?.chainId) return
    return createExistingTx(chainInfo.chainId, txId)
  }, [txId, chainInfo?.chainId])

  const safeTxHasSignatures = !!safeTx?.signatures?.size ? true : false

  const onCancel = () => {
    trackEvent(MODALS_EVENTS.CANCEL_SPEED_UP)
    handleClose()
  }

  const onSubmit = useCallback(async () => {
    if (!wallet || !speedUpFee || !onboard || !chainInfo || !safeTx) {
      return null
    }

    const txOptions = getTxOptions(
      {
        ...speedUpFee,
        gasLimit: typeof gasLimit === 'undefined' ? null : BigInt(gasLimit),
      },
      chainInfo,
    )
    txOptions.nonce = signerNonce

    try {
      setWaitingForConfirmation(true)

      if (pendingTx.txType === PendingTxType.SAFE_TX) {
        await dispatchSafeTxSpeedUp(
          txOptions as Omit<TransactionOptions, 'nonce'> & { nonce: number },
          txId,
          wallet.provider,
          chainInfo.chainId,
          wallet.address,
          safeAddress,
          safeTx.data.nonce,
        )
        const { data: details } = await trigger({ chainId: chainInfo.chainId, txId })
        const txType = getTransactionTrackingType(details)
        trackEvent({ ...TX_EVENTS.SPEED_UP, label: txType })
      } else {
        await dispatchCustomTxSpeedUp(
          txOptions as Omit<TransactionOptions, 'nonce'> & { nonce: number },
          txId,
          pendingTx.to,
          pendingTx.data,
          wallet.provider,
          wallet.address,
          pendingTx.nonce,
        )
        // Currently all custom txs are batch executes
        trackEvent({ ...TX_EVENTS.SPEED_UP, label: 'batch' })
      }

      if (txHash) {
        SimpleTxWatcher.getInstance().stopWatchingTxHash(txHash)
      }

      setWaitingForConfirmation(false)
      handleClose()
    } catch (e) {
      const error = asError(e)
      setWaitingForConfirmation(false)
      if (!isWalletRejection(error)) {
        trackError(ErrorCodes._814, error)
        dispatch(
          showNotification({
            message: 'Speed up failed',
            variant: 'error',
            detailedMessage: error.message,
            groupKey: txHash,
          }),
        )
      }
    }
  }, [
    chainInfo,
    dispatch,
    gasLimit,
    handleClose,
    onboard,
    pendingTx,
    safeAddress,
    signerNonce,
    speedUpFee,
    txHash,
    txId,
    wallet,
    safeTx,
    trigger,
  ])

  if (!hasActions) {
    return null
  }

  if (safeTxHasSignatures) {
    return (
      <ModalDialog open={open} onClose={onCancel} dialogTitle="Speed up transaction">
        <DialogContent sx={{ p: '24px !important' }}>
          <Box display="flex" justifyContent="center" alignItems="center" mb={2}>
            <SvgIcon inheritViewBox component={RocketSpeedup} sx={{ width: 90, height: 90 }} />
          </Box>

          <Typography data-testid="speedup-summary">
            This will speed up the pending transaction by{' '}
            <Typography component="span" fontWeight={700}>
              replacing
            </Typography>{' '}
            the original gas parameters with new ones.
          </Typography>

          <Box mt={2}>
            {speedUpFee && signerNonce && (
              <GasParams
                params={{
                  // nonce: safeTx?.data?.nonce,
                  userNonce: signerNonce,
                  gasLimit: typeof gasLimit === 'undefined' ? null : BigInt(gasLimit),
                  maxFeePerGas: speedUpFee.maxFeePerGas,
                  maxPriorityFeePerGas: speedUpFee.maxPriorityFeePerGas,
                }}
                isExecution={true}
                isEIP1559={isEIP1559}
                willRelay={false}
              />
            )}
          </Box>
          <Box sx={{ '&:not(:empty)': { mt: 3 } }}>
            <NetworkWarning />
          </Box>
        </DialogContent>

        <DialogActions>
          <Button onClick={onCancel}>Cancel</Button>

          <Tooltip title="Speed up transaction">
            <CheckWallet checkNetwork={!isDisabled}>
              {(isOk) => (
                <Button
                  color="primary"
                  disabled={!isOk || isDisabled}
                  onClick={onSubmit}
                  variant="contained"
                  disableElevation
                >
                  {isDisabled ? <CircularProgress size={20} /> : 'Confirm'}
                </Button>
              )}
            </CheckWallet>
          </Tooltip>
        </DialogActions>
      </ModalDialog>
    )
  }

  return (
    <ModalDialog open={open} onClose={handleClose} dialogTitle="Speed up transaction">
      <DialogContent sx={{ p: '24px !important' }}>
        <Box display="flex" justifyContent="center" alignItems="center" mb={2}>
          <SvgIcon inheritViewBox component={RocketSpeedup} sx={{ width: 90, height: 90 }} />
        </Box>

        <Typography data-testid="speedup-summary">
          Is this transaction taking too long? Speed it up by using the &quot;speed up&quot; option in your connected
          wallet.
        </Typography>
      </DialogContent>
    </ModalDialog>
  )
}
</file>

<file path="src/features/speedup/components/SpeedUpMonitor.tsx">
import { Alert, AlertTitle, Box, Button, SvgIcon, Typography } from '@mui/material'
import { SpeedUpModal } from '@/features/speedup/components/SpeedUpModal'
import Rocket from '@/public/images/common/rocket.svg'
import { useCounter } from '@/components/common/Notifications/useCounter'
import type { MouseEventHandler } from 'react'
import { useState } from 'react'
import type { PendingProcessingTx } from '@/store/pendingTxsSlice'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { isSmartContract } from '@/utils/wallets'
import useWallet from '@/hooks/wallets/useWallet'
import { isSpeedableTx } from '@/features/speedup/utils/IsSpeedableTx'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

type SpeedUpMonitorProps = {
  txId: string
  pendingTx: PendingProcessingTx
  modalTrigger: 'alertBox' | 'alertButton'
}

const SPEED_UP_THRESHOLD_IN_SECONDS = 15

export const SpeedUpMonitor = ({ txId, pendingTx, modalTrigger = 'alertBox' }: SpeedUpMonitorProps) => {
  const [openSpeedUpModal, setOpenSpeedUpModal] = useState(false)
  const wallet = useWallet()
  const counter = useCounter(pendingTx.submittedAt)
  const web3ReadOnly = useWeb3ReadOnly()
  const isFeatureEnabled = useHasFeature(FEATURES.SPEED_UP_TX)

  const [smartContract] = useAsync(async () => {
    if (!pendingTx.signerAddress || !web3ReadOnly) return false
    return isSmartContract(pendingTx.signerAddress)
  }, [pendingTx.signerAddress, web3ReadOnly])

  if (!isFeatureEnabled || !isSpeedableTx(pendingTx, smartContract, wallet?.address ?? '')) {
    return null
  }

  if (!counter || counter < SPEED_UP_THRESHOLD_IN_SECONDS) {
    return null
  }

  const onOpen: MouseEventHandler = (e) => {
    e.stopPropagation()
    setOpenSpeedUpModal(true)
    trackEvent(MODALS_EVENTS.OPEN_SPEED_UP_MODAL)
  }

  return (
    <>
      <Box>
        <SpeedUpModal
          open={openSpeedUpModal}
          handleClose={() => setOpenSpeedUpModal(false)}
          pendingTx={pendingTx}
          gasLimit={pendingTx.gasLimit}
          txId={txId}
          txHash={pendingTx.txHash!}
          signerAddress={pendingTx.signerAddress}
          signerNonce={pendingTx.signerNonce}
        />
        {modalTrigger === 'alertBox' ? (
          <Alert
            severity="warning"
            icon={<SvgIcon component={Rocket} />}
            action={<Button onClick={onOpen}>{`Speed up >`}</Button>}
          >
            <AlertTitle>
              <Typography
                sx={{
                  textAlign: 'left',
                }}
              >
                Taking too long?
              </Typography>
            </AlertTitle>
            Try to speed up with better gas parameters.
          </Alert>
        ) : (
          <Button variant="outlined" size="small" sx={{ py: 0.6 }} onClick={onOpen}>
            Speed up
          </Button>
        )}
      </Box>
    </>
  )
}
</file>

<file path="src/features/speedup/hooks/useSafeTransaction.tsx">
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import useChainId from '@/hooks/useChainId'
import { useEffect, useState } from 'react'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { createExistingTx } from '@/services/tx/tx-sender'

export const useSafeTransaction = (txId: string) => {
  const safeSdk = useSafeSDK()
  const chainId = useChainId()
  const [safeTx, setSafeTx] = useState<SafeTransaction>()

  useEffect(() => {
    if (!safeSdk) {
      return
    }
    createExistingTx(chainId, txId).then(setSafeTx)
  }, [chainId, txId, safeSdk])

  return safeTx
}
</file>

<file path="src/features/speedup/utils/IsSpeedableTx.tsx">
import { type PendingProcessingTx, PendingStatus, type PendingTx } from '@/store/pendingTxsSlice'
import { sameAddress } from '@safe-global/utils/utils/addresses'

export const isSpeedableTx = (
  pendingTx: PendingTx,
  isSmartContract: boolean | undefined,
  walletAddress: string,
): pendingTx is PendingProcessingTx => {
  return (
    pendingTx.status === PendingStatus.PROCESSING &&
    sameAddress(pendingTx.signerAddress, walletAddress) &&
    !isSmartContract
  )
}
</file>

<file path="src/features/stake/components/InfoTooltip/index.tsx">
import { SvgIcon, Tooltip } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import type { ReactNode } from 'react'

export function InfoTooltip({ title }: { title: string | ReactNode }) {
  return (
    <Tooltip title={title} arrow placement="top">
      <span>
        <SvgIcon
          component={InfoIcon}
          inheritViewBox
          color="border"
          fontSize="small"
          sx={{
            verticalAlign: 'middle',
            ml: 0.5,
          }}
        />
      </span>
    </Tooltip>
  )
}
</file>

<file path="src/features/stake/components/StakeButton/index.tsx">
import CheckWallet from '@/components/common/CheckWallet'
import Track from '@/components/common/Track'
import { AppRoutes } from '@/config/routes'
import useSpendingLimit from '@/hooks/useSpendingLimit'
import { Button } from '@mui/material'
import type { TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import { useRouter } from 'next/router'
import type { ReactElement } from 'react'
import StakeIcon from '@/public/images/common/stake.svg'
import type { STAKE_LABELS } from '@/services/analytics/events/stake'
import { STAKE_EVENTS } from '@/services/analytics/events/stake'
import { useCurrentChain } from '@/hooks/useChains'

const StakeButton = ({
  tokenInfo,
  trackingLabel,
}: {
  tokenInfo: TokenInfo
  trackingLabel: STAKE_LABELS
}): ReactElement => {
  const spendingLimit = useSpendingLimit(tokenInfo)
  const chain = useCurrentChain()
  const router = useRouter()

  return (
    <CheckWallet allowSpendingLimit={!!spendingLimit}>
      {(isOk) => (
        <Track {...STAKE_EVENTS.OPEN_STAKE} label={trackingLabel}>
          <Button
            data-testid="stake-btn"
            aria-label="Stake"
            variant="text"
            color="info"
            size="small"
            startIcon={<StakeIcon />}
            onClick={() => {
              router.push({
                pathname: AppRoutes.stake,
                query: {
                  ...router.query,
                  asset: `${chain?.shortName}_${
                    tokenInfo.type === TokenType.NATIVE_TOKEN ? 'NATIVE_TOKEN' : tokenInfo.address
                  }`,
                },
              })
            }}
            disabled={!isOk}
          >
            Stake
          </Button>
        </Track>
      )}
    </CheckWallet>
  )
}

export default StakeButton
</file>

<file path="src/features/stake/components/StakePage/index.tsx">
import { Stack } from '@mui/material'
import Disclaimer from '@/components/common/Disclaimer'
import WidgetDisclaimer from '@/components/common/WidgetDisclaimer'
import useStakeConsent from '@/features/stake/useStakeConsent'
import StakingWidget from '../StakingWidget'
import { useRouter } from 'next/router'
import { useGetIsSanctionedQuery } from '@/store/api/ofac'
import { skipToken } from '@reduxjs/toolkit/query/react'
import useWallet from '@/hooks/wallets/useWallet'
import useSafeInfo from '@/hooks/useSafeInfo'
import { getKeyWithTrueValue } from '@/utils/helpers'
import BlockedAddress from '@/components/common/BlockedAddress'

const StakePage = () => {
  const { isConsentAccepted, onAccept } = useStakeConsent()
  const router = useRouter()
  const { asset } = router.query

  const { safeAddress } = useSafeInfo()
  const wallet = useWallet()

  const { data: isSafeAddressBlocked } = useGetIsSanctionedQuery(safeAddress || skipToken)
  const { data: isWalletAddressBlocked } = useGetIsSanctionedQuery(wallet?.address || skipToken)
  const blockedAddresses = {
    [safeAddress]: !!isSafeAddressBlocked,
    [wallet?.address || '']: !!isWalletAddressBlocked,
  }

  const blockedAddress = getKeyWithTrueValue(blockedAddresses)

  if (blockedAddress) {
    return (
      <Stack
        direction="column"
        sx={{
          alignItems: 'center',
          justifyContent: 'center',
          flex: 1,
        }}
      >
        <BlockedAddress address={blockedAddress} featureTitle="stake feature with Kiln" />
      </Stack>
    )
  }

  return (
    <>
      {isConsentAccepted === undefined ? null : isConsentAccepted ? (
        <StakingWidget asset={String(asset)} />
      ) : (
        <Stack
          direction="column"
          sx={{
            alignItems: 'center',
            justifyContent: 'center',
            flex: 1,
          }}
        >
          <Disclaimer
            title="Note"
            content={<WidgetDisclaimer widgetName="Stake Widget by Kiln" />}
            onAccept={onAccept}
            buttonText="Continue"
          />
        </Stack>
      )}
    </>
  )
}

export default StakePage
</file>

<file path="src/features/stake/components/StakingConfirmationTx/Deposit.tsx">
import { Box, Stack, Typography } from '@mui/material'
import FieldsGrid from '@/components/tx/FieldsGrid'
import type { StakingTxDepositInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type NativeStakingDepositConfirmationView } from '@safe-global/safe-gateway-typescript-sdk'
import ConfirmationOrderHeader from '@/components/tx/ConfirmationOrder/ConfirmationOrderHeader'
import { formatDurationFromMilliseconds, formatVisualAmount, maybePlural } from '@safe-global/utils/utils/formatters'
import { formatCurrency } from '@safe-global/utils/utils/formatNumber'
import StakingStatus from '@/features/stake/components/StakingStatus'
import { InfoTooltip } from '@/features/stake/components/InfoTooltip'
import { BRAND_NAME } from '@/config/constants'

type StakingOrderConfirmationViewProps = {
  order: NativeStakingDepositConfirmationView | StakingTxDepositInfo
  isTxDetails?: boolean
}

const CURRENCY = 'USD'

const StakingConfirmationTxDeposit = ({ order, isTxDetails }: StakingOrderConfirmationViewProps) => {
  const isOrder = !isTxDetails

  // the fee is returned in decimal format, so we multiply by 100 to get the percentage
  const fee = (order.fee * 100).toFixed(2)
  return (
    <Stack
      sx={{
        gap: isOrder ? 2 : 1,
      }}
    >
      {isOrder && (
        <ConfirmationOrderHeader
          blocks={[
            {
              value: order.value,
              tokenInfo: order.tokenInfo,
              label: 'Deposit',
            },
            {
              value: order.annualNrr.toFixed(3) + '%',
              label: 'Rewards rate (after fees)',
            },
          ]}
        />
      )}
      <FieldsGrid title="Net annual rewards">
        {formatVisualAmount(order.expectedAnnualReward, order.tokenInfo.decimals)} {order.tokenInfo.symbol}
        {' ('}
        {formatCurrency(order.expectedFiatAnnualReward, CURRENCY)})
      </FieldsGrid>
      <FieldsGrid title="Net monthly rewards">
        {formatVisualAmount(order.expectedMonthlyReward, order.tokenInfo.decimals)} {order.tokenInfo.symbol}
        {' ('}
        {formatCurrency(order.expectedFiatMonthlyReward, CURRENCY)})
      </FieldsGrid>
      <FieldsGrid
        title={
          <>
            Fee
            <InfoTooltip
              title={`The widget fee incurred here is charged by Kiln for the operation of this widget. The fee is calculated automatically. Part of the fee will contribute to a license fee that supports the Safe Community. Neither the Safe Ecosystem Foundation nor ${BRAND_NAME} operates the Kiln Widget and/or Kiln.`}
            />
          </>
        }
      >
        {fee} %
      </FieldsGrid>
      <Stack
        {...{ [isOrder ? 'border' : 'borderTop']: '1px solid' }}
        {...(isOrder ? { p: 2, borderRadius: 1 } : { mt: 1, pt: 2, pb: 1 })}
        sx={{
          borderColor: 'border.light',
          gap: 1,
        }}
      >
        {isOrder ? (
          <Typography
            sx={{
              fontWeight: 'bold',
              mb: 2,
            }}
          >
            You will own{' '}
            <Box
              component="span"
              sx={{
                bgcolor: 'border.background',
                px: 1,
                py: 0.5,
                borderRadius: 1,
              }}
            >
              {order.numValidators} Ethereum validator{maybePlural(order.numValidators)}
            </Box>
          </Typography>
        ) : (
          <FieldsGrid title="Validators">{order.numValidators}</FieldsGrid>
        )}

        <FieldsGrid title="Activation time">{formatDurationFromMilliseconds(order.estimatedEntryTime)}</FieldsGrid>

        <FieldsGrid title="Rewards">Approx. every 5 days after activation</FieldsGrid>

        {!isOrder && (
          <FieldsGrid title="Validator status">
            <StakingStatus status={order.status} />
          </FieldsGrid>
        )}

        {isOrder && (
          <Typography
            variant="body2"
            sx={{
              color: 'text.secondary',
              mt: 2,
            }}
          >
            Earn ETH rewards with dedicated validators. Rewards must be withdrawn manually, and you can request a
            withdrawal at any time.
          </Typography>
        )}
      </Stack>
    </Stack>
  )
}

export default StakingConfirmationTxDeposit
</file>

<file path="src/features/stake/components/StakingConfirmationTx/Exit.tsx">
import { Alert, Stack, Typography } from '@mui/material'
import FieldsGrid from '@/components/tx/FieldsGrid'
import { formatDurationFromMilliseconds } from '@safe-global/utils/utils/formatters'
import ConfirmationOrderHeader from '@/components/tx/ConfirmationOrder/ConfirmationOrderHeader'
import { InfoTooltip } from '@/features/stake/components/InfoTooltip'
import type { StakingTxExitInfo } from '@safe-global/safe-gateway-typescript-sdk'

type StakingOrderConfirmationViewProps = {
  order: StakingTxExitInfo
}

const StakingConfirmationTxExit = ({ order }: StakingOrderConfirmationViewProps) => {
  const withdrawIn = formatDurationFromMilliseconds(order.estimatedExitTime + order.estimatedWithdrawalTime, [
    'days',
    'hours',
  ])

  return (
    <Stack
      sx={{
        gap: 2,
      }}
    >
      <ConfirmationOrderHeader
        blocks={[
          {
            value: `${order.numValidators} Validators`,
            label: 'Exit',
          },
          {
            value: order.value,
            tokenInfo: order.tokenInfo,
            label: 'Receive',
          },
        ]}
      />
      <FieldsGrid
        title={
          <>
            Withdraw in
            <InfoTooltip
              title={
                <>
                  Withdrawal time is the sum of:
                  <ul>
                    <li>Time until your validator is successfully exited after the withdraw request</li>
                    <li>Time for a stake to receive Consensus rewards on the execution layer</li>
                  </ul>
                </>
              }
            />
          </>
        }
      >
        Up to {withdrawIn}
      </FieldsGrid>
      <Typography
        variant="body2"
        sx={{
          color: 'text.secondary',
          mt: 2,
        }}
      >
        The selected amount and any rewards will be withdrawn from Dedicated Staking for ETH after the validator exit.
      </Typography>
      <Alert severity="warning" sx={{ mb: 1 }}>
        This transaction is a withdrawal request. After it&apos;s executed, you&apos;ll need to complete a separate
        withdrawal transaction.
      </Alert>
    </Stack>
  )
}

export default StakingConfirmationTxExit
</file>

<file path="src/features/stake/components/StakingConfirmationTx/index.tsx">
import type { StakingTxInfo } from '@safe-global/safe-gateway-typescript-sdk'
import StakingConfirmationTxDeposit from '@/features/stake/components/StakingConfirmationTx/Deposit'
import StakingConfirmationTxExit from '@/features/stake/components/StakingConfirmationTx/Exit'
import StakingConfirmationTxWithdraw from '@/features/stake/components/StakingConfirmationTx/Withdraw'
import { isStakingTxDepositInfo, isStakingTxExitInfo, isStakingTxWithdrawInfo } from '@/utils/transaction-guards'

type StakingOrderConfirmationViewProps = {
  order: StakingTxInfo
}

const StrakingConfirmationTx = ({ order }: StakingOrderConfirmationViewProps) => {
  if (isStakingTxDepositInfo(order)) {
    return <StakingConfirmationTxDeposit order={order} />
  }

  if (isStakingTxExitInfo(order)) {
    return <StakingConfirmationTxExit order={order} />
  }

  if (isStakingTxWithdrawInfo(order)) {
    return <StakingConfirmationTxWithdraw order={order} />
  }

  return null
}

export default StrakingConfirmationTx
</file>

<file path="src/features/stake/components/StakingConfirmationTx/Withdraw.tsx">
import { Stack } from '@mui/material'
import FieldsGrid from '@/components/tx/FieldsGrid'
import {
  type NativeStakingWithdrawConfirmationView,
  type StakingTxWithdrawInfo,
} from '@safe-global/safe-gateway-typescript-sdk'
import TokenAmount from '@/components/common/TokenAmount'

type StakingOrderConfirmationViewProps = {
  order: NativeStakingWithdrawConfirmationView | StakingTxWithdrawInfo
}

const StakingConfirmationTxWithdraw = ({ order }: StakingOrderConfirmationViewProps) => {
  return (
    <Stack
      sx={{
        gap: 2,
      }}
    >
      <FieldsGrid title="Receive">
        {' '}
        <TokenAmount
          value={order.value}
          tokenSymbol={order.tokenInfo.symbol}
          decimals={order.tokenInfo.decimals}
          logoUri={order.tokenInfo.logoUri}
        />
      </FieldsGrid>
    </Stack>
  )
}

export default StakingConfirmationTxWithdraw
</file>

<file path="src/features/stake/components/StakingStatus/index.tsx">
import { NativeStakingStatus } from '@safe-global/safe-gateway-typescript-sdk'
import { SvgIcon } from '@mui/material'
import CheckIcon from '@/public/images/common/circle-check.svg'
import ClockIcon from '@/public/images/common/clock.svg'
import SlashShield from '@/public/images/common/shield-off.svg'
import SignatureIcon from '@/public/images/common/document_signature.svg'
import TxStatusChip, { type TxStatusChipProps } from '@/components/transactions/TxStatusChip'

const ColorIcons: Record<
  NativeStakingStatus,
  | {
      color: TxStatusChipProps['color']
      icon?: React.ComponentType
      text: string
    }
  | undefined
> = {
  [NativeStakingStatus.NOT_STAKED]: {
    color: 'warning',
    icon: SignatureIcon,
    text: 'Inactive',
  },
  [NativeStakingStatus.ACTIVATING]: {
    color: 'info',
    icon: ClockIcon,
    text: 'Activating',
  },
  [NativeStakingStatus.DEPOSIT_IN_PROGRESS]: {
    color: 'info',
    icon: ClockIcon,
    text: 'Awaiting entry',
  },
  [NativeStakingStatus.ACTIVE]: {
    color: 'success',
    icon: CheckIcon,
    text: 'Validating',
  },
  [NativeStakingStatus.EXIT_REQUESTED]: {
    color: 'info',
    icon: ClockIcon,
    text: 'Requested exit',
  },
  [NativeStakingStatus.EXITING]: {
    color: 'info',
    icon: ClockIcon,
    text: 'Request pending',
  },
  [NativeStakingStatus.EXITED]: {
    color: 'success',
    icon: CheckIcon,
    text: 'Withdrawn',
  },
  [NativeStakingStatus.SLASHED]: {
    color: 'warning',
    icon: SlashShield,
    text: 'Slashed',
  },
}

const capitalizedStatus = (status: string) =>
  status
    .toLowerCase()
    .replace(/_/g, ' ')
    .replace(/^\w/g, (l) => l.toUpperCase())

const StakingStatus = ({ status }: { status: NativeStakingStatus }) => {
  const config = ColorIcons[status]

  return (
    <TxStatusChip color={config?.color}>
      {config?.icon && <SvgIcon component={config.icon} fontSize="small" inheritViewBox />}
      {config?.text || capitalizedStatus(status)}
    </TxStatusChip>
  )
}

export default StakingStatus
</file>

<file path="src/features/stake/components/StakingTxDepositDetails/index.tsx">
import { Box } from '@mui/material'
import type { StakingTxDepositInfo, TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import FieldsGrid from '@/components/tx/FieldsGrid'
import SendAmountBlock from '@/components/tx-flow/flows/TokenTransfer/SendAmountBlock'
import StakingConfirmationTxDeposit from '@/features/stake/components/StakingConfirmationTx/Deposit'

const StakingTxDepositDetails = ({ info, txData }: { info: StakingTxDepositInfo; txData?: TransactionData }) => {
  return (
    <Box
      sx={{
        pl: 1,
        pr: 5,
        display: 'flex',
        flexDirection: 'column',
        gap: 1,
      }}
    >
      {txData && (
        <SendAmountBlock title="Deposit" amountInWei={txData.value?.toString() || '0'} tokenInfo={info.tokenInfo} />
      )}
      <FieldsGrid title="Net reward rate">{info.annualNrr.toFixed(3)}%</FieldsGrid>
      <StakingConfirmationTxDeposit order={info} isTxDetails />
    </Box>
  )
}

export default StakingTxDepositDetails
</file>

<file path="src/features/stake/components/StakingTxDepositInfo/index.tsx">
import type { StakingTxDepositInfo as StakingTxDepositInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import TokenAmount from '@/components/common/TokenAmount'

export const StakingTxDepositInfo = ({ info }: { info: StakingTxDepositInfoType }) => {
  return (
    <>
      <TokenAmount
        value={info.value}
        tokenSymbol={info.tokenInfo.symbol}
        decimals={info.tokenInfo.decimals}
        logoUri={info.tokenInfo.logoUri}
      />
    </>
  )
}

export default StakingTxDepositInfo
</file>

<file path="src/features/stake/components/StakingTxExitDetails/index.tsx">
import { Box, Link } from '@mui/material'
import type { StakingTxExitInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { NativeStakingStatus } from '@safe-global/safe-gateway-typescript-sdk'
import FieldsGrid from '@/components/tx/FieldsGrid'
import StakingStatus from '@/features/stake/components/StakingStatus'
import { formatDurationFromMilliseconds } from '@safe-global/utils/utils/formatters'
import { BEACON_CHAIN_EXPLORERS } from '@/features/stake/constants'
import useChainId from '@/hooks/useChainId'

const StakingTxExitDetails = ({ info }: { info: StakingTxExitInfo }) => {
  const withdrawIn = formatDurationFromMilliseconds(info.estimatedExitTime + info.estimatedWithdrawalTime, [
    'days',
    'hours',
  ])

  return (
    <Box pr={5} display="flex" flexDirection="column" gap={1}>
      <FieldsGrid title="Exit">
        {info.validators.map((validator: string, index: number) => {
          return (
            <>
              <BeaconChainLink name={`Validator ${index + 1}`} validator={validator} key={index} />
              {index < info.validators.length - 1 && ' | '}
            </>
          )
        })}
      </FieldsGrid>
      {info.status !== NativeStakingStatus.EXITED && <FieldsGrid title="Est. exit time">Up to {withdrawIn}</FieldsGrid>}

      <FieldsGrid title="Validator status">
        <StakingStatus status={info.status} />
      </FieldsGrid>
    </Box>
  )
}

export const BeaconChainLink = ({ validator, name }: { validator: string; name: string }) => {
  const chainId = useChainId()
  return (
    <Link
      variant="body1"
      target="_blank"
      href={`${
        BEACON_CHAIN_EXPLORERS[chainId as keyof typeof BEACON_CHAIN_EXPLORERS] ?? 'https://beaconcha.in'
      }/validator/${validator}`}
    >
      {name}
    </Link>
  )
}
export default StakingTxExitDetails
</file>

<file path="src/features/stake/components/StakingTxExitInfo/index.tsx">
import { maybePlural } from '@safe-global/utils/utils/formatters'
import type { StakingTxExitInfo } from '@safe-global/safe-gateway-typescript-sdk'

const StakingTxExitInfo = ({ info }: { info: StakingTxExitInfo }) => {
  return (
    <>
      {info.numValidators} Validator{maybePlural(info.numValidators)}
    </>
  )
}

export default StakingTxExitInfo
</file>

<file path="src/features/stake/components/StakingTxWithdrawDetails/index.tsx">
import { Box } from '@mui/material'
import type { StakingTxWithdrawInfo } from '@safe-global/safe-gateway-typescript-sdk'
import StakingConfirmationTxWithdraw from '@/features/stake/components/StakingConfirmationTx/Withdraw'

const StakingTxWithdrawDetails = ({ info }: { info: StakingTxWithdrawInfo }) => {
  return (
    <Box pl={1} pr={5} display="flex" flexDirection="column" gap={1}>
      <StakingConfirmationTxWithdraw order={info} />
    </Box>
  )
}

export default StakingTxWithdrawDetails
</file>

<file path="src/features/stake/components/StakingTxWithdrawInfo/index.tsx">
import type { StakingTxWithdrawInfo } from '@safe-global/safe-gateway-typescript-sdk'
import TokenAmount from '@/components/common/TokenAmount'

const StakingTxWithdrawInfo = ({ info }: { info: StakingTxWithdrawInfo }) => {
  return (
    <>
      <TokenAmount
        value={info.value}
        tokenSymbol={info.tokenInfo.symbol}
        decimals={info.tokenInfo.decimals}
        logoUri={info.tokenInfo.logoUri}
      />
    </>
  )
}

export default StakingTxWithdrawInfo
</file>

<file path="src/features/stake/components/StakingWidget/index.tsx">
import { useMemo } from 'react'
import AppFrame from '@/components/safe-apps/AppFrame'
import { getEmptySafeApp } from '@/components/safe-apps/utils'
import { useGetStakeWidgetUrl } from '@/features/stake/hooks/useGetStakeWidgetUrl'
import { widgetAppData } from '@/features/stake/constants'

const StakingWidget = ({ asset }: { asset?: string }) => {
  const url = useGetStakeWidgetUrl(asset)

  const appData = useMemo(
    () => ({
      ...getEmptySafeApp(),
      ...widgetAppData,
      url,
    }),
    [url],
  )

  return (
    <AppFrame
      appUrl={appData.url}
      allowedFeaturesList="clipboard-read; clipboard-write"
      safeAppFromManifest={appData}
      isNativeEmbed
    />
  )
}

export default StakingWidget
</file>

<file path="src/features/stake/helpers/utils.ts">
import { id } from 'ethers'
import type { BaseTransaction } from '@safe-global/safe-apps-sdk'

const WITHDRAW_SIGHASH = id('requestValidatorsExit(bytes)').slice(0, 10)
const CLAIM_SIGHASH = id('batchWithdrawCLFee(bytes)').slice(0, 10)

export const getStakeTitle = (txs: BaseTransaction[] | undefined) => {
  const hashToLabel = {
    [WITHDRAW_SIGHASH]: 'Withdraw request',
    [CLAIM_SIGHASH]: 'Claim',
  }

  const stakeTitle = txs
    ?.map((tx) => hashToLabel[tx.data.slice(0, 10)])
    .filter(Boolean)
    .join(' and ')

  return stakeTitle
}
</file>

<file path="src/features/stake/hooks/useGetStakeWidgetUrl.ts">
import { useDarkMode } from '@/hooks/useDarkMode'
import useChainId from '@/hooks/useChainId'
import useChains from '@/hooks/useChains'
import { useMemo } from 'react'
import { WIDGET_PRODUCTION_URL, WIDGET_TESTNET_URL } from '@/features/stake/constants'

export const useGetStakeWidgetUrl = (asset?: string) => {
  let url = WIDGET_PRODUCTION_URL
  const isDarkMode = useDarkMode()
  const currentChainId = useChainId()
  const { configs } = useChains()
  const testChains = useMemo(() => configs.filter((chain) => chain.isTestnet), [configs])
  if (testChains.some((chain) => chain.chainId === currentChainId)) {
    url = WIDGET_TESTNET_URL
  }
  const params = new URLSearchParams()
  params.append('theme', isDarkMode ? 'dark' : 'light')

  if (asset) {
    params.append('asset', asset)
  }

  return url + '?' + params.toString()
}
</file>

<file path="src/features/stake/hooks/useIsStakingBannerEnabled.ts">
import { useHasFeature } from '@/hooks/useChains'
import useIsStakingFeatureEnabled from './useIsStakingFeatureEnabled'
import { FEATURES } from '@safe-global/utils/utils/chains'

const useIsStakingBannerEnabled = () => {
  const isStakingFeatureEnabled = useIsStakingFeatureEnabled()
  return useHasFeature(FEATURES.STAKING_BANNER) && isStakingFeatureEnabled
}

export default useIsStakingBannerEnabled
</file>

<file path="src/features/stake/hooks/useIsStakingFeatureEnabled.ts">
import { GeoblockingContext } from '@/components/common/GeoblockingProvider'
import { useHasFeature } from '@/hooks/useChains'
import { useContext } from 'react'
import { FEATURES } from '@safe-global/utils/utils/chains'

const useIsStakingFeatureEnabled = () => {
  const isBlockedCountry = useContext(GeoblockingContext)
  return useHasFeature(FEATURES.STAKING) && !isBlockedCountry
}

export default useIsStakingFeatureEnabled
</file>

<file path="src/features/stake/constants.ts">
export const STAKE_TITLE = 'Stake'

export const WIDGET_PRODUCTION_URL = 'https://safe.widget.kiln.fi/overview'
export const WIDGET_TESTNET_URL = 'https://safe.widget.testnet.kiln.fi/overview'

export const widgetAppData = {
  url: WIDGET_PRODUCTION_URL,
  name: STAKE_TITLE,
  iconUrl: '/images/common/stake.svg',
  chainIds: ['17000', '11155111', '1', '42161', '137', '56', '8453', '10'],
}

// TODO: move this to the config service
export const BEACON_CHAIN_EXPLORERS = {
  '1': 'https://beaconcha.in',
  '17000': 'https://holesky.beaconcha.in',
}
</file>

<file path="src/features/stake/useStakeConsent.ts">
import { localItem } from '@/services/local-storage/local'
import { useCallback, useEffect, useState } from 'react'

const STAKE_CONSENT_STORAGE_KEY = 'stakeDisclaimerAcceptedV1'
const stakeConsentStorage = localItem<boolean>(STAKE_CONSENT_STORAGE_KEY)

const useStakeConsent = (): {
  isConsentAccepted: boolean | undefined
  onAccept: () => void
} => {
  const [isConsentAccepted, setIsConsentAccepted] = useState<boolean | undefined>()

  const onAccept = useCallback(() => {
    setIsConsentAccepted(true)
    stakeConsentStorage.set(true)
  }, [setIsConsentAccepted])

  useEffect(() => {
    setIsConsentAccepted(stakeConsentStorage.get() || false)
  }, [setIsConsentAccepted])

  return {
    isConsentAccepted,
    onAccept,
  }
}

export default useStakeConsent
</file>

<file path="src/features/swap/components/HelpIconTooltip/index.tsx">
import { SvgIcon, Tooltip } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import type { ReactNode } from 'react'

type Props = {
  title: ReactNode
}
export const HelpIconTooltip = ({ title }: Props) => {
  return (
    <Tooltip title={title} arrow placement="top">
      <span>
        <SvgIcon
          component={InfoIcon}
          inheritViewBox
          color="border"
          fontSize="small"
          sx={{
            verticalAlign: 'middle',
            ml: 0.5,
          }}
        />
      </span>
    </Tooltip>
  )
}
</file>

<file path="src/features/swap/components/OrderId/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import OrderId from './index'
import { Paper } from '@mui/material'

const meta = {
  component: OrderId,
  parameters: {
    componentSubtitle: 'Renders an order id with an external link and a copy button',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof OrderId>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    orderId:
      '0x1282e32a3a69aeb5a65fcdec0ae40fe16b398d54609bc9a3c8be3eb57d1a0fd07a9af6ef9197041a5841e84cb27873bebd3486e2661510ab',
    href: 'https://explorer.cow.fi/orders/0x1282e32a3a69aeb5a65fcdec0ae40fe16b398d54609bc9a3c8be3eb57d1a0fd07a9af6ef9197041a5841e84cb27873bebd3486e2661510ab',
  },
}
</file>

<file path="src/features/swap/components/OrderId/index.tsx">
import CopyButton from '@/components/common/CopyButton'
import ExplorerButton from '@/components/common/ExplorerButton'
import { Box } from '@mui/material'
import Stack from '@mui/material/Stack'

const OrderId = ({
  orderId,
  href,
  length = 8,
  showCopyButton = true,
}: {
  orderId: string
  href: string
  length?: number
  showCopyButton?: boolean
}) => {
  // CoWSwap doesn't show the 0x at the beginning of a tx
  const truncatedOrderId = orderId.replace('0x', '').slice(0, length)

  return (
    <Stack direction="row">
      <span>{truncatedOrderId}</span>
      {showCopyButton && <CopyButton text={orderId} />}
      <Box color="border.main">
        <ExplorerButton href={href} />
      </Box>
    </Stack>
  )
}

export default OrderId
</file>

<file path="src/features/swap/components/StatusLabel/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import StatusLabel from './index'
import { Paper } from '@mui/material'

const meta = {
  component: StatusLabel,
  parameters: {
    componentSubtitle: 'Renders a Status label with icon and text for a swap order',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof StatusLabel>

export default meta
type Story = StoryObj<typeof meta>

export const Filled: Story = {
  args: {
    status: 'fulfilled',
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37793&mode=design&t=fZkl3tqjIWoYsB9C-4',
    },
  },
}

export const Pending: Story = {
  args: {
    status: 'presignaturePending',
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5981-14754&mode=design&t=fZkl3tqjIWoYsB9C-4',
    },
  },
}

export const Open: Story = {
  args: {
    status: 'open',
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37842&mode=design&t=fZkl3tqjIWoYsB9C-4',
    },
  },
}

export const Cancelled: Story = {
  args: {
    status: 'cancelled',
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37955&mode=design&t=fZkl3tqjIWoYsB9C-4',
    },
  },
}

export const Expired: Story = {
  args: {
    status: 'expired',
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-38019&mode=design&t=fZkl3tqjIWoYsB9C-4',
    },
  },
}

export const PartiallyFilled: Story = {
  args: {
    status: 'partiallyFilled',
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-38019&mode=design&t=fZkl3tqjIWoYsB9C-4',
    },
  },
}
</file>

<file path="src/features/swap/components/StatusLabel/index.tsx">
import { SvgIcon } from '@mui/material'
import type { OrderStatuses } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'
import CheckIcon from '@/public/images/common/circle-check.svg'
import ClockIcon from '@/public/images/common/clock.svg'
import BlockIcon from '@/public/images/common/block.svg'
import SignatureIcon from '@/public/images/common/document_signature.svg'
import CircleIPartialFillcon from '@/public/images/common/circle-partial-fill.svg'
import TxStatusChip, { type TxStatusChipProps } from '@/components/transactions/TxStatusChip'

type CustomOrderStatuses = OrderStatuses | 'partiallyFilled'
type Props = {
  status: CustomOrderStatuses
}

type StatusProps = {
  label: string
  color: TxStatusChipProps['color']
  icon: React.ComponentType
}

const statusMap: Record<CustomOrderStatuses, StatusProps> = {
  presignaturePending: {
    label: 'Execution needed',
    color: 'warning',
    icon: SignatureIcon,
  },
  fulfilled: {
    label: 'Filled',
    color: 'success',
    icon: CheckIcon,
  },
  open: {
    label: 'Open',
    color: 'warning',
    icon: ClockIcon,
  },
  cancelled: {
    label: 'Cancelled',
    color: 'error',
    icon: BlockIcon,
  },
  expired: {
    label: 'Expired',
    color: 'primary',
    icon: ClockIcon,
  },
  partiallyFilled: {
    label: 'Partially filled',
    color: 'success',
    icon: CircleIPartialFillcon,
  },
}
export const StatusLabel = (props: Props): ReactElement => {
  const { status } = props
  const { label, color, icon } = statusMap[status]

  return (
    <TxStatusChip color={color}>
      <SvgIcon component={icon} inheritViewBox fontSize="small" />
      {label}
    </TxStatusChip>
  )
}

export default StatusLabel
</file>

<file path="src/features/swap/components/SwapButton/index.tsx">
import CheckWallet from '@/components/common/CheckWallet'
import Track from '@/components/common/Track'
import { AppRoutes } from '@/config/routes'
import useSpendingLimit from '@/hooks/useSpendingLimit'
import type { SWAP_LABELS } from '@/services/analytics/events/swaps'
import { SWAP_EVENTS } from '@/services/analytics/events/swaps'
import { Button } from '@mui/material'
import type { TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useRouter } from 'next/router'
import type { ReactElement } from 'react'
import SwapIcon from '@/public/images/common/swap.svg'

const SwapButton = ({
  tokenInfo,
  amount,
  trackingLabel,
}: {
  tokenInfo: TokenInfo
  amount: string
  trackingLabel: SWAP_LABELS
}): ReactElement => {
  const spendingLimit = useSpendingLimit(tokenInfo)
  const router = useRouter()

  return (
    <CheckWallet allowSpendingLimit={!!spendingLimit}>
      {(isOk) => (
        <Track {...SWAP_EVENTS.OPEN_SWAPS} label={trackingLabel}>
          <Button
            data-testid="swap-btn"
            variant="outlined"
            color="primary"
            size="small"
            startIcon={<SwapIcon />}
            onClick={() => {
              router.push({
                pathname: AppRoutes.swap,
                query: {
                  ...router.query,
                  token: tokenInfo.address,
                  amount,
                },
              })
            }}
            disabled={!isOk}
          >
            Swap
          </Button>
        </Track>
      )}
    </CheckWallet>
  )
}

export default SwapButton
</file>

<file path="src/features/swap/components/SwapOrder/rows/PartBuyAmount.tsx">
import { Typography } from '@mui/material'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { type TwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import { DataRow } from '@/components/common/Table/DataRow'
import { Box } from '@mui/system'

export const PartBuyAmount = ({
  order,
  addonText = '',
}: {
  order: Pick<TwapOrder, 'minPartLimit' | 'buyToken'>
  addonText?: string
}) => {
  const { minPartLimit, buyToken } = order
  return (
    <DataRow title="Buy amount" key="buy_amount_part">
      <Box>
        <Typography component="span" fontWeight="bold">
          {formatVisualAmount(minPartLimit, buyToken.decimals)} {buyToken.symbol}
        </Typography>
        <Typography component="span" color="var(--color-primary-light)">
          {` ${addonText}`}
        </Typography>
      </Box>
    </DataRow>
  )
}
</file>

<file path="src/features/swap/components/SwapOrder/rows/PartDuration.tsx">
import { DataRow } from '@/components/common/Table/DataRow'
import { type TwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import { getPeriod } from '@safe-global/utils/utils/date'

export const PartDuration = ({ order }: { order: Pick<TwapOrder, 'timeBetweenParts'> }) => {
  const { timeBetweenParts } = order
  return (
    <DataRow title="Part duration" key="part_duration">
      {getPeriod(+timeBetweenParts)}
    </DataRow>
  )
}
</file>

<file path="src/features/swap/components/SwapOrder/rows/PartSellAmount.tsx">
import { Typography } from '@mui/material'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { type TwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import { DataRow } from '@/components/common/Table/DataRow'
import { Box } from '@mui/system'

export const PartSellAmount = ({
  order,
  addonText = '',
}: {
  order: Pick<TwapOrder, 'partSellAmount' | 'sellToken'>
  addonText?: string
}) => {
  const { partSellAmount, sellToken } = order
  return (
    <DataRow title="Sell amount" key="sell_amount_part">
      <Box>
        <Typography component="span" fontWeight="bold">
          {formatVisualAmount(partSellAmount, sellToken.decimals)} {sellToken.symbol}
        </Typography>
        <Typography component="span" color="var(--color-primary-light)">
          {` ${addonText}`}
        </Typography>
      </Box>
    </DataRow>
  )
}
</file>

<file path="src/features/swap/components/SwapOrder/rows/SurplusFee.tsx">
import type { TwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import { getOrderFeeBps } from '@/features/swap/helpers/utils'
import { DataRow } from '@/components/common/Table/DataRow'
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { HelpIconTooltip } from '@/features/swap/components/HelpIconTooltip'

export const SurplusFee = ({
  order,
}: {
  order: Pick<TwapOrder, 'fullAppData' | 'executedFee' | 'executedFeeToken'>
}) => {
  const bps = getOrderFeeBps(order)
  const { executedFee, executedFeeToken } = order

  if (!executedFee || executedFee === '0') {
    return null
  }

  return (
    <DataRow
      title={
        <>
          Total fees
          <HelpIconTooltip
            title={
              <>
                The amount of fees paid for this order.
                {bps > 0 && ` This includes a Widget fee of ${bps / 100}% and network fees.`}
              </>
            }
          />
        </>
      }
      key="widget_fee"
    >
      {formatVisualAmount(BigInt(executedFee), executedFeeToken.decimals)} {executedFeeToken.symbol}
    </DataRow>
  )
}
</file>

<file path="src/features/swap/components/SwapOrder/index.tsx">
import { Fragment } from 'react'
import OrderId from '@/features/swap/components/OrderId'
import StatusLabel from '@/features/swap/components/StatusLabel'
import SwapProgress from '@/features/swap/components/SwapProgress'
import { capitalize } from '@/hooks/useMnemonicName'
import { formatDateTime, formatTimeInWords } from '@safe-global/utils/utils/date'
import Stack from '@mui/material/Stack'
import type { ReactElement } from 'react'
import type { TwapOrder as SwapTwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import {
  type Order,
  type SwapOrder as SwapOrderType,
  type TransactionData,
} from '@safe-global/safe-gateway-typescript-sdk'
import { DataRow } from '@/components/common/Table/DataRow'
import { DataTable } from '@/components/common/Table/DataTable'
import { compareAsc } from 'date-fns'
import css from './styles.module.css'
import { Typography } from '@mui/material'
import { formatAmount } from '@safe-global/utils/utils/formatNumber'
import {
  getExecutionPrice,
  getLimitPrice,
  getOrderClass,
  getPartiallyFilledSurplus,
  getSurplusPrice,
  isOrderPartiallyFilled,
} from '@/features/swap/helpers/utils'
import EthHashInfo from '@/components/common/EthHashInfo'
import TokenAmount from '@/components/common/TokenAmount'
import useSafeInfo from '@/hooks/useSafeInfo'
import { isSwapOrderTxInfo, isSwapTransferOrderTxInfo, isTwapOrderTxInfo } from '@/utils/transaction-guards'
import { EmptyRow } from '@/components/common/Table/EmptyRow'
import { PartDuration } from '@/features/swap/components/SwapOrder/rows/PartDuration'
import { PartSellAmount } from '@/features/swap/components/SwapOrder/rows/PartSellAmount'
import { PartBuyAmount } from '@/features/swap/components/SwapOrder/rows/PartBuyAmount'
import { SurplusFee } from '@/features/swap/components/SwapOrder/rows/SurplusFee'

type SwapOrderProps = {
  txData?: TransactionData
  txInfo?: Order
}

const TWAP_PARTS_STATUS_THRESHOLD = 10

const AmountRow = ({ order }: { order: Order }) => {
  const { sellToken, buyToken, sellAmount, buyAmount, kind } = order
  const isSellOrder = kind === 'sell'
  return (
    <DataRow key="Amount" title="Amount">
      <Stack
        sx={{
          flexDirection: isSellOrder ? 'column' : 'column-reverse',
        }}
      >
        <div>
          <span className={css.value}>
            {isSellOrder ? 'Sell' : 'For at most'}{' '}
            <TokenAmount
              value={sellAmount}
              decimals={sellToken.decimals}
              tokenSymbol={sellToken.symbol}
              logoUri={sellToken.logoUri ?? undefined}
            />
          </span>
        </div>
        <div>
          <span className={css.value}>
            {isSellOrder ? 'for at least' : 'Buy'}{' '}
            <TokenAmount
              value={buyAmount}
              decimals={buyToken.decimals}
              tokenSymbol={buyToken.symbol}
              logoUri={buyToken.logoUri ?? undefined}
            />
          </span>
        </div>
      </Stack>
    </DataRow>
  )
}

const PriceRow = ({ order }: { order: Order }) => {
  const { status, sellToken, buyToken } = order
  const executionPrice = getExecutionPrice(order)
  const limitPrice = getLimitPrice(order)

  if (status === 'fulfilled') {
    return (
      <DataRow key="Execution price" title="Execution price">
        1 {buyToken.symbol} = {formatAmount(executionPrice)} {sellToken.symbol}
      </DataRow>
    )
  }

  return (
    <DataRow key="Limit price" title="Limit price">
      1 {buyToken.symbol} = {formatAmount(limitPrice)} {sellToken.symbol}
    </DataRow>
  )
}

const ExpiryRow = ({ order }: { order: Order }) => {
  const { validUntil, status } = order
  const now = new Date()
  const expires = new Date(validUntil * 1000)
  if (status! == 'fulfilled') {
    if (compareAsc(now, expires) !== 1) {
      return (
        <DataRow key="Expiry" title="Expiry">
          <Typography>
            <Typography
              component="span"
              sx={{
                fontWeight: 700,
              }}
            >
              {formatTimeInWords(validUntil * 1000)}
            </Typography>{' '}
            ({formatDateTime(validUntil * 1000)})
          </Typography>
        </DataRow>
      )
    } else {
      return (
        <DataRow key="Expiry" title="Expiry">
          {formatDateTime(validUntil * 1000)}
        </DataRow>
      )
    }
  }

  return null
}

const SurplusRow = ({ order }: { order: Order }) => {
  const { status, kind } = order
  const isPartiallyFilled = isOrderPartiallyFilled(order)
  const surplusPrice = isPartiallyFilled ? getPartiallyFilledSurplus(order) : getSurplusPrice(order)
  const { sellToken, buyToken } = order
  const isSellOrder = kind === 'sell'
  if (status === 'fulfilled' || isPartiallyFilled) {
    return (
      <DataRow key="Surplus" title="Surplus">
        {formatAmount(surplusPrice)} {isSellOrder ? buyToken.symbol : sellToken.symbol}
      </DataRow>
    )
  }

  return null
}

const FilledRow = ({ order }: { order: Order }) => {
  const orderClass = getOrderClass(order)
  if (['limit', 'twap'].includes(orderClass)) {
    return (
      <DataRow title="Filled" key="Filled">
        <SwapProgress order={order} />
      </DataRow>
    )
  }

  return null
}

const OrderUidRow = ({ order }: { order: Order }) => {
  if (isSwapOrderTxInfo(order) || isSwapTransferOrderTxInfo(order)) {
    const { uid, explorerUrl } = order
    return (
      <DataRow key="Order ID" title="Order ID">
        <OrderId orderId={uid} href={explorerUrl} />
      </DataRow>
    )
  }
  return null
}

const StatusRow = ({ order }: { order: Order }) => {
  const { status } = order
  const isPartiallyFilled = isOrderPartiallyFilled(order)
  return (
    <DataRow key="Status" title="Status">
      <StatusLabel status={isPartiallyFilled ? 'partiallyFilled' : status} />
    </DataRow>
  )
}

const RecipientRow = ({ order }: { order: Order }) => {
  const { safeAddress } = useSafeInfo()
  const { receiver } = order

  if (receiver && receiver !== safeAddress) {
    return (
      <DataRow key="Recipient" title="Recipient">
        <EthHashInfo address={receiver} showAvatar={false} />
      </DataRow>
    )
  }

  return null
}

export const SellOrder = ({ order }: { order: SwapOrderType }) => {
  const { kind } = order
  const orderKindLabel = capitalize(kind)

  return (
    <DataTable
      header={`${orderKindLabel} order`}
      rows={[
        <AmountRow order={order} key="amount-row" />,
        <PriceRow order={order} key="price-row" />,
        <SurplusRow order={order} key="surplus-row" />,
        <ExpiryRow order={order} key="expiry-row" />,
        <FilledRow order={order} key="filled-row" />,
        <OrderUidRow order={order} key="order-uid-row" />,
        <StatusRow order={order} key="status-row" />,
        <RecipientRow order={order} key="recipient-row" />,
        <SurplusFee order={order} key="fee-row" />,
      ]}
    />
  )
}

export const TwapOrder = ({ order }: { order: SwapTwapOrder }) => {
  const { kind, validUntil, status, numberOfParts } = order

  const isPartiallyFilled = isOrderPartiallyFilled(order)
  const expires = new Date(validUntil * 1000)
  const now = new Date()
  const orderKindLabel = capitalize(kind)

  const isStatusKnown = Number(numberOfParts) <= TWAP_PARTS_STATUS_THRESHOLD
  return (
    <DataTable
      header={`${orderKindLabel} order`}
      rows={[
        <AmountRow order={order} key="amount-row" />,
        <PriceRow order={order} key="price-row" />,
        <SurplusRow order={order} key="surplus-row" />,
        <RecipientRow order={order} key="recipient-row" />,
        <SurplusFee order={order} key="fee-row" />,
        <EmptyRow key="spacer-0" />,
        <DataRow title="No of parts" key="n_of_parts">
          {numberOfParts}
        </DataRow>,
        <PartSellAmount order={order} key="part_sell_amount" />,
        <PartBuyAmount order={order} key="part_buy_amount" />,
        order.executedSellAmount !== null && order.executedBuyAmount !== null ? (
          <FilledRow order={order} key="filled-row" />
        ) : (
          <Fragment key="filled-row" />
        ),
        <PartDuration order={order} key="part_duration" />,
        <EmptyRow key="spacer-1" />,
        status !== 'fulfilled' && compareAsc(now, expires) !== 1 ? (
          <DataRow key="Expiry" title="Expiry">
            <Typography>
              <Typography
                component="span"
                sx={{
                  fontWeight: 700,
                }}
              >
                {formatTimeInWords(validUntil * 1000)}
              </Typography>{' '}
              ({formatDateTime(validUntil * 1000)})
            </Typography>
          </DataRow>
        ) : (
          <DataRow key="Expired" title="Expired">
            {formatDateTime(validUntil * 1000)}
          </DataRow>
        ),
        isStatusKnown ? (
          <DataRow key="Status" title="Status">
            <StatusLabel status={isPartiallyFilled ? 'partiallyFilled' : status} />
          </DataRow>
        ) : (
          <Fragment key="status" />
        ),
      ]}
    />
  )
}

export const SwapOrder = ({ txInfo }: SwapOrderProps): ReactElement | null => {
  if (!txInfo) return null

  if (isTwapOrderTxInfo(txInfo)) {
    return <TwapOrder order={txInfo} />
  }

  if (isSwapOrderTxInfo(txInfo) || isSwapTransferOrderTxInfo(txInfo)) {
    return <SellOrder order={txInfo} />
  }
  return null
}

export default SwapOrder
</file>

<file path="src/features/swap/components/SwapOrder/styles.module.css">
.actionsHeader {
  border-bottom: 1px solid var(--color-border-light);
  cursor: auto !important;
  padding-left: var(--space-2);
  padding-right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.compactHeader {
  border: 0;
  padding-left: 0;
}

.actionsHeader button {
  padding-left: 18px;
  padding-right: 18px;
}

.divider {
  margin-top: 14px;
  margin-bottom: 14px;
  border: 1px solid var(--color-border-light);
}

.compact {
  display: flex;
  flex-direction: column;
}

.compact > div:first-child {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.compact > div ~ div {
  border-radius: 0;
  margin-top: -1px !important;
}

.compact > div:hover,
.compact > div:global(.Mui-expanded) {
  border-color: var(--color-border-light);
}

.value {
  display: flex;
  align-items: center;
  gap: var(--space-1);
}
</file>

<file path="src/features/swap/components/SwapOrder/swap.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { SellOrder as SellOrderComponent } from './index'
import { Paper } from '@mui/material'
import type { OrderStatuses } from '@safe-global/safe-gateway-typescript-sdk'
import { appDataBuilder, orderTokenBuilder, swapOrderBuilder } from '@/features/swap/helpers/swapOrderBuilder'
import { StoreDecorator } from '@/stories/storeDecorator'

const FulfilledSwapOrder = swapOrderBuilder()
  .with({
    uid: '0x03a5d561ad2452d719a0d075573f4bed68217c696b52f151122c30e3e4426f1b05e6b5eb1d0e6aabab082057d5bb91f2ee6d11be66223d88',
  })
  .with({ status: 'fulfilled' })
  .with({ kind: 'sell' })
  .with({ orderClass: 'limit' })
  .with({ sellAmount: '10000000000000000' })
  .with({ executedSellAmount: '10000000000000000' })
  .with({ buyAmount: '3388586928324482608' })
  .with({ executedBuyAmount: '3388586928324482608' })
  .with({ validUntil: 1713520008 })
  .with({
    sellToken: {
      ...orderTokenBuilder().build(),
      logoUri:
        'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14.png',
    },
  })
  .with({
    buyToken: {
      ...orderTokenBuilder().build(),
      logoUri:
        'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0xbe72E441BF55620febc26715db68d3494213D8Cb.png',
    },
  })
  .with({
    explorerUrl:
      'https://explorer.cow.fi/orders/0x03a5d561ad2452d719a0d075573f4bed68217c696b52f151122c30e3e4426f1b05e6b5eb1d0e6aabab082057d5bb91f2ee6d11be66223d88',
  })
  .with({
    fullAppData: appDataBuilder('market').build(),
  })

const NonFulfilledSwapOrder = {
  ...FulfilledSwapOrder.build(),
  status: 'open' as OrderStatuses,
  expiresTimestamp: new Date().getTime() / 1000 + 28 * 60,
  executedSellAmount: '0',
}

const meta = {
  component: SellOrderComponent,
  parameters: {
    componentSubtitle: 'Renders a Status label with icon and text for a swap order',
  },

  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{}}>
          <Paper sx={{ padding: 2 }}>
            <Story />
          </Paper>
        </StoreDecorator>
      )
    },
  ],
  tags: ['autodocs'],
  // excludeStories: ['SwapOrderProps'],
} satisfies Meta<typeof SellOrderComponent>

export default meta
type Story = StoryObj<typeof meta>

export const ExecutedMarket: Story = {
  args: {
    order: FulfilledSwapOrder.build(),
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37759&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}
export const ExecutedLimit: Story = {
  args: {
    order: FulfilledSwapOrder.with({ fullAppData: appDataBuilder('limit').build() }).build(),
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37759&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const PendingMarket: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('market').build(),
      status: 'presignaturePending' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 + 28 * 60,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5974-14391&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const PendingLimit: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('limit').build(),
      status: 'presignaturePending' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 + 28 * 60,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5974-14391&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const OpenMarket: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37808&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}
export const OpenLimit: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('limit').build(),
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37808&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}
export const CancelledMarket: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('market').build(),
      status: 'cancelled' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 - 28 * 60,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37924&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const CancelledLimit: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('limit').build(),
      status: 'cancelled' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 - 28 * 60,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37924&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const ExpiredSwap: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('market').build(),
      status: 'expired' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 - 28 * 60,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37987&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const ExpiredLimit: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('limit').build(),
      status: 'expired' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 - 28 * 60,
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37987&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const LimitOpenPartiallyFilled: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('limit').build(),
      status: 'open' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 + 28 * 60,
      executedSellAmount: '1000000000000000',
      executedBuyAmount: '3388586928324',
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37987&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}

export const LimitExpiredPartiallyFilled: Story = {
  args: {
    order: {
      ...NonFulfilledSwapOrder,
      fullAppData: appDataBuilder('limit').build(),
      status: 'expired' as OrderStatuses,
      validUntil: new Date().getTime() / 1000 - 28 * 60,
      executedSellAmount: '1000000000000000',
      executedBuyAmount: '3388586928324',
    },
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5813-37987&mode=design&t=cJDGDQGZFqccSTaB-4',
    },
  },
}
</file>

<file path="src/features/swap/components/SwapOrder/twap.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import { TwapOrder as TwapOrderComponent } from './index'
import { Paper } from '@mui/material'
import { appDataBuilder, orderTokenBuilder, twapOrderBuilder } from '@/features/swap/helpers/swapOrderBuilder'
import { StoreDecorator } from '@/stories/storeDecorator'

const FullfilledTwapOrder = twapOrderBuilder()
  .with({ status: 'fulfilled' })
  .with({ kind: 'sell' })
  .with({ orderClass: 'limit' })
  .with({ sellAmount: '10000000000000000' })
  .with({ executedSellAmount: '10000000000000000' })
  .with({ buyAmount: '3388586928324482608' })
  .with({ executedBuyAmount: '3388586928324482608' })
  .with({ validUntil: 1713520008 })
  .with({
    sellToken: {
      ...orderTokenBuilder().build(),
      logoUri:
        'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14.png',
    },
  })
  .with({
    buyToken: {
      ...orderTokenBuilder().build(),
      logoUri:
        'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0xbe72E441BF55620febc26715db68d3494213D8Cb.png',
    },
  })
  .with({ numberOfParts: '2' })

  .with({ partSellAmount: '5000000000000000' })
  .with({ minPartLimit: '1694293464162241304' })
  .with({ timeBetweenParts: 1800 })
  .with({
    fullAppData: appDataBuilder('twap').build(),
  })

const meta = {
  component: TwapOrderComponent,
  parameters: {
    componentSubtitle: 'Renders a Status label with icon and text for a swap order',
  },

  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{}}>
          <Paper sx={{ padding: 2 }}>
            <Story />
          </Paper>
        </StoreDecorator>
      )
    },
  ],
  tags: ['autodocs'],
  // excludeStories: ['SwapOrderProps'],
} satisfies Meta<typeof TwapOrderComponent>

export default meta
type Story = StoryObj<typeof meta>

export const ExecutedTwap: Story = {
  args: {
    order: FullfilledTwapOrder.build(),
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/design/VyA38zUPbJ2zflzCIYR6Nu/Swap?node-id=6655-24390&t=pg5ZPJArWFJOiEsn-4',
    },
  },
}
</file>

<file path="src/features/swap/components/SwapOrderConfirmationView/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import CowOrderConfirmationView from './index'
import { Paper } from '@mui/material'
import type { OrderStatuses } from '@safe-global/safe-gateway-typescript-sdk'
import { orderTokenBuilder, swapOrderConfirmationViewBuilder } from '@/features/swap/helpers/swapOrderBuilder'
import { faker } from '@faker-js/faker'
import { StoreDecorator } from '@/stories/storeDecorator'

const Order = swapOrderConfirmationViewBuilder()
  .with({ kind: 'sell' })
  .with({ sellAmount: '10000000' })
  .with({ executedSellAmount: '10000000' })
  .with({ sellToken: { ...orderTokenBuilder().build(), decimals: 6 } })
  .with({ validUntil: new Date().getTime() / 1000 + 28 * 60 })
  .with({ status: 'open' as OrderStatuses })

const meta = {
  component: CowOrderConfirmationView,

  decorators: [
    (Story) => {
      return (
        <StoreDecorator initialState={{}}>
          <Paper sx={{ padding: 2 }}>
            <Story />
          </Paper>
        </StoreDecorator>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof CowOrderConfirmationView>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    order: Order.build(),
    settlementContract: faker.finance.ethereumAddress(),
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5256-18562&mode=design&t=FlMhDhzNxpNKWuc1-4',
    },
  },
}

export const CustomRecipient: Story = {
  args: {
    order: Order.with({ receiver: faker.finance.ethereumAddress() }).build(),
    settlementContract: faker.finance.ethereumAddress(),
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?type=design&node-id=5752-17758&mode=design&t=0Hnp94dhQMroAAnr-4',
    },
  },
}
</file>

<file path="src/features/swap/components/SwapOrderConfirmationView/index.tsx">
import OrderId from '@/features/swap/components/OrderId'
import { formatDateTime, formatTimeInWords, getPeriod } from '@safe-global/utils/utils/date'
import { Fragment, type ReactElement } from 'react'
import { DataRow } from '@/components/common/Table/DataRow'
import { DataTable } from '@/components/common/Table/DataTable'
import { compareAsc } from 'date-fns'
import { Alert, Typography } from '@mui/material'
import { formatAmount } from '@safe-global/utils/utils/formatNumber'
import { getLimitPrice, getOrderClass, getSlippageInPercent } from '@/features/swap/helpers/utils'
import type { DataDecoded, SwapOrder, SwapTransferOrder, TwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import { StartTimeValue, TransactionInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import SwapTokens from '@/features/swap/components/SwapTokens'
import AlertIcon from '@/public/images/common/alert.svg'
import EthHashInfo from '@/components/common/EthHashInfo'
import css from './styles.module.css'
import NamedAddress from '@/components/common/NamedAddressInfo'
import { PartDuration } from '@/features/swap/components/SwapOrder/rows/PartDuration'
import { PartSellAmount } from '@/features/swap/components/SwapOrder/rows/PartSellAmount'
import { PartBuyAmount } from '@/features/swap/components/SwapOrder/rows/PartBuyAmount'
import { OrderFeeConfirmationView } from '@/features/swap/components/SwapOrderConfirmationView/OrderFeeConfirmationView'
import { isSettingTwapFallbackHandler } from '@/features/swap/helpers/utils'
import { TwapFallbackHandlerWarning } from '@/features/swap/components/TwapFallbackHandlerWarning'

type SwapOrderProps = {
  order: SwapOrder | SwapTransferOrder | TwapOrder
  settlementContract: string
  decodedData?: DataDecoded
}

export const SwapOrderConfirmation = ({ order, decodedData, settlementContract }: SwapOrderProps): ReactElement => {
  const { owner, kind, validUntil, sellToken, buyToken, sellAmount, buyAmount, explorerUrl, receiver } = order

  const isTwapOrder = order.type === TransactionInfoType.TWAP_ORDER

  const limitPrice = getLimitPrice(order)
  const orderClass = getOrderClass(order)
  const expires = new Date(validUntil * 1000)
  const now = new Date()

  const slippage = getSlippageInPercent(order)
  const isSellOrder = kind === 'sell'
  const isChangingFallbackHandler = decodedData && isSettingTwapFallbackHandler(decodedData)

  return (
    <>
      {isChangingFallbackHandler && <TwapFallbackHandlerWarning />}

      <DataTable
        header="Order details"
        rows={[
          <div key="amount" className={css.amount}>
            <SwapTokens
              first={{
                value: sellAmount,
                label: isSellOrder ? 'Sell' : 'For at most',
                tokenInfo: sellToken,
              }}
              second={{
                value: buyAmount,
                label: isSellOrder ? 'For at least' : 'Buy exactly',
                tokenInfo: buyToken,
              }}
            />
          </div>,

          <DataRow datatestid="limit-price" key="Limit price" title="Limit price">
            1 {buyToken.symbol} = {formatAmount(limitPrice)} {sellToken.symbol}
          </DataRow>,

          compareAsc(now, expires) !== 1 ? (
            <DataRow datatestid="expiry" key="Expiry" title="Expiry">
              <Typography>
                <Typography fontWeight={700} component="span">
                  {formatTimeInWords(validUntil * 1000)}
                </Typography>{' '}
                ({formatDateTime(validUntil * 1000)})
              </Typography>
            </DataRow>
          ) : (
            <DataRow key="Expiry" title="Expiry">
              {formatDateTime(validUntil * 1000)}
            </DataRow>
          ),
          orderClass !== 'limit' ? (
            <DataRow datatestid="slippage" key="Slippage" title="Slippage">
              {slippage}%
            </DataRow>
          ) : (
            <Fragment key="none" />
          ),
          !isTwapOrder ? (
            <DataRow datatestid="order-id" key="Order ID" title="Order ID">
              <OrderId orderId={order.uid} href={explorerUrl} />
            </DataRow>
          ) : (
            <></>
          ),
          <OrderFeeConfirmationView key="SurplusFee" order={order} />,
          <DataRow datatestid="interact-wth" key="Interact with" title="Interact with">
            <NamedAddress address={settlementContract} onlyName hasExplorer shortAddress={false} avatarSize={24} />
          </DataRow>,
          receiver && owner !== receiver ? (
            <>
              <DataRow datatestid="recipient" key="recipient-address" title="Recipient">
                <EthHashInfo address={receiver} hasExplorer={true} avatarSize={24} />
              </DataRow>
              <div key="recipient">
                <Alert data-testid="recipient-alert" severity="warning" icon={AlertIcon}>
                  <Typography variant="body2">
                    <Typography component="span" sx={{ fontWeight: 'bold' }}>
                      Order recipient address differs from order owner.
                    </Typography>{' '}
                    Double check the address to prevent fund loss.
                  </Typography>
                </Alert>
              </div>
            </>
          ) : (
            <></>
          ),
        ]}
      />

      {isTwapOrder && (
        <div className={css.partsBlock}>
          <DataTable
            rows={[
              <Typography key="title" variant="body1" className={css.partsBlockTitle}>
                <strong>
                  Order will be split in{' '}
                  <span className={css.numberOfPartsLabel}>{order.numberOfParts} equal parts</span>
                </strong>
              </Typography>,
              <PartSellAmount order={order} addonText="per part" key="sell_part" />,
              <PartBuyAmount order={order} addonText="per part" key="buy_part" />,
              <DataRow title="Start time" key="Start time">
                {order.startTime.startType === StartTimeValue.AT_MINING_TIME && 'Now'}
                {order.startTime.startType === StartTimeValue.AT_EPOCH && `At block number: ${order.startTime.epoch}`}
              </DataRow>,
              <PartDuration order={order} key="part_duration" />,
              <DataRow title="Total duration" key="total_duration">
                {getPeriod(+order.timeBetweenParts * +order.numberOfParts)}
              </DataRow>,
            ]}
          />
        </div>
      )}
    </>
  )
}

export default SwapOrderConfirmation
</file>

<file path="src/features/swap/components/SwapOrderConfirmationView/OrderFeeConfirmationView.tsx">
import type { SwapOrderConfirmationView, TwapOrderConfirmationView } from '@safe-global/safe-gateway-typescript-sdk'
import { getOrderFeeBps } from '@/features/swap/helpers/utils'
import { DataRow } from '@/components/common/Table/DataRow'
import { BRAND_NAME, HelpCenterArticle } from '@/config/constants'
import { HelpIconTooltip } from '@/features/swap/components/HelpIconTooltip'
import MUILink from '@mui/material/Link'

export const OrderFeeConfirmationView = ({
  order,
}: {
  order: Pick<SwapOrderConfirmationView | TwapOrderConfirmationView, 'fullAppData'>
}) => {
  const bps = getOrderFeeBps(order)

  if (Number(bps) === 0) {
    return null
  }

  const title = (
    <>
      Widget fee{' '}
      <HelpIconTooltip
        title={
          <>
            The tiered widget fee incurred here is charged by CoW Protocol for the operation of this widget. The fee is
            automatically calculated into this quote. Part of the fee will contribute to a license fee that supports the
            Safe Community. Neither the Safe Ecosystem Foundation nor {`${BRAND_NAME}`} operate the CoW Swap Widget
            and/or CoW Swap.
            <MUILink href={HelpCenterArticle.SWAP_WIDGET_FEES} target="_blank" rel="noopener noreferrer">
              Learn more
            </MUILink>
          </>
        }
      />
    </>
  )

  return (
    <DataRow datatestid="widget-fee" title={title} key="widget_fee">
      {Number(bps) / 100} %
    </DataRow>
  )
}
</file>

<file path="src/features/swap/components/SwapOrderConfirmationView/styles.module.css">
.amount {
  margin-bottom: var(--space-1);
}
.partsBlock {
  border: 1px solid var(--color-border-light);
  border-radius: 4px;
  padding: calc(var(--space-1) - 6px) var(--space-2);
  margin-top: var(--space-1);
}

.partsBlockTitle {
  padding: var(--space-1) 0;
}

.numberOfPartsLabel {
  display: inline-block;
  border-radius: 4px;
  padding: 2px 8px;
  background-color: var(--color-border-background);
}
</file>

<file path="src/features/swap/components/SwapProgress/index.stories.tsx">
import { orderTokenBuilder, swapOrderBuilder } from '@/features/swap/helpers/swapOrderBuilder'
import type { Meta, StoryObj } from '@storybook/react'
import SwapProgress from './index'
import { Paper } from '@mui/material'

const meta = {
  component: SwapProgress,
  parameters: {
    componentSubtitle: 'Renders a linear progress bar with % of a token sold',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof SwapProgress>

export default meta
type Story = StoryObj<typeof meta>

export const Filled: Story = {
  args: {
    order: swapOrderBuilder()
      .with({ kind: 'sell' })
      .with({ sellAmount: '10000000' })
      .with({ executedSellAmount: '10000000' })
      .with({ sellToken: { ...orderTokenBuilder().build(), decimals: 6 } })
      .build(),
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/VyA38zUPbJ2zflzCIYR6Nu/Swap?node-id=5974%3A14487&mode=dev',
    },
  },
}

export const PartiallyFilled: Story = {
  args: {
    order: swapOrderBuilder()
      .with({ kind: 'sell' })
      .with({ sellAmount: '5000000' })
      .with({ executedSellAmount: '1000000' })
      .with({ sellToken: { ...orderTokenBuilder().build(), decimals: 6 } })
      .build(),
  },
}

export const NotFilled: Story = {
  args: {
    order: swapOrderBuilder()
      .with({ kind: 'sell' })
      .with({ sellAmount: '5000000' })
      .with({ executedSellAmount: '0' })
      .with({ sellToken: { ...orderTokenBuilder().build(), decimals: 6 } })
      .build(),
  },
}
</file>

<file path="src/features/swap/components/SwapProgress/index.tsx">
import { getFilledAmount, getFilledPercentage } from '@/features/swap/helpers/utils'
import { formatAmount } from '@safe-global/utils/utils/formatNumber'
import { LinearProgress, Stack, Typography } from '@mui/material'
import type { Order } from '@safe-global/safe-gateway-typescript-sdk'

const SwapProgress = ({ order }: { order: Order }) => {
  const filledPercentage = getFilledPercentage(order)
  const filledAmount = formatAmount(getFilledAmount(order))

  const progressValue = Math.min(Math.max(Number(filledPercentage), 0), 100)
  const isFilled = progressValue >= 100
  const color = isFilled ? 'success' : 'warning'

  const isSellOrder = order.kind === 'sell'
  const tokenSymbol = isSellOrder ? order.sellToken.symbol : order.buyToken.symbol

  return (
    <Stack direction="row" alignItems="center" gap={1}>
      <LinearProgress
        variant="determinate"
        value={progressValue}
        sx={{ width: '100px', borderRadius: '6px' }}
        color={color}
      />
      <Typography color={`${color}.main`}>{progressValue} %</Typography>
      <Typography>
        <Typography component="span" fontWeight="bold">
          {filledAmount} {tokenSymbol}
        </Typography>{' '}
        sold
      </Typography>
    </Stack>
  )
}

export default SwapProgress
</file>

<file path="src/features/swap/components/SwapTokens/index.stories.tsx">
import type { Meta, StoryObj } from '@storybook/react'
import SwapTokens from './index'
import { Paper } from '@mui/material'

const meta = {
  component: SwapTokens,
  parameters: {
    componentSubtitle: 'Renders a token swap between two tokens',
  },

  decorators: [
    (Story) => {
      return (
        <Paper sx={{ padding: 2 }}>
          <Story />
        </Paper>
      )
    },
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof SwapTokens>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    first: {
      value: '100',
      label: 'Sell',
      tokenInfo: {
        decimals: 18,
        logoUri:
          'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0x0625aFB445C3B6B7B929342a04A22599fd5dBB59.png',
        symbol: 'COW',
      },
    },
    second: {
      value: '86',
      label: 'For at least',
      tokenInfo: {
        decimals: 18,
        logoUri:
          'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984.png',
        symbol: 'UNI',
      },
    },
  },
}
</file>

<file path="src/features/swap/components/SwapTokens/index.tsx">
import ConfirmationOrderHeader, { type InfoBlock } from '@/components/tx/ConfirmationOrder/ConfirmationOrderHeader'

const SwapTokens = ({ first, second }: { first: InfoBlock; second: InfoBlock }) => {
  return <ConfirmationOrderHeader blocks={[first, second]} showArrow />
}

export default SwapTokens
</file>

<file path="src/features/swap/components/SwapTxInfo/SwapTx.tsx">
import type { Order, OrderToken } from '@safe-global/safe-gateway-typescript-sdk'
import type { ReactElement } from 'react'
import { Typography } from '@mui/material'
import TokenAmount from '@/components/common/TokenAmount'
import TokenIcon from '@/components/common/TokenIcon'

const Amount = ({ value, token }: { value: string; token: OrderToken }) => (
  <TokenAmount
    value={value}
    decimals={token.decimals}
    tokenSymbol={token.symbol}
    logoUri={token.logoUri ?? undefined}
  />
)

const OnlyToken = ({ token }: { token: OrderToken }) => (
  <Typography fontWeight="bold" component="span" display="flex" alignItems="center" gap={1}>
    <TokenIcon tokenSymbol={token.symbol} logoUri={token.logoUri ?? undefined} />
    {token.symbol}
  </Typography>
)

export const SwapTx = ({ info }: { info: Order }): ReactElement => {
  const { kind, sellToken, sellAmount, buyToken, buyAmount } = info
  const isSellOrder = kind === 'sell'

  let from = <Amount value={sellAmount} token={sellToken} />
  let to = <OnlyToken token={buyToken} />

  if (!isSellOrder) {
    from = <OnlyToken token={sellToken} />
    to = <Amount value={buyAmount} token={buyToken} />
  }

  return (
    <Typography
      component="div"
      display="flex"
      alignItems="center"
      fontWeight="bold"
      whiteSpace="nowrap"
      overflow="hidden"
      textOverflow="ellipsis"
    >
      {from}
      <Typography component="span" mx={0.5}>
        &nbsp;to&nbsp;
      </Typography>
      {to}
    </Typography>
  )
}
</file>

<file path="src/features/swap/components/TwapFallbackHandlerWarning/index.tsx">
import { Alert, SvgIcon } from '@mui/material'
import InfoOutlinedIcon from '@/public/images/notifications/info.svg'

export const TwapFallbackHandlerWarning = () => {
  return (
    <Alert
      severity="warning"
      icon={<SvgIcon component={InfoOutlinedIcon} inheritViewBox color="error" />}
      sx={{ mb: 1 }}
    >
      <b>Enable TWAPs and submit order.</b>
      {` `}
      To enable TWAP orders you need to set a custom fallback handler. This software is developed by CoW Swap and Safe
      will not be responsible for any possible issues with it.
    </Alert>
  )
}
</file>

<file path="src/features/swap/helpers/data/stablecoins.ts">
export const stableCoinAddresses: {
  [address: string]: {
    name: string
    symbol: string
    chains: Array<'gnosis' | 'ethereum' | 'arbitrum-one' | 'sepolia' | 'base'>
  }
} = {
  '0xdd96b45877d0e8361a4ddb732da741e97f3191ff': {
    name: 'BUSD Token from BSC',
    symbol: 'BUSD',
    chains: ['gnosis'],
  },
  '0x44fa8e6f47987339850636f88629646662444217': {
    name: 'Dai Stablecoin on Gnosis',
    symbol: 'DAI',
    chains: ['gnosis'],
  },
  '0x1e37e5b504f7773460d6eb0e24d2e7c223b66ec7': {
    name: 'HUSD on Gnosis',
    symbol: 'HUSD',
    chains: ['gnosis'],
  },
  '0xb714654e905edad1ca1940b7790a8239ece5a9ff': {
    name: 'TrueUSD on Gnosis',
    symbol: 'TUSD',
    chains: ['gnosis'],
  },
  '0xddafbb505ad214d7b80b1f830fccc89b60fb7a83': {
    name: 'USD//C on Gnosis',
    symbol: 'USDC',
    chains: ['gnosis'],
  },
  '0x4ecaba5870353805a9f068101a40e0f32ed605c6': {
    name: 'Tether on Gnosis',
    symbol: 'USDT',
    chains: ['gnosis'],
  },
  '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063': {
    name: 'Dai Stablecoin',
    symbol: 'DAI',
    chains: ['gnosis'],
  },
  '0x104592a158490a9228070E0A8e5343B499e125D0': {
    name: 'Frax',
    symbol: 'FRAX',
    chains: ['gnosis'],
  },
  '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174': {
    name: 'USD Coin',
    symbol: 'USDC',
    chains: ['gnosis'],
  },
  '0xc2132D05D31c914a87C6611C10748AEb04B58e8F': {
    name: 'Tether USD',
    symbol: 'USDT',
    chains: ['gnosis'],
  },
  '0x3e7676937A7E96CFB7616f255b9AD9FF47363D4b': {
    name: 'Dai Stablecoin',
    symbol: 'DAI',
    chains: ['gnosis'],
  },
  '0x0faF6df7054946141266420b43783387A78d82A9': {
    name: 'USDC from Ethereum',
    symbol: 'USDC',
    chains: ['gnosis'],
  },
  '0xcB1e72786A6eb3b44C2a2429e317c8a2462CFeb1': {
    name: 'Dai Stablecoin',
    symbol: 'DAI',
    chains: ['gnosis'],
  },
  '0x3813e82e6f7098b9583FC0F33a962D02018B6803': {
    name: 'Tether USD',
    symbol: 'USDT',
    chains: ['gnosis'],
  },

  '0xdac17f958d2ee523a2206206994597c13d831ec7': {
    name: 'Tether',
    symbol: 'usdt',
    chains: ['ethereum'],
  },
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': {
    name: 'USDC',
    symbol: 'usdc',
    chains: ['ethereum'],
  },
  '0xaf88d065e77c8cc2239327c5edb3a432268e5831': {
    name: 'USDC',
    symbol: 'usdc',
    chains: ['arbitrum-one'],
  },
  '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9': {
    name: 'USDT',
    symbol: 'usdt',
    chains: ['arbitrum-one'],
  },
  '0x6b175474e89094c44da98b954eedeac495271d0f': {
    name: 'Dai',
    symbol: 'dai',
    chains: ['ethereum'],
  },
  '0xda10009cbd5d07dd0cecc66161fc93d7c9000da1': {
    name: 'Dai',
    symbol: 'dai',
    chains: ['arbitrum-one'],
  },
  '0x4c9edd5852cd905f086c759e8383e09bff1e68b3': {
    name: 'Ethena USDe',
    symbol: 'usde',
    chains: ['ethereum'],
  },
  '0xc5f0f7b66764f6ec8c8dff7ba683102295e16409': {
    name: 'First Digital USD',
    symbol: 'fdusd',
    chains: ['ethereum'],
  },
  '0x0c10bf8fcb7bf5412187a595ab97a3609160b5c6': {
    name: 'USDD',
    symbol: 'usdd',
    chains: ['ethereum'],
  },
  '0x680447595e8b7b3aa1b43beb9f6098c79ac2ab3f': {
    name: 'USDD',
    symbol: 'usdd',
    chains: ['arbitrum-one'],
  },
  '0x853d955acef822db058eb8505911ed77f175b99e': {
    name: 'Frax',
    symbol: 'frax',
    chains: ['ethereum'],
  },
  '0x17fc002b466eec40dae837fc4be5c67993ddbd6f': {
    name: 'Frax',
    symbol: 'frax',
    chains: ['arbitrum-one'],
  },
  '0x68749665ff8d2d112fa859aa293f07a622782f38': {
    name: 'Tether Gold',
    symbol: 'xaut',
    chains: ['ethereum'],
  },
  '0x0000000000085d4780b73119b644ae5ecd22b376': {
    name: 'TrueUSD',
    symbol: 'tusd',
    chains: ['ethereum'],
  },
  '0x45804880de22913dafe09f4980848ece6ecbaf78': {
    name: 'PAX Gold',
    symbol: 'paxg',
    chains: ['ethereum'],
  },
  '0x6c3ea9036406852006290770bedfcaba0e23a0e8': {
    name: 'PayPal USD',
    symbol: 'pyusd',
    chains: ['ethereum'],
  },
  '0xbc6da0fe9ad5f3b0d58160288917aa56653660e9': {
    name: 'Alchemix USD',
    symbol: 'alusd',
    chains: ['ethereum'],
  },
  '0xdb25f211ab05b1c97d595516f45794528a807ad8': {
    name: 'STASIS EURO',
    symbol: 'eurs',
    chains: ['ethereum'],
  },
  '0x8e870d67f660d95d5be530380d0ec0bd388289e1': {
    name: 'Pax Dollar',
    symbol: 'usdp',
    chains: ['ethereum'],
  },
  '0xf939e0a03fb07f59a73314e73794be0e57ac1b4e': {
    name: 'crvUSD',
    symbol: 'crvusd',
    chains: ['ethereum'],
  },
  '0x498bf2b1e120fed3ad3d42ea2165e9b73f99c1e5': {
    name: 'crvUSD',
    symbol: 'crvusd',
    chains: ['arbitrum-one'],
  },
  '0x056fd409e1d7a124bd7017459dfea2f387b6d5cd': {
    name: 'Gemini Dollar',
    symbol: 'gusd',
    chains: ['ethereum'],
  },
  '0x865377367054516e17014ccded1e7d814edc9ce4': {
    name: 'DOLA',
    symbol: 'dola',
    chains: ['ethereum'],
  },
  '0x6a7661795c374c0bfc635934efaddff3a7ee23b6': {
    name: 'DOLA',
    symbol: 'dola',
    chains: ['arbitrum-one'],
  },
  '0x40d16fc0246ad3160ccc09b8d0d3a2cd28ae6c2f': {
    name: 'GHO',
    symbol: 'gho',
    chains: ['ethereum'],
  },
  '0x5f98805a4e8be255a32880fdec7f6728c6568ba0': {
    name: 'Liquity USD',
    symbol: 'lusd',
    chains: ['ethereum'],
  },
  '0x93b346b6bc2548da6a1e7d98e9a421b42541425b': {
    name: 'Liquity USD',
    symbol: 'lusd',
    chains: ['arbitrum-one'],
  },
  '0x4fabb145d64652a948d72533023f6e7a623c7c53': {
    name: 'BUSD',
    symbol: 'busd',
    chains: ['ethereum'],
  },
  '0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3': {
    name: 'Magic Internet Money (Ethereum)',
    symbol: 'mim',
    chains: ['ethereum'],
  },
  '0x59d9356e565ab3a36dd77763fc0d87feaf85508c': {
    name: 'Mountain Protocol USD',
    symbol: 'usdm',
    chains: ['ethereum', 'arbitrum-one'],
  },
  '0xbea0000029ad1c77d3d5d23ba2d8893db9d1efab': {
    name: 'Bean',
    symbol: 'bean',
    chains: ['ethereum'],
  },
  '0x57ab1ec28d129707052df4df418d58a2d46d5f51': {
    name: 'sUSD',
    symbol: 'susd',
    chains: ['ethereum'],
  },
  '0xa970af1a584579b618be4d69ad6f73459d112f95': {
    name: 'sUSD',
    symbol: 'susd',
    chains: ['arbitrum-one'],
  },
  '0xc581b735a1688071a1746c968e0798d642ede491': {
    name: 'Euro Tether',
    symbol: 'eurt',
    chains: ['ethereum'],
  },
  '0xa774ffb4af6b0a91331c084e1aebae6ad535e6f3': {
    name: 'flexUSD',
    symbol: 'flexusd',
    chains: ['ethereum'],
  },
  '0x1a7e4e63778b4f12a199c062f3efdd288afcbce8': {
    name: 'EURA',
    symbol: 'eura',
    chains: ['ethereum'],
  },
  '0xfa5ed56a203466cbbc2430a43c66b9d8723528e7': {
    name: 'EURA',
    symbol: 'eura',
    chains: ['arbitrum-one'],
  },
  '0xe07f9d810a48ab5c3c914ba3ca53af14e4491e8a': {
    name: 'Gyroscope GYD',
    symbol: 'gyd',
    chains: ['ethereum'],
  },
  '0xca5d8f8a8d49439357d3cf46ca2e720702f132b8': {
    name: 'Gyroscope GYD',
    symbol: 'gyd',
    chains: ['arbitrum-one'],
  },
  '0x2c537e5624e4af88a7ae4060c022609376c8d0eb': {
    name: 'BiLira',
    symbol: 'tryb',
    chains: ['ethereum'],
  },
  '0x0e573ce2736dd9637a0b21058352e1667925c7a8': {
    name: 'Verified USD',
    symbol: 'usdv',
    chains: ['ethereum'],
  },
  '0x323665443cef804a3b5206103304bd4872ea4253': {
    name: 'Verified USD',
    symbol: 'usdv',
    chains: ['arbitrum-one'],
  },
  '0x956f47f50a910163d8bf957cf5846d573e7f87ca': {
    name: 'Fei USD',
    symbol: 'fei',
    chains: ['ethereum'],
  },
  '0x0a5e677a6a24b2f1a2bf4f3bffc443231d2fdec8': {
    name: 'dForce USD',
    symbol: 'usx',
    chains: ['ethereum'],
  },
  '0x641441c631e2f909700d2f41fd87f0aa6a6b4edb': {
    name: 'dForce USD',
    symbol: 'usx',
    chains: ['arbitrum-one'],
  },
  '0x4591dbff62656e7859afe5e45f6f47d3669fbb28': {
    name: 'Prisma mkUSD',
    symbol: 'mkusd',
    chains: ['ethereum'],
  },
  '0xc08512927d12348f6620a698105e1baac6ecd911': {
    name: 'GYEN',
    symbol: 'gyen',
    chains: ['ethereum'],
  },
  '0x589d35656641d6ab57a545f08cf473ecd9b6d5f7': {
    name: 'GYEN',
    symbol: 'gyen',
    chains: ['arbitrum-one'],
  },
  '0xdf3ac4f479375802a821f7b7b46cd7eb5e4262cc': {
    name: 'eUSD',
    symbol: 'eusd',
    chains: ['ethereum'],
  },
  '0x2a8e1e676ec238d8a992307b495b45b3feaa5e86': {
    name: 'Origin Dollar',
    symbol: 'ousd',
    chains: ['ethereum'],
  },
  '0x1b3c515f58857e141a966b33182f2f3feecc10e9': {
    name: 'USK',
    symbol: 'usk',
    chains: ['ethereum'],
  },
  '0xdf574c24545e5ffecb9a659c229253d4111d87e1': {
    name: 'HUSD',
    symbol: 'husd',
    chains: ['ethereum'],
  },
  '0xe2f2a5c287993345a840db3b0845fbc70f5935a5': {
    name: 'mStable USD',
    symbol: 'musd',
    chains: ['ethereum'],
  },
  '0x6e109e9dd7fa1a58bc3eff667e8e41fc3cc07aef': {
    name: 'CNH Tether',
    symbol: 'cnht',
    chains: ['ethereum'],
  },
  '0x6ba75d640bebfe5da1197bb5a2aff3327789b5d3': {
    name: 'VNX EURO',
    symbol: 'veur',
    chains: ['ethereum'],
  },
  '0x70e8de73ce538da2beed35d14187f6959a8eca96': {
    name: 'XSGD',
    symbol: 'xsgd',
    chains: ['ethereum'],
  },
  '0x97de57ec338ab5d51557da3434828c5dbfada371': {
    name: 'eUSD (OLD)',
    symbol: 'eusd',
    chains: ['ethereum'],
  },
  '0x68037790a0229e9ce6eaa8a99ea92964106c4703': {
    name: 'Parallel',
    symbol: 'par',
    chains: ['ethereum'],
  },
  '0x1cfa5641c01406ab8ac350ded7d735ec41298372': {
    name: 'Convertible JPY Token',
    symbol: 'cjpy',
    chains: ['ethereum'],
  },
  '0xd74f5255d557944cf7dd0e45ff521520002d5748': {
    name: 'Sperax USD',
    symbol: 'usds',
    chains: ['arbitrum-one'],
  },
  '0xd71ecff9342a5ced620049e616c5035f1db98620': {
    name: 'sEUR',
    symbol: 'seur',
    chains: ['ethereum'],
  },
  '0x38547d918b9645f2d94336b6b61aeb08053e142c': {
    name: 'USC',
    symbol: 'usc',
    chains: ['ethereum'],
  },
  '0x45fdb1b92a649fb6a64ef1511d3ba5bf60044838': {
    name: 'SpiceUSD',
    symbol: 'usds',
    chains: ['ethereum'],
  },
  '0xebf2096e01455108badcbaf86ce30b6e5a72aa52': {
    name: 'XIDR',
    symbol: 'xidr',
    chains: ['ethereum'],
  },
  '0xb0b195aefa3650a6908f15cdac7d92f8a5791b0b': {
    name: 'BOB',
    symbol: 'bob',
    chains: ['ethereum', 'arbitrum-one'],
  },
  '0x86b4dbe5d203e634a12364c0e428fa242a3fba98': {
    name: 'poundtoken',
    symbol: 'gbpt',
    chains: ['ethereum'],
  },
  '0xd90e69f67203ebe02c917b5128629e77b4cd92dc': {
    name: 'One Cash',
    symbol: 'onc',
    chains: ['ethereum'],
  },
  '0x3449fc1cd036255ba1eb19d65ff4ba2b8903a69a': {
    name: 'Basis Cash',
    symbol: 'bac',
    chains: ['ethereum'],
  },
  '0xc285b7e09a4584d027e5bc36571785b515898246': {
    name: 'Coin98 Dollar',
    symbol: 'cusd',
    chains: ['ethereum'],
  },
  '0x64343594ab9b56e99087bfa6f2335db24c2d1f17': {
    name: 'Vesta Stable',
    symbol: 'vst',
    chains: ['arbitrum-one'],
  },
  '0x2370f9d504c7a6e775bf6e14b3f12846b594cd53': {
    name: 'JPY Coin v1',
    symbol: 'jpyc',
    chains: ['ethereum'],
  },
  '0x53dfea0a8cc2a2a2e425e1c174bc162999723ea0': {
    name: 'Jarvis Synthetic Swiss Franc',
    symbol: 'jchf',
    chains: ['ethereum'],
  },
  '0x0f17bc9a994b87b5225cfb6a2cd4d667adb4f20b': {
    name: 'Jarvis Synthetic Euro',
    symbol: 'jeur',
    chains: ['ethereum'],
  },
  '0x3231cb76718cdef2155fc47b5286d82e6eda273f': {
    name: 'Monerium EUR emoney',
    symbol: 'eure',
    chains: ['ethereum'],
  },
  '0x65d72aa8da931f047169112fcf34f52dbaae7d18': {
    name: 'f(x) rUSD',
    symbol: 'rusd',
    chains: ['ethereum'],
  },
  '0x085780639cc2cacd35e474e71f4d000e2405d8f6': {
    name: 'f(x) Protocol fxUSD',
    symbol: 'fxusd',
    chains: ['ethereum'],
  },
  '0xa663b02cf0a4b149d2ad41910cb81e23e1c41c32': {
    name: 'Staked FRAX',
    symbol: 'sfrax',
    chains: ['ethereum'],
  },
  '0xe3b3fe7bca19ca77ad877a5bebab186becfad906': {
    name: 'Staked FRAX',
    symbol: 'sfrax',
    chains: ['arbitrum-one'],
  },
  '0xcfc5bd99915aaa815401c5a41a927ab7a38d29cf': {
    name: 'Threshold USD',
    symbol: 'thusd',
    chains: ['ethereum'],
  },
  '0xa47c8bf37f92abed4a126bda807a7b7498661acd': {
    name: 'Wrapped USTC',
    symbol: 'ustc',
    chains: ['ethereum'],
  },
  '0x3509f19581afedeff07c53592bc0ca84e4855475': {
    name: 'xDollar Stablecoin',
    symbol: 'xusd',
    chains: ['arbitrum-one'],
  },
  '0x431d5dff03120afa4bdf332c61a6e1766ef37bdb': {
    name: 'JPY Coin',
    symbol: 'jpyc',
    chains: ['ethereum'],
  },
  '0xb6667b04cb61aa16b59617f90ffa068722cf21da': {
    name: 'Worldwide USD',
    symbol: 'wusd',
    chains: ['ethereum'],
  },
  '0xB4F1737Af37711e9A5890D9510c9bB60e170CB0D': {
    name: 'COW Dai Stablecoin',
    symbol: 'DAI',
    chains: ['sepolia'],
  },
  '0xbe72E441BF55620febc26715db68d3494213D8Cb': {
    name: 'COW USD Coin',
    symbol: 'USDC',
    chains: ['sepolia'],
  },
  '0x58eb19ef91e8a6327fed391b51ae1887b833cc91': {
    name: 'COW Tether USD',
    symbol: 'USDT',
    chains: ['sepolia'],
  },
  '0xaf204776c7245bf4147c2612bf6e5972ee483701': {
    name: 'Savings xDai',
    symbol: 'SDAI',
    chains: ['gnosis'],
  },
  '0x83f20f44975d03b1b09e64809b757c47f942beea': {
    name: 'Savings xDai',
    symbol: 'SDAI',
    chains: ['ethereum'],
  },
  '0x4c612e3b15b96ff9a6faed838f8d07d479a8dd4c': {
    name: 'Aave v3 sDai',
    symbol: 'ASDAI',
    chains: ['ethereum'],
  },
  '0x7a5c3860a77a8dc1b225bd46d0fb2ac1c6d191bc': {
    name: 'Aave v3 sDai',
    symbol: 'ASDAI',
    chains: ['gnosis'],
  },
  '0x2a22f9c3b484c3629090feed35f17ff8f88f76f0': {
    name: 'Gnosis xDAI Bridged USDC',
    symbol: 'USDC.e',
    chains: ['gnosis'],
  },
  '0xcb444e90d8198415266c6a2724b7900fb12fc56e': {
    name: 'Monerium EUR emoney',
    symbol: 'EURE',
    chains: ['gnosis'],
  },
  '0xdc035d45d973e3ec169d2276ddab16f1e407384f': {
    name: 'Sky dollar',
    symbol: 'USDS',
    chains: ['ethereum'],
  },
  // Base
  '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913': {
    name: 'USDC',
    symbol: 'usdc',
    chains: ['base'],
  },
  '0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2': {
    name: 'Tether USD',
    symbol: 'usdt',
    chains: ['base'],
  },
  '0x50c5725949a6f0c72e6c4a641f24049a917db0cb': {
    name: 'Dai Stablecoin',
    symbol: 'dai',
    chains: ['base'],
  },
  '0x5d3a1Ff2b6BAb83b63cd9AD0787074081a52ef34': {
    name: 'USDe',
    symbol: 'usde',
    chains: ['base'],
  },
  '0x820c137fa70c8691f0e44dc420a5e53c168921dc': {
    name: 'USDS Stablecoin',
    symbol: 'usds',
    chains: ['base'],
  },
  '0x60a3e35cc302bfa44cb288bc5a4f316fdb1adb42': {
    name: 'EURC',
    symbol: 'eurc',
    chains: ['base'],
  },
}
</file>

<file path="src/features/swap/helpers/fee.ts">
import type { OnTradeParamsPayload } from '@cowprotocol/events'
import { stableCoinAddresses } from '@/features/swap/helpers/data/stablecoins'

const FEE_PERCENTAGE_BPS = {
  REGULAR: {
    TIER_1: 35,
    TIER_2: 20,
    TIER_3: 10,
  },
  STABLE: {
    TIER_1: 10,
    TIER_2: 7,
    TIER_3: 5,
  },
}

const FEE_TIERS = {
  TIER_1: 100_000, // 0 - 100k
  TIER_2: 1_000_000, // 100k - 1m
}

const getLowerCaseStableCoinAddresses = () => {
  const lowerCaseStableCoinAddresses = Object.keys(stableCoinAddresses).reduce(
    (result, key) => {
      result[key.toLowerCase()] = stableCoinAddresses[key]
      return result
    },
    {} as typeof stableCoinAddresses,
  )

  return lowerCaseStableCoinAddresses
}
/**
 * Function to calculate the fee % in bps to apply for a trade.
 * The fee % should be applied based on the fiat value of the buy or sell token.
 *
 * @param orderParams
 */
export const calculateFeePercentageInBps = (orderParams: OnTradeParamsPayload) => {
  const { sellToken, buyToken, buyTokenFiatAmount, sellTokenFiatAmount, orderKind } = orderParams
  const stableCoins = getLowerCaseStableCoinAddresses()
  const isStableCoin = stableCoins[sellToken?.address?.toLowerCase()] && stableCoins[buyToken?.address.toLowerCase()]

  const fiatAmount = Number(orderKind == 'sell' ? sellTokenFiatAmount : buyTokenFiatAmount) || 0

  if (fiatAmount < FEE_TIERS.TIER_1) {
    return isStableCoin ? FEE_PERCENTAGE_BPS.STABLE.TIER_1 : FEE_PERCENTAGE_BPS.REGULAR.TIER_1
  }

  if (fiatAmount < FEE_TIERS.TIER_2) {
    return isStableCoin ? FEE_PERCENTAGE_BPS.STABLE.TIER_2 : FEE_PERCENTAGE_BPS.REGULAR.TIER_2
  }

  return isStableCoin ? FEE_PERCENTAGE_BPS.STABLE.TIER_3 : FEE_PERCENTAGE_BPS.REGULAR.TIER_3
}
</file>

<file path="src/features/swap/helpers/swapOrderBuilder.ts">
import { Builder, type IBuilder } from '@/tests/Builder'
import { faker } from '@faker-js/faker'
import type {
  OrderToken,
  SwapOrder,
  TransactionInfoType,
  TwapOrder,
  Order,
} from '@safe-global/safe-gateway-typescript-sdk'
import { DurationType, StartTimeValue } from '@safe-global/safe-gateway-typescript-sdk'

export function appDataBuilder(
  orderClass: 'limit' | 'market' | 'twap' | 'liquidity' = 'limit',
): IBuilder<Record<string, unknown>> {
  return Builder.new<Record<string, unknown>>().with({
    appCode: 'Safe Wallet Swaps',
    metadata: {
      orderClass: {
        orderClass,
      },
      partnerFee: {
        bps: 50,
        recipient: '0x0B00b3227A5F3df3484f03990A87e02EbaD2F888',
      },
      quote: {
        slippageBips: 50,
      },
      widget: {
        appCode: 'CoW Swap-SafeApp',
        environment: 'production',
      },
    },
    version: '1.1.0',
  })
}

export function orderTokenBuilder(): IBuilder<OrderToken> {
  return Builder.new<OrderToken>().with({
    address: faker.finance.ethereumAddress(),
    decimals: faker.number.int({ max: 18 }),
    logoUri:
      'https://safe-transaction-assets.staging.5afe.dev/tokens/logos/0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14.png',
    name: faker.finance.currencyName(),
    symbol: faker.finance.currencyCode(),
    trusted: faker.datatype.boolean(),
  })
}

export function swapOrderBuilder(): IBuilder<SwapOrder> {
  const sellToken = orderTokenBuilder().build()
  const executedFee = faker.string.numeric()
  return Builder.new<SwapOrder>().with({
    type: 'SwapOrder' as TransactionInfoType.SWAP_ORDER,
    uid: faker.string.uuid(),
    status: faker.helpers.arrayElement(['presignaturePending', 'open', 'cancelled', 'fulfilled', 'expired']),
    kind: faker.helpers.arrayElement(['buy', 'sell']),
    orderClass: faker.helpers.arrayElement(['limit', 'market', 'liquidity']),
    validUntil: faker.date.future().getTime(),
    sellAmount: faker.string.numeric(),
    buyAmount: faker.string.numeric(),
    executedSellAmount: faker.string.numeric(),
    executedBuyAmount: faker.string.numeric(),
    sellToken,
    buyToken: orderTokenBuilder().build(),
    explorerUrl:
      'https://explorer.cow.fi/orders/0x03a5d561ad2452d719a0d075573f4bed68217c696b52f151122c30e3e4426f1b05e6b5eb1d0e6aabab082057d5bb91f2ee6d11be66223d88',
    executedFee,
    executedFeeToken: sellToken,
    fullAppData: appDataBuilder().build(),
  })
}

export function twapOrderBuilder(): IBuilder<TwapOrder> {
  const sellToken = orderTokenBuilder().build()
  const executedFee = faker.string.numeric()
  return Builder.new<TwapOrder>().with({
    type: 'TwapOrder' as TransactionInfoType.TWAP_ORDER,
    status: faker.helpers.arrayElement(['presignaturePending', 'open', 'cancelled', 'fulfilled', 'expired']),
    kind: faker.helpers.arrayElement(['buy', 'sell']),
    orderClass: faker.helpers.arrayElement(['limit', 'market', 'liquidity']),
    validUntil: faker.date.future().getTime(),
    sellAmount: faker.string.numeric(),
    buyAmount: faker.string.numeric(),
    executedSellAmount: faker.string.numeric(),
    executedBuyAmount: faker.string.numeric(),
    sellToken: orderTokenBuilder().build(),
    buyToken: orderTokenBuilder().build(),
    executedFee,
    executedFeeToken: sellToken,
    fullAppData: appDataBuilder().build(),
    numberOfParts: faker.number.int({ min: 1, max: 10 }).toString(),
    /** @description The amount of sellToken to sell in each part */
    partSellAmount: faker.string.numeric(),
    /** @description The amount of buyToken that must be bought in each part */
    minPartLimit: faker.string.numeric(),
    /** @description The duration of the TWAP interval */
    timeBetweenParts: faker.number.int({ min: 1, max: 10000000 }),
    /** @description Whether the TWAP is valid for the entire interval or not */
    durationOfPart: {
      durationType: DurationType.AUTO,
    },
    /** @description The start time of the TWAP */
    startTime: {
      startType: StartTimeValue.AT_MINING_TIME,
    },
  })
}

// create a builder for SwapOrderConfirmationView
export function swapOrderConfirmationViewBuilder(): IBuilder<Order> {
  const ownerAndReceiver = faker.finance.ethereumAddress()
  return Builder.new<Order>().with({
    type: 'SwapOrder' as TransactionInfoType.SWAP_ORDER,
    uid: faker.string.uuid(),
    kind: faker.helpers.arrayElement(['buy', 'sell']),
    orderClass: faker.helpers.arrayElement(['limit', 'market', 'liquidity']),
    validUntil: faker.date.future().getTime(),
    status: faker.helpers.arrayElement(['presignaturePending', 'open', 'cancelled', 'fulfilled', 'expired']),
    sellToken: orderTokenBuilder().build(),
    buyToken: orderTokenBuilder().build(),
    sellAmount: faker.string.numeric(),
    buyAmount: faker.string.numeric(),
    executedSellAmount: faker.string.numeric(),
    executedBuyAmount: faker.string.numeric(),
    receiver: ownerAndReceiver,
    owner: ownerAndReceiver,
    explorerUrl:
      'https://explorer.cow.fi/orders/0x03a5d561ad2452d719a0d075573f4bed68217c696b52f151122c30e3e4426f1b05e6b5eb1d0e6aabab082057d5bb91f2ee6d11be66223d88',
    fullAppData: appDataBuilder().build(),
  })
}
</file>

<file path="src/features/swap/helpers/utils.ts">
import type { DataDecoded, Order as SwapOrder } from '@safe-global/safe-gateway-typescript-sdk'
import { formatUnits } from 'ethers'
import type { AnyAppDataDocVersion, latest, LatestAppDataDocVersion } from '@cowprotocol/app-data'

import { TradeType, UiOrderType } from '@safe-global/utils/features/swap/types'

type Quantity = {
  amount: string | number | bigint
  decimals: number
}

export enum OrderKind {
  SELL = 'sell',
  BUY = 'buy',
}

function calculateDifference(amountA: string, amountB: string, decimals: number): number {
  return asDecimal(BigInt(amountA), decimals) - asDecimal(BigInt(amountB), decimals)
}

function asDecimal(amount: number | bigint, decimals: number): number {
  return Number(formatUnits(amount, decimals))
}

export const TWAP_FALLBACK_HANDLER = '0x2f55e8b20D0B9FEFA187AA7d00B6Cbe563605bF5'

// https://github.com/cowprotocol/composable-cow/blob/main/networks.json
export const TWAP_FALLBACK_HANDLER_NETWORKS = ['1', '100', '11155111', '42161']

export const getExecutionPrice = (
  order: Pick<SwapOrder, 'executedSellAmount' | 'executedBuyAmount' | 'buyToken' | 'sellToken'>,
): number => {
  const { executedSellAmount, executedBuyAmount, buyToken, sellToken } = order

  const ratio = calculateRatio(
    { amount: executedSellAmount || '0', decimals: sellToken.decimals },
    {
      amount: executedBuyAmount || '0',
      decimals: buyToken.decimals,
    },
  )

  return ratio
}

export const getLimitPrice = (
  order: Pick<SwapOrder, 'sellAmount' | 'buyAmount' | 'buyToken' | 'sellToken'>,
): number => {
  const { sellAmount, buyAmount, buyToken, sellToken } = order

  const ratio = calculateRatio(
    { amount: sellAmount, decimals: sellToken.decimals },
    { amount: buyAmount, decimals: buyToken.decimals },
  )

  return ratio
}

const calculateRatio = (a: Quantity, b: Quantity) => {
  if (BigInt(b.amount) === 0n) {
    return 0
  }
  return asDecimal(BigInt(a.amount), a.decimals) / asDecimal(BigInt(b.amount), b.decimals)
}

export const getSurplusPrice = (
  order: Pick<
    SwapOrder,
    'executedBuyAmount' | 'buyAmount' | 'buyToken' | 'executedSellAmount' | 'sellAmount' | 'sellToken' | 'kind'
  >,
): number => {
  const { kind, executedSellAmount, sellAmount, sellToken, executedBuyAmount, buyAmount, buyToken } = order
  if (kind === OrderKind.BUY) {
    return calculateDifference(sellAmount, executedSellAmount || '', sellToken.decimals)
  } else if (kind === OrderKind.SELL) {
    return calculateDifference(executedBuyAmount || '', buyAmount, buyToken.decimals)
  } else {
    return 0
  }
}

export const getPartiallyFilledSurplus = (order: SwapOrder): number => {
  if (order.kind === OrderKind.BUY) {
    return getPartiallyFilledBuySurplus(order)
  } else if (order.kind === OrderKind.SELL) {
    return getPartiallyFilledSellSurplus(order)
  } else {
    return 0
  }
}

const getPartiallyFilledBuySurplus = (
  order: Pick<
    SwapOrder,
    'executedBuyAmount' | 'buyAmount' | 'buyToken' | 'executedSellAmount' | 'sellAmount' | 'sellToken' | 'kind'
  >,
): number => {
  const { executedSellAmount, sellAmount, sellToken, executedBuyAmount, buyAmount, buyToken } = order

  const limitPrice = calculateRatio(
    { amount: sellAmount, decimals: sellToken.decimals },
    { amount: buyAmount, decimals: buyToken.decimals },
  )
  const maximumSellAmount = asDecimal(BigInt(executedBuyAmount || 0n), buyToken.decimals) * limitPrice
  return maximumSellAmount - asDecimal(BigInt(executedSellAmount || 0n), sellToken.decimals)
}

const getPartiallyFilledSellSurplus = (
  order: Pick<
    SwapOrder,
    'executedBuyAmount' | 'buyAmount' | 'buyToken' | 'executedSellAmount' | 'sellAmount' | 'sellToken' | 'kind'
  >,
): number => {
  const { executedSellAmount, sellAmount, sellToken, executedBuyAmount, buyAmount, buyToken } = order

  const limitPrice = calculateRatio(
    { amount: buyAmount, decimals: buyToken.decimals },
    { amount: sellAmount, decimals: sellToken.decimals },
  )

  const minimumBuyAmount = asDecimal(BigInt(executedSellAmount || 0n), sellToken.decimals) * limitPrice
  return asDecimal(BigInt(executedBuyAmount || 0n), buyToken.decimals) - minimumBuyAmount
}

export const getFilledPercentage = (
  order: Pick<SwapOrder, 'executedBuyAmount' | 'kind' | 'buyAmount' | 'executedSellAmount' | 'sellAmount'>,
): string => {
  let executed: number
  let total: number

  if (order.kind === OrderKind.BUY) {
    executed = Number(order.executedBuyAmount)
    total = Number(order.buyAmount)
  } else if (order.kind === OrderKind.SELL) {
    executed = Number(order.executedSellAmount)
    total = Number(order.sellAmount)
  } else {
    return '0'
  }

  return ((executed / total) * 100).toFixed(0)
}

export const getFilledAmount = (
  order: Pick<SwapOrder, 'kind' | 'executedBuyAmount' | 'executedSellAmount' | 'buyToken' | 'sellToken'>,
): string => {
  if (order.kind === OrderKind.BUY) {
    return formatUnits(order.executedBuyAmount || 0n, order.buyToken.decimals)
  } else if (order.kind === OrderKind.SELL) {
    return formatUnits(order.executedSellAmount || 0n, order.sellToken.decimals)
  } else {
    return '0'
  }
}

export const getSlippageInPercent = (order: Pick<SwapOrder, 'fullAppData'>): string => {
  const fullAppData = order.fullAppData as AnyAppDataDocVersion
  const slippageBips = (fullAppData?.metadata?.quote as latest.Quote)?.slippageBips || 0

  return (Number(slippageBips) / 100).toFixed(2)
}

export const getOrderClass = (order: Pick<SwapOrder, 'fullAppData'>): latest.OrderClass1 => {
  const fullAppData = order.fullAppData as AnyAppDataDocVersion
  const orderClass = (fullAppData?.metadata?.orderClass as latest.OrderClass)?.orderClass

  return orderClass || 'market'
}

export const getOrderFeeBps = (order: Pick<SwapOrder, 'fullAppData'>): number => {
  const fullAppData = order.fullAppData as unknown as LatestAppDataDocVersion
  const basisPoints = (fullAppData?.metadata?.partnerFee as latest.PartnerFee)?.bps

  return Number(basisPoints) || 0
}

export const isOrderPartiallyFilled = (
  order: Pick<SwapOrder, 'executedBuyAmount' | 'executedSellAmount' | 'sellAmount' | 'buyAmount' | 'kind'>,
): boolean => {
  const executedBuyAmount = BigInt(order.executedBuyAmount || 0)
  const buyAmount = BigInt(order.buyAmount)
  const executedSellAmount = BigInt(order.executedSellAmount || 0)
  const sellAmount = BigInt(order.sellAmount)

  if (order.kind === OrderKind.BUY) {
    return executedBuyAmount !== 0n && executedBuyAmount < buyAmount
  }

  return BigInt(executedSellAmount) !== 0n && executedSellAmount < sellAmount
}

export const UiOrderTypeToOrderType = (orderType: UiOrderType): TradeType => {
  switch (orderType) {
    case UiOrderType.SWAP:
      return TradeType.SWAP
    case UiOrderType.LIMIT:
      return TradeType.LIMIT
    case UiOrderType.TWAP:
      return TradeType.ADVANCED
  }
}

export const isSettingTwapFallbackHandler = (decodedData: DataDecoded) => {
  return (
    decodedData.parameters?.some(
      (item) =>
        Array.isArray(item?.valueDecoded) &&
        item.valueDecoded.some(
          (decoded) =>
            decoded.dataDecoded?.method === 'setFallbackHandler' &&
            decoded.dataDecoded.parameters?.some(
              (parameter) => parameter.name === 'handler' && parameter.value === TWAP_FALLBACK_HANDLER,
            ),
        ),
    ) || false
  )
}
</file>

<file path="src/features/swap/hooks/useIsExpiredSwap.ts">
import { useEffect, useRef, useState } from 'react'
import type { TransactionInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { isSwapOrderTxInfo } from '@/utils/transaction-guards'

// https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#maximum_delay_value
const MAX_TIMEOUT = 2147483647

function getExpiryDelay(expiryUnixTimestampSec: number): number {
  const currentTimeMs = Date.now()
  const expiryTimeMs = expiryUnixTimestampSec * 1000
  const timeUntilExpiry = expiryTimeMs - currentTimeMs

  if (timeUntilExpiry <= 0) {
    return 0 // Already expired
  }

  return Math.min(timeUntilExpiry, MAX_TIMEOUT)
}

/**
 * Checks whether a swap has expired and if it hasn't it sets a timeout
 * for the exact moment it will expire
 * @param txInfo
 */
const useIsExpiredSwap = (txInfo: TransactionInfo) => {
  const [isExpired, setIsExpired] = useState<boolean>(false)
  const timerRef = useRef<NodeJS.Timeout | null>(null)

  useEffect(() => {
    if (!isSwapOrderTxInfo(txInfo)) return

    const delay = getExpiryDelay(txInfo.validUntil)

    if (delay === 0) {
      setIsExpired(true)
    } else {
      // Set a timeout for the exact moment it will expire
      timerRef.current = setTimeout(() => {
        setIsExpired(true)
      }, delay)
    }

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current)
      }
    }
  }, [txInfo])

  return isExpired
}

export default useIsExpiredSwap
</file>

<file path="src/features/swap/hooks/useIsSwapFeatureEnabled.ts">
import { GeoblockingContext } from '@/components/common/GeoblockingProvider'
import { useHasFeature } from '@/hooks/useChains'
import { useContext } from 'react'
import { FEATURES } from '@safe-global/utils/utils/chains'

const useIsSwapFeatureEnabled = () => {
  const isBlockedCountry = useContext(GeoblockingContext)
  return useHasFeature(FEATURES.NATIVE_SWAPS) && !isBlockedCountry
}

export default useIsSwapFeatureEnabled
</file>

<file path="src/features/swap/hooks/useIsTWAPFallbackHandler.ts">
import { useMemo } from 'react'
import useSafeInfo from '@/hooks/useSafeInfo'
import { TWAP_FALLBACK_HANDLER, TWAP_FALLBACK_HANDLER_NETWORKS } from '../helpers/utils'

/**
 * Hook to check if the Safe's fallback handler (or optionally a provided address) is the TWAP fallback handler.
 * @param fallbackHandler Optional fallback handler address (if not provided, it will be taken from the Safe info)
 * @returns Boolean indicating if the provided fallback handler is the TWAP fallback handler
 */
export const useIsTWAPFallbackHandler = (fallbackHandler?: string) => {
  const { safe } = useSafeInfo()

  const fallbackHandlerAddress = fallbackHandler || safe.fallbackHandler?.value

  return useMemo(
    () => fallbackHandlerAddress === TWAP_FALLBACK_HANDLER && TWAP_FALLBACK_HANDLER_NETWORKS.includes(safe.chainId),
    [fallbackHandlerAddress, safe.chainId],
  )
}
</file>

<file path="src/features/swap/store/swapParamsSlice.ts">
import type { RootState } from '@/store'
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import { UiOrderTypeToOrderType } from '@/features/swap/helpers/utils'
import { TradeType, type UiOrderType } from '@safe-global/utils/features/swap/types'

export type SwapState = {
  tradeType: TradeType
}

const initialState: SwapState = {
  tradeType: TradeType.SWAP,
}

export const swapParamsSlice = createSlice({
  name: 'swapParams',
  initialState,
  reducers: {
    setSwapParams: (
      _,
      action: PayloadAction<{
        tradeType: UiOrderType
      }>,
    ) => {
      return {
        tradeType: UiOrderTypeToOrderType(action.payload.tradeType),
      }
    },
  },
})

export const { setSwapParams } = swapParamsSlice.actions
export const selectSwapParams = (state: RootState): SwapState => state[swapParamsSlice.name]
</file>

<file path="src/features/swap/constants.ts">
export const SWAP_TITLE = 'Safe Swap'
export const SWAP_ORDER_TITLE = 'Swap order'
export const LIMIT_ORDER_TITLE = 'Limit order'
export const TWAP_ORDER_TITLE = 'TWAP order'

export const SWAP_FEE_RECIPIENT = '0xE344241493D573428076c022835856a221dB3E26'
</file>

<file path="src/features/swap/index.tsx">
import { CowSwapWidget } from '@cowprotocol/widget-react'
import { type CowSwapWidgetParams, TradeType } from '@cowprotocol/widget-lib'
import type { OnTradeParamsPayload } from '@cowprotocol/events'
import { type CowEventListeners, CowEvents } from '@cowprotocol/events'
import { type MutableRefObject, useEffect, useMemo, useRef, useState } from 'react'
import { Box, useTheme } from '@mui/material'
import {
  SafeAppAccessPolicyTypes,
  type SafeAppData,
  SafeAppFeatures,
} from '@safe-global/safe-gateway-typescript-sdk/dist/types/safe-apps'
import { useCurrentChain, useHasFeature } from '@/hooks/useChains'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useCustomAppCommunicator } from '@/hooks/safe-apps/useCustomAppCommunicator'
import { useAppDispatch, useAppSelector } from '@/store'

import css from './styles.module.css'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWallet from '@/hooks/wallets/useWallet'
import BlockedAddress from '@/components/common/BlockedAddress'
import useSwapConsent from './useSwapConsent'
import Disclaimer from '@/components/common/Disclaimer'
import WidgetDisclaimer from '@/components/common/WidgetDisclaimer'
import { selectSwapParams, setSwapParams, type SwapState } from './store/swapParamsSlice'
import { setSwapOrder } from '@/store/swapOrderSlice'
import useChainId from '@/hooks/useChainId'
import { type BaseTransaction } from '@safe-global/safe-apps-sdk'
import { id } from 'ethers'
import {
  LIMIT_ORDER_TITLE,
  SWAP_TITLE,
  SWAP_ORDER_TITLE,
  TWAP_ORDER_TITLE,
  SWAP_FEE_RECIPIENT,
} from '@/features/swap/constants'
import { calculateFeePercentageInBps } from '@/features/swap/helpers/fee'
import { UiOrderTypeToOrderType } from '@/features/swap/helpers/utils'
import { useGetIsSanctionedQuery } from '@/store/api/ofac'
import { skipToken } from '@reduxjs/toolkit/query/react'
import { getKeyWithTrueValue } from '@/utils/helpers'
import { BRAND_NAME } from '@/config/constants'
import { APPROVAL_SIGNATURE_HASH } from '@safe-global/utils/components/tx/ApprovalEditor/utils/approvals'
import { FEATURES } from '@safe-global/utils/utils/chains'

const BASE_URL = typeof window !== 'undefined' && window.location.origin ? window.location.origin : ''

const PRE_SIGN_SIGHASH = id('setPreSignature(bytes,bool)').slice(0, 10)
const WRAP_SIGHASH = id('deposit()').slice(0, 10)
const UNWRAP_SIGHASH = id('withdraw(uint256)').slice(0, 10)
const CREATE_WITH_CONTEXT_SIGHASH = id('createWithContext((address,bytes32,bytes),address,bytes,bool)').slice(0, 10)
const CANCEL_ORDER_SIGHASH = id('invalidateOrder(bytes)').slice(0, 10)

type Params = {
  sell?: {
    // The token address
    asset: string
    amount: string
  }
}

export const getSwapTitle = (tradeType: SwapState['tradeType'], txs: BaseTransaction[] | undefined) => {
  const hashToLabel = {
    [PRE_SIGN_SIGHASH]: tradeType === 'limit' ? LIMIT_ORDER_TITLE : SWAP_ORDER_TITLE,
    [APPROVAL_SIGNATURE_HASH]: 'Approve',
    [WRAP_SIGHASH]: 'Wrap',
    [UNWRAP_SIGHASH]: 'Unwrap',
    [CREATE_WITH_CONTEXT_SIGHASH]: TWAP_ORDER_TITLE,
    [CANCEL_ORDER_SIGHASH]: 'Cancel Order',
  }

  const swapTitle = txs
    ?.map((tx) => hashToLabel[tx.data.slice(0, 10)])
    .filter(Boolean)
    .join(' and ')

  return swapTitle
}

const SwapWidget = ({ sell }: Params) => {
  const { palette } = useTheme()
  const darkMode = useDarkMode()
  const chainId = useChainId()
  const dispatch = useAppDispatch()
  const swapParams = useAppSelector(selectSwapParams)
  const { safeAddress, safeLoading } = useSafeInfo()
  const [recipientAddress, setRecipientAddress] = useState('')
  const wallet = useWallet()
  const { isConsentAccepted, onAccept } = useSwapConsent()
  const feeEnabled = useHasFeature(FEATURES.NATIVE_SWAPS_FEE_ENABLED)
  const useStagingCowServer = useHasFeature(FEATURES.NATIVE_SWAPS_USE_COW_STAGING_SERVER)

  const { data: isSafeAddressBlocked } = useGetIsSanctionedQuery(safeAddress || skipToken)
  const { data: isWalletAddressBlocked } = useGetIsSanctionedQuery(wallet?.address || skipToken)
  const { data: isRecipientAddressBlocked } = useGetIsSanctionedQuery(recipientAddress || skipToken)
  const blockedAddresses = {
    [safeAddress]: !!isSafeAddressBlocked,
    [wallet?.address || '']: !!isWalletAddressBlocked,
    [recipientAddress]: !!isRecipientAddressBlocked,
  }

  const blockedAddress = getKeyWithTrueValue(blockedAddresses)

  const [params, setParams] = useState<CowSwapWidgetParams>({
    appCode: 'Safe Wallet Swaps', // Name of your app (max 50 characters)
    width: '100%', // Width in pixels (or 100% to use all available space)
    height: '860px',
    chainId,
    baseUrl: useStagingCowServer ? 'https://staging.swap.cow.fi' : 'https://swap.cow.fi',
    standaloneMode: false,
    disableToastMessages: true,
    disablePostedOrderConfirmationModal: true,
    hideLogo: true,
    hideNetworkSelector: true,
    sounds: {
      orderError: null,
      orderExecuted: null,
      postOrder: null,
    },
    tradeType: swapParams.tradeType,
    sell: sell || {
      asset: '',
      amount: '0',
    },
    buy: {
      asset: '',
      amount: '0',
    },
    images: {
      emptyOrders: darkMode
        ? BASE_URL + '/images/common/swap-empty-dark.svg'
        : BASE_URL + '/images/common/swap-empty-light.svg',
    },
    enabledTradeTypes: [TradeType.SWAP, TradeType.LIMIT, TradeType.ADVANCED],
    theme: {
      baseTheme: darkMode ? 'dark' : 'light',
      primary: palette.primary.main,
      background: palette.background.main,
      paper: palette.background.paper,
      text: palette.text.primary,
      danger: palette.error.dark,
      info: palette.info.main,
      success: palette.success.main,
      warning: palette.warning.main,
      alert: palette.warning.main,
    },
    partnerFee: {
      bps: feeEnabled ? 35 : 0,
      recipient: SWAP_FEE_RECIPIENT,
    },
    content: {
      feeLabel: 'Widget Fee',
      feeTooltipMarkdown: `The [tiered widget fee](https://help.safe.global/en/articles/178530-how-does-the-widget-fee-work-for-native-swaps) incurred here is charged by CoW Protocol for the operation of this widget. The fee is automatically calculated into this quote. Part of the fee will contribute to a license fee that supports the Safe Community. Neither the Safe Ecosystem Foundation nor ${BRAND_NAME} operate the CoW Swap Widget and/or CoW Swap`,
    },
  })

  const appData: SafeAppData = useMemo(
    () => ({
      id: 1,
      url: 'https://app.safe.global',
      name: SWAP_TITLE,
      iconUrl: darkMode ? './images/common/safe-swap-dark.svg' : './images/common/safe-swap.svg',
      description: 'Safe Apps',
      chainIds: ['1', '100'],
      accessControl: { type: SafeAppAccessPolicyTypes.NoRestrictions },
      tags: ['safe-apps'],
      features: [SafeAppFeatures.BATCHED_TRANSACTIONS],
      socialProfiles: [],
    }),
    [darkMode],
  )

  const listeners = useMemo<CowEventListeners>(() => {
    return [
      {
        event: CowEvents.ON_TOAST_MESSAGE,
        handler: (event) => {
          console.info('[Swaps] message:', event)
          const { messageType } = event

          switch (messageType) {
            case 'ORDER_CREATED':
              dispatch(
                setSwapOrder({
                  orderUid: event.data.orderUid,
                  status: 'created',
                }),
              )
              break
            case 'ORDER_PRESIGNED':
              dispatch(
                setSwapOrder({
                  orderUid: event.data.orderUid,
                  status: 'open',
                }),
              )
              break
            case 'ORDER_FULFILLED':
              dispatch(
                setSwapOrder({
                  orderUid: event.data.orderUid,
                  status: 'fulfilled',
                }),
              )
              break
            case 'ORDER_EXPIRED':
              dispatch(
                setSwapOrder({
                  orderUid: event.data.orderUid,
                  status: 'expired',
                }),
              )
              break
            case 'ORDER_CANCELLED':
              dispatch(
                setSwapOrder({
                  orderUid: event.data.orderUid,
                  status: 'cancelled',
                }),
              )
              break
          }
        },
      },
      {
        event: CowEvents.ON_CHANGE_TRADE_PARAMS,
        handler: (newTradeParams: OnTradeParamsPayload) => {
          const { orderType: tradeType, recipient, sellToken, buyToken } = newTradeParams

          const newFeeBps = feeEnabled ? calculateFeePercentageInBps(newTradeParams) : 0

          setParams((params) => ({
            ...params,
            tradeType: UiOrderTypeToOrderType(tradeType),
            partnerFee: {
              recipient: SWAP_FEE_RECIPIENT,
              bps: newFeeBps,
            },
            sell: {
              asset: sellToken?.address,
            },
            buy: {
              asset: buyToken?.address,
            },
          }))

          if (recipient) {
            setRecipientAddress(recipient)
          }

          dispatch(setSwapParams({ tradeType }))
        },
      },
    ]
  }, [dispatch, feeEnabled])

  useEffect(() => {
    setParams((params) => ({
      ...params,
      chainId,
      theme: {
        baseTheme: darkMode ? 'dark' : 'light',
        primary: palette.primary.main,
        background: palette.background.main,
        paper: palette.background.paper,
        text: palette.text.primary,
        danger: palette.error.dark,
        info: palette.info.main,
        success: palette.success.main,
        warning: palette.warning.main,
        alert: palette.warning.main,
      },
    }))
  }, [palette, darkMode, chainId])

  useEffect(() => {
    if (!sell) return
    setParams((params) => ({
      ...params,
      sell,
    }))
  }, [sell])

  const chain = useCurrentChain()

  const iframeRef: MutableRefObject<HTMLIFrameElement | null> = useRef<HTMLIFrameElement | null>(null)

  useEffect(() => {
    const iframeElement = document.querySelector('#swapWidget iframe')
    if (iframeElement) {
      iframeRef.current = iframeElement as HTMLIFrameElement
    }
  }, [params, isConsentAccepted, safeLoading])

  useCustomAppCommunicator(iframeRef, appData, chain)

  if (blockedAddress) {
    return <BlockedAddress address={blockedAddress} featureTitle="embedded swaps feature with CoW Swap" />
  }

  if (!isConsentAccepted) {
    return (
      <Disclaimer
        title="Note"
        content={<WidgetDisclaimer widgetName="CoW Swap Widget" />}
        onAccept={onAccept}
        buttonText="Continue"
      />
    )
  }

  return (
    <Box className={css.swapWidget} id="swapWidget">
      <CowSwapWidget params={params} listeners={listeners} />
    </Box>
  )
}

export default SwapWidget
</file>

<file path="src/features/swap/styles.module.css">
.swapWidget,
.swapWidget > div,
.swapWidget > div > iframe {
  height: 100% !important;
}
</file>

<file path="src/features/swap/useSwapConsent.ts">
import { useCallback } from 'react'
import useLocalStorage from '@/services/local-storage/useLocalStorage'

const SWAPS_CONSENT_STORAGE_KEY = 'swapDisclaimerAcceptedV1'

const useSwapConsent = (): {
  isConsentAccepted: boolean
  onAccept: () => void
} => {
  const [isConsentAccepted = false, setIsConsentAccepted] = useLocalStorage<boolean>(SWAPS_CONSENT_STORAGE_KEY)

  const onAccept = useCallback(() => {
    setIsConsentAccepted(true)
  }, [setIsConsentAccepted])

  return {
    isConsentAccepted,
    onAccept,
  }
}

export default useSwapConsent
</file>

<file path="src/features/targetedFeatures/hooks/useIsOutreachSafe.ts">
import { useTargetedMessagingGetTargetedSafeV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/targeted-messages'

import useSafeInfo from '@/hooks/useSafeInfo'
import { sameAddress } from '@safe-global/utils/utils/addresses'

export function useIsOutreachSafe(outreachId: number): boolean {
  const { safe } = useSafeInfo()
  const { data } = useTargetedMessagingGetTargetedSafeV1Query(
    {
      outreachId,
      chainId: safe.chainId,
      safeAddress: safe.address.value,
    },
    { skip: !safe.address.value },
  )

  return data?.outreachId === outreachId && sameAddress(data.address, safe.address.value)
}
</file>

<file path="src/features/targetedFeatures/hooks/useIsTargetedFeature.ts">
import { useEffect } from 'react'

import { useIsOutreachSafe } from '@/features/targetedFeatures/hooks/useIsOutreachSafe'
import { useHasFeature } from '@/hooks/useChains'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { TARGETED_FEATURES } from '../constants'

const UNLOCKED_FEATURES_LS_KEY = 'unlockedFeatures'

export type TargetedFeatures = (typeof TARGETED_FEATURES)[number]['feature']

export function useIsTargetedFeature(feature: TargetedFeatures): boolean {
  const hasFeature = useHasFeature(feature)

  const outreachId = TARGETED_FEATURES.find((f) => f && f['feature'] === feature)!['id']
  const isTargeted = useIsOutreachSafe(outreachId)

  // Should a targeted Safe have been opened, we "unlock" the feature across the app
  const [unlockedFeatures = [], setUnlockedFeatures] =
    useLocalStorage<Array<TargetedFeatures>>(UNLOCKED_FEATURES_LS_KEY)
  const isUnlocked = unlockedFeatures.includes(feature)
  useEffect(() => {
    if (hasFeature && isTargeted && !isUnlocked) {
      setUnlockedFeatures([...unlockedFeatures, feature])
    }
  }, [feature, hasFeature, isTargeted, isUnlocked, setUnlockedFeatures, unlockedFeatures])

  return !!hasFeature && (isTargeted || isUnlocked)
}
</file>

<file path="src/features/targetedFeatures/constants.ts">
export const TARGETED_FEATURES = [
  // example of a targeted feature
  // { id: 3, feature: FEATURES.NESTED_SAFES },
] as const
</file>

<file path="src/features/targetedOutreach/components/OutreachPopup/index.tsx">
import dynamic from 'next/dynamic'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

const LazyOutreachPopup = dynamic(() => import('./OutreachPopup'), {
  ssr: false,
})

function OutreachPopup() {
  const isEnabled = useHasFeature(FEATURES.TARGETED_SURVEY)
  return isEnabled ? <LazyOutreachPopup /> : null
}

export default OutreachPopup
</file>

<file path="src/features/targetedOutreach/components/OutreachPopup/OutreachPopup.tsx">
import { useCreateSubmissionMutation, useGetSubmissionQuery } from '@/store/api/gateway'
import { skipToken } from '@reduxjs/toolkit/query'
import { useEffect, type ReactElement } from 'react'
import { Avatar, Box, Button, IconButton, Link, Paper, Stack, ThemeProvider, Typography } from '@mui/material'
import { Close } from '@mui/icons-material'
import type { Theme } from '@mui/material/styles'
import { useAppDispatch, useAppSelector } from '@/store'
import css from './styles.module.css'
import { closeOutreachBanner, openOutreachBanner, selectOutreachBanner } from '@/store/popupSlice'
import useLocalStorage, { useSessionStorage } from '@/services/local-storage/useLocalStorage'
import useShowOutreachPopup from '@/features/targetedOutreach/hooks/useShowOutreachPopup'
import { ACTIVE_OUTREACH, OUTREACH_LS_KEY, OUTREACH_SS_KEY } from '@/features/targetedOutreach/constants'
import Track from '@/components/common/Track'
import { OUTREACH_EVENTS } from '@/services/analytics/events/outreach'
import SafeThemeProvider from '@/components/theme/SafeThemeProvider'
import useChainId from '@/hooks/useChainId'
import useSafeAddress from '@/hooks/useSafeAddress'
import useWallet from '@/hooks/wallets/useWallet'

const OutreachPopup = (): ReactElement | null => {
  const dispatch = useAppDispatch()
  const outreachPopup = useAppSelector(selectOutreachBanner)
  const [isClosed, setIsClosed] = useLocalStorage<boolean>(`${OUTREACH_LS_KEY}_v${ACTIVE_OUTREACH.id}`)
  const currentChainId = useChainId()
  const safeAddress = useSafeAddress()
  const wallet = useWallet()
  const [createSubmission] = useCreateSubmissionMutation()
  const { data: submission } = useGetSubmissionQuery(
    !wallet || !safeAddress
      ? skipToken
      : {
          outreachId: ACTIVE_OUTREACH.id,
          chainId: currentChainId,
          safeAddress,
          signerAddress: wallet?.address,
        },
  )

  const outreachUrl = `${ACTIVE_OUTREACH.url}#safe_address=${safeAddress}&signer_address=${wallet?.address}&chain_id=${currentChainId}`

  const [askAgainLaterTimestamp, setAskAgainLaterTimestamp] = useSessionStorage<number>(
    `${OUTREACH_SS_KEY}_v${ACTIVE_OUTREACH.id}`,
  )

  const shouldOpen = useShowOutreachPopup(isClosed, askAgainLaterTimestamp, submission)

  const handleClose = () => {
    setIsClosed(true)
    dispatch(closeOutreachBanner())
  }

  const handleAskAgainLater = () => {
    setAskAgainLaterTimestamp(Date.now())
    dispatch(closeOutreachBanner())
  }

  // Decide whether to show the popup.
  useEffect(() => {
    if (shouldOpen) {
      dispatch(openOutreachBanner())
    } else {
      dispatch(closeOutreachBanner())
    }
  }, [dispatch, shouldOpen])

  if (!outreachPopup.open) return null

  const handleOpenSurvey = async () => {
    if (wallet) {
      await createSubmission({
        outreachId: ACTIVE_OUTREACH.id,
        chainId: currentChainId,
        safeAddress,
        signerAddress: wallet.address,
      })
    }
    dispatch(closeOutreachBanner())
  }

  return (
    // Enforce light theme for the popup
    <SafeThemeProvider mode="light">
      {(safeTheme: Theme) => (
        <ThemeProvider theme={safeTheme}>
          <Box className={css.popup}>
            <Paper className={css.container}>
              <Stack gap={2}>
                <Box display="flex" alignItems="center">
                  <Avatar
                    alt="Product marketing lead avatar"
                    src="/images/common/outreach-popup-avatar.png"
                    className={css.avatar}
                  />
                  <Box ml={1}>
                    <Typography variant="body2">Danilo Pereira</Typography>
                    <Typography variant="body2" color="primary.light">
                      Product Marketing Lead
                    </Typography>
                  </Box>
                </Box>
                <Typography variant="h4" fontWeight={700}>
                  Your voice matters!
                  <br />
                  Help us improve {'Safe{Wallet}'}.
                </Typography>
                <Typography>
                  In 1 minute, tell us why you use {'Safe{Wallet}'}. Your input will help us create a better, smarter
                  wallet experience for you!
                </Typography>
                <Track {...OUTREACH_EVENTS.OPEN_SURVEY}>
                  <Link rel="noreferrer noopener" target="_blank" href={outreachUrl}>
                    <Button fullWidth variant="contained" onClick={handleOpenSurvey}>
                      Get Involved
                    </Button>
                  </Link>
                </Track>
                <Track {...OUTREACH_EVENTS.ASK_AGAIN_LATER}>
                  <Button fullWidth variant="text" onClick={handleAskAgainLater}>
                    Ask me later
                  </Button>
                </Track>
                <Typography variant="body2" color="primary.light" mx="auto">
                  It&apos;ll only take 1 minute.
                </Typography>
              </Stack>
              <Track {...OUTREACH_EVENTS.CLOSE_POPUP}>
                <IconButton className={css.close} aria-label="close outreach popup" onClick={handleClose}>
                  <Close />
                </IconButton>
              </Track>
            </Paper>
          </Box>
        </ThemeProvider>
      )}
    </SafeThemeProvider>
  )
}
export default OutreachPopup
</file>

<file path="src/features/targetedOutreach/components/OutreachPopup/styles.module.css">
.popup {
  position: fixed;
  z-index: 1300;
  bottom: var(--space-2);
  right: var(--space-2);
  max-width: 340px;
}

.container {
  padding: var(--space-2);
  border-radius: var(--space-2);
  background: linear-gradient(180deg, #b0ffc9 0%, #d7f6ff 99.5%);
}

.close {
  position: absolute;
  right: var(--space-1);
  top: var(--space-1);
  z-index: 1;
  padding: var(--space-1);
}

.avatar {
  height: 32px;
  width: 32px;
}

@media (max-width: 599.99px) {
  .popup {
    right: 0;
    bottom: 0;
  }
}
</file>

<file path="src/features/targetedOutreach/hooks/useShowOutreachPopup.tsx">
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { ACTIVE_OUTREACH, MAX_ASK_AGAIN_DELAY } from '@/features/targetedOutreach/constants'
import { useAppSelector } from '@/store'
import { selectCookieBanner } from '@/store/popupSlice'
import type { getSubmission } from '@safe-global/safe-client-gateway-sdk'

const useShowOutreachPopup = (
  isDismissed: boolean | undefined,
  askAgainLaterTimestamp: number | undefined,
  submission: getSubmission | undefined,
) => {
  const cookiesPopup = useAppSelector(selectCookieBanner)
  const isSigner = useIsSafeOwner()

  const submissionHasLoaded = submission !== undefined
  const isTargetedSafe = submissionHasLoaded && (ACTIVE_OUTREACH.targetAll || !!submission?.outreachId)
  const hasCompletedSurvey = !!submission?.completionDate

  if (cookiesPopup?.open || isDismissed || !isSigner || !isTargetedSafe || hasCompletedSurvey) {
    return false
  }

  if (askAgainLaterTimestamp) {
    return Date.now() - askAgainLaterTimestamp > MAX_ASK_AGAIN_DELAY
  }

  return true
}

export default useShowOutreachPopup
</file>

<file path="src/features/targetedOutreach/constants.ts">
export const ACTIVE_OUTREACH = { id: 2, url: 'https://wn2n6ocviur.typeform.com/to/nlQlP7lU', targetAll: true }

export const OUTREACH_LS_KEY = 'outreachPopup'
export const OUTREACH_SS_KEY = 'outreachPopup_session'

export const HOUR_IN_MS = 60 * 60 * 1000
export const MAX_ASK_AGAIN_DELAY = HOUR_IN_MS * 24
</file>

<file path="src/features/tx-notes/encodeTxNote.ts">
const MAX_ORIGIN_LENGTH = 200

// Simply strip out any HTML tags from the input in addition to backend sanitization
function sanitizeInput(input: string): string {
  return input.replace(/<\/?[^>]+(>|$)/g, '')
}

export function encodeTxNote(note: string, origin = ''): string {
  note = sanitizeInput(note)
  let originalOrigin = {}

  if (origin) {
    try {
      originalOrigin = JSON.parse(origin)
    } catch {
      // Ignore, invalid JSON
    }
  }

  let result = JSON.stringify({
    ...originalOrigin,
    note,
  })

  if (result.length > MAX_ORIGIN_LENGTH) {
    result = JSON.stringify({
      ...originalOrigin,
      note: note.slice(0, MAX_ORIGIN_LENGTH - origin.length),
    })
  }

  return result
}
</file>

<file path="src/features/tx-notes/index.tsx">
import { featureToggled, FEATURES } from '@/utils/featureToggled'
import { TxNote as TxNoteComponent } from './TxNote'
import { TxNoteForm as TxNoteFormComponent } from './TxNoteForm'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'

export const TxNote = featureToggled(TxNoteComponent, FEATURES.TX_NOTES)
export const TxNoteForm = featureToggled(TxNoteFormComponent, FEATURES.TX_NOTES)
export * from './encodeTxNote'

export function trackAddNote() {
  trackEvent(MODALS_EVENTS.SUBMIT_TX_NOTE)
}
</file>

<file path="src/features/tx-notes/TxNote.tsx">
import { Tooltip, Typography, Stack } from '@mui/material'
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import InfoIcon from '@/public/images/notifications/info.svg'
import { isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'
import EthHashInfo from '@/components/common/EthHashInfo'

export function TxNote({ txDetails }: { txDetails: TransactionDetails | undefined }) {
  const note = txDetails?.note
  if (!note) return null

  const creator =
    isMultisigDetailedExecutionInfo(txDetails?.detailedExecutionInfo) && txDetails?.detailedExecutionInfo.proposer

  return (
    <div>
      <Typography variant="h5" display="flex" alignItems="center" justifyItems="center">
        Note
        <Tooltip
          data-testid="tx-note-tooltip"
          title={
            <Stack data-testid="note-creator" direction="row" gap={1}>
              <span>By </span>
              {creator ? (
                <EthHashInfo avatarSize={20} address={creator.value} showName onlyName />
              ) : (
                <span>transaction creator</span>
              )}
            </Stack>
          }
          arrow
        >
          <Typography color="text.secondary" component="span" height="1em">
            <InfoIcon height="100%" />
          </Typography>
        </Tooltip>
      </Typography>

      <Typography data-testid="tx-note" p={2} mt={1} borderRadius={1} bgcolor="background.main">
        {note}
      </Typography>
    </div>
  )
}
</file>

<file path="src/features/tx-notes/TxNoteForm.tsx">
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import TxCard from '@/components/tx-flow/common/TxCard'
import { TxNote } from './TxNote'
import { TxNoteInput } from './TxNoteInput'

export function TxNoteForm({
  isCreation,
  txDetails,
  onChange,
}: {
  isCreation: boolean
  txDetails?: TransactionDetails
  onChange: (note: string) => void
}) {
  if (!isCreation && !txDetails?.note) return null

  return <TxCard>{isCreation ? <TxNoteInput onChange={onChange} /> : <TxNote txDetails={txDetails} />}</TxCard>
}
</file>

<file path="src/features/tx-notes/TxNoteInput.tsx">
import { useCallback } from 'react'
import { InputAdornment, Stack, TextField, Typography, SvgIcon, Box } from '@mui/material'
import { MODALS_EVENTS, trackEvent } from '@/services/analytics'
import { useForm } from 'react-hook-form'
import InfoOutlinedIcon from '@/public/images/notifications/info.svg'

const MAX_NOTE_LENGTH = 60

export const TxNoteInput = ({ onChange }: { onChange: (note: string) => void }) => {
  const {
    register,
    watch,
    reset,
    formState: { isDirty },
  } = useForm<{ note: string }>()

  const note = watch('note') || ''

  const onInput = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      onChange(e.target.value.slice(0, MAX_NOTE_LENGTH))
    },
    [onChange],
  )

  const onFocus = useCallback(() => {
    // Reset the isDirty state when the user focuses on the input
    reset({ note })
  }, [reset, note])

  const onBlur = useCallback(() => {
    if (isDirty && note.length > 0) {
      // Track the event only if the note is dirty and not empty
      // This prevents tracking the event when the user focuses and blurs the input without changing the note
      trackEvent(MODALS_EVENTS.SUBMIT_TX_NOTE)
    }
  }, [isDirty, note])

  return (
    <>
      <Stack direction="row" alignItems="flex-end" gap={1}>
        <Typography variant="h5">Add transaction note</Typography>
      </Stack>

      <TextField
        data-testid="tx-note-textfield"
        label="Note (optional)"
        fullWidth
        slotProps={{
          htmlInput: { maxLength: MAX_NOTE_LENGTH },
          input: {
            endAdornment: (
              <InputAdornment position="end">
                <Typography variant="caption" mt={3}>
                  {note.length}/{MAX_NOTE_LENGTH}
                </Typography>
              </InputAdornment>
            ),
          },
        }}
        {...register('note')}
        onInput={onInput}
        onBlur={onBlur}
        onFocus={onFocus}
      />

      <Stack data-testid="tx-note-alert" direction="row" gap={1} color="text.secondary">
        <SvgIcon component={InfoOutlinedIcon} sx={{ width: '20px', height: '20px', rotate: '180deg' }} inheritViewBox />
        <Box>
          <Typography variant="body2" fontWeight="700">
            Notes are publicly visible.
          </Typography>
          <Typography variant="body2">Do not share any private or sensitive details.</Typography>
        </Box>
      </Stack>
    </>
  )
}
</file>

<file path="src/features/walletconnect/components/WalletConnectProvider/index.tsx">
import { type ReactNode, useEffect, useState } from 'react'
import { getSdkError } from '@walletconnect/utils'
import { formatJsonRpcError } from '@walletconnect/jsonrpc-utils'

import useSafeInfo from '@/hooks/useSafeInfo'
import useSafeWalletProvider from '@/services/safe-wallet-provider/useSafeWalletProvider'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { IS_PRODUCTION } from '@/config/constants'
import { getPeerName, stripEip155Prefix } from '@/features/walletconnect/services/utils'
import { trackRequest } from '@/features/walletconnect//services/tracking'
import { wcPopupStore } from '@/features/walletconnect/components'
import WalletConnectWallet from '@/features/walletconnect/services/WalletConnectWallet'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'

enum Errors {
  WRONG_CHAIN = '%%dappName%% made a request on a different chain than the one you are connected to',
}

export enum WCLoadingState {
  APPROVE = 'Approve',
  REJECT = 'Reject',
  CONNECT = 'Connect',
  DISCONNECT = 'Disconnect',
}

// The URL of the former WalletConnect Safe App
// This is still used to differentiate these txs from Safe App txs in the analytics
const LEGACY_WC_APP_URL = 'https://apps-portal.safe.global/wallet-connect'

const walletConnectSingleton = new WalletConnectWallet()

const getWrongChainError = (dappName: string): Error => {
  const message = Errors.WRONG_CHAIN.replace('%%dappName%%', dappName)
  return new Error(message)
}

export const WalletConnectProvider = ({ children }: { children: ReactNode }) => {
  const {
    safe: { chainId },
    safeAddress,
  } = useSafeInfo()
  const [walletConnect, setWalletConnect] = useState<WalletConnectWallet | null>(null)
  const open = wcPopupStore.useStore() ?? false
  const setOpen = wcPopupStore.setStore
  const [error, setError] = useState<Error | null>(null)
  const [isLoading, setIsLoading] = useState<WCLoadingState>()
  const safeWalletProvider = useSafeWalletProvider()

  // Init WalletConnect
  useEffect(() => {
    walletConnectSingleton
      .init()
      .then(() => setWalletConnect(walletConnectSingleton))
      .catch(setError)
  }, [])

  // Update chainId/safeAddress
  useEffect(() => {
    if (!walletConnect || !chainId || !safeAddress) return

    walletConnect.updateSessions(chainId, safeAddress).catch(setError)
  }, [walletConnect, chainId, safeAddress])

  // Subscribe to requests
  useEffect(() => {
    if (!walletConnect || !safeWalletProvider || !chainId) return

    return walletConnect.onRequest(async (event) => {
      if (!IS_PRODUCTION) {
        console.log('[WalletConnect] request', event)
      }

      const { topic } = event
      const session = walletConnect.getActiveSessions().find((s) => s.topic === topic)
      const requestChainId = stripEip155Prefix(event.params.chainId)

      // Track requests
      if (session) {
        trackRequest(session.peer.metadata.url, event.params.request.method)
      }

      const getResponse = () => {
        // Get error if wrong chain
        if (!session || requestChainId !== chainId) {
          if (session) {
            setError(getWrongChainError(getPeerName(session.peer)))
          }

          const error = getSdkError('UNSUPPORTED_CHAINS')
          return formatJsonRpcError(event.id, error)
        }

        // Get response from Safe Wallet Provider
        return safeWalletProvider.request(event.id, event.params.request, {
          url: LEGACY_WC_APP_URL, // required for server-side analytics
          name: getPeerName(session.peer) || 'WalletConnect',
          description: session.peer.metadata.description,
          iconUrl: session.peer.metadata.icons[0],
        })
      }

      try {
        const response = await getResponse()

        // Send response to WalletConnect
        await walletConnect.sendSessionResponse(topic, response)
      } catch (e) {
        setError(asError(e))
      }
    })
  }, [walletConnect, chainId, safeWalletProvider])

  return (
    <WalletConnectContext.Provider value={{ walletConnect, error, setError, open, setOpen, isLoading, setIsLoading }}>
      {children}
    </WalletConnectContext.Provider>
  )
}
</file>

<file path="src/features/walletconnect/components/WalletConnectUi/index.tsx">
import { useCallback, useContext, useEffect } from 'react'
import { ErrorBoundary } from '@sentry/react'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWalletConnectSessions from '@/features/walletconnect/hooks/useWalletConnectSessions'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'
import useWcUri from '../../hooks/useWcUri'
import WcHeaderWidget from '../WcHeaderWidget'
import WcSessionManager from '../WcSessionManager'
import { WalletConnectProvider } from '../WalletConnectProvider'

const WalletConnectWidget = () => {
  const { walletConnect, error, open, setOpen } = useContext(WalletConnectContext)
  const [uri, clearUri] = useWcUri()
  const sessions = useWalletConnectSessions()
  const { safeLoaded } = useSafeInfo()

  const onOpen = useCallback(() => {
    setOpen(true)
  }, [setOpen])

  const onClose = useCallback(() => {
    setOpen(false)
  }, [setOpen])

  // Open the popup if there is a pairing code in the URL or clipboard
  useEffect(() => {
    if (safeLoaded && uri) {
      onOpen()
    }
  }, [safeLoaded, uri, onOpen])

  // Clear the pairing code when connected
  useEffect(() => {
    return walletConnect?.onSessionPropose(clearUri)
  }, [walletConnect, clearUri])

  return (
    <WcHeaderWidget isError={!!error} isOpen={open} onOpen={onOpen} onClose={onClose} sessions={sessions}>
      <WcSessionManager sessions={sessions} uri={uri} />
    </WcHeaderWidget>
  )
}

const WalletConnectUi = () => (
  <ErrorBoundary>
    <WalletConnectProvider>
      <WalletConnectWidget />
    </WalletConnectProvider>
  </ErrorBoundary>
)

export default WalletConnectUi
</file>

<file path="src/features/walletconnect/components/WcConnectionForm/index.tsx">
import { useCallback, useEffect } from 'react'
import { Grid, Typography, Divider, SvgIcon, IconButton, Tooltip, Box } from '@mui/material'
import type { ReactElement } from 'react'
import type { SessionTypes } from '@walletconnect/types'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import InfoIcon from '@/public/images/notifications/info.svg'
import WcHints from '../WcHints'
import WcSessionList from '../WcSessionList'
import WcInput from '../WcInput'
import WcLogoHeader from '../WcLogoHeader'
import css from './styles.module.css'
import useSafeInfo from '@/hooks/useSafeInfo'
import Track from '@/components/common/Track'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'
import { BRAND_NAME } from '@/config/constants'

const WC_HINTS_KEY = 'wcHints'

export const WcConnectionForm = ({ sessions, uri }: { sessions: SessionTypes.Struct[]; uri: string }): ReactElement => {
  const [showHints = true, setShowHints] = useLocalStorage<boolean>(WC_HINTS_KEY)
  const { safeLoaded } = useSafeInfo()

  const onToggle = useCallback(() => {
    setShowHints((prev) => !prev)
  }, [setShowHints])

  // Show the hints only once
  useEffect(() => {
    return () => setShowHints(false)
  }, [setShowHints])

  return (
    <Grid className={css.container}>
      <Grid
        item
        sx={{
          textAlign: 'center',
        }}
      >
        <Tooltip
          title={showHints ? 'Hide how WalletConnect works' : 'How does WalletConnect work?'}
          placement="top"
          arrow
          className={css.infoIcon}
        >
          <span>
            <Track {...(showHints ? WALLETCONNECT_EVENTS.HINTS_HIDE : WALLETCONNECT_EVENTS.HINTS_SHOW)}>
              <IconButton onClick={onToggle}>
                <SvgIcon component={InfoIcon} inheritViewBox color="border" />
              </IconButton>
            </Track>
          </span>
        </Tooltip>

        <WcLogoHeader />

        <Typography
          variant="body2"
          sx={{
            color: 'text.secondary',
          }}
        >
          {safeLoaded
            ? `Paste the pairing code below to connect to your ${BRAND_NAME} via WalletConnect`
            : `Please open one of your Safe Accounts to connect to via WalletConnect`}
        </Typography>

        {safeLoaded ? (
          <Box
            sx={{
              mt: 3,
            }}
          >
            <WcInput uri={uri} />
          </Box>
        ) : null}
      </Grid>
      <Divider flexItem />
      <Grid item>
        <WcSessionList sessions={sessions} />
      </Grid>
      {showHints && (
        <>
          <Divider flexItem />

          <Grid
            item
            sx={{
              mt: 1,
            }}
          >
            <WcHints />
          </Grid>
        </>
      )}
    </Grid>
  )
}

export default WcConnectionForm
</file>

<file path="src/features/walletconnect/components/WcConnectionForm/styles.module.css">
.container :global .MuiGrid-item {
  padding: var(--space-3) 0;
}

.container :global .MuiGrid-item:first-of-type {
  padding: 0 0 var(--space-3) 0;
}

.container :global .MuiGrid-item:last-of-type {
  padding: var(--space-3) 0 0 0;
}

.infoIcon {
  position: absolute;
  top: var(--space-3);
  right: var(--space-3);
}
</file>

<file path="src/features/walletconnect/components/WcConnectionState/index.tsx">
import { SvgIcon, Typography } from '@mui/material'
import classNames from 'classnames'
import type { CoreTypes } from '@walletconnect/types'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import SafeLogo from '@/public/images/logo-no-text.svg'
import ConnectionDots from '@/public/images/common/connection-dots.svg'
import css from './styles.module.css'

const WcConnectionState = ({ metadata, isDelete }: { metadata?: CoreTypes.Metadata; isDelete: boolean }) => {
  const name = metadata?.name || 'dApp'
  const icon = metadata?.icons[0] || ''

  return (
    <div data-testid="wc-connection-state" className={css.container}>
      <div>
        <SafeLogo alt="Safe logo" width="28px" height="28px" />

        <SvgIcon
          data-testid="connection-dots"
          component={ConnectionDots}
          inheritViewBox
          sx={{ mx: 2 }}
          className={classNames(css.dots, { [css.errorDots]: isDelete })}
        />

        <SafeAppIconCard src={icon} width={28} height={28} alt={`${name} logo`} />
      </div>

      <Typography variant="h5" mt={3}>
        {isDelete ? `${name} disconnected` : `${name} successfully connected!`}
      </Typography>
    </div>
  )
}

export default WcConnectionState
</file>

<file path="src/features/walletconnect/components/WcConnectionState/styles.module.css">
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  padding-top: var(--space-2);
}

.errorDots circle:first-of-type,
.errorDots circle:last-of-type {
  fill: var(--color-error-dark);
}

.errorDots circle:nth-of-type(2),
.errorDots circle:nth-of-type(5) {
  fill: var(--color-error-main);
}
.errorDots circle:nth-of-type(3),
.errorDots circle:nth-of-type(4) {
  fill: var(--color-error-light);
}

@keyframes blink {
  0% {
    opacity: 0.2;
  }
  100% {
    transform: 1;
  }
}

.dots circle {
  animation: blink 1.5s ease-in-out infinite;
}

.dots circle:nth-of-type(1) {
  animation-delay: 0;
}
.dots circle:nth-of-type(2),
.dots circle:nth-of-type(5) {
  animation-delay: 0.2s;
}

.dots circle:nth-of-type(3),
.dots circle:nth-of-type(4) {
  animation-delay: 0.3s;
}
</file>

<file path="src/features/walletconnect/components/WcErrorMessage/index.tsx">
import { splitError } from '@/features/walletconnect/services/utils'
import { Button, Typography } from '@mui/material'
import WcLogoHeader from '../WcLogoHeader'
import css from './styles.module.css'

const WcErrorMessage = ({ error, onClose }: { error: Error; onClose: () => void }) => {
  const message = error.message || 'An error occurred'
  const [summary, details] = splitError(message)

  return (
    <div className={css.errorContainer}>
      <WcLogoHeader errorMessage={summary} />

      {details && (
        <Typography mt={1} className={css.details}>
          {details}
        </Typography>
      )}

      <Button variant="contained" onClick={onClose} className={css.button}>
        OK
      </Button>
    </div>
  )
}

export default WcErrorMessage
</file>

<file path="src/features/walletconnect/components/WcErrorMessage/styles.module.css">
.errorContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.button {
  padding: var(--space-1) var(--space-4);
  margin-top: var(--space-3);
}

.details {
  width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  hyphens: auto;
}
</file>

<file path="src/features/walletconnect/components/WcHeaderWidget/index.tsx">
import { type ReactNode, useRef } from 'react'
import type { SessionTypes } from '@walletconnect/types'
import Popup from '@/components/common/Popup'
import WcIcon from './WcIcon'

type WcHeaderWidgetProps = {
  children: ReactNode
  sessions: SessionTypes.Struct[]
  isError: boolean
  isOpen: boolean
  onOpen: () => void
  onClose: () => void
}

const WcHeaderWidget = ({ sessions, ...props }: WcHeaderWidgetProps) => {
  const iconRef = useRef<HTMLDivElement>(null)

  return (
    <>
      <div ref={iconRef}>
        <WcIcon
          onClick={props.onOpen}
          sessionCount={sessions.length}
          sessionIcon={sessions[0]?.peer.metadata.icons[0]}
          isError={props.isError}
        />
      </div>

      <Popup keepMounted anchorEl={iconRef.current} open={props.isOpen} onClose={props.onClose} transitionDuration={0}>
        {props.children}
      </Popup>
    </>
  )
}

export default WcHeaderWidget
</file>

<file path="src/features/walletconnect/components/WcHeaderWidget/WcIcon.tsx">
import { type ReactElement } from 'react'
import { Badge, ButtonBase, SvgIcon } from '@mui/material'
import WalletConnectIcon from '@/public/images/common/walletconnect.svg'
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'
import Track from '@/components/common/Track'

type WcIconProps = {
  onClick: () => void
  sessionCount: number
  isError: boolean
  sessionIcon?: string
}

const WcIcon = ({ sessionCount, sessionIcon, isError, onClick }: WcIconProps): ReactElement => {
  const showIcon = sessionCount === 1 && !!sessionIcon

  return (
    <Track {...WALLETCONNECT_EVENTS.POPUP_OPENED}>
      <ButtonBase onClick={onClick} title="WalletConnect" sx={{ p: 2 }}>
        <Badge
          variant={isError ? 'dot' : 'standard'}
          badgeContent={
            showIcon ? (
              <SafeAppIconCard alt="Connected dApp icon" src={sessionIcon} width={18} height={18} />
            ) : (
              sessionCount
            )
          }
          color={isError ? 'error' : showIcon ? undefined : 'secondary'}
          anchorOrigin={{
            vertical: 'bottom',
            horizontal: 'right',
          }}
        >
          <SvgIcon component={WalletConnectIcon} inheritViewBox fontSize="medium" />
        </Badge>
      </ButtonBase>
    </Track>
  )
}

export default WcIcon
</file>

<file path="src/features/walletconnect/components/WcHints/index.tsx">
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import {
  Accordion,
  AccordionSummary,
  Avatar,
  Box,
  Typography,
  AccordionDetails,
  SvgIcon,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
} from '@mui/material'
import { useState } from 'react'
import type { ReactElement } from 'react'
import Question from '@/public/images/common/question.svg'
import css from './styles.module.css'
import { trackEvent } from '@/services/analytics'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'

const HintAccordion = ({
  title,
  items,
  expanded,
  onExpand,
}: {
  title: string
  items: Array<string>
  expanded: boolean
  onExpand: () => void
}): ReactElement => {
  return (
    <Accordion onClick={onExpand} expanded={expanded}>
      <AccordionSummary expandIcon={<ExpandMoreIcon />}>
        <Typography className={css.title}>
          <SvgIcon component={Question} inheritViewBox className={css.questionIcon} />
          {title}
        </Typography>
      </AccordionSummary>

      <AccordionDetails sx={{ p: 0 }}>
        <List className={css.list}>
          {items.map((item, i) => (
            <ListItem key={i} sx={{ p: 0 }}>
              <ListItemAvatar className={css.listItemAvatar}>
                <Avatar className={css.avatar}>{i + 1}</Avatar>
              </ListItemAvatar>
              <ListItemText primary={item} sx={{ m: 0 }} primaryTypographyProps={{ variant: 'body2' }} />
            </ListItem>
          ))}
        </List>
      </AccordionDetails>
    </Accordion>
  )
}

const ConnectionTitle = 'How do I connect to a dApp?'
const ConnectionSteps = [
  'Open a WalletConnect supported dApp',
  'Connect a wallet',
  'Select WalletConnect as the wallet',
  'Copy the pairing code and paste it into the input field above',
  'Approve the session',
  'dApp is now connected to the Safe',
]

const InteractionTitle = 'How do I interact with a dApp?'
const InteractionSteps = [
  'Connect a dApp by following the above steps',
  'Ensure the dApp is connected to the same chain as your Safe Account',
  'Initiate a transaction/signature request via the dApp',
  'Transact/sign as normal via the Safe',
]

const WcHints = (): ReactElement => {
  const [expandedAccordion, setExpandedAccordion] = useState<'connection' | 'interaction' | null>(null)

  const onExpand = (accordion: 'connection' | 'interaction') => {
    setExpandedAccordion((prev) => {
      return prev === accordion ? null : accordion
    })

    trackEvent(WALLETCONNECT_EVENTS.HINTS_EXPAND)
  }

  return (
    <Box display="flex" flexDirection="column" gap={1}>
      <HintAccordion
        title={ConnectionTitle}
        items={ConnectionSteps}
        onExpand={() => onExpand('connection')}
        expanded={expandedAccordion === 'connection'}
      />
      <HintAccordion
        title={InteractionTitle}
        items={InteractionSteps}
        onExpand={() => onExpand('interaction')}
        expanded={expandedAccordion === 'interaction'}
      />
    </Box>
  )
}

export default WcHints
</file>

<file path="src/features/walletconnect/components/WcHints/styles.module.css">
.title {
  display: flex;
  align-items: center;
  justify-content: center;
}

.questionIcon {
  color: currentColor;
  vertical-align: middle;
  margin-right: var(--space-1);
  font-size: inherit;
}

.list {
  padding: var(--space-2);
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.listItemAvatar {
  min-width: unset;
  margin-right: var(--space-2);
}

.avatar {
  width: 16px;
  height: 16px;
  font-size: 11px;
}
</file>

<file path="src/features/walletconnect/components/WcInput/index.tsx">
import Track from '@/components/common/Track'
import { WCLoadingState } from '@/features/walletconnect/components/WalletConnectProvider'
import { isPairingUri } from '@/features/walletconnect/services/utils'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'
import useDebounce from '@/hooks/useDebounce'
import { trackEvent } from '@/services/analytics'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { getClipboard, isClipboardSupported } from '@/utils/clipboard'
import { Button, CircularProgress, InputAdornment, TextField } from '@mui/material'
import { useCallback, useContext, useEffect, useState } from 'react'

const PROPOSAL_TIMEOUT = 30_000

const useTrackErrors = (error?: Error) => {
  const debouncedErrorMessage = useDebounce(error?.message, 1000)

  // Track errors
  useEffect(() => {
    if (debouncedErrorMessage) {
      trackEvent({ ...WALLETCONNECT_EVENTS.SHOW_ERROR, label: debouncedErrorMessage })
    }
  }, [debouncedErrorMessage])
}

const WcInput = ({ uri }: { uri: string }) => {
  const { walletConnect, isLoading, setIsLoading, setError } = useContext(WalletConnectContext)
  const [value, setValue] = useState('')
  const [inputError, setInputError] = useState<Error>()
  useTrackErrors(inputError)

  const onInput = useCallback(
    async (val: string) => {
      if (!walletConnect) return

      setValue(val)

      if (val && !isPairingUri(val)) {
        setInputError(new Error('Invalid pairing code'))
        return
      }

      setInputError(undefined)

      if (!val) return

      setIsLoading(WCLoadingState.CONNECT)

      try {
        await walletConnect.connect(val)
      } catch (e) {
        setInputError(asError(e))
        setIsLoading(undefined)
      }
      setTimeout(() => {
        if (isLoading && isLoading !== WCLoadingState.APPROVE) {
          setIsLoading(undefined)
          setError(new Error('Connection timed out'))
        }
      }, PROPOSAL_TIMEOUT)
    },
    [isLoading, setError, setIsLoading, walletConnect],
  )

  // Insert a pre-filled uri
  useEffect(() => {
    onInput(uri)
  }, [onInput, uri])

  const onPaste = useCallback(async () => {
    // Errors are handled by in getClipboard
    const clipboard = await getClipboard()

    if (clipboard && isPairingUri(clipboard)) {
      onInput(clipboard)
    }
  }, [onInput])

  return (
    <TextField
      data-testid="wc-input"
      value={value}
      onChange={(e) => onInput(e.target.value)}
      fullWidth
      autoComplete="off"
      autoFocus
      disabled={!!isLoading}
      error={!!inputError}
      label={inputError ? inputError.message : 'Pairing code'}
      placeholder="wc:"
      spellCheck={false}
      InputProps={{
        autoComplete: 'off',
        endAdornment: isClipboardSupported() ? undefined : (
          <InputAdornment position="end">
            <Track {...WALLETCONNECT_EVENTS.PASTE_CLICK}>
              <Button variant="contained" onClick={onPaste} sx={{ py: 1 }} disabled={!!isLoading}>
                {isLoading === WCLoadingState.CONNECT || isLoading === WCLoadingState.APPROVE ? (
                  <CircularProgress size={20} />
                ) : (
                  'Paste'
                )}
              </Button>
            </Track>
          </InputAdornment>
        ),
      }}
    />
  )
}

export default WcInput
</file>

<file path="src/features/walletconnect/components/WcLogoHeader/index.tsx">
import { SvgIcon, Typography } from '@mui/material'
import type { ReactElement } from 'react'
import WalletConnect from '@/public/images/common/walletconnect.svg'
import Alert from '@/public/images/notifications/alert.svg'
import css from './styles.module.css'
import { BRAND_NAME } from '@/config/constants'

const WcLogoHeader = ({ errorMessage }: { errorMessage?: string }): ReactElement => {
  return (
    <>
      <div>
        <SvgIcon data-testid="wc-icon" component={WalletConnect} inheritViewBox className={css.icon} />
        {errorMessage && (
          <SvgIcon
            data-testid="wc-alert"
            component={Alert}
            inheritViewBox
            className={css.errorBadge}
            fontSize="small"
          />
        )}
      </div>

      <Typography data-testid="wc-title" variant="h5" mt={2} mb={0.5} className={css.title}>
        {errorMessage || `Connect dApps to ${BRAND_NAME}`}
      </Typography>
    </>
  )
}

export default WcLogoHeader
</file>

<file path="src/features/walletconnect/components/WcLogoHeader/styles.module.css">
.icon {
  color: #3a99fb;
  font-size: 50px;
}

.errorBadge {
  color: var(--color-error-main);
  margin-left: -16px;
  margin-bottom: -6px;
  background-color: var(--color-background-paper);
  border-radius: 50%;
  border: 1px solid var(--color-background-paper);
}

.title {
  width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
}
</file>

<file path="src/features/walletconnect/components/WcProposalForm/CompatibilityWarning.tsx">
import { Alert, Stack, Typography } from '@mui/material'
import type { WalletKitTypes } from '@reown/walletkit'

import ChainIndicator from '@/components/common/ChainIndicator'
import { useCompatibilityWarning } from './useCompatibilityWarning'
import useSafeInfo from '@/hooks/useSafeInfo'

import css from './styles.module.css'

export const CompatibilityWarning = ({
  proposal,
  chainIds,
}: {
  proposal: WalletKitTypes.SessionProposal
  chainIds: Array<string>
}) => {
  const { safe } = useSafeInfo()
  const isUnsupportedChain = !chainIds.includes(safe.chainId)
  const { severity, message } = useCompatibilityWarning(proposal, isUnsupportedChain)

  return (
    <>
      <Alert severity={severity} className={css.alert}>
        {message}
      </Alert>

      {isUnsupportedChain && (
        <>
          <Typography mt={3} mb={1} variant="h5">
            Supported networks
          </Typography>

          <Stack direction="row">
            {chainIds.map((chainId) => (
              <ChainIndicator inline chainId={chainId} key={chainId} className={css.chain} />
            ))}
          </Stack>
        </>
      )}
    </>
  )
}
</file>

<file path="src/features/walletconnect/components/WcProposalForm/index.tsx">
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import { WCLoadingState } from '@/features/walletconnect/components/WalletConnectProvider'
import {
  getPeerName,
  getSupportedChainIds,
  isBlockedBridge,
  isSafePassApp,
  isWarnedBridge,
} from '@/features/walletconnect/services/utils'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'
import useChains from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { trackEvent } from '@/services/analytics'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'

import { asError } from '@safe-global/utils/services/exceptions/utils'
import { Button, Checkbox, CircularProgress, Divider, FormControlLabel, Typography } from '@mui/material'
import type { WalletKitTypes } from '@reown/walletkit'
import type { ChangeEvent, ReactElement } from 'react'
import { type Dispatch, type SetStateAction, useCallback, useContext, useEffect, useMemo, useState } from 'react'
import { CompatibilityWarning } from './CompatibilityWarning'
import ProposalVerification from './ProposalVerification'
import css from './styles.module.css'
import { useSanctionedAddress } from '@/hooks/useSanctionedAddress'
import BlockedAddress from '@/components/common/BlockedAddress'

type ProposalFormProps = {
  proposal: WalletKitTypes.SessionProposal
  setProposal: Dispatch<SetStateAction<WalletKitTypes.SessionProposal | undefined>>
  onApprove: () => void
}

const WcProposalForm = ({ proposal, setProposal, onApprove }: ProposalFormProps): ReactElement => {
  const { walletConnect, setError, setIsLoading, isLoading } = useContext(WalletConnectContext)

  const { configs } = useChains()
  const { safeLoaded, safe } = useSafeInfo()
  const { chainId } = safe
  const [understandsRisk, setUnderstandsRisk] = useState(false)
  const { proposer } = proposal.params
  const { isScam, origin } = proposal.verifyContext.verified
  const url = proposer.metadata.url || origin

  const isSafePass = isSafePassApp(origin)
  const sanctionedAddress = useSanctionedAddress(isSafePass)

  const chainIds = useMemo(() => getSupportedChainIds(configs, proposal.params), [configs, proposal.params])
  const isUnsupportedChain = !chainIds.includes(chainId)

  const name = getPeerName(proposer) || 'Unknown dApp'
  const isHighRisk = proposal.verifyContext.verified.validation === 'INVALID' || isWarnedBridge(origin, name)
  const isBlocked = isScam || isBlockedBridge(origin)
  const disabled =
    !safeLoaded ||
    isUnsupportedChain ||
    isBlocked ||
    (isHighRisk && !understandsRisk) ||
    !!isLoading ||
    (Boolean(sanctionedAddress) && isSafePass)

  // On session reject
  const onReject = useCallback(async () => {
    if (!walletConnect || !proposal) return

    const label = proposal?.params.proposer.metadata.url
    trackEvent({ ...WALLETCONNECT_EVENTS.REJECT_CLICK, label })

    setIsLoading(WCLoadingState.REJECT)

    try {
      await walletConnect.rejectSession(proposal)
    } catch (e) {
      setIsLoading(undefined)
      setError(asError(e))
    }

    setIsLoading(undefined)
    setProposal(undefined)
  }, [walletConnect, proposal, setIsLoading, setProposal, setError])

  const onCheckboxClick = useCallback(
    (_: ChangeEvent, checked: boolean) => {
      setUnderstandsRisk(checked)

      if (checked) {
        trackEvent({
          ...WALLETCONNECT_EVENTS.ACCEPT_RISK,
          label: url,
        })
      }
    },
    [url],
  )

  // Track risk/scam/bridge warnings
  useEffect(() => {
    if (isHighRisk || isBlocked) {
      trackEvent({
        ...WALLETCONNECT_EVENTS.SHOW_RISK,
        label: url,
      })
    }
  }, [isHighRisk, isBlocked, url])

  // Track unsupported chain warnings
  useEffect(() => {
    if (isUnsupportedChain) {
      trackEvent({
        ...WALLETCONNECT_EVENTS.UNSUPPORTED_CHAIN,
        label: url,
      })
    }
  }, [url, isUnsupportedChain])

  return (
    <div className={css.container}>
      <Typography variant="body2" color="text.secondary">
        WalletConnect
      </Typography>

      {proposer.metadata.icons[0] && (
        <div className={css.icon}>
          <SafeAppIconCard src={proposer.metadata.icons[0]} width={32} height={32} alt={`${name || 'dApp'} logo`} />
        </div>
      )}

      <Typography mb={1}>
        <b>{name}</b> wants to connect
      </Typography>

      <Typography className={css.origin} mb={3}>
        {proposal.verifyContext.verified.origin}
      </Typography>

      <div className={css.info}>
        <ProposalVerification proposal={proposal} />

        <CompatibilityWarning proposal={proposal} chainIds={chainIds} />
      </div>

      {!isBlocked && isHighRisk && (
        <FormControlLabel
          className={css.checkbox}
          control={<Checkbox checked={understandsRisk} onChange={onCheckboxClick} />}
          label="I understand the risks associated with interacting with this dApp and would like to continue."
        />
      )}

      {isSafePass && sanctionedAddress && (
        <BlockedAddress address={sanctionedAddress} featureTitle="Safe{Pass}" onClose={onReject} />
      )}

      <Divider flexItem className={css.divider} />

      <div className={css.buttons}>
        <Button variant="danger" onClick={onReject} className={css.button} disabled={!!isLoading}>
          {isLoading === WCLoadingState.REJECT ? <CircularProgress size={20} /> : 'Reject'}
        </Button>

        <Button variant="contained" onClick={() => onApprove()} className={css.button} disabled={disabled}>
          {isLoading === WCLoadingState.APPROVE ? <CircularProgress size={20} /> : 'Approve'}
        </Button>
      </div>
    </div>
  )
}

export default WcProposalForm
</file>

<file path="src/features/walletconnect/components/WcProposalForm/ProposalVerification.tsx">
import type { WalletKitTypes } from '@reown/walletkit'
import { Alert, SvgIcon } from '@mui/material'
import AlertIcon from '@/public/images/notifications/alert.svg'
import type { ReactElement } from 'react'
import { getPeerName } from '@/features/walletconnect/services/utils'
import css from './styles.module.css'

const ProposalVerification = ({ proposal }: { proposal: WalletKitTypes.SessionProposal }): ReactElement | null => {
  const { isScam, validation } = proposal.verifyContext.verified

  if (validation === 'UNKNOWN' || validation === 'VALID') {
    return null
  }

  const appName = getPeerName(proposal.params.proposer)

  return (
    <Alert
      severity="error"
      sx={{ bgcolor: 'error.background' }}
      className={css.alert}
      icon={
        <SvgIcon
          component={AlertIcon}
          inheritViewBox
          color="error"
          sx={{
            '& path': {
              fill: 'error.main',
            },
          }}
        />
      }
    >
      {isScam
        ? `We prevent connecting to ${appName || 'this dApp'} as they are a known scam.`
        : `${
            appName || 'This dApp'
          } has a domain that does not match the sender of this request. Approving it may result in a loss of funds.`}
    </Alert>
  )
}
export default ProposalVerification
</file>

<file path="src/features/walletconnect/components/WcProposalForm/styles.module.css">
.container {
  display: flex;
  align-items: center;
  flex-direction: column;
  text-align: center;
}

.icon {
  padding: var(--space-2);
}

.chain {
  margin: 2px;
}

.origin {
  padding: var(--space-1) var(--space-2);
  background: var(--color-border-background);
  border-radius: 6px;
}

.info {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
}

.alert {
  width: 100%;
  text-align: left;
}

.checkbox {
  text-align: left;
  margin-top: var(--space-2);
}

.divider {
  margin: var(--space-3) calc(-1 * var(--space-4));
}

.buttons {
  width: 100%;
  display: flex;
  justify-content: space-between;
}

.button {
  padding: var(--space-1) var(--space-4);
  min-width: 130px;
}
</file>

<file path="src/features/walletconnect/components/WcProposalForm/useCompatibilityWarning.ts">
import { useMemo } from 'react'
import type { AlertColor } from '@mui/material'
import type { WalletKitTypes } from '@reown/walletkit'
import useChains from '@/hooks/useChains'
import useSafeInfo from '@/hooks/useSafeInfo'
import { capitalize } from '@safe-global/utils/utils/formatters'
import { getPeerName, isBlockedBridge, isWarnedBridge } from '@/features/walletconnect/services/utils'
import { BRAND_NAME } from '@/config/constants'

const NAME_FALLBACK = 'this dApp'
const NAME_PLACEHOLDER = '%%name%%'
const CHAIN_PLACEHOLDER = '%%chain%%'

const Warnings: Record<string, { severity: AlertColor; message: string }> = {
  BLOCKED_BRIDGE: {
    severity: 'error',
    message: `${NAME_PLACEHOLDER} is a bridge that is incompatible with ${BRAND_NAME} — the bridged funds will be lost. Consider using a different bridge.`,
  },
  WARNED_BRIDGE: {
    severity: 'warning',
    message: `While bridging via ${NAME_PLACEHOLDER}, please make sure that the desination address you send funds to matches the Safe address you have on the respective chain. Otherwise, the funds will be lost.`,
  },
  UNSUPPORTED_CHAIN: {
    severity: 'error',
    message: `${NAME_PLACEHOLDER} does not support this Safe Account's network (${CHAIN_PLACEHOLDER}). Please switch to a Safe Account on one of the supported networks below.`,
  },
  WRONG_CHAIN: {
    severity: 'info',
    message: `Please make sure that the dApp is connected to ${CHAIN_PLACEHOLDER}.`,
  },
}

export const _getWarning = (origin: string, name: string, isUnsupportedChain: boolean) => {
  if (isUnsupportedChain) {
    return Warnings.UNSUPPORTED_CHAIN
  }

  if (isBlockedBridge(origin)) {
    return Warnings.BLOCKED_BRIDGE
  }

  if (isWarnedBridge(origin, name)) {
    return Warnings.WARNED_BRIDGE
  }

  return Warnings.WRONG_CHAIN
}

export const useCompatibilityWarning = (
  proposal: WalletKitTypes.SessionProposal,
  isUnsupportedChain: boolean,
): (typeof Warnings)[string] => {
  const { configs } = useChains()
  const { safe } = useSafeInfo()

  return useMemo(() => {
    const name = getPeerName(proposal.params.proposer) || NAME_FALLBACK
    const { origin } = proposal.verifyContext.verified
    let { message, severity } = _getWarning(origin, name, isUnsupportedChain)

    if (message.includes(NAME_PLACEHOLDER)) {
      message = message.replaceAll(NAME_PLACEHOLDER, name)
      if (message.startsWith(NAME_FALLBACK)) {
        message = capitalize(message)
      }
    }

    if (message.includes(CHAIN_PLACEHOLDER)) {
      const chainName = configs.find((chain) => chain.chainId === safe.chainId)?.chainName ?? 'this network'
      message = message.replaceAll(CHAIN_PLACEHOLDER, chainName)
    }

    return {
      message,
      severity,
    }
  }, [configs, isUnsupportedChain, proposal.params, proposal.verifyContext.verified, safe.chainId])
}
</file>

<file path="src/features/walletconnect/components/WcSessionList/index.tsx">
import SafeAppIconCard from '@/components/safe-apps/SafeAppIconCard'
import { WCLoadingState } from '@/features/walletconnect/components/WalletConnectProvider'
import { getPeerName } from '@/features/walletconnect/services/utils'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'
import useSafeInfo from '@/hooks/useSafeInfo'
import { trackEvent } from '@/services/analytics'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { Button, CircularProgress, List, ListItem, ListItemAvatar, ListItemIcon, ListItemText } from '@mui/material'
import type { SessionTypes } from '@walletconnect/types'
import { useCallback, useContext } from 'react'
import css from './styles.module.css'
import WcNoSessions from './WcNoSessions'

type WcSesstionListProps = {
  sessions: SessionTypes.Struct[]
}

const WcSessionListItem = ({ session }: { session: SessionTypes.Struct }) => {
  const { walletConnect, setError, isLoading, setIsLoading } = useContext(WalletConnectContext)

  const MAX_NAME_LENGTH = 23
  const { safeLoaded } = useSafeInfo()
  let name = getPeerName(session.peer) || 'Unknown dApp'

  if (name.length > MAX_NAME_LENGTH + 1) {
    name = `${name.slice(0, MAX_NAME_LENGTH)}…`
  }

  const onDisconnect = useCallback(async () => {
    if (!walletConnect) return

    const label = session.peer.metadata.url
    trackEvent({ ...WALLETCONNECT_EVENTS.DISCONNECT_CLICK, label })

    setIsLoading(WCLoadingState.DISCONNECT)

    try {
      await walletConnect.disconnectSession(session)
    } catch (error) {
      setIsLoading(undefined)
      setError(asError(error))
    }

    setIsLoading(undefined)
  }, [walletConnect, session, setIsLoading, setError])

  return (
    <ListItem className={css.sessionListItem}>
      {session.peer.metadata.icons[0] && (
        <ListItemAvatar className={css.sessionListAvatar}>
          <SafeAppIconCard src={session.peer.metadata.icons[0]} alt="icon" width={20} height={20} />
        </ListItemAvatar>
      )}

      <ListItemText primary={name} primaryTypographyProps={{ color: safeLoaded ? undefined : 'text.secondary' }} />

      <ListItemIcon className={css.sessionListSecondaryAction}>
        <Button variant="danger" onClick={onDisconnect} className={css.button} disabled={!!isLoading}>
          {isLoading === WCLoadingState.DISCONNECT ? <CircularProgress size={20} /> : 'Disconnect'}
        </Button>
      </ListItemIcon>
    </ListItem>
  )
}

const WcSessionList = ({ sessions }: WcSesstionListProps) => {
  if (sessions.length === 0) {
    return <WcNoSessions />
  }

  return (
    <List className={css.sessionList}>
      {Object.values(sessions).map((session) => (
        <WcSessionListItem key={session.topic} session={session} />
      ))}
    </List>
  )
}

export default WcSessionList
</file>

<file path="src/features/walletconnect/components/WcSessionList/styles.module.css">
.sessionList {
  width: 100%;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
}

.sessionListItem {
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
  min-height: 56px;
}

.sessionListAvatar {
  display: flex;
  min-width: unset;
  padding-right: var(--space-1);
}

.sessionListSecondaryAction {
  /* InputAdornment */
  right: 14px;
}

.button {
  padding: var(--space-1) var(--space-2);
}
</file>

<file path="src/features/walletconnect/components/WcSessionList/WcNoSessions.tsx">
import ExternalLink from '@/components/common/ExternalLink'
import useSafeInfo from '@/hooks/useSafeInfo'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { Typography } from '@mui/material'
import { useCallback, useEffect } from 'react'

const SAMPLE_DAPPS = [
  { name: 'Zerion', icon: '/images/common/nft-zerion.svg', url: 'https://app.zerion.io/connect-wallet' },
  { name: 'Zapper', icon: '/images/common/nft-zapper.svg', url: 'https://zapper.xyz/' },
  { name: 'OpenSea', icon: '/images/common/nft-opensea.svg', url: 'https://opensea.io/' },
]

const LS_KEY = 'native_wc_dapps'

const WcSampleDapps = ({ onUnload }: { onUnload: () => void }) => {
  // Only show the sample dApps list once
  useEffect(() => {
    return onUnload
  }, [onUnload])

  return (
    <Typography
      variant="body2"
      display="flex"
      justifyContent="space-between"
      alignItems="center"
      mt={3}
      component="div"
    >
      {SAMPLE_DAPPS.map((item) => (
        <Typography variant="body2" key={item.url}>
          <ExternalLink href={item.url} noIcon px={1}>
            <img src={item.icon} alt={item.name} width={32} height={32} style={{ marginRight: '0.5em' }} />
            {item.name}
          </ExternalLink>
        </Typography>
      ))}
    </Typography>
  )
}

const WcNoSessions = () => {
  const { safeLoaded } = useSafeInfo()
  const [showDapps = true, setShowDapps] = useLocalStorage<boolean>(LS_KEY)

  const onUnload = useCallback(() => {
    setShowDapps(false)
  }, [setShowDapps])

  const sampleDapps = showDapps && safeLoaded && <WcSampleDapps onUnload={onUnload} />

  return (
    <>
      <Typography variant="body2" textAlign="center" color="text.secondary">
        No dApps are connected yet.{sampleDapps ? ' Try one of these:' : ''}
      </Typography>

      {sampleDapps}
    </>
  )
}

export default WcNoSessions
</file>

<file path="src/features/walletconnect/components/WcSessionManager/index.tsx">
import { WCLoadingState } from '@/features/walletconnect/components/WalletConnectProvider'
import useSafeInfo from '@/hooks/useSafeInfo'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { useCallback, useContext, useEffect, useState } from 'react'
import type { WalletKitTypes } from '@reown/walletkit'
import type { SessionTypes } from '@walletconnect/types'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'
import WcConnectionForm from '../WcConnectionForm'
import WcErrorMessage from '../WcErrorMessage'
import WcProposalForm from '../WcProposalForm'
import { trackEvent } from '@/services/analytics'
import { WALLETCONNECT_EVENTS } from '@/services/analytics/events/walletconnect'
import { splitError } from '@/features/walletconnect/services/utils'

type WcSessionManagerProps = {
  sessions: SessionTypes.Struct[]
  uri: string
}

// chainId -> origin -> boolean
type WcAutoApproveProps = Record<string, Record<string, boolean>>

const WC_AUTO_APPROVE_KEY = 'wcAutoApprove'

const WcSessionManager = ({ sessions, uri }: WcSessionManagerProps) => {
  const [autoApprove = {}, setAutoApprove] = useLocalStorage<WcAutoApproveProps>(WC_AUTO_APPROVE_KEY)
  const { walletConnect, error, setError, open, setOpen, setIsLoading } = useContext(WalletConnectContext)
  const { safe, safeAddress } = useSafeInfo()
  const { chainId } = safe
  const [proposal, setProposal] = useState<WalletKitTypes.SessionProposal>()

  // On session approve
  const onApprove = useCallback(
    async (proposalData?: WalletKitTypes.SessionProposal) => {
      const sessionProposal = proposalData || proposal

      if (!walletConnect || !chainId || !safeAddress || !sessionProposal) return

      const label = sessionProposal?.params.proposer.metadata.url
      trackEvent({ ...WALLETCONNECT_EVENTS.APPROVE_CLICK, label })

      setIsLoading(WCLoadingState.APPROVE)

      try {
        await walletConnect.approveSession(sessionProposal, chainId, safeAddress, {
          capabilities: JSON.stringify({
            [safeAddress]: {
              [`0x${Number(chainId).toString(16)}`]: {
                atomicBatch: {
                  supported: true,
                },
              },
            },
          }),
        })

        // Auto approve future sessions for non-malicious dApps
        if (
          sessionProposal.verifyContext.verified.validation !== 'INVALID' &&
          !sessionProposal.verifyContext.verified.isScam
        ) {
          setAutoApprove((prev) => ({
            ...prev,
            [chainId]: { ...prev?.[chainId], [sessionProposal.verifyContext.verified.origin]: true },
          }))
        }

        setOpen(false)
      } catch (e) {
        setIsLoading(undefined)
        setError(asError(e))
        return
      }

      trackEvent({ ...WALLETCONNECT_EVENTS.CONNECTED, label })
      setIsLoading(undefined)
      setProposal(undefined)
    },
    [proposal, walletConnect, chainId, safeAddress, setIsLoading, setOpen, setAutoApprove, setError],
  )

  // Reset error
  const onErrorReset = useCallback(() => {
    setError(null)
  }, [setError])

  // Subscribe to session proposals
  useEffect(() => {
    if (!walletConnect) return
    return walletConnect.onSessionPropose((proposalData) => {
      setError(null)

      if (autoApprove[chainId]?.[proposalData.verifyContext.verified.origin]) {
        onApprove(proposalData)
        return
      }

      setProposal(proposalData)
      setIsLoading(undefined)
    })
  }, [autoApprove, chainId, onApprove, setError, setIsLoading, walletConnect])

  // Track errors
  useEffect(() => {
    if (error) {
      // The summary of the error
      const label = splitError(error.message || '')[0]
      trackEvent({ ...WALLETCONNECT_EVENTS.SHOW_ERROR, label })
    }
  }, [error])

  // Nothing to show
  if (!open) return null

  // Error
  if (error) {
    return <WcErrorMessage error={error} onClose={onErrorReset} />
  }

  // Session proposal
  if (proposal) {
    return <WcProposalForm proposal={proposal} setProposal={setProposal} onApprove={onApprove} />
  }

  // Connection form (initial state)
  return <WcConnectionForm sessions={sessions} uri={uri} />
}

export default WcSessionManager
</file>

<file path="src/features/walletconnect/components/index.tsx">
import dynamic from 'next/dynamic'
import ExternalStore from '@safe-global/utils/services/ExternalStore'

const WalletConnectUi = dynamic(() => import('./WalletConnectUi'))

export default WalletConnectUi

// Open/close WC popup externally
export const wcPopupStore = new ExternalStore<boolean>(false)

export function openWalletConnect() {
  wcPopupStore.setStore(true)
}
</file>

<file path="src/features/walletconnect/hooks/useWalletConnectClipboardUri.ts">
import { useState, useEffect } from 'react'
import type { Dispatch, SetStateAction } from 'react'

import { getClipboard, isClipboardGranted } from '@/utils/clipboard'
import { isPairingUri } from '../services/utils'

// TODO: put this into session storage, otherwise it keeps pasting a stale pairing URI after refresh
const stalePairingUris: Array<string> = []

export const useWalletConnectClipboardUri = (): [string, Dispatch<SetStateAction<string>>] => {
  const [state, setState] = useState('')

  useEffect(() => {
    if (!navigator || !window) {
      return
    }

    const setClipboard = async () => {
      // Errors handled in the clipboard utils
      const isGranted = await isClipboardGranted()
      if (!isGranted) {
        return
      }

      const clipboard = await getClipboard()

      // Ensure valid pairing URIs
      if (isPairingUri(clipboard) && !stalePairingUris.includes(clipboard)) {
        stalePairingUris.push(clipboard)
        setState(clipboard)
      }
    }

    if (document.hasFocus()) {
      setClipboard()
    }

    // Update clipboard when returning to Safe
    window.addEventListener('focus', setClipboard)

    return () => {
      window.removeEventListener('focus', setClipboard)
    }
  }, [])

  return [state, setState]
}
</file>

<file path="src/features/walletconnect/hooks/useWalletConnectSearchParamUri.ts">
import { useRouter } from 'next/router'
import { useCallback } from 'react'

export const WC_URI_SEARCH_PARAM = 'wc'

export function useWalletConnectSearchParamUri(): [string | null, (wcUri: string | null) => void] {
  const router = useRouter()
  const wcUri = (router.query[WC_URI_SEARCH_PARAM] || '').toString() || null

  const setWcUri = useCallback(
    (wcUri: string | null) => {
      const newQuery = { ...router.query }

      if (!wcUri) {
        delete newQuery[WC_URI_SEARCH_PARAM]
      } else {
        newQuery[WC_URI_SEARCH_PARAM] = wcUri
      }

      router.replace({
        pathname: router.pathname,
        query: newQuery,
      })
    },
    [router],
  )

  return [wcUri, setWcUri]
}
</file>

<file path="src/features/walletconnect/hooks/useWalletConnectSessions.ts">
import { useContext, useEffect, useCallback, useState } from 'react'
import type { SessionTypes } from '@walletconnect/types'
import { WalletConnectContext } from '@/features/walletconnect/WalletConnectContext'

function useWalletConnectSessions(): SessionTypes.Struct[] {
  const { walletConnect } = useContext(WalletConnectContext)
  const [sessions, setSessions] = useState<SessionTypes.Struct[]>([])

  const updateSessions = useCallback(() => {
    if (!walletConnect) return
    setSessions(walletConnect.getActiveSessions())
  }, [walletConnect])

  // Initial sessions
  useEffect(updateSessions, [updateSessions])

  // On session add
  useEffect(() => {
    if (!walletConnect) return
    return walletConnect.onSessionAdd(updateSessions)
  }, [walletConnect, updateSessions])

  // On session delete
  useEffect(() => {
    if (!walletConnect) return
    return walletConnect.onSessionDelete(updateSessions)
  }, [walletConnect, updateSessions])

  return sessions
}

export default useWalletConnectSessions
</file>

<file path="src/features/walletconnect/hooks/useWcUri.ts">
import { useCallback } from 'react'
import { useWalletConnectSearchParamUri } from '@/features/walletconnect/hooks/useWalletConnectSearchParamUri'

const useWcUri = (): [string, () => void] => {
  const [searchParamWcUri, setSearchParamWcUri] = useWalletConnectSearchParamUri()
  const uri = searchParamWcUri || ''

  const clearUri = useCallback(() => {
    setSearchParamWcUri(null)
  }, [setSearchParamWcUri])

  return [uri, clearUri]
}

export default useWcUri
</file>

<file path="src/features/walletconnect/services/tracking.ts">
import { trackEvent } from '../../../services/analytics'
import { WALLETCONNECT_EVENTS } from '../../../services/analytics/events/walletconnect'

const trackedRequests = [
  'personal_sign',
  'eth_sign',
  'eth_signTypedData',
  'eth_signTypedData_v4',
  'eth_sendTransaction',
]

export const trackRequest = (peerUrl: string, method: string) => {
  if (trackedRequests.includes(method)) {
    trackEvent({ ...WALLETCONNECT_EVENTS.REQUEST, label: peerUrl })
  }
}
</file>

<file path="src/features/walletconnect/services/utils.ts">
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { ProposalTypes, SessionTypes } from '@walletconnect/types'
import { EIP155, BlockedBridges, WarnedBridges, WarnedBridgeNames } from '@/features/walletconnect/constants'

export const isPairingUri = (uri: string): boolean => {
  return uri.startsWith('wc:')
}

export const getEip155ChainId = (chainId: string): string => {
  return `${EIP155}:${chainId}`
}

export const stripEip155Prefix = (eip155Address: string): string => {
  return eip155Address.split(':').pop() ?? ''
}

export const getSupportedEip155ChainIds = (
  requiredNamespaces: ProposalTypes.RequiredNamespaces,
  optionalNamespaces: ProposalTypes.OptionalNamespaces,
): Array<string> => {
  const requiredChains = requiredNamespaces[EIP155]?.chains ?? []
  const optionalChains = optionalNamespaces[EIP155]?.chains ?? []

  return requiredChains.concat(optionalChains)
}

export const getSupportedChainIds = (
  configs: Array<ChainInfo>,
  { requiredNamespaces, optionalNamespaces }: ProposalTypes.Struct,
): Array<string> => {
  const supportedEip155ChainIds = getSupportedEip155ChainIds(requiredNamespaces, optionalNamespaces)

  return configs
    .filter((chain) => {
      const eipChainId = getEip155ChainId(chain.chainId)
      return supportedEip155ChainIds.includes(eipChainId)
    })
    .map((chain) => chain.chainId)
}

export const isUnsupportedChain = (session: SessionTypes.Struct, chainId: string) => {
  const supportedEip155ChainIds = getSupportedEip155ChainIds(session.requiredNamespaces, session.optionalNamespaces)

  const eipChainId = getEip155ChainId(chainId)
  return !supportedEip155ChainIds.includes(eipChainId)
}

// Bridge enforces the same address on destination chain
export const isBlockedBridge = (origin: string) => {
  return BlockedBridges.some((bridge) => origin.includes(bridge))
}

export const isSafePassApp = (origin: string) => {
  return origin.includes('community.safe.global')
}

// Bridge defaults to same address on destination chain but allows changing it
export const isWarnedBridge = (origin: string, name: string) => {
  return WarnedBridges.some((bridge) => origin.includes(bridge)) || WarnedBridgeNames.includes(name)
}

export const getPeerName = (peer: SessionTypes.Struct['peer'] | ProposalTypes.Struct['proposer']): string => {
  return peer.metadata?.name || peer.metadata?.url || ''
}

export const splitError = (message: string): string[] => {
  return message.split(/: (.+)/).slice(0, 2)
}
</file>

<file path="src/features/walletconnect/services/WalletConnectWallet.ts">
import { Core } from '@walletconnect/core'
import { WalletKit, type WalletKitTypes } from '@reown/walletkit'
import { buildApprovedNamespaces, getSdkError } from '@walletconnect/utils'
import type Web3WalletType from '@reown/walletkit'
import type { ProposalTypes, SessionTypes } from '@walletconnect/types'
import { type JsonRpcResponse } from '@walletconnect/jsonrpc-utils'
import uniq from 'lodash/uniq'

import { IS_PRODUCTION, LS_NAMESPACE, WC_PROJECT_ID } from '@/config/constants'
import { EIP155, SAFE_COMPATIBLE_EVENTS, SAFE_COMPATIBLE_METHODS, SAFE_WALLET_METADATA } from '../constants'
import { getEip155ChainId, stripEip155Prefix } from './utils'
import { invariant } from '@safe-global/utils/utils/helpers'

const SESSION_ADD_EVENT = 'session_add' as WalletKitTypes.Event // Workaround: WalletConnect doesn't emit session_add event
const SESSION_REJECT_EVENT = 'session_reject' as WalletKitTypes.Event // Workaround: WalletConnect doesn't emit session_reject event

function assertWeb3Wallet<T extends Web3WalletType | null>(web3Wallet: T): asserts web3Wallet {
  return invariant(web3Wallet, 'WalletConnect not initialized')
}

/**
 * An abstraction over the WalletConnect SDK to simplify event subscriptions
 * and add workarounds for dapps requesting wrong required chains.
 * Should be kept stateless exept for the web3Wallet instance.
 */
class WalletConnectWallet {
  private web3Wallet: Web3WalletType | null = null

  /**
   * Initialize WalletConnect wallet SDK
   */
  public async init() {
    if (this.web3Wallet) return

    const core = new Core({
      projectId: WC_PROJECT_ID,
      logger: IS_PRODUCTION ? undefined : 'debug',
      customStoragePrefix: LS_NAMESPACE,
    })

    const web3wallet = await WalletKit.init({
      core,
      metadata: SAFE_WALLET_METADATA,
    })

    this.web3Wallet = web3wallet
  }

  /**
   * Connect using a wc-URI
   */
  public async connect(uri: string) {
    assertWeb3Wallet(this.web3Wallet)
    return this.web3Wallet.core.pairing.pair({ uri })
  }

  public async chainChanged(topic: string, chainId: string) {
    const eipChainId = getEip155ChainId(chainId)

    return this.web3Wallet?.emitSessionEvent({
      topic,
      event: {
        name: 'chainChanged',
        data: Number(chainId),
      },
      chainId: eipChainId,
    })
  }

  public async accountsChanged(topic: string, chainId: string, address: string) {
    const eipChainId = getEip155ChainId(chainId)

    return this.web3Wallet?.emitSessionEvent({
      topic,
      event: {
        name: 'accountsChanged',
        data: [address],
      },
      chainId: eipChainId,
    })
  }

  private getNamespaces(proposal: WalletKitTypes.SessionProposal, currentChainId: string, safeAddress: string) {
    // As workaround, we pretend to support all the required chains plus the current Safe's chain
    const requiredChains = proposal.params.requiredNamespaces[EIP155]?.chains || []

    const supportedChainIds = [currentChainId].concat(requiredChains.map(stripEip155Prefix))

    const eip155ChainIds = supportedChainIds.map(getEip155ChainId)
    const eip155Accounts = eip155ChainIds.map((eip155ChainId) => `${eip155ChainId}:${safeAddress}`)

    // Don't include optionalNamespaces methods/events
    const methods = uniq((proposal.params.requiredNamespaces[EIP155]?.methods || []).concat(SAFE_COMPATIBLE_METHODS))
    const events = uniq((proposal.params.requiredNamespaces[EIP155]?.events || []).concat(SAFE_COMPATIBLE_EVENTS))

    return buildApprovedNamespaces({
      proposal: proposal.params,
      supportedNamespaces: {
        [EIP155]: {
          chains: eip155ChainIds,
          accounts: eip155Accounts,
          methods,
          events,
        },
      },
    })
  }

  public async approveSession(
    proposal: WalletKitTypes.SessionProposal,
    currentChainId: string,
    safeAddress: string,
    sessionProperties?: ProposalTypes.SessionProperties,
  ) {
    assertWeb3Wallet(this.web3Wallet)

    const namespaces = this.getNamespaces(proposal, currentChainId, safeAddress)

    // Approve the session proposal
    const session = await this.web3Wallet.approveSession({
      id: proposal.id,
      namespaces,
      sessionProperties,
    })

    await this.chainChanged(session.topic, currentChainId)

    // Workaround: WalletConnect doesn't have a session_add event
    // and we want to update our state inside the useWalletConnectSessions hook
    this.web3Wallet?.events.emit(SESSION_ADD_EVENT, session)

    // Return updated session as it may have changed
    return this.getActiveSessions().find(({ topic }) => topic === session.topic) ?? session
  }

  private async updateSession(session: SessionTypes.Struct, chainId: string, safeAddress: string) {
    assertWeb3Wallet(this.web3Wallet)

    const currentEip155ChainIds = session.namespaces[EIP155]?.chains || []
    const currentEip155Accounts = session.namespaces[EIP155]?.accounts || []

    const newEip155ChainId = getEip155ChainId(chainId)
    const newEip155Account = `${newEip155ChainId}:${safeAddress}`

    const isUnsupportedChain = !currentEip155ChainIds.includes(newEip155ChainId)
    const isNewSessionSafe = !currentEip155Accounts.includes(newEip155Account)

    // Switching to unsupported chain
    if (isUnsupportedChain) {
      return this.disconnectSession(session)
    }

    // Add new Safe to the session namespace
    if (isNewSessionSafe) {
      const namespaces: SessionTypes.Namespaces = {
        [EIP155]: {
          ...session.namespaces[EIP155],
          chains: currentEip155ChainIds,
          accounts: [newEip155Account, ...currentEip155Accounts],
        },
      }

      await this.web3Wallet.updateSession({
        topic: session.topic,
        namespaces,
      })
    }

    // Switch to the new chain
    await this.chainChanged(session.topic, chainId)

    // Switch to the new Safe
    await this.accountsChanged(session.topic, chainId, safeAddress)
  }

  public async updateSessions(chainId: string, safeAddress: string) {
    // If updating sessions disconnects multiple due to an unsupported chain,
    // we need to wait for the previous session to disconnect before the next
    for await (const session of this.getActiveSessions()) {
      await this.updateSession(session, chainId, safeAddress)
    }
  }

  public async rejectSession(proposal: WalletKitTypes.SessionProposal) {
    assertWeb3Wallet(this.web3Wallet)

    await this.web3Wallet.rejectSession({
      id: proposal.id,
      reason: getSdkError('USER_REJECTED'),
    })

    // Workaround: WalletConnect doesn't have a session_reject event
    this.web3Wallet?.events.emit(SESSION_REJECT_EVENT, proposal)
  }

  /**
   * Subscribe to session proposals
   */
  public onSessionPropose(handler: (e: WalletKitTypes.SessionProposal) => void) {
    // Subscribe to the session proposal event
    this.web3Wallet?.on('session_proposal', handler)

    // Return the unsubscribe function
    return () => {
      this.web3Wallet?.off('session_proposal', handler)
    }
  }

  /**
   * Subscribe to session proposal rejections
   */
  public onSessionReject(handler: (e: WalletKitTypes.SessionProposal) => void) {
    // @ts-expect-error - custom event payload
    this.web3Wallet?.on(SESSION_REJECT_EVENT, handler)

    return () => {
      // @ts-expect-error
      this.web3Wallet?.off(SESSION_REJECT_EVENT, handler)
    }
  }

  /**
   * Subscribe to session add
   */
  public onSessionAdd = (handler: (e: SessionTypes.Struct) => void) => {
    // @ts-expect-error - custom event payload
    this.web3Wallet?.on(SESSION_ADD_EVENT, handler)

    return () => {
      // @ts-expect-error
      this.web3Wallet?.off(SESSION_ADD_EVENT, handler)
    }
  }

  /**
   * Subscribe to session delete
   */
  public onSessionDelete = (handler: (session: SessionTypes.Struct) => void) => {
    // @ts-expect-error - custom event payload
    this.web3Wallet?.on('session_delete', handler)

    return () => {
      // @ts-expect-error
      this.web3Wallet?.off('session_delete', handler)
    }
  }

  /**
   * Disconnect a session
   */
  public async disconnectSession(session: SessionTypes.Struct) {
    assertWeb3Wallet(this.web3Wallet)

    await this.web3Wallet.disconnectSession({
      topic: session.topic,
      reason: getSdkError('USER_DISCONNECTED'),
    })

    // Workaround: WalletConnect doesn't emit session_delete event when disconnecting from the wallet side
    // and we want to update the state inside the useWalletConnectSessions hook
    this.web3Wallet.events.emit('session_delete', session)
  }

  /**
   * Get active sessions
   */
  public getActiveSessions(): SessionTypes.Struct[] {
    const sessionsMap = this.web3Wallet?.getActiveSessions() || {}
    return Object.values(sessionsMap)
  }

  /**
   * Subscribe to requests
   */
  public onRequest(handler: (event: WalletKitTypes.SessionRequest) => void) {
    this.web3Wallet?.on('session_request', handler)

    return () => {
      this.web3Wallet?.off('session_request', handler)
    }
  }

  /**
   * Send a response to a request
   */
  public async sendSessionResponse(topic: string, response: JsonRpcResponse<unknown>) {
    assertWeb3Wallet(this.web3Wallet)

    return await this.web3Wallet.respondSessionRequest({ topic, response })
  }
}

export default WalletConnectWallet
</file>

<file path="src/features/walletconnect/constants.ts">
import { BRAND_NAME } from '@/config/constants'

export const SAFE_COMPATIBLE_METHODS = [
  'eth_accounts',
  'net_version',
  'eth_chainId',
  'personal_sign',
  'eth_sign',
  'eth_signTypedData',
  'eth_signTypedData_v4',
  'eth_sendTransaction',
  'eth_blockNumber',
  'eth_getBalance',
  'eth_getCode',
  'eth_getTransactionCount',
  'eth_getStorageAt',
  'eth_getBlockByNumber',
  'eth_getBlockByHash',
  'eth_getTransactionByHash',
  'eth_getTransactionReceipt',
  'eth_estimateGas',
  'eth_call',
  'eth_getLogs',
  'eth_gasPrice',
  'wallet_switchEthereumChain',
  'wallet_sendCalls',
  'wallet_getCallsStatus',
  'wallet_showCallsStatus',
  'wallet_getCapabilities',
  'safe_setSettings',
]

export const SAFE_COMPATIBLE_EVENTS = ['chainChanged', 'accountsChanged']

export const SAFE_WALLET_METADATA = {
  name: BRAND_NAME,
  url: 'https://app.safe.global',
  description: 'Smart contract wallet for Ethereum',
  icons: ['https://app.safe.global/images/logo-round.svg'],
}

export const EIP155 = 'eip155' as const

// Bridges enforcing same address on destination chains
export const BlockedBridges = [
  'app.chainport.io',
  'cbridge.celer.network',
  'www.orbiter.finance',
  'zksync-era.l2scan.co',
  'www.portalbridge.com',
  'wallet.polygon.technology',

  // Unsupported chain bridges
  'bridge.zora.energy',
  'bridge.mantle.xyz',
  'bridge.metis.io',
  'pacific-bridge.manta.network',
  'tokenbridge.rsk.co',
  'canto.io',
  'gateway.boba.network',
  'bttc.bittorrent.com',
  'iotube.org',
  'bridge.telos.net',
  'ultronswap.com',
]

// Bridges that initially select the same address on the destination chain but allow changing it
export const WarnedBridges = [
  'core.app',
  'across.to', // doesn't send their URL in the session proposal
  'app.allbridge.io',
  'app.rhino.fi',
  'bridge.arbitrum.io',
  'bridge.base.org',
  'bridge.linea.build',
  'core.allbridge.io',
  'bungee.exchange',
  'www.carrier.so',
  'app.chainport.io',
  'bridge.gnosischain.com',
  'app.hop.exchange', // doesn't send their URL in the session proposal
  'app.interport.fi',
  'jumper.exchange',
  'www.layerswap.io',
  'meson.fi',
  'satellite.money',
  'stargate.finance',
  'app.squidrouter.com',
  'app.symbiosis.finance',
  'www.synapseprotocol.com',
  'app.thevoyager.io',
  'portal.txsync.io',
  'bridge.wanchain.org',
  'app.xy.finance',
  'scroll.io',
]

export const WarnedBridgeNames = ['Across Bridge', 'Hop']
</file>

<file path="src/features/walletconnect/WalletConnectContext.tsx">
import type { WCLoadingState } from '@/features/walletconnect/components/WalletConnectProvider'
import { createContext, type Dispatch, type SetStateAction } from 'react'
import type WalletConnectWallet from '@/features/walletconnect/services/WalletConnectWallet'

type WalletConnectContextType = {
  walletConnect: WalletConnectWallet | null
  error: Error | null
  setError: Dispatch<SetStateAction<Error | null>>
  open: boolean
  setOpen: (open: boolean) => void
  isLoading: WCLoadingState | undefined
  setIsLoading: Dispatch<SetStateAction<WCLoadingState | undefined>>
}

export const WalletConnectContext = createContext<WalletConnectContextType>({
  walletConnect: null,
  error: null,
  setError: () => {},
  open: false,
  setOpen: () => {},
  isLoading: undefined,
  setIsLoading: () => {},
})
</file>

<file path="src/hooks/Beamer/useBeamer.ts">
import { useEffect } from 'react'

import { useAppSelector } from '@/store'
import { CookieAndTermType, hasConsentFor } from '@/store/cookiesAndTermsSlice'
import { loadBeamer, unloadBeamer, updateBeamer } from '@/services/beamer'
import { useCurrentChain } from '@/hooks/useChains'

const useBeamer = () => {
  const isBeamerEnabled = useAppSelector((state) => hasConsentFor(state, CookieAndTermType.UPDATES))
  const chain = useCurrentChain()

  useEffect(() => {
    if (!chain?.shortName) {
      return
    }

    if (isBeamerEnabled) {
      loadBeamer(chain.shortName)
    } else {
      unloadBeamer()
    }
  }, [isBeamerEnabled, chain?.shortName])

  useEffect(() => {
    if (isBeamerEnabled && chain?.shortName) {
      updateBeamer(chain.shortName)
    }
  }, [isBeamerEnabled, chain?.shortName])
}

export default useBeamer
</file>

<file path="src/hooks/coreSDK/safeCoreSDK.ts">
import chains from '@safe-global/utils/config/chains'
import { getSafeL2SingletonDeployments, getSafeSingletonDeployments } from '@safe-global/safe-deployments'
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import { Gnosis_safe__factory } from '@safe-global/utils/types/contracts'
import Safe from '@safe-global/protocol-kit'
import { isValidMasterCopy } from '@safe-global/utils/services/contracts/safeContracts'
import { isPredictedSafeProps, isReplayedSafeProps } from '@/features/counterfactual/utils'
import { isLegacyVersion } from '@safe-global/utils/services/contracts/utils'
import { isInDeployments } from '@safe-global/utils/hooks/coreSDK/utils'
import type { SafeCoreSDKProps } from '@safe-global/utils/hooks/coreSDK/types'

// Safe Core SDK
export const initSafeSDK = async ({
  provider,
  chainId,
  address,
  version,
  implementationVersionState,
  implementation,
  undeployedSafe,
}: SafeCoreSDKProps): Promise<Safe | undefined> => {
  const providerNetwork = (await provider.getNetwork()).chainId
  if (providerNetwork !== BigInt(chainId)) return

  const safeVersion = version ?? (await Gnosis_safe__factory.connect(address, provider).VERSION())
  let isL1SafeSingleton = chainId === chains.eth

  // If it is an official deployment we should still initiate the safeSDK
  if (!isValidMasterCopy(implementationVersionState)) {
    const masterCopy = implementation

    const safeL1Deployment = getSafeSingletonDeployments({ network: chainId, version: safeVersion })
    const safeL2Deployment = getSafeL2SingletonDeployments({ network: chainId, version: safeVersion })

    isL1SafeSingleton = isInDeployments(masterCopy, safeL1Deployment?.networkAddresses[chainId])
    const isL2SafeMasterCopy = isInDeployments(masterCopy, safeL2Deployment?.networkAddresses[chainId])

    // Unknown deployment, which we do not want to support
    if (!isL1SafeSingleton && !isL2SafeMasterCopy) {
      return Promise.resolve(undefined)
    }
  }
  // Legacy Safe contracts
  if (isLegacyVersion(safeVersion)) {
    isL1SafeSingleton = true
  }

  if (undeployedSafe) {
    if (isPredictedSafeProps(undeployedSafe.props) || isReplayedSafeProps(undeployedSafe.props)) {
      return Safe.init({
        provider: provider._getConnection().url,
        isL1SafeSingleton,
        predictedSafe: undeployedSafe.props,
      })
    }
    // We cannot initialize a Core SDK for replayed Safes yet.
    return
  }
  return Safe.init({
    provider: provider._getConnection().url,
    safeAddress: address,
    isL1SafeSingleton,
  })
}

export const {
  getStore: getSafeSDK,
  setStore: setSafeSDK,
  useStore: useSafeSDK,
} = new ExternalStore<Safe | undefined>()
</file>

<file path="src/hooks/coreSDK/useInitSafeCoreSDK.ts">
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import { useEffect } from 'react'
import { useRouter } from 'next/router'
import useSafeInfo from '@/hooks/useSafeInfo'
import { initSafeSDK, setSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { trackError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { useAppDispatch, useAppSelector } from '@/store'
import { showNotification } from '@/store/notificationsSlice'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { parsePrefixedAddress, sameAddress } from '@safe-global/utils/utils/addresses'
import { asError } from '@safe-global/utils/services/exceptions/utils'

export const useInitSafeCoreSDK = () => {
  const { safe, safeLoaded } = useSafeInfo()
  const dispatch = useAppDispatch()
  const web3ReadOnly = useWeb3ReadOnly()

  const { query } = useRouter()
  const prefixedAddress = Array.isArray(query.safe) ? query.safe[0] : query.safe
  const { address } = parsePrefixedAddress(prefixedAddress || '')
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, safe.chainId, address))

  useEffect(() => {
    if (!safeLoaded || !web3ReadOnly || !sameAddress(address, safe.address.value)) {
      // If we don't reset the SDK, a previous Safe could remain in the store
      setSafeSDK(undefined)
      return
    }

    // A read-only instance of the SDK is sufficient because we connect the signer to it when needed
    initSafeSDK({
      provider: web3ReadOnly,
      chainId: safe.chainId,
      address: safe.address.value,
      version: safe.version,
      implementationVersionState: safe.implementationVersionState,
      implementation: safe.implementation.value,
      undeployedSafe,
    })
      .then(setSafeSDK)
      .catch((_e) => {
        const e = asError(_e)
        dispatch(
          showNotification({
            message: 'Error connecting to the blockchain. Please try reloading the page.',
            groupKey: 'core-sdk-init-error',
            variant: 'error',
            detailedMessage: e.message,
          }),
        )
        trackError(ErrorCodes._105, e.message)
      })
  }, [
    address,
    dispatch,
    safe.address.value,
    safe.chainId,
    safe.implementation.value,
    safe.implementationVersionState,
    safe.version,
    safeLoaded,
    web3ReadOnly,
    undeployedSafe,
  ])
}
</file>

<file path="src/hooks/loadables/useLoadBalances.ts">
import { useMemo } from 'react'
import { type Balances, useBalancesGetBalancesV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/balances'
import { useAppSelector } from '@/store'
import { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { selectCurrency, selectSettings, TOKEN_LISTS } from '@/store/settingsSlice'
import { useCurrentChain } from '../useChains'
import useSafeInfo from '../useSafeInfo'
import { POLLING_INTERVAL } from '@/config/constants'
import { useCounterfactualBalances } from '@/features/counterfactual/useCounterfactualBalances'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

export const useTokenListSetting = (): boolean | undefined => {
  const chain = useCurrentChain()
  const settings = useAppSelector(selectSettings)

  const isTrustedTokenList = useMemo(() => {
    if (settings.tokenList === TOKEN_LISTS.ALL) return false
    return chain ? hasFeature(chain, FEATURES.DEFAULT_TOKENLIST) : undefined
  }, [chain, settings.tokenList])

  return isTrustedTokenList
}

const useLoadBalances = () => {
  const currency = useAppSelector(selectCurrency)
  const isTrustedTokenList = useTokenListSetting()
  const { safe, safeAddress } = useSafeInfo()
  const isReady = safeAddress && safe.deployed && isTrustedTokenList !== undefined
  const isCounterfactual = !safe.deployed

  let {
    data: balances,
    isLoading: loading,
    error: errorStr,
  } = useBalancesGetBalancesV1Query(
    {
      chainId: safe.chainId,
      safeAddress,
      fiatCode: currency,
      trusted: isTrustedTokenList,
    },
    {
      skip: !isReady,
      pollingInterval: POLLING_INTERVAL,
      skipPollingIfUnfocused: true,
      refetchOnFocus: true,
    },
  )

  // Counterfactual balances
  const [cfData, cfError, cfLoading] = useCounterfactualBalances(safe)

  let error = useMemo(() => (errorStr ? new Error(errorStr.toString()) : undefined), [errorStr])

  if (isCounterfactual) {
    balances = cfData as unknown as Balances
    loading = cfLoading
    error = cfError
  }

  return useMemo(() => [balances, error, loading], [balances, error, loading]) as AsyncResult<Balances>
}

export default useLoadBalances
</file>

<file path="src/hooks/loadables/useLoadChains.ts">
import { useEffect } from 'react'
import { useChainsGetChainsV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/chains'
import { Errors, logError } from '@/services/exceptions'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'

const MAX_CHAINS = 40

export const useLoadChains = () => {
  const { data, isLoading, error } = useChainsGetChainsV1Query({ cursor: `limit=${MAX_CHAINS}` })

  // Log errors
  useEffect(() => {
    if (error) {
      logError(Errors._620, error.toString())
    }
  }, [error])

  return [data?.results, error, isLoading] as AsyncResult<ChainInfo[]>
}

export default useLoadChains
</file>

<file path="src/hooks/loadables/useLoadSafeInfo.ts">
import { selectUndeployedSafe } from '@/features/counterfactual/store/undeployedSafesSlice'
import { getUndeployedSafeInfo } from '@/features/counterfactual/utils'
import { useAppSelector } from '@/store'
import { useEffect, useMemo } from 'react'
import { getSafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { useChainId } from '../useChainId'
import useIntervalCounter from '../useIntervalCounter'
import useSafeInfo from '../useSafeInfo'
import { Errors, logError } from '@/services/exceptions'
import { POLLING_INTERVAL } from '@/config/constants'
import { useCurrentChain } from '../useChains'
import { useSafeAddressFromUrl } from '../useSafeAddressFromUrl'

export const useLoadSafeInfo = (): AsyncResult<SafeState> => {
  const address = useSafeAddressFromUrl()
  const chainId = useChainId()
  const chain = useCurrentChain()
  const [pollCount, resetPolling] = useIntervalCounter(POLLING_INTERVAL)
  const { safe } = useSafeInfo()
  const isStoredSafeValid = safe.chainId === chainId && safe.address.value === address
  const cache = isStoredSafeValid ? safe : undefined
  const undeployedSafe = useAppSelector((state) => selectUndeployedSafe(state, chainId, address))

  const [undeployedData, undeployedError] = useAsync<SafeState | undefined>(async () => {
    if (!undeployedSafe || !chain) return
    /**
     * This is the one place where we can't check for `safe.deployed` as we want to update that value
     * when the local storage is cleared, so we have to check undeployedSafe
     */
    return getUndeployedSafeInfo(undeployedSafe, address, chain)
  }, [undeployedSafe, address, chain])

  const [cgwData, cgwError, cgwLoading] = useAsync<SafeState | undefined>(async () => {
    if (!chainId || !address || pollCount === undefined) return
    const safeInfo = await getSafeInfo(chainId, address)
    return { ...safeInfo, deployed: true }
  }, [chainId, address, pollCount])

  // Reset the counter when safe address/chainId changes
  useEffect(() => {
    resetPolling()
  }, [resetPolling, address, chainId])

  // Log errors
  useEffect(() => {
    if (cgwError) {
      logError(Errors._600, cgwError.message)
    }
  }, [cgwError])

  // Return stored SafeInfo between polls
  const safeData = cgwData ?? undeployedData ?? cache
  const error = cgwError ?? (undeployedSafe ? undeployedError : undefined)
  const loading = cgwLoading

  return useMemo(() => [safeData, error, loading], [safeData, error, loading])
}

export default useLoadSafeInfo
</file>

<file path="src/hooks/loadables/useLoadSafeMessages.ts">
import type { MessagePage } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { useEffect } from 'react'
import { getSafeMessages } from '@safe-global/safe-gateway-typescript-sdk'

import useAsync from '@safe-global/utils/hooks/useAsync'
import { logError, Errors } from '@/services/exceptions'
import useSafeInfo from '@/hooks/useSafeInfo'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'

export const useLoadSafeMessages = (): AsyncResult<MessagePage> => {
  const { safe, safeAddress, safeLoaded } = useSafeInfo()

  const [data, error, loading] = useAsync<MessagePage>(
    () => {
      if (!safeLoaded) return
      if (!safe.deployed) return Promise.resolve({ results: [] })

      return getSafeMessages(safe.chainId, safeAddress) as Promise<MessagePage>
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [safeLoaded, safe.chainId, safeAddress, safe.messagesTag, safe.deployed],
    false,
  )

  useEffect(() => {
    if (error) {
      logError(Errors._608, error.message)
    }
  }, [error])

  return [data, error, loading]
}

export default useLoadSafeMessages
</file>

<file path="src/hooks/loadables/useLoadSpendingLimits.ts">
import { useEffect } from 'react'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '../useSafeInfo'
import { Errors, logError } from '@/services/exceptions'
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import useChainId from '@/hooks/useChainId'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import type { JsonRpcProvider } from 'ethers'
import { getSpendingLimitContract } from '@/services/contracts/spendingLimitContracts'
import type { TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type AddressInfo } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { type AllowanceModule } from '@safe-global/utils/types/contracts'
import { getERC20TokenInfoOnChain } from '@/utils/tokens'

import { sameString } from '@safe-global/protocol-kit/dist/src/utils'
import { useAppSelector } from '@/store'
import { selectTokens } from '@/store/balancesSlice'
import isEqual from 'lodash/isEqual'

const DEFAULT_TOKEN_INFO = {
  decimals: 18,
  symbol: '',
}

const discardZeroAllowance = (spendingLimit: SpendingLimitState): boolean =>
  !(sameString(spendingLimit.amount, '0') && sameString(spendingLimit.resetTimeMin, '0'))

const getTokenInfoFromBalances = (tokenInfoFromBalances: TokenInfo[], address: string): TokenInfo | undefined =>
  tokenInfoFromBalances.find((token) => token.address === address)

export const getTokenAllowanceForDelegate = async (
  contract: AllowanceModule,
  safeAddress: string,
  delegate: string,
  token: string,
  tokenInfoFromBalances: TokenInfo[],
): Promise<SpendingLimitState> => {
  const tokenAllowance = await contract.getTokenAllowance(safeAddress, delegate, token)
  const [amount, spent, resetTimeMin, lastResetMin, nonce] = tokenAllowance
  return {
    beneficiary: delegate,
    token: getTokenInfoFromBalances(tokenInfoFromBalances, token) ||
      (await getERC20TokenInfoOnChain(token)) || { ...DEFAULT_TOKEN_INFO, address: token },
    amount: amount.toString(),
    spent: spent.toString(),
    resetTimeMin: resetTimeMin.toString(),
    lastResetMin: lastResetMin.toString(),
    nonce: nonce.toString(),
  }
}

export const getTokensForDelegate = async (
  contract: AllowanceModule,
  safeAddress: string,
  delegate: string,
  tokenInfoFromBalances: TokenInfo[],
) => {
  const tokens = await contract.getTokens(safeAddress, delegate)

  return Promise.all(
    tokens.map(async (token) =>
      getTokenAllowanceForDelegate(contract, safeAddress, delegate, token, tokenInfoFromBalances),
    ),
  )
}

export const getSpendingLimits = async (
  provider: JsonRpcProvider,
  safeModules: AddressInfo[],
  safeAddress: string,
  chainId: string,
  tokenInfoFromBalances: TokenInfo[],
): Promise<SpendingLimitState[] | undefined> => {
  let contract: ReturnType<typeof getSpendingLimitContract>
  try {
    contract = getSpendingLimitContract(chainId, safeModules, provider)
  } catch {
    return
  }
  const delegates = await contract.getDelegates(safeAddress, 0, 100)

  const spendingLimits = await Promise.all(
    delegates.results.map(async (delegate) =>
      getTokensForDelegate(contract, safeAddress, delegate, tokenInfoFromBalances),
    ),
  )
  return spendingLimits.flat().filter(discardZeroAllowance)
}

export const useLoadSpendingLimits = (): AsyncResult<SpendingLimitState[]> => {
  const { safeAddress, safe, safeLoaded } = useSafeInfo()
  const chainId = useChainId()
  const provider = useWeb3ReadOnly()
  const tokenInfoFromBalances = useAppSelector(selectTokens, isEqual)

  const [data, error, loading] = useAsync<SpendingLimitState[] | undefined>(
    () => {
      if (!provider || !safeLoaded || !safe.modules || tokenInfoFromBalances.length === 0) return

      return getSpendingLimits(provider, safe.modules, safeAddress, chainId, tokenInfoFromBalances)
    },
    // Need to check length of modules array to prevent new request every time Safe info polls
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [provider, safeLoaded, safe.modules?.length, tokenInfoFromBalances, safeAddress, chainId, safe.txHistoryTag],
    false,
  )

  useEffect(() => {
    if (error) {
      logError(Errors._609, error.message)
    }
  }, [error])

  return [data, error, loading]
}

export default useLoadSpendingLimits
</file>

<file path="src/hooks/loadables/useLoadTxHistory.ts">
import { useEffect } from 'react'
import { type TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { Errors, logError } from '@/services/exceptions'
import useSafeInfo from '../useSafeInfo'
import { getTxHistory } from '@/services/transactions'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'
import { useHasFeature } from '../useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

export const useLoadTxHistory = (): AsyncResult<TransactionListPage> => {
  const { safe, safeAddress, safeLoaded } = useSafeInfo()
  const { chainId, txHistoryTag } = safe
  const { hideSuspiciousTransactions } = useAppSelector(selectSettings)
  const hasDefaultTokenlist = useHasFeature(FEATURES.DEFAULT_TOKENLIST)
  const hideUntrustedTxs = (hasDefaultTokenlist && hideSuspiciousTransactions) ?? true
  const hideImitationTxs = hideSuspiciousTransactions ?? true

  // Re-fetch when chainId, address, hideSuspiciousTransactions, or txHistoryTag changes
  const [data, error, loading] = useAsync<TransactionListPage>(
    () => {
      if (!safeLoaded) return
      if (!safe.deployed) return Promise.resolve({ results: [] })

      return getTxHistory(chainId, safeAddress, hideUntrustedTxs, hideImitationTxs)
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [safeLoaded, chainId, safeAddress, hideSuspiciousTransactions, hasDefaultTokenlist, txHistoryTag, safe.deployed],
    false,
  )

  // Log errors
  useEffect(() => {
    if (!error) return
    logError(Errors._602, error.message)
  }, [error])

  return [data, error, loading]
}

export default useLoadTxHistory
</file>

<file path="src/hooks/loadables/useLoadTxQueue.ts">
import { useEffect, useState } from 'react'
import { getTransactionQueue, type TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '../useSafeInfo'
import { Errors, logError } from '@/services/exceptions'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'

export const useLoadTxQueue = (): AsyncResult<TransactionListPage> => {
  const { safe, safeAddress, safeLoaded } = useSafeInfo()
  const { chainId, txQueuedTag, txHistoryTag } = safe
  const [updatedTxId, setUpdatedTxId] = useState<string>('')
  // N.B. we reload when txQueuedTag/txHistoryTag/updatedTxId changes as txQueuedTag alone is not enough
  const reloadTag = (txQueuedTag ?? '') + (txHistoryTag ?? '') + updatedTxId

  // Re-fetch when chainId/address, or txQueueTag change
  const [data, error, loading] = useAsync<TransactionListPage>(
    () => {
      if (!safeLoaded) return
      if (!safe.deployed) return Promise.resolve({ results: [] })

      return getTransactionQueue(chainId, safeAddress)
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [safeLoaded, chainId, safeAddress, reloadTag, safe.deployed],
    false,
  )

  // Track proposed and deleted txs so that we can reload the queue
  useEffect(() => {
    const unsubscribeProposed = txSubscribe(TxEvent.PROPOSED, ({ txId }) => {
      setUpdatedTxId(txId)
    })
    const unsubscribeDeleted = txSubscribe(TxEvent.DELETED, ({ safeTxHash }) => {
      setUpdatedTxId(safeTxHash)
    })
    return () => {
      unsubscribeProposed()
      unsubscribeDeleted()
    }
  }, [])

  // Log errors
  useEffect(() => {
    if (!error) return
    logError(Errors._603, error.message)
  }, [error])

  return [data, error, loading]
}

export default useLoadTxQueue
</file>

<file path="src/hooks/messages/useDecodedSafeMessage.ts">
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { getDecodedMessage } from '@/components/safe-apps/utils'
import { generateSafeMessageMessage, generateSafeMessageHash } from '@safe-global/utils/utils/safe-messages'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { useMemo } from 'react'

/**
 * Returns the decoded message, the hash of the `message` and the hash of the `safeMessage`.
 * The `safeMessageMessage` is the value inside the SafeMessage and the `safeMessageHash` gets signed if the connected wallet does not support `eth_signTypedData`.
 *
 * @param message message as string, UTF-8 encoded hex string or EIP-712 Typed Data
 * @param safe SafeInfo of the opened Safe
 * @returns `{
 *   decodedMessage,
 *   safeMessageMessage,
 *   safeMessageHash
 * }`
 */
const useDecodedSafeMessage = (
  message: string | TypedData,
  safe: SafeState,
): { decodedMessage: string | TypedData; safeMessageMessage: string; safeMessageHash: string } => {
  // Decode message if UTF-8 encoded
  const decodedMessage = useMemo(() => {
    return typeof message === 'string' ? getDecodedMessage(message) : message
  }, [message])

  // Get `SafeMessage` message
  const safeMessageMessage = useMemo(() => {
    return generateSafeMessageMessage(decodedMessage)
  }, [decodedMessage])

  // Get `SafeMessage` hash
  const safeMessageHash = useMemo(() => {
    return generateSafeMessageHash(safe, decodedMessage)
  }, [safe, decodedMessage])

  return {
    decodedMessage,
    safeMessageMessage,
    safeMessageHash,
  }
}

export default useDecodedSafeMessage
</file>

<file path="src/hooks/messages/useIsSafeMessagePending.ts">
import { useAppSelector } from '@/store'
import { selectPendingSafeMessageByHash } from '@/store/pendingSafeMessagesSlice'

const useIsSafeMessagePending = (messageHash: string): boolean => {
  return useAppSelector((state) => selectPendingSafeMessageByHash(state, messageHash))
}

export default useIsSafeMessagePending
</file>

<file path="src/hooks/messages/useIsSafeMessageSignableBy.ts">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'

import useIsSafeOwner from '@/hooks/useIsSafeOwner'

const useIsSafeMessageSignableBy = (message: MessageItem, walletAddress: string): boolean => {
  const isSafeOwner = useIsSafeOwner()
  return isSafeOwner && message.confirmations.every(({ owner }) => owner.value !== walletAddress)
}

export default useIsSafeMessageSignableBy
</file>

<file path="src/hooks/messages/useSafeMessage.ts">
import { isSafeMessageListItem } from '@/utils/safe-message-guards'
import { useState, useEffect } from 'react'
import useSafeMessages from './useSafeMessages'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '../useSafeInfo'
import { fetchSafeMessage } from './useSyncSafeMessageSigner'
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'

const useSafeMessage = (safeMessageHash: string | undefined) => {
  const [safeMessage, setSafeMessage] = useState<MessageItem | undefined>()

  const { safe } = useSafeInfo()

  const messages = useSafeMessages()

  const ongoingMessage = messages.page?.results
    ?.filter(isSafeMessageListItem)
    .find((msg) => msg.messageHash === safeMessageHash)

  const [updatedMessage, messageError] = useAsync(async () => {
    if (!safeMessageHash) return
    return fetchSafeMessage(safeMessageHash, safe.chainId)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [safeMessageHash, safe.chainId, safe.messagesTag])

  useEffect(() => {
    setSafeMessage(updatedMessage ?? ongoingMessage)
  }, [ongoingMessage, updatedMessage])

  return [safeMessage, setSafeMessage, messageError] as const
}

export default useSafeMessage
</file>

<file path="src/hooks/messages/useSafeMessageNotifications.ts">
import type { SafeMessageListItem } from '@safe-global/store/gateway/types'
import { useEffect, useMemo, useRef } from 'react'

import { SafeMsgEvent, safeMsgSubscribe } from '@/services/safe-messages/safeMsgEvents'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectNotifications, showNotification } from '@/store/notificationsSlice'
import { formatError } from '@safe-global/utils/utils/formatters'
import { isSafeMessageListItem } from '@/utils/safe-message-guards'
import useSafeMessages from '@/hooks/messages/useSafeMessages'
import { selectPendingSafeMessages } from '@/store/pendingSafeMessagesSlice'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { AppRoutes } from '@/config/routes'
import useWallet from '@/hooks/wallets/useWallet'
import { useCurrentChain } from '@/hooks/useChains'
import useSafeAddress from '@/hooks/useSafeAddress'
import type { PendingSafeMessagesState } from '@/store/pendingSafeMessagesSlice'
import { isWalletRejection } from '@/utils/wallets'

const SafeMessageNotifications: Partial<Record<SafeMsgEvent, string>> = {
  [SafeMsgEvent.PROPOSE]: 'You successfully signed the message.',
  [SafeMsgEvent.PROPOSE_FAILED]: 'Signing the message failed. Please try again.',
  [SafeMsgEvent.CONFIRM_PROPOSE]: 'You successfully confirmed the message.',
  [SafeMsgEvent.CONFIRM_PROPOSE_FAILED]: 'Confirming the message failed. Please try again.',
  [SafeMsgEvent.SIGNATURE_PREPARED]: 'The message was successfully confirmed.',
}

export const _getSafeMessagesAwaitingConfirmations = (
  items: SafeMessageListItem[],
  pendingMsgs: PendingSafeMessagesState,
  walletAddress: string,
) => {
  return items.filter(isSafeMessageListItem).filter((message) => {
    const needsConfirmation = message.status === 'NEEDS_CONFIRMATION'
    const isPending = !!pendingMsgs[message.messageHash]
    const canSign = message.confirmations.every(({ owner }) => owner.value !== walletAddress)
    return needsConfirmation && !isPending && canSign
  })
}

const useSafeMessageNotifications = () => {
  const dispatch = useAppDispatch()

  /**
   * Show notifications of a messages's lifecycle
   */

  useEffect(() => {
    const entries = Object.entries(SafeMessageNotifications) as [keyof typeof SafeMessageNotifications, string][]

    const unsubFns = entries.map(([event, baseMessage]) =>
      safeMsgSubscribe(event, (detail) => {
        const isError = 'error' in detail
        if (isError && isWalletRejection(detail.error)) return
        const isSuccess = event === SafeMsgEvent.PROPOSE || event === SafeMsgEvent.SIGNATURE_PREPARED
        const message = isError ? `${baseMessage}${formatError(detail.error)}` : baseMessage

        dispatch(
          showNotification({
            message,
            detailedMessage: isError ? detail.error.message : undefined,
            groupKey: detail.messageHash,
            variant: isError ? 'error' : isSuccess ? 'success' : 'info',
          }),
        )
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [dispatch])

  /**
   * If there's at least one message awaiting confirmations, show a notification for it
   */

  const { page } = useSafeMessages()
  const pendingMsgs = useAppSelector(selectPendingSafeMessages)
  const wallet = useWallet()
  const isOwner = useIsSafeOwner()
  const notifications = useAppSelector(selectNotifications)
  const chain = useCurrentChain()
  const safeAddress = useSafeAddress()
  const notifiedAwaitingMessageHashes = useRef<Array<string>>([])

  const msgsNeedingConfirmation = useMemo(() => {
    if (!page?.results) {
      return []
    }

    return _getSafeMessagesAwaitingConfirmations(page.results, pendingMsgs, wallet?.address || '')
  }, [page?.results, pendingMsgs, wallet?.address])

  useEffect(() => {
    if (!isOwner || msgsNeedingConfirmation.length === 0) {
      return
    }

    const messageHash = msgsNeedingConfirmation[0].messageHash
    const hasNotified = notifiedAwaitingMessageHashes.current.includes(messageHash)

    if (hasNotified) {
      return
    }

    dispatch(
      showNotification({
        variant: 'info',
        message: 'A message requires your confirmation.',
        link: {
          href: `${AppRoutes.transactions.messages}?safe=${chain?.shortName}:${safeAddress}`,
          title: 'View messages',
        },
        groupKey: messageHash,
      }),
    )

    notifiedAwaitingMessageHashes.current.push(messageHash)
  }, [dispatch, isOwner, notifications, msgsNeedingConfirmation, chain?.shortName, safeAddress])
}

export default useSafeMessageNotifications
</file>

<file path="src/hooks/messages/useSafeMessagePendingStatuses.ts">
import { useEffect } from 'react'

import { safeMsgSubscribe, SafeMsgEvent } from '@/services/safe-messages/safeMsgEvents'
import { useAppDispatch } from '@/store'
import { clearPendingSafeMessage, setPendingSafeMessage } from '@/store/pendingSafeMessagesSlice'

const pendingStatuses: Record<SafeMsgEvent, boolean> = {
  [SafeMsgEvent.PROPOSE]: true,
  [SafeMsgEvent.PROPOSE_FAILED]: false,
  [SafeMsgEvent.CONFIRM_PROPOSE]: true,
  [SafeMsgEvent.CONFIRM_PROPOSE_FAILED]: false,
  [SafeMsgEvent.UPDATED]: false,
  [SafeMsgEvent.SIGNATURE_PREPARED]: false,
}

const entries = Object.entries(pendingStatuses) as [keyof typeof pendingStatuses, boolean][]

const useSafeMessagePendingStatuses = () => {
  const dispatch = useAppDispatch()

  useEffect(() => {
    const unsubFns = entries.map(([event, isPending]) =>
      safeMsgSubscribe(event, ({ messageHash }) => {
        if (!isPending) {
          dispatch(clearPendingSafeMessage(messageHash))
          return
        }

        dispatch(setPendingSafeMessage(messageHash))
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [dispatch])
}

export default useSafeMessagePendingStatuses
</file>

<file path="src/hooks/messages/useSafeMessages.ts">
import type { MessagePage } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { getSafeMessages } from '@safe-global/safe-gateway-typescript-sdk'

import { useAppSelector } from '@/store'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '@/hooks/useSafeInfo'
import { selectSafeMessages } from '@/store/safeMessagesSlice'

const useSafeMessages = (
  pageUrl?: string,
): {
  page?: MessagePage
  error?: string
  loading: boolean
} => {
  const { safe, safeAddress, safeLoaded } = useSafeInfo()

  // If pageUrl is passed, load a new messages page from the API
  const [page, error, loading] = useAsync<MessagePage>(
    () => {
      if (!safeLoaded || !pageUrl) {
        return
      }
      return getSafeMessages(safe.chainId, safeAddress, pageUrl) as Promise<MessagePage>
    },
    [safe.chainId, safeAddress, safeLoaded, pageUrl],
    false,
  )

  const messagesState = useAppSelector(selectSafeMessages)

  return pageUrl
    ? // New page
      {
        page,
        error: error?.message,
        loading,
      }
    : // Stored page
      {
        page: messagesState.data,
        error: messagesState.error,
        loading: messagesState.loading,
      }
}

export default useSafeMessages
</file>

<file path="src/hooks/messages/useSafeMessageStatus.ts">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import type { SafeMessageStatus } from '@safe-global/store/gateway/types'

import useIsSafeMessagePending from './useIsSafeMessagePending'
import useWallet from '../wallets/useWallet'

const ConfirmingStatus = 'CONFIRMING'
const AwaitingConfirmationsStatus = 'AWAITING_CONFIRMATIONS'
const ConfirmedStatus = 'CONFIRMED'
const NeedsConfirmationStatus = 'NEEDS_CONFIRMATION'
type SafeMessageLocalStatus =
  | SafeMessageStatus
  | typeof ConfirmingStatus
  | typeof AwaitingConfirmationsStatus
  | typeof ConfirmedStatus
  | typeof NeedsConfirmationStatus

const STATUS_LABELS: { [_key in SafeMessageLocalStatus]: string } = {
  [ConfirmingStatus]: 'Confirming',
  [AwaitingConfirmationsStatus]: 'Awaiting confirmations',
  [ConfirmedStatus]: 'Confirmed',
  [NeedsConfirmationStatus]: 'Needs confirmation',
}

const useSafeMessageStatus = (msg: MessageItem) => {
  const isPending = useIsSafeMessagePending(msg.messageHash)
  const wallet = useWallet()

  if (isPending) {
    return STATUS_LABELS[ConfirmingStatus]
  }

  const hasWalletSigned = wallet && msg.confirmations.some(({ owner }) => owner.value === wallet.address)
  const isConfirmed = msg.status === ConfirmedStatus
  if (hasWalletSigned && !isConfirmed) {
    return STATUS_LABELS[AwaitingConfirmationsStatus]
  }

  return STATUS_LABELS[msg.status]
}

export default useSafeMessageStatus
</file>

<file path="src/hooks/messages/useSafeMsgTracking.ts">
import { useEffect } from 'react'

import { trackEvent, WALLET_EVENTS } from '@/services/analytics'
import { SafeMsgEvent, safeMsgSubscribe } from '@/services/safe-messages/safeMsgEvents'

const safeMsgEvents = {
  [SafeMsgEvent.PROPOSE]: WALLET_EVENTS.SIGN_MESSAGE,
  [SafeMsgEvent.CONFIRM_PROPOSE]: WALLET_EVENTS.CONFIRM_MESSAGE,
}

export const useSafeMsgTracking = (): void => {
  useEffect(() => {
    const unsubFns = Object.entries(safeMsgEvents).map(([safeMsgEvent, analyticsEvent]) =>
      safeMsgSubscribe(safeMsgEvent as SafeMsgEvent, () => {
        trackEvent(analyticsEvent)
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [])
}
</file>

<file path="src/hooks/messages/useSyncSafeMessageSigner.ts">
import type { TypedData, MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import useWallet from '@/hooks/wallets/useWallet'
import { Errors, logError } from '@/services/exceptions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { dispatchPreparedSignature } from '@/services/safe-messages/safeMsgNotifications'
import { dispatchSafeMsgProposal, dispatchSafeMsgConfirmation } from '@/services/safe-messages/safeMsgSender'
import { getSafeMessage } from '@safe-global/safe-gateway-typescript-sdk'
import { useEffect, useCallback, useState } from 'react'
import useSafeInfo from '../useSafeInfo'

const HIDE_DELAY = 3000

export const fetchSafeMessage = async (safeMessageHash: string, chainId: string): Promise<MessageItem | undefined> => {
  let message: MessageItem | undefined
  try {
    // fetchedMessage does not have a type because it is explicitly a message
    const fetchedMessage = await getSafeMessage(chainId, safeMessageHash)
    // @ts-expect-error - the getSafeMessage type from the safe-gateway-typescript-sdk is wrong. The gateway returns a MessageItem
    message = { ...fetchedMessage, type: 'MESSAGE' }
  } catch (err) {
    logError(Errors._613, err)
    throw err
  }

  return message
}

const useSyncSafeMessageSigner = (
  message: MessageItem | undefined,
  decodedMessage: string | TypedData,
  safeMessageHash: string,
  requestId: string | undefined,
  origin: string | undefined,
  onClose: () => void,
) => {
  const [submitError, setSubmitError] = useState<Error | undefined>()
  const wallet = useWallet()
  const { safe } = useSafeInfo()

  // If the message gets updated in the messageSlice we dispatch it if the signature is complete
  useEffect(() => {
    let timeout: NodeJS.Timeout | undefined
    if (message?.preparedSignature) {
      timeout = setTimeout(() => dispatchPreparedSignature(message, safeMessageHash, onClose, requestId), HIDE_DELAY)
    }
    return () => clearTimeout(timeout)
  }, [message, safe.chainId, safeMessageHash, onClose, requestId])

  const onSign = useCallback(async () => {
    // Error is shown when no wallet is connected, this appeases TypeScript
    if (!wallet) {
      return
    }

    setSubmitError(undefined)

    try {
      // When collecting the first signature
      if (!message) {
        await dispatchSafeMsgProposal({ provider: wallet.provider, safe, message: decodedMessage, origin })

        // Fetch updated message
        const updatedMsg = await fetchSafeMessage(safeMessageHash, safe.chainId)

        // If threshold 1, we do not want to wait for polling
        if (safe.threshold === 1 && updatedMsg) {
          setTimeout(() => dispatchPreparedSignature(updatedMsg, safeMessageHash, onClose, requestId), HIDE_DELAY)
        }
        return updatedMsg
      } else {
        await dispatchSafeMsgConfirmation({ provider: wallet.provider, safe, message: decodedMessage })

        // No requestID => we are in the confirm message dialog and do not need to leave the window open
        if (!requestId) {
          onClose()
          return
        }

        const updatedMsg = await fetchSafeMessage(safeMessageHash, safe.chainId)
        if (updatedMsg) {
          setTimeout(() => dispatchPreparedSignature(updatedMsg, safeMessageHash, onClose, requestId), HIDE_DELAY)
        }
        return updatedMsg
      }
    } catch (e) {
      setSubmitError(asError(e))
    }
  }, [wallet, safe, message, decodedMessage, origin, safeMessageHash, onClose, requestId])

  return { submitError, onSign }
}

export default useSyncSafeMessageSigner
</file>

<file path="src/hooks/safe-apps/permissions/index.ts">
import { RestrictedMethods } from '@safe-global/safe-apps-sdk'
import type { AllowedFeatures } from '@/components/safe-apps/types'
import { capitalize } from '@safe-global/utils/utils/formatters'

type PermissionsDisplayType = {
  displayName: string
  description: string
}

export * from './useBrowserPermissions'
export * from './useSafePermissions'

const SAFE_PERMISSIONS_TEXTS: Record<string, PermissionsDisplayType> = {
  [RestrictedMethods.requestAddressBook]: {
    displayName: 'Address Book',
    description: 'Access to your address book',
  },
}

export const getSafePermissionDisplayValues = (method: string) => {
  return SAFE_PERMISSIONS_TEXTS[method]
}

export const getBrowserPermissionDisplayValues = (feature: AllowedFeatures) => {
  return {
    displayName: capitalize(feature).replace(/-/g, ' '),
    description: `Allow to use - ${feature}`,
  }
}
</file>

<file path="src/hooks/safe-apps/permissions/useBrowserPermissions.ts">
import type { AllowedFeatures } from '@/components/safe-apps/types'
import { PermissionStatus } from '@/components/safe-apps/types'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { useCallback } from 'react'
import { trimTrailingSlash } from '@/utils/url'

const BROWSER_PERMISSIONS = 'SafeApps__browserPermissions'

export type BrowserPermission = { feature: AllowedFeatures; status: PermissionStatus }

type BrowserPermissions = { [origin: string]: BrowserPermission[] }

type BrowserPermissionChangeSet = { feature: AllowedFeatures; selected: boolean }[]

type UseBrowserPermissionsReturnType = {
  permissions: BrowserPermissions
  getPermissions: (origin: string) => BrowserPermission[]
  updatePermission: (origin: string, changeset: BrowserPermissionChangeSet) => void
  addPermissions: (origin: string, permissions: BrowserPermission[]) => void
  removePermissions: (origin: string) => void
  getAllowedFeaturesList: (origin: string) => string
}

const useBrowserPermissions = (): UseBrowserPermissionsReturnType => {
  const [permissions = {}, setPermissions] = useLocalStorage<BrowserPermissions>(BROWSER_PERMISSIONS)

  const getPermissions = useCallback(
    (origin: string) => {
      return permissions[trimTrailingSlash(origin)] || []
    },
    [permissions],
  )

  const updatePermission = useCallback(
    (origin: string, changeset: BrowserPermissionChangeSet) => {
      const appUrl = trimTrailingSlash(origin)

      setPermissions({
        ...permissions,
        [appUrl]: permissions[appUrl].map((p) => {
          const change = changeset.find((change) => change.feature === p.feature)

          if (change) {
            p.status = change.selected ? PermissionStatus.GRANTED : PermissionStatus.DENIED
          }

          return p
        }),
      })
    },
    [permissions, setPermissions],
  )

  const removePermissions = useCallback(
    (origin: string) => {
      delete permissions[trimTrailingSlash(origin)]
      setPermissions({ ...permissions })
    },
    [permissions, setPermissions],
  )

  const addPermissions = useCallback(
    (origin: string, selectedPermissions: BrowserPermission[]) => {
      setPermissions({ ...permissions, [trimTrailingSlash(origin)]: selectedPermissions })
    },
    [permissions, setPermissions],
  )

  const getAllowedFeaturesList = useCallback(
    (origin: string): string => {
      return getPermissions(origin)
        .filter(({ status }) => status === PermissionStatus.GRANTED)
        .map((permission) => permission.feature)
        .join('; ')
    },
    [getPermissions],
  )

  return {
    permissions,
    getPermissions,
    updatePermission,
    addPermissions,
    removePermissions,
    getAllowedFeaturesList,
  }
}

export { useBrowserPermissions }
</file>

<file path="src/hooks/safe-apps/permissions/useSafePermissions.ts">
import { useState, useCallback } from 'react'
import type { Methods } from '@safe-global/safe-apps-sdk'
import type {
  Permission,
  PermissionCaveat,
  PermissionRequest,
} from '@safe-global/safe-apps-sdk/dist/types/types/permissions'

import { PermissionStatus } from '@/components/safe-apps/types'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { trimTrailingSlash } from '@/utils/url'

const SAFE_PERMISSIONS = 'SafeApps__safePermissions'
const USER_RESTRICTED = 'userRestricted'

export type SafePermissions = { [origin: string]: Permission[] }

export type SafePermissionsRequest = {
  origin: string
  requestId: string
  request: PermissionRequest[]
}

type SafePermissionChangeSet = { capability: string; selected: boolean }[]

type UseSafePermissionsReturnType = {
  permissions: SafePermissions
  getPermissions: (origin: string) => Permission[]
  updatePermission: (origin: string, changeset: SafePermissionChangeSet) => void
  removePermissions: (origin: string) => void
  permissionsRequest: SafePermissionsRequest | undefined
  setPermissionsRequest: (permissionsRequest?: SafePermissionsRequest) => void
  confirmPermissionRequest: (result: PermissionStatus) => Permission[]
  hasPermission: (origin: string, permission: Methods) => boolean
  isUserRestricted: (caveats?: PermissionCaveat[]) => boolean
}

const useSafePermissions = (): UseSafePermissionsReturnType => {
  const [permissions = {}, setPermissions] = useLocalStorage<SafePermissions>(SAFE_PERMISSIONS)

  const [permissionsRequest, setPermissionsRequest] = useState<SafePermissionsRequest | undefined>()

  const getPermissions = useCallback(
    (origin: string) => {
      return permissions[trimTrailingSlash(origin)] || []
    },
    [permissions],
  )

  const updatePermission = useCallback(
    (origin: string, changeset: SafePermissionChangeSet) => {
      const appUrl = trimTrailingSlash(origin)

      setPermissions({
        ...permissions,
        [appUrl]: permissions[appUrl].map((permission) => {
          const change = changeset.find((change) => change.capability === permission.parentCapability)

          if (change) {
            if (change.selected) {
              permission.caveats = permission.caveats?.filter((caveat) => caveat.type !== USER_RESTRICTED) || []
            } else if (!isUserRestricted(permission.caveats)) {
              permission.caveats = [
                ...(permission.caveats || []),
                {
                  type: USER_RESTRICTED,
                  value: true,
                },
              ]
            }
          }

          return permission
        }),
      })
    },
    [permissions, setPermissions],
  )

  const removePermissions = useCallback(
    (origin: string) => {
      delete permissions[trimTrailingSlash(origin)]
      setPermissions({ ...permissions })
    },
    [permissions, setPermissions],
  )

  const hasPermission = useCallback(
    (origin: string, permission: Methods) => {
      return permissions[trimTrailingSlash(origin)]?.some(
        (p) => p.parentCapability === permission && !isUserRestricted(p.caveats),
      )
    },
    [permissions],
  )

  const hasCapability = useCallback(
    (origin: string, permission: Methods) => {
      return permissions[trimTrailingSlash(origin)]?.some((p) => p.parentCapability === permission)
    },
    [permissions],
  )

  const confirmPermissionRequest = useCallback(
    (result: PermissionStatus) => {
      if (!permissionsRequest) return []

      const updatedPermissionsByOrigin = [...(permissions[permissionsRequest.origin] || [])]

      permissionsRequest.request.forEach((requestedPermission) => {
        const capability = Object.keys(requestedPermission)[0]

        if (hasCapability(permissionsRequest.origin, capability as Methods)) {
          updatedPermissionsByOrigin.map((permission) => {
            if (permission.parentCapability === capability) {
              if (isUserRestricted(permission.caveats)) {
                if (result === PermissionStatus.GRANTED) {
                  permission.caveats = permission.caveats?.filter((caveat) => caveat.type !== USER_RESTRICTED) || []
                }
              } else {
                if (result === PermissionStatus.DENIED) {
                  permission.caveats?.push({
                    type: USER_RESTRICTED,
                    value: true,
                  })
                }
              }
            }
          })
        } else {
          updatedPermissionsByOrigin.push({
            invoker: permissionsRequest.origin,
            parentCapability: capability,
            date: new Date().getTime(),
            caveats:
              result === PermissionStatus.DENIED
                ? [
                    {
                      type: USER_RESTRICTED,
                      value: true,
                    },
                  ]
                : [],
          })
        }
      })

      setPermissions({
        ...permissions,
        [permissionsRequest.origin]: updatedPermissionsByOrigin,
      })
      setPermissionsRequest(undefined)

      return updatedPermissionsByOrigin
    },
    [permissionsRequest, permissions, setPermissions, hasCapability],
  )

  const isUserRestricted = (caveats?: PermissionCaveat[]) =>
    !!caveats?.some((caveat) => caveat.type === USER_RESTRICTED && caveat.value === true)

  return {
    permissions,
    isUserRestricted,
    getPermissions,
    updatePermission,
    removePermissions,
    permissionsRequest,
    setPermissionsRequest,
    confirmPermissionRequest,
    hasPermission,
  }
}

export { useSafePermissions }
</file>

<file path="src/hooks/safe-apps/useAppsFilterByCategory.ts">
import { useMemo } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

const useAppsFilterByCategory = (safeApps: SafeAppData[], selectedCategories: string[]): SafeAppData[] => {
  const filteredApps = useMemo(() => {
    const hasSelectedCategories = selectedCategories.length > 0

    if (hasSelectedCategories) {
      return safeApps.filter((safeApp) => selectedCategories.some((category) => safeApp.tags.includes(category)))
    }

    return safeApps
  }, [safeApps, selectedCategories])

  return filteredApps
}

export { useAppsFilterByCategory }
</file>

<file path="src/hooks/safe-apps/useAppsFilterByOptimizedForBatch.ts">
import { useMemo } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import { isOptimizedForBatchTransactions } from '@/components/safe-apps/utils'

const useAppsFilterByOptimizedForBatch = (
  safeApps: SafeAppData[],
  optimizedWithBatchFilter: boolean,
): SafeAppData[] => {
  const filteredApps = useMemo(() => {
    if (optimizedWithBatchFilter) {
      return safeApps.filter((safeApp) => isOptimizedForBatchTransactions(safeApp))
    }

    return safeApps
  }, [safeApps, optimizedWithBatchFilter])

  return filteredApps
}

export { useAppsFilterByOptimizedForBatch }
</file>

<file path="src/hooks/safe-apps/useAppsSearch.ts">
import { useMemo } from 'react'
import Fuse from 'fuse.js'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

const useAppsSearch = (apps: SafeAppData[], query: string): SafeAppData[] => {
  const fuse = useMemo(
    () =>
      new Fuse(apps, {
        keys: [
          {
            name: 'name',
            weight: 0.99,
          },
          {
            name: 'description',
            weight: 0.5,
          },
          {
            name: 'tags',
            weight: 0.99,
          },
        ],
        // https://fusejs.io/api/options.html#threshold
        // Very naive explanation: threshold represents how accurate the search results should be. The default is 0.6
        // I tested it and found it to make the search results more accurate when the threshold is 0.3
        // 0 - 1, where 0 is the exact match and 1 matches anything
        threshold: 0.3,
        findAllMatches: true,
      }),
    [apps],
  )

  const results = useMemo(() => (query ? fuse.search(query).map((result) => result.item) : apps), [fuse, apps, query])

  return results
}

export { useAppsSearch }
</file>

<file path="src/hooks/safe-apps/useCategoryFilter.ts">
import { type Dispatch, type SetStateAction, useEffect } from 'react'
import { useRouter } from 'next/router'
import { getCategoryOptions } from '@/components/safe-apps/SafeAppsFilters'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

const useCategoryFilter = ({
  safeAppsList,
  selectedCategories,
  setSelectedCategories,
}: {
  safeAppsList: SafeAppData[]
  selectedCategories: string[]
  setSelectedCategories: Dispatch<SetStateAction<string[]>>
}) => {
  const router = useRouter()

  useEffect(() => {
    if (!router.isReady) return

    const categoryOptions = getCategoryOptions(safeAppsList).map((category) => category.value)
    const categoryQuery = Array.isArray(router.query.categories) ? router.query.categories[0] : router.query.categories

    if (categoryQuery && selectedCategories.length === 0) {
      const categoryQueryOptions = categoryQuery.split(',')
      const isCategoryOption = categoryQueryOptions.every((category) => categoryOptions.includes(category))

      if (!isCategoryOption) return

      setSelectedCategories(categoryQueryOptions)
    }
  }, [router.isReady, router.query.categories, safeAppsList, selectedCategories.length, setSelectedCategories])

  const onSelectCategories = async (selectedCategories: string[]) => {
    const { categories: _, ...restProps } = router.query

    await router.push(
      {
        pathname: router.pathname,
        query:
          selectedCategories.length === 0 ? restProps : { ...router.query, categories: selectedCategories.join(',') },
      },
      undefined,
      {
        shallow: true,
      },
    )

    setSelectedCategories(selectedCategories)
  }

  return { onSelectCategories }
}

export default useCategoryFilter
</file>

<file path="src/hooks/safe-apps/useCustomAppCommunicator.tsx">
import { useState, useEffect, useContext, type MutableRefObject } from 'react'
import type { UseAppCommunicatorHandlers } from '@/components/safe-apps/AppFrame/useAppCommunicator'
import useAppCommunicator, { CommunicatorMessages } from '@/components/safe-apps/AppFrame/useAppCommunicator'
import type { Methods } from '@safe-global/safe-apps-sdk'
import {
  type BaseTransaction,
  type EIP712TypedData,
  type RequestId,
  type SafeSettings,
  type SendTransactionRequestParams,
} from '@safe-global/safe-apps-sdk'
import { SafeAppsTxFlow, SignMessageFlow, SignMessageOnChainFlow } from '@/components/tx-flow/flows'
import { isOffchainEIP1271Supported } from '@safe-global/utils/utils/safe-messages'
import { getSafeMessage, getTransactionDetails, type SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import useGetSafeInfo from '@/components/safe-apps/AppFrame/useGetSafeInfo'
import { isSafeMessageListItem } from '@/utils/safe-message-guards'
import { TxModalContext } from '@/components/tx-flow'
import { selectOnChainSigning, selectTokenList, TOKEN_LISTS } from '@/store/settingsSlice'
import { useAppSelector } from '@/store'
import useSafeInfo from '@/hooks/useSafeInfo'
import { selectSafeMessages } from '@/store/safeMessagesSlice'
import { trackSafeAppEvent, SAFE_APPS_EVENTS } from '@/services/analytics'
import { safeMsgSubscribe, SafeMsgEvent } from '@/services/safe-messages/safeMsgEvents'
import { txSubscribe, TxEvent } from '@/services/tx/txEvents'
import type { ChainInfo as WebCoreChainInfo } from '@safe-global/safe-gateway-typescript-sdk/dist/types/chains'
import useChainId from '@/hooks/useChainId'
import type AppCommunicator from '@/services/safe-apps/AppCommunicator'
import useBalances from '@/hooks/useBalances'
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'
import { useLazyBalancesGetBalancesV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

export const useCustomAppCommunicator = (
  iframeRef: MutableRefObject<HTMLIFrameElement | null>,
  app: SafeAppData,
  chain: WebCoreChainInfo | undefined,
  overrideHandlers?: Partial<UseAppCommunicatorHandlers>,
): AppCommunicator | undefined => {
  const [currentRequestId, setCurrentRequestId] = useState<RequestId | undefined>()
  const safeMessages = useAppSelector(selectSafeMessages)
  const { setTxFlow } = useContext(TxModalContext)
  const { safe, safeAddress } = useSafeInfo()
  const onChainSigning = useAppSelector(selectOnChainSigning)
  const [settings, setSettings] = useState<SafeSettings>({
    offChainSigning: true,
  })
  const appData = app
  const onTxFlowClose = () => {
    setCurrentRequestId((prevId) => {
      if (prevId) {
        communicator?.send(CommunicatorMessages.REJECT_TRANSACTION_MESSAGE, prevId, true)
        trackSafeAppEvent(SAFE_APPS_EVENTS.PROPOSE_TRANSACTION_REJECTED, app.name)
      }
      return undefined
    })
  }
  const tokenlist = useAppSelector(selectTokenList)
  const chainId = useChainId()
  const { balances } = useBalances()
  const [getBalances] = useLazyBalancesGetBalancesV1Query()

  const communicator = useAppCommunicator(iframeRef, appData, chain, {
    onConfirmTransactions: (txs: BaseTransaction[], requestId: RequestId, params?: SendTransactionRequestParams) => {
      const data = {
        app: appData,
        appId: appData ? String(appData.id) : undefined,
        requestId,
        txs,
        params,
      }

      setCurrentRequestId(requestId)
      trackSafeAppEvent({ ...SAFE_APPS_EVENTS.OPEN_TRANSACTION_MODAL, label: appData.name })
      setTxFlow(<SafeAppsTxFlow data={data} />, onTxFlowClose)
    },
    onSignMessage: (
      message: string | EIP712TypedData,
      requestId: string,
      method: Methods.signMessage | Methods.signTypedMessage,
      sdkVersion: string,
    ) => {
      const isOffChainSigningSupported = isOffchainEIP1271Supported(safe, chain, sdkVersion)
      const signOffChain = isOffChainSigningSupported && !onChainSigning && !!settings.offChainSigning

      setCurrentRequestId(requestId)

      if (signOffChain) {
        setTxFlow(
          <SignMessageFlow
            logoUri={appData?.iconUrl || ''}
            name={appData?.name || ''}
            message={message as string | TypedData}
            origin={appData?.url}
            requestId={requestId}
          />,
          onTxFlowClose,
        )
      } else {
        setTxFlow(
          <SignMessageOnChainFlow
            props={{
              app: appData,
              requestId,
              message,
              method,
            }}
          />,
        )
      }
    },
    onGetPermissions: () => [],
    onSetPermissions: () => {},
    onRequestAddressBook: () => [],
    onGetTxBySafeTxHash: (safeTxHash) => getTransactionDetails(chainId, safeTxHash),
    onGetEnvironmentInfo: () => ({
      origin: document.location.origin,
    }),
    onGetSafeInfo: useGetSafeInfo(),
    onGetSafeBalances: (currency) => {
      const isDefaultTokenlistSupported = chain && hasFeature(chain, FEATURES.DEFAULT_TOKENLIST)
      return safe.deployed
        ? getBalances({
            chainId,
            safeAddress,
            fiatCode: currency,
            excludeSpam: true,
            trusted: isDefaultTokenlistSupported && TOKEN_LISTS.TRUSTED === tokenlist,
          }).then((res) => res.data ?? balances)
        : Promise.resolve(balances)
    },
    onGetChainInfo: () => {
      if (!chain) return

      const { nativeCurrency, chainName, chainId, shortName, blockExplorerUriTemplate } = chain

      return {
        chainName,
        chainId,
        shortName,
        nativeCurrency,
        blockExplorerUriTemplate,
      }
    },
    onSetSafeSettings: (safeSettings: SafeSettings) => {
      const newSettings: SafeSettings = {
        ...settings,
        offChainSigning: !!safeSettings.offChainSigning,
      }

      setSettings(newSettings)

      return newSettings
    },
    onGetOffChainSignature: async (messageHash: string) => {
      const safeMessage = safeMessages.data?.results
        ?.filter(isSafeMessageListItem)
        ?.find((item) => item.messageHash === messageHash)

      if (safeMessage) {
        return safeMessage.preparedSignature || undefined
      }

      try {
        const { preparedSignature } = await getSafeMessage(chainId, messageHash)
        return preparedSignature || undefined
      } catch {
        return undefined
      }
    },
    ...overrideHandlers,
  })

  useEffect(() => {
    const unsubscribe = txSubscribe(TxEvent.SAFE_APPS_REQUEST, async ({ safeAppRequestId, safeTxHash }) => {
      if (safeAppRequestId && currentRequestId === safeAppRequestId) {
        trackSafeAppEvent(SAFE_APPS_EVENTS.PROPOSE_TRANSACTION, appData?.name)
        communicator?.send({ safeTxHash }, safeAppRequestId)
      }
    })

    return unsubscribe
  }, [chainId, communicator, currentRequestId, appData.name])

  useEffect(() => {
    const unsubscribe = safeMsgSubscribe(SafeMsgEvent.SIGNATURE_PREPARED, ({ messageHash, requestId, signature }) => {
      if (requestId && currentRequestId === requestId) {
        communicator?.send({ messageHash, signature }, requestId)
      }
    })

    return unsubscribe
  }, [communicator, currentRequestId])

  return communicator
}
</file>

<file path="src/hooks/safe-apps/useCustomSafeApps.ts">
import { useState, useEffect, useCallback } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import local from '@/services/local-storage/local'
import { fetchSafeAppFromManifest } from '@/services/safe-apps/manifest'
import useChainId from '@/hooks/useChainId'

type ReturnType = {
  customSafeApps: SafeAppData[]
  loading: boolean
  updateCustomSafeApps: (newCustomSafeApps: SafeAppData[]) => void
}

const CUSTOM_SAFE_APPS_STORAGE_KEY = 'customSafeApps'

const getChainSpecificSafeAppsStorageKey = (chainId: string) => `${CUSTOM_SAFE_APPS_STORAGE_KEY}-${chainId}`

type StoredCustomSafeApp = { url: string }

/*
  This hook is used to manage the list of custom safe apps.
  What it does:
  1. Loads a list of custom safe apps from local storage
  2. Does some backward compatibility checks (supported app networks, etc)
  3. Tries to fetch the app info (manifest.json) from the app url
*/
const useCustomSafeApps = (): ReturnType => {
  const [customSafeApps, setCustomSafeApps] = useState<SafeAppData[]>([])
  const [loading, setLoading] = useState(false)
  const chainId = useChainId()

  const updateCustomSafeApps = useCallback(
    (newCustomSafeApps: SafeAppData[]) => {
      setCustomSafeApps(newCustomSafeApps)

      const chainSpecificSafeAppsStorageKey = getChainSpecificSafeAppsStorageKey(chainId)
      local.setItem(
        chainSpecificSafeAppsStorageKey,
        newCustomSafeApps.map((app) => ({ url: app.url })),
      )
    },
    [chainId],
  )

  useEffect(() => {
    const loadCustomApps = async () => {
      setLoading(true)
      const chainSpecificSafeAppsStorageKey = getChainSpecificSafeAppsStorageKey(chainId)
      const storedApps = local.getItem<StoredCustomSafeApp[]>(chainSpecificSafeAppsStorageKey) || []
      const appManifests = await Promise.allSettled(storedApps.map((app) => fetchSafeAppFromManifest(app.url, chainId)))
      const resolvedApps = appManifests
        .filter((promiseResult) => promiseResult.status === 'fulfilled')
        .map((promiseResult) => (promiseResult as PromiseFulfilledResult<SafeAppData>).value)

      setCustomSafeApps(resolvedApps)
      setLoading(false)
    }

    loadCustomApps()
  }, [chainId])

  return { customSafeApps, loading, updateCustomSafeApps }
}

export { useCustomSafeApps }
</file>

<file path="src/hooks/safe-apps/useOpenedSafeApps.ts">
import { useCallback } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import useChainId from '@/hooks/useChainId'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectOpened, markOpened } from '@/store/safeAppsSlice'

type ReturnType = {
  openedSafeAppIds: Array<SafeAppData['id']>
  markSafeAppOpened: (id: SafeAppData['id']) => void
}

// Return the ids of Safe Apps previously opened by the user
export const useOpenedSafeApps = (): ReturnType => {
  const chainId = useChainId()

  const dispatch = useAppDispatch()
  const openedSafeAppIds = useAppSelector((state) => selectOpened(state, chainId))

  const markSafeAppOpened = useCallback(
    (id: SafeAppData['id']) => {
      dispatch(markOpened({ id, chainId }))
    },
    [dispatch, chainId],
  )

  return { openedSafeAppIds, markSafeAppOpened }
}
</file>

<file path="src/hooks/safe-apps/usePinnedSafeApps.ts">
import { useCallback, useMemo } from 'react'
import { useAppDispatch, useAppSelector } from '@/store'
import { selectPinned, setPinned } from '@/store/safeAppsSlice'
import useChainId from '../useChainId'

type ReturnType = {
  pinnedSafeAppIds: Set<number>
  updatePinnedSafeApps: (newPinnedSafeAppIds: Set<number>) => void
}

// Return the pinned app ids across all chains
export const usePinnedSafeApps = (): ReturnType => {
  const chainId = useChainId()
  const pinned = useAppSelector((state) => selectPinned(state, chainId))
  const pinnedSafeAppIds = useMemo(() => new Set(pinned), [pinned])
  const dispatch = useAppDispatch()

  const updatePinnedSafeApps = useCallback(
    (ids: Set<number>) => {
      dispatch(setPinned({ pinned: Array.from(ids), chainId }))
    },
    [dispatch, chainId],
  )

  return { pinnedSafeAppIds, updatePinnedSafeApps }
}
</file>

<file path="src/hooks/safe-apps/useRankedSafeApps.ts">
import { useMemo } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { rankSafeApps } from '@/services/safe-apps/track-app-usage-count'

// number of ranked Safe Apps that we want to display
const NUMBER_OF_SAFE_APPS = 5

const useRankedSafeApps = (safeApps: SafeAppData[], pinnedSafeApps: SafeAppData[]): SafeAppData[] => {
  return useMemo(() => {
    if (!safeApps.length) return []

    // TODO: Remove assertion after migrating to new SDK
    const featuredApps = safeApps.filter((app) => (app as SafeAppData & { featured: boolean }).featured)
    const rankedPinnedApps = rankSafeApps(pinnedSafeApps)

    const allRankedApps = featuredApps.concat(rankedPinnedApps, pinnedSafeApps)

    // Use a Set to remove duplicates
    return [...new Set(allRankedApps)].slice(0, NUMBER_OF_SAFE_APPS)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [safeApps])
}

export { useRankedSafeApps }
</file>

<file path="src/hooks/safe-apps/useRemoteSafeApps.ts">
import type { SafeAppsName, SafeAppsTag } from '@/config/constants'
import useChainId from '@/hooks/useChainId'
import { Errors, logError } from '@/services/exceptions'
import type { SafeAppsResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { getSafeApps } from '@safe-global/safe-gateway-typescript-sdk'
import { useEffect, useMemo } from 'react'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import useAsync from '@safe-global/utils/hooks/useAsync'

// To avoid multiple simultaneous requests (e.g. the Dashboard and the SAFE header widget),
// cache the request promise for 100ms
let cache: Record<string, Promise<SafeAppsResponse> | undefined> = {}
const cachedGetSafeApps = (chainId: string): ReturnType<typeof getSafeApps> | undefined => {
  if (!cache[chainId]) {
    cache[chainId] = getSafeApps(chainId, { client_url: window.location.origin })

    // Clear the cache the promise resolves with a small delay
    cache[chainId]
      ?.catch(() => null)
      .then(() => {
        setTimeout(() => (cache[chainId] = undefined), 100)
      })
  }

  return cache[chainId]
}

type UseRemoteSafeAppsProps =
  | { tag: SafeAppsTag; name?: never }
  | { name: SafeAppsName; tag?: never }
  | { name?: never; tag?: never }

const useRemoteSafeApps = ({ tag, name }: UseRemoteSafeAppsProps = {}): AsyncResult<SafeAppsResponse> => {
  const chainId = useChainId()

  const [remoteApps, error, loading] = useAsync<SafeAppsResponse>(() => {
    if (!chainId) return
    return cachedGetSafeApps(chainId)
  }, [chainId])

  useEffect(() => {
    if (error) {
      logError(Errors._902, error.message)
    }
  }, [error])

  const apps = useMemo(() => {
    if (!remoteApps) return remoteApps
    if (tag) {
      return remoteApps.filter((app) => app.tags.includes(tag))
    }
    if (name) {
      return remoteApps.filter((app) => app.name === name)
    }
    return remoteApps
  }, [remoteApps, tag, name])

  const sortedApps = useMemo(() => {
    return apps?.sort((a, b) => a.name.localeCompare(b.name))
  }, [apps])

  return [sortedApps, error, loading]
}

export { useRemoteSafeApps }
</file>

<file path="src/hooks/safe-apps/useRemoveAppModal.ts">
import { useState, useCallback } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

type ModalState =
  | {
      isOpen: false
      app: null
    }
  | {
      isOpen: true
      app: SafeAppData
    }

type ReturnType = { state: ModalState; open: (app: SafeAppData) => void; close: () => void }

const useRemoveAppModal = (): ReturnType => {
  const [state, setState] = useState<ModalState>({ isOpen: false, app: null })

  const open = useCallback((app: SafeAppData) => {
    setState({ isOpen: true, app })
  }, [])

  const close = useCallback(() => setState(() => ({ isOpen: false, app: null })), [])

  return { state, open, close }
}

export { useRemoveAppModal }
</file>

<file path="src/hooks/safe-apps/useSafeAppFromBackend.ts">
import { useEffect } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { getSafeApps } from '@safe-global/safe-gateway-typescript-sdk'
import { Errors, logError } from '@/services/exceptions'
import type { AsyncResult } from '@safe-global/utils/hooks/useAsync'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { trimTrailingSlash } from '@/utils/url'

const useSafeAppFromBackend = (url: string, chainId: string): AsyncResult<SafeAppData> => {
  const [backendApp, error, loading] = useAsync(async () => {
    if (!chainId) return

    // We do not have a single standard for storing URLs, it may be stored with or without a trailing slash.
    // But for the request it has to be an exact match.
    const retryUrl = url.endsWith('/') ? trimTrailingSlash(url) : `${url}/`
    let response = await getSafeApps(chainId, { url })
    if (!response[0]) {
      response = await getSafeApps(chainId, { url: retryUrl })
    }

    return response?.[0]
  }, [chainId, url])

  useEffect(() => {
    if (error) {
      logError(Errors._900, error.message)
    }
  }, [error])

  return [backendApp, error, loading]
}

export { useSafeAppFromBackend }
</file>

<file path="src/hooks/safe-apps/useSafeAppFromManifest.ts">
import { useEffect, useMemo } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { Errors, logError } from '@/services/exceptions'
import { fetchSafeAppFromManifest } from '@/services/safe-apps/manifest'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { getEmptySafeApp } from '@/components/safe-apps/utils'
import type { SafeAppDataWithPermissions } from '@/components/safe-apps/types'
import { asError } from '@safe-global/utils/services/exceptions/utils'

type UseSafeAppFromManifestReturnType = {
  safeApp: SafeAppDataWithPermissions
  isLoading: boolean
}

const useSafeAppFromManifest = (
  appUrl: string,
  chainId: string,
  safeAppData?: SafeAppData,
): UseSafeAppFromManifestReturnType => {
  const [data, error, isLoading] = useAsync<SafeAppDataWithPermissions>(() => {
    if (appUrl && chainId && safeAppData) return fetchSafeAppFromManifest(appUrl, chainId)
  }, [appUrl, chainId, safeAppData])

  const emptyApp = useMemo(() => getEmptySafeApp(appUrl, safeAppData), [appUrl, safeAppData])

  useEffect(() => {
    if (!error) return
    logError(Errors._903, `${appUrl}, ${asError(error).message}`)
  }, [appUrl, error])

  return { safeApp: data || emptyApp, isLoading }
}

export { useSafeAppFromManifest }
</file>

<file path="src/hooks/safe-apps/useSafeAppPreviewDrawer.ts">
import { useCallback, useState } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

type ReturnType = {
  isPreviewDrawerOpen: boolean
  previewDrawerApp: SafeAppData | undefined
  openPreviewDrawer: (safeApp: SafeAppData) => void
  closePreviewDrawer: () => void
}

const useSafeAppPreviewDrawer = (): ReturnType => {
  const [previewDrawerApp, setPreviewDrawerApp] = useState<SafeAppData>()
  const [isPreviewDrawerOpen, setIsPreviewDrawerOpen] = useState<boolean>(false)

  const openPreviewDrawer = useCallback((safeApp: SafeAppData) => {
    setPreviewDrawerApp(safeApp)
    setIsPreviewDrawerOpen(true)
  }, [])

  const closePreviewDrawer = useCallback(() => {
    setIsPreviewDrawerOpen(false)
  }, [])

  return { isPreviewDrawerOpen, previewDrawerApp, openPreviewDrawer, closePreviewDrawer }
}

export default useSafeAppPreviewDrawer
</file>

<file path="src/hooks/safe-apps/useSafeApps.ts">
import { useMemo, useCallback } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'
import { useCustomSafeApps } from '@/hooks/safe-apps/useCustomSafeApps'
import { usePinnedSafeApps } from '@/hooks/safe-apps/usePinnedSafeApps'
import { useBrowserPermissions, useSafePermissions } from './permissions'
import { useRankedSafeApps } from '@/hooks/safe-apps/useRankedSafeApps'
import { SAFE_APPS_EVENTS, type SAFE_APPS_LABELS, trackSafeAppEvent } from '@/services/analytics'

type ReturnType = {
  allSafeApps: SafeAppData[]
  pinnedSafeApps: SafeAppData[]
  pinnedSafeAppIds: Set<number>
  remoteSafeApps: SafeAppData[]
  customSafeApps: SafeAppData[]
  rankedSafeApps: SafeAppData[]
  remoteSafeAppsLoading: boolean
  customSafeAppsLoading: boolean
  remoteSafeAppsError?: Error
  addCustomApp: (app: SafeAppData) => void
  togglePin: (appId: number, eventLabel: SAFE_APPS_LABELS) => void
  removeCustomApp: (appId: number) => void
}

const useSafeApps = (): ReturnType => {
  const [remoteSafeApps = [], remoteSafeAppsError, remoteSafeAppsLoading] = useRemoteSafeApps()
  const { customSafeApps, loading: customSafeAppsLoading, updateCustomSafeApps } = useCustomSafeApps()
  const { pinnedSafeAppIds, updatePinnedSafeApps } = usePinnedSafeApps()
  const { removePermissions: removeSafePermissions } = useSafePermissions()
  const { removePermissions: removeBrowserPermissions } = useBrowserPermissions()

  const allSafeApps = useMemo(
    () => remoteSafeApps.concat(customSafeApps).sort((a, b) => a.name.localeCompare(b.name)),
    [remoteSafeApps, customSafeApps],
  )

  const pinnedSafeApps = useMemo(
    () => remoteSafeApps.filter((app) => pinnedSafeAppIds.has(app.id)),
    [remoteSafeApps, pinnedSafeAppIds],
  )

  const rankedSafeApps = useRankedSafeApps(allSafeApps, pinnedSafeApps)

  const addCustomApp = useCallback(
    (app: SafeAppData) => {
      updateCustomSafeApps([...customSafeApps, app])
    },
    [updateCustomSafeApps, customSafeApps],
  )

  const removeCustomApp = useCallback(
    (appId: number) => {
      updateCustomSafeApps(customSafeApps.filter((app) => app.id !== appId))
      const app = customSafeApps.find((app) => app.id === appId)

      if (app) {
        removeSafePermissions(app.url)
        removeBrowserPermissions(app.url)
      }
    },
    [updateCustomSafeApps, customSafeApps, removeSafePermissions, removeBrowserPermissions],
  )

  const togglePin = (appId: number, eventLabel: SAFE_APPS_LABELS) => {
    const alreadyPinned = pinnedSafeAppIds.has(appId)
    const newSet = new Set(pinnedSafeAppIds)
    const appName = allSafeApps.find((app) => app.id === appId)?.name

    if (alreadyPinned) {
      newSet.delete(appId)
      trackSafeAppEvent({ ...SAFE_APPS_EVENTS.UNPIN, label: eventLabel }, appName)
    } else {
      newSet.add(appId)
      trackSafeAppEvent({ ...SAFE_APPS_EVENTS.PIN, label: eventLabel }, appName)
    }
    updatePinnedSafeApps(newSet)
  }

  return {
    allSafeApps,
    rankedSafeApps,

    remoteSafeApps,
    remoteSafeAppsLoading: remoteSafeAppsLoading || !(remoteSafeApps || remoteSafeAppsError),
    remoteSafeAppsError,

    pinnedSafeApps,
    pinnedSafeAppIds,
    togglePin,

    customSafeApps,
    customSafeAppsLoading,
    addCustomApp,
    removeCustomApp,
  }
}

export { useSafeApps }
</file>

<file path="src/hooks/safe-apps/useSafeAppsFilters.ts">
import useCategoryFilter from '@/hooks/safe-apps/useCategoryFilter'
import { useEffect, useState } from 'react'
import type { Dispatch, SetStateAction } from 'react'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import { useAppsFilterByCategory } from './useAppsFilterByCategory'
import { useAppsSearch } from './useAppsSearch'
import { useAppsFilterByOptimizedForBatch } from './useAppsFilterByOptimizedForBatch'
import useDebounce from '../useDebounce'
import { SAFE_APPS_EVENTS, trackSafeAppEvent } from '@/services/analytics'

type ReturnType = {
  query: string
  setQuery: Dispatch<SetStateAction<string>>
  selectedCategories: string[]
  setSelectedCategories: (categories: string[]) => void
  optimizedWithBatchFilter: boolean
  setOptimizedWithBatchFilter: Dispatch<SetStateAction<boolean>>
  filteredApps: SafeAppData[]
}

const useSafeAppsFilters = (safeAppsList: SafeAppData[]): ReturnType => {
  const [query, setQuery] = useState<string>('')
  const [selectedCategories, setSelectedCategories] = useState<string[]>([])
  const [optimizedWithBatchFilter, setOptimizedWithBatchFilter] = useState<boolean>(false)

  const filteredAppsByQuery = useAppsSearch(safeAppsList, query)
  const filteredAppsByQueryAndCategories = useAppsFilterByCategory(filteredAppsByQuery, selectedCategories)
  const filteredApps = useAppsFilterByOptimizedForBatch(filteredAppsByQueryAndCategories, optimizedWithBatchFilter)

  const { onSelectCategories } = useCategoryFilter({
    safeAppsList,
    selectedCategories,
    setSelectedCategories,
  })

  const debouncedSearchQuery = useDebounce(query, 2000)
  useEffect(() => {
    if (debouncedSearchQuery) {
      trackSafeAppEvent({ ...SAFE_APPS_EVENTS.SEARCH, label: debouncedSearchQuery })
    }
  }, [debouncedSearchQuery])

  return {
    query,
    setQuery,

    selectedCategories,
    setSelectedCategories: onSelectCategories,

    optimizedWithBatchFilter,
    setOptimizedWithBatchFilter,

    filteredApps,
  }
}

export default useSafeAppsFilters
</file>

<file path="src/hooks/safe-apps/useSafeAppUrl.ts">
import { useRouter } from 'next/router'
import { sanitizeUrl } from '@/utils/url'
import { useEffect, useMemo, useState } from 'react'

const useSafeAppUrl = (): string | undefined => {
  const router = useRouter()
  const [appUrl, setAppUrl] = useState<string | undefined>()

  useEffect(() => {
    if (!router.isReady) return
    setAppUrl(router.query.appUrl?.toString())
  }, [router])

  return useMemo(() => (appUrl ? sanitizeUrl(appUrl) : undefined), [appUrl])
}

export { useSafeAppUrl }
</file>

<file path="src/hooks/safe-apps/useTxBuilderApp.ts">
import { useRouter } from 'next/router'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import type { UrlObject } from 'url'

import { SafeAppsTag } from '@/config/constants'
import { AppRoutes } from '@/config/routes'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'

export const useTxBuilderApp = (): { app?: SafeAppData; link: UrlObject } | undefined => {
  const [matchingApps] = useRemoteSafeApps({ tag: SafeAppsTag.TX_BUILDER })
  const router = useRouter()
  const app = matchingApps?.[0]

  if (!app) {
    return undefined
  }

  return {
    app,
    link: {
      pathname: AppRoutes.apps.open,
      query: { safe: router.query.safe, appUrl: app?.url },
    },
  }
}
</file>

<file path="src/hooks/useMnemonicName/dict.ts">
export const adjectivesDict = `
admirable
energetic
lucky
affable
enjoyable
magnificent
affectionate
enthusiastic
marvelous
agreeable
euphoric
meritorious
amazing
excellent
merry
amiable
exceptional
amused
excited
nice
amusing
extraordinary
noble
animated
exultant
outstanding
appreciative
fabulous
overjoyed
astonishing
faithful
passionate
authentic
fantastic
peaceful
believable
fervent
placid
benevolent
fortunate
pleasant
blissful
friendly
pleasing
bouncy
fun
pleasurable
brilliant
genuine
positive
bubbly
glad
praiseworthy
buoyant
glorious
prominent
calm
good
proud
charming
relaxed
cheerful
reliable
cheery
gracious
respectable
clever
grateful
sharp
comfortable
great
sincere
comical
happy
spirited
commendable
heartfelt
splendid
confident
honest
superb
congenial
honorable
superior
content
hopeful
terrific
cordial
humorous
thankful
courteous
incredible
tremendous
dedicated
inspirational
triumphant
delighted
jolly
trustworthy
delightful
jovial
trusty
dependable
joyful
truthful
devoted
joyous
uplifting
docile
jubilant
victorious
dynamic
keen
vigorous
eager
kind
virtuous
earnest
laudable
vivacious
easygoing
laughing
whimsical
ebullient
likable
witty
ecstatic
lively
wonderful
elated
lovely
worthy
emphatic
loving
zealous
enchanting
loyal
zestful
`
</file>

<file path="src/hooks/useMnemonicName/index.ts">
import { useMemo } from 'react'
import { useCurrentChain } from '@/hooks/useChains'
import { adjectivesDict } from './dict'

const adjectives: string[] = adjectivesDict.trim().split(/\s+/)

export const capitalize = (word: string) => (word.length > 0 ? `${word.charAt(0).toUpperCase()}${word.slice(1)}` : word)

const getRandomItem = <T>(arr: T[]): T => {
  return arr[Math.floor(arr.length * Math.random())]
}

export const getRandomAdjective = (): string => {
  return capitalize(getRandomItem<string>(adjectives))
}

export function useMnemonicPrefixedSafeName(prefix?: string): string {
  const currentNetwork = useCurrentChain()?.chainName
  const adjective = useMemo(() => getRandomAdjective(), [])
  return `${adjective} ${prefix ?? currentNetwork} Safe`
}

export const useMnemonicSafeName = (multiChain?: boolean): string => {
  return useMnemonicPrefixedSafeName(multiChain ? 'Multi-Chain' : undefined)
}
</file>

<file path="src/hooks/wallets/consts.ts">
export const enum WALLET_KEYS {
  INJECTED = 'INJECTED',
  WALLETCONNECT_V2 = 'WALLETCONNECT_V2',
  COINBASE = 'COINBASE',
  LEDGER = 'LEDGER',
  TREZOR = 'TREZOR',
  KEYSTONE = 'KEYSTONE',
  PK = 'PRIVATE KEY',
}

// TODO: Check if undefined is needed as a return type, possibly couple this with WALLET_MODULES
export const CGW_NAMES: { [_key in WALLET_KEYS]: string | undefined } = {
  [WALLET_KEYS.INJECTED]: 'detectedwallet',
  [WALLET_KEYS.WALLETCONNECT_V2]: 'walletConnect_v2',
  [WALLET_KEYS.COINBASE]: 'coinbase',
  [WALLET_KEYS.LEDGER]: 'ledger',
  [WALLET_KEYS.TREZOR]: 'trezor',
  [WALLET_KEYS.KEYSTONE]: 'keystone',
  [WALLET_KEYS.PK]: 'pk',
}
</file>

<file path="src/hooks/wallets/useInitWeb3.ts">
import { useEffect } from 'react'

import { useCurrentChain } from '@/hooks/useChains'
import useWallet from '@/hooks/wallets/useWallet'
import { createWeb3, createWeb3ReadOnly, setWeb3, setWeb3ReadOnly } from '@/hooks/wallets/web3'
import { useAppSelector } from '@/store'
import { selectRpc } from '@/store/settingsSlice'

export const useInitWeb3 = () => {
  const chain = useCurrentChain()
  const chainId = chain?.chainId
  const wallet = useWallet()
  const customRpc = useAppSelector(selectRpc)
  const customRpcUrl = chain ? customRpc?.[chain.chainId] : undefined

  useEffect(() => {
    if (wallet && wallet.chainId === chainId) {
      const web3 = createWeb3(wallet.provider)
      setWeb3(web3)
    } else {
      setWeb3(undefined)
    }
  }, [wallet, chainId])

  useEffect(() => {
    if (!chain) {
      setWeb3ReadOnly(undefined)
      return
    }
    const web3ReadOnly = createWeb3ReadOnly(chain, customRpcUrl)
    setWeb3ReadOnly(web3ReadOnly)
  }, [chain, customRpcUrl])
}
</file>

<file path="src/hooks/wallets/useOnboard.ts">
import { useEffect } from 'react'
import { type WalletState, type OnboardAPI } from '@web3-onboard/core'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { Eip1193Provider } from 'ethers'
import { getAddress } from 'ethers'
import useChains, { useCurrentChain } from '@/hooks/useChains'
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import { logError, Errors } from '@/services/exceptions'
import { trackEvent, WALLET_EVENTS } from '@/services/analytics'
import { useAppSelector, useAppDispatch } from '@/store'
import { selectRpc } from '@/store/settingsSlice'
import { formatAmount } from '@safe-global/utils/utils/formatNumber'
import { localItem } from '@/services/local-storage/local'
import { isWalletConnect, isWalletUnlocked } from '@/utils/wallets'
import { setUnauthenticated } from '@/store/authSlice'
import type { EnvState } from '@safe-global/store/settingsSlice'

export type ConnectedWallet = {
  label: string
  chainId: string
  address: string
  ens?: string
  provider: Eip1193Provider
  icon?: string
  balance?: string
  isProposer?: boolean
}

const { getStore, setStore, useStore } = new ExternalStore<OnboardAPI>()

export const initOnboard = async (
  chainConfigs: ChainInfo[],
  currentChain: ChainInfo,
  rpcConfig: EnvState['rpc'] | undefined,
) => {
  const { createOnboard } = await import('@/services/onboard')
  if (!getStore()) {
    setStore(createOnboard(chainConfigs, currentChain, rpcConfig))
  }
}

// Get the most recently connected wallet address
export const getConnectedWallet = (wallets: WalletState[]): ConnectedWallet | null => {
  if (!wallets) return null

  const primaryWallet = wallets[0]
  if (!primaryWallet) return null

  const account = primaryWallet.accounts[0]
  if (!account) return null

  let balance = ''
  if (account.balance) {
    const tokenBalance = Object.entries(account.balance)[0]
    const token = tokenBalance?.[0] || ''
    const balanceString = tokenBalance?.[1] || ''
    const balanceNumber = parseFloat(balanceString)
    if (Number.isNaN(balanceNumber)) {
      balance = balanceString
    } else {
      const balanceFormatted = formatAmount(balanceNumber)
      balance = `${balanceFormatted} ${token}`
    }
  }

  try {
    const address = getAddress(account.address)
    return {
      label: primaryWallet.label,
      address,
      ens: account.ens?.name,
      chainId: Number(primaryWallet.chains[0].id).toString(10),
      provider: primaryWallet.provider,
      icon: primaryWallet.icon,
      balance,
      isProposer: false,
    }
  } catch (e) {
    logError(Errors._106, e)
    return null
  }
}

export const getWalletConnectLabel = (wallet: ConnectedWallet): string | undefined => {
  const UNKNOWN_PEER = 'Unknown'
  if (!isWalletConnect(wallet)) return
  const { connector } = wallet.provider as unknown as any
  const peerWalletV2 = connector.session?.peer?.metadata?.name
  return peerWalletV2 || UNKNOWN_PEER
}

const trackWalletType = (wallet: ConnectedWallet) => {
  trackEvent({ ...WALLET_EVENTS.CONNECT, label: wallet.label })

  const wcLabel = getWalletConnectLabel(wallet)
  if (wcLabel) {
    trackEvent({
      ...WALLET_EVENTS.WALLET_CONNECT,
      label: wcLabel,
    })
  }
}

let isConnecting = false

// Wrapper that tracks/sets the last used wallet
export const connectWallet = async (
  onboard: OnboardAPI,
  options?: Parameters<OnboardAPI['connectWallet']>[0],
): Promise<WalletState[] | undefined> => {
  if (isConnecting) {
    return
  }

  isConnecting = true

  let wallets: WalletState[] | undefined

  try {
    wallets = await onboard.connectWallet(options)
  } catch (e) {
    logError(Errors._107, e)
    isConnecting = false

    return
  }

  isConnecting = false

  return wallets
}

export const switchWallet = async (onboard: OnboardAPI) => {
  await connectWallet(onboard)
}

const lastWalletStorage = localItem<string>('lastWallet')

const connectLastWallet = async (onboard: OnboardAPI) => {
  const lastWalletLabel = lastWalletStorage.get()
  if (lastWalletLabel) {
    const isUnlocked = await isWalletUnlocked(lastWalletLabel)

    if (isUnlocked === true || isUnlocked === undefined) {
      connectWallet(onboard, {
        autoSelect: { label: lastWalletLabel, disableModals: isUnlocked || false },
      })
    }
  }
}

const saveLastWallet = (walletLabel: string) => {
  lastWalletStorage.set(walletLabel)
}

// Disable/enable wallets according to chain
export const useInitOnboard = () => {
  const { configs } = useChains()
  const chain = useCurrentChain()
  const onboard = useStore()
  const customRpc = useAppSelector(selectRpc)
  const dispatch = useAppDispatch()

  useEffect(() => {
    if (configs.length > 0 && chain) {
      void initOnboard(configs, chain, customRpc)
    }
  }, [configs, chain, customRpc])

  // Disable unsupported wallets on the current chain
  useEffect(() => {
    if (!onboard || !chain) return

    const enableWallets = async () => {
      const { getSupportedWallets } = await import('@/hooks/wallets/wallets')
      const supportedWallets = getSupportedWallets(chain)
      onboard.state.actions.setWalletModules(supportedWallets)
    }

    enableWallets().then(() => {
      // Reconnect last wallet
      connectLastWallet(onboard)
    })
  }, [chain, onboard])

  // Track connected wallet
  useEffect(() => {
    let lastConnectedWallet = ''
    if (!onboard) return

    const walletSubscription = onboard.state.select('wallets').subscribe((wallets) => {
      const newWallet = getConnectedWallet(wallets)
      if (newWallet) {
        if (newWallet.label !== lastConnectedWallet) {
          lastConnectedWallet = newWallet.label
          saveLastWallet(lastConnectedWallet)
          trackWalletType(newWallet)
        }
      } else if (lastConnectedWallet) {
        lastConnectedWallet = ''
        saveLastWallet(lastConnectedWallet)
        dispatch(setUnauthenticated())
      }
    })

    return () => {
      walletSubscription.unsubscribe()
    }
  }, [onboard, dispatch])
}

export default useStore
</file>

<file path="src/hooks/wallets/useWallet.ts">
import { useContext } from 'react'
import { type ConnectedWallet } from './useOnboard'
import { WalletContext } from '@/components/common/WalletProvider'

const useWallet = (): ConnectedWallet | null => {
  return useContext(WalletContext)?.connectedWallet ?? null
}

export const useSigner = () => {
  return useContext(WalletContext)?.signer ?? null
}

export const useWalletContext = () => {
  return useContext(WalletContext)
}

export default useWallet
</file>

<file path="src/hooks/wallets/useWalletBalance.ts">
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import useWallet from './useWallet'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'

const useWalletBalance = (): AsyncResult<bigint | undefined> => {
  const web3ReadOnly = useWeb3ReadOnly()
  const wallet = useWallet()

  return useAsync<bigint | undefined>(async () => {
    if (!wallet || !web3ReadOnly) {
      return undefined
    }

    const balance = await web3ReadOnly.getBalance(wallet.address, 'latest')
    return balance
  }, [wallet, web3ReadOnly])
}

export default useWalletBalance
</file>

<file path="src/hooks/wallets/wallets.ts">
import { WC_PROJECT_ID } from '@/config/constants'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { InitOptions } from '@web3-onboard/core'
import coinbaseModule from '@web3-onboard/coinbase'
import injectedWalletModule from '@web3-onboard/injected-wallets'
import walletConnect from '@web3-onboard/walletconnect'
import pkModule from '@/services/private-key-module'
import { ledgerModule } from '@/services/onboard/ledger-module'

import { CGW_NAMES, WALLET_KEYS } from './consts'

const prefersDarkMode = (): boolean => {
  return window?.matchMedia('(prefers-color-scheme: dark)')?.matches
}

type WalletInits = InitOptions['wallets']
type WalletInit = WalletInits extends Array<infer U> ? U : never

const walletConnectV2 = (chain: ChainInfo) => {
  // WalletConnect v2 requires a project ID
  if (!WC_PROJECT_ID) {
    return () => null
  }

  return walletConnect({
    version: 2,
    projectId: WC_PROJECT_ID,
    qrModalOptions: {
      themeVariables: {
        '--wcm-z-index': '1302',
      },
      themeMode: prefersDarkMode() ? 'dark' : 'light',
    },
    requiredChains: [parseInt(chain.chainId)],
    dappUrl: location.origin,
  })
}

const WALLET_MODULES: Partial<{ [_key in WALLET_KEYS]: (chain: ChainInfo) => WalletInit }> = {
  [WALLET_KEYS.INJECTED]: () => injectedWalletModule() as WalletInit,
  [WALLET_KEYS.WALLETCONNECT_V2]: (chain) => walletConnectV2(chain) as WalletInit,
  [WALLET_KEYS.COINBASE]: () => coinbaseModule({ darkMode: prefersDarkMode() }) as WalletInit,
  [WALLET_KEYS.LEDGER]: () => ledgerModule(),
  [WALLET_KEYS.PK]: (chain) => pkModule(chain.chainId, chain.rpcUri) as WalletInit,
}

export const getAllWallets = (chain: ChainInfo): WalletInits => {
  return Object.values(WALLET_MODULES).map((module) => module(chain))
}

export const isWalletSupported = (disabledWallets: string[], walletLabel: string): boolean => {
  const legacyWalletName = CGW_NAMES?.[walletLabel.toUpperCase() as WALLET_KEYS]
  return !disabledWallets.includes(legacyWalletName || walletLabel)
}

export const getSupportedWallets = (chain: ChainInfo): WalletInits => {
  const enabledWallets = Object.entries(WALLET_MODULES).filter(([key]) => isWalletSupported(chain.disabledWallets, key))

  if (enabledWallets.length === 0) {
    return [injectedWalletModule()]
  }

  return enabledWallets.map(([, module]) => module(chain))
}
</file>

<file path="src/hooks/wallets/web3.ts">
import { type ChainInfo, RPC_AUTHENTICATION, type RpcUri } from '@safe-global/safe-gateway-typescript-sdk'
import { JsonRpcProvider, BrowserProvider, type Eip1193Provider } from 'ethers'
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import { INFURA_TOKEN, SAFE_APPS_INFURA_TOKEN } from '@safe-global/utils/config/constants'

/**
 * Infura and other RPC providers limit the max amount included in a batch RPC call.
 * Ethers uses 100 by default which is too high for i.e. Infura.
 *
 * Some networks like Scroll only support a batch size of 3.
 */
const BATCH_MAX_COUNT = 3

// RPC helpers
const formatRpcServiceUrl = ({ authentication, value }: RpcUri, token: string): string => {
  const needsToken = authentication === RPC_AUTHENTICATION.API_KEY_PATH

  if (needsToken && !token) {
    console.warn('Infura token not set in .env')
    return ''
  }

  return needsToken ? `${value}${token}` : value
}

export const getRpcServiceUrl = (rpcUri: RpcUri): string => {
  return formatRpcServiceUrl(rpcUri, INFURA_TOKEN)
}

export const createWeb3ReadOnly = (chain: ChainInfo, customRpc?: string): JsonRpcProvider | undefined => {
  const url = customRpc || getRpcServiceUrl(chain.rpcUri)
  if (!url) return
  return new JsonRpcProvider(url, Number(chain.chainId), {
    staticNetwork: true,
    batchMaxCount: BATCH_MAX_COUNT,
  })
}

export const createWeb3 = (walletProvider: Eip1193Provider): BrowserProvider => {
  return new BrowserProvider(walletProvider)
}

export const createSafeAppsWeb3Provider = (chain: ChainInfo, customRpc?: string): JsonRpcProvider | undefined => {
  const url = customRpc || formatRpcServiceUrl(chain.rpcUri, SAFE_APPS_INFURA_TOKEN)
  if (!url) return
  return new JsonRpcProvider(url, undefined, {
    staticNetwork: true,
    batchMaxCount: BATCH_MAX_COUNT,
  })
}

export const { setStore: setWeb3, useStore: useWeb3 } = new ExternalStore<BrowserProvider>()

export const {
  getStore: getWeb3ReadOnly,
  setStore: setWeb3ReadOnly,
  useStore: useWeb3ReadOnly,
} = new ExternalStore<JsonRpcProvider>()

export const getUserNonce = async (userAddress: string): Promise<number> => {
  const web3 = getWeb3ReadOnly()
  if (!web3) return -1
  try {
    return await web3.getTransactionCount(userAddress, 'pending')
  } catch (error) {
    return Promise.reject(error)
  }
}
</file>

<file path="src/hooks/useAddressBook.ts">
import { useAppSelector } from '@/store'
import { selectAddressBookByChain } from '@/store/addressBookSlice'
import useChainId from './useChainId'

const useAddressBook = () => {
  const chainId = useChainId()
  return useAppSelector((state) => selectAddressBookByChain(state, chainId))
}

export default useAddressBook
</file>

<file path="src/hooks/useAddressResolver.ts">
import useAddressBook from '@/hooks/useAddressBook'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { lookupAddress } from '@/services/ens'
import { useMemo } from 'react'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useDebounce from './useDebounce'
import { useHasFeature } from './useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'

export const useAddressResolver = (address: string) => {
  const addressBook = useAddressBook()
  const ethersProvider = useWeb3ReadOnly()
  const debouncedValue = useDebounce(address, 200)
  const addressBookName = addressBook[address]
  const isDomainLookupEnabled = useHasFeature(FEATURES.DOMAIN_LOOKUP)
  const shouldResolve = !addressBookName && isDomainLookupEnabled && !!ethersProvider && !!debouncedValue

  const [ens, _, isResolving] = useAsync<string | undefined>(() => {
    if (!shouldResolve) return
    return lookupAddress(ethersProvider, debouncedValue)
  }, [ethersProvider, debouncedValue, shouldResolve])

  const resolving = shouldResolve && isResolving

  return useMemo(
    () => ({
      ens,
      name: addressBookName,
      resolving,
    }),
    [ens, addressBookName, resolving],
  )
}
</file>

<file path="src/hooks/useAdjustUrl.ts">
import { useEffect } from 'react'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'

const SAFE_ROUTES = [
  AppRoutes.balances.index,
  AppRoutes.balances.nfts,
  AppRoutes.home,
  AppRoutes.settings.modules,
  AppRoutes.settings.setup,
  AppRoutes.swap,
  AppRoutes.transactions.index,
  AppRoutes.transactions.history,
  AppRoutes.transactions.messages,
  AppRoutes.transactions.queue,
  AppRoutes.transactions.tx,
]

// Replace %3A with : in the ?safe= parameter
// Redirect to index if a required safe parameter is missing
const useAdjustUrl = () => {
  const router = useRouter()

  useEffect(() => {
    const { asPath, isReady, query, pathname } = router

    const newPath = asPath.replace(/([?&]safe=.+?)%3A(?=0x)/g, '$1:')
    if (newPath !== asPath) {
      history.replaceState(history.state, '', newPath)
      return
    }

    if (isReady && !query.safe && SAFE_ROUTES.includes(pathname)) {
      router.replace({ pathname: AppRoutes.index })
    }
  }, [router])
}

export default useAdjustUrl
</file>

<file path="src/hooks/useAllAddressBooks.ts">
import { useAppSelector } from '@/store'
import { selectAllAddressBooks } from '@/store/addressBookSlice'

const useAllAddressBooks = () => {
  return useAppSelector(selectAllAddressBooks)
}

export default useAllAddressBooks
</file>

<file path="src/hooks/useBalances.ts">
import { useMemo } from 'react'
import isEqual from 'lodash/isEqual'
import { useAppSelector } from '@/store'
import { selectBalances } from '@/store/balancesSlice'
import type { Balances } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

const useBalances = (): {
  balances: Balances
  loading: boolean
  error?: string
} => {
  const state = useAppSelector(selectBalances, isEqual)
  const { data, error, loading } = state

  return useMemo(
    () => ({
      balances: data,
      error,
      loading,
    }),
    [data, error, loading],
  )
}

export default useBalances
</file>

<file path="src/hooks/useBatchedTxs.ts">
import type { Transaction, TransactionListItem } from '@safe-global/safe-gateway-typescript-sdk'
import { isMultisigExecutionInfo, isTransactionListItem } from '@/utils/transaction-guards'
import { useMemo } from 'react'
import useSafeInfo from '@/hooks/useSafeInfo'
import { groupConflictingTxs } from '@/utils/tx-list'

const BATCH_LIMIT = 20

export const getBatchableTransactions = (items: TransactionListItem[], nonce: number) => {
  const batchableTransactions: Transaction[] = []
  let currentNonce = nonce

  const grouped = groupConflictingTxs(items)
    .map((item) => {
      if (Array.isArray(item)) return item
      if (isTransactionListItem(item)) return [item]
    })
    .filter(Boolean) as Transaction[][]

  grouped.forEach((txs) => {
    const sorted = txs.slice().sort((a, b) => b.transaction.timestamp - a.transaction.timestamp)
    sorted.forEach((tx) => {
      if (!isMultisigExecutionInfo(tx.transaction.executionInfo)) return

      const { nonce, confirmationsSubmitted, confirmationsRequired } = tx.transaction.executionInfo
      if (
        batchableTransactions.length < BATCH_LIMIT &&
        nonce === currentNonce &&
        confirmationsSubmitted >= confirmationsRequired
      ) {
        batchableTransactions.push(tx)
        currentNonce = nonce + 1
      }
    })
  })

  return batchableTransactions
}

const useBatchedTxs = (items: TransactionListItem[]) => {
  const { safe } = useSafeInfo()
  const currentNonce = safe.nonce

  return useMemo(() => getBatchableTransactions(items, currentNonce), [currentNonce, items])
}

export default useBatchedTxs
</file>

<file path="src/hooks/useChainId.ts">
import { useParams } from 'next/navigation'
import { parse, type ParsedUrlQuery } from 'querystring'
import { DEFAULT_CHAIN_ID } from '@/config/constants'
import chains from '@/config/chains'
import { parsePrefixedAddress } from '@safe-global/utils/utils/addresses'
import useWallet from './wallets/useWallet'
import useChains from './useChains'

// Use the location object directly because Next.js's router.query is available only on mount
const getLocationQuery = (): ParsedUrlQuery => {
  if (typeof location === 'undefined') return {}
  const query = parse(location.search.slice(1))
  return query
}

export const useUrlChainId = (): string | undefined => {
  const queryParams = useParams()
  const { configs } = useChains()

  // Dynamic query params
  const query = queryParams && (queryParams.safe || queryParams.chain) ? queryParams : getLocationQuery()
  const chain = query.chain?.toString() || ''
  const safe = query.safe?.toString() || ''

  const { prefix } = parsePrefixedAddress(safe)
  const shortName = prefix || chain

  if (!shortName) return undefined

  return chains[shortName] || configs.find((item) => item.shortName === shortName)?.chainId
}

const useWalletChainId = (): string | undefined => {
  const wallet = useWallet()
  const { configs } = useChains()
  const walletChainId =
    wallet?.chainId && configs.some(({ chainId }) => chainId === wallet.chainId) ? wallet.chainId : undefined
  return walletChainId
}

export const useChainId = (): string => {
  const urlChainId = useUrlChainId()
  const walletChainId = useWalletChainId()

  return urlChainId || walletChainId || String(DEFAULT_CHAIN_ID)
}

export default useChainId
</file>

<file path="src/hooks/useChains.ts">
import { useMemo } from 'react'
import isEqual from 'lodash/isEqual'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { useAppSelector } from '@/store'
import { selectChainById, selectChains } from '@/store/chainsSlice'
import { useChainId } from './useChainId'
import type { FEATURES } from '@safe-global/utils/utils/chains'
import { hasFeature } from '@safe-global/utils/utils/chains'

const useChains = (): { configs: ChainInfo[]; error?: string; loading?: boolean } => {
  const state = useAppSelector(selectChains, isEqual)

  return useMemo(
    () => ({
      configs: state.data,
      error: state.error,
      loading: state.loading,
    }),
    [state.data, state.error, state.loading],
  )
}

export default useChains

export const useChain = (chainId: string): ChainInfo | undefined => {
  return useAppSelector((state) => selectChainById(state, chainId), isEqual)
}

export const useCurrentChain = (): ChainInfo | undefined => {
  const chainId = useChainId()
  const chainInfo = useAppSelector((state) => selectChainById(state, chainId), isEqual)
  return chainInfo
}

/**
 * Checks if a feature is enabled on the current chain.
 *
 * @param feature name of the feature to check for
 * @returns `true`, if the feature is enabled on the current chain. Otherwise `false`
 */
export const useHasFeature = (feature: FEATURES): boolean | undefined => {
  const currentChain = useCurrentChain()
  return currentChain ? hasFeature(currentChain, feature) : undefined
}
</file>

<file path="src/hooks/useChangedValue.ts">
import { useEffect, useState } from 'react'

// Return the value only if it has been previously set to a non-falsy value
const useChangedValue = <T>(value: T): T | undefined => {
  const [_, setPrevValue] = useState<T>(value)
  const [newValue, setNewValue] = useState<T>()

  useEffect(() => {
    setPrevValue((prev) => {
      if (prev) {
        setNewValue(value)
      }
      return value
    })
  }, [value])

  return newValue
}

export default useChangedValue
</file>

<file path="src/hooks/useClock.ts">
import { useState, useEffect } from 'react'

export function useClock(interval = 1_000): number {
  const [timestamp, setTimestamp] = useState(Date.now())

  useEffect(() => {
    const timeout = setInterval(() => {
      setTimestamp((prev) => prev + interval)
    }, interval)

    return () => {
      clearInterval(timeout)
    }
  }, [interval])

  return timestamp
}
</file>

<file path="src/hooks/useCollectibles.ts">
import { useEffect } from 'react'
import { getCollectiblesPage, type SafeCollectiblesPage } from '@safe-global/safe-gateway-typescript-sdk'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { Errors, logError } from '@/services/exceptions'
import useSafeInfo from './useSafeInfo'

export const useCollectibles = (pageUrl?: string): AsyncResult<SafeCollectiblesPage> => {
  const { safe, safeAddress } = useSafeInfo()

  const [data, error, loading] = useAsync<SafeCollectiblesPage>(() => {
    if (!safeAddress) return
    if (!safe.deployed) return Promise.resolve({ results: [] })

    return getCollectiblesPage(safe.chainId, safeAddress, undefined, pageUrl)
  }, [safeAddress, safe.chainId, pageUrl, safe.deployed])

  // Log errors
  useEffect(() => {
    if (error) {
      logError(Errors._604, error.message)
    }
  }, [error])

  return [data, error, loading || !safeAddress]
}

export default useCollectibles
</file>

<file path="src/hooks/useCompatibilityFallbackHandlerDeployments.ts">
import { getCompatibilityFallbackHandlerDeployments } from '@safe-global/safe-deployments'
import { useMemo } from 'react'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useCurrentChain } from '@/hooks/useChains'

/**
 * Hook to get the compatibility fallback handler deployments for the current Safe version and network
 * @returns The compatibility fallback handler deployments or undefined if the Safe version or chain is not set
 */
export const useCompatibilityFallbackHandlerDeployments = () => {
  const { safe } = useSafeInfo()
  const chain = useCurrentChain()

  return useMemo(() => {
    if (!chain?.chainId || !safe.version) return undefined
    return getCompatibilityFallbackHandlerDeployments({ network: chain?.chainId, version: safe.version })
  }, [safe.version, chain?.chainId])
}
</file>

<file path="src/hooks/useDarkMode.ts">
import { useEffect, useState } from 'react'
import { useAppSelector } from '@/store'
import { selectSettings } from '@/store/settingsSlice'

const isSystemDarkMode = (): boolean => {
  if (typeof window === 'undefined' || !window.matchMedia) return false
  return window.matchMedia('(prefers-color-scheme: dark)').matches
}

export const useDarkMode = (): boolean => {
  const settings = useAppSelector(selectSettings)
  const [isDarkMode, setIsDarkMode] = useState<boolean>(false)

  useEffect(() => {
    const isDark = settings.theme.darkMode ?? isSystemDarkMode()

    setIsDarkMode(isDark)
    document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light')
  }, [settings.theme.darkMode])

  return isDarkMode
}
</file>

<file path="src/hooks/useDebounce.ts">
import { useEffect, useState } from 'react'

const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(timer)
  }, [value, delay])

  return debouncedValue
}

export default useDebounce
</file>

<file path="src/hooks/useDraftBatch.ts">
import { isMultisigExecutionInfo } from '@/utils/transaction-guards'
import { useCallback } from 'react'
import { useAppDispatch, useAppSelector } from '@/store'
import useChainId from './useChainId'
import useSafeAddress from './useSafeAddress'
import type { DraftBatchItem } from '@/store/batchSlice'
import { selectBatchBySafe, addTx, removeTx } from '@/store/batchSlice'
import { type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { BATCH_EVENTS, trackEvent } from '@/services/analytics'
import { txDispatch, TxEvent } from '@/services/tx/txEvents'
import { shallowEqual } from 'react-redux'

export const useUpdateBatch = () => {
  const chainId = useChainId()
  const safeAddress = useSafeAddress()
  const dispatch = useAppDispatch()

  const onAdd = useCallback(
    async (txDetails: TransactionDetails): Promise<void> => {
      dispatch(
        addTx({
          chainId,
          safeAddress,
          txDetails,
        }),
      )

      if (isMultisigExecutionInfo(txDetails.detailedExecutionInfo)) {
        txDispatch(TxEvent.BATCH_ADD, { txId: txDetails.txId, nonce: txDetails.detailedExecutionInfo.nonce })
      }

      trackEvent({ ...BATCH_EVENTS.BATCH_TX_APPENDED, label: txDetails.txInfo.type })
    },
    [dispatch, chainId, safeAddress],
  )

  const onDelete = useCallback(
    (id: DraftBatchItem['id']) => {
      dispatch(
        removeTx({
          chainId,
          safeAddress,
          id,
        }),
      )
    },
    [dispatch, chainId, safeAddress],
  )

  return [onAdd, onDelete] as const
}

export const useDraftBatch = (): DraftBatchItem[] => {
  const chainId = useChainId()
  const safeAddress = useSafeAddress()
  const batch = useAppSelector((state) => selectBatchBySafe(state, chainId, safeAddress), shallowEqual)
  return batch
}
</file>

<file path="src/hooks/useGasLimit.ts">
import { SafeProvider } from '@safe-global/protocol-kit'
import { useEffect } from 'react'
import type Safe from '@safe-global/protocol-kit'
import { encodeSignatures } from '@/services/tx/encodeSignatures'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import chains from '@/config/chains'
import { useSigner } from './wallets/useWallet'
import { useSafeSDK } from './coreSDK/safeCoreSDK'
import useIsSafeOwner from './useIsSafeOwner'
import { Errors, logError } from '@/services/exceptions'
import useSafeInfo from './useSafeInfo'
import { estimateTxBaseGas } from '@safe-global/protocol-kit/dist/src/utils/transactions/gas'
import {
  getCompatibilityFallbackHandlerContract,
  getSimulateTxAccessorContract,
} from '@safe-global/protocol-kit/dist/src/contracts/safeDeploymentContracts'
import { type JsonRpcProvider } from 'ethers'
import type { ExtendedSafeInfo } from '@safe-global/store/slices/SafeInfo/types'

const getEncodedSafeTx = (
  safeSDK: Safe,
  safeTx: SafeTransaction,
  from: string | undefined,
  needsSignature: boolean,
): string | undefined => {
  const EXEC_TX_METHOD = 'execTransaction'

  // @ts-ignore union type is too complex
  return safeSDK
    .getContractManager()
    .safeContract?.encode(EXEC_TX_METHOD, [
      safeTx.data.to,
      safeTx.data.value,
      safeTx.data.data,
      safeTx.data.operation,
      safeTx.data.safeTxGas,
      safeTx.data.baseGas,
      safeTx.data.gasPrice,
      safeTx.data.gasToken,
      safeTx.data.refundReceiver,
      encodeSignatures(safeTx, from, needsSignature),
    ])
}

const GasMultipliers = {
  [chains.gno]: 1.3,
  [chains.zksync]: 20,
}

const incrementByGasMultiplier = (value: bigint, multiplier: number) => {
  return (value * BigInt(100 * multiplier)) / BigInt(100)
}

/**
 * Estimates the gas limit for a transaction that will be executed on the zkSync network.
 *
 *  The rpc call for estimateGas is failing for the zkSync network, when the from address
 *  is a Safe. Quote from this discussion:
 *  https://github.com/zkSync-Community-Hub/zksync-developers/discussions/144
 *  ======================
 *  zkSync has native account abstraction and, under the hood, all accounts are a smart
 *  contract account. Even EOA use the DefaultAccount smart contract. All smart contract
 *  accounts on zkSync must be deployed using the createAccount or create2Account
 *  methods of the ContractDeployer system contract.
 *
 * When processing a transaction, the protocol checks the code of the from account and,
 * in this case, as Safe accounts are not deployed as native accounts on zkSync
 * (via createAccount or create2Account), it fails with the error above.
 * ======================
 *
 * We do some "magic" here by simulating the transaction on the SafeProxy contract
 *
 * @param safe
 * @param web3
 * @param safeSDK
 * @param safeTx
 */
const getGasLimitForZkSync = async (
  safe: ExtendedSafeInfo,
  web3: JsonRpcProvider,
  safeSDK: Safe,
  safeTx: SafeTransaction,
) => {
  // use a random EOA address as the from address
  // https://github.com/zkSync-Community-Hub/zksync-developers/discussions/144
  const fakeEOAFromAddress = '0x330d9F4906EDA1f73f668660d1946bea71f48827'
  const customContracts = safeSDK.getContractManager().contractNetworks?.[safe.chainId]
  const safeVersion = await safeSDK.getContractVersion()
  const safeProvider = new SafeProvider({ provider: web3._getConnection().url })
  const fallbackHandlerContract = await getCompatibilityFallbackHandlerContract({
    safeProvider,
    safeVersion,
    customContracts,
  })

  const simulateTxAccessorContract = await getSimulateTxAccessorContract({
    safeProvider,
    safeVersion,
    customContracts,
  })

  // 2. Add a simulate call to the predicted SafeProxy as second transaction
  const transactionDataToEstimate: string = simulateTxAccessorContract.encode('simulate', [
    safeTx.data.to,
    // @ts-ignore
    safeTx.data.value,
    safeTx.data.data,
    safeTx.data.operation,
  ])

  const safeFunctionToEstimate: string = fallbackHandlerContract.encode('simulate', [
    await simulateTxAccessorContract.getAddress(),
    transactionDataToEstimate,
  ])

  const gas = await web3.estimateGas({
    to: safe.address.value,
    from: fakeEOAFromAddress,
    value: '0',
    data: safeFunctionToEstimate,
  })

  // The estimateTxBaseGas function seems to estimate too low for zkSync
  const baseGas = incrementByGasMultiplier(
    BigInt(await estimateTxBaseGas(safeSDK, safeTx)),
    GasMultipliers[chains.zksync],
  )

  return BigInt(gas) + baseGas
}

const useGasLimit = (
  safeTx?: SafeTransaction,
): {
  gasLimit?: bigint
  gasLimitError?: Error
  gasLimitLoading: boolean
} => {
  const safeSDK = useSafeSDK()
  const web3ReadOnly = useWeb3ReadOnly()
  const { safe } = useSafeInfo()
  const safeAddress = safe.address.value
  const threshold = safe.threshold
  const wallet = useSigner()
  const walletAddress = wallet?.address
  const isOwner = useIsSafeOwner()
  const currentChainId = useChainId()
  const hasSafeTxGas = !!safeTx?.data?.safeTxGas

  const [gasLimit, gasLimitError, gasLimitLoading] = useAsync<bigint | undefined>(async () => {
    if (!safeAddress || !walletAddress || !safeSDK || !web3ReadOnly || !safeTx) return

    const encodedSafeTx = getEncodedSafeTx(
      safeSDK,
      safeTx,
      isOwner ? walletAddress : undefined,
      safeTx.signatures.size < threshold,
    )

    // if we are dealing with zksync and the walletAddress is a Safe, we have to do some magic
    // FIXME a new check to indicate ZKsync chain will be added to the config service and available under ChainInfo
    if (
      (safe.chainId === chains.zksync || safe.chainId === chains.lens) &&
      (await web3ReadOnly.getCode(walletAddress)) !== '0x'
    ) {
      return getGasLimitForZkSync(safe, web3ReadOnly, safeSDK, safeTx)
    }

    return web3ReadOnly
      .estimateGas({
        to: safeAddress,
        from: walletAddress,
        data: encodedSafeTx,
      })
      .then((gasLimit) => {
        // Due to a bug in Nethermind estimation, we need to increment the gasLimit by 30%
        // when the safeTxGas is defined and not 0. Currently Nethermind is used only for Gnosis Chain.
        if (currentChainId === chains.gno && hasSafeTxGas) {
          return incrementByGasMultiplier(gasLimit, GasMultipliers[chains.gno])
        }

        return gasLimit
      })
  }, [
    safeAddress,
    walletAddress,
    safeSDK,
    web3ReadOnly,
    safeTx,
    isOwner,
    currentChainId,
    hasSafeTxGas,
    threshold,
    safe,
  ])

  useEffect(() => {
    if (gasLimitError) {
      logError(Errors._612, gasLimitError.message)
    }
  }, [gasLimitError])

  return { gasLimit, gasLimitError, gasLimitLoading }
}

export default useGasLimit
</file>

<file path="src/hooks/useGasPrice.ts">
import { formatVisualAmount } from '@safe-global/utils/utils/formatters'
import { type FeeData } from 'ethers'
import type {
  ChainInfo,
  GasPrice,
  GasPriceFixed,
  GasPriceFixedEIP1559,
  GasPriceOracle,
} from '@safe-global/safe-gateway-typescript-sdk'
import { GAS_PRICE_TYPE } from '@safe-global/safe-gateway-typescript-sdk'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import { useCurrentChain } from './useChains'
import useIntervalCounter from './useIntervalCounter'
import { useWeb3ReadOnly } from '../hooks/wallets/web3'
import { Errors, logError } from '@/services/exceptions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

type EstimatedGasPrice =
  | {
      gasPrice: bigint
    }
  | {
      maxFeePerGas: bigint
      maxPriorityFeePerGas: bigint
    }

type GasFeeParams = {
  maxFeePerGas: bigint | null | undefined
  maxPriorityFeePerGas: bigint | null | undefined
}

// Update gas fees every 20 seconds
const REFRESH_DELAY = 20e3

type EtherscanResult = {
  LastBlock: string
  SafeGasPrice: string
  ProposeGasPrice: string
  FastGasPrice: string
  suggestBaseFee: string
  gasUsedRatio: string
}

const isEtherscanResult = (data: any): data is EtherscanResult => {
  return 'FastGasPrice' in data && 'suggestBaseFee' in data
}

/**
 * Parses result from etherscan oracle.
 * Since EIP 1559 it returns the `maxFeePerGas` as gas price and the current network baseFee as `suggestedBaseFee`.
 * The `maxPriorityFeePerGas` can then be computed as `maxFeePerGas` - `suggestedBaseFee`
 *
 * @param result {@link EtherscanResult}
 * @see https://docs.etherscan.io/api-endpoints/gas-tracker
 */
const parseEtherscanOracleResult = (result: EtherscanResult, gweiFactor: string): EstimatedGasPrice => {
  const maxFeePerGas = BigInt(Number(result.FastGasPrice) * Number(gweiFactor))
  const baseFee = BigInt(Number(result.suggestBaseFee) * Number(gweiFactor))

  return {
    maxFeePerGas,
    maxPriorityFeePerGas: maxFeePerGas - baseFee,
  }
}

// Loop over the oracles and return the first one that works.
// Or return a fixed value if specified.
// If none of them work, throw an error.
const fetchGasOracle = async (gasPriceOracle: GasPriceOracle): Promise<EstimatedGasPrice> => {
  const { uri, gasParameter, gweiFactor } = gasPriceOracle
  const response = await fetch(uri)
  if (!response.ok) {
    throw new Error(`Error fetching gas price from oracle ${uri}`)
  }

  const json = await response.json()
  const data = json.data || json.result || json

  if (isEtherscanResult(data)) {
    return parseEtherscanOracleResult(data, gweiFactor)
  }
  return { gasPrice: BigInt(data[gasParameter] * Number(gweiFactor)) }
}

// These typeguards are necessary because the GAS_PRICE_TYPE enum uses uppercase while the config service uses lowercase values
const isGasPriceFixed = (gasPriceConfig: GasPrice[number]): gasPriceConfig is GasPriceFixed => {
  return gasPriceConfig.type.toUpperCase() == GAS_PRICE_TYPE.FIXED
}

const isGasPriceFixed1559 = (gasPriceConfig: GasPrice[number]): gasPriceConfig is GasPriceFixedEIP1559 => {
  return gasPriceConfig.type.toUpperCase() == GAS_PRICE_TYPE.FIXED_1559
}

const isGasPriceOracle = (gasPriceConfig: GasPrice[number]): gasPriceConfig is GasPriceOracle => {
  return gasPriceConfig.type.toUpperCase() == GAS_PRICE_TYPE.ORACLE
}

const getGasPrice = async (gasPriceConfigs: GasPrice): Promise<EstimatedGasPrice | undefined> => {
  let error: Error | undefined
  for (const config of gasPriceConfigs) {
    if (isGasPriceFixed(config)) {
      return {
        gasPrice: BigInt(config.weiValue),
      }
    }

    if (isGasPriceFixed1559(config)) {
      return {
        maxFeePerGas: BigInt(config.maxFeePerGas),
        maxPriorityFeePerGas: BigInt(config.maxPriorityFeePerGas),
      }
    }

    if (isGasPriceOracle(config)) {
      try {
        return await fetchGasOracle(config)
      } catch (_err) {
        error = asError(_err)
        logError(Errors._611, error.message)
        // Continue to the next oracle
        continue
      }
    }
  }

  // If everything failed, throw the last error or return undefined
  if (error) {
    throw error
  }
}

const getGasParameters = (
  estimation: EstimatedGasPrice | undefined,
  feeData: FeeData | undefined,
  isEIP1559: boolean,
): GasFeeParams => {
  if (!estimation) {
    return {
      maxFeePerGas: isEIP1559 ? feeData?.maxFeePerGas : feeData?.gasPrice,
      maxPriorityFeePerGas: isEIP1559 ? feeData?.maxPriorityFeePerGas : undefined,
    }
  }

  if (isEIP1559 && 'maxFeePerGas' in estimation && 'maxPriorityFeePerGas' in estimation) {
    return estimation
  }

  if ('gasPrice' in estimation) {
    return {
      maxFeePerGas: estimation.gasPrice,
      maxPriorityFeePerGas: isEIP1559 ? feeData?.maxPriorityFeePerGas : undefined,
    }
  }

  return {
    maxFeePerGas: undefined,
    maxPriorityFeePerGas: undefined,
  }
}

export const getTotalFee = (maxFeePerGas: bigint, gasLimit: bigint | string | number) => {
  return maxFeePerGas * BigInt(gasLimit)
}

export const getTotalFeeFormatted = (
  maxFeePerGas: bigint | null | undefined,
  gasLimit: bigint | undefined,
  chain: ChainInfo | undefined,
) => {
  return gasLimit && maxFeePerGas
    ? formatVisualAmount(getTotalFee(maxFeePerGas, gasLimit), chain?.nativeCurrency.decimals)
    : '> 0.001'
}

const SPEED_UP_MAX_PRIO_FACTOR = 2n

const SPEED_UP_GAS_PRICE_FACTOR = 150n

/**
 * Estimates the gas price through the configured methods:
 * - Oracle
 * - Fixed gas prices
 * - Or using ethers' getFeeData
 *
 * @param isSpeedUp if true, increases the returned gas parameters
 * @returns [gasPrice, error, loading]
 */
const useGasPrice = (isSpeedUp: boolean = false): AsyncResult<GasFeeParams> => {
  const chain = useCurrentChain()
  const gasPriceConfigs = chain?.gasPrice
  const [counter] = useIntervalCounter(REFRESH_DELAY)
  const provider = useWeb3ReadOnly()
  const isEIP1559 = !!chain && hasFeature(chain, FEATURES.EIP1559)

  const [gasPrice, gasPriceError, gasPriceLoading] = useAsync(
    async () => {
      const [gasEstimation, feeData] = await Promise.all([
        // Fetch gas price from oracles or get a fixed value
        gasPriceConfigs ? getGasPrice(gasPriceConfigs) : undefined,

        // Fetch the gas fees from the blockchain itself
        provider?.getFeeData(),
      ])

      // Prepare the return values
      const gasParameters = getGasParameters(gasEstimation, feeData, isEIP1559)

      if (!isSpeedUp) {
        return gasParameters
      }

      if (isEIP1559 && gasParameters.maxFeePerGas && gasParameters.maxPriorityFeePerGas) {
        return {
          maxFeePerGas:
            gasParameters.maxFeePerGas +
            (gasParameters.maxPriorityFeePerGas * SPEED_UP_MAX_PRIO_FACTOR - gasParameters.maxPriorityFeePerGas),
          maxPriorityFeePerGas: gasParameters.maxPriorityFeePerGas * SPEED_UP_MAX_PRIO_FACTOR,
        }
      }

      return {
        maxFeePerGas: gasParameters.maxFeePerGas
          ? (gasParameters.maxFeePerGas * SPEED_UP_GAS_PRICE_FACTOR) / 100n
          : undefined,
        maxPriorityFeePerGas: undefined,
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [gasPriceConfigs, provider, counter, isEIP1559],
    false,
  )

  const isLoading = gasPriceLoading || (!gasPrice && !gasPriceError)

  return [gasPrice, gasPriceError, isLoading]
}

export default useGasPrice
</file>

<file path="src/hooks/useHiddenTokens.ts">
import { useAppSelector } from '@/store'
import { selectHiddenTokensPerChain } from '@/store/settingsSlice'
import useChainId from './useChainId'

const useHiddenTokens = () => {
  const chainId = useChainId()
  return useAppSelector((state) => selectHiddenTokensPerChain(state, chainId))
}

export default useHiddenTokens
</file>

<file path="src/hooks/useHighlightHiddenTab.ts">
import { useEffect } from 'react'

const ALT_FAVICON = '/favicons/favicon-dot.ico'
const TITLE_PREFIX = '‼️ '

const setFavicon = (favicon: HTMLLinkElement | null, href: string) => {
  if (favicon) favicon.href = href
}

const setDocumentTitle = (isPrefixed: boolean) => {
  document.title = isPrefixed ? TITLE_PREFIX + document.title : document.title.replace(TITLE_PREFIX, '')
}

const blinkFavicon = (
  favicon: HTMLLinkElement | null,
  originalHref: string,
  isBlinking = false,
): ReturnType<typeof setInterval> => {
  const onBlink = () => {
    setDocumentTitle(isBlinking)
    setFavicon(favicon, isBlinking ? ALT_FAVICON : originalHref)
    isBlinking = !isBlinking
  }

  onBlink()

  return setInterval(onBlink, 300)
}

/**
 * Blink favicon when the tab is hidden
 */
const useHighlightHiddenTab = () => {
  useEffect(() => {
    const favicon = document.querySelector<HTMLLinkElement>('link[rel*="icon"]')
    const originalHref = favicon?.href || ''
    let interval: ReturnType<typeof setInterval>

    const reset = () => {
      clearInterval(interval)
      setFavicon(favicon, originalHref)
      setDocumentTitle(false)
    }

    const handleVisibilityChange = () => {
      if (document.hidden) {
        interval = blinkFavicon(favicon, originalHref)
      } else {
        reset()
      }
    }

    document.addEventListener('visibilitychange', handleVisibilityChange)

    handleVisibilityChange()

    return () => {
      reset()
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [])
}

export default useHighlightHiddenTab
</file>

<file path="src/hooks/useInitSession.ts">
import { useAppDispatch } from '@/store'
import { setLastChainId, setLastSafeAddress } from '@/store/sessionSlice'
import { useEffect } from 'react'
import { useUrlChainId } from './useChainId'
import useSafeInfo from './useSafeInfo'

export const useInitSession = (): void => {
  const dispatch = useAppDispatch()
  const chainId = useUrlChainId()
  // N.B. only successfully loaded Safes, don't use useSafeAddress() here!
  const { safe, safeAddress } = useSafeInfo()

  useEffect(() => {
    if (chainId) {
      dispatch(setLastChainId(chainId))
    }
  }, [dispatch, chainId])

  useEffect(() => {
    if (!safeAddress) return

    dispatch(
      setLastSafeAddress({
        // This chainId isn't necessarily the same as the current chainId
        chainId: safe.chainId,
        safeAddress,
      }),
    )
  }, [dispatch, safe.chainId, safeAddress])
}
</file>

<file path="src/hooks/useIntervalCounter.ts">
import { useCallback, useEffect, useState } from 'react'

const useIntervalCounter = (interval: number): [number, () => void] => {
  const [counter, setCounter] = useState<number>(0)

  const resetCounter = useCallback(() => {
    setCounter(0)
  }, [setCounter])

  useEffect(() => {
    let reqFrameId: number
    const timerId = setTimeout(() => {
      // requestAnimationFrame prevents the timer from ticking in a background tab
      reqFrameId = requestAnimationFrame(() => {
        setCounter(counter + 1)
      })
    }, interval)
    return () => {
      clearTimeout(timerId)
      if (reqFrameId) {
        cancelAnimationFrame(reqFrameId)
      }
    }
  }, [counter, interval])

  return [counter, resetCounter]
}

export default useIntervalCounter
</file>

<file path="src/hooks/useIsGeoblockedFeatureEnabled.ts">
import { useContext } from 'react'

import { GeoblockingContext } from '@/components/common/GeoblockingProvider'
import { useHasFeature } from '@/hooks/useChains'

import type { FEATURES } from '@safe-global/utils/utils/chains'

// TODO: Refactor useIsStakingFeatureEnabled/useIsStakingFeatureEnabled to use this
export function useIsGeoblockedFeatureEnabled(feature: FEATURES): boolean | undefined {
  const isBlockedCountry = useContext(GeoblockingContext)
  return useHasFeature(feature) && !isBlockedCountry
}
</file>

<file path="src/hooks/useIsMac.ts">
import { useState, useEffect } from 'react'

export const useIsMac = (): boolean => {
  const [isMac, setIsMac] = useState(false)

  useEffect(() => {
    if (typeof navigator !== 'undefined') {
      setIsMac(navigator.userAgent.includes('Mac'))
    }
  }, [])

  return isMac
}
</file>

<file path="src/hooks/useIsNestedSafeOwner.ts">
import { useMemo } from 'react'
import { useNestedSafeOwners } from './useNestedSafeOwners'

export const useIsNestedSafeOwner = () => {
  const nestedOwners = useNestedSafeOwners()
  return useMemo(() => nestedOwners && nestedOwners.length > 0, [nestedOwners])
}
</file>

<file path="src/hooks/useIsOfficialFallbackHandler.ts">
import { useMemo } from 'react'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useCompatibilityFallbackHandlerDeployments } from '@/hooks/useCompatibilityFallbackHandlerDeployments'

/**
 * Hook to check if the Safe's fallback handler (or optionally a provided address) is an official one.
 * @param fallbackHandler Optional fallback handler address (if not provided, it will be taken from the Safe info)
 * @returns Boolean indicating if the provided fallback handler is an official fallback handler
 */
export const useIsOfficialFallbackHandler = (fallbackHandler?: string) => {
  const fallbackHandlerDeployments = useCompatibilityFallbackHandlerDeployments()
  const { safe } = useSafeInfo()

  const fallbackHandlerAddress = fallbackHandler || safe.fallbackHandler?.value

  return useMemo(
    () =>
      !!fallbackHandlerAddress &&
      !!fallbackHandlerDeployments?.networkAddresses[safe.chainId].includes(fallbackHandlerAddress),
    [fallbackHandlerAddress, safe.chainId, fallbackHandlerDeployments],
  )
}
</file>

<file path="src/hooks/useIsOfficialHost.ts">
import { useMemo } from 'react'
import { IPFS_HOSTS, IS_OFFICIAL_HOST, OFFICIAL_HOSTS } from '@/config/constants'
import packageJson from '../../package.json'
import useAsync from '@safe-global/utils/hooks/useAsync'

const GITHUB_API_URL = 'https://api.github.com/repos/5afe/safe-wallet-ipfs/releases/tags'

async function getGithubRelease(version: string) {
  const resp = await fetch(`${GITHUB_API_URL}/v${version}`, {
    headers: {
      Accept: 'application/vnd.github.v3+json',
    },
  })
  if (!resp.ok) return false
  return await resp.json()
}

async function isOfficialIpfs(): Promise<boolean> {
  const data = await getGithubRelease(packageJson.version)
  return data.body.includes(window.location.host)
}

function isIpfs() {
  return IPFS_HOSTS.test(window.location.host)
}

export const useIsOfficialHost = (): boolean => {
  const isOfficialHost = useMemo(
    () => IS_OFFICIAL_HOST && (typeof window === 'undefined' || OFFICIAL_HOSTS.test(window.location.host)),
    [],
  )

  const [isTrustedIpfs = false] = useAsync<boolean>(() => {
    if (isOfficialHost || !isIpfs()) return
    return isOfficialIpfs()
  }, [isOfficialHost])

  return isOfficialHost || isTrustedIpfs
}
</file>

<file path="src/hooks/useIsOnlySpendingLimitBeneficiary.tsx">
import { useIsWalletProposer } from '@/hooks/useProposers'
import { useAppSelector } from '@/store'
import { selectSpendingLimits } from '@/store/spendingLimitsSlice'
import useWallet from '@/hooks/wallets/useWallet'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useHasFeature } from './useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'

export const useIsSpendingLimitBeneficiary = (): boolean => {
  const isEnabled = useHasFeature(FEATURES.SPENDING_LIMIT)
  const spendingLimits = useAppSelector(selectSpendingLimits)
  const wallet = useWallet()

  if (!isEnabled || spendingLimits.length === 0) {
    return false
  }

  return spendingLimits.some(({ beneficiary }) => beneficiary === wallet?.address)
}

const useIsOnlySpendingLimitBeneficiary = (): boolean => {
  const isSpendingLimitBeneficiary = useIsSpendingLimitBeneficiary()
  const isSafeOwner = useIsSafeOwner()
  const isProposer = useIsWalletProposer()
  return !isSafeOwner && !isProposer && isSpendingLimitBeneficiary
}

export default useIsOnlySpendingLimitBeneficiary
</file>

<file path="src/hooks/useIsPending.ts">
import { useAppSelector } from '@/store'
import { selectPendingTxs } from '@/store/pendingTxsSlice'

const useIsPending = (txId: string): boolean => {
  const pendingTxs = useAppSelector(selectPendingTxs)
  return !!pendingTxs[txId]
}

export default useIsPending
</file>

<file path="src/hooks/useIsSafeOwner.ts">
import useSafeInfo from '@/hooks/useSafeInfo'
import { isOwner } from '@/utils/transaction-guards'
import { useSigner } from './wallets/useWallet'

const useIsSafeOwner = () => {
  const { safe } = useSafeInfo()
  const signer = useSigner()

  return isOwner(safe.owners, signer?.address)
}

export default useIsSafeOwner
</file>

<file path="src/hooks/useIsSidebarRoute.ts">
import { AppRoutes } from '@/config/routes'
import { useIsSpaceRoute } from '@/hooks/useIsSpaceRoute'
import { usePathname } from 'next/navigation'
import { useRouter } from 'next/router'

const NO_SIDEBAR_ROUTES = [
  AppRoutes.share.safeApp,
  AppRoutes.newSafe.create,
  AppRoutes.newSafe.load,
  AppRoutes.index,
  AppRoutes.welcome.index,
  AppRoutes.welcome.accounts,
  AppRoutes.welcome.spaces,
  AppRoutes.imprint,
  AppRoutes.privacy,
  AppRoutes.cookie,
  AppRoutes.terms,
  AppRoutes.licenses,
]

const TOGGLE_SIDEBAR_ROUTES = [AppRoutes.apps.open]

/**
 * Returns a boolean tuple indicating if the current route should display the sidebar and if the sidebar can be toggled
 * @param pathname Optional server-side pathname to check against
 * @returns A tuple with the first value indicating if the sidebar should be displayed and the second value indicating if the sidebar can be toggled
 */
export function useIsSidebarRoute(pathname?: string): [boolean, boolean] {
  const clientPathname = usePathname()
  const isSpaceRoute = useIsSpaceRoute()
  const route = pathname || clientPathname || ''
  const noSidebar = NO_SIDEBAR_ROUTES.includes(route)
  const toggledSidebar = TOGGLE_SIDEBAR_ROUTES.includes(route)
  const router = useRouter()
  const hasSafe = !router.isReady || !!router.query.safe

  const displaySidebar = (!noSidebar && hasSafe) || isSpaceRoute

  return [displaySidebar, toggledSidebar]
}
</file>

<file path="src/hooks/useIsSpaceRoute.ts">
import { usePathname } from 'next/navigation'
import { AppRoutes } from '@/config/routes'
import { useCurrentSpaceId } from '@/features/spaces/hooks/useCurrentSpaceId'

const SPACES_ROUTES = [
  AppRoutes.spaces.index,
  AppRoutes.spaces.settings,
  AppRoutes.spaces.members,
  AppRoutes.spaces.safeAccounts,
]

export const useIsSpaceRoute = (): boolean => {
  const clientPathname = usePathname()
  const route = clientPathname || ''
  const spaceId = useCurrentSpaceId()

  return SPACES_ROUTES.includes(route) && !!spaceId
}
</file>

<file path="src/hooks/useIsValidExecution.ts">
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import type { EthersError } from '@/utils/ethers-utils'

import useAsync from '@safe-global/utils/hooks/useAsync'
import ContractErrorCodes from '@/services/contracts/ContractErrorCodes'
import { type SafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { createWeb3, useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { type JsonRpcProvider } from 'ethers'
import { type ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { getCurrentGnosisSafeContract } from '@/services/contracts/safeContracts'
import useSafeInfo from '@/hooks/useSafeInfo'
import { useSigner } from '@/hooks/wallets/useWallet'
import { encodeSignatures } from '@/services/tx/encodeSignatures'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { type NestedWallet } from '@/utils/nested-safe-wallet'
import { assertProvider } from '@/utils/helpers'

const isContractError = (error: EthersError) => {
  if (!error.reason) return false

  return Object.keys(ContractErrorCodes).includes(error.reason)
}

// Monkey patch the signerProvider to proxy requests to the "readonly" provider if on the wrong chain
// This is ONLY used to check the validity of a transaction in `useIsValidExecution`
export const getPatchedSignerProvider = (
  wallet: ConnectedWallet | NestedWallet,
  chainId: SafeInfo['chainId'],
  readOnlyProvider: JsonRpcProvider,
) => {
  assertProvider(wallet.provider)

  const signerProvider = createWeb3(wallet.provider)

  if (wallet.chainId !== chainId) {
    // The RPC methods that are used when we call contract.callStatic.execTransaction
    const READ_ONLY_METHODS = ['eth_chainId', 'eth_call']
    const ETH_ACCOUNTS_METHOD = 'eth_accounts'

    const originalSend = signerProvider.send

    signerProvider.send = (request, ...args) => {
      if (READ_ONLY_METHODS.includes(request)) {
        return readOnlyProvider.send.call(readOnlyProvider, request, ...args)
      }
      if (request === ETH_ACCOUNTS_METHOD) {
        return originalSend.call(signerProvider, request, ...args)
      }
      throw new Error('Invalid execution validity request')
    }
  }

  return signerProvider
}

const useIsValidExecution = (
  safeTx?: SafeTransaction,
  gasLimit?: bigint,
): {
  isValidExecution?: boolean
  executionValidationError?: Error
  isValidExecutionLoading: boolean
} => {
  const wallet = useSigner()
  const { safe } = useSafeInfo()
  const readOnlyProvider = useWeb3ReadOnly()
  const isOwner = useIsSafeOwner()
  const threshold = safe.threshold

  const [isValidExecution, executionValidationError, isValidExecutionLoading] = useAsync(async () => {
    if (!safeTx || !wallet || gasLimit === undefined || !readOnlyProvider) {
      return
    }

    try {
      const safeContract = await getCurrentGnosisSafeContract(safe, readOnlyProvider._getConnection().url)

      /**
       * We need to call the contract directly instead of using `sdk.isValidTransaction`
       * because `gasLimit` errors are otherwise not propagated.
       * @see https://github.com/safe-global/safe-core-sdk/blob/main/packages/safe-ethers-lib/src/contracts/GnosisSafe/GnosisSafeContractEthers.ts#L126
       * This also fixes the over-fetching issue of the monkey patched provider.
       */

      return safeContract.contract.execTransaction.staticCall(
        safeTx.data.to,
        safeTx.data.value,
        safeTx.data.data,
        safeTx.data.operation,
        safeTx.data.safeTxGas,
        safeTx.data.baseGas,
        safeTx.data.gasPrice,
        safeTx.data.gasToken,
        safeTx.data.refundReceiver,
        encodeSignatures(safeTx, isOwner ? wallet.address : undefined, safeTx.signatures.size < threshold),
        { from: wallet.address, gasLimit: gasLimit.toString() },
      )
    } catch (_err) {
      const err = _err as EthersError

      if (isContractError(err)) {
        // @ts-ignore
        err.reason += `: ${ContractErrorCodes[err.reason]}`
      }

      throw err
    }
  }, [safeTx, wallet, gasLimit, safe, readOnlyProvider, isOwner, threshold])

  return { isValidExecution, executionValidationError, isValidExecutionLoading }
}

export default useIsValidExecution
</file>

<file path="src/hooks/useIsWrongChain.ts">
import useChainId from '@/hooks/useChainId'
import useWallet from '@/hooks/wallets/useWallet'

const useIsWrongChain = (): boolean => {
  const chainId = useChainId()
  const wallet = useWallet()
  return !wallet || !chainId ? false : wallet.chainId !== chainId
}

export default useIsWrongChain
</file>

<file path="src/hooks/useLastSafe.ts">
import { useAppSelector } from '@/store'
import { selectLastSafeAddress } from '@/store/sessionSlice'
import { useCurrentChain } from './useChains'

const useLastSafe = (): string | undefined => {
  const chainInfo = useCurrentChain()
  const chainId = chainInfo?.chainId || ''
  const prefix = chainInfo?.shortName || ''
  const lastSafeAddress = useAppSelector((state) => selectLastSafeAddress(state, chainId))
  return prefix && lastSafeAddress ? `${prefix}:${lastSafeAddress}` : undefined
}

export default useLastSafe
</file>

<file path="src/hooks/useLoadableStores.ts">
import { useEffect } from 'react'
import { type Slice } from '@reduxjs/toolkit'
import { useAppDispatch } from '@/store'
import { type AsyncResult } from '@safe-global/utils/hooks/useAsync'

// Import all the loadable hooks
import useLoadChains from './loadables/useLoadChains'
import useLoadSafeInfo from './loadables/useLoadSafeInfo'
import useLoadBalances from './loadables/useLoadBalances'
import useLoadTxHistory from './loadables/useLoadTxHistory'
import useLoadTxQueue from './loadables/useLoadTxQueue'
import useLoadMessages from './loadables/useLoadSafeMessages'

// Import all the loadable slices
import { chainsSlice } from '@/store/chainsSlice'
import { safeInfoSlice } from '@/store/safeInfoSlice'
import { balancesSlice } from '@/store/balancesSlice'
import { txHistorySlice } from '@/store/txHistorySlice'
import { txQueueSlice } from '@/store/txQueueSlice'
import { spendingLimitSlice } from '@/store/spendingLimitsSlice'
import useLoadSpendingLimits from '@/hooks/loadables/useLoadSpendingLimits'
import { safeMessagesSlice } from '@/store/safeMessagesSlice'

// Dispatch into the corresponding store when the loadable is loaded
const useUpdateStore = (slice: Slice, useLoadHook: () => AsyncResult<unknown>): void => {
  const dispatch = useAppDispatch()
  const [data, error, loading] = useLoadHook()
  const setAction = slice.actions.set

  useEffect(() => {
    dispatch(
      setAction({
        data,
        error: data ? undefined : error?.message,
        loading: loading && !data,
      }),
    )
  }, [dispatch, setAction, data, error, loading])
}

const useLoadableStores = () => {
  useUpdateStore(chainsSlice, useLoadChains)
  useUpdateStore(safeInfoSlice, useLoadSafeInfo)
  useUpdateStore(balancesSlice, useLoadBalances)
  useUpdateStore(txHistorySlice, useLoadTxHistory)
  useUpdateStore(txQueueSlice, useLoadTxQueue)
  useUpdateStore(safeMessagesSlice, useLoadMessages)
  useUpdateStore(spendingLimitSlice, useLoadSpendingLimits)
}

export default useLoadableStores
</file>

<file path="src/hooks/useMasterCopies.ts">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from '@/hooks/useChainId'
import { Errors, logError } from '@/services/exceptions'
import type { MasterCopyReponse } from '@safe-global/safe-gateway-typescript-sdk'
import { getMasterCopies } from '@safe-global/safe-gateway-typescript-sdk'

export enum MasterCopyDeployer {
  GNOSIS = 'Gnosis',
  CIRCLES = 'Circles',
}

export type MasterCopy = MasterCopyReponse[number] & {
  deployer: MasterCopyDeployer
  deployerRepoUrl: string
}

const extractMasterCopyInfo = (mc: MasterCopyReponse[number]): MasterCopy => {
  const isCircles = mc.version.toLowerCase().includes(MasterCopyDeployer.CIRCLES.toLowerCase())
  const dashIndex = mc.version.indexOf('-')

  const masterCopy = {
    address: mc.address,
    version: !isCircles ? mc.version : mc.version.substring(0, dashIndex),
    deployer: !isCircles ? MasterCopyDeployer.GNOSIS : MasterCopyDeployer.CIRCLES,
    deployerRepoUrl: !isCircles
      ? 'https://github.com/gnosis/safe-contracts/releases'
      : 'https://github.com/CirclesUBI/safe-contracts/releases',
  }
  return masterCopy
}

export const useMasterCopies = () => {
  const chainId = useChainId()
  const fetchMasterCopies = async (): Promise<MasterCopy[] | undefined> => {
    try {
      const res = await getMasterCopies(chainId)
      return res.map(extractMasterCopyInfo)
    } catch (error) {
      logError(Errors._619, error)
    }
  }
  return useAsync(fetchMasterCopies, [chainId])
}
</file>

<file path="src/hooks/useNestedSafeOwners.tsx">
import useSafeInfo from '@/hooks/useSafeInfo'
import { useMemo } from 'react'
import useOwnedSafes from './useOwnedSafes'

export const useNestedSafeOwners = () => {
  const { safe, safeLoaded } = useSafeInfo()
  const allOwned = useOwnedSafes()

  const nestedSafeOwner = useMemo(() => {
    if (!safeLoaded) return null

    // Find an intersection of owned safes and the owners of the current safe
    const ownerAddresses = safe?.owners.map((owner) => owner.value)

    return allOwned[safe.chainId]?.filter((ownedSafe) => ownerAddresses?.includes(ownedSafe))
  }, [allOwned, safe, safeLoaded])

  return nestedSafeOwner
}
</file>

<file path="src/hooks/useOnceVisible.ts">
import { type RefObject, useEffect, useState } from 'react'

// A hook to detect when an element is visible in the viewport for the first time
const useOnceVisible = (element: RefObject<HTMLElement | null>): boolean => {
  const [onceVisible, setOnceVisible] = useState<boolean>(false)

  useEffect(() => {
    if (!element.current) return

    const observer = new IntersectionObserver(([entry], obs) => {
      if (entry.isIntersecting) {
        setOnceVisible(true)
        obs.unobserve(entry.target)
      }
    })

    observer.observe(element.current)

    return () => {
      observer.disconnect()
    }
  }, [element])

  return onceVisible
}

export default useOnceVisible
</file>

<file path="src/hooks/useOrigin.ts">
import { useEffect, useState } from 'react'

const useOrigin = () => {
  const [origin, setOrigin] = useState('')

  useEffect(() => {
    if (typeof location !== 'undefined') {
      setOrigin(location.origin)
    }
  }, [])
  return origin
}

export default useOrigin
</file>

<file path="src/hooks/useOwnedSafes.ts">
import { useMemo } from 'react'
import { type OwnedSafes } from '@safe-global/safe-gateway-typescript-sdk'

import useWallet from '@/hooks/wallets/useWallet'
import useChainId from './useChainId'
import { useGetOwnedSafesQuery } from '@/store/slices'
import { skipToken } from '@reduxjs/toolkit/query'

type OwnedSafesCache = {
  [walletAddress: string]: {
    [chainId: string]: OwnedSafes['safes']
  }
}

const useOwnedSafes = (): OwnedSafesCache['walletAddress'] => {
  const chainId = useChainId()
  const { address: walletAddress } = useWallet() || {}

  const { data: ownedSafes } = useGetOwnedSafesQuery(
    walletAddress ? { chainId, ownerAddress: walletAddress } : skipToken,
  )

  const result = useMemo(() => ({ [chainId]: ownedSafes?.safes ?? [] }), [chainId, ownedSafes])

  return result ?? {}
}

export default useOwnedSafes
</file>

<file path="src/hooks/useParentSafe.ts">
import { useGetSafeQuery } from '@/store/slices'
import { skipToken } from '@reduxjs/toolkit/query'
import useSafeInfo from './useSafeInfo'
import type { getSafe } from '@safe-global/safe-client-gateway-sdk'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

export function useParentSafe(): getSafe | undefined {
  const isEnabled = useHasFeature(FEATURES.NESTED_SAFES)
  const { safe } = useSafeInfo()

  // Nested Safes are deployed by a single owner
  const maybeParent = safe.owners.length === 1 ? safe.owners[0].value : undefined

  const { data: parentSafe } = useGetSafeQuery(
    isEnabled && maybeParent
      ? {
          chainId: safe.chainId,
          safeAddress: maybeParent,
        }
      : skipToken,
  )

  if (parentSafe?.address.value === maybeParent) {
    return parentSafe
  }
}
</file>

<file path="src/hooks/usePendingActions.ts">
import { isTransactionListItem } from '@/utils/transaction-guards'
import { isSignableBy } from '@/utils/transaction-guards'
import type { TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import { getTransactionQueue } from '@safe-global/safe-gateway-typescript-sdk'
import { useMemo } from 'react'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from './useSafeInfo'
import useTxQueue from './useTxQueue'
import useWallet from './wallets/useWallet'

type PendingActions = {
  totalQueued: string
  totalToSign: string
}

const getSignableCount = (queue: TransactionListPage, walletAddress: string): number => {
  return queue.results.filter((tx) => isTransactionListItem(tx) && isSignableBy(tx.transaction, walletAddress)).length
}

const usePendingActions = (chainId: string, safeAddress?: string): PendingActions => {
  const wallet = useWallet()
  const { safeAddress: currentSafeAddress } = useSafeInfo()
  const { page: currentSafeQueue } = useTxQueue()
  const isCurrentSafe = currentSafeAddress === safeAddress

  const [loadedQueue] = useAsync<TransactionListPage>(() => {
    if (isCurrentSafe || !safeAddress) return
    return getTransactionQueue(chainId, safeAddress)
  }, [chainId, safeAddress, isCurrentSafe])

  const queue = isCurrentSafe ? currentSafeQueue : loadedQueue

  return useMemo(
    () => ({
      // Return 20+ if more than one page, otherwise just the length
      totalQueued: queue ? (queue.results.filter(isTransactionListItem).length || '') + (queue.next ? '+' : '') : '',
      // Return the queued txs signable by wallet
      totalToSign: queue ? (getSignableCount(queue, wallet?.address || '') || '').toString() : '',
    }),
    [queue, wallet],
  )
}

export default usePendingActions
</file>

<file path="src/hooks/usePendingTxs.ts">
import { useMemo } from 'react'
import {
  type TransactionListPage,
  type TransactionSummary,
  LabelValue,
  getTransactionQueue,
} from '@safe-global/safe-gateway-typescript-sdk'
import { useAppSelector } from '@/store'
import { selectPendingTxIdsBySafe } from '@/store/pendingTxsSlice'
import useAsync from '@safe-global/utils/hooks/useAsync'
import {
  isConflictHeaderListItem,
  isLabelListItem,
  isMultisigExecutionInfo,
  isTransactionListItem,
} from '@/utils/transaction-guards'
import useSafeInfo from './useSafeInfo'
import { shallowEqual } from 'react-redux'

export const usePendingTxIds = (): Array<TransactionSummary['id']> => {
  const { safe, safeAddress } = useSafeInfo()
  const { chainId } = safe
  return useAppSelector((state) => selectPendingTxIdsBySafe(state, chainId, safeAddress), shallowEqual)
}

export const useHasPendingTxs = (): boolean => {
  const pendingIds = usePendingTxIds()
  return pendingIds.length > 0
}

/**
 * Show unsigned pending queue only in 1/X Safes
 */
export const useShowUnsignedQueue = (): boolean => {
  const { safe } = useSafeInfo()
  const hasPending = useHasPendingTxs()
  return safe.threshold === 1 && hasPending
}

export const filterUntrustedQueue = (
  untrustedQueue: TransactionListPage,
  pendingIds: Array<TransactionSummary['id']>,
) => {
  // Only keep labels and pending unsigned transactions
  const results = untrustedQueue.results
    .filter((item) => !isTransactionListItem(item) || pendingIds.includes(item.transaction.id))
    .filter((item) => !isConflictHeaderListItem(item))
    .filter(
      (item) =>
        !isTransactionListItem(item) ||
        (isTransactionListItem(item) &&
          isMultisigExecutionInfo(item.transaction.executionInfo) &&
          item.transaction.executionInfo.confirmationsSubmitted === 0),
    )

  // Adjust the first label ("Next" -> "Pending")
  if (results[0] && isLabelListItem(results[0])) {
    results[0].label = 'Pending' as LabelValue
  }

  const transactions = results.filter((item) => isTransactionListItem(item))

  return transactions.length ? { results } : undefined
}

export function getNextTransactions(queue: TransactionListPage): TransactionListPage {
  const queueLabelIndex = queue.results.findIndex((item) => isLabelListItem(item) && item.label === LabelValue.Queued)
  const nextTransactions = queueLabelIndex === -1 ? queue.results : queue.results.slice(0, queueLabelIndex)
  return { results: nextTransactions }
}

export const usePendingTxsQueue = (): {
  page?: TransactionListPage
  error?: string
  loading: boolean
} => {
  const { safe, safeAddress } = useSafeInfo()
  const { chainId } = safe
  const pendingIds = usePendingTxIds()
  const hasPending = pendingIds.length > 0

  const [untrustedNext, error, loading] = useAsync<TransactionListPage | undefined>(
    async () => {
      if (!hasPending) return
      const untrustedQueue = await getTransactionQueue(chainId, safeAddress, { trusted: false })
      return getNextTransactions(untrustedQueue)
    },
    [chainId, safeAddress, hasPending],
    false,
  )

  const pendingTxPage = useMemo(() => {
    if (!untrustedNext || !pendingIds.length) return

    return filterUntrustedQueue(untrustedNext, pendingIds)
  }, [untrustedNext, pendingIds])

  return useMemo(
    () => ({
      page: pendingTxPage,
      error: error?.message,
      loading,
    }),
    [pendingTxPage, error, loading],
  )
}
</file>

<file path="src/hooks/usePredictSafeAddressFromTxDetails.ts">
import type { DataDecoded, TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'

import { predictSafeAddress } from '@/features/multichain/utils/utils'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { useWeb3ReadOnly } from './wallets/web3'

export function _getSetupFromDataDecoded(dataDecoded: DataDecoded) {
  if (dataDecoded?.method !== 'createProxyWithNonce') {
    return
  }

  const singleton = dataDecoded?.parameters?.[0]?.value
  const initializer = dataDecoded?.parameters?.[1]?.value
  const saltNonce = dataDecoded?.parameters?.[2]?.value

  if (typeof singleton !== 'string' || typeof initializer !== 'string' || typeof saltNonce !== 'string') {
    return
  }

  return {
    singleton,
    initializer,
    saltNonce,
  }
}

function isCreateProxyWithNonce(dataDecoded?: DataDecoded) {
  return dataDecoded?.method === 'createProxyWithNonce'
}

export function usePredictSafeAddressFromTxDetails(txDetails: TransactionDetails | undefined) {
  const web3 = useWeb3ReadOnly()

  return useAsync(() => {
    const txData = txDetails?.txData
    if (!web3 || !txData) {
      return
    }

    const isMultiSend = txData?.dataDecoded?.method === 'multiSend'

    const dataDecoded = isMultiSend
      ? txData?.dataDecoded?.parameters?.[0]?.valueDecoded?.find((tx) => isCreateProxyWithNonce(tx?.dataDecoded))
          ?.dataDecoded
      : txData?.dataDecoded
    const factoryAddress = isMultiSend
      ? txData?.dataDecoded?.parameters?.[0]?.valueDecoded?.find((tx) => isCreateProxyWithNonce(tx?.dataDecoded))?.to
      : txData?.to?.value

    if (!dataDecoded || !isCreateProxyWithNonce(dataDecoded) || !factoryAddress) {
      return
    }

    const setup = _getSetupFromDataDecoded(dataDecoded)
    if (!setup) {
      return
    }

    return predictSafeAddress(setup, factoryAddress, web3)
  }, [txDetails?.txData, web3])
}
</file>

<file path="src/hooks/usePreviousNonces.ts">
import { useMemo } from 'react'
import { isMultisigExecutionInfo, isTransactionListItem } from '@/utils/transaction-guards'
import uniqBy from 'lodash/uniqBy'
import useTxQueue from '@/hooks/useTxQueue'
import { type TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'

export const _getUniqueQueuedTxs = (page?: TransactionListPage) => {
  if (!page) {
    return []
  }

  const txs = page.results.filter(isTransactionListItem).map((item) => item.transaction)

  return uniqBy(txs, (tx) => {
    return isMultisigExecutionInfo(tx.executionInfo) ? tx.executionInfo.nonce : ''
  })
}

const usePreviousNonces = () => {
  const { page } = useTxQueue()

  const previousNonces = useMemo(() => {
    return _getUniqueQueuedTxs(page)
      .map((tx) => (isMultisigExecutionInfo(tx.executionInfo) ? tx.executionInfo.nonce : undefined))
      .filter((nonce): nonce is number => nonce !== undefined)
  }, [page])

  return previousNonces
}

export default usePreviousNonces
</file>

<file path="src/hooks/useProposers.ts">
import useSafeInfo from '@/hooks/useSafeInfo'
import useWallet from '@/hooks/wallets/useWallet'
import { useGetProposersQuery } from '@/store/api/gateway'
import { skipToken } from '@reduxjs/toolkit/query/react'

const useProposers = () => {
  const {
    safe: { chainId },
    safeAddress,
  } = useSafeInfo()

  return useGetProposersQuery(chainId && safeAddress ? { chainId, safeAddress } : skipToken)
}

export const useIsWalletProposer = () => {
  const wallet = useWallet()
  const proposers = useProposers()

  return proposers.data?.results.some((proposer) => proposer.delegate === wallet?.address)
}

export default useProposers
</file>

<file path="src/hooks/useRemainingRelays.ts">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from './useSafeInfo'
import { useCurrentChain } from '@/hooks/useChains'
import { getRelayCount } from '@safe-global/safe-gateway-typescript-sdk'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

export const MAX_DAY_RELAYS = 5

export const useRelaysBySafe = () => {
  const chain = useCurrentChain()
  const { safe, safeAddress } = useSafeInfo()

  return useAsync(() => {
    if (!safeAddress || !chain) return
    if (hasFeature(chain, FEATURES.RELAYING)) {
      return getRelayCount(chain.chainId, safeAddress)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chain, safeAddress, safe.txHistoryTag])
}

export const useLeastRemainingRelays = (ownerAddresses: string[]) => {
  const chain = useCurrentChain()
  const { safe } = useSafeInfo()

  return useAsync(() => {
    if (!chain || !hasFeature(chain, FEATURES.RELAYING)) return

    return Promise.all(ownerAddresses.map((address) => getRelayCount(chain.chainId, address)))
      .then((result) => {
        const min = Math.min(...result.map((r) => r.remaining))
        return result.find((r) => r.remaining === min)
      })
      .catch(() => {
        return { remaining: 0, limit: MAX_DAY_RELAYS }
      })
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chain, ownerAddresses, safe.txHistoryTag])
}
</file>

<file path="src/hooks/useSafeAddress.ts">
import useSafeInfo from '@/hooks/useSafeInfo'

const useSafeAddress = (): string => {
  const { safeAddress } = useSafeInfo()
  return safeAddress
}

export default useSafeAddress
</file>

<file path="src/hooks/useSafeAddressFromUrl.ts">
import { useMemo } from 'react'
import { useRouter } from 'next/router'
import { parsePrefixedAddress } from '@safe-global/utils/utils/addresses'

export const useSafeAddressFromUrl = (): string => {
  const router = useRouter()
  const { safe = '' } = router.query
  const fullAddress = Array.isArray(safe) ? safe[0] : safe

  const checksummedAddress = useMemo(() => {
    if (!fullAddress) return ''
    const { address } = parsePrefixedAddress(fullAddress)
    return address
  }, [fullAddress])

  return checksummedAddress
}
</file>

<file path="src/hooks/useSafeInfo.ts">
import { useMemo } from 'react'
import isEqual from 'lodash/isEqual'
import { useAppSelector } from '@/store'
import { selectSafeInfo } from '@/store/safeInfoSlice'
import type { ExtendedSafeInfo } from '@safe-global/store/slices/SafeInfo/types'
import { defaultSafeInfo } from '@safe-global/store/slices/SafeInfo/utils'

const useSafeInfo = (): {
  safe: ExtendedSafeInfo
  safeAddress: string
  safeLoaded: boolean
  safeLoading: boolean
  safeError?: string
} => {
  const { data, error, loading } = useAppSelector(selectSafeInfo, isEqual)

  return useMemo(
    () => ({
      safe: data || defaultSafeInfo,
      safeAddress: data?.address.value || '',
      safeLoaded: !!data,
      safeError: error,
      safeLoading: loading,
    }),
    [data, error, loading],
  )
}

export default useSafeInfo
</file>

<file path="src/hooks/useSafeNotifications.ts">
import { useCallback, useEffect } from 'react'
import { showNotification, closeNotification } from '@/store/notificationsSlice'
import { ImplementationVersionState } from '@safe-global/safe-gateway-typescript-sdk'
import useSafeInfo from './useSafeInfo'
import { useAppDispatch } from '@/store'
import { AppRoutes } from '@/config/routes'
import { isMigrationToL2Possible } from '@/services/contracts/safeContracts'
import { isValidMasterCopy } from '@safe-global/utils/services/contracts/safeContracts'
import { useRouter } from 'next/router'
import useIsSafeOwner from './useIsSafeOwner'
import useSafeAddress from '@/hooks/useSafeAddress'
import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { isValidSafeVersion } from '@safe-global/utils/services/contracts/utils'

const CLI_LINK = {
  href: 'https://github.com/5afe/safe-cli',
  title: 'Get CLI',
}

type DismissedUpdateNotifications = {
  [chainId: string]: {
    [address: string]: number
  }
}

const DISMISS_NOTIFICATION_KEY = 'dismissUpdateSafe'
const OUTDATED_VERSION_KEY = 'safe-outdated-version'

const isUpdateSafeNotification = (groupKey: string) => {
  return groupKey === OUTDATED_VERSION_KEY
}

/**
 * General-purpose notifications relating to the entire Safe
 */
const useSafeNotifications = (): void => {
  const [dismissedUpdateNotifications, setDismissedUpdateNotifications] =
    useLocalStorage<DismissedUpdateNotifications>(DISMISS_NOTIFICATION_KEY)
  const dispatch = useAppDispatch()
  const { query } = useRouter()
  const { safe, safeAddress } = useSafeInfo()
  const { chainId, version, implementationVersionState } = safe
  const isOwner = useIsSafeOwner()
  const urlSafeAddress = useSafeAddress()

  const dismissUpdateNotification = useCallback(
    (groupKey: string) => {
      const EXPIRY_DAYS = 90

      if (!isUpdateSafeNotification(groupKey)) return

      const expiryDate = Date.now() + EXPIRY_DAYS * 24 * 60 * 60 * 1000

      const newState = {
        ...dismissedUpdateNotifications,
        [safe.chainId]: {
          ...dismissedUpdateNotifications?.[safe.chainId],
          [safe.address.value]: expiryDate,
        },
      }

      setDismissedUpdateNotifications(newState)
    },
    [dismissedUpdateNotifications, safe.address.value, safe.chainId, setDismissedUpdateNotifications],
  )

  /**
   * Show a notification when the Safe version is out of date
   */

  useEffect(() => {
    if (safeAddress !== urlSafeAddress) return
    if (!isOwner) return

    const dismissedNotificationTimestamp = dismissedUpdateNotifications?.[chainId]?.[safeAddress]

    if (dismissedNotificationTimestamp !== undefined) {
      if (Date.now() >= dismissedNotificationTimestamp) {
        const newState = { ...dismissedUpdateNotifications }
        delete newState?.[chainId]?.[safeAddress]

        setDismissedUpdateNotifications(newState)
      } else {
        return
      }
    }

    if (implementationVersionState !== ImplementationVersionState.OUTDATED) return

    const isUnsupported = !isValidSafeVersion(version)

    const id = dispatch(
      showNotification({
        variant: 'warning',
        groupKey: OUTDATED_VERSION_KEY,

        message: isUnsupported
          ? `Safe Account version ${version} is not supported by this web app anymore. You can update your Safe Account via the CLI.`
          : `Your Safe Account version ${version} is out of date. Please update it.`,

        link: isUnsupported
          ? CLI_LINK
          : {
              href: {
                pathname: AppRoutes.settings.setup,
                query: { safe: query.safe },
              },
              title: 'Update Safe Account',
            },

        onClose: () => dismissUpdateNotification(OUTDATED_VERSION_KEY),
      }),
    )

    return () => {
      dispatch(closeNotification({ id }))
    }
  }, [
    dispatch,
    implementationVersionState,
    version,
    query.safe,
    isOwner,
    safeAddress,
    urlSafeAddress,
    chainId,
    dismissedUpdateNotifications,
    setDismissedUpdateNotifications,
    dismissUpdateNotification,
  ])

  /**
   * Show a notification when the Safe master copy is not supported
   */
  useEffect(() => {
    if (isValidMasterCopy(safe.implementationVersionState)) return

    const isMigrationPossible = isMigrationToL2Possible(safe)

    const message = isMigrationPossible
      ? `This Safe Account was created with an unsupported base contract.
           It is possible to migrate it to a compatible base contract. You can migrate it to a compatible contract on the Home screen.`
      : `This Safe Account was created with an unsupported base contract.
           The web interface might not work correctly.
           We recommend using the command line interface instead.`

    const id = dispatch(
      showNotification({
        variant: isMigrationPossible ? 'info' : 'warning',
        message,
        groupKey: 'invalid-mastercopy',
        link: isMigrationPossible ? undefined : CLI_LINK,
      }),
    )

    return () => {
      dispatch(closeNotification({ id }))
    }
  }, [dispatch, safe, safe.implementationVersionState])
}

export default useSafeNotifications
</file>

<file path="src/hooks/useSafeTokenAllocation.ts">
import { getSafeTokenAddress, getSafeLockingAddress } from '@/components/common/SafeTokenWidget'
import { IS_PRODUCTION } from '@/config/constants'
import { ZERO_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import { isPast } from 'date-fns'
import { AbiCoder, Interface, type JsonRpcProvider } from 'ethers'
import { useMemo } from 'react'
import useAsync, { type AsyncResult } from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from './useSafeInfo'
import { getWeb3ReadOnly } from './wallets/web3'
import memoize from 'lodash/memoize'
import { cgwDebugStorage } from '@/config/gateway'

export const VESTING_URL =
  IS_PRODUCTION || cgwDebugStorage.get()
    ? 'https://safe-claiming-app-data.safe.global/allocations/'
    : 'https://safe-claiming-app-data.staging.5afe.dev/allocations/'

export type VestingData = {
  tag: 'user' | 'ecosystem' | 'investor' | 'user_v2' | 'sap_boosted' | 'sap_unboosted' // SEP #5
  account: string
  chainId: number
  contract: string
  vestingId: string
  durationWeeks: number
  startDate: number
  amount: string
  curve: 0 | 1
  proof: string[]
}

export type Vesting = VestingData & {
  isExpired: boolean
  isRedeemed: boolean
  amountClaimed: string
}

// We currently do not have typechain as dependency so we fallback to human readable ABIs
const airdropInterface = new Interface([
  'function redeemDeadline() public returns (uint64)',
  'function vestings(bytes32) public returns (address account, uint8 curveType,bool managed, uint16 durationWeeks, uint64 startDate, uint128 amount, uint128 amountClaimed, uint64 pausingDate,bool cancelled)',
])
const tokenInterface = new Interface(['function balanceOf(address _owner) public view returns (uint256 balance)'])
const safeLockingInterface = new Interface([
  'function getUserTokenBalance(address holder) external view returns (uint96 amount)',
])

export const _getRedeemDeadline = memoize(
  async (allocation: VestingData, web3ReadOnly: JsonRpcProvider): Promise<string> => {
    return web3ReadOnly.call({
      to: allocation.contract,
      data: airdropInterface.encodeFunctionData('redeemDeadline'),
    })
  },
  ({ chainId, contract }) => chainId + contract,
)

/**
 * Add on-chain information to allocation.
 * Fetches if the redeem deadline is expired and the claimed tokens from on-chain
 */
const completeAllocation = async (allocation: VestingData): Promise<Vesting> => {
  const web3ReadOnly = getWeb3ReadOnly()
  if (!web3ReadOnly) {
    throw new Error('Cannot fetch vesting without web3 provider')
  }
  const onChainVestingData = await web3ReadOnly.call({
    to: allocation.contract,
    data: airdropInterface.encodeFunctionData('vestings', [allocation.vestingId]),
  })

  const decodedVestingData = AbiCoder.defaultAbiCoder().decode(
    // account, curveType, managed, durationWeeks, startDate, amount, amountClaimed, pausingDate, cancelled}
    ['address', 'uint8', 'bool', 'uint16', 'uint64', 'uint128', 'uint128', 'uint64', 'bool'],
    onChainVestingData,
  )

  const isRedeemed = decodedVestingData[0].toLowerCase() !== ZERO_ADDRESS.toLowerCase()
  if (isRedeemed) {
    return { ...allocation, isRedeemed, isExpired: false, amountClaimed: decodedVestingData[6] }
  }

  // Allocation is not yet redeemed => check the redeemDeadline
  const redeemDeadline = await _getRedeemDeadline(allocation, web3ReadOnly)

  const redeemDeadlineDate = new Date(Number(BigInt(redeemDeadline) * BigInt(1000)))

  // Allocation is valid if redeem deadline is in future
  return { ...allocation, isRedeemed, isExpired: isPast(redeemDeadlineDate), amountClaimed: '0' }
}

const fetchAllocation = async (chainId: string, safeAddress: string): Promise<VestingData[]> => {
  try {
    const response = await fetch(`${VESTING_URL}${chainId}/${safeAddress}.json`)

    // No file exists => the safe is not part of any vesting
    if (response.status === 404) {
      return Promise.resolve([]) as Promise<VestingData[]>
    }

    // Some other error
    if (!response.ok) {
      throw Error(`Error fetching vestings: ${response.statusText}`)
    }

    // Success
    return response.json() as Promise<VestingData[]>
  } catch (err) {
    throw Error(`Error fetching vestings: ${err}`)
  }
}

const useSafeTokenAllocation = (): AsyncResult<Vesting[]> => {
  const { safe, safeAddress } = useSafeInfo()
  const chainId = safe.chainId

  return useAsync<Vesting[] | undefined>(async () => {
    if (!safeAddress) return
    return Promise.all(
      await fetchAllocation(chainId, safeAddress).then((allocations) =>
        allocations.map((allocation) => completeAllocation(allocation)),
      ),
    )
    // If the history tag changes we could have claimed / redeemed tokens
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chainId, safeAddress, safe.txHistoryTag])
}

const fetchTokenBalance = async (chainId: string, safeAddress: string): Promise<string> => {
  try {
    const web3ReadOnly = getWeb3ReadOnly()
    const safeTokenAddress = getSafeTokenAddress(chainId)
    if (!safeTokenAddress || !web3ReadOnly) return '0'

    return await web3ReadOnly.call({
      to: safeTokenAddress,
      data: tokenInterface.encodeFunctionData('balanceOf', [safeAddress]),
    })
  } catch (err) {
    throw Error(`Error fetching Safe Token balance:  ${err}`)
  }
}
const fetchLockingContractBalance = async (chainId: string, safeAddress: string): Promise<string> => {
  try {
    const web3ReadOnly = getWeb3ReadOnly()
    const safeLockingAddress = getSafeLockingAddress(chainId)
    if (!safeLockingAddress || !web3ReadOnly) return '0'

    return await web3ReadOnly.call({
      to: safeLockingAddress,
      data: safeLockingInterface.encodeFunctionData('getUserTokenBalance', [safeAddress]),
    })
  } catch (err) {
    throw Error(`Error fetching Safe Token balance in locking contract:  ${err}`)
  }
}

/**
 * The Safe token allocation is equal to the voting power.
 * It is computed by adding all vested tokens - claimed tokens + token balance
 */
export const useSafeVotingPower = (allocationData?: Vesting[]): AsyncResult<bigint> => {
  const { safe, safeAddress } = useSafeInfo()
  const chainId = safe.chainId

  const [balance, balanceError, balanceLoading] = useAsync<bigint>(() => {
    if (!safeAddress) return
    const tokenBalancePromise = fetchTokenBalance(chainId, safeAddress)
    const lockingContractBalancePromise = fetchLockingContractBalance(chainId, safeAddress)
    return Promise.all([tokenBalancePromise, lockingContractBalancePromise]).then(
      ([tokenBalance, lockingContractBalance]) => {
        return BigInt(tokenBalance) + BigInt(lockingContractBalance)
      },
    )
    // If the history tag changes we could have claimed / redeemed tokens
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chainId, safeAddress, safe.txHistoryTag])

  const allocation = useMemo(() => {
    if (balance === undefined) {
      return
    }

    // Return current balance if no allocation exists
    if (!allocationData) {
      return balance
    }

    const tokensInVesting = allocationData.reduce(
      (acc, data) =>
        data.isExpired || data.tag === 'sap_boosted' || data.tag === 'sap_unboosted' // Exclude the SAP Airdrops from voting power
          ? acc
          : acc + BigInt(data.amount) - BigInt(data.amountClaimed),
      BigInt(0),
    )

    // add balance
    const totalAllocation = tokensInVesting + balance
    return totalAllocation
  }, [allocationData, balance])

  return [allocation, balanceError, balanceLoading]
}

export default useSafeTokenAllocation
</file>

<file path="src/hooks/useSafeTokenEnabled.ts">
import { useContext } from 'react'
import { GeoblockingContext } from '@/components/common/GeoblockingProvider'
import useSafeInfo from './useSafeInfo'
import { getSafeTokenAddress } from '@/components/common/SafeTokenWidget'

export function useSafeTokenEnabled(): boolean {
  const isBlockedCountry = useContext(GeoblockingContext)
  const { safe, safeLoaded } = useSafeInfo()
  return !isBlockedCountry && safeLoaded && !!getSafeTokenAddress(safe.chainId)
}
</file>

<file path="src/hooks/useSanctionedAddress.ts">
import { useGetIsSanctionedQuery } from '@/store/api/ofac'
import useSafeAddress from './useSafeAddress'
import useWallet from './wallets/useWallet'
import { skipToken } from '@reduxjs/toolkit/query/react'

/**
 * Checks if the opened Safe or the connected wallet are sanctioned and returns the sanctioned address.
 * @param isRestricted the check is only performed if isRestricted is true.
 * @returns address of sanctioned wallet or Safe
 */
export const useSanctionedAddress = (isRestricted = true) => {
  const wallet = useWallet()
  const safeAddress = useSafeAddress()

  const { data: isWalletSanctioned } = useGetIsSanctionedQuery(isRestricted && wallet ? wallet.address : skipToken)

  const { data: isSafeSanctioned } = useGetIsSanctionedQuery(
    isRestricted && safeAddress !== '' ? safeAddress : skipToken,
  )

  if (isSafeSanctioned) {
    return safeAddress
  }
  if (isWalletSanctioned) {
    return wallet?.address
  }

  return undefined
}
</file>

<file path="src/hooks/useSpendingLimit.ts">
import { useSelector } from 'react-redux'
import type { TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import useWallet from '@/hooks/wallets/useWallet'
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import { selectSpendingLimits } from '@/store/spendingLimitsSlice'
import { sameAddress } from '@safe-global/utils/utils/addresses'

const useSpendingLimit = (selectedToken?: TokenInfo): SpendingLimitState | undefined => {
  const wallet = useWallet()
  const spendingLimits = useSelector(selectSpendingLimits)

  return spendingLimits.find(
    (spendingLimit) =>
      sameAddress(spendingLimit.token.address, selectedToken?.address) &&
      sameAddress(spendingLimit.beneficiary, wallet?.address),
  )
}

export default useSpendingLimit
</file>

<file path="src/hooks/useSpendingLimitGas.ts">
import useWallet from '@/hooks/wallets/useWallet'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { getSpendingLimitContract } from '@/services/contracts/spendingLimitContracts'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { type SpendingLimitTxParams } from '@/components/tx-flow/flows/TokenTransfer/ReviewSpendingLimitTx'
import useChainId from '@/hooks/useChainId'
import useSafeInfo from './useSafeInfo'

const useSpendingLimitGas = (params: SpendingLimitTxParams) => {
  const chainId = useChainId()
  const provider = useWeb3ReadOnly()
  const wallet = useWallet()
  const { safe } = useSafeInfo()

  const [gasLimit, gasLimitError, gasLimitLoading] = useAsync<bigint | undefined>(async () => {
    if (!provider || !wallet || !safe.modules?.length) return

    const contract = getSpendingLimitContract(chainId, safe.modules, provider)

    const data = contract.interface.encodeFunctionData('executeAllowanceTransfer', [
      params.safeAddress,
      params.token,
      params.to,
      params.amount,
      params.paymentToken,
      params.payment,
      params.delegate,
      params.signature,
    ])

    return provider.estimateGas({
      to: await contract.getAddress(),
      from: wallet.address,
      data,
    })
  }, [provider, wallet, chainId, params, safe.modules])

  return { gasLimit, gasLimitError, gasLimitLoading }
}

export default useSpendingLimitGas
</file>

<file path="src/hooks/useTransactionStatus.ts">
import { ReplaceTxHoverContext } from '@/components/transactions/GroupedTxListItems/ReplaceTxHoverProvider'
import { useAppSelector } from '@/store'
import { PendingStatus, selectPendingTxById } from '@/store/pendingTxsSlice'
import { isCancelledSwapOrder, isSignableBy } from '@/utils/transaction-guards'
import type { TransactionSummary } from '@safe-global/safe-gateway-typescript-sdk'
import { TransactionStatus } from '@safe-global/safe-gateway-typescript-sdk'
import { useContext } from 'react'
import useWallet from './wallets/useWallet'

const ReplacedStatus = 'WILL_BE_REPLACED'

type TxLocalStatus = TransactionStatus | PendingStatus | typeof ReplacedStatus

export const STATUS_LABELS: Record<TxLocalStatus, string> = {
  [TransactionStatus.AWAITING_CONFIRMATIONS]: 'Awaiting confirmations',
  [TransactionStatus.AWAITING_EXECUTION]: 'Awaiting execution',
  [TransactionStatus.CANCELLED]: 'Cancelled',
  [TransactionStatus.FAILED]: 'Failed',
  [TransactionStatus.SUCCESS]: 'Success',
  [PendingStatus.SUBMITTING]: 'Submitting',
  [PendingStatus.PROCESSING]: 'Processing',
  [PendingStatus.RELAYING]: 'Relaying',
  [PendingStatus.INDEXING]: 'Indexing',
  [PendingStatus.SIGNING]: 'Signing',
  [PendingStatus.NESTED_SIGNING]: 'Signing',
  [ReplacedStatus]: 'Transaction will be replaced',
}

const WALLET_STATUS_LABELS: Record<TxLocalStatus, string> = {
  ...STATUS_LABELS,
  [TransactionStatus.AWAITING_CONFIRMATIONS]: 'Needs your confirmation',
}

const useTransactionStatus = (txSummary: TransactionSummary): string => {
  const { txStatus, id } = txSummary

  const { replacedTxIds } = useContext(ReplaceTxHoverContext)
  const wallet = useWallet()
  const pendingTx = useAppSelector((state) => selectPendingTxById(state, id))

  if (isCancelledSwapOrder(txSummary.txInfo)) {
    return STATUS_LABELS['CANCELLED']
  }

  if (replacedTxIds.includes(id)) {
    return STATUS_LABELS[ReplacedStatus]
  }

  const statuses = wallet?.address && isSignableBy(txSummary, wallet.address) ? WALLET_STATUS_LABELS : STATUS_LABELS

  return statuses[pendingTx?.status || txStatus] || ''
}

export default useTransactionStatus
</file>

<file path="src/hooks/useTransactionType.tsx">
import { getOrderClass } from '@/features/swap/helpers/utils'
import type { ReactElement } from 'react'
import { useMemo } from 'react'
import {
  type AddressEx,
  SettingsInfoType,
  TransactionInfoType,
  type TransactionSummary,
} from '@safe-global/safe-gateway-typescript-sdk'
import SwapIcon from '@/public/images/common/swap.svg'
import StakeIcon from '@/public/images/common/stake.svg'
import NestedSafeIcon from '@/public/images/transactions/nestedTx.svg'
import BatchIcon from '@/public/images/common/multisend.svg'

import {
  isCancellationTxInfo,
  isModuleExecutionInfo,
  isMultiSendTxInfo,
  isNestedConfirmationTxInfo,
  isOutgoingTransfer,
  isTxQueued,
} from '@/utils/transaction-guards'
import useAddressBook from './useAddressBook'
import type { AddressBook } from '@/store/addressBookSlice'
import { TWAP_ORDER_TITLE } from '@/features/swap/constants'
import { SvgIcon } from '@mui/material'

const getTxTo = ({ txInfo }: Pick<TransactionSummary, 'txInfo'>): AddressEx | undefined => {
  switch (txInfo.type) {
    case TransactionInfoType.CREATION: {
      return txInfo.factory
    }
    case TransactionInfoType.TRANSFER: {
      return txInfo.recipient
    }
    case TransactionInfoType.SETTINGS_CHANGE: {
      return undefined
    }
    case TransactionInfoType.CUSTOM: {
      return txInfo.to
    }
  }
}

type TxType = {
  icon: string | ReactElement
  text: string
}

export const getTransactionType = (tx: TransactionSummary, addressBook: AddressBook): TxType => {
  const toAddress = getTxTo(tx)
  const addressBookName = toAddress?.value ? addressBook[toAddress.value] : undefined

  switch (tx.txInfo.type) {
    case TransactionInfoType.CREATION: {
      return {
        icon: toAddress?.logoUri || '/images/transactions/settings.svg',
        text: 'Safe Account created',
      }
    }
    case TransactionInfoType.SWAP_TRANSFER:
    case TransactionInfoType.TRANSFER: {
      const isSendTx = isOutgoingTransfer(tx.txInfo)

      return {
        icon: isSendTx ? '/images/transactions/outgoing.svg' : '/images/transactions/incoming.svg',
        text: isSendTx ? (isTxQueued(tx.txStatus) ? 'Send' : 'Sent') : 'Received',
      }
    }
    case TransactionInfoType.SETTINGS_CHANGE: {
      // deleteGuard doesn't exist in Solidity
      // It is decoded as 'setGuard' with a settingsInfo.type of 'DELETE_GUARD'
      const isDeleteGuard = tx.txInfo.settingsInfo?.type === SettingsInfoType.DELETE_GUARD

      return {
        icon: '/images/transactions/settings.svg',
        text: isDeleteGuard ? 'deleteGuard' : tx.txInfo.dataDecoded.method,
      }
    }
    case TransactionInfoType.SWAP_ORDER: {
      const orderClass = getOrderClass(tx.txInfo)
      const altText = orderClass === 'limit' ? 'Limit order' : 'Swap order'

      return {
        icon: <SvgIcon component={SwapIcon} inheritViewBox fontSize="small" alt={altText} />,
        text: altText,
      }
    }
    case TransactionInfoType.TWAP_ORDER: {
      return {
        icon: <SvgIcon component={SwapIcon} inheritViewBox fontSize="small" alt="Twap Order" />,
        text: TWAP_ORDER_TITLE,
      }
    }
    case TransactionInfoType.NATIVE_STAKING_DEPOSIT: {
      return {
        icon: <SvgIcon component={StakeIcon} inheritViewBox fontSize="small" alt="Stake" />,
        text: 'Stake',
      }
    }
    case TransactionInfoType.NATIVE_STAKING_VALIDATORS_EXIT: {
      return {
        icon: <StakeIcon component={StakeIcon} inheritViewBox fontSize="small" alt="Withdraw request" />,
        text: 'Withdraw request',
      }
    }
    case TransactionInfoType.NATIVE_STAKING_WITHDRAW: {
      return {
        icon: <StakeIcon component={StakeIcon} inheritViewBox fontSize="small" alt="Claim" />,
        text: 'Claim',
      }
    }
    case TransactionInfoType.CUSTOM: {
      if (tx.safeAppInfo) {
        return {
          icon: tx.safeAppInfo.logoUri,
          text: tx.safeAppInfo.name,
        }
      }

      if (isMultiSendTxInfo(tx.txInfo)) {
        return {
          icon: <SvgIcon component={BatchIcon} inheritViewBox fontSize="small" alt="Batch" />,
          text: 'Batch',
        }
      }

      if (isModuleExecutionInfo(tx.executionInfo)) {
        return {
          icon: toAddress?.logoUri || '/images/transactions/custom.svg',
          text: toAddress?.name || 'Contract interaction',
        }
      }

      if (isCancellationTxInfo(tx.txInfo)) {
        return {
          icon: '/images/transactions/circle-cross-red.svg',
          text: 'On-chain rejection',
        }
      }

      if (isNestedConfirmationTxInfo(tx.txInfo)) {
        return {
          icon: <SvgIcon component={NestedSafeIcon} inheritViewBox fontSize="small" alt="Nested Safe" />,
          text: `Nested Safe${addressBookName ? `: ${addressBookName}` : ''}`,
        }
      }

      return {
        icon: toAddress?.logoUri || '/images/transactions/custom.svg',
        text: addressBookName || toAddress?.name || 'Contract interaction',
      }
    }
    default: {
      return {
        icon: '/images/transactions/custom.svg',
        text: addressBookName || 'Contract interaction',
      }
    }
  }
}

export const useTransactionType = (tx: TransactionSummary): TxType => {
  const addressBook = useAddressBook()

  return useMemo(() => {
    return getTransactionType(tx, addressBook)
  }, [tx, addressBook])
}
</file>

<file path="src/hooks/useTxDetails.ts">
import { getTransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import useAsync from '@safe-global/utils/hooks/useAsync'
import useChainId from './useChainId'

function useTxDetails(txId?: string) {
  const chainId = useChainId()

  return useAsync(() => {
    if (!txId) return
    return getTransactionDetails(chainId, txId)
  }, [chainId, txId])
}

export default useTxDetails
</file>

<file path="src/hooks/useTxHistory.ts">
import { useMemo } from 'react'
import { type TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import { useAppSelector } from '@/store'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { selectTxHistory } from '@/store/txHistorySlice'
import useSafeInfo from './useSafeInfo'
import { fetchFilteredTxHistory, useTxFilter } from '@/utils/tx-history-filter'
import { getTxHistory } from '@/services/transactions'
import { selectSettings } from '@/store/settingsSlice'
import { useHasFeature } from './useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

const useTxHistory = (
  pageUrl?: string,
): {
  page?: TransactionListPage
  error?: string
  loading: boolean
} => {
  // The latest page of the history is always in the store
  const historyState = useAppSelector(selectTxHistory)
  const [filter] = useTxFilter()
  const { hideSuspiciousTransactions } = useAppSelector(selectSettings)
  const hasDefaultTokenlist = useHasFeature(FEATURES.DEFAULT_TOKENLIST)
  const hideUntrustedTxs = (hasDefaultTokenlist && hideSuspiciousTransactions) ?? true
  const hideImitationTxs = hideSuspiciousTransactions ?? true

  const {
    safe: { chainId },
    safeAddress,
  } = useSafeInfo()

  // If filter exists or pageUrl is passed, load a new history page from the API
  const [page, error, loading] = useAsync<TransactionListPage>(
    () => {
      if (!(filter || pageUrl)) return

      return filter
        ? fetchFilteredTxHistory(chainId, safeAddress, filter, hideUntrustedTxs, hideImitationTxs, pageUrl)
        : getTxHistory(chainId, safeAddress, hideUntrustedTxs, hideImitationTxs, pageUrl)
    },
    [filter, pageUrl, chainId, safeAddress, hideUntrustedTxs, hideImitationTxs],
    false,
  )

  const isFetched = filter || pageUrl
  const dataPage = isFetched ? page : historyState.data
  const errorMessage = isFetched ? error?.message : historyState.error
  const isLoading = isFetched ? loading : historyState.loading

  // Return the new page or the stored page
  return useMemo(
    () => ({
      page: dataPage,
      error: errorMessage,
      loading: isLoading,
    }),
    [dataPage, errorMessage, isLoading],
  )
}

export default useTxHistory
</file>

<file path="src/hooks/useTxNotifications.ts">
import { useEffect, useMemo, useRef } from 'react'
import { formatError } from '@safe-global/utils/utils/formatters'
import { selectNotifications, showNotification } from '@/store/notificationsSlice'
import { useAppDispatch, useAppSelector } from '@/store'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'
import { useCurrentChain } from './useChains'
import useTxQueue from './useTxQueue'
import { isSignableBy, isTransactionListItem } from '@/utils/transaction-guards'
import { TransactionStatus } from '@safe-global/safe-gateway-typescript-sdk'
import { selectPendingTxs } from '@/store/pendingTxsSlice'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import useWallet from './wallets/useWallet'
import useSafeAddress from './useSafeAddress'
import { isWalletRejection } from '@/utils/wallets'
import { getTxLink } from '@/utils/tx-link'
import { useLazyGetTransactionDetailsQuery } from '@/store/api/gateway'
import { getExplorerLink } from '@safe-global/utils/utils/gateway'

const TxNotifications = {
  [TxEvent.SIGN_FAILED]: 'Failed to sign. Please try again.',
  [TxEvent.PROPOSED]: 'Successfully added to queue.',
  [TxEvent.PROPOSE_FAILED]: 'Failed to add to queue. Please try again.',
  [TxEvent.DELETED]: 'Successfully deleted transaction.',
  [TxEvent.SIGNATURE_PROPOSED]: 'Successfully signed.',
  [TxEvent.SIGNATURE_PROPOSE_FAILED]: 'Failed to send signature. Please try again.',
  [TxEvent.EXECUTING]: 'Confirm the execution in your wallet.',
  [TxEvent.PROCESSING]: 'Validating...',
  [TxEvent.PROCESSING_MODULE]: 'Validating module interaction...',
  [TxEvent.ONCHAIN_SIGNATURE_REQUESTED]: 'Confirm on-chain signature in your wallet.',
  [TxEvent.ONCHAIN_SIGNATURE_SUCCESS]: 'On-chain signature request confirmed.',
  [TxEvent.PROCESSED]: 'Successfully validated. Indexing...',
  [TxEvent.REVERTED]: 'Reverted. Please check your gas settings.',
  [TxEvent.SUCCESS]: 'Successfully executed.',
  [TxEvent.FAILED]: 'Failed.',
}

enum Variant {
  INFO = 'info',
  SUCCESS = 'success',
  ERROR = 'error',
}

const successEvents = [TxEvent.PROPOSED, TxEvent.SIGNATURE_PROPOSED, TxEvent.ONCHAIN_SIGNATURE_SUCCESS, TxEvent.SUCCESS]

const useTxNotifications = (): void => {
  const dispatch = useAppDispatch()
  const chain = useCurrentChain()
  const safeAddress = useSafeAddress()
  const [trigger] = useLazyGetTransactionDetailsQuery()

  /**
   * Show notifications of a transaction's lifecycle
   */

  useEffect(() => {
    if (!chain) return

    const entries = Object.entries(TxNotifications) as [keyof typeof TxNotifications, string][]

    const unsubFns = entries.map(([event, baseMessage]) =>
      txSubscribe(event, async (detail) => {
        const isError = 'error' in detail
        if (isError && isWalletRejection(detail.error)) return
        const isSuccess = successEvents.includes(event)
        const message = isError ? `${baseMessage} ${formatError(detail.error)}` : baseMessage
        const txId = 'txId' in detail ? detail.txId : undefined
        const txHash = 'txHash' in detail ? detail.txHash : undefined
        const groupKey = 'groupKey' in detail && detail.groupKey ? detail.groupKey : txId || ''

        let humanDescription = 'Transaction'
        const id = txId || txHash
        if (id) {
          try {
            const { data: txDetails } = await trigger({ chainId: chain.chainId, txId: id })
            humanDescription = txDetails?.txInfo.humanDescription || humanDescription
          } catch {}
        }

        dispatch(
          showNotification({
            title: humanDescription,
            message,
            detailedMessage: isError ? detail.error.message : undefined,
            groupKey,
            variant: isError ? Variant.ERROR : isSuccess ? Variant.SUCCESS : Variant.INFO,
            link: txId
              ? getTxLink(txId, chain, safeAddress)
              : txHash
                ? getExplorerLink(txHash, chain.blockExplorerUriTemplate)
                : undefined,
          }),
        )
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [dispatch, safeAddress, chain, trigger])

  /**
   * If there's at least one transaction awaiting confirmations, show a notification for it
   */

  const { page } = useTxQueue()
  const isOwner = useIsSafeOwner()
  const pendingTxs = useAppSelector(selectPendingTxs)
  const notifications = useAppSelector(selectNotifications)
  const wallet = useWallet()
  const notifiedAwaitingTxIds = useRef<Array<string>>([])

  const txsAwaitingConfirmation = useMemo(() => {
    if (!page?.results) {
      return []
    }

    return page.results.filter(isTransactionListItem).filter(({ transaction }) => {
      const isAwaitingConfirmations = transaction.txStatus === TransactionStatus.AWAITING_CONFIRMATIONS
      const isPending = !!pendingTxs[transaction.id]
      const canSign = isSignableBy(transaction, wallet?.address || '')
      return isAwaitingConfirmations && !isPending && canSign
    })
  }, [page?.results, pendingTxs, wallet?.address])

  useEffect(() => {
    if (!isOwner || txsAwaitingConfirmation.length === 0) {
      return
    }

    const txId = txsAwaitingConfirmation[0].transaction.id
    const hasNotified = notifiedAwaitingTxIds.current.includes(txId)

    if (hasNotified) {
      return
    }

    dispatch(
      showNotification({
        variant: 'info',
        message: 'A transaction requires your confirmation.',
        link: chain && getTxLink(txId, chain, safeAddress),
        groupKey: txId,
      }),
    )

    notifiedAwaitingTxIds.current.push(txId)
  }, [chain, dispatch, isOwner, notifications, safeAddress, txsAwaitingConfirmation])
}

export default useTxNotifications
</file>

<file path="src/hooks/useTxPendingStatuses.ts">
import { useAppDispatch, useAppSelector } from '@/store'
import {
  clearPendingTx,
  setPendingTx,
  selectPendingTxs,
  PendingStatus,
  PendingTxType,
  type PendingProcessingTx,
} from '@/store/pendingTxsSlice'
import { useEffect, useMemo, useRef } from 'react'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'
import useChainId from './useChainId'
import { waitForRelayedTx, waitForTx } from '@/services/tx/txMonitor'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import useTxHistory from './useTxHistory'
import { isTransactionListItem } from '@/utils/transaction-guards'
import useSafeInfo from './useSafeInfo'
import { SimpleTxWatcher } from '@/utils/SimpleTxWatcher'

const FINAL_PENDING_STATUSES = [TxEvent.SIGNATURE_INDEXED, TxEvent.SUCCESS, TxEvent.REVERTED, TxEvent.FAILED]

export const useTxMonitor = (): void => {
  const chainId = useChainId()
  const pendingTxs = useAppSelector(selectPendingTxs)
  const pendingTxEntriesOnChain = Object.entries(pendingTxs).filter(([, pendingTx]) => pendingTx.chainId === chainId)
  const provider = useWeb3ReadOnly()

  // Prevent `waitForTx` from monitoring the same tx more than once
  const monitoredTxs = useRef<{ [txId: string]: boolean }>({})

  // Monitor pending transaction mining/validating progress
  useEffect(() => {
    if (!provider || !pendingTxEntriesOnChain) {
      return
    }

    for (const [txId, pendingTx] of pendingTxEntriesOnChain) {
      const isProcessing = pendingTx.status === PendingStatus.PROCESSING
      const isMonitored = monitoredTxs.current[txId]
      const isRelaying = pendingTx.status === PendingStatus.RELAYING

      if (!(isProcessing || isRelaying) || isMonitored) {
        continue
      }

      monitoredTxs.current[txId] = true

      if (isProcessing) {
        waitForTx(
          provider,
          [txId],
          pendingTx.txHash,
          pendingTx.safeAddress,
          pendingTx.signerAddress,
          pendingTx.signerNonce,
          pendingTx.nonce,
          chainId,
        )
        continue
      }

      if (isRelaying) {
        waitForRelayedTx(pendingTx.taskId, [txId], pendingTx.safeAddress, pendingTx.nonce)
      }
    }
    // `provider` is updated when switching chains, re-running this effect
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pendingTxEntriesOnChain.length, provider])
}

const useTxPendingStatuses = (): void => {
  const dispatch = useAppDispatch()
  const { safe, safeAddress } = useSafeInfo()
  const { chainId } = safe
  const txHistory = useTxHistory()
  const historicalTxs = useMemo(() => {
    return txHistory.page?.results?.filter(isTransactionListItem) || []
  }, [txHistory.page?.results])

  useTxMonitor()

  // Subscribe to pending statuses
  useEffect(() => {
    const unsubSignatureProposing = txSubscribe(TxEvent.SIGNATURE_PROPOSED, (detail) => {
      // All pending txns should have a txId
      const txId = 'txId' in detail && detail.txId
      const nonce = 'nonce' in detail ? detail.nonce : undefined

      if (!txId || nonce === undefined) return

      // If we have future issues with statuses, we should refactor `useTxPendingStatuses`
      // @see https://github.com/safe-global/safe-wallet-web/issues/1754
      const isIndexed = historicalTxs.some((tx) => tx.transaction.id === txId)
      if (isIndexed) {
        return
      }

      // Update pendingTx
      dispatch(
        setPendingTx({
          nonce,
          chainId,
          safeAddress,
          txId,
          signerAddress: detail.signerAddress,
          status: PendingStatus.SIGNING,
        }),
      )
    })

    const unsubProcessing = txSubscribe(TxEvent.PROCESSING, (detail) => {
      // All pending txns should have a txId
      const txId = 'txId' in detail && detail.txId
      const nonce = 'nonce' in detail ? detail.nonce : undefined

      if (!txId || nonce === undefined) return

      // If we have future issues with statuses, we should refactor `useTxPendingStatuses`
      // @see https://github.com/safe-global/safe-wallet-web/issues/1754
      const isIndexed = historicalTxs.some((tx) => tx.transaction.id === txId)
      if (isIndexed) {
        return
      }

      const pendingTx: PendingProcessingTx & { txId: string } =
        detail.txType === 'Custom'
          ? {
              nonce,
              chainId,
              safeAddress,
              txId,
              status: PendingStatus.PROCESSING,
              txHash: detail.txHash,
              signerAddress: detail.signerAddress,
              signerNonce: detail.signerNonce,
              submittedAt: Date.now(),
              txType: PendingTxType.CUSTOM_TX,
              data: detail.data,
              to: detail.to,
            }
          : {
              nonce,
              chainId,
              safeAddress,
              txId,
              status: PendingStatus.PROCESSING,
              txHash: detail.txHash,
              signerAddress: detail.signerAddress,
              signerNonce: detail.signerNonce,
              submittedAt: Date.now(),
              gasLimit: detail.gasLimit,
              txType: PendingTxType.SAFE_TX,
            }
      // Update pendingTx
      dispatch(setPendingTx(pendingTx))
    })
    const unsubExecuting = txSubscribe(TxEvent.EXECUTING, (detail) => {
      // All pending txns should have a txId
      const txId = 'txId' in detail && detail.txId
      const nonce = 'nonce' in detail ? detail.nonce : undefined

      if (!txId || nonce === undefined) return

      // If we have future issues with statuses, we should refactor `useTxPendingStatuses`
      // @see https://github.com/safe-global/safe-wallet-web/issues/1754
      const isIndexed = historicalTxs.some((tx) => tx.transaction.id === txId)
      if (isIndexed) {
        return
      }

      // Update pendingTx
      dispatch(
        setPendingTx({
          nonce,
          chainId,
          safeAddress,
          txId,
          status: PendingStatus.SUBMITTING,
        }),
      )
    })

    const unsubProcessed = txSubscribe(TxEvent.PROCESSED, (detail) => {
      // All pending txns should have a txId
      const txId = 'txId' in detail && detail.txId
      const nonce = 'nonce' in detail ? detail.nonce : undefined

      if (!txId || nonce === undefined) return

      // If we have future issues with statuses, we should refactor `useTxPendingStatuses`
      // @see https://github.com/safe-global/safe-wallet-web/issues/1754
      const isIndexed = historicalTxs.some((tx) => tx.transaction.id === txId)
      if (isIndexed) {
        return
      }

      // Update pendingTx
      dispatch(
        setPendingTx({
          nonce,
          chainId,
          safeAddress,
          txId,
          txHash: detail.txHash,
          status: PendingStatus.INDEXING,
        }),
      )
    })
    const unsubRelaying = txSubscribe(TxEvent.RELAYING, (detail) => {
      // All pending txns should have a txId
      const txId = 'txId' in detail && detail.txId
      const nonce = 'nonce' in detail ? detail.nonce : undefined

      if (!txId || nonce === undefined) return

      // If we have future issues with statuses, we should refactor `useTxPendingStatuses`
      // @see https://github.com/safe-global/safe-wallet-web/issues/1754
      const isIndexed = historicalTxs.some((tx) => tx.transaction.id === txId)
      if (isIndexed) {
        return
      }

      // Update pendingTx
      dispatch(
        setPendingTx({
          nonce,
          chainId,
          safeAddress,
          txId,
          status: PendingStatus.RELAYING,
          taskId: detail.taskId,
        }),
      )
    })

    const unsubNestedTx = txSubscribe(TxEvent.NESTED_SAFE_TX_CREATED, (detail) => {
      const txId = detail.txId
      const nonce = detail.nonce

      if (!txId || nonce === undefined) return

      // If we have future issues with statuses, we should refactor `useTxPendingStatuses`
      // @see https://github.com/safe-global/safe-wallet-web/issues/1754
      const isIndexed = historicalTxs.some((tx) => tx.transaction.id === txId)
      if (isIndexed) {
        return
      }

      dispatch(
        setPendingTx({
          nonce,
          chainId,
          safeAddress,
          txId,
          status: PendingStatus.NESTED_SIGNING,
          signerAddress: detail.parentSafeAddress,
          txHashOrParentSafeTxHash: detail.txHashOrParentSafeTxHash,
        }),
      )
    })

    // All final states stop the watcher and clear the pending state
    const unsubFns = FINAL_PENDING_STATUSES.map((event) =>
      txSubscribe(event, (detail) => {
        // All pending txns should have a txId
        const txId = 'txId' in detail && detail.txId
        if (!txId) return

        // Clear the pending status if the tx is no longer pending
        if ('txHash' in detail && detail.txHash) {
          SimpleTxWatcher.getInstance().stopWatchingTxHash(detail.txHash)
        }
        dispatch(clearPendingTx({ txId }))
        return
      }),
    )

    unsubFns.push(
      unsubProcessing,
      unsubSignatureProposing,
      unsubExecuting,
      unsubProcessed,
      unsubRelaying,
      unsubNestedTx,
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [dispatch, chainId, safeAddress, historicalTxs])
}

export default useTxPendingStatuses
</file>

<file path="src/hooks/useTxQueue.ts">
import { getTransactionQueue, type TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import { useAppSelector } from '@/store'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { selectTxQueue, selectQueuedTransactionsByNonce } from '@/store/txQueueSlice'
import useSafeInfo from './useSafeInfo'
import { isTransactionListItem } from '@/utils/transaction-guards'
import { useRecoveryQueue } from '../features/recovery/hooks/useRecoveryQueue'

const useTxQueue = (
  pageUrl?: string,
): {
  page?: TransactionListPage
  error?: string
  loading: boolean
} => {
  const { safe, safeAddress, safeLoaded } = useSafeInfo()
  const { chainId } = safe

  // If pageUrl is passed, load a new queue page from the API
  const [page, error, loading] = useAsync<TransactionListPage>(() => {
    if (!pageUrl || !safeLoaded) return
    return getTransactionQueue(chainId, safeAddress, undefined, pageUrl)
  }, [chainId, safeAddress, safeLoaded, pageUrl])

  // The latest page of the queue is always in the store
  const queueState = useAppSelector(selectTxQueue)

  // Return the new page or the stored page
  return pageUrl
    ? {
        page,
        error: error?.message,
        loading,
      }
    : {
        page: queueState.data,
        error: queueState.error,
        loading: queueState.loading,
      }
}

// Get the size of the queue as a string with an optional '+' if there are more pages
export const useQueuedTxsLength = (): string => {
  const queue = useAppSelector(selectTxQueue)
  const { length } = queue.data?.results.filter(isTransactionListItem) ?? []
  const recoveryQueueSize = useRecoveryQueue().length
  const totalSize = length + recoveryQueueSize
  if (totalSize === 0) return ''
  const hasNextPage = queue.data?.next != null
  return `${totalSize}${hasNextPage ? '+' : ''}`
}

export const useQueuedTxByNonce = (nonce?: number) => {
  return useAppSelector((state) => selectQueuedTransactionsByNonce(state, nonce))
}

export default useTxQueue
</file>

<file path="src/hooks/useTxTracking.ts">
import { trackEvent, WALLET_EVENTS } from '@/services/analytics'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'
import { useEffect } from 'react'
import useChainId from './useChainId'
import { useLazyGetTransactionDetailsQuery } from '@/store/api/gateway'

const events = {
  [TxEvent.SIGNED]: WALLET_EVENTS.OFFCHAIN_SIGNATURE,
  [TxEvent.PROCESSING]: WALLET_EVENTS.ONCHAIN_INTERACTION,
  [TxEvent.PROCESSING_MODULE]: WALLET_EVENTS.ONCHAIN_INTERACTION,
  [TxEvent.RELAYING]: WALLET_EVENTS.ONCHAIN_INTERACTION,
}

export const useTxTracking = (): void => {
  const chainId = useChainId()

  const [trigger] = useLazyGetTransactionDetailsQuery()

  useEffect(() => {
    const unsubFns = Object.entries(events).map(([txEvent, analyticsEvent]) =>
      txSubscribe(txEvent as TxEvent, async (detail) => {
        const txId = 'txId' in detail ? detail.txId : undefined
        const txHash = 'txHash' in detail ? detail.txHash : undefined
        const id = txId || txHash

        let origin = ''

        if (id) {
          try {
            const { data: txDetails } = await trigger({ chainId, txId: id })
            origin = txDetails?.safeAppInfo?.url || ''
          } catch {}
        }

        trackEvent({
          ...analyticsEvent,
          label: origin,
        })
      }),
    )

    return () => {
      unsubFns.forEach((unsub) => unsub())
    }
  }, [chainId, trigger])
}
</file>

<file path="src/hooks/useValidateTxData.ts">
import { SafeTxContext } from '@/components/tx-flow/SafeTxProvider'
import { useSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import useAsync from '@safe-global/utils/hooks/useAsync'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { ethers } from 'ethers'
import { useContext } from 'react'

export const useValidateTxData = (txId?: string) => {
  const { safeTx } = useContext(SafeTxContext)

  const sdk = useSafeSDK()

  return useAsync(async () => {
    if (!sdk || !safeTx) {
      return
    }
    // Validate hash
    const computedSafeTxHash = await sdk.getTransactionHash(safeTx)

    if (txId && txId.slice(-66) !== computedSafeTxHash) {
      return 'The transaction data does not match its safeTxHash'
    }

    // Validate non 1271 signatures
    for (const signature of safeTx.signatures.values()) {
      if (signature.isContractSignature) {
        continue
      }

      const sig = signature.staticPart()
      const v = parseInt(sig.slice(-2), 16)

      if (v === 0 || v === 1) {
        // We ignore pre-validated sigs and EIP1271 for now
        continue
      }
      // ECDSA signature
      if (v === 27 || v === 28) {
        try {
          const recoveredAddress = ethers.recoverAddress(computedSafeTxHash, sig)
          if (recoveredAddress !== signature.signer) {
            return `The signature for the signer ${signature.signer} is invalid`
          }
        } catch (e) {
          logError(ErrorCodes._818, e)
          return `The signature for the signer ${signature.signer} could not be validated`
        }
      }
      // ETH_SIGN signature
      if (v === 31 || v === 32) {
        try {
          const modifiedSig = `${sig.slice(0, -2)}${(v - 4).toString(16)}`
          const recoveredAddress = ethers.verifyMessage(ethers.getBytes(computedSafeTxHash), modifiedSig)
          if (recoveredAddress !== signature.signer) {
            return `The signature for the signer ${signature.signer} is invalid`
          }
        } catch (e) {
          logError(ErrorCodes._818, e)
          return `The signature for the signer ${signature.signer} could not be validated`
        }
      }
    }
  }, [sdk, safeTx, txId])
}
</file>

<file path="src/hooks/useVisibleBalances.ts">
import { safeFormatUnits, safeParseUnits } from '@safe-global/utils/utils/formatters'
import type { SafeBalanceResponse } from '@safe-global/safe-gateway-typescript-sdk'
import { useMemo } from 'react'
import useBalances from './useBalances'
import useHiddenTokens from './useHiddenTokens'

const PRECISION = 18

/**
 * We have to avoid underflows for too high precisions.
 * We only display very few floating points anyway so a precision of 18 should be more than enough.
 */
const truncateNumber = (balance: string): string => {
  const floatingPointPosition = balance.indexOf('.')
  if (floatingPointPosition < 0) {
    return balance
  }

  const currentPrecision = balance.length - floatingPointPosition - 1
  return currentPrecision < PRECISION ? balance : balance.slice(0, floatingPointPosition + PRECISION + 1)
}

const filterHiddenTokens = (items: SafeBalanceResponse['items'], hiddenAssets: string[]) =>
  items.filter((balanceItem) => !hiddenAssets.includes(balanceItem.tokenInfo.address))

const getVisibleFiatTotal = (balances: SafeBalanceResponse, hiddenAssets: string[]): string => {
  return safeFormatUnits(
    balances.items
      .reduce(
        (acc, balanceItem) => {
          if (hiddenAssets.includes(balanceItem.tokenInfo.address)) {
            return acc - BigInt(safeParseUnits(truncateNumber(balanceItem.fiatBalance), PRECISION) ?? 0)
          }
          return acc
        },
        BigInt(balances.fiatTotal === '' ? 0 : (safeParseUnits(truncateNumber(balances.fiatTotal), PRECISION) ?? 0)),
      )
      .toString(),
    PRECISION,
  )
}

export const useVisibleBalances = (): {
  balances: SafeBalanceResponse
  loading: boolean
  error?: string
} => {
  const data = useBalances()
  const hiddenTokens = useHiddenTokens()

  return useMemo(
    () => ({
      ...data,
      balances: {
        items: filterHiddenTokens(data.balances.items, hiddenTokens),
        fiatTotal: data.balances.fiatTotal ? getVisibleFiatTotal(data.balances, hiddenTokens) : '',
      },
    }),
    [data, hiddenTokens],
  )
}
</file>

<file path="src/hooks/useWalletCanPay.ts">
import { getTotalFee } from '@/hooks/useGasPrice'
import useWalletBalance from '@/hooks/wallets/useWalletBalance'

const useWalletCanPay = ({ gasLimit, maxFeePerGas }: { gasLimit?: bigint; maxFeePerGas?: bigint | null }) => {
  const [walletBalance] = useWalletBalance()

  // Take an optimistic approach and assume the wallet can pay
  // if gasLimit, maxFeePerGas or their walletBalance are missing
  if (gasLimit === undefined || maxFeePerGas === undefined || maxFeePerGas === null || walletBalance === undefined)
    return true

  const totalFee = getTotalFee(maxFeePerGas, gasLimit)

  return walletBalance >= totalFee
}

export default useWalletCanPay
</file>

<file path="src/hooks/useWalletCanRelay.ts">
import useAsync from '@safe-global/utils/hooks/useAsync'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWallet from '@/hooks/wallets/useWallet'
import { isSmartContractWallet } from '@/utils/wallets'
import { Errors, logError } from '@/services/exceptions'
import { type SafeTransaction } from '@safe-global/safe-core-sdk-types'

const useWalletCanRelay = (tx: SafeTransaction | undefined) => {
  const { safe } = useSafeInfo()
  const wallet = useWallet()
  const hasEnoughSignatures = tx && tx.signatures.size >= safe.threshold

  return useAsync(() => {
    if (!tx || !wallet) return

    return isSmartContractWallet(wallet.chainId, wallet.address)
      .then((isSCWallet) => {
        if (!isSCWallet) return true

        return hasEnoughSignatures
      })
      .catch((err) => {
        logError(Errors._106, err.message)
        return false
      })
  }, [hasEnoughSignatures, tx, wallet])
}

export default useWalletCanRelay
</file>

<file path="src/pages/apps/bookmarked.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { useRouter } from 'next/router'
import { useEffect } from 'react'
import { AppRoutes } from '@/config/routes'
import { BRAND_NAME } from '@/config/constants'

const BookmarkedSafeApps: NextPage = () => {
  const router = useRouter()

  // Redirect to /apps
  useEffect(() => {
    router.replace({ pathname: AppRoutes.apps.index, query: { safe: router.query.safe } })
  }, [router])

  return (
    <Head>
      <title>{`${BRAND_NAME} – Safe Apps`}</title>
    </Head>
  )
}

export default BookmarkedSafeApps
</file>

<file path="src/pages/apps/custom.tsx">
import { useState } from 'react'
import type { NextPage } from 'next'
import Head from 'next/head'

import { useSafeApps } from '@/hooks/safe-apps/useSafeApps'
import SafeAppsHeader from '@/components/safe-apps/SafeAppsHeader'
import SafeAppList from '@/components/safe-apps/SafeAppList'
import SafeAppsSDKLink from '@/components/safe-apps/SafeAppsSDKLink'
import { RemoveCustomAppModal } from '@/components/safe-apps/RemoveCustomAppModal'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import { SAFE_APPS_LABELS } from '@/services/analytics'
import { BRAND_NAME } from '@/config/constants'

const CustomSafeApps: NextPage = () => {
  // TODO: create a custom hook instead of use useSafeApps
  const { customSafeApps, addCustomApp, removeCustomApp } = useSafeApps()

  const [isOpenRemoveSafeAppModal, setIsOpenRemoveSafeAppModal] = useState<boolean>(false)
  const [customSafeAppToRemove, setCustomSafeAppToRemove] = useState<SafeAppData>()

  const openRemoveCustomAppModal = (customSafeAppToRemove: SafeAppData) => {
    setIsOpenRemoveSafeAppModal(true)
    setCustomSafeAppToRemove(customSafeAppToRemove)
  }

  const onConfirmRemoveCustomAppModal = (safeAppId: number) => {
    removeCustomApp(safeAppId)
    setIsOpenRemoveSafeAppModal(false)
  }

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Custom Safe Apps`}</title>
      </Head>

      <SafeAppsSDKLink />

      <SafeAppsHeader />

      <main>
        <SafeAppList
          title="Custom apps"
          safeAppsList={customSafeApps}
          addCustomApp={addCustomApp}
          removeCustomApp={openRemoveCustomAppModal}
          eventLabel={SAFE_APPS_LABELS.apps_custom}
        />
      </main>

      {/* remove custom safe app modal */}
      {customSafeAppToRemove && (
        <RemoveCustomAppModal
          open={isOpenRemoveSafeAppModal}
          app={customSafeAppToRemove}
          onClose={() => setIsOpenRemoveSafeAppModal(false)}
          onConfirm={onConfirmRemoveCustomAppModal}
        />
      )}
    </>
  )
}

export default CustomSafeApps
</file>

<file path="src/pages/apps/index.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { useRouter } from 'next/router'
import { useCallback, useEffect, useMemo } from 'react'
import debounce from 'lodash/debounce'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

import { useSafeApps } from '@/hooks/safe-apps/useSafeApps'
import SafeAppsSDKLink from '@/components/safe-apps/SafeAppsSDKLink'
import SafeAppsHeader from '@/components/safe-apps/SafeAppsHeader'
import SafeAppList from '@/components/safe-apps/SafeAppList'
import { AppRoutes } from '@/config/routes'
import useSafeAppsFilters from '@/hooks/safe-apps/useSafeAppsFilters'
import SafeAppsFilters from '@/components/safe-apps/SafeAppsFilters'
import { useHasFeature } from '@/hooks/useChains'
import { SAFE_APPS_LABELS } from '@/services/analytics'
import { BRAND_NAME } from '@/config/constants'
import { FEATURES } from '@safe-global/utils/utils/chains'

const SafeApps: NextPage = () => {
  const router = useRouter()
  const { remoteSafeApps, remoteSafeAppsLoading, pinnedSafeApps, pinnedSafeAppIds } = useSafeApps()
  const { filteredApps, query, setQuery, setSelectedCategories, setOptimizedWithBatchFilter, selectedCategories } =
    useSafeAppsFilters(remoteSafeApps)
  const isFiltered = filteredApps.length !== remoteSafeApps.length
  const isSafeAppsEnabled = useHasFeature(FEATURES.SAFE_APPS)

  const featuredSafeApps = useMemo(() => {
    // TODO: Remove assertion after migrating to new SDK
    return remoteSafeApps.filter((app) => (app as SafeAppData & { featured: boolean }).featured)
  }, [remoteSafeApps])

  const nonPinnedApps = useMemo(
    () => remoteSafeApps.filter((app) => !pinnedSafeAppIds.has(app.id)),
    [remoteSafeApps, pinnedSafeAppIds],
  )

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const onChangeQuery = useCallback(debounce(setQuery, 300), [])

  // Redirect to an individual safe app page if the appUrl is in the query params
  useEffect(() => {
    const appUrl = router.query.appUrl as string
    if (appUrl) {
      router.push({ pathname: AppRoutes.apps.open, query: { safe: router.query.safe, appUrl } })
    }
  }, [router])

  if (!isSafeAppsEnabled) return <></>

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Safe Apps`}</title>
      </Head>

      <SafeAppsSDKLink />

      <SafeAppsHeader />

      <main>
        {/* Safe Apps Filters */}
        <SafeAppsFilters
          onChangeQuery={onChangeQuery}
          onChangeFilterCategory={setSelectedCategories}
          onChangeOptimizedWithBatch={setOptimizedWithBatchFilter}
          selectedCategories={selectedCategories}
          safeAppsList={remoteSafeApps}
        />

        {/* Pinned apps */}
        {!isFiltered && pinnedSafeApps.length > 0 && (
          <SafeAppList
            title="My pinned apps"
            safeAppsList={pinnedSafeApps}
            bookmarkedSafeAppsId={pinnedSafeAppIds}
            eventLabel={SAFE_APPS_LABELS.apps_pinned}
          />
        )}

        {/* Featured apps */}
        {!isFiltered && featuredSafeApps.length > 0 && (
          <SafeAppList
            title="Featured apps"
            safeAppsList={featuredSafeApps}
            bookmarkedSafeAppsId={pinnedSafeAppIds}
            eventLabel={SAFE_APPS_LABELS.apps_featured}
          />
        )}

        {/* All apps */}
        <SafeAppList
          title="All apps"
          isFiltered={isFiltered}
          safeAppsList={isFiltered ? filteredApps : nonPinnedApps}
          safeAppsListLoading={remoteSafeAppsLoading}
          bookmarkedSafeAppsId={pinnedSafeAppIds}
          eventLabel={SAFE_APPS_LABELS.apps_all}
          query={query}
          showNativeSwapsCard
        />
      </main>
    </>
  )
}

export default SafeApps
</file>

<file path="src/pages/apps/open.tsx">
import type { NextPage } from 'next'
import { useRouter } from 'next/router'
import { useCallback } from 'react'
import { Box, CircularProgress } from '@mui/material'

import { useSafeAppUrl } from '@/hooks/safe-apps/useSafeAppUrl'
import { useSafeApps } from '@/hooks/safe-apps/useSafeApps'
import SafeAppsInfoModal from '@/components/safe-apps/SafeAppsInfoModal'
import useSafeAppsInfoModal from '@/components/safe-apps/SafeAppsInfoModal/useSafeAppsInfoModal'
import SafeAppsErrorBoundary from '@/components/safe-apps/SafeAppsErrorBoundary'
import SafeAppsLoadError from '@/components/safe-apps/SafeAppsErrorBoundary/SafeAppsLoadError'
import AppFrame from '@/components/safe-apps/AppFrame'
import { useSafeAppFromManifest } from '@/hooks/safe-apps/useSafeAppFromManifest'
import { useBrowserPermissions } from '@/hooks/safe-apps/permissions'
import useChainId from '@/hooks/useChainId'
import { AppRoutes } from '@/config/routes'
import { getOrigin } from '@/components/safe-apps/utils'
import { useHasFeature } from '@/hooks/useChains'

import { FEATURES } from '@safe-global/utils/utils/chains'

const SafeApps: NextPage = () => {
  const chainId = useChainId()
  const router = useRouter()
  const appUrl = useSafeAppUrl()
  const { allSafeApps, remoteSafeAppsLoading } = useSafeApps()
  const safeAppData = allSafeApps.find((app) => app.url === appUrl)
  const { safeApp, isLoading } = useSafeAppFromManifest(appUrl || '', chainId, safeAppData)
  const isSafeAppsEnabled = useHasFeature(FEATURES.SAFE_APPS)

  const { addPermissions, getPermissions, getAllowedFeaturesList } = useBrowserPermissions()
  const origin = getOrigin(appUrl)
  const {
    isModalVisible,
    isSafeAppInDefaultList,
    isFirstTimeAccessingApp,
    isConsentAccepted,
    isPermissionsReviewCompleted,
    onComplete,
  } = useSafeAppsInfoModal({
    url: origin,
    safeApp: safeAppData,
    permissions: safeApp?.safeAppsPermissions || [],
    addPermissions,
    getPermissions,
    remoteSafeAppsLoading,
  })

  const goToList = useCallback(() => {
    router.push({
      pathname: AppRoutes.apps.index,
      query: { safe: router.query.safe },
    })
  }, [router])

  // appUrl is required to be present
  if (!isSafeAppsEnabled || !appUrl || !router.isReady) return null

  // No `safe` query param, redirect to the share route
  if (router.isReady && !router.query.safe) {
    router.push({
      pathname: AppRoutes.share.safeApp,
      query: { appUrl },
    })
    return null
  }

  if (isModalVisible) {
    return (
      <SafeAppsInfoModal
        key={isLoading ? 'loading' : 'loaded'}
        onCancel={goToList}
        onConfirm={onComplete}
        features={safeApp.safeAppsPermissions}
        appUrl={safeApp.url}
        isConsentAccepted={isConsentAccepted}
        isPermissionsReviewCompleted={isPermissionsReviewCompleted}
        isSafeAppInDefaultList={isSafeAppInDefaultList}
        isFirstTimeAccessingApp={isFirstTimeAccessingApp}
      />
    )
  }

  if (isLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100%">
        <CircularProgress />
      </Box>
    )
  }

  return (
    <SafeAppsErrorBoundary render={() => <SafeAppsLoadError onBackToApps={() => router.back()} />}>
      <AppFrame appUrl={appUrl} allowedFeaturesList={getAllowedFeaturesList(origin)} safeAppFromManifest={safeApp} />
    </SafeAppsErrorBoundary>
  )
}

export default SafeApps
</file>

<file path="src/pages/balances/index.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'

import AssetsTable from '@/components/balances/AssetsTable'
import AssetsHeader from '@/components/balances/AssetsHeader'
import useBalances from '@/hooks/useBalances'
import { useState } from 'react'

import PagePlaceholder from '@/components/common/PagePlaceholder'
import NoAssetsIcon from '@/public/images/balances/no-assets.svg'
import HiddenTokenButton from '@/components/balances/HiddenTokenButton'
import CurrencySelect from '@/components/balances/CurrencySelect'
import TokenListSelect from '@/components/balances/TokenListSelect'
import StakingBanner from '@/components/dashboard/StakingBanner'
import useIsStakingBannerEnabled from '@/features/stake/hooks/useIsStakingBannerEnabled'
import { Box } from '@mui/material'
import { BRAND_NAME } from '@/config/constants'

const Balances: NextPage = () => {
  const { error } = useBalances()
  const [showHiddenAssets, setShowHiddenAssets] = useState(false)
  const toggleShowHiddenAssets = () => setShowHiddenAssets((prev) => !prev)
  const isStakingBannerEnabled = useIsStakingBannerEnabled()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Assets`}</title>
      </Head>

      <AssetsHeader>
        <HiddenTokenButton showHiddenAssets={showHiddenAssets} toggleShowHiddenAssets={toggleShowHiddenAssets} />
        <TokenListSelect />
        <CurrencySelect />
      </AssetsHeader>

      <main>
        {isStakingBannerEnabled && (
          <Box mb={2}>
            <StakingBanner />
          </Box>
        )}

        {error ? (
          <PagePlaceholder img={<NoAssetsIcon />} text="There was an error loading your assets" />
        ) : (
          <AssetsTable setShowHiddenAssets={setShowHiddenAssets} showHiddenAssets={showHiddenAssets} />
        )}
      </main>
    </>
  )
}

export default Balances
</file>

<file path="src/pages/balances/nfts.tsx">
import { type ReactElement, memo } from 'react'
import type { NextPage } from 'next'
import Head from 'next/head'
import { Grid, Skeleton, Typography } from '@mui/material'
import AssetsHeader from '@/components/balances/AssetsHeader'
import NftCollections from '@/components/nfts/NftCollections'
import SafeAppCard from '@/components/safe-apps/SafeAppCard'
import { BRAND_NAME, SafeAppsTag } from '@/config/constants'
import { useRemoteSafeApps } from '@/hooks/safe-apps/useRemoteSafeApps'

// `React.memo` requires a `displayName`
const NftApps = memo(function NftApps(): ReactElement | null {
  const [nftApps] = useRemoteSafeApps({ tag: SafeAppsTag.NFT })

  if (nftApps?.length === 0) {
    return null
  }

  return (
    <Grid
      item
      sm={12}
      lg={3}
      sx={{
        order: { lg: 1 },
      }}
    >
      <Typography
        component="h2"
        variant="subtitle1"
        sx={{
          fontWeight: 700,
          mb: 2,
          mt: 0.75,
        }}
      >
        NFT Safe Apps
      </Typography>
      <Grid container spacing={3}>
        {nftApps ? (
          nftApps.map((nftSafeApp) => (
            <Grid item lg={12} md={4} xs={6} key={nftSafeApp.id}>
              <SafeAppCard safeApp={nftSafeApp} />
            </Grid>
          ))
        ) : (
          <Grid item lg={12} md={4} xs={6}>
            <Skeleton variant="rounded" height="245px" />
          </Grid>
        )}
      </Grid>
    </Grid>
  )
})

const NFTs: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – NFTs`}</title>
      </Head>

      <AssetsHeader />

      <main>
        <Grid container spacing={3}>
          <NftApps />

          <Grid item xs>
            <NftCollections />
          </Grid>
        </Grid>
      </main>
    </>
  )
}

export default NFTs
</file>

<file path="src/pages/new-safe/advanced-create.tsx">
import Head from 'next/head'
import type { NextPage } from 'next'

import AdvancedCreateSafe from '@/components/new-safe/create/AdvancedCreateSafe'
import { BRAND_NAME } from '@/config/constants'

const Open: NextPage = () => {
  return (
    <main>
      <Head>
        <title>{`${BRAND_NAME} – Advanced Safe creation`}</title>
      </Head>

      <AdvancedCreateSafe />
    </main>
  )
}

export default Open
</file>

<file path="src/pages/new-safe/create.tsx">
import Head from 'next/head'
import type { NextPage } from 'next'

import CreateSafe from '@/components/new-safe/create'
import { BRAND_NAME } from '@/config/constants'

const Open: NextPage = () => {
  return (
    <main>
      <Head>
        <title>{`${BRAND_NAME} – Create Safe Account`}</title>
      </Head>

      <CreateSafe />
    </main>
  )
}

export default Open
</file>

<file path="src/pages/new-safe/load.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { useRouter } from 'next/router'
import LoadSafe, { loadSafeDefaultData } from '@/components/new-safe/load'
import { BRAND_NAME } from '@/config/constants'

const Load: NextPage = () => {
  const router = useRouter()
  const { address = '' } = router.query
  const safeAddress = Array.isArray(address) ? address[0] : address

  return (
    <main>
      <Head>
        <title>{`${BRAND_NAME} – Add Safe Account`}</title>
      </Head>

      {safeAddress ? (
        <LoadSafe initialData={{ ...loadSafeDefaultData, address: safeAddress }} />
      ) : (
        <LoadSafe initialData={loadSafeDefaultData} />
      )}
    </main>
  )
}

export default Load
</file>

<file path="src/pages/settings/safe-apps/index.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'

import SafeAppsPermissions from '@/components/settings/SafeAppsPermissions'
import SettingsHeader from '@/components/settings/SettingsHeader'
import { SafeAppsSigningMethod } from '@/components/settings/SafeAppsSigningMethod'
import { BRAND_NAME } from '@/config/constants'

const SafeAppsPermissionsPage: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Safe Apps`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <SafeAppsPermissions />
        <SafeAppsSigningMethod />
      </main>
    </>
  )
}

export default SafeAppsPermissionsPage
</file>

<file path="src/pages/settings/appearance.tsx">
import { Checkbox, FormControlLabel, FormGroup, Grid, Paper, Typography, Switch } from '@mui/material'
import type { ChangeEvent } from 'react'
import type { NextPage } from 'next'
import Head from 'next/head'

import { useAppDispatch, useAppSelector } from '@/store'
import { selectSettings, setCopyShortName, setDarkMode } from '@/store/settingsSlice'
import SettingsHeader from '@/components/settings/SettingsHeader'
import { trackEvent, SETTINGS_EVENTS } from '@/services/analytics'
import { useDarkMode } from '@/hooks/useDarkMode'
import ExternalLink from '@/components/common/ExternalLink'
import { BRAND_NAME } from '@/config/constants'

const Appearance: NextPage = () => {
  const dispatch = useAppDispatch()
  const settings = useAppSelector(selectSettings)
  const isDarkMode = useDarkMode()

  const handleToggle = (
    action: typeof setCopyShortName | typeof setDarkMode,
    event: typeof SETTINGS_EVENTS.APPEARANCE.COPY_PREFIXES | typeof SETTINGS_EVENTS.APPEARANCE.DARK_MODE,
  ) => {
    return (_: ChangeEvent<HTMLInputElement>, checked: boolean) => {
      dispatch(action(checked))

      trackEvent({
        ...event,
        label: checked,
      })
    }
  }

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Appearance`}</title>
      </Head>
      <SettingsHeader />
      <main>
        <Paper sx={{ p: 4 }}>
          <Grid container spacing={3}>
            <Grid item lg={4} xs={12}>
              <Typography
                variant="h4"
                sx={{
                  fontWeight: 'bold',
                  mb: 1,
                }}
              >
                Chain-specific addresses
              </Typography>
            </Grid>

            <Grid item xs>
              <Typography
                sx={{
                  mb: 2,
                }}
              >
                Choose whether to copy{' '}
                <ExternalLink href="https://eips.ethereum.org/EIPS/eip-3770">EIP-3770</ExternalLink> prefixes when
                copying Ethereum addresses.
              </Typography>
              <FormGroup>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={settings.shortName.copy}
                      onChange={handleToggle(setCopyShortName, SETTINGS_EVENTS.APPEARANCE.COPY_PREFIXES)}
                    />
                  }
                  label="Copy addresses with chain prefix"
                />
              </FormGroup>
            </Grid>
          </Grid>

          <Grid
            container
            spacing={3}
            sx={{
              alignItems: 'center',
              marginTop: 2,
            }}
          >
            <Grid item lg={4} xs={12}>
              <Typography
                variant="h4"
                sx={{
                  fontWeight: 'bold',
                }}
              >
                Theme
              </Typography>
            </Grid>

            <Grid item xs>
              <FormControlLabel
                control={
                  <Switch
                    checked={isDarkMode}
                    onChange={handleToggle(setDarkMode, SETTINGS_EVENTS.APPEARANCE.DARK_MODE)}
                  />
                }
                label="Dark mode"
              />
            </Grid>
          </Grid>
        </Paper>
      </main>
    </>
  )
}

export default Appearance
</file>

<file path="src/pages/settings/data.tsx">
import DataManagement from '@/components/settings/DataManagement'
import SettingsHeader from '@/components/settings/SettingsHeader'
import { BRAND_NAME } from '@/config/constants'
import type { NextPage } from 'next'
import Head from 'next/head'

const Data: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Data`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <DataManagement />
      </main>
    </>
  )
}

export default Data
</file>

<file path="src/pages/settings/environment-variables.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import SettingsHeader from '@/components/settings/SettingsHeader'
import EnvironmentVariables from '@/components/settings/EnvironmentVariables'
import { BRAND_NAME } from '@/config/constants'

const EnvironmentVariablesPage: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Environment variables`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <EnvironmentVariables />
      </main>
    </>
  )
}

export default EnvironmentVariablesPage
</file>

<file path="src/pages/settings/index.tsx">
import { useEffect } from 'react'
import type { NextPage } from 'next'
import Head from 'next/head'
import { useRouter } from 'next/router'
import { generalSettingsNavItems, settingsNavItems } from '@/components/sidebar/SidebarNavigation/config'
import { BRAND_NAME } from '@/config/constants'

const Settings: NextPage = () => {
  const router = useRouter()

  useEffect(() => {
    const redirectPath = router.query.safe ? settingsNavItems[0].href : generalSettingsNavItems[0].href
    router.push(redirectPath, {
      query: router.query,
    })
  }, [router, router.query.safe])

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings`}</title>
      </Head>
    </>
  )
}

export default Settings
</file>

<file path="src/pages/settings/modules.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { Grid } from '@mui/material'
import SafeModules from '@/components/settings/SafeModules'
import TransactionGuards from '@/components/settings/TransactionGuards'
import SettingsHeader from '@/components/settings/SettingsHeader'
import { FallbackHandler } from '@/components/settings/FallbackHandler'
import { BRAND_NAME } from '@/config/constants'

const Modules: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Modules`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <Grid container direction="column" spacing={2}>
          <Grid item>
            <SafeModules />
          </Grid>

          <Grid item>
            <TransactionGuards />
          </Grid>

          <Grid item>
            <FallbackHandler />
          </Grid>
        </Grid>
      </main>
    </>
  )
}

export default Modules
</file>

<file path="src/pages/settings/notifications.tsx">
import Head from 'next/head'
import type { NextPage } from 'next'

import SettingsHeader from '@/components/settings/SettingsHeader'
import { PushNotifications } from '@/components/settings/PushNotifications'
import { useHasFeature } from '@/hooks/useChains'
import { BRAND_NAME } from '@/config/constants'
import { FEATURES } from '@safe-global/utils/utils/chains'

const NotificationsPage: NextPage = () => {
  const isNotificationFeatureEnabled = useHasFeature(FEATURES.PUSH_NOTIFICATIONS)

  if (!isNotificationFeatureEnabled) {
    return null
  }

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Notifications`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <PushNotifications />
      </main>
    </>
  )
}

export default NotificationsPage
</file>

<file path="src/pages/settings/security.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'

import SettingsHeader from '@/components/settings/SettingsHeader'
import SecurityLogin from '@/components/settings/SecurityLogin'
import { BRAND_NAME } from '@/config/constants'

const SecurityPage: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Security`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <SecurityLogin />
      </main>
    </>
  )
}

export default SecurityPage
</file>

<file path="src/pages/settings/setup.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { Grid, Paper, Skeleton, SvgIcon, Tooltip, Typography, Box } from '@mui/material'
import InfoIcon from '@/public/images/notifications/info.svg'
import { ContractVersion } from '@/components/settings/ContractVersion'
import { OwnerList } from '@/components/settings/owner/OwnerList'
import { RequiredConfirmation } from '@/components/settings/RequiredConfirmations'
import useSafeInfo from '@/hooks/useSafeInfo'
import SettingsHeader from '@/components/settings/SettingsHeader'
import ProposersList from 'src/components/settings/ProposersList'
import SpendingLimits from '@/components/settings/SpendingLimits'
import { BRAND_NAME } from '@/config/constants'
import { NestedSafesList } from '@/components/settings/NestedSafesList'

const Setup: NextPage = () => {
  const { safe, safeLoaded } = useSafeInfo()
  const nonce = safe.nonce
  const ownerLength = safe.owners.length
  const threshold = safe.threshold

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Settings – Setup`}</title>
      </Head>

      <SettingsHeader />

      <main>
        <Paper data-testid="setup-section" sx={{ p: 4, mb: 2 }}>
          <Grid container spacing={3}>
            <Grid item lg={4} xs={12}>
              <Typography variant="h4" fontWeight={700}>
                <Tooltip
                  placement="top"
                  title="For security reasons, transactions made with a Safe Account need to be executed in order. The nonce shows you which transaction will be executed next. You can find the nonce for a transaction in the transaction details."
                >
                  <span>
                    Safe Account nonce
                    <SvgIcon
                      component={InfoIcon}
                      inheritViewBox
                      fontSize="small"
                      color="border"
                      sx={{ verticalAlign: 'middle', ml: 0.5 }}
                    />
                  </span>
                </Tooltip>
              </Typography>

              <Typography pt={1}>
                Current nonce:{' '}
                {safeLoaded ? <b>{nonce}</b> : <Skeleton width="30px" sx={{ display: 'inline-block' }} />}
              </Typography>
            </Grid>

            <Grid item xs>
              <ContractVersion />
            </Grid>
          </Grid>
        </Paper>

        <Paper sx={{ p: 4, mb: 2 }}>
          <Grid container spacing={3}>
            <Grid item lg={4} xs={12}>
              <Typography variant="h4" fontWeight={700}>
                Members
              </Typography>
            </Grid>

            <Grid item xs>
              <Box display="flex" flexDirection="column" gap={2}>
                <OwnerList />
                <ProposersList />
              </Box>
            </Grid>
          </Grid>

          <RequiredConfirmation threshold={threshold} owners={ownerLength} />
        </Paper>

        <SpendingLimits />

        <NestedSafesList />
      </main>
    </>
  )
}

export default Setup
</file>

<file path="src/pages/share/safe-app.tsx">
import Head from 'next/head'
import { Box, CircularProgress } from '@mui/material'
import { useSafeAppUrl } from '@/hooks/safe-apps/useSafeAppUrl'
import { SafeAppLanding } from '@/components/safe-apps/SafeAppLandingPage'
import { useCurrentChain } from '@/hooks/useChains'
import { BRAND_NAME } from '@/config/constants'

const ShareSafeApp = () => {
  const appUrl = useSafeAppUrl()
  const chain = useCurrentChain()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Safe Apps`}</title>
      </Head>

      <main>
        {appUrl && chain ? (
          <SafeAppLanding appUrl={appUrl} chain={chain} />
        ) : (
          <Box py={4} textAlign="center">
            <CircularProgress size={40} />
          </Box>
        )}
      </main>
    </>
  )
}

export default ShareSafeApp
</file>

<file path="src/pages/spaces/index.tsx">
import { useRouter } from 'next/router'
import Head from 'next/head'
import { BRAND_NAME } from '@/config/constants'
import SpaceDashboard from '@/features/spaces/components/Dashboard'
import AuthState from '@/features/spaces/components/AuthState'

export default function SpacePage() {
  const router = useRouter()
  const { spaceId } = router.query

  if (!router.isReady || !spaceId || typeof spaceId !== 'string') return null

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Space dashboard`}</title>
      </Head>

      <main>
        <AuthState spaceId={spaceId}>
          <SpaceDashboard />
        </AuthState>
      </main>
    </>
  )
}
</file>

<file path="src/pages/spaces/members.tsx">
import { useRouter } from 'next/router'
import Head from 'next/head'
import { BRAND_NAME } from '@/config/constants'
import SpaceMembers from '@/features/spaces/components/Members'
import AuthState from '@/features/spaces/components/AuthState'

export default function SpaceMembersPage() {
  const router = useRouter()
  const { spaceId } = router.query

  if (!router.isReady || !spaceId || typeof spaceId !== 'string') return null

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Space members`}</title>
      </Head>

      <main>
        <AuthState spaceId={spaceId}>
          <SpaceMembers />
        </AuthState>
      </main>
    </>
  )
}
</file>

<file path="src/pages/spaces/safe-accounts.tsx">
import { useRouter } from 'next/router'
import Head from 'next/head'
import { BRAND_NAME } from '@/config/constants'
import SpaceSafeAccounts from '@/features/spaces/components/SafeAccounts'
import AuthState from '@/features/spaces/components/AuthState'

export default function SpaceAccountsPage() {
  const router = useRouter()
  const { spaceId } = router.query

  if (!router.isReady || !spaceId || typeof spaceId !== 'string') return null

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Space Safe Accounts`}</title>
      </Head>

      <main>
        <AuthState spaceId={spaceId}>
          <SpaceSafeAccounts />
        </AuthState>
      </main>
    </>
  )
}
</file>

<file path="src/pages/spaces/settings.tsx">
import { useRouter } from 'next/router'
import Head from 'next/head'
import { BRAND_NAME } from '@/config/constants'
import SpaceSettings from 'src/features/spaces/components/SpaceSettings'
import AuthState from '@/features/spaces/components/AuthState'

export default function SpaceSettingsPage() {
  const router = useRouter()
  const { spaceId } = router.query

  if (!router.isReady || !spaceId || typeof spaceId !== 'string') return null

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Space settings`}</title>
      </Head>

      <main>
        <AuthState spaceId={spaceId}>
          <SpaceSettings />
        </AuthState>
      </main>
    </>
  )
}
</file>

<file path="src/pages/transactions/history.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import useTxHistory from '@/hooks/useTxHistory'
import PaginatedTxns from '@/components/common/PaginatedTxns'
import TxHeader from '@/components/transactions/TxHeader'
import { Box } from '@mui/material'
import { useState } from 'react'
import Button from '@mui/material/Button'
import ExpandLessIcon from '@mui/icons-material/ExpandLess'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import TxFilterForm from '@/components/transactions/TxFilterForm'
import TrustedToggle from '@/components/transactions/TrustedToggle'
import { useTxFilter } from '@/utils/tx-history-filter'
import { BRAND_NAME } from '@/config/constants'

const History: NextPage = () => {
  const [filter] = useTxFilter()

  const [showFilter, setShowFilter] = useState(false)

  const toggleFilter = () => {
    setShowFilter((prev) => !prev)
  }

  const ExpandIcon = showFilter ? ExpandLessIcon : ExpandMoreIcon
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Transaction history`}</title>
      </Head>

      <TxHeader>
        <TrustedToggle />

        <Button variant="outlined" onClick={toggleFilter} size="small" endIcon={<ExpandIcon />}>
          {filter?.type ?? 'Filter'}
        </Button>
      </TxHeader>

      <main>
        {showFilter && <TxFilterForm toggleFilter={toggleFilter} />}

        <Box mb={4}>
          <PaginatedTxns useTxns={useTxHistory} />
        </Box>
      </main>
    </>
  )
}

export default History
</file>

<file path="src/pages/transactions/index.tsx">
import HistoryPage from './history'

export default HistoryPage
</file>

<file path="src/pages/transactions/messages.tsx">
import { useEffect } from 'react'
import Head from 'next/head'
import { useRouter } from 'next/router'
import type { NextPage } from 'next'

import PaginatedMsgs from '@/components/safe-messages/PaginatedMsgs'
import TxHeader from '@/components/transactions/TxHeader'
import SignedMessagesHelpLink from '@/components/transactions/SignedMessagesHelpLink'
import { AppRoutes } from '@/config/routes'
import { useCurrentChain } from '@/hooks/useChains'
import { BRAND_NAME } from '@/config/constants'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

const Messages: NextPage = () => {
  const chain = useCurrentChain()
  const router = useRouter()

  useEffect(() => {
    if (!chain || hasFeature(chain, FEATURES.EIP1271)) {
      return
    }

    router.replace({ ...router, pathname: AppRoutes.transactions.history })
  }, [router, chain])

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Messages`}</title>
      </Head>

      <TxHeader>
        <SignedMessagesHelpLink />
      </TxHeader>

      <main>
        <PaginatedMsgs />
      </main>
    </>
  )
}

export default Messages
</file>

<file path="src/pages/transactions/msg.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'

import Typography from '@mui/material/Typography'
import SingleMsg from '@/components/safe-messages/SingleMsg'
import { BRAND_NAME } from '@/config/constants'

const SingleTransaction: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Message details`}</title>
      </Head>

      <main>
        <Typography data-testid="tx-details" variant="h3" fontWeight={700} pt={1} mb={3}>
          Message details
        </Typography>

        <SingleMsg />
      </main>
    </>
  )
}

export default SingleTransaction
</file>

<file path="src/pages/transactions/queue.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import useTxQueue from '@/hooks/useTxQueue'
import PaginatedTxns from '@/components/common/PaginatedTxns'
import TxHeader from '@/components/transactions/TxHeader'
import BatchExecuteButton from '@/components/transactions/BatchExecuteButton'
import { Box } from '@mui/material'
import { BatchExecuteHoverProvider } from '@/components/transactions/BatchExecuteButton/BatchExecuteHoverProvider'
import { usePendingTxsQueue, useShowUnsignedQueue } from '@/hooks/usePendingTxs'
import RecoveryList from '@/features/recovery/components/RecoveryList'
import { BRAND_NAME } from '@/config/constants'

const Queue: NextPage = () => {
  const showPending = useShowUnsignedQueue()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Transaction queue`}</title>
      </Head>

      <BatchExecuteHoverProvider>
        <TxHeader>
          <BatchExecuteButton />
        </TxHeader>

        <main>
          <Box mb={4}>
            <RecoveryList />

            {/* Pending unsigned transactions */}
            {showPending && <PaginatedTxns useTxns={usePendingTxsQueue} />}

            {/* The main queue of signed transactions */}
            <PaginatedTxns useTxns={useTxQueue} />
          </Box>
        </main>
      </BatchExecuteHoverProvider>
    </>
  )
}

export default Queue
</file>

<file path="src/pages/transactions/tx.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'

import SingleTx from '@/components/transactions/SingleTx'
import Typography from '@mui/material/Typography'
import { BRAND_NAME } from '@/config/constants'

const SingleTransaction: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Transaction details`}</title>
      </Head>

      <main>
        <Typography data-testid="tx-details" variant="h3" fontWeight={700} pt={1} mb={3}>
          Transaction details
        </Typography>

        <SingleTx />
      </main>
    </>
  )
}

export default SingleTransaction
</file>

<file path="src/pages/welcome/accounts.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import MyAccounts from '@/features/myAccounts'
import { BRAND_NAME } from '@/config/constants'

const Accounts: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – My accounts`}</title>
      </Head>

      <MyAccounts />
    </>
  )
}

export default Accounts
</file>

<file path="src/pages/welcome/index.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import NewSafe from '@/components/welcome/NewSafe'
import { BRAND_NAME } from '@/config/constants'

const Welcome: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Welcome`}</title>
      </Head>

      <NewSafe />
    </>
  )
}

export default Welcome
</file>

<file path="src/pages/welcome/spaces.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import SpacesList from '@/features/spaces/components/SpacesList'
import { BRAND_NAME } from '@/config/constants'
import useFeatureFlagRedirect from '@/features/spaces/hooks/useFeatureFlagRedirect'
import { useHasFeature } from '@/hooks/useChains'
import { FEATURES } from '@safe-global/utils/utils/chains'

const Spaces: NextPage = () => {
  const isSpacesFeatureEnabled = useHasFeature(FEATURES.SPACES)
  useFeatureFlagRedirect()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Spaces`}</title>
      </Head>

      {isSpacesFeatureEnabled && <SpacesList />}
    </>
  )
}

export default Spaces
</file>

<file path="src/pages/_app.tsx">
import Analytics from '@/services/analytics/Analytics'
import { SentryErrorBoundary } from '@/services/sentry'
import type { ReactNode } from 'react'
import { type ReactElement } from 'react'
import { type AppProps } from 'next/app'
import Head from 'next/head'
import { Provider } from 'react-redux'
import CssBaseline from '@mui/material/CssBaseline'
import type { Theme } from '@mui/material/styles'
import { ThemeProvider } from '@mui/material/styles'
import { setBaseUrl as setGatewayBaseUrl } from '@safe-global/safe-gateway-typescript-sdk'
import { setBaseUrl as setNewGatewayBaseUrl } from '@safe-global/safe-client-gateway-sdk'
import { CacheProvider, type EmotionCache } from '@emotion/react'
import SafeThemeProvider from '@/components/theme/SafeThemeProvider'
import '@/styles/globals.css'
import { BRAND_NAME } from '@/config/constants'
import { makeStore, useHydrateStore } from '@/store'
import PageLayout from '@/components/common/PageLayout'
import useLoadableStores from '@/hooks/useLoadableStores'
import { useInitOnboard } from '@/hooks/wallets/useOnboard'
import { useInitWeb3 } from '@/hooks/wallets/useInitWeb3'
import { useInitSafeCoreSDK } from '@/hooks/coreSDK/useInitSafeCoreSDK'
import useTxNotifications from '@/hooks/useTxNotifications'
import useSafeNotifications from '@/hooks/useSafeNotifications'
import useTxPendingStatuses from '@/hooks/useTxPendingStatuses'
import { useInitSession } from '@/hooks/useInitSession'
import Notifications from '@/components/common/Notifications'
import CookieAndTermBanner from 'src/components/common/CookieAndTermBanner'
import { useDarkMode } from '@/hooks/useDarkMode'
import { useTxTracking } from '@/hooks/useTxTracking'
import { useSafeMsgTracking } from '@/hooks/messages/useSafeMsgTracking'
import useGtm from '@/services/analytics/useGtm'
import useBeamer from '@/hooks/Beamer/useBeamer'
import ErrorBoundary from '@/components/common/ErrorBoundary'
import createEmotionCache from '@/utils/createEmotionCache'
import MetaTags from '@/components/common/MetaTags'
import useAdjustUrl from '@/hooks/useAdjustUrl'
import useSafeMessageNotifications from '@/hooks/messages/useSafeMessageNotifications'
import useSafeMessagePendingStatuses from '@/hooks/messages/useSafeMessagePendingStatuses'
import useChangedValue from '@/hooks/useChangedValue'
import { TxModalProvider } from '@/components/tx-flow'
import { useNotificationTracking } from '@/components/settings/PushNotifications/hooks/useNotificationTracking'
import Recovery from '@/features/recovery/components/Recovery'
import WalletProvider from '@/components/common/WalletProvider'
import CounterfactualHooks from '@/features/counterfactual/CounterfactualHooks'
import PkModulePopup from '@/services/private-key-module/PkModulePopup'
import GeoblockingProvider from '@/components/common/GeoblockingProvider'
import { useVisitedSafes } from '@/features/myAccounts/hooks/useVisitedSafes'
import OutreachPopup from '@/features/targetedOutreach/components/OutreachPopup'
import { GATEWAY_URL } from '@/config/gateway'
import { useDatadog } from '@/services/datadog'

const reduxStore = makeStore()

const InitApp = (): null => {
  setGatewayBaseUrl(GATEWAY_URL)
  setNewGatewayBaseUrl(GATEWAY_URL)
  useHydrateStore(reduxStore)
  useAdjustUrl()
  useDatadog()
  useGtm()
  useNotificationTracking()
  useInitSession()
  useLoadableStores()
  useInitOnboard()
  useInitWeb3()
  useInitSafeCoreSDK()
  useTxNotifications()
  useSafeMessageNotifications()
  useSafeNotifications()
  useTxPendingStatuses()
  useSafeMessagePendingStatuses()
  useTxTracking()
  useSafeMsgTracking()
  useBeamer()
  useVisitedSafes()

  return null
}

// Client-side cache, shared for the whole session of the user in the browser.
const clientSideEmotionCache = createEmotionCache()

export const AppProviders = ({ children }: { children: ReactNode | ReactNode[] }) => {
  const isDarkMode = useDarkMode()
  const themeMode = isDarkMode ? 'dark' : 'light'

  return (
    <SafeThemeProvider mode={themeMode}>
      {(safeTheme: Theme) => (
        <ThemeProvider theme={safeTheme}>
          <SentryErrorBoundary showDialog fallback={ErrorBoundary}>
            <WalletProvider>
              <GeoblockingProvider>
                <TxModalProvider>{children}</TxModalProvider>
              </GeoblockingProvider>
            </WalletProvider>
          </SentryErrorBoundary>
        </ThemeProvider>
      )}
    </SafeThemeProvider>
  )
}

interface SafeWalletAppProps extends AppProps {
  emotionCache?: EmotionCache
}

const SafeWalletApp = ({
  Component,
  pageProps,
  router,
  emotionCache = clientSideEmotionCache,
}: SafeWalletAppProps): ReactElement => {
  const safeKey = useChangedValue(router.query.safe?.toString())

  return (
    <Provider store={reduxStore}>
      <Head>
        <title key="default-title">{BRAND_NAME}</title>
        <MetaTags prefetchUrl={GATEWAY_URL} />
      </Head>

      <CacheProvider value={emotionCache}>
        <AppProviders>
          <CssBaseline />

          <InitApp />

          <PageLayout pathname={router.pathname}>
            <Component {...pageProps} key={safeKey} />
          </PageLayout>

          <CookieAndTermBanner />

          <OutreachPopup />

          <Notifications />

          <Recovery />

          <CounterfactualHooks />

          <Analytics />

          <PkModulePopup />
        </AppProviders>
      </CacheProvider>
    </Provider>
  )
}

export default SafeWalletApp
</file>

<file path="src/pages/_document.tsx">
/**
 * This file is needed to embed MUI theme CSS into the pre-built HTML files
 * @see https://github.com/mui/material-ui/tree/master/examples/nextjs-with-typescript
 */
import type { DocumentContext } from 'next/document'
import Document, { Html, Head, Main, NextScript } from 'next/document'
import createEmotionServer from '@emotion/server/create-instance'
import createEmotionCache from '@/utils/createEmotionCache'

export default class WebCoreDocument extends Document {
  render() {
    return (
      <Html lang="en">
        <Head>
          <meta name="emotion-insertion-point" content="" />
          {(this.props as any).emotionStyleTags}
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    )
  }
}

const getInitialProps = async (ctx: DocumentContext) => {
  const originalRenderPage = ctx.renderPage

  // You can consider sharing the same Emotion cache between all the SSR requests to speed up performance.
  // However, be aware that it can have global side effects.
  const cache = createEmotionCache()
  const { extractCriticalToChunks } = createEmotionServer(cache)

  ctx.renderPage = () =>
    originalRenderPage({
      enhanceApp: (App: any) =>
        function EnhanceApp(props) {
          return <App emotionCache={cache} {...props} />
        },
    })

  const initialProps = await Document.getInitialProps(ctx)
  // This is important. It prevents Emotion to render invalid HTML.
  // See https://github.com/mui/material-ui/issues/26561#issuecomment-855286153
  const emotionStyles = extractCriticalToChunks(initialProps.html)
  const emotionStyleTags = emotionStyles.styles.map((style) => (
    <style
      data-emotion={`${style.key} ${style.ids.join(' ')}`}
      key={style.key}
      dangerouslySetInnerHTML={{ __html: style.css }}
    />
  ))

  return {
    ...initialProps,
    emotionStyleTags,
  }
}

WebCoreDocument.getInitialProps = getInitialProps
</file>

<file path="src/pages/_offline.tsx">
import { Box, Paper, Typography } from '@mui/material'
import WifiOffIcon from '@mui/icons-material/WifiOff'
import type { NextPage } from 'next'
import Head from 'next/head'
import { BRAND_NAME } from '@/config/constants'

const Offline: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Offline`}</title>
      </Head>

      <main>
        <Box display="flex" justifyContent="center">
          <Paper sx={{ p: 4, mb: 2, maxWidth: 900 }}>
            <Box display="flex" justifyContent="center" mb={2} fontSize={100}>
              <WifiOffIcon fontSize="inherit" />
            </Box>

            <Typography variant="h1" textAlign="center">
              Oops, it looks like you&apos;re offline!
            </Typography>

            <Typography variant="body1" mt={3}>
              We apologize, but it looks like you are currently unable to access our app due to an offline connection.
            </Typography>

            <Typography variant="body1" mt={2}>
              While you wait for your internet to come back online, we encourage you to take a moment to step outside
              and enjoy the nature. If you have the opportunity, try touching the grass with your bare feet -
              there&apos;s something about the sensation of grass on our skin that can be really grounding and
              refreshing.
            </Typography>

            <Typography variant="body1" mt={2}>
              We hope to see you back online soon. Thank you for your patience.
            </Typography>
          </Paper>
        </Box>
      </main>
    </>
  )
}

export default Offline
</file>

<file path="src/pages/403.tsx">
import { AppRoutes } from '@/config/routes'
import type { NextPage } from 'next'
import Link from 'next/link'
import MUILink from '@mui/material/Link'

const Custom403: NextPage = () => {
  return (
    <main>
      <h1>403 - Access Restricted</h1>
      <p>
        We regret to inform you that access to this service is currently unavailable in your region. For further
        information, you may refer to our{' '}
        <Link href={AppRoutes.terms} passHref legacyBehavior>
          <MUILink target="_blank" rel="noreferrer">
            terms
          </MUILink>
        </Link>
        . We apologize for any inconvenience this may cause. Thank you for your understanding.
      </p>
    </main>
  )
}

export default Custom403
</file>

<file path="src/pages/404.tsx">
import { useEffect, useState } from 'react'
import type { NextPage } from 'next'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'

// Rewrite the URL to put the Safe address into the query.
export const _getRedirectUrl = (location: Location): string | undefined => {
  const { pathname, search } = location
  const re = /^\/([^/]+?:0x[0-9a-f]{40})/i
  const [, pathSafe] = pathname.match(re) || []

  if (pathSafe) {
    let newPath = pathname.replace(re, '') || AppRoutes.home
    let newSearch = search ? '&' + search.slice(1) : ''

    // TxId used to be in the path, rewrite it to the query
    if (newPath.startsWith(AppRoutes.transactions.index)) {
      const isStaticPath = Object.values(AppRoutes.transactions).some((route) => route === newPath)
      if (!isStaticPath) {
        const txId = newPath.match(/\/transactions\/([^/]+)/)?.[1]
        newPath = AppRoutes.transactions.tx
        newSearch = `${newSearch}&id=${txId}`
      }
    }

    if (newPath !== pathname) {
      return `${newPath}?safe=${pathSafe}${newSearch}`
    }
  }
}

const Custom404: NextPage = () => {
  const router = useRouter()
  const [isRedirecting, setIsRedirecting] = useState<boolean>(true)

  useEffect(() => {
    if (typeof location === 'undefined') return

    const redirectUrl = _getRedirectUrl(location)

    if (redirectUrl) {
      router.replace(redirectUrl)
    } else {
      setIsRedirecting(false)
    }
  }, [router])

  return <main>{!isRedirecting && <h1>404 - Page not found</h1>}</main>
}

export default Custom404
</file>

<file path="src/pages/addOwner.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { useRouter } from 'next/router'
import { useContext, useEffect } from 'react'
import { TxModalContext } from '@/components/tx-flow'
import { AddOwnerFlow } from '@/components/tx-flow/flows'
import { AppRoutes } from '@/config/routes'
import { BRAND_NAME } from '@/config/constants'

const AddOwner: NextPage = () => {
  const router = useRouter()
  const { address } = router.query
  const ownerAddress = Array.isArray(address) ? address[0] : address
  const { setTxFlow } = useContext(TxModalContext)

  useEffect(() => {
    router.push({ pathname: AppRoutes.settings.setup, query: router.query }).then(() => {
      if (!ownerAddress) return

      setTxFlow(<AddOwnerFlow address={ownerAddress} />)
    })
  }, [ownerAddress, router, setTxFlow])

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Add Signer`}</title>
      </Head>
    </>
  )
}

export default AddOwner
</file>

<file path="src/pages/address-book.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import AddressBookTable from '@/components/address-book/AddressBookTable'
import { BRAND_NAME } from '@/config/constants'

const AddressBook: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Address book`}</title>
      </Head>

      <AddressBookTable />
    </>
  )
}

export default AddressBook
</file>

<file path="src/pages/bridge.tsx">
import Head from 'next/head'
import type { NextPage } from 'next'

import { Bridge } from '@/features/bridge/components/Bridge'
import { BRAND_NAME } from '@/config/constants'

const BridgePage: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Bridge`}</title>
      </Head>
      <Bridge />
    </>
  )
}

export default BridgePage
</file>

<file path="src/pages/home.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'

import Dashboard from '@/components/dashboard'
import { BRAND_NAME } from '@/config/constants'

const Home: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Dashboard`}</title>
      </Head>

      <main>
        <Dashboard />
      </main>
    </>
  )
}

export default Home
</file>

<file path="src/pages/imprint.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { Typography } from '@mui/material'
import Link from 'next/link'
import MUILink from '@mui/material/Link'
import { useIsOfficialHost } from '@/hooks/useIsOfficialHost'
import { BRAND_NAME } from '@/config/constants'

const SafeImprint = () => (
  <div>
    <Typography variant="h1" mb={2}>
      Imprint & Disclaimer
    </Typography>
    <Typography variant="h3" mb={2}>
      Information in accordance with section 5 of the Telemedia Act (TMG, Germany):
    </Typography>
    <Typography mb={2}>
      Core Contributors GmbH
      <br />
      c/o WeWork
      <br />
      Dircksenstr. 3
      <br />
      10179 Berlin, Germany
    </Typography>
    <Typography mb={4}>
      Managing director: Richard Meißner
      <br />
      Contact:{' '}
      <Link href="mailto:info@cc0x.dev" passHref legacyBehavior>
        <MUILink>info@cc0x.dev</MUILink>
      </Link>
      <br />
      District Court: Berlin Charlottenburg
      <br />
      Register Number: HRB 240421 B
    </Typography>
    <Typography variant="h3" mb={2}>
      Disclaimer
    </Typography>
    <Typography mb={1}>
      <strong>Accountability for content</strong>
    </Typography>
    <Typography mb={2}>
      The contents of our pages have been created with the utmost care. However, we cannot guarantee the contents’
      accuracy, completeness or topicality. According to statutory provisions, we are furthermore responsible for our
      own content on these web pages. In this context, please note that we are accordingly not obliged to monitor merely
      the transmitted or saved information of third parties, or investigate circumstances pointing to illegal activity.
      Our obligations to remove or block the use of information under generally applicable laws remain unaffected by
      this as per §§ 8 to 10 of the Telemedia Act (TMG).
    </Typography>
    <Typography mb={1}>
      <strong>Accountability for links</strong>
    </Typography>
    <Typography mb={2}>
      Responsibility for the content of external links (to web pages of third parties) lies solely with the operators of
      the linked pages. No violations were evident to us at the time of linking. Should any legal infringement become
      known to us, we will remove the respective link immediately.
    </Typography>
    <Typography mb={1}>
      <strong>Copyright</strong>
    </Typography>
    <Typography>
      This website and their contents are subject to copyright laws.{' '}
      <Link href="https://github.com/safe-global/safe-wallet-web/blob/dev/LICENSE" passHref legacyBehavior>
        <MUILink target="_blank" rel="noreferrer">
          The code is open-source, released under GPL-3.0.
        </MUILink>
      </Link>
    </Typography>
  </div>
)

const Imprint: NextPage = () => {
  const isOfficialHost = useIsOfficialHost()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Imprint`}</title>
      </Head>

      <main>{isOfficialHost && <SafeImprint />}</main>
    </>
  )
}

export default Imprint
</file>

<file path="src/pages/index.tsx">
import { useEffect } from 'react'
import type { NextPage } from 'next'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import isEmpty from 'lodash/isEmpty'
import local from '@/services/local-storage/local'
import { addedSafesSlice, type AddedSafesState } from '@/store/addedSafesSlice'

const IndexPage: NextPage = () => {
  const router = useRouter()
  const { chain } = router.query

  useEffect(() => {
    if (!router.isReady || router.pathname !== AppRoutes.index) {
      return
    }
    // TODO: Replace with useLocalStorage. For now read directly from localstorage so we have value on first render
    const addedSafes = local.getItem<AddedSafesState>(addedSafesSlice.name)
    const hasAddedSafes = addedSafes !== null && !isEmpty(addedSafes)
    const pathname = hasAddedSafes ? AppRoutes.welcome.accounts : AppRoutes.welcome.index

    router.replace({
      pathname,
      query: chain ? { chain } : undefined,
    })
  }, [router, chain])

  return <></>
}

export default IndexPage
</file>

<file path="src/pages/privacy.tsx">
import CustomLink from '@/components/common/CustomLink'
import type { MDXComponents } from 'mdx/types'
import type { NextPage } from 'next'
import Head from 'next/head'
import SafePrivacyPolicy from '@/markdown/privacy/privacy.md'
import { useIsOfficialHost } from '@/hooks/useIsOfficialHost'
import { BRAND_NAME } from '@/config/constants'

const overrideComponents: MDXComponents = {
  // @ts-expect-error
  a: CustomLink,
}

const PrivacyPolicy: NextPage = () => {
  const isOfficialHost = useIsOfficialHost()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Privacy policy`}</title>
      </Head>

      <main>{isOfficialHost && <SafePrivacyPolicy components={overrideComponents} />}</main>
    </>
  )
}

export default PrivacyPolicy
</file>

<file path="src/pages/stake.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import dynamic from 'next/dynamic'
import { Typography } from '@mui/material'
import { useHasFeature } from '@/hooks/useChains'
import { BRAND_NAME } from '@/config/constants'
import { FEATURES } from '@safe-global/utils/utils/chains'

const LazyStakePage = dynamic(() => import('@/features/stake/components/StakePage'), { ssr: false })

const StakePage: NextPage = () => {
  const isFeatureEnabled = useHasFeature(FEATURES.STAKING)

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Stake`}</title>
      </Head>

      {isFeatureEnabled === true ? (
        <LazyStakePage />
      ) : isFeatureEnabled === false ? (
        <main>
          <Typography textAlign="center" my={3}>
            Staking is not available on this network.
          </Typography>
        </main>
      ) : null}
    </>
  )
}

export default StakePage
</file>

<file path="src/pages/swap.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { useRouter } from 'next/router'
import dynamic from 'next/dynamic'
import { Typography } from '@mui/material'
import { useHasFeature } from '@/hooks/useChains'
import { BRAND_NAME } from '@/config/constants'
import { FEATURES } from '@safe-global/utils/utils/chains'

// Cow Swap expects native token addresses to be in the format '0xeeee...eeee'
const adjustEthAddress = (address: string) => {
  if (address && Number(address) === 0) {
    const ETH_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'
    return ETH_ADDRESS
  }
  return address
}

const SwapWidgetNoSSR = dynamic(() => import('@/features/swap'), { ssr: false })

const SwapPage: NextPage = () => {
  const router = useRouter()
  const { token, amount } = router.query
  const isFeatureEnabled = useHasFeature(FEATURES.NATIVE_SWAPS)

  let sell = undefined
  if (token && amount) {
    sell = {
      asset: adjustEthAddress(String(token ?? '')),
      amount: adjustEthAddress(String(amount ?? '')),
    }
  }

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Swap`}</title>
      </Head>

      <main style={{ height: 'calc(100vh - 52px)' }}>
        {isFeatureEnabled === true ? (
          <SwapWidgetNoSSR sell={sell} />
        ) : isFeatureEnabled === false ? (
          <Typography textAlign="center" my={3}>
            Swaps are not supported on this network.
          </Typography>
        ) : null}
      </main>
    </>
  )
}

export default SwapPage
</file>

<file path="src/pages/terms.tsx">
import CustomLink from '@/components/common/CustomLink'
import type { NextPage } from 'next'
import Head from 'next/head'
import SafeTerms from '@/markdown/terms/terms.md'
import type { MDXComponents } from 'mdx/types'
import { useIsOfficialHost } from '@/hooks/useIsOfficialHost'
import { BRAND_NAME } from '@/config/constants'

const overrideComponents: MDXComponents = {
  // @ts-expect-error
  a: CustomLink,
}

const Terms: NextPage = () => {
  const isOfficialHost = useIsOfficialHost()

  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – Terms`}</title>
      </Head>

      <main>{isOfficialHost && <SafeTerms components={overrideComponents} />}</main>
    </>
  )
}

export default Terms
</file>

<file path="src/pages/user-settings.tsx">
import type { NextPage } from 'next'
import Head from 'next/head'
import { BRAND_NAME } from '@/config/constants'
import UserSettings from '@/features/spaces/components/UserSettings'

const UserSettingsPage: NextPage = () => {
  return (
    <>
      <Head>
        <title>{`${BRAND_NAME} – User Settings`}</title>
      </Head>

      <UserSettings />
    </>
  )
}

export default UserSettingsPage
</file>

<file path="src/pages/wc.tsx">
import { useEffect } from 'react'
import type { NextPage } from 'next'
import { useRouter } from 'next/router'
import useLastSafe from '@/hooks/useLastSafe'
import { AppRoutes } from '@/config/routes'
import { WC_URI_SEARCH_PARAM } from '@/features/walletconnect/hooks/useWalletConnectSearchParamUri'

const WcPage: NextPage = () => {
  const router = useRouter()
  const lastSafe = useLastSafe()

  useEffect(() => {
    if (!router.isReady || router.pathname !== AppRoutes.wc) {
      return
    }

    const { uri } = router.query

    router.replace(
      lastSafe
        ? {
            pathname: AppRoutes.home,
            query: {
              safe: lastSafe,
              [WC_URI_SEARCH_PARAM]: uri,
            },
          }
        : {
            pathname: AppRoutes.welcome.index,
            query: {
              [WC_URI_SEARCH_PARAM]: uri,
            },
          },
    )
  }, [router, lastSafe])

  return <></>
}

export default WcPage
</file>

<file path="src/permissions/hoc/withPermission.tsx">
import type { Permission, PermissionProps } from '../config'
import { useHasPermission } from '../hooks/useHasPermission'

type WrappingComponentProps<
  C extends React.ComponentType<any>,
  P extends Permission,
  PProps = PermissionProps<P> extends undefined ? { permissionProps?: never } : { permissionProps: PermissionProps<P> },
> = React.ComponentProps<C> &
  PProps & {
    // if true, the component will be rendered even if the user does not have the permission
    forceRender?: boolean
  }

/**
 * HOC that renders WrappedComponent only if user has a specific permission
 * @param WrappedComponent component to wrap with permission check
 * @param permission permission to check
 * @returns component that renders WrappedComponent if user has permission
 * @example
 * const RandomComponent = () => <div>Hello world.</div>
 * const WithProposeTxPermission = withPermission(RandomComponent, Permission.ProposeTransaction)
 * const OuterComponent = () => <WithProposeTxPermission />
 * @example
 * const RandomComponent = (props: { hasPermission?: boolean }) => <div>hasPermission: {props.hasPermission}</div>
 * const WithProposeTxPermission = withPermission(RandomComponent, Permission.ProposeTransaction)
 * const OuterComponent = () => <WithProposeTxPermission forceRender />
 * @example
 * const RandomComponent = (props: { foo: string }) => <div>{props.foo}</div>
 * const WithExecuteTxPermission = withPermission(RandomComponent, Permission.ExecuteTransaction)
 * const OuterComponent = () => <WithExecuteTxPermission foo="Hello" permissionProps={{safeTx: {} as any}} />
 */
export function withPermission<C extends React.ComponentType<any & { hasPermission?: boolean }>, P extends Permission>(
  WrappedComponent: C,
  permission: P,
) {
  const WithPermissions = ({ forceRender, permissionProps, ...props }: WrappingComponentProps<C, P>) => {
    const hasPermission = useHasPermission(permission, ...(permissionProps ? [permissionProps] : []))

    if (!forceRender && !hasPermission) {
      return null
    }

    const wrappedProps = { ...props, hasPermission } as React.ComponentProps<C>

    return <WrappedComponent {...wrappedProps} />
  }

  WithPermissions.displayName = WrappedComponent.displayName || WrappedComponent.name

  return WithPermissions
}
</file>

<file path="src/permissions/hoc/withRole.tsx">
import type { Role } from '../config'
import { useHasRoles } from '../hooks/useHasRoles'

type WrappingComponentProps<C extends React.ComponentType<any>> = React.ComponentProps<C> & {
  // whether the user must have only the roles to check
  exclusive?: boolean
  // if true, the component will be rendered even if the user does not have the role
  forceRender?: boolean
}

/**
 * HOC that renders WrappedComponent only if user has a specific role
 * @param WrappedComponent component to wrap with role check
 * @param role role to check
 * @returns component that renders WrappedComponent if user has role
 * @example
 * const RandomComponent = (props: { hasRole?: boolean }) => <div>hasRole: {props.hasRole}</div>
 * const WithOwnerRole = withRole(RandomComponent, Role.Owner)
 * const RenderOnlyForOwner = () => <WithOwnerRole />
 * const RenderOnlyForOwnerExclusively = () => <WithOwnerRole exclusive />
 * const RenderForAllWithIsOwnerInfo = () => <WithOwnerRole forceRender />
 */
export function withRole<C extends React.ComponentType<any & { hasRole?: boolean }>, R extends Role>(
  WrappedComponent: C,
  role: R,
) {
  const WithRole = ({ forceRender, exclusive, ...props }: WrappingComponentProps<C>) => {
    const hasRole = useHasRoles([role], exclusive)

    if (!forceRender && !hasRole) {
      return null
    }

    const wrappedProps = { ...props, hasRole } as React.ComponentProps<C>

    return <WrappedComponent {...wrappedProps} />
  }

  WithRole.displayName = WrappedComponent.displayName || WrappedComponent.name

  return WithRole
}
</file>

<file path="src/permissions/hooks/useHasPermission.ts">
import type { Permission, PermissionProps } from '../config'
import { usePermission } from './usePermission'

/**
 * Hook to check if the current user has a specific permission.
 * @param permission Permission to check.
 * @param props Specific props to pass to the permission function (only required if configured for the permission).
 * @returns Boolean indicating if the user has the permission.
 */
export const useHasPermission = <P extends Permission, Props extends PermissionProps<P> = PermissionProps<P>>(
  permission: P,
  ...props: Props extends undefined ? [] : [props: Props]
): boolean => {
  const permissions = usePermission(permission, ...props)

  return Object.values(permissions).some((flag) => flag)
}
</file>

<file path="src/permissions/hooks/useHasRoles.ts">
import { useEffect, useState } from 'react'
import { useRoles } from './useRoles'
import { intersection, uniq } from 'lodash'
import type { Role } from '../config'

/**
 * Hook to check if the current user has the given roles.
 * @param rolesToCheck roles that the user must have to return true
 * @param exclusive whether the user must have only the roles to check
 * @returns true if the user has the roles to check, false otherwise
 */
export const useHasRoles = (rolesToCheck: Role[], exclusive = false): boolean => {
  const roles = useRoles()
  const [hasRoles, setHasRoles] = useState<boolean>(false)

  useEffect(() => {
    const uniqueRolesToCheck = uniq(rolesToCheck)
    const rolesIntersection = intersection(rolesToCheck, roles)
    const hasRolesNew = rolesIntersection.length === uniqueRolesToCheck.length

    if (exclusive) {
      setHasRoles(hasRolesNew && uniq(roles).length === uniqueRolesToCheck.length)
    } else {
      setHasRoles(hasRolesNew)
    }
  }, [rolesToCheck, roles, exclusive])

  return hasRoles
}
</file>

<file path="src/permissions/hooks/usePermission.ts">
import { useMemo } from 'react'
import { useRoles } from './useRoles'
import { useRoleProps } from './useRoleProps'
import { getRolePermissions } from '../getRolePermissions'
import type { Permission, Role, PermissionProps } from '../config'
import useSafeInfo from '@/hooks/useSafeInfo'
import useWallet from '@/hooks/wallets/useWallet'

/**
 * Hook to get the result of a permission check for the current user based on the Safe and the connected wallet.
 * @param permission Permission to check.
 * @param props Specific props to pass to the permission function (only required if configured for the permission).
 * @returns Object with the result of the permission check for each role that the user has.
 */
export const usePermission = <P extends Permission>(
  permission: P,
  ...[props]: PermissionProps<P> extends undefined ? [] : [props: PermissionProps<P>]
): { [_R in Role]?: boolean } => {
  const userRoles = useRoles()
  const roleProps = useRoleProps()
  const { safe } = useSafeInfo()
  const wallet = useWallet()

  const userPermissions = useMemo(() => {
    return getRolePermissions(userRoles, { safe, wallet }, roleProps)
  }, [userRoles, roleProps, safe, wallet])

  const permissionPerRole = useMemo(() => {
    return Object.entries(userPermissions).reduce((acc, [role, permissions]) => {
      const permissionValue = permissions?.[permission]

      if (permissionValue === undefined) {
        // No permission defined for the role
        return acc
      }

      if (typeof permissionValue === 'function') {
        // Evaluate the permission function with the given props
        return { ...acc, [role]: permissionValue(props as PermissionProps<P>) }
      }

      // Return the permission value (boolean) as is
      return { ...acc, [role]: permissionValue }
    }, {})
  }, [userPermissions, permission, props])

  return permissionPerRole
}
</file>

<file path="src/permissions/hooks/useRoleProps.ts">
import { useSelector } from 'react-redux'
import { selectSpendingLimits } from '@/store/spendingLimitsSlice'
import { type RolePropsMap, Role } from '../config'

/**
 * Hook to get the props for each role based on the current state of the application.
 * @returns Object with the props per role.
 */
export const useRoleProps = (): RolePropsMap => {
  const spendingLimits = useSelector(selectSpendingLimits)

  return {
    [Role.SpendingLimitBeneficiary]: { spendingLimits },
  }
}
</file>

<file path="src/permissions/hooks/useRoles.ts">
import { useMemo } from 'react'
import useIsSafeOwner from '@/hooks/useIsSafeOwner'
import { useIsWalletProposer } from '@/hooks/useProposers'
import { useIsRecoverer } from '@/features/recovery/hooks/useIsRecoverer'
import { useIsSpendingLimitBeneficiary } from '@/hooks/useIsOnlySpendingLimitBeneficiary'
import useWallet from '@/hooks/wallets/useWallet'
import { Role } from '../config'
import { useIsNestedSafeOwner } from '@/hooks/useIsNestedSafeOwner'

/**
 * Hook to get the roles that the current user has based on the Safe and the connected wallet.
 * @returns Array with the roles that the current user has.
 */
export const useRoles = (): Role[] => {
  const wallet = useWallet()
  const isOwner = useIsSafeOwner()
  const isNestedSafeOwner = useIsNestedSafeOwner()
  const isProposer = useIsWalletProposer()
  const isRecoverer = useIsRecoverer()
  const isSpendingLimitBeneficiary = useIsSpendingLimitBeneficiary()

  // Map of roles and whether they are applicable to the current user
  const roleApplicableMap: Record<Role, boolean> = useMemo(
    () => ({
      [Role.Owner]: isOwner,
      [Role.NestedOwner]: !!isNestedSafeOwner,
      [Role.Proposer]: !!isProposer,
      [Role.Recoverer]: isRecoverer,
      [Role.SpendingLimitBeneficiary]: isSpendingLimitBeneficiary,
      [Role.Executioner]: !!wallet,
      [Role.NoWalletConnected]: !wallet,
      [Role.ModuleRole]: false, // TODO: Implement module role
    }),
    [isOwner, isNestedSafeOwner, isProposer, isRecoverer, isSpendingLimitBeneficiary, wallet],
  )

  const roles = useMemo(
    () =>
      (Object.entries(roleApplicableMap) as [[Role, boolean]]).reduce<Role[]>(
        (acc, [role, isApplicable]) => (isApplicable ? [...acc, role] : acc),
        [],
      ),
    [roleApplicableMap],
  )

  return roles
}
</file>

<file path="src/permissions/config.ts">
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import type { ExtendedSafeInfo } from '@safe-global/store/slices/SafeInfo/types'
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'

export enum Role {
  Owner = 'Owner',
  NestedOwner = 'NestedOwner',
  Proposer = 'Proposer',
  Executioner = 'Executioner',
  ModuleRole = 'ModuleRole',
  Recoverer = 'Recoverer',
  SpendingLimitBeneficiary = 'SpendingLimitBeneficiary',
  NoWalletConnected = 'NoWalletConnected',
}

export enum Permission {
  CreateTransaction = 'CreateTransaction',
  ProposeTransaction = 'ProposeTransaction',
  SignTransaction = 'SignTransaction',
  ExecuteTransaction = 'ExecuteTransaction',
  CreateSpendingLimitTransaction = 'CreateSpendingLimitTransaction',
  EnablePushNotifications = 'EnablePushNotifications',
}

/**
 * RolePropsMap defines property types for specific roles.
 * The props are used to specify conditional permission values for the respective role.
 */
export type RolePropsMap = {
  [Role.SpendingLimitBeneficiary]: {
    spendingLimits: SpendingLimitState[]
  }
}

// Extract the props for a specific role from RolePropsMap
export type RoleProps<R extends Role> = R extends keyof RolePropsMap ? RolePropsMap[R] : undefined

/**
 * PermissionPropsMap defines property types for specific permissions.
 * The props are used as inputs to evaluate permission functions.
 */
export type PermissionPropsMap = {
  [Permission.ExecuteTransaction]: { safeTx: SafeTransaction }
  [Permission.CreateSpendingLimitTransaction]: { tokenAddress?: string } | undefined
}

// Extract the props for a specific permission from PermissionPropsMap
export type PermissionProps<P extends Permission> = P extends keyof PermissionPropsMap
  ? PermissionPropsMap[P]
  : undefined

// Define the type for a permission function that evaluates to a boolean
type PermissionFn<P extends Permission> =
  PermissionProps<P> extends undefined ? undefined : (args: PermissionProps<P>) => boolean

// Define the type for a permission set that maps permissions to their values
export type PermissionSet = {
  [P in Permission]?: PermissionFn<P> extends undefined ? boolean : PermissionFn<P>
}

export type CommonProps = {
  safe: ExtendedSafeInfo
  wallet: ConnectedWallet | null
}

export type RolePermissionsFn<R extends Role> =
  RoleProps<R> extends undefined
    ? (props: CommonProps) => PermissionSet
    : (props: CommonProps, roleProps: RoleProps<R>) => PermissionSet

type RolePermissionsConfig = {
  [R in Role]?: RolePermissionsFn<R>
}

/**
 * Defines the permissions for each role.
 */
export default <RolePermissionsConfig>{
  [Role.Owner]: () => ({
    [Permission.CreateTransaction]: true,
    [Permission.ProposeTransaction]: true,
    [Permission.SignTransaction]: true,
    [Permission.ExecuteTransaction]: () => true,
    [Permission.EnablePushNotifications]: true,
  }),
  [Role.Proposer]: () => ({
    [Permission.CreateTransaction]: true,
    [Permission.ProposeTransaction]: true,
    [Permission.ExecuteTransaction]: () => true,
    [Permission.EnablePushNotifications]: true,
  }),
  [Role.Executioner]: () => ({
    [Permission.ExecuteTransaction]: () => true,
    [Permission.EnablePushNotifications]: true,
  }),
  [Role.SpendingLimitBeneficiary]: ({ wallet }, { spendingLimits }) => ({
    [Permission.ExecuteTransaction]: () => true,
    [Permission.EnablePushNotifications]: true,
    [Permission.CreateSpendingLimitTransaction]: ({ tokenAddress } = {}) => {
      if (!wallet) return false

      if (!tokenAddress) {
        // Check if the connected wallet has a spending limit for any token
        return spendingLimits.some((sl) => sameAddress(sl.beneficiary, wallet.address))
      }

      // Check if the connected wallet has a spending limit for the given token
      const spendingLimit = spendingLimits.find(
        (sl) => sameAddress(sl.token.address, tokenAddress) && sameAddress(sl.beneficiary, wallet.address),
      )

      if (spendingLimit) {
        // Check if the spending limit has not been reached
        return BigInt(spendingLimit.amount) - BigInt(spendingLimit.spent) > 0
      }

      return false
    },
  }),
  [Role.NoWalletConnected]: () => ({
    [Permission.EnablePushNotifications]: false,
  }),
}
</file>

<file path="src/permissions/getRolePermissions.ts">
import rolePermissionConfig from './config'
import type { CommonProps, PermissionSet, Role, RoleProps } from './config'

/**
 * Get the PermissionSet for multiple roles with the given role props object.
 * @param roles Roles to get permissions for
 * @param props Common props used to evaluate the permissions
 * @param roleProps Object with specific parameters for the roles
 * @returns Object with PermissionSet for each of the give roles that has permissions defined
 */
export const getRolePermissions = <R extends Role>(
  roles: R[],
  props: CommonProps,
  roleProps: { [K in R]?: RoleProps<K> },
) =>
  roles.reduce<{ [_K in R]?: PermissionSet }>((acc, role) => {
    const rolePermissionsFn = rolePermissionConfig[role]

    if (!rolePermissionsFn) {
      return acc
    }

    return { ...acc, [role]: rolePermissionsFn(props, roleProps[role] as RoleProps<R>) }
  }, {})
</file>

<file path="src/service-workers/firebase-messaging/firebase-messaging-sw.ts">
// Be careful what you import here as it will increase the service worker bundle size

/// <reference lib="webworker" />

import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw'
import type { MessagePayload } from 'firebase/messaging/sw'

import { initializeFirebaseApp } from '@/services/push-notifications/firebase'
import {
  shouldShowServiceWorkerPushNotification,
  parseServiceWorkerPushNotification,
} from '@/service-workers/firebase-messaging/notifications'
import { cacheServiceWorkerPushNotificationTrackingEvent } from '@/services/push-notifications/tracking'

declare const self: ServiceWorkerGlobalScope

type NotificationData = MessagePayload['data'] & {
  link: string
}

export function firebaseMessagingSw() {
  const ICON_PATH = '/images/safe-logo-green.png'

  const app = initializeFirebaseApp()

  if (!app) {
    return
  }

  // Must be called before `onBackgroundMessage` as Firebase embeds a `notificationclick` listener
  self.addEventListener(
    'notificationclick',
    (event) => {
      event.notification.close()

      const data: NotificationData = event.notification.data

      cacheServiceWorkerPushNotificationTrackingEvent('opened', data)

      self.clients.openWindow(data.link)
    },
    false,
  )

  const messaging = getMessaging(app)

  onBackgroundMessage(messaging, async (payload) => {
    const shouldShow = await shouldShowServiceWorkerPushNotification(payload)

    if (!shouldShow) {
      return
    }

    const notification = await parseServiceWorkerPushNotification(payload)

    if (!notification) {
      return
    }

    const data: NotificationData = {
      ...payload.data,
      link: notification.link ?? self.location.origin,
    }

    cacheServiceWorkerPushNotificationTrackingEvent('shown', data)

    self.registration.showNotification(notification.title || '', {
      icon: ICON_PATH,
      body: notification.body,
      data,
    })
  })
}
</file>

<file path="src/service-workers/firebase-messaging/notification-mapper.ts">
// Be careful what you import here as it will increase the service worker bundle size

import { formatUnits } from 'ethers'
import { getBalances } from '@safe-global/safe-gateway-typescript-sdk'
import type { ChainInfo, TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'

import { WebhookType } from './webhook-types'
import type { WebhookEvent } from './webhook-types'

type PushNotificationsMap<T extends WebhookEvent = WebhookEvent> = {
  [P in T['type']]: (
    data: Extract<T, { type: P }>,
    chain?: ChainInfo,
  ) => Promise<{ title: string; body: string }> | { title: string; body: string } | null
}

const getChainName = (chainId: string, chain?: ChainInfo): string => {
  return chain?.chainName ?? `chain ${chainId}`
}

const getCurrencyName = (chain?: ChainInfo): string => {
  return chain?.nativeCurrency?.name ?? 'Ether'
}

const getCurrencySymbol = (chain?: ChainInfo): string => {
  return chain?.nativeCurrency?.symbol ?? 'ETH'
}

const getTokenInfo = async (
  chainId: string,
  safeAddress: string,
  tokenAddress: string,
  tokenValue?: string,
): Promise<{ symbol: string; value: string; name: string }> => {
  const DEFAULT_CURRENCY = 'USD'

  const DEFAULT_INFO = {
    symbol: 'tokens',
    value: 'some',
    name: 'Token',
  }

  let tokenInfo: TokenInfo | undefined

  try {
    const balances = await getBalances(chainId, safeAddress, DEFAULT_CURRENCY)
    tokenInfo = balances.items.find((token) => token.tokenInfo.address === tokenAddress)?.tokenInfo
  } catch {
    // Swallow error
  }

  if (!tokenInfo) {
    return DEFAULT_INFO
  }

  const symbol = tokenInfo?.symbol ?? DEFAULT_INFO.symbol
  const value =
    tokenValue && tokenInfo ? formatUnits(tokenValue, tokenInfo.decimals ?? 0).toString() : DEFAULT_INFO.value
  const name = tokenInfo?.name ?? DEFAULT_INFO.name

  return {
    symbol,
    value,
    name,
  }
}

const shortenAddress = (address: string, length = 4): string => {
  if (!address) {
    return ''
  }

  return `${address.slice(0, length + 2)}...${address.slice(-length)}`
}

export const Notifications: PushNotificationsMap = {
  [WebhookType.EXECUTED_MULTISIG_TRANSACTION]: ({ address, failed, txHash, chainId }, chain) => {
    const didFail = failed === 'true'
    return {
      title: `Transaction ${didFail ? 'failed' : 'executed'}`,
      body: `Safe ${shortenAddress(address)} on ${getChainName(chainId, chain)} ${
        didFail ? 'failed to execute' : 'executed'
      } transaction ${shortenAddress(txHash)}.`,
    }
  },
  [WebhookType.INCOMING_ETHER]: ({ address, txHash, value, chainId }, chain) => {
    return {
      title: `${getCurrencyName(chain)} received`,
      body: `Safe ${shortenAddress(address)} on ${getChainName(chainId, chain)} received ${formatUnits(
        value,
        chain?.nativeCurrency?.decimals,
      ).toString()} ${getCurrencySymbol(chain)} in transaction ${shortenAddress(txHash)}.`,
    }
  },
  [WebhookType.INCOMING_TOKEN]: async ({ address, txHash, tokenAddress, value, chainId }, chain) => {
    const token = await getTokenInfo(chainId, address, tokenAddress, value)
    return {
      title: `${token.name} received`,
      body: `Safe ${shortenAddress(address)} on ${getChainName(chainId, chain)} received ${token.value} ${
        token.symbol
      } in transaction ${shortenAddress(txHash)}.`,
    }
  },
  [WebhookType.MODULE_TRANSACTION]: ({ address, module, txHash, chainId }, chain) => {
    return {
      title: 'Module transaction',
      body: `Safe ${shortenAddress(address)} on ${getChainName(
        chainId,
        chain,
      )} executed a module transaction ${shortenAddress(txHash)} from module ${shortenAddress(module)}.`,
    }
  },
  [WebhookType.CONFIRMATION_REQUEST]: ({ address, safeTxHash, chainId }, chain) => {
    return {
      title: 'Confirmation request',
      body: `Safe ${shortenAddress(address)} on ${getChainName(
        chainId,
        chain,
      )} has a new confirmation request for transaction ${shortenAddress(safeTxHash)}.`,
    }
  },
  [WebhookType.SAFE_CREATED]: () => {
    // We do not preemptively subscribe to Safes before they are created
    return null
  },
  // Disabled on the Transaction Service
  [WebhookType._PENDING_MULTISIG_TRANSACTION]: () => {
    // We don't send notifications for pending transactions
    // @see https://github.com/safe-global/safe-transaction-service/blob/master/safe_transaction_service/notifications/tasks.py#L34
    return null
  },
  [WebhookType._NEW_CONFIRMATION]: () => {
    // Disabled for now
    // @see https://github.com/safe-global/safe-transaction-service/blob/master/safe_transaction_service/notifications/tasks.py#L43
    return null
  },
  [WebhookType._OUTGOING_TOKEN]: () => {
    // We don't sen as we have execution notifications
    // @see https://github.com/safe-global/safe-transaction-service/blob/master/safe_transaction_service/notifications/tasks.py#L48
    return null
  },
  [WebhookType._OUTGOING_ETHER]: () => {
    // We don't sen as we have execution notifications
    // @see https://github.com/safe-global/safe-transaction-service/blob/master/safe_transaction_service/notifications/tasks.py#L48
    return null
  },
}
</file>

<file path="src/service-workers/firebase-messaging/notifications.ts">
// Be careful what you import here as it will increase the service worker bundle size

import { get as getFromIndexedDb } from 'idb-keyval'
import { getChainsConfig, setBaseUrl } from '@safe-global/safe-gateway-typescript-sdk'
import type { MessagePayload } from 'firebase/messaging'

import { AppRoutes } from '@/config/routes' // Has no internal imports
import { isWebhookEvent } from './webhook-types'
import {
  getPushNotificationPrefsKey,
  createPushNotificationPrefsIndexedDb,
} from '@/services/push-notifications/preferences'
import { FIREBASE_IS_PRODUCTION } from '@/services/push-notifications/firebase'
import { Notifications } from './notification-mapper'
import type { WebhookEvent } from './webhook-types'
import type { PushNotificationPreferences, PushNotificationPrefsKey } from '@/services/push-notifications/preferences'

const GATEWAY_URL_PRODUCTION = process.env.NEXT_PUBLIC_GATEWAY_URL_PRODUCTION || 'https://safe-client.safe.global'
const GATEWAY_URL_STAGING = process.env.NEXT_PUBLIC_GATEWAY_URL_STAGING || 'https://safe-client.staging.5afe.dev'

// localStorage cannot be accessed in service workers so we reference the flag from the environment
const GATEWAY_URL = FIREBASE_IS_PRODUCTION ? GATEWAY_URL_PRODUCTION : GATEWAY_URL_STAGING

setBaseUrl(GATEWAY_URL)

export const shouldShowServiceWorkerPushNotification = async (payload: MessagePayload): Promise<boolean> => {
  if (!isWebhookEvent(payload.data)) {
    return true
  }

  const { chainId, address, type } = payload.data

  const key = getPushNotificationPrefsKey(chainId, address)
  const store = createPushNotificationPrefsIndexedDb()

  const preferencesStore = await getFromIndexedDb<PushNotificationPreferences[PushNotificationPrefsKey]>(
    key,
    store,
  ).catch(() => null)

  if (!preferencesStore) {
    return false
  }

  return preferencesStore.preferences[type]
}

const getLink = (data: WebhookEvent, shortName?: string) => {
  const URL = self.location.origin

  if (!shortName) {
    return URL
  }

  const withRoute = (route: string) => {
    return `${URL}${route}?safe=${shortName}:${data.address}`
  }

  if ('safeTxHash' in data) {
    return `${withRoute(AppRoutes.transactions.tx)}&id=${data.safeTxHash}`
  }

  return withRoute(AppRoutes.transactions.history)
}

export const _parseServiceWorkerWebhookPushNotification = async (
  data: WebhookEvent,
): Promise<{ title: string; body: string; link: string } | undefined> => {
  const chain = await getChainsConfig()
    .then(({ results }) => results.find((chain) => chain.chainId === data.chainId))
    .catch(() => undefined)

  // Can be safely casted as `data.type` is a mapped type of `NotificationsMap`
  const notification = await Notifications[data.type](data as any, chain)

  if (notification) {
    return {
      ...notification,
      link: getLink(data, chain?.shortName),
    }
  }
}

export const parseServiceWorkerPushNotification = async (
  payload: MessagePayload,
): Promise<({ title?: string; link?: string } & NotificationOptions) | undefined> => {
  // Manually dispatched notifications from the Firebase admin panel; displayed as is
  if (!isWebhookEvent(payload.data)) {
    return payload.notification
  }

  // Transaction Service-dispatched notification
  return _parseServiceWorkerWebhookPushNotification(payload.data)
}
</file>

<file path="src/service-workers/firebase-messaging/webhook-types.ts">
// Be careful what you import here as it will increase the service worker bundle size

import type { MessagePayload } from 'firebase/messaging'

export const isWebhookEvent = (data: MessagePayload['data']): data is WebhookEvent => {
  return Object.values(WebhookType).some((type) => type === data?.type)
}

export enum WebhookType {
  EXECUTED_MULTISIG_TRANSACTION = 'EXECUTED_MULTISIG_TRANSACTION',
  INCOMING_ETHER = 'INCOMING_ETHER',
  INCOMING_TOKEN = 'INCOMING_TOKEN',
  MODULE_TRANSACTION = 'MODULE_TRANSACTION',
  CONFIRMATION_REQUEST = 'CONFIRMATION_REQUEST', // Notification-specific webhook
  SAFE_CREATED = 'SAFE_CREATED',
  // Disabled on the Transaction Service
  _PENDING_MULTISIG_TRANSACTION = 'PENDING_MULTISIG_TRANSACTION',
  _NEW_CONFIRMATION = 'NEW_CONFIRMATION',
  _OUTGOING_ETHER = 'OUTGOING_ETHER',
  _OUTGOING_TOKEN = 'OUTGOING_TOKEN',
}

export type PendingMultisigTransactionEvent = {
  type: WebhookType._PENDING_MULTISIG_TRANSACTION
  chainId: string
  address: string
  safeTxHash: string
}

export type NewConfirmationEvent = {
  type: WebhookType._NEW_CONFIRMATION
  chainId: string
  address: string
  owner: string
  safeTxHash: string
}

export type OutgoingEtherEvent = {
  type: WebhookType._OUTGOING_ETHER
  chainId: string
  address: string
  txHash: string
  value: string
}

export type OutgoingTokenEvent = {
  type: WebhookType._OUTGOING_TOKEN
  chainId: string
  address: string
  tokenAddress: string
  txHash: string
  value?: string // If ERC-20 token
}

export type ExecutedMultisigTransactionEvent = {
  type: WebhookType.EXECUTED_MULTISIG_TRANSACTION
  chainId: string
  address: string
  safeTxHash: string
  failed: 'true' | 'false'
  txHash: string
}

export type IncomingEtherEvent = {
  type: WebhookType.INCOMING_ETHER
  chainId: string
  address: string
  txHash: string
  value: string
}

export type IncomingTokenEvent = {
  type: WebhookType.INCOMING_TOKEN
  chainId: string
  address: string
  tokenAddress: string
  txHash: string
  value?: string // If ERC-20 token
}

export type ModuleTransactionEvent = {
  type: WebhookType.MODULE_TRANSACTION
  chainId: string
  address: string
  module: string
  txHash: string
}

export type ConfirmationRequestEvent = {
  type: WebhookType.CONFIRMATION_REQUEST
  chainId: string
  address: string
  safeTxHash: string
}

export type SafeCreatedEvent = {
  type: WebhookType.SAFE_CREATED
  chainId: string
  address: string
  txHash: string
  blockNumber: string
}

export type WebhookEvent =
  | NewConfirmationEvent
  | ExecutedMultisigTransactionEvent
  | PendingMultisigTransactionEvent
  | IncomingEtherEvent
  | OutgoingEtherEvent
  | IncomingTokenEvent
  | OutgoingTokenEvent
  | ModuleTransactionEvent
  | ConfirmationRequestEvent
  | SafeCreatedEvent
</file>

<file path="src/service-workers/index.ts">
// Be careful what you import here as it will increase the service worker bundle size

/// <reference lib="webworker" />

import { firebaseMessagingSw } from './firebase-messaging/firebase-messaging-sw'

firebaseMessagingSw()
</file>

<file path="src/services/analytics/events/addressBook.ts">
const ADDRESS_BOOK_CATEGORY = 'address-book'

export const ADDRESS_BOOK_EVENTS = {
  EXPORT: {
    action: 'Export',
    category: ADDRESS_BOOK_CATEGORY,
  },
  DOWNLOAD_BUTTON: {
    action: 'Download address book',
    category: ADDRESS_BOOK_CATEGORY,
  },
  IMPORT: {
    action: 'Import',
    category: ADDRESS_BOOK_CATEGORY,
  },
  IMPORT_BUTTON: {
    action: 'Import address book',
    category: ADDRESS_BOOK_CATEGORY,
  },
  CREATE_ENTRY: {
    action: 'Create entry',
    category: ADDRESS_BOOK_CATEGORY,
  },
  EDIT_ENTRY: {
    action: 'Edit entry',
    category: ADDRESS_BOOK_CATEGORY,
  },
  DELETE_ENTRY: {
    action: 'Delete entry',
    category: ADDRESS_BOOK_CATEGORY,
  },
  SEND: {
    action: 'Send to contact',
    category: ADDRESS_BOOK_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/assets.ts">
import { EventType } from '@/services/analytics/types'

const ASSETS_CATEGORY = 'assets'

export const ASSETS_EVENTS = {
  CURRENCY_MENU: {
    action: 'Currency menu',
    category: ASSETS_CATEGORY,
  },
  OPEN_TOKEN_LIST_MENU: {
    action: 'Open token list menu',
    category: ASSETS_CATEGORY,
  },
  CHANGE_CURRENCY: {
    event: EventType.META,
    action: 'Change currency',
    category: ASSETS_CATEGORY,
  },
  DIFFERING_TOKENS: {
    event: EventType.META,
    action: 'Tokens',
    category: ASSETS_CATEGORY,
  },
  HIDDEN_TOKENS: {
    event: EventType.META,
    action: 'Hidden tokens',
    category: ASSETS_CATEGORY,
  },
  SHOW_HIDDEN_ASSETS: {
    action: 'Show hidden assets',
    category: ASSETS_CATEGORY,
  },
  SEND: {
    action: 'Send',
    category: ASSETS_CATEGORY,
  },
  HIDE_TOKEN: {
    action: 'Hide single token',
    category: ASSETS_CATEGORY,
  },
  CANCEL_HIDE_DIALOG: {
    action: 'Cancel hide dialog',
    category: ASSETS_CATEGORY,
  },
  SAVE_HIDE_DIALOG: {
    action: 'Save hide dialog',
    category: ASSETS_CATEGORY,
  },
  DESELECT_ALL_HIDE_DIALOG: {
    action: 'Deselect all hide dialog',
    category: ASSETS_CATEGORY,
  },
  SHOW_DEFAULT_TOKENS: {
    action: 'Show default tokens',
    category: ASSETS_CATEGORY,
  },
  SHOW_ALL_TOKENS: {
    action: 'Show all tokens',
    category: ASSETS_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/batching.ts">
export const category = 'batching'

export const BATCH_EVENTS = {
  // Click on the batch button in header
  BATCH_SIDEBAR_OPEN: {
    action: 'Batch sidebar open',
    category,
  },
  // On "Add to batch" click
  BATCH_APPEND: {
    action: 'Add to batch',
    category,
  },
  // When a tx is successfully appended to the batch
  BATCH_TX_APPENDED: {
    action: 'Tx added to batch',
    category,
  },
  // When batch item details are expanded
  BATCH_EXPAND_TX: {
    action: 'Expand batched tx',
    category,
  },
  // When batch item is removed
  BATCH_DELETE_TX: {
    action: 'Delete batched tx',
    category,
  },
  // "Add new transaction" in the batch sidebar
  BATCH_NEW_TX: {
    action: 'Add new tx to batch',
    category,
  },
  // Confirm batch in the batch sidebar
  BATCH_CONFIRM: {
    action: 'Confirm batch',
    category,
  },
}
</file>

<file path="src/services/analytics/events/bridge.ts">
const BRIDGE_CATEGORY = 'bridge'

export const BRIDGE_EVENTS = {
  OPEN_BRIDGE: {
    action: 'Open bridge',
    category: BRIDGE_CATEGORY,
  },
}

export enum BRIDGE_LABELS {
  sidebar = 'sidebar',
}
</file>

<file path="src/services/analytics/events/counterfactual.ts">
import { EventType } from '@/services/analytics'

const COUNTERFACTUAL_CATEGORY = 'counterfactual'

export const COUNTERFACTUAL_EVENTS = {
  CHECK_BALANCES: {
    action: 'Check balances on block explorer',
    category: COUNTERFACTUAL_CATEGORY,
    event: EventType.CLICK,
  },
}
</file>

<file path="src/services/analytics/events/createLoadSafe.ts">
import { EventType } from '@/services/analytics/types'

export const CREATE_SAFE_CATEGORY = 'create-safe'

export const CREATE_SAFE_EVENTS = {
  CONTINUE_TO_CREATION: {
    action: 'Continue to creation',
    category: CREATE_SAFE_CATEGORY,
    event: EventType.META,
  },
  OPEN_SAFE_CREATION: {
    action: 'Open stepper',
    category: CREATE_SAFE_CATEGORY,
  },
  NAME_SAFE: {
    event: EventType.META,
    action: 'Name Safe',
    category: CREATE_SAFE_CATEGORY,
  },
  OWNERS: {
    event: EventType.META,
    action: 'Owners',
    category: CREATE_SAFE_CATEGORY,
  },
  THRESHOLD: {
    event: EventType.META,
    action: 'Threshold',
    category: CREATE_SAFE_CATEGORY,
  },
  SUBMIT_CREATE_SAFE: {
    event: EventType.META,
    action: 'Submit Safe creation',
    category: CREATE_SAFE_CATEGORY,
  },
  REJECT_CREATE_SAFE: {
    event: EventType.META,
    action: 'Reject Safe creation',
    category: CREATE_SAFE_CATEGORY,
  },
  RETRY_CREATE_SAFE: {
    event: EventType.META,
    action: 'Retry Safe creation',
    category: CREATE_SAFE_CATEGORY,
  },
  CANCEL_CREATE_SAFE_FORM: {
    action: 'Cancel safe creation form',
    category: CREATE_SAFE_CATEGORY,
  },
  CANCEL_CREATE_SAFE: {
    event: EventType.META,
    action: 'Cancel Safe creation',
    category: CREATE_SAFE_CATEGORY,
  },
  CREATED_SAFE: {
    event: EventType.SAFE_CREATED,
    action: 'Created Safe',
    category: CREATE_SAFE_CATEGORY,
  },
  ACTIVATED_SAFE: {
    event: EventType.SAFE_ACTIVATED,
    action: 'Activated Safe',
    category: CREATE_SAFE_CATEGORY,
  },
  OPEN_HINT: {
    action: 'Open Hint',
    category: CREATE_SAFE_CATEGORY,
  },
}

export const LOAD_SAFE_CATEGORY = 'load-safe'

export const LOAD_SAFE_EVENTS = {
  LOAD_BUTTON: {
    action: 'Open stepper',
    category: LOAD_SAFE_CATEGORY,
  },
  NAME_SAFE: {
    event: EventType.META,
    action: 'Name Safe',
    category: LOAD_SAFE_CATEGORY,
  },
  OWNERS: {
    event: EventType.META,
    action: 'Owners',
    category: LOAD_SAFE_CATEGORY,
  },
  THRESHOLD: {
    event: EventType.META,
    action: 'Threshold',
    category: LOAD_SAFE_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/index.ts">
export * from './addressBook'
export * from './assets'
export * from './createLoadSafe'
export * from './modals'
export * from './overview'
export * from './safeApps'
export * from './settings'
export * from './txList'
export * from './wallet'
export * from './batching'
</file>

<file path="src/services/analytics/events/modals.ts">
import { EventType } from '@/services/analytics/types'

export const MODALS_CATEGORY = 'modals'

export const MODALS_EVENTS = {
  SEND_FUNDS: {
    action: 'Send tokens',
    category: MODALS_CATEGORY,
  },
  CONTRACT_INTERACTION: {
    action: 'Contract interaction',
    category: MODALS_CATEGORY,
  },
  TX_DETAILS: {
    action: 'Transaction details',
    category: MODALS_CATEGORY,
  },
  EDIT_ADVANCED_PARAMS: {
    action: 'Edit advanced params',
    category: MODALS_CATEGORY,
  },
  ESTIMATION: {
    action: 'Estimation',
    category: MODALS_CATEGORY,
  },
  TOGGLE_EXECUTE_TX: {
    action: 'Toggle execute transaction',
    category: MODALS_CATEGORY,
  },
  USE_SPENDING_LIMIT: {
    event: EventType.META,
    action: 'Use spending limit',
    category: MODALS_CATEGORY,
  },
  OPEN_SAFE_UTILS: {
    action: 'Open Safe Utils',
    category: MODALS_CATEGORY,
  },
  SIGNING_ARTICLE: {
    action: 'Open signing article',
    category: MODALS_CATEGORY,
  },
  SIMULATE_TX: {
    action: 'Simulate transaction',
    category: MODALS_CATEGORY,
  },
  EDIT_APPROVALS: {
    action: 'Edit approval',
    category: MODALS_CATEGORY,
  },
  ACCEPT_RISK: {
    action: 'Accept transaction risk',
    category: MODALS_CATEGORY,
  },
  REDEFINE_RESULT: {
    action: 'Redefine scan result',
    category: MODALS_CATEGORY,
    event: EventType.META,
  },
  BLOCKAID_RESULT: {
    action: 'Blockaid scan result',
    category: MODALS_CATEGORY,
    event: EventType.META,
  },
  OPEN_SPEED_UP_MODAL: {
    action: 'Open speed-up modal',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  CANCEL_SPEED_UP: {
    action: 'Cancel speed-up',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  SWAP: {
    action: 'Swap',
    category: MODALS_CATEGORY,
  },
  CHANGE_SIGNER: {
    action: 'Change tx signer',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  OPEN_PARENT_TX: {
    action: 'Open parent transaction',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  OPEN_NESTED_TX: {
    action: 'Open nested transaction',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  SUBMIT_TX_NOTE: {
    action: 'Submit tx note',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  CONFIRM_SIGN_CHECKBOX: {
    action: 'Confirm sign checkbox',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  ADD_RECIPIENT: {
    action: 'Add recipient',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
  REMOVE_RECIPIENT: {
    action: 'Remove recipient',
    category: MODALS_CATEGORY,
    event: EventType.CLICK,
  },
}

export enum MODAL_NAVIGATION {
  Next = 'Next click',
  Back = 'Back click',
}
</file>

<file path="src/services/analytics/events/nested-safes.ts">
const NESTED_SAFES_CATEGORY = 'nested-safes'

export const NESTED_SAFE_EVENTS = {
  OPEN_LIST: {
    action: 'Open nested Safe list',
    category: NESTED_SAFES_CATEGORY,
  },
  OPEN_NESTED_SAFE: {
    action: 'Open nested Safe',
    category: NESTED_SAFES_CATEGORY,
  },
  SHOW_ALL: {
    action: 'Show all',
    category: NESTED_SAFES_CATEGORY,
  },
  ADD: {
    action: 'Add',
    category: NESTED_SAFES_CATEGORY,
  },
  RENAME: {
    action: 'Rename',
    category: NESTED_SAFES_CATEGORY,
  },
}

export enum NESTED_SAFE_LABELS {
  header = 'header',
  sidebar = 'sidebar',
  list = 'list',
  success_screen = 'success_screen',
}
</file>

<file path="src/services/analytics/events/nfts.ts">
const NFT_CATEGORY = 'nfts'

export const NFT_EVENTS = {
  SEND: {
    action: 'Send NFTs',
    category: NFT_CATEGORY,
  },

  PREVIEW: {
    action: 'Preview NFT',
    category: NFT_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/outreach.ts">
const OUTREACH_CATEGORY = 'outreach'

export const OUTREACH_EVENTS = {
  CLOSE_POPUP: {
    action: 'Close outreach popup',
    category: OUTREACH_CATEGORY,
  },
  ASK_AGAIN_LATER: {
    action: 'Ask again later',
    category: OUTREACH_CATEGORY,
  },
  OPEN_SURVEY: {
    action: 'Open outreach survey',
    category: OUTREACH_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/overview.ts">
import { EventType } from '@/services/analytics/types'

const OVERVIEW_CATEGORY = 'overview'

export const OVERVIEW_EVENTS = {
  OPEN_ONBOARD: {
    action: 'Open wallet modal',
    category: OVERVIEW_CATEGORY,
  },
  SWITCH_NETWORK: {
    action: 'Switch network',
    category: OVERVIEW_CATEGORY,
  },
  SHOW_QR: {
    action: 'Show Safe QR code',
    category: OVERVIEW_CATEGORY,
  },
  COPY_ADDRESS: {
    action: 'Copy Safe address',
    category: OVERVIEW_CATEGORY,
  },
  OPEN_EXPLORER: {
    action: 'Open Safe on block explorer',
    category: OVERVIEW_CATEGORY,
  },
  ADD_TO_WATCHLIST: {
    action: 'Add Safe to watchlist',
    category: OVERVIEW_CATEGORY,
  },
  REMOVE_FROM_WATCHLIST: {
    action: 'Remove from watchlist',
    category: OVERVIEW_CATEGORY,
  },
  ADD_NEW_NETWORK: {
    action: 'Add new network',
    category: OVERVIEW_CATEGORY,
  },
  SUBMIT_ADD_NEW_NETWORK: {
    action: 'Submit add new network',
    category: OVERVIEW_CATEGORY,
  },
  CANCEL_ADD_NEW_NETWORK: {
    action: 'Cancel add new network',
    category: OVERVIEW_CATEGORY,
  },
  DELETED_FROM_WATCHLIST: {
    action: 'Deleted from watchlist',
    category: OVERVIEW_CATEGORY,
  },
  TOTAL_SAFES_OWNED: {
    action: 'Total Safes owned',
    category: OVERVIEW_CATEGORY,
    event: EventType.META,
  },
  TOTAL_SAFES_PINNED: {
    action: 'Total Safes pinned',
    category: OVERVIEW_CATEGORY,
    event: EventType.META,
  },
  SEARCH: {
    action: 'Search safes',
    category: OVERVIEW_CATEGORY,
  },
  SORT_SAFES: {
    action: 'Sort Safes',
    category: OVERVIEW_CATEGORY,
  },
  SIDEBAR: {
    action: 'Sidebar',
    category: OVERVIEW_CATEGORY,
  },
  WHATS_NEW: {
    action: "Open What's New",
    category: OVERVIEW_CATEGORY,
  },
  HELP_CENTER: {
    action: 'Open Help Center',
    category: OVERVIEW_CATEGORY,
  },
  NEW_TRANSACTION: {
    action: 'New transaction',
    category: OVERVIEW_CATEGORY,
  },
  CHOOSE_TRANSACTION_TYPE: {
    action: 'Choose transaction type',
    category: OVERVIEW_CATEGORY,
    event: EventType.CLICK,
  },
  ADD_FUNDS: {
    action: 'Add funds',
    category: OVERVIEW_CATEGORY,
    event: EventType.CLICK,
  },
  NOTIFICATION_CENTER: {
    action: 'Open Notification Center',
    category: OVERVIEW_CATEGORY,
  },
  NOTIFICATION_INTERACTION: {
    action: 'Interact with notification',
    category: OVERVIEW_CATEGORY,
  },
  SIDEBAR_RENAME: {
    action: 'Rename Safe from sidebar',
    category: OVERVIEW_CATEGORY,
  },
  SAFE_TOKEN_WIDGET: {
    action: 'Open Safe Governance App from widget',
    category: OVERVIEW_CATEGORY,
  },
  OPEN_MISSING_SIGNATURES: {
    action: 'Open transactions queue from missing signatures',
    category: OVERVIEW_CATEGORY,
  },
  OPEN_QUEUED_TRANSACTIONS: {
    action: 'Open transactions queue from queue size',
    category: OVERVIEW_CATEGORY,
  },
  EXPORT_DATA: {
    action: 'Export data',
    category: OVERVIEW_CATEGORY,
  },
  IMPORT_DATA: {
    action: 'Import data',
    category: OVERVIEW_CATEGORY,
  },
  RELAYING_HELP_ARTICLE: {
    action: 'Open relaying help article',
    category: OVERVIEW_CATEGORY,
  },
  SEP5_ALLOCATION_BUTTON: {
    action: 'Click on SEP5 allocation button',
    category: OVERVIEW_CATEGORY,
  },
  // Track clicks on links to Safe Accounts
  OPEN_SAFE: {
    action: 'Open Safe',
    category: OVERVIEW_CATEGORY,
    //label: OPEN_SAFE_LABELS
  },
  PIN_SAFE: {
    action: 'Toggle Safe pinned state',
    category: OVERVIEW_CATEGORY,
  },
  // Track clicks on links to Safe Accounts
  EXPAND_MULTI_SAFE: {
    action: 'Expand multi Safe',
    category: OVERVIEW_CATEGORY,
    //label: OPEN_SAFE_LABELS
  },
  SHOW_ALL_NETWORKS: {
    action: 'Show all networks',
    category: OVERVIEW_CATEGORY,
  },
  // Track actual Safe views
  SAFE_VIEWED: {
    event: EventType.SAFE_OPENED,
    action: 'Safe viewed',
    category: OVERVIEW_CATEGORY,
  },
  BUY_CRYPTO_BUTTON: {
    action: 'Buy crypto button',
    category: OVERVIEW_CATEGORY,
  },
  SHOW_MORE_SAFES: {
    action: 'Show more Safes',
    category: OVERVIEW_CATEGORY,
  },
  CREATE_NEW_SAFE: {
    action: 'Create new Safe',
    category: OVERVIEW_CATEGORY,
  },
  PROCEED_WITH_TX: {
    event: EventType.CLICK,
    action: 'Proceed with transaction',
    category: OVERVIEW_CATEGORY,
  },
  OPEN_STAKING_WIDGET: {
    action: 'Open staking widget from banner',
    category: OVERVIEW_CATEGORY,
  },
  HIDE_STAKING_BANNER: {
    action: 'Hide staking banner',
    category: OVERVIEW_CATEGORY,
  },
  OPEN_LEARN_MORE_STAKING_BANNER: {
    action: 'Staking banner learn more',
    category: OVERVIEW_CATEGORY,
  },
}

export enum PIN_SAFE_LABELS {
  pin = 'pin',
  unpin = 'unpin',
}

export enum OPEN_SAFE_LABELS {
  sidebar = 'sidebar',
  after_create = 'after_create',
  after_add = 'after_add',
  login_page = 'login_page',
}

export enum OVERVIEW_LABELS {
  sidebar = 'sidebar',
  quick_add = 'quick_add',
  quick_remove = 'quick_remove',
  top_bar = 'top_bar',
  welcome_page = 'welcome_page',
  login_page = 'login_page',
  settings = 'settings',
  space_list_page = 'space_list_page',
  space_page = 'space_page',
}
</file>

<file path="src/services/analytics/events/push-notifications.ts">
export const category = 'push-notifications'

export const PUSH_NOTIFICATION_EVENTS = {
  // Browser notification shown to user
  SHOW_NOTIFICATION: {
    action: 'Show notification',
    category,
  },
  // User opened on notification
  OPEN_NOTIFICATION: {
    action: 'Open notification',
    category,
  },
  // User registered Safe(s) for notifications
  REGISTER_SAFES: {
    action: 'Register Safe(s) notifications',
    category,
  },
  // User unregistered Safe from notifications
  UNREGISTER_SAFE: {
    action: 'Unregister Safe notifications',
    category,
  },
  // User unregistered device from notifications
  UNREGISTER_DEVICE: {
    action: 'Unregister device notifications',
    category,
  },
  // Notification banner shown
  SHOW_BANNER: {
    action: 'Show notification banner',
    category,
  },
  // User dismissed notfication banner
  DISMISS_BANNER: {
    action: 'Dismiss notification banner',
    category,
  },
  // User enabled all notifications from banner
  ENABLE_ALL: {
    action: 'Enable all notifications',
    category,
  },
  // User opened Safe notification settings from banner
  CUSTOMIZE_SETTINGS: {
    action: 'Customize notifications',
    category,
  },
  // User turned notifications on for a Safe from settings
  ENABLE_SAFE: {
    action: 'Turn notifications on',
    category,
  },
  // User turned notifications off for a Safe from settings
  DISABLE_SAFE: {
    action: 'Turn notifications off',
    category,
  },
  // Save button clicked in global notification settings
  SAVE_SETTINGS: {
    action: 'Save notification settings',
    category,
  },
  // User changed the incoming transactions notifications setting
  // (incoming native currency/tokens)
  TOGGLE_INCOMING_TXS: {
    action: 'Toggle incoming transactions notifications',
    category,
  },
  // User changed the outgoing transactions notifications setting
  // (module/executed multisig transactions)
  TOGGLE_OUTGOING_TXS: {
    action: 'Toggle outgoing assets notifications',
    category,
  },
  // User changed the confirmation request notifications setting
  TOGGLE_CONFIRMATION_REQUEST: {
    action: 'Toggle confirmation request notifications',
    category,
  },
}
</file>

<file path="src/services/analytics/events/recovery.ts">
import { EventType } from '@/services/analytics'

const RECOVERY_CATEGORY = 'recovery'

export const RECOVERY_EVENTS = {
  SETUP_RECOVERY: {
    action: 'Start recovery setup',
    category: RECOVERY_CATEGORY,
  },
  SELECT_RECOVERY_METHOD: {
    action: 'Select recovery method',
    category: RECOVERY_CATEGORY,
  },
  CONTINUE_WITH_RECOVERY: {
    action: 'Continue with recovery method',
    category: RECOVERY_CATEGORY,
  },
  CONTINUE_TO_WAITLIST: {
    action: 'Continue to waitlist',
    category: RECOVERY_CATEGORY,
  },
  SYGNUM_APP: {
    action: 'Go to Sygnum app',
    category: RECOVERY_CATEGORY,
  },
  RECOVERY_SETTINGS: {
    action: 'Recovery settings',
    category: RECOVERY_CATEGORY,
    event: EventType.META,
  },
  EDIT_RECOVERY: {
    action: 'Start edit recovery',
    category: RECOVERY_CATEGORY,
  },
  REMOVE_RECOVERY: {
    action: 'Start recovery removal',
    category: RECOVERY_CATEGORY,
  },
  START_RECOVERY: {
    action: 'Start recovery proposal',
    category: RECOVERY_CATEGORY,
  },
  CANCEL_RECOVERY: {
    action: 'Start recovery cancellation',
    category: RECOVERY_CATEGORY,
  },
  SHOW_ADVANCED: {
    action: 'Show advanced recovery settings',
    category: RECOVERY_CATEGORY,
  },
  DISMISS_PROPOSAL_CARD: {
    action: 'Dismiss recovery proposal card',
    category: RECOVERY_CATEGORY,
  },
  LEARN_MORE: {
    action: 'Recovery info click',
    category: RECOVERY_CATEGORY,
  },
  GO_BACK: {
    action: 'Recovery cancellation back',
    category: RECOVERY_CATEGORY,
  },
  GIVE_US_FEEDBACK: {
    action: 'Recovery feedback click',
    category: RECOVERY_CATEGORY,
    event: EventType.CLICK,
  },
  CHECK_RECOVERY_PROPOSAL: {
    action: 'Check recovery proposal',
    category: RECOVERY_CATEGORY,
  },
  SUBMIT_RECOVERY_CREATE: {
    action: 'Submit recovery setup',
    category: RECOVERY_CATEGORY,
    event: EventType.META,
  },
  SUBMIT_RECOVERY_EDIT: {
    action: 'Submit recovery edit',
    category: RECOVERY_CATEGORY,
    event: EventType.META,
  },
  SUBMIT_RECOVERY_REMOVE: {
    action: 'Submit recovery remove',
    category: RECOVERY_CATEGORY,
    event: EventType.META,
  },
  SUBMIT_RECOVERY_ATTEMPT: {
    action: 'Submit recovery attempt',
    category: RECOVERY_CATEGORY,
    event: EventType.META,
  },
  SUBMIT_RECOVERY_CANCEL: {
    action: 'Submit recovery cancel',
    category: RECOVERY_CATEGORY,
    event: EventType.META,
  },
}
</file>

<file path="src/services/analytics/events/reject-tx.ts">
const category = 'reject-tx'

export const REJECT_TX_EVENTS = {
  READ_MORE: {
    action: 'Reject tx read more',
    category,
  },

  REPLACE_TX_BUTTON: {
    action: 'Replace tx button',
    category,
  },
  REJECT_ONCHAIN_BUTTON: {
    action: 'Reject onchain button',
    category,
  },
  DELETE_OFFCHAIN_BUTTON: {
    action: 'Delete offchain button',
    category,
  },
  DELETE_CANCEL: {
    action: 'Delete cancel',
    category,
  },
  DELETE_CONFIRM: {
    action: 'Delete confirm',
    category,
  },
  DELETE_SUCCESS: {
    action: 'Delete success',
    category,
  },
  DELETE_FAIL: {
    action: 'Delete fail',
    category,
  },
}
</file>

<file path="src/services/analytics/events/safeApps.ts">
import { EventType } from '@/services/analytics/types'

export const SAFE_APPS_CATEGORY = 'safe-apps'
export const SAFE_APPS_SDK_CATEGORY = 'safe-apps-sdk'
export const SAFE_APPS_ANALYTICS_CATEGORY = 'safe-apps-analytics'

const SAFE_APPS_EVENT_DATA = {
  event: EventType.SAFE_APP,
  category: SAFE_APPS_CATEGORY,
}

export const SAFE_APPS_EVENTS = {
  OPEN_APP: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Open Safe App',
  },
  PIN: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Pin Safe App',
  },
  UNPIN: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Unpin Safe App',
  },
  COPY_SHARE_URL: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Copy Share URL',
  },
  SEARCH: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Search for Safe App',
  },
  ADD_CUSTOM_APP: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Add custom Safe App',
  },
  OPEN_TRANSACTION_MODAL: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Open Transaction modal',
  },
  PROPOSE_TRANSACTION: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Propose Transaction',
  },
  PROPOSE_TRANSACTION_REJECTED: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Propose Transaction Rejected',
  },
  SHARED_APP_LANDING: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Shared App landing page visited',
  },
  SHARED_APP_CHAIN_ID: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Shared App chainId',
  },
  SHARED_APP_OPEN_DEMO: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Open demo safe from shared app',
  },
  SHARED_APP_OPEN_AFTER_SAFE_CREATION: {
    ...SAFE_APPS_EVENT_DATA,
    action: 'Open shared app after Safe creation',
  },

  // SDK
  SAFE_APP_SDK_METHOD_CALL: {
    ...SAFE_APPS_EVENT_DATA,
    category: SAFE_APPS_SDK_CATEGORY,
    action: 'SDK method call',
  },
}

export enum SAFE_APPS_LABELS {
  dashboard = 'dashboard',
  apps_pinned = 'apps_pinned',
  apps_featured = 'apps_featured',
  apps_all = 'apps_all',
  apps_custom = 'apps_custom',
  apps_sidebar = 'apps_sidebar',
}
</file>

<file path="src/services/analytics/events/settings.ts">
import { EventType } from '@/services/analytics/types'

const SETTINGS_CATEGORY = 'settings'

export const SETTINGS_EVENTS = {
  SETUP: {
    ADD_OWNER: {
      action: 'Add owner',
      category: SETTINGS_CATEGORY,
    },
    EDIT_OWNER: {
      action: 'Edit owner',
      category: SETTINGS_CATEGORY,
    },
    REPLACE_OWNER: {
      action: 'Replace owner',
      category: SETTINGS_CATEGORY,
    },
    REMOVE_OWNER: {
      action: 'Remove owner',
      category: SETTINGS_CATEGORY,
    },
    CHANGE_THRESHOLD: {
      action: 'Change threshold',
      category: SETTINGS_CATEGORY,
    },
    OWNERS: {
      event: EventType.META,
      action: 'Owners',
      category: SETTINGS_CATEGORY,
    },
    THRESHOLD: {
      event: EventType.META,
      action: 'Threshold',
      category: SETTINGS_CATEGORY,
    },
  },
  APPEARANCE: {
    COPY_PREFIXES: {
      action: 'Copy EIP-3770 prefixes',
      category: SETTINGS_CATEGORY,
    },
    DARK_MODE: {
      action: 'Dark mode',
      category: SETTINGS_CATEGORY,
    },
  },
  MODULES: {
    REMOVE_MODULE: {
      action: 'Remove module',
      category: SETTINGS_CATEGORY,
    },
    REMOVE_GUARD: {
      action: 'Remove transaction guard',
      category: SETTINGS_CATEGORY,
    },
  },
  SPENDING_LIMIT: {
    NEW_LIMIT: {
      action: 'New spending limit',
      category: SETTINGS_CATEGORY,
    },
    RESET_PERIOD: {
      event: EventType.META,
      action: 'Spending limit reset period',
      category: SETTINGS_CATEGORY,
    },
    REMOVE_LIMIT: {
      action: 'Remove spending limit',
      category: SETTINGS_CATEGORY,
    },
    LIMIT_REMOVED: {
      action: 'Spending limit removed',
      category: SETTINGS_CATEGORY,
    },
  },
  PROPOSERS: {
    ADD_PROPOSER: {
      action: 'Add safe proposer',
      category: SETTINGS_CATEGORY,
    },
    REMOVE_PROPOSER: {
      action: 'Remove safe proposer',
      category: SETTINGS_CATEGORY,
    },
    EDIT_PROPOSER: {
      action: 'Edit safe proposer',
      category: SETTINGS_CATEGORY,
    },
    SUBMIT_ADD_PROPOSER: {
      action: 'Submit add safe proposer',
      category: SETTINGS_CATEGORY,
    },
    SUBMIT_REMOVE_PROPOSER: {
      action: 'Submit remove safe proposer',
      category: SETTINGS_CATEGORY,
    },
    SUBMIT_EDIT_PROPOSER: {
      action: 'Submit edit safe proposer',
      category: SETTINGS_CATEGORY,
    },
    CANCEL_ADD_PROPOSER: {
      action: 'Cancel add safe proposer',
      category: SETTINGS_CATEGORY,
    },
    CANCEL_REMOVE_PROPOSER: {
      action: 'Cancel remove safe proposer',
      category: SETTINGS_CATEGORY,
    },
    CANCEL_EDIT_PROPOSER: {
      action: 'Cancel edit safe proposer',
      category: SETTINGS_CATEGORY,
    },
  },
  DATA: {
    IMPORT_ADDRESS_BOOK: {
      action: 'Imported address book via Import all',
      category: SETTINGS_CATEGORY,
    },
    IMPORT_SETTINGS: {
      action: 'Imported settings via Import all',
      category: SETTINGS_CATEGORY,
    },
    IMPORT_SAFE_APPS: {
      action: 'Imported Safe apps via Import all',
      category: SETTINGS_CATEGORY,
    },
    IMPORT_UNDEPLOYED_SAFES: {
      action: 'Imported counterfactual safes via Import all',
      category: SETTINGS_CATEGORY,
    },
    IMPORT_VISITED_SAFES: {
      action: 'Imported visited safes via Import all',
      category: SETTINGS_CATEGORY,
    },
    CLEAR_PENDING_TXS: {
      action: 'Cleared pending transactions',
      category: SETTINGS_CATEGORY,
    },
  },
  ENV_VARIABLES: {
    SAVE: {
      action: 'Environment variables changed',
      category: SETTINGS_CATEGORY,
    },
  },
  SAFE_APPS: {
    CHANGE_SIGNING_METHOD: {
      action: 'Safe apps signing method changed',
      category: SETTINGS_CATEGORY,
    },
  },
}
</file>

<file path="src/services/analytics/events/spaces.ts">
import { EventType } from '@/services/analytics'

const SPACE_CATEGORY = 'spaces'

export const SPACE_EVENTS = {
  SIGN_IN_BUTTON: {
    action: 'Open sign in message',
    category: SPACE_CATEGORY,
  },
  INFO_MODAL: {
    action: 'Open info dialog',
    category: SPACE_CATEGORY,
  },
  OPEN_SPACE_LIST_PAGE: {
    action: 'Open space list page',
    category: SPACE_CATEGORY,
  },
  OPEN_SPACE_DASHBOARD: {
    action: 'Open space dashboard',
    category: SPACE_CATEGORY,
  },
  CREATE_SPACE_MODAL: {
    action: 'Open create space dialog',
    category: SPACE_CATEGORY,
  },
  CREATE_SPACE: {
    action: 'Submit space creation',
    category: SPACE_CATEGORY,
  },
  ACCEPT_INVITE: {
    action: 'Open accept invitation dialog',
    category: SPACE_CATEGORY,
  },
  ACCEPT_INVITE_SUBMIT: {
    action: 'Submit accept invitation',
    category: SPACE_CATEGORY,
  },
  DECLINE_INVITE: {
    action: 'Open decline invitation dialog',
    category: SPACE_CATEGORY,
  },
  DECLINE_INVITE_SUBMIT: {
    action: 'Submit decline invitation',
    category: SPACE_CATEGORY,
  },
  VIEW_INVITING_SPACE: {
    action: 'View preview of inviting space',
    category: SPACE_CATEGORY,
  },
  ADD_MEMBER_MODAL: {
    action: 'Open add member modal',
    category: SPACE_CATEGORY,
  },
  REMOVE_MEMBER_MODAL: {
    action: 'Open remove member modal',
    category: SPACE_CATEGORY,
  },
  REMOVE_MEMBER: {
    action: 'Submit remove member',
    category: SPACE_CATEGORY,
  },
  ADD_MEMBER: {
    action: 'Submit add member',
    category: SPACE_CATEGORY,
  },
  ADD_ACCOUNTS_MODAL: {
    action: 'Open add accounts modal',
    category: SPACE_CATEGORY,
  },
  ADD_ACCOUNTS: {
    action: 'Submit add accounts',
    category: SPACE_CATEGORY,
  },
  ADD_ACCOUNT_MANUALLY_MODAL: {
    action: 'Open add account manually modal',
    category: SPACE_CATEGORY,
  },
  ADD_ACCOUNT_MANUALLY: {
    action: 'Add account manually submit',
    category: SPACE_CATEGORY,
  },
  RENAME_ACCOUNT_MODAL: {
    action: 'Open rename account modal',
    category: SPACE_CATEGORY,
  },
  RENAME_ACCOUNT: {
    action: 'Submit rename account',
    category: SPACE_CATEGORY,
  },
  DELETE_ACCOUNT_MODAL: {
    action: 'Open delete account modal',
    category: SPACE_CATEGORY,
  },
  DELETE_ACCOUNT: {
    action: 'Submit delete account',
    category: SPACE_CATEGORY,
  },
  DELETE_SPACE_MODAL: {
    action: 'Open delete space modal',
    category: SPACE_CATEGORY,
  },
  DELETE_SPACE: {
    action: 'Submit delete space',
    category: SPACE_CATEGORY,
  },
  VIEW_ALL_ACCOUNTS: {
    action: 'View all accounts',
    category: SPACE_CATEGORY,
  },
  VIEW_ALL_MEMBERS: {
    action: 'View all members',
    category: SPACE_CATEGORY,
  },
  SEARCH_ACCOUNTS: {
    action: 'Search accounts',
    category: SPACE_CATEGORY,
  },
  SEARCH_MEMBERS: {
    action: 'Search members',
    category: SPACE_CATEGORY,
  },
  CREATE_SPACE_TX: {
    action: 'Open send tokens flow in space',
    category: SPACE_CATEGORY,
  },
  TOTAL_SAFE_ACCOUNTS: {
    action: 'Total safes added to space',
    category: SPACE_CATEGORY,
    event: EventType.META,
  },
  TOTAL_ACTIVE_MEMBERS: {
    action: 'Total active members in space',
    category: SPACE_CATEGORY,
    event: EventType.META,
  },
  HIDE_DASHBOARD_WIDGET: {
    action: 'Hide spaces dashboard widget',
    category: SPACE_CATEGORY,
  },
}

export enum SPACE_LABELS {
  space_list_page = 'space_list_page',
  safe_dashboard_banner = 'safe_dashboard_banner',
  info_modal = 'info_modal',
  space_selector = 'space_selector',
  accounts_page = 'accounts_page',
  preview_banner = 'preview_banner',
  space_dashboard = 'space_dashboard',
  space_dashboard_card = 'space_dashboard_card',
  members_page = 'members_page',
  member_list = 'member_list',
  invite_list = 'invite_list',
  add_accounts_modal = 'add_accounts_modal',
  space_settings = 'space_settings',
  space_context_menu = 'space_context_menu',
  space_breadcrumbs = 'space_breadcrumbs',
}
</file>

<file path="src/services/analytics/events/stake.ts">
const STAKE_CATEGORY = 'stake'

export const STAKE_EVENTS = {
  OPEN_STAKE: {
    action: 'Open stake',
    category: STAKE_CATEGORY,
  },
}

export enum STAKE_LABELS {
  dashboard = 'dashboard',
  sidebar = 'sidebar',
  asset = 'asset',
}
</file>

<file path="src/services/analytics/events/swaps.ts">
const SWAP_CATEGORY = 'swap'

export const SWAP_EVENTS = {
  OPEN_SWAPS: {
    action: 'Open swaps',
    category: SWAP_CATEGORY,
  },
}

export enum SWAP_LABELS {
  dashboard = 'dashboard',
  sidebar = 'sidebar',
  asset = 'asset',
  dashboard_assets = 'dashboard_assets',
  promoWidget = 'promoWidget',
  safeAppsPromoWidget = 'safeAppsPromoWidget',
}
</file>

<file path="src/services/analytics/events/transactions.ts">
import { EventType } from '../types'

export enum TX_TYPES {
  // Settings
  owner_add = 'owner_add',
  owner_remove = 'owner_remove',
  owner_swap = 'owner_swap',
  owner_threshold_change = 'owner_threshold_change',

  // Module txs
  guard_remove = 'guard_remove',
  module_remove = 'module_remove',

  // Transfers
  transfer_token = 'transfer_token',
  batch_transfer_token = 'batch_transfer_token',
  transfer_nft = 'transfer_nft',

  // Other
  batch = 'batch',
  rejection = 'rejection',
  typed_message = 'typed_message',
  nested_safe = 'nested_safe',
  walletconnect = 'walletconnect',
  custom = 'custom',
  native_bridge = 'native_bridge',
  native_swap = 'native_swap',
  bulk_execute = 'bulk_execute',

  // Counterfactual
  activate_without_tx = 'activate_without_tx',
  activate_with_tx = 'activate_with_tx',
}

const TX_CATEGORY = 'transactions'

export const TX_EVENTS = {
  CREATE: {
    event: EventType.TX_CREATED,
    action: 'Create transaction',
    category: TX_CATEGORY,
    // label: TX_TYPES,
  },
  CREATE_VIA_ROLE: {
    event: EventType.TX_CREATED,
    action: 'Create via role',
    category: TX_CATEGORY,
  },
  CREATE_VIA_SPENDING_LIMTI: {
    event: EventType.TX_CREATED,
    action: 'Create via spending limit',
    category: TX_CATEGORY,
  },
  CREATE_VIA_PROPOSER: {
    event: EventType.TX_CREATED,
    action: 'Create via proposer',
    category: TX_CATEGORY,
  },
  CONFIRM: {
    event: EventType.TX_CONFIRMED,
    action: 'Confirm transaction',
    category: TX_CATEGORY,
  },
  EXECUTE: {
    event: EventType.TX_EXECUTED,
    action: 'Execute transaction',
    category: TX_CATEGORY,
  },
  SPEED_UP: {
    event: EventType.TX_EXECUTED,
    action: 'Speed up transaction',
    category: TX_CATEGORY,
  },
  EXECUTE_VIA_SPENDING_LIMIT: {
    event: EventType.TX_EXECUTED,
    action: 'Execute via spending limit',
    category: TX_CATEGORY,
  },
  EXECUTE_VIA_ROLE: {
    event: EventType.TX_EXECUTED,
    action: 'Execute via role',
    category: TX_CATEGORY,
  },
  CREATE_VIA_PARENT: {
    event: EventType.TX_CREATED,
    action: 'Create via parent',
    category: TX_CATEGORY,
  },
  CONFIRM_VIA_PARENT: {
    event: EventType.TX_CREATED,
    action: 'Confirm via parent',
    category: TX_CATEGORY,
  },
  EXECUTE_VIA_PARENT: {
    event: EventType.TX_CREATED,
    action: 'Execute via parent',
    category: TX_CATEGORY,
  },
  CONFIRM_IN_PARENT: {
    event: EventType.TX_CONFIRMED,
    action: 'Confirm in parent',
    category: TX_CATEGORY,
  },
  EXECUTE_IN_PARENT: {
    event: EventType.TX_EXECUTED,
    action: 'Execute in parent',
    category: TX_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/txList.ts">
import { EventType } from '@/services/analytics/types'

const TX_LIST_CATEGORY = 'tx-list'

export enum CopyDeeplinkLabels {
  shareBlock = 'share-block',
  button = 'button',
}

export const TX_LIST_EVENTS = {
  QUEUED_TXS: {
    event: EventType.META,
    action: 'Queued transactions',
    category: TX_LIST_CATEGORY,
  },
  ADDRESS_BOOK: {
    action: 'Add to address book',
    category: TX_LIST_CATEGORY,
  },
  SEND_AGAIN: {
    action: 'Send again',
    category: TX_LIST_CATEGORY,
  },
  COPY_DEEPLINK: {
    action: 'Copy deeplink',
    category: TX_LIST_CATEGORY,
    label: CopyDeeplinkLabels.shareBlock,
  },
  OPEN_SHARE_BLOCK: {
    action: 'Open share block',
    category: TX_LIST_CATEGORY,
  },
  CONFIRM: {
    action: 'Confirm transaction',
    category: TX_LIST_CATEGORY,
  },
  EXECUTE: {
    action: 'Execute transaction',
    category: TX_LIST_CATEGORY,
  },
  REJECT: {
    action: 'Reject transaction',
    category: TX_LIST_CATEGORY,
  },
  FILTER: {
    action: 'Filter transactions',
    category: TX_LIST_CATEGORY,
  },
  BATCH_EXECUTE: {
    action: 'Batch Execute',
    category: TX_LIST_CATEGORY,
  },
  EXPAND_TRANSACTION: {
    action: 'Expand transaction item',
    category: TX_LIST_CATEGORY,
  },
  COPY_WARNING_SHOWN: {
    action: 'Show copy address warning',
    category: TX_LIST_CATEGORY,
    event: EventType.META,
  },
  COPY_WARNING_PROCEED: {
    action: 'Proceed and copy address',
    category: TX_LIST_CATEGORY,
    event: EventType.CLICK,
  },
  COPY_WARNING_CLOSE: {
    action: 'Do not copy address',
    category: TX_LIST_CATEGORY,
    event: EventType.CLICK,
  },
  TOGGLE_UNTRUSTED: {
    action: 'Toggle untrusted transactions',
    category: TX_LIST_CATEGORY,
    event: EventType.CLICK,
    // label: 'hide' | 'show',
  },
}

export const MESSAGE_EVENTS = {
  SIGN: {
    action: 'Sign message',
    category: TX_LIST_CATEGORY,
  },
  COPY_DEEPLINK: {
    action: 'Copy message deeplink',
    category: TX_LIST_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/wallet.ts">
import { EventType } from '@/services/analytics/types'

const WALLET_CATEGORY = 'wallet'

export const WALLET_EVENTS = {
  CONNECT: {
    event: EventType.WALLET_CONNECTED,
    action: 'Connect wallet',
    category: WALLET_CATEGORY,
  },
  WALLET_CONNECT: {
    event: EventType.META,
    action: 'WalletConnect peer',
    category: WALLET_CATEGORY,
  },
  OFFCHAIN_SIGNATURE: {
    event: EventType.META,
    action: 'Off-chain signature',
    category: WALLET_CATEGORY,
  },
  ONCHAIN_INTERACTION: {
    event: EventType.META,
    action: 'On-chain interaction',
    category: WALLET_CATEGORY,
  },
  SIGN_MESSAGE: {
    event: EventType.META,
    action: 'Sign message',
    category: WALLET_CATEGORY,
  },
  CONFIRM_MESSAGE: {
    event: EventType.META,
    action: 'Confirm message',
    category: WALLET_CATEGORY,
  },
  RELAYED_EXECUTION: {
    event: EventType.META,
    action: 'Relayed execution',
    category: WALLET_CATEGORY,
  },
}
</file>

<file path="src/services/analytics/events/walletconnect.ts">
import { EventType } from '@/services/analytics/types'

const WALLETCONNECT_CATEGORY = 'walletconnect'

export const WALLETCONNECT_EVENTS = {
  CONNECTED: {
    action: 'WC connected',
    category: WALLETCONNECT_CATEGORY,
    event: EventType.META,
  },
  POPUP_OPENED: {
    action: 'WC popup',
    category: WALLETCONNECT_CATEGORY,
  },
  DISCONNECT_CLICK: {
    action: 'WC disconnect click',
    category: WALLETCONNECT_CATEGORY,
  },
  APPROVE_CLICK: {
    action: 'WC approve click',
    category: WALLETCONNECT_CATEGORY,
  },
  REJECT_CLICK: {
    action: 'WC reject click',
    category: WALLETCONNECT_CATEGORY,
  },
  PASTE_CLICK: {
    action: 'WC paste click',
    category: WALLETCONNECT_CATEGORY,
  },
  HINTS_SHOW: {
    action: 'WC show hints',
    category: WALLETCONNECT_CATEGORY,
  },
  HINTS_HIDE: {
    action: 'WC hide hints',
    category: WALLETCONNECT_CATEGORY,
  },
  HINTS_EXPAND: {
    action: 'WC expand hints',
    category: WALLETCONNECT_CATEGORY,
  },
  SHOW_RISK: {
    action: 'WC show risk',
    category: WALLETCONNECT_CATEGORY,
    event: EventType.META,
  },
  ACCEPT_RISK: {
    action: 'WC accept risk',
    category: WALLETCONNECT_CATEGORY,
  },
  UNSUPPORTED_CHAIN: {
    action: 'WC unsupported chain',
    category: WALLETCONNECT_CATEGORY,
    event: EventType.META,
  },
  SHOW_ERROR: {
    action: 'WC show error',
    category: WALLETCONNECT_CATEGORY,
    event: EventType.META,
  },
  REQUEST: {
    action: 'WC request',
    category: WALLETCONNECT_CATEGORY,
    event: EventType.META,
  },
}
</file>

<file path="src/services/analytics/Analytics.tsx">
import { GA_TRACKING_ID, IS_PRODUCTION, SAFE_APPS_GA_TRACKING_ID } from '@/config/constants'
import { GoogleAnalytics } from '@next/third-parties/google'
import { useEffect } from 'react'

const Analytics = () => {
  useEffect(() => {
    // This needs to be added once in order for events with send_to: SAFE_APPS_GA_TRACKING_ID to work
    window.gtag?.('config', SAFE_APPS_GA_TRACKING_ID, { debug_mode: !IS_PRODUCTION })

    window.gtag?.('consent', 'default', {
      ad_storage: 'denied',
      analytics_storage: 'denied',
      functionality_storage: 'granted',
      personalization_storage: 'denied',
      security_storage: 'granted',
      wait_for_update: 500,
    })
  }, [])

  return <GoogleAnalytics gaId={GA_TRACKING_ID} debugMode={!IS_PRODUCTION} />
}

export default Analytics
</file>

<file path="src/services/analytics/gtm.ts">
/**
 * Google Tag Manager-related functions.
 *
 * Initializes and un-initializes GTM in production or dev mode.
 * Allows sending datalayer events to GTM.
 *
 * This service should NOT be used directly by components. Use the `analytics` service instead.
 */

import { sendGAEvent } from '@next/third-parties/google'
import Cookies from 'js-cookie'
import { SAFE_APPS_GA_TRACKING_ID, GA_TRACKING_ID, IS_PRODUCTION } from '@/config/constants'
import type { AnalyticsEvent, EventLabel, SafeAppSDKEvent } from './types'
import { EventType, DeviceType } from './types'
import { SAFE_APPS_SDK_CATEGORY } from './events'
import { getAbTest } from '../tracking/abTesting'
import type { AbTest } from '../tracking/abTesting'
import { AppRoutes } from '@/config/routes'
import packageJson from '../../../package.json'

const commonEventParams = {
  appVersion: packageJson.version,
  chainId: '',
  deviceType: DeviceType.DESKTOP,
  safeAddress: '',
}

export const gtmSetChainId = (chainId: string): void => {
  commonEventParams.chainId = chainId
}

export const gtmSetDeviceType = (type: DeviceType): void => {
  commonEventParams.deviceType = type
}

export const gtmSetSafeAddress = (safeAddress: string): void => {
  commonEventParams.safeAddress = safeAddress.slice(2) // Remove 0x prefix
}

export const gtmEnableCookies = () => {
  window.gtag?.('consent', 'update', {
    analytics_storage: 'granted',
  })
}

export const gtmDisableCookies = () => {
  window.gtag?.('consent', 'update', {
    analytics_storage: 'denied',
  })

  const GA_COOKIE_LIST = ['_ga', '_gat', '_gid']
  const GA_PREFIX = '_ga_'
  const allCookies = document.cookie.split(';').map((cookie) => cookie.split('=')[0].trim())
  const gaCookies = allCookies.filter((cookie) => cookie.startsWith(GA_PREFIX))

  GA_COOKIE_LIST.concat(gaCookies).forEach((cookie) => {
    Cookies.remove(cookie, {
      path: '/',
      domain: `.${location.host.split('.').slice(-2).join('.')}`,
    })
  })

  // Injected script will remain in memory until new session
  location.reload()
}

export const gtmSetUserProperty = (name: string, value: string) => {
  window.gtag?.('set', 'user_properties', {
    [name]: value,
  })

  if (!IS_PRODUCTION) {
    console.info('[GTM] -', 'set user_properties', name, '=', value)
  }
}

type GtmEvent = {
  event: EventType
  chainId: string
  deviceType: DeviceType
  abTest?: AbTest
}

type ActionGtmEvent = GtmEvent & {
  eventCategory: string
  eventAction: string
  send_to: string
  eventLabel?: EventLabel
  eventType?: string
}

type PageviewGtmEvent = GtmEvent & {
  page_location: string
  page_path: string
  send_to: string
}

type SafeAppGtmEvent = ActionGtmEvent & {
  safeAppName: string
  safeAppMethod?: string
  safeAppEthMethod?: string
  safeAppSDKVersion?: string
  send_to: string
}

export const gtmTrack = (eventData: AnalyticsEvent): void => {
  const gtmEvent: ActionGtmEvent = {
    ...commonEventParams,
    event: eventData.event || EventType.CLICK,
    eventCategory: eventData.category,
    eventAction: eventData.action,
    chainId: eventData.chainId || commonEventParams.chainId,
    send_to: GA_TRACKING_ID,
  }

  if (eventData.event) {
    gtmEvent.eventType = eventData.event
  } else {
    gtmEvent.eventType = undefined
  }

  if (eventData.label !== undefined) {
    gtmEvent.eventLabel = eventData.label
  } else {
    // Otherwise, whatever was in the datalayer before will be reused
    gtmEvent.eventLabel = undefined
  }

  const abTest = getAbTest()

  if (abTest) {
    gtmEvent.abTest = abTest
  }

  sendEvent(gtmEvent.event, gtmEvent)
}

export const gtmTrackPageview = (pagePath: string, pathWithQuery: string): void => {
  const gtmEvent: PageviewGtmEvent = {
    ...commonEventParams,
    event: EventType.PAGEVIEW,
    page_location: `${location.origin}${pathWithQuery}`,
    page_path: pagePath,
    send_to: GA_TRACKING_ID,
  }

  sendEvent('page_view', gtmEvent)
}

export const normalizeAppName = (appName?: string): string => {
  // App name is a URL
  if (appName?.startsWith('http')) {
    // Strip search query and hash
    return appName.split('?')[0].split('#')[0]
  }
  return appName || ''
}

export const gtmTrackSafeApp = (eventData: AnalyticsEvent, appName?: string, sdkEventData?: SafeAppSDKEvent): void => {
  if (!location.pathname.startsWith(AppRoutes.apps.index) && !eventData.label) {
    return
  }

  const safeAppGtmEvent: SafeAppGtmEvent = {
    ...commonEventParams,
    event: EventType.SAFE_APP,
    eventCategory: eventData.category,
    eventAction: eventData.action,
    safeAppName: normalizeAppName(appName),
    safeAppEthMethod: '',
    safeAppMethod: '',
    safeAppSDKVersion: '',
    send_to: SAFE_APPS_GA_TRACKING_ID,
  }

  if (eventData.category === SAFE_APPS_SDK_CATEGORY) {
    safeAppGtmEvent.safeAppMethod = sdkEventData?.method
    safeAppGtmEvent.safeAppEthMethod = sdkEventData?.ethMethod
    safeAppGtmEvent.safeAppSDKVersion = sdkEventData?.version
  }

  if (eventData.label) {
    safeAppGtmEvent.eventLabel = eventData.label
  }

  sendEvent('safeAppEvent', safeAppGtmEvent)
}

const sendEvent = (eventName: string, data: object) => {
  sendGAEvent('event', eventName, data)

  if (!IS_PRODUCTION) {
    console.info('[GA] -', data)
  }
}
</file>

<file path="src/services/analytics/index.ts">
/**
 * The analytics service.
 *
 * Exports `trackEvent` and event types.
 * `trackEvent` is supposed to be called by UI components.
 *
 * The event definitions are in the `events` folder.
 *
 * Usage example:
 *
 * `import { trackEvent, ADDRESS_BOOK_EVENTS } from '@/services/analytics'`
 * `trackEvent(ADDRESS_BOOK_EVENTS.EXPORT)`
 */
import { gtmTrack, gtmTrackSafeApp } from './gtm'

export const trackEvent = gtmTrack
export const trackSafeAppEvent = gtmTrackSafeApp

export * from './types'
export * from './events'
</file>

<file path="src/services/analytics/spindl.ts">
import spindl from '@spindl-xyz/attribution-lite'
import { IS_PRODUCTION } from '@/config/constants'

export const spindlInit = () => {
  const SPINDL_SDK_KEY = process.env.NEXT_PUBLIC_SPINDL_SDK_KEY

  if (!IS_PRODUCTION || !SPINDL_SDK_KEY) return

  spindl.configure({
    sdkKey: SPINDL_SDK_KEY || '',
    debugMode: false,
  })

  spindl.enableAutoPageViews()
}

export const spindlAttribute = (address: string) => {
  if (!IS_PRODUCTION) return

  spindl.attribute(address)
}
</file>

<file path="src/services/analytics/tx-tracking.ts">
import { TX_TYPES } from '@/services/analytics/events/transactions'
import { SettingsInfoType, type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import {
  isERC721Transfer,
  isMultiSendTxInfo,
  isSettingsChangeTxInfo,
  isTransferTxInfo,
  isCustomTxInfo,
  isCancellationTxInfo,
  isSwapOrderTxInfo,
  isAnyStakingTxInfo,
  isNestedConfirmationTxInfo,
} from '@/utils/transaction-guards'
import { BRIDGE_WIDGET_URL } from '@/features/bridge/components/BridgeWidget'

export const getTransactionTrackingType = (
  details: TransactionDetails | undefined,
  origin?: string,
  isMassPayout?: boolean,
): string => {
  if (isMassPayout) {
    return TX_TYPES.batch_transfer_token
  }

  if (!details) {
    return TX_TYPES.custom
  }

  const { txInfo } = details

  const isNativeBridge = origin?.includes(BRIDGE_WIDGET_URL)
  if (isNativeBridge) {
    return TX_TYPES.native_bridge
  }

  if (isTransferTxInfo(txInfo)) {
    if (isERC721Transfer(txInfo.transferInfo)) {
      return TX_TYPES.transfer_nft
    }
    return TX_TYPES.transfer_token
  }

  if (isSwapOrderTxInfo(txInfo)) {
    return TX_TYPES.native_swap
  }

  if (isAnyStakingTxInfo(txInfo)) {
    return txInfo.type
  }

  if (isSettingsChangeTxInfo(txInfo)) {
    switch (txInfo.settingsInfo?.type) {
      case SettingsInfoType.ADD_OWNER: {
        return TX_TYPES.owner_add
      }
      case SettingsInfoType.REMOVE_OWNER: {
        return TX_TYPES.owner_remove
      }
      case SettingsInfoType.SWAP_OWNER: {
        return TX_TYPES.owner_swap
      }
      case SettingsInfoType.CHANGE_THRESHOLD: {
        return TX_TYPES.owner_threshold_change
      }
      case SettingsInfoType.DISABLE_MODULE: {
        return TX_TYPES.module_remove
      }
      case SettingsInfoType.DELETE_GUARD: {
        return TX_TYPES.guard_remove
      }
    }
  }

  if (isCustomTxInfo(txInfo)) {
    if (isCancellationTxInfo(txInfo)) {
      return TX_TYPES.rejection
    }

    if (details.safeAppInfo) {
      return details.safeAppInfo.url
    }

    if (isMultiSendTxInfo(txInfo)) {
      return TX_TYPES.batch
    }

    if (isNestedConfirmationTxInfo(txInfo)) {
      return TX_TYPES.nested_safe
    }

    return TX_TYPES.walletconnect
  }

  return TX_TYPES.custom
}
</file>

<file path="src/services/analytics/types.ts">
/**
 * These event names are passed straight to GTM
 */
export enum EventType {
  PAGEVIEW = 'pageview',
  CLICK = 'customClick',
  META = 'metadata',
  SAFE_APP = 'safeApp',
  SAFE_CREATED = 'safe_created',
  SAFE_ACTIVATED = 'safe_activated',
  SAFE_OPENED = 'safe_opened',
  WALLET_CONNECTED = 'wallet_connected',
  TX_CREATED = 'tx_created',
  TX_CONFIRMED = 'tx_confirmed',
  TX_EXECUTED = 'tx_executed',
}

export type EventLabel = string | number | boolean | null

export type AnalyticsEvent = {
  event?: EventType
  category: string
  action: string
  label?: EventLabel
  chainId?: string
}

export type SafeAppSDKEvent = {
  method: string
  ethMethod: string
  version: string
}

export enum DeviceType {
  DESKTOP = 'desktop',
  MOBILE = 'mobile',
  TABLET = 'tablet',
}

export enum AnalyticsUserProperties {
  WALLET_LABEL = 'walletLabel',
  WALLET_ADDRESS = 'walletAddress',
}

// These are used for the generic stepper flow events (Next, Back)
export enum TxFlowType {
  ADD_OWNER = 'add-owner',
  CANCEL_RECOVERY = 'cancel-recovery',
  CHANGE_THRESHOLD = 'change-threshold',
  CONFIRM_BATCH = 'confirm-batch',
  CONFIRM_TX = 'confirm-tx',
  NFT_TRANSFER = 'nft-transfer',
  REJECT_TX = 'reject-tx',
  REMOVE_GUARD = 'remove-guard',
  REMOVE_MODULE = 'remove-module',
  REMOVE_OWNER = 'remove-owner',
  REMOVE_RECOVERY = 'remove-recovery',
  REMOVE_SPENDING_LIMIT = 'remove-spending-limit',
  REPLACE_OWNER = 'replace-owner',
  SAFE_APPS_TX = 'safe-apps-tx',
  SETUP_RECOVERY = 'setup-recovery',
  SETUP_SPENDING_LIMIT = 'setup-spending-limit',
  SIGN_MESSAGE_ON_CHAIN = 'sign-message-on-chain',
  START_RECOVERY = 'propose-recovery',
  TOKEN_TRANSFER = 'token-transfer',
  UPDATE_SAFE = 'update-safe',
}
</file>

<file path="src/services/analytics/useGtm.ts">
/**
 * Track analytics events using Google Tag Manager
 */
import { useEffect, useState } from 'react'
import { useTheme } from '@mui/material/styles'
import {
  gtmTrackPageview,
  gtmSetChainId,
  gtmEnableCookies,
  gtmDisableCookies,
  gtmSetDeviceType,
  gtmSetSafeAddress,
  gtmSetUserProperty,
  gtmTrack,
} from '@/services/analytics/gtm'
import { spindlInit, spindlAttribute } from './spindl'
import { useAppSelector } from '@/store'
import { CookieAndTermType, hasConsentFor } from '@/store/cookiesAndTermsSlice'
import useChainId from '@/hooks/useChainId'
import { useRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import useMetaEvents from './useMetaEvents'
import { useMediaQuery } from '@mui/material'
import { AnalyticsUserProperties, DeviceType } from './types'
import useSafeAddress from '@/hooks/useSafeAddress'
import useWallet from '@/hooks/wallets/useWallet'
import { OVERVIEW_EVENTS } from './events'
import { useIsSpaceRoute } from '@/hooks/useIsSpaceRoute'

const useGtm = () => {
  const chainId = useChainId()
  const isAnalyticsEnabled = useAppSelector((state) => hasConsentFor(state, CookieAndTermType.ANALYTICS))
  const [, setPrevAnalytics] = useState(isAnalyticsEnabled)
  const router = useRouter()
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))
  const isTablet = useMediaQuery(theme.breakpoints.down('md'))
  const deviceType = isMobile ? DeviceType.MOBILE : isTablet ? DeviceType.TABLET : DeviceType.DESKTOP
  const safeAddress = useSafeAddress()
  const wallet = useWallet()
  const isSpaceRoute = useIsSpaceRoute()

  // Initialize GTM and Spindl
  useEffect(() => {
    spindlInit()
  }, [])

  // Enable GA cookies if consent was given
  useEffect(() => {
    setPrevAnalytics((prev) => {
      if (isAnalyticsEnabled === prev) return prev

      if (isAnalyticsEnabled) {
        gtmEnableCookies()
      } else {
        gtmDisableCookies()
      }

      return isAnalyticsEnabled
    })
  }, [isAnalyticsEnabled])

  // Set the chain ID for all GTM events
  useEffect(() => {
    gtmSetChainId(chainId)
  }, [chainId])

  // Set device type for all GTM events
  useEffect(() => {
    gtmSetDeviceType(deviceType)
  }, [deviceType])

  // Set safe address for all GTM events
  useEffect(() => {
    gtmSetSafeAddress(safeAddress)

    if (safeAddress && !isSpaceRoute) {
      gtmTrack(OVERVIEW_EVENTS.SAFE_VIEWED)
    }
  }, [safeAddress, isSpaceRoute])

  // Track page views – anonymized by default.
  useEffect(() => {
    // Don't track 404 because it's not a real page, it immediately does a client-side redirect
    if (router.pathname === AppRoutes['404'] || isSpaceRoute) return

    gtmTrackPageview(router.pathname, router.asPath)
  }, [router.asPath, router.pathname, isSpaceRoute])

  useEffect(() => {
    if (wallet?.label) {
      gtmSetUserProperty(AnalyticsUserProperties.WALLET_LABEL, wallet.label)
    }
  }, [wallet?.label])

  useEffect(() => {
    if (wallet?.address) {
      gtmSetUserProperty(AnalyticsUserProperties.WALLET_ADDRESS, wallet.address.slice(2)) // Remove 0x prefix because GA converts it to a number otherwise
      spindlAttribute(wallet.address)
    }
  }, [wallet?.address])

  // Track meta events on app load
  useMetaEvents()
}

export default useGtm
</file>

<file path="src/services/analytics/useMetaEvents.ts">
import { useEffect, useMemo } from 'react'
import { gtmTrack } from '@/services/analytics/gtm'
import { TX_LIST_EVENTS, ASSETS_EVENTS } from './events'
import { selectQueuedTransactions } from '@/store/txQueueSlice'
import { useAppSelector } from '@/store'
import useChainId from '@/hooks/useChainId'
import useBalances from '@/hooks/useBalances'
import useSafeInfo from '@/hooks/useSafeInfo'
import useHiddenTokens from '@/hooks/useHiddenTokens'
import { useIsSpaceRoute } from '@/hooks/useIsSpaceRoute'

// Track meta events on app load
const useMetaEvents = () => {
  const chainId = useChainId()
  const { safeAddress } = useSafeInfo()
  const isSpaceRoute = useIsSpaceRoute()

  // Queue size
  const queue = useAppSelector(selectQueuedTransactions)
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const safeQueue = useMemo(() => queue, [safeAddress, queue !== undefined])
  useEffect(() => {
    if (!safeQueue || isSpaceRoute) return

    gtmTrack({
      ...TX_LIST_EVENTS.QUEUED_TXS,
      label: safeQueue.length.toString(),
    })
  }, [safeQueue, isSpaceRoute])

  // Tokens
  const { balances } = useBalances()
  const totalTokens = balances?.items.length ?? 0
  useEffect(() => {
    if (!safeAddress || totalTokens <= 0 || isSpaceRoute) return

    gtmTrack({ ...ASSETS_EVENTS.DIFFERING_TOKENS, label: totalTokens })
  }, [totalTokens, safeAddress, chainId, isSpaceRoute])

  // Manually hidden tokens
  const hiddenTokens = useHiddenTokens()
  const totalHiddenFromBalance =
    balances?.items.filter((item) => hiddenTokens.includes(item.tokenInfo.address)).length ?? 0

  useEffect(() => {
    if (!safeAddress || totalTokens <= 0 || isSpaceRoute) return

    gtmTrack({ ...ASSETS_EVENTS.HIDDEN_TOKENS, label: totalHiddenFromBalance })
  }, [safeAddress, totalHiddenFromBalance, totalTokens, isSpaceRoute])
}

export default useMetaEvents
</file>

<file path="src/services/beamer/index.ts">
import Cookies from 'js-cookie'

import { BEAMER_ID } from '@/config/constants'
import local from '@/services/local-storage/local'

export const BEAMER_SELECTOR = 'whats-new-button'

const enum CustomBeamerAttribute {
  CHAIN = 'chain',
}

// Beamer script tag singleton
let scriptRef: HTMLScriptElement | null = null

const isBeamerLoaded = (): boolean => !!scriptRef

export const loadBeamer = async (shortName: string): Promise<void> => {
  if (isBeamerLoaded()) return

  const BEAMER_URL = 'https://app.getbeamer.com/js/beamer-embed.js'

  if (!BEAMER_ID) {
    console.warn('[Beamer] In order to use Beamer you need to add a `product_id`')
    return
  }

  window.beamer_config = {
    product_id: BEAMER_ID,
    selector: BEAMER_SELECTOR,
    display: 'left',
    bounce: false,
    display_position: 'right',
    [CustomBeamerAttribute.CHAIN]: shortName,
  }

  scriptRef = document.createElement('script')
  scriptRef.type = 'text/javascript'
  scriptRef.defer = true
  scriptRef.src = BEAMER_URL

  const firstScript = document.getElementsByTagName('script')[0]
  firstScript?.parentNode?.insertBefore(scriptRef, firstScript)

  scriptRef.addEventListener('load', () => window.Beamer?.init(), { once: true })
}

export const updateBeamer = async (shortName: string): Promise<void> => {
  if (!isBeamerLoaded() || !window?.Beamer) {
    return
  }

  window.Beamer.update({
    [CustomBeamerAttribute.CHAIN]: shortName,
  })
}

export const unloadBeamer = (): void => {
  const BEAMER_LS_RE = /^_BEAMER_/

  const BEAMER_COOKIES = [
    '_BEAMER_LAST_POST_SHOWN_',
    '_BEAMER_DATE_',
    '_BEAMER_FIRST_VISIT_',
    '_BEAMER_USER_ID_',
    '_BEAMER_FILTER_BY_URL_',
    '_BEAMER_LAST_UPDATE_',
    '_BEAMER_BOOSTED_ANNOUNCEMENT_DATE_',
    '_BEAMER_NPS_LAST_SHOWN_',
  ]

  if (!window?.Beamer || !scriptRef) {
    return
  }

  window.Beamer.destroy()
  scriptRef.remove()
  scriptRef = null

  const domain = location.host.split('.').slice(-2).join('.')

  setTimeout(() => {
    local.removeMatching(BEAMER_LS_RE)
    BEAMER_COOKIES.forEach((name) => Cookies.remove(name, { domain, path: '/' }))
  }, 100)
}

export const shouldShowBeamerNps = (): boolean => {
  if (!isBeamerLoaded() || !window?.Beamer) {
    return false
  }

  const COOKIE_NAME = `_BEAMER_NPS_LAST_SHOWN_${BEAMER_ID}`

  // Beamer advise using their '/nps/check' endpoint to see if the NPS should be shown
  // As we need to check this more than the request limit, we instead check the cookie
  // @see https://www.getbeamer.com/api
  return !window.Beamer.getCookie(COOKIE_NAME)
}
</file>

<file path="src/services/beamer/types.ts">
export type BeamerConfig = {
  product_id: string
  selector?: string
  display?: 'left' | 'right' | 'popup' | 'in-app'
  display_position?: string
  top?: number
  right?: number
  bottom?: number
  left?: number
  embed?: boolean
  button?: boolean
  button_position?: 'top-left' | 'top-right' | 'bottom-right' | 'bottom-left'
  icon?: 'bell_full' | 'bell_lines' | 'flame' | 'flame_alt' | 'alert_bubble' | 'alert_circle' | 'bullhorn' | 'thumbtack'
  bounce?: boolean
  notification_prompt?: 'sidebar' | 'popup'
  notification_prompt_delay?: number
  language?: string
  filter?: string
  force_filter?: string
  filter_by_url?: boolean
  mobile?: boolean
  lazy?: boolean
  alert?: boolean
  force_button?: boolean
  counter?: boolean
  first_visit_unread?: number
  standalone?: boolean
  post_request?: boolean
  delay?: number
  callback?: (url: string, openInNewWindow: boolean) => boolean
  onclick?: (url: string, openInNewWindow: boolean) => boolean
  onopen?: () => boolean
  onclose?: () => boolean
  onerror?: () => unknown
  user_firstname?: string
  user_lastname?: string
  user_email?: string
  user_id?: string
  multi_user?: boolean
  nps_delay?: number
  user_created_at?: number | string
}

export type BeamerMethods = {
  init: () => void
  show: () => void
  hide: () => void
  update: (params: BeamerConfig) => void
  destroy: () => void
}
</file>

<file path="src/services/contracts/ContractErrorCodes.ts">
// https://github.com/gnosis/safe-contracts/blob/main/docs/error_codes.md
export enum ContractErrorCodes {
  // General init related
  GS000 = 'Could not finish initialization',
  GS001 = 'Threshold needs to be defined',

  // General gas/ execution related
  GS010 = 'Not enough gas to execute Safe transaction',
  GS011 = 'Could not pay gas costs with ether',
  GS012 = 'Could not pay gas costs with token',
  GS013 = 'Safe transaction failed when gasPrice and safeTxGas were 0',

  // General signature validation related
  GS020 = 'Signatures data too short',
  GS021 = 'Invalid contract signature location = inside static part',
  GS022 = 'Invalid contract signature location = length not present',
  GS023 = 'Invalid contract signature location = data not complete',
  GS024 = 'Invalid contract signature provided',
  GS025 = 'Hash has not been approved',
  GS026 = 'Invalid owner provided',

  // General auth related
  GS030 = 'Only owners can approve a hash',
  GS031 = 'Method can only be called from this contract',

  // Module management related
  GS100 = 'Modules have already been initialized',
  GS101 = 'Invalid module address provided',
  GS102 = 'Module has already been added',
  GS103 = 'Invalid prevModule, module pair provided',
  GS104 = 'Method can only be called from an enabled module',

  // Owner management related
  GS200 = 'Owners have already been set up',
  GS201 = 'Threshold cannot exceed owner count',
  GS202 = 'Threshold needs to be greater than 0',
  GS203 = 'Invalid owner address provided',
  GS204 = 'Address is already an owner',
  GS205 = 'Invalid prevOwner, owner pair provided',

  // Guard management related
  GS300 = 'Guard does not implement IERC165',
}

export default ContractErrorCodes
</file>

<file path="src/services/contracts/safeContracts.ts">
import { _isL2 } from '@safe-global/utils/services/contracts/deployments'
import { getSafeProvider } from '@/services/tx/tx-sender/sdk'
import { SafeProvider } from '@safe-global/protocol-kit'
import {
  getCompatibilityFallbackHandlerContractInstance,
  getMultiSendCallOnlyContractInstance,
  getSafeContractInstance,
  getSafeProxyFactoryContractInstance,
  getSignMessageLibContractInstance,
} from '@safe-global/protocol-kit/dist/src/contracts/contractInstances'
import type SafeBaseContract from '@safe-global/protocol-kit/dist/src/contracts/Safe/SafeBaseContract'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { getSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import semver from 'semver'
import { getSafeMigrationDeployment } from '@safe-global/safe-deployments'
import { SAFE_TO_L2_MIGRATION_VERSION } from '@/utils/safe-migrations'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'
import { _getValidatedGetContractProps } from '@safe-global/utils/services/contracts/safeContracts'

// GnosisSafe

const getGnosisSafeContract = async (safe: SafeState, safeProvider: SafeProvider) => {
  return getSafeContractInstance(
    _getValidatedGetContractProps(safe.version).safeVersion,
    safeProvider,
    safe.address.value,
  )
}

export const getReadOnlyCurrentGnosisSafeContract = async (safe: SafeState): Promise<SafeBaseContract<any>> => {
  const safeSDK = getSafeSDK()
  if (!safeSDK) {
    throw new Error('Safe SDK not found.')
  }

  const safeProvider = safeSDK.getSafeProvider()

  return getGnosisSafeContract(safe, safeProvider)
}

export const getCurrentGnosisSafeContract = async (safe: SafeState, provider: string) => {
  const safeProvider = new SafeProvider({ provider })

  return getGnosisSafeContract(safe, safeProvider)
}

export const getReadOnlyGnosisSafeContract = async (
  chain: ChainInfo,
  safeVersion: SafeState['version'],
  isL1?: boolean,
) => {
  const version = safeVersion ?? getLatestSafeVersion(chain)

  const safeProvider = getSafeProvider()

  const isL1SafeSingleton = isL1 ?? !_isL2(chain, _getValidatedGetContractProps(version).safeVersion)

  return getSafeContractInstance(
    _getValidatedGetContractProps(version).safeVersion,
    safeProvider,
    undefined,
    undefined,
    isL1SafeSingleton,
  )
}

// MultiSend

export const _getMinimumMultiSendCallOnlyVersion = (safeVersion: SafeState['version']) => {
  const INITIAL_CALL_ONLY_VERSION = '1.3.0'

  if (!safeVersion) {
    return INITIAL_CALL_ONLY_VERSION
  }

  return semver.gte(safeVersion, INITIAL_CALL_ONLY_VERSION) ? safeVersion : INITIAL_CALL_ONLY_VERSION
}

export const getReadOnlyMultiSendCallOnlyContract = async (safeVersion: SafeState['version']) => {
  const safeSDK = getSafeSDK()
  if (!safeSDK) {
    throw new Error('Safe SDK not found.')
  }

  const safeProvider = safeSDK.getSafeProvider()

  return getMultiSendCallOnlyContractInstance(_getValidatedGetContractProps(safeVersion).safeVersion, safeProvider)
}

// GnosisSafeProxyFactory

export const getReadOnlyProxyFactoryContract = async (safeVersion: SafeState['version'], contractAddress?: string) => {
  const safeProvider = getSafeProvider()

  return getSafeProxyFactoryContractInstance(
    _getValidatedGetContractProps(safeVersion).safeVersion,
    safeProvider,
    safeProvider.getExternalProvider(),
    contractAddress,
  )
}

// Fallback handler

export const getReadOnlyFallbackHandlerContract = async (safeVersion: SafeState['version']) => {
  const safeProvider = getSafeProvider()

  return getCompatibilityFallbackHandlerContractInstance(
    _getValidatedGetContractProps(safeVersion).safeVersion,
    safeProvider,
  )
}

// Sign messages deployment

export const getReadOnlySignMessageLibContract = async (safeVersion: SafeState['version']) => {
  const safeSDK = getSafeSDK()
  if (!safeSDK) {
    throw new Error('Safe SDK not found.')
  }

  const safeProvider = safeSDK.getSafeProvider()

  return getSignMessageLibContractInstance(_getValidatedGetContractProps(safeVersion).safeVersion, safeProvider)
}

export const isMigrationToL2Possible = (safe: SafeState): boolean => {
  return (
    safe.nonce === 0 &&
    Boolean(
      getSafeMigrationDeployment({ network: safe.chainId, version: SAFE_TO_L2_MIGRATION_VERSION })?.networkAddresses[
        safe.chainId
      ],
    )
  )
}
</file>

<file path="src/services/contracts/spendingLimitContracts.ts">
import { getAllowanceModuleDeployment } from '@safe-global/safe-modules-deployments'

import type { AllowanceModule } from '@safe-global/utils/types/contracts'
import { AllowanceModule__factory } from '@safe-global/utils/types/contracts'
import type { JsonRpcProvider, JsonRpcSigner } from 'ethers'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { sameAddress } from '@safe-global/utils/utils/addresses'

enum ALLOWANCE_MODULE_VERSIONS {
  '0.1.0' = '0.1.0',
  '0.1.1' = '0.1.1',
}

const ALL_VERSIONS = [ALLOWANCE_MODULE_VERSIONS['0.1.0'], ALLOWANCE_MODULE_VERSIONS['0.1.1']]

const getDeployment = (chainId: string, modules: SafeState['modules']) => {
  if (!modules?.length) return
  for (let version of ALL_VERSIONS) {
    const deployment = getAllowanceModuleDeployment({ network: chainId, version })
    if (!deployment) continue
    const deploymentAddress = deployment?.networkAddresses[chainId]
    const isMatch = modules?.some((address) => sameAddress(address.value, deploymentAddress))
    if (isMatch) return deployment
  }
}

export const getLatestSpendingLimitAddress = (chainId: string): string | undefined => {
  const deployment = getAllowanceModuleDeployment({ network: chainId })
  return deployment?.networkAddresses[chainId]
}

export const getDeployedSpendingLimitModuleAddress = (
  chainId: string,
  modules: SafeState['modules'],
): string | undefined => {
  const deployment = getDeployment(chainId, modules)
  return deployment?.networkAddresses[chainId]
}

// SDK request here: https://github.com/safe-global/safe-core-sdk/issues/263
export const getSpendingLimitContract = (
  chainId: string,
  modules: SafeState['modules'],
  provider: JsonRpcProvider | JsonRpcSigner,
): AllowanceModule => {
  const allowanceModuleDeployment = getDeployment(chainId, modules)

  if (!allowanceModuleDeployment) {
    throw new Error(`AllowanceModule contract not found`)
  }

  const contractAddress = allowanceModuleDeployment.networkAddresses[chainId]

  return AllowanceModule__factory.connect(contractAddress, provider)
}

export const getSpendingLimitInterface = () => {
  return AllowanceModule__factory.createInterface()
}
</file>

<file path="src/services/datadog/index.ts">
import { useEffect } from 'react'
import { datadogLogs } from '@datadog/browser-logs'
import { DATADOG_CLIENT_TOKEN, IS_PRODUCTION } from '@/config/constants'

let isDatadogInitialized = false

function initDatadog() {
  if (isDatadogInitialized) {
    return
  }
  if (!DATADOG_CLIENT_TOKEN) {
    console.warn('Datadog client token is not set. Skipping Datadog initialization.')
    return
  }
  if (!IS_PRODUCTION) {
    console.warn('Datadog is not initialized in non-production environments. Skipping Datadog initialization.')
    return
  }

  datadogLogs.init({
    clientToken: DATADOG_CLIENT_TOKEN,
    site: 'datadoghq.eu',
    forwardErrorsToLogs: true,
    sessionSampleRate: 100,
  })

  isDatadogInitialized = true
}

export function useDatadog() {
  useEffect(() => {
    initDatadog()
  }, [])
}

export const logger = datadogLogs.logger
</file>

<file path="src/services/ens/index.ts">
import { type Provider } from 'ethers'
import { logError } from '../exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'

type EthersError = Error & {
  reason?: string
}

// ENS domains can have any TLD, so just check that it ends with a dot-separated tld
const DOMAIN_RE = /[^.]+[.][^.]+$/iu

export function isDomain(domain: string): boolean {
  return DOMAIN_RE.test(domain)
}

export const resolveName = async (rpcProvider: Provider, name: string): Promise<string | undefined> => {
  try {
    return (await rpcProvider.resolveName(name)) || undefined
  } catch (e) {
    const err = e as EthersError
    logError(ErrorCodes._101, err.reason || err.message)
  }
}

export const lookupAddress = async (rpcProvider: Provider, address: string): Promise<string | undefined> => {
  try {
    return (await rpcProvider.lookupAddress(address)) || undefined
  } catch (e) {
    const err = e as EthersError
    logError(ErrorCodes._101, err.reason || err.message)
  }
}
</file>

<file path="src/services/exceptions/index.ts">
import { sentryCaptureException } from '@/services/sentry'
import { IS_PRODUCTION } from '@/config/constants'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { logger } from '../datadog'

export class CodedException extends Error {
  public readonly code: number
  public readonly content: string

  private getCode(content: ErrorCodes): number {
    const codePrefix = content.split(':')[0]
    const code = Number(codePrefix)
    if (isNaN(code)) {
      throw new CodedException(ErrorCodes.___0, codePrefix)
    }
    return code
  }

  constructor(content: ErrorCodes, thrown?: unknown) {
    super()

    const extraInfo = thrown ? ` (${asError(thrown).message})` : ''
    this.message = `Code ${content}${extraInfo}`
    this.code = this.getCode(content)
    this.content = content
  }

  public log(): void {
    // Filter out the logError fn from the stack trace
    if (this.stack) {
      const newStack = this.stack
        .split('\n')
        .filter((line) => !line.includes(logError.name))
        .join('\n')
      try {
        this.stack = newStack
      } catch (e) {}
    }

    // Log only the message on prod, and the full error on dev
    console.error(IS_PRODUCTION ? this.message : this)

    if (IS_PRODUCTION) {
      // Log to Datadog
      logger.error(this.message, {
        code: this.code,
      })
    }
  }

  public track(): void {
    this.log()

    if (IS_PRODUCTION) {
      sentryCaptureException(this)
    }
  }
}

type ErrorHandler = (content: ErrorCodes, thrown?: unknown) => CodedException

export const logError: ErrorHandler = function logError(...args) {
  const error = new CodedException(...args)
  error.log()
  return error
}

export const trackError: ErrorHandler = function trackError(...args) {
  const error = new CodedException(...args)
  error.track()
  return error
}

export const Errors = ErrorCodes
</file>

<file path="src/services/local-storage/local.ts">
import Storage from './Storage'

const local = new Storage(typeof window !== 'undefined' ? window.localStorage : undefined)

export const localItem = <T>(key: string) => ({
  get: () => local.getItem<T>(key),
  set: (value: T) => local.setItem<T>(key, value),
  remove: () => local.removeItem(key),
})

export default local
</file>

<file path="src/services/local-storage/session.ts">
import Storage from './Storage'

const session = new Storage(typeof window !== 'undefined' ? window.sessionStorage : undefined)

export const sessionItem = <T>(key: string) => ({
  get: () => session.getItem<T>(key),
  set: (value: T) => session.setItem<T>(key, value),
  remove: () => session.removeItem(key),
})

export default session
</file>

<file path="src/services/local-storage/Storage.ts">
import { LS_NAMESPACE } from '@/config/constants'
import { Errors, logError } from '@/services/exceptions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { reviver, replacer } from './storageHelpers'
type BrowserStorage = typeof localStorage | typeof sessionStorage

type ItemWithExpiry<T> = {
  value: T
  expiry: number
}

class Storage {
  private readonly prefix: string
  private storage?: BrowserStorage

  constructor(storage?: BrowserStorage, prefix = LS_NAMESPACE) {
    this.prefix = prefix
    this.storage = storage
  }

  public getPrefixedKey = (key: string): string => {
    return `${this.prefix}${key}`
  }

  public getItem = <T>(key: string): T | null => {
    const fullKey = this.getPrefixedKey(key)
    let saved: string | null = null
    try {
      saved = this.storage?.getItem(fullKey) ?? null
    } catch (err) {
      logError(Errors._700, `key ${key} – ${asError(err).message}`)
    }

    if (saved == null) return null

    try {
      return JSON.parse(saved, reviver) as T
    } catch (err) {
      logError(Errors._700, `key ${key} – ${asError(err).message}`)
    }
    return null
  }

  public setItem = <T>(key: string, item: T): void => {
    const fullKey = this.getPrefixedKey(key)

    try {
      if (item == null) {
        this.storage?.removeItem(fullKey)
      } else {
        this.storage?.setItem(fullKey, JSON.stringify(item, replacer))
      }
    } catch (err) {
      logError(Errors._701, `key ${key} – ${asError(err).message}`)
    }
  }

  public removeItem = (key: string): void => {
    const fullKey = this.getPrefixedKey(key)
    try {
      this.storage?.removeItem(fullKey)
    } catch (err) {
      logError(Errors._702, `key ${key} – ${asError(err).message}`)
    }
  }

  public removeMatching = (pattern: RegExp): void => {
    Object.keys(this.storage || {})
      .filter((key) => pattern.test(key))
      .forEach((key) => this.storage?.removeItem(key))
  }

  public setWithExpiry = <T>(key: string, item: T, expiry: number): void => {
    this.setItem<ItemWithExpiry<T>>(key, {
      value: item,
      expiry: new Date().getTime() + expiry,
    })
  }

  public getWithExpiry = <T>(key: string): T | undefined => {
    const item = this.getItem<ItemWithExpiry<T>>(key)
    if (!item) {
      return
    }

    if (new Date().getTime() > item.expiry) {
      this.removeItem(key)
      return
    }

    return item.value
  }
}

export default Storage
</file>

<file path="src/services/local-storage/storageHelpers.ts">
/**
 * JSON.stringify or JSON.parse can't handle BigInts.
 *
 * With the replacer we convert a BigInt value to {__type: 'bigint', __value: '0x...'}
 *
 * The reviver converts the object back to a BigInt.
 */
type BigIntSerialized = {
  __type: 'bigint'
  __value: string
}

function isBigIntSerialized(value: unknown): value is BigIntSerialized {
  return (value as BigIntSerialized)?.__type === 'bigint'
}

export function replacer(_: string, value: unknown) {
  if (typeof value === 'bigint') {
    let hex = value.toString(16)
    if (hex.length % 2 === 0) {
      hex = '0' + hex
    }

    return {
      __type: 'bigint',
      __value: '0x' + hex,
    }
  } else {
    return value
  }
}

export function reviver(_: string, value: unknown) {
  if (isBigIntSerialized(value)) {
    return BigInt(value.__value)
  }
  return value
}
</file>

<file path="src/services/local-storage/useLocalStorage.ts">
import { useCallback, useEffect } from 'react'
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import session from './session'
import local from './local'
import type Storage from './Storage'

// The setter accepts T or a function that takes the old value and returns T
// Mimics the behavior of useState
type Undefinable<T> = T | undefined

export type Setter<T> = (val: T | ((prevVal: Undefinable<T>) => Undefinable<T>)) => void

// External stores for each localStorage key which act as a shared cache for LS
const externalStores: Record<string, ExternalStore<any>> = {}

const useStorage = <T>(key: string, storage: Storage): [Undefinable<T>, Setter<T>] => {
  if (!externalStores[key]) {
    externalStores[key] = new ExternalStore<T>()
  }
  const { getStore, setStore, useStore } = externalStores[key] as ExternalStore<T>

  // This is the setter that will be returned
  // It will update the local storage and cache
  const setNewValue = useCallback<Setter<T>>(
    (value) => {
      setStore((oldValue) => {
        const newValue = value instanceof Function ? value(oldValue) : value

        if (newValue !== oldValue) {
          storage.setItem(key, newValue)
        }

        return newValue
      })
    },
    [key, setStore, storage],
  )

  // Set the initial value from LS on mount
  useEffect(() => {
    if (getStore() === undefined) {
      const lsValue = storage.getItem<T>(key)
      if (lsValue !== null) {
        setStore(lsValue)
      }
    }
  }, [key, getStore, setStore, storage])

  // Subscribe to changes in local storage and update the cache
  // This will work across tabs
  useEffect(() => {
    const onStorageEvent = (event: StorageEvent) => {
      if (event.key === storage.getPrefixedKey(key)) {
        const lsValue = storage.getItem<T>(key)
        if (lsValue !== null && lsValue !== getStore()) {
          setStore(lsValue)
        }
      }
    }

    window.addEventListener('storage', onStorageEvent)

    return () => {
      window.removeEventListener('storage', onStorageEvent)
    }
  }, [key, getStore, setStore, storage])

  return [useStore(), setNewValue]
}

const useLocalStorage = <T>(key: string): [Undefinable<T>, Setter<T>] => {
  const localStorage = useStorage<T>(key, local)
  return localStorage
}

export const useSessionStorage = <T>(key: string): [Undefinable<T>, Setter<T>] => {
  const localStorage = useStorage<T>(key, session)
  return localStorage
}

export default useLocalStorage
</file>

<file path="src/services/ls-migration/addedSafes.ts">
import { type AddedSafesState, type AddedSafesOnChain } from '@/store/addedSafesSlice'
import type { LOCAL_STORAGE_DATA } from './common'
import { parseLsValue } from './common'
import { isChecksummedAddress } from '@safe-global/utils/utils/addresses'
import isObject from 'lodash/isObject'
import type { AddressEx } from '@safe-global/safe-gateway-typescript-sdk'

const IMMORTAL_PREFIX = '_immortal|v2_'

const CHAIN_PREFIXES: Record<string, string> = {
  '1': 'MAINNET',
  '56': 'BSC',
  '100': 'XDAI',
  '137': 'POLYGON',
  '246': 'ENERGY_WEB_CHAIN',
  '42161': 'ARBITRUM',
  '73799': 'VOLTA',
}
const ALL_CHAINS = ['1', '100', '137', '56', '246', '42161', '1313161554', '43114', '10', '5', '73799']

const OLD_LS_KEY = '__SAFES'

type OldAddedSafes = Record<
  string,
  {
    address: string
    chainId: string
    ethBalance: string
    owners: Array<string | { name?: string; address: string }>
    threshold: number
  }
>

export const migrateAddedSafesOwners = (
  owners: OldAddedSafes[string]['owners'],
): AddedSafesState[string][string]['owners'] | undefined => {
  const migratedOwners = owners
    .map((value) => {
      if (typeof value === 'string' && isChecksummedAddress(value)) {
        return { value }
      }

      if (isObject(value) && typeof value.address === 'string' && isChecksummedAddress(value.address)) {
        const owner: AddressEx = {
          value: value.address,
          ...(typeof value.name === 'string' && { name: value.name }),
        }
        return owner
      }
    })
    .filter((owner): owner is AddressEx => !!owner)

  return migratedOwners.length > 0 ? migratedOwners : undefined
}

export const migrateAddedSafes = (lsData: LOCAL_STORAGE_DATA): AddedSafesState | void => {
  const newAddedSafes: AddedSafesState = {}

  ALL_CHAINS.forEach((chainId) => {
    const chainPrefix = CHAIN_PREFIXES[chainId] || chainId
    const legacyAddedSafes = parseLsValue<OldAddedSafes>(lsData[IMMORTAL_PREFIX + chainPrefix + OLD_LS_KEY])

    if (legacyAddedSafes && Object.keys(legacyAddedSafes).length > 0) {
      console.log('Migrating added Safe Accounts on chain', chainId)

      const safesPerChain = Object.values(legacyAddedSafes).reduce<AddedSafesOnChain>((acc, oldItem) => {
        const migratedOwners = migrateAddedSafesOwners(oldItem.owners)

        if (migratedOwners) {
          acc[oldItem.address] = {
            ethBalance: oldItem.ethBalance,
            owners: migratedOwners,
            threshold: oldItem.threshold,
          }
        }

        return acc
      }, {})

      if (Object.keys(safesPerChain).length > 0) {
        newAddedSafes[chainId] = safesPerChain
      }
    }
  })

  if (Object.keys(newAddedSafes).length > 0) {
    return newAddedSafes
  }
}
</file>

<file path="src/services/ls-migration/addressBook.ts">
import chains from '@/config/chains'
import { type AddressBookState } from '@/store/addressBookSlice'
import { isChecksummedAddress } from '@safe-global/utils/utils/addresses'
import type { LOCAL_STORAGE_DATA } from './common'
import { parseLsValue } from './common'

const OLD_LS_KEY = 'SAFE__addressBook'

type OldAddressBook = Array<{ address: string; name: string; chainId: string }>

export const migrateAddressBook = (lsData: LOCAL_STORAGE_DATA): AddressBookState | void => {
  const legacyAb = parseLsValue<OldAddressBook>(lsData[OLD_LS_KEY])
  if (Array.isArray(legacyAb)) {
    console.log('Migrating address book')

    const newAb = legacyAb.reduce<AddressBookState>((acc, { address, name, chainId }) => {
      if (!name || !address || !isChecksummedAddress(address) || chainId === chains.rin) {
        return acc
      }
      acc[chainId] = acc[chainId] || {}
      acc[chainId][address] = name
      return acc
    }, {})

    if (Object.keys(newAb).length > 0) {
      return newAb
    }
  }
}
</file>

<file path="src/services/ls-migration/common.ts">
type LS_ITEM = string | number | boolean | null

export type LOCAL_STORAGE_DATA = Record<string, LS_ITEM>

export const parseLsValue = <T>(value: LS_ITEM): T | undefined => {
  if (typeof value === 'string' && value.length > 0) {
    try {
      return JSON.parse(value) as T
    } catch (e) {
      console.error('Failed to parse stored value', value)
      return
    }
  }
}
</file>

<file path="src/services/onboard/ledger-module.ts">
import type { DeviceActionState } from '@ledgerhq/device-management-kit'
import type {
  GetAddressDAOutput,
  SignPersonalMessageDAOutput,
  SignTransactionDAOutput,
  SignTypedDataDAOutput,
  TypedData,
} from '@ledgerhq/device-signer-kit-ethereum'
import type { Chain, WalletInit, WalletInterface } from '@web3-onboard/common'
import type { Account, Asset, BasePath, DerivationPath, ScanAccountsOptions } from '@web3-onboard/hw-common'

const LEDGER_LIVE_PATH: DerivationPath = "44'/60'"
const LEDGER_LEGACY_PATH: DerivationPath = "44'/60'/0'"

const DEFAULT_BASE_PATHS: Array<BasePath> = [
  {
    label: 'Ledger Live',
    value: LEDGER_LIVE_PATH,
  },
  {
    label: 'Ledger Legacy',
    value: LEDGER_LEGACY_PATH,
  },
]

const DEFAULT_ASSETS: Array<Asset> = [
  {
    label: 'ETH',
  },
]

export function ledgerModule(): WalletInit {
  return () => {
    return {
      label: 'Ledger',
      getIcon: async (): Promise<string> => `
<svg width="160" height="160" viewBox="0 0 160 160" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="160" height="160" rx="16" fill="#00000D"/>
<path d="M93.1482 119.207V125H135V98.8769H128.902V119.207H93.1482ZM93.1482 33V38.792H128.902V59.1231H135V33H93.1482ZM74.0104 59.1231H67.9125V98.8769H95.4153V93.6539H74.0104V59.1231ZM26 98.8769V125H67.8518V119.207H32.0979V98.8769H26ZM26 33V59.1231H32.0979V38.792H67.8518V33H26Z" fill="white"/>
</svg>`,
      getInterface: async ({ chains, EventEmitter }): Promise<WalletInterface> => {
        const DEFAULT_CHAIN = chains[0]

        const { BigNumber } = await import('@ethersproject/bignumber')
        const { hexaStringToBuffer } = await import('@ledgerhq/device-management-kit')
        const { createEIP1193Provider, ProviderRpcError, ProviderRpcErrorCode } = await import('@web3-onboard/common')
        const { accountSelect, getHardwareWalletProvider } = await import('@web3-onboard/hw-common')
        const { Signature, Transaction, JsonRpcProvider } = await import('ethers')

        const eventEmitter = new EventEmitter()
        const ledgerSdk = await getLedgerSdk()

        /* -------------------------------------------------------------------------- */
        /*                                    State                                   */
        /* -------------------------------------------------------------------------- */

        let currentChain = DEFAULT_CHAIN
        let currentAccount: Account | null = null

        // Sets the current chain and emits the chainChanged event
        function setCurrentChain(chainId: Chain['id']): void {
          const newChain = chains.find((chain) => chain.id === chainId)
          if (!newChain) {
            throw new ProviderRpcError({
              code: ProviderRpcErrorCode.UNRECOGNIZED_CHAIN_ID,
              message: `Unrecognized chain ID: ${chainId}`,
            })
          }
          currentChain = newChain
          eventEmitter.emit('chainChanged', currentChain.id)
        }

        // Sets the current account and emits the accountsChanged event
        function setCurrentAccount(account: Account): void {
          currentAccount = account
          eventEmitter.emit('accountsChanged', [currentAccount.address])
        }

        // Clears the current account and emits the accountsChanged event
        function clearCurrentAccount(): void {
          currentAccount = null
          eventEmitter.emit('accountsChanged', [])
        }

        // Clears the current chain and emits the chainChanged event
        function clearCurrentChain(): void {
          currentChain = DEFAULT_CHAIN
          eventEmitter.emit('chainChanged', currentChain.id)
        }

        // Gets the asserted derivation path from the current account
        function getAssertedDerivationPath(): DerivationPath {
          if (!currentAccount?.derivationPath) {
            throw new ProviderRpcError({
              code: -32000, // Method handler crashed
              message: 'No derivation path found',
            })
          }
          return currentAccount.derivationPath
        }

        /* -------------------------------------------------------------------------- */
        /*                              EIP-1193 provider                             */
        /* -------------------------------------------------------------------------- */

        const eip1193Provider = createEIP1193Provider(
          getHardwareWalletProvider(() => {
            const rpcUrl = currentChain.rpcUrl
            if (!rpcUrl) {
              throw new ProviderRpcError({
                code: ProviderRpcErrorCode.UNRECOGNIZED_CHAIN_ID,
                message: `No RPC found for chain ID: ${currentChain.id}`,
              })
            }
            return rpcUrl
          }),
          {
            eth_requestAccounts: async () => {
              const accounts = await getAccounts()
              return [accounts[0].address]
            },
            eth_selectAccounts: async () => {
              const accounts = await getAccounts()
              return accounts.map((account) => account.address)
            },
            eth_accounts: async () => {
              if (!currentAccount) {
                return []
              }
              return [currentAccount.address]
            },
            eth_chainId: async () => {
              return currentChain.id
            },
            eth_signTransaction: async (args) => {
              const txParams = args.params[0]

              const gasLimit = txParams.gas ?? txParams.gasLimit
              const nonce =
                txParams.nonce ??
                // Safe creation does not provide nonce
                ((await eip1193Provider.request({
                  method: 'eth_getTransactionCount',
                  // Take pending transactions into account
                  params: [currentAccount!.address, 'pending'],
                })) as string)

              const transaction = Transaction.from({
                chainId: BigInt(currentChain.id),
                data: txParams.data,
                gasLimit: gasLimit ? BigInt(gasLimit) : null,
                gasPrice: txParams.gasPrice ? BigInt(txParams.gasPrice) : null,
                maxFeePerGas: txParams.maxFeePerGas ? BigInt(txParams.maxFeePerGas) : null,
                maxPriorityFeePerGas: txParams.maxPriorityFeePerGas ? BigInt(txParams.maxPriorityFeePerGas) : null,
                nonce: parseInt(nonce, 16),
                to: txParams.to,
                value: txParams.value ? BigInt(txParams.value) : null,
              })

              transaction.signature = await ledgerSdk.signTransaction(
                getAssertedDerivationPath(),
                hexaStringToBuffer(transaction.unsignedSerialized)!,
              )

              return transaction.serialized
            },
            eth_sendTransaction: async (args) => {
              const signedTransaction = await eip1193Provider.request({
                method: 'eth_signTransaction',
                params: args.params,
              })
              return (await eip1193Provider.request({
                method: 'eth_sendRawTransaction',
                params: [signedTransaction],
              })) as string
            },
            eth_sign: async (args) => {
              // The Safe requires transactions be signed as bytes, but eth_sign is only used by
              // the Transaction Service, e.g. notification registration. We therefore sign
              // messages as is to avoid unreadable byte notation (e.g. \xef\xbe\xad\xde). Instead,
              // the Ledger device shows plain hex (e.g. 0xdeadbeef).
              const message = args.params[1]
              const signature = await ledgerSdk.signMessage(getAssertedDerivationPath(), message)
              return Signature.from(signature).serialized
            },
            personal_sign: async (args) => {
              // personal_sign params are the inverse of eth_sign
              const [message, address] = args.params
              return await eip1193Provider.request({
                method: 'eth_sign',
                params: [address, message],
              })
            },
            eth_signTypedData: async (args) => {
              const typedData = JSON.parse(args.params[1])
              const signature = await ledgerSdk.signTypedData(getAssertedDerivationPath(), typedData)
              return Signature.from(signature).serialized
            },
            // @ts-expect-error createEIP1193Provider does not allow overriding eth_signTypedData_v3
            eth_signTypedData_v3: async (args) => {
              return await eip1193Provider.request({ method: 'eth_signTypedData', params: args.params })
            },
            // @ts-expect-error createEIP1193Provider does not allow overriding eth_signTypedData_v4
            eth_signTypedData_v4: async (args) => {
              return await eip1193Provider.request({ method: 'eth_signTypedData', params: args.params })
            },
            wallet_switchEthereumChain: async (args) => {
              const chainId = args.params[0].chainId
              setCurrentChain(chainId)
              return null
            },
          },
        )

        // Disconnects Ledger device and clears current account and chain
        eip1193Provider.disconnect = async () => {
          await ledgerSdk.disconnect()
          clearCurrentAccount()
          clearCurrentChain()
        }

        // createEIP1193Provider does not bind EventEmitter
        eip1193Provider.on = eventEmitter.on.bind(eventEmitter)
        eip1193Provider.removeListener = eventEmitter.removeListener.bind(eventEmitter)

        /* -------------------------------------------------------------------------- */
        /*                       Web3-Onboard account selection                       */
        /* -------------------------------------------------------------------------- */

        /**
         * Gets a list of derived accounts from Ledger device for selection
         * and sets the first account as the current account
         */
        async function getAccounts(): Promise<Array<Account>> {
          const accounts = await accountSelect({
            basePaths: DEFAULT_BASE_PATHS,
            assets: DEFAULT_ASSETS,
            chains,
            scanAccounts: deriveAccounts,
          })

          if (accounts.length > 0) {
            setCurrentAccount(accounts[0])
          }

          return accounts
        }

        /**
         * Gets a list of derived accounts from Ledger device for selection
         * If a custom derivation path is provided, one account is returned
         * otherwise a minimum of 5 accounts are returned
         */
        async function deriveAccounts(args: ScanAccountsOptions): Promise<Array<Account>> {
          const MAX_ZERO_BALANCE_ACCOUNTS = 5

          setCurrentChain(args.chainId)

          const provider = new JsonRpcProvider(currentChain.rpcUrl)

          // Only return exact account from custom derivation
          if (args.derivationPath !== LEDGER_LIVE_PATH && args.derivationPath !== LEDGER_LEGACY_PATH) {
            const account = await deriveAccount({ ...args, provider })
            return [account]
          }

          const accounts = []

          let zeroBalanceAccounts = 0
          let index = 0

          // Iterates until 0 balance account, then add 4 more 0 balance accounts after
          while (zeroBalanceAccounts < MAX_ZERO_BALANCE_ACCOUNTS) {
            const account = await deriveAccount({
              derivationPath:
                args.derivationPath === LEDGER_LIVE_PATH
                  ? `${args.derivationPath}/${index}'/0/0`
                  : `${args.derivationPath}/${index}`,
              provider,
              asset: args.asset,
            })
            accounts.push(account)

            if (account.balance.value.isZero()) {
              zeroBalanceAccounts++
            } else {
              zeroBalanceAccounts = 0
            }

            index++
          }

          return accounts
        }

        // Gets derived account from Ledger device for selection in Web3-Onboard
        async function deriveAccount(args: {
          derivationPath: string
          provider: InstanceType<typeof JsonRpcProvider>
          asset: Asset
        }): Promise<Account> {
          const { address } = await ledgerSdk.getAddress(args.derivationPath)
          const balance = await args.provider.getBalance(address)

          return {
            derivationPath: args.derivationPath,
            address,
            balance: {
              asset: args.asset.label,
              value: BigNumber.from(balance),
            },
          }
        }

        return {
          provider: eip1193Provider,
        }
      },
    }
  }
}

const enum LedgerErrorCode {
  REJECTED = '6985',
}

// Promisified Ledger SDK
async function getLedgerSdk() {
  const { DeviceActionStatus, DeviceManagementKitBuilder } = await import('@ledgerhq/device-management-kit')
  const { webHidTransportFactory, webHidIdentifier } = await import('@ledgerhq/device-transport-kit-web-hid')
  const { SignerEthBuilder } = await import('@ledgerhq/device-signer-kit-ethereum')
  const { makeError } = await import('ethers')
  const { default: get } = await import('lodash/get')
  const { lastValueFrom } = await import('rxjs')

  // Get connected device and create signer
  const dmk = new DeviceManagementKitBuilder().addTransport(webHidTransportFactory).build()
  const device = await lastValueFrom(dmk.startDiscovering({ transport: webHidIdentifier }))
  const sessionId = await dmk.connect({ device })
  const signer = new SignerEthBuilder({ dmk, sessionId }).build()

  function mapOutput<T>(actionState: DeviceActionState<T, unknown, unknown>): T {
    switch (actionState.status) {
      case DeviceActionStatus.Completed: {
        return actionState.output
      }
      case DeviceActionStatus.Error: {
        const errorCode = get(actionState.error, 'originalError.errorCode')
        const isRejection = errorCode === LedgerErrorCode.REJECTED

        if (!isRejection) {
          throw actionState.error
        }

        // Ethers error for user rejection
        throw makeError('user rejected action', 'ACTION_REJECTED', {
          action: 'unknown',
          reason: 'rejected',
          info: actionState,
        })
      }
      default: {
        throw new Error(`Device ${actionState.status}`)
      }
    }
  }

  return {
    disconnect: async (): Promise<void> => {
      return dmk.disconnect({ sessionId })
    },
    getAddress: async (derivationPath: string): Promise<GetAddressDAOutput> => {
      const actionState = await lastValueFrom(signer.getAddress(derivationPath, { checkOnDevice: false }).observable)
      return mapOutput(actionState)
    },
    signMessage: async (derivationPath: string, message: string | Uint8Array): Promise<SignPersonalMessageDAOutput> => {
      const actionState = await lastValueFrom(signer.signMessage(derivationPath, message).observable)
      return mapOutput(actionState)
    },
    signTransaction: async (derivationPath: string, transaction: Uint8Array): Promise<SignTransactionDAOutput> => {
      const actionState = await lastValueFrom(signer.signTransaction(derivationPath, transaction).observable)
      return mapOutput(actionState)
    },
    signTypedData: async (derivationPath: string, typedData: TypedData): Promise<SignTypedDataDAOutput> => {
      const actionState = await lastValueFrom(signer.signTypedData(derivationPath, typedData).observable)
      return mapOutput(actionState)
    },
  }
}
</file>

<file path="src/services/private-key-module/icon.ts">
const icon = `<svg width="100%" height="100%" viewBox="0 0 65 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3337 7C18.4255 7 17.6893 7.73621 17.6893 8.64436V11.9999H14.334C13.4258 11.9999 12.6896 12.7361 12.6896 13.6443V16.9999H16.0452C16.9534 16.9999 17.6896 16.2637 17.6896 15.3556V12H47.6893V15.3556C47.6893 16.2637 48.4255 16.9999 49.3337 16.9999H52.689V46.9999H56.0447C56.9528 46.9999 57.689 46.2637 57.689 45.3555V18.6442C57.689 17.7361 56.9528 16.9999 56.0447 16.9999H52.6893V13.6443C52.6893 12.7361 51.9531 11.9999 51.0449 11.9999H47.6894V8.64436C47.6894 7.73621 46.9532 7 46.045 7H19.3337ZM47.6893 48.6444C47.6893 47.7363 48.4255 47.0001 49.3337 47.0001H52.6893V50.3557C52.6893 51.2639 51.9531 52.0001 51.0449 52.0001H47.6894V55.3556C47.6894 56.2638 46.9532 57 46.045 57H19.3337C18.4255 57 17.6893 56.2638 17.6893 55.3556V52.0001H14.334C13.4258 52.0001 12.6896 51.2639 12.6896 50.3557V47.0001H16.0452C16.9534 47.0001 17.6896 47.7363 17.6896 48.6444V52H47.6893V48.6444ZM9.33382 16.9999C8.42566 16.9999 7.68945 17.7361 7.68945 18.6442V45.3555C7.68945 46.2637 8.42566 46.9999 9.33382 46.9999H12.6895V16.9999H9.33382ZM36.8004 27.248C36.8004 28.9337 35.7858 30.3824 34.3339 31.0168V40.403C34.3339 40.857 33.9658 41.2252 33.5117 41.2252H31.8673C31.4133 41.2252 31.0452 40.857 31.0452 40.403V31.0168C29.5932 30.3825 28.5786 28.9337 28.5786 27.248C28.5786 24.9776 30.4191 23.1371 32.6895 23.1371C34.9599 23.1371 36.8004 24.9776 36.8004 27.248Z" style="fill: var(--color-text-primary, #000)"/>
</svg>`

export default icon
</file>

<file path="src/services/private-key-module/index.ts">
import { JsonRpcProvider, Wallet } from 'ethers'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type WalletInit, createEIP1193Provider } from '@web3-onboard/common'
import { getRpcServiceUrl } from '@/hooks/wallets/web3'
import pkPopupStore from './pk-popup-store'
import { numberToHex } from '@/utils/hex'

export const PRIVATE_KEY_MODULE_LABEL = 'Private key'

async function getPrivateKey() {
  const savedKey = pkPopupStore.getStore()?.privateKey
  if (savedKey) return savedKey

  pkPopupStore.setStore({
    isOpen: true,
    privateKey: '',
  })

  return new Promise<string>((resolve) => {
    const unsubscribe = pkPopupStore.subscribe(() => {
      unsubscribe()
      resolve(pkPopupStore.getStore()?.privateKey ?? '')
    })
  })
}

let currentChainId = ''
let currentRpcUri = ''

const PrivateKeyModule = (chainId: ChainInfo['chainId'], rpcUri: ChainInfo['rpcUri']): WalletInit => {
  currentChainId = chainId
  currentRpcUri = getRpcServiceUrl(rpcUri)

  return () => {
    return {
      label: PRIVATE_KEY_MODULE_LABEL,
      getIcon: async () => (await import('./icon')).default,
      getInterface: async () => {
        const privateKey = await getPrivateKey()
        if (!privateKey) {
          throw new Error('You rejected the connection')
        }

        let provider: JsonRpcProvider
        let wallet: Wallet
        const chainChangedListeners = new Set<(chainId: string) => void>()

        const updateProvider = () => {
          console.log('[Private key signer] Updating provider to chainId', currentChainId, currentRpcUri)
          provider?.destroy()
          provider = new JsonRpcProvider(currentRpcUri, Number(currentChainId), { staticNetwork: true })
          wallet = new Wallet(privateKey, provider)

          setTimeout(() => {
            chainChangedListeners.forEach((listener) => listener(numberToHex(Number(currentChainId))))
          }, 100)
        }

        updateProvider()

        return {
          provider: createEIP1193Provider(
            {
              on: (event: string, listener: (...args: any[]) => void) => {
                if (event === 'accountsChanged') {
                  return
                } else if (event === 'chainChanged') {
                  chainChangedListeners.add(listener)
                } else {
                  provider.on(event, listener)
                }
              },

              request: async (request: { method: string; params: any[] }) => {
                return provider.send(request.method, request.params)
              },

              disconnect: () => {
                pkPopupStore.setStore({
                  isOpen: false,
                  privateKey: '',
                })
              },
            },
            {
              eth_chainId: async () => currentChainId,

              // @ts-ignore
              eth_getCode: async ({ params }) => provider.getCode(params[0], params[1]),
              // @ts-ignore
              eth_accounts: async () => [wallet.address],
              // @ts-ignore
              eth_requestAccounts: async () => [wallet.address],

              eth_call: async ({ params }: { params: any }) => wallet.call(params[0]),

              eth_sendTransaction: async ({ params }) => {
                const tx = await wallet.sendTransaction(params[0] as any)
                return tx.hash // return transaction hash
              },

              personal_sign: async ({ params }) => {
                return wallet.signMessage(params[0])
              },

              eth_signTypedData: async ({ params }) => {
                const [, typedData] = params
                return await wallet.signTypedData(
                  typedData.domain,
                  { [typedData.primaryType]: typedData.types[typedData.primaryType] },
                  typedData.message,
                )
              },

              // @ts-ignore
              eth_signTypedData_v4: async ({ params }) => {
                const [, typedData] = params

                let parsedTypedData
                try {
                  parsedTypedData = JSON.parse(typedData)
                } catch (error: unknown) {
                  if (error instanceof Error) {
                    throw new Error('Failed to parse typedData: ' + error.message)
                  } else {
                    throw new Error('Failed to parse typedData: Unknown error')
                  }
                }

                if (!parsedTypedData || !parsedTypedData.domain || !parsedTypedData.types || !parsedTypedData.message) {
                  throw new Error('Invalid parameters for eth_signTypedData_v4')
                }

                return await wallet.signTypedData(
                  parsedTypedData.domain,
                  { [parsedTypedData.primaryType]: parsedTypedData.types[parsedTypedData.primaryType] },
                  parsedTypedData.message,
                )
              },

              // @ts-ignore
              wallet_switchEthereumChain: async ({ params }) => {
                console.log('[Private key signer] Switching chain', params)
                updateProvider()
              },
            },
          ),
        }
      },
      platforms: ['desktop'],
    }
  }
}

export default PrivateKeyModule
</file>

<file path="src/services/private-key-module/pk-popup-store.ts">
import ExternalStore from '@safe-global/utils/services/ExternalStore'
import { sessionItem } from '@/services/local-storage/session'

type PkModulePopupStore = {
  isOpen: boolean
  privateKey: string
}

const defaultValue = {
  isOpen: false,
  privateKey: '',
}

const STORAGE_KEY = 'privateKeyModulePK'
const pkStorage = sessionItem<PkModulePopupStore>(STORAGE_KEY)

const popupStore = new ExternalStore<PkModulePopupStore>(pkStorage.get() || defaultValue)

popupStore.subscribe(() => {
  pkStorage.set(popupStore.getStore() || defaultValue)
})

export default popupStore
</file>

<file path="src/services/private-key-module/PkModulePopup.tsx">
import type { FormEvent } from 'react'
import { Button, TextField, Typography, Box } from '@mui/material'
import ModalDialog from '@/components/common/ModalDialog'
import pkStore from './pk-popup-store'
const { useStore, setStore } = pkStore

const PkModulePopup = () => {
  const { isOpen, privateKey } = useStore() ?? { isOpen: false, privateKey: '' }

  const onClose = () => {
    setStore({ isOpen: false, privateKey })
  }

  const onSubmit = (e: FormEvent) => {
    e.preventDefault()
    const privateKey = (e.target as unknown as { 'private-key': HTMLInputElement })['private-key'].value

    setStore({
      isOpen: false,
      privateKey,
    })
  }

  return (
    <ModalDialog dialogTitle="Connect with Private Key" onClose={onClose} open={isOpen} sx={{ zIndex: 1400 }}>
      <Box p={2}>
        <Typography variant="body1" gutterBottom mb={3}>
          Enter your signer private key. The key will be saved for the duration of this browser session.
        </Typography>

        <form onSubmit={onSubmit} action="#" method="post">
          <TextField
            type="password"
            label="Private key"
            fullWidth
            required
            name="private-key"
            sx={{ mb: 3 }}
            data-testid="private-key-input"
          />

          <Button data-testid="pk-connect-btn" variant="contained" color="primary" fullWidth type="submit">
            Connect
          </Button>
        </form>
      </Box>
    </ModalDialog>
  )
}

export default PkModulePopup
</file>

<file path="src/services/push-notifications/firebase.ts">
// Be careful what you import here as it will increase the service worker bundle size

import { initializeApp } from 'firebase/app'
import type { FirebaseApp, FirebaseOptions } from 'firebase/app'

export const FIREBASE_IS_PRODUCTION = process.env.NEXT_PUBLIC_IS_PRODUCTION === 'true'

const FIREBASE_VALID_KEY_PRODUCTION = process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY_PRODUCTION || ''
const FIREBASE_VALID_KEY_STAGING = process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY_STAGING
export const FIREBASE_VAPID_KEY = FIREBASE_IS_PRODUCTION ? FIREBASE_VALID_KEY_PRODUCTION : FIREBASE_VALID_KEY_STAGING

export const FIREBASE_OPTIONS = (() => {
  const FIREBASE_OPTIONS_PRODUCTION = process.env.NEXT_PUBLIC_FIREBASE_OPTIONS_PRODUCTION || ''
  const FIREBASE_OPTIONS_STAGING = process.env.NEXT_PUBLIC_FIREBASE_OPTIONS_STAGING || ''
  try {
    return JSON.parse(FIREBASE_IS_PRODUCTION ? FIREBASE_OPTIONS_PRODUCTION : FIREBASE_OPTIONS_STAGING)
  } catch {
    return {}
  }
})()

const isFirebaseOptions = (options: object): options is FirebaseOptions => {
  // At least projectId is required
  return 'projectId' in options && Object.values(options).every(Boolean)
}

export const initializeFirebaseApp = () => {
  if (!isFirebaseOptions(FIREBASE_OPTIONS)) {
    return
  }

  let app: FirebaseApp | undefined

  try {
    app = initializeApp(FIREBASE_OPTIONS)
  } catch (e) {
    console.error('[Firebase] Initialization failed', e)
  }

  return app
}
</file>

<file path="src/services/push-notifications/preferences.ts">
// Be careful what you import here as it will increase the service worker bundle size

import { createStore as createIndexedDb } from 'idb-keyval'

import type { WebhookType } from '@/service-workers/firebase-messaging/webhook-types'

export type PushNotificationPrefsKey = `${string}:${string}`

export enum NotificationsTokenVersion {
  // V1 is the initial version of the notifications token
  V1 = 1,
  // V2 is the version after the migration to the new notification service
  V2 = 2,
}

export type PushNotificationPreferences = {
  [safeKey: PushNotificationPrefsKey]: {
    chainId: string
    safeAddress: string
    preferences: { [_key in WebhookType]: boolean }
  }
}

export const getPushNotificationPrefsKey = (chainId: string, safeAddress: string): PushNotificationPrefsKey => {
  return `${chainId}:${safeAddress}`
}

export const createPushNotificationUuidIndexedDb = () => {
  const DB_NAME = 'notifications-uuid-database'
  const STORE_NAME = 'notifications-uuid-store'

  return createIndexedDb(DB_NAME, STORE_NAME)
}

export const createPushNotificationPrefsIndexedDb = () => {
  const DB_NAME = 'notifications-preferences-database'
  const STORE_NAME = 'notifications-preferences-store'

  return createIndexedDb(DB_NAME, STORE_NAME)
}
</file>

<file path="src/services/push-notifications/tracking.ts">
// Be careful what you import here as it will increase the service worker bundle size

import { createStore as createIndexedDb, update as updateIndexedDb } from 'idb-keyval'
import type { MessagePayload } from 'firebase/messaging/sw'

import { isWebhookEvent, WebhookType } from '@/service-workers/firebase-messaging/webhook-types'

export type NotificationTrackingKey = `${string}:${WebhookType}`

export type NotificationTracking = {
  [chainKey: NotificationTrackingKey]: {
    shown: number
    opened: number
  }
}

export const getNotificationTrackingKey = (chainId: string, type: WebhookType): NotificationTrackingKey => {
  return `${chainId}:${type}`
}

export const parseNotificationTrackingKey = (key: string): { chainId: string; type: WebhookType } => {
  const [chainId, type] = key.split(':') as [string, WebhookType]

  if (!Object.values(WebhookType).includes(type)) {
    throw new Error(`Invalid notification tracking key: ${key}`)
  }

  return {
    chainId,
    type: type as WebhookType,
  }
}

export const createNotificationTrackingIndexedDb = () => {
  const DB_NAME = 'notifications-tracking-database'
  const STORE_NAME = 'notifications-tracking-store'

  return createIndexedDb(DB_NAME, STORE_NAME)
}

export const DEFAULT_WEBHOOK_TRACKING: NotificationTracking[NotificationTrackingKey] = {
  shown: 0,
  opened: 0,
}

export const cacheServiceWorkerPushNotificationTrackingEvent = (
  property: keyof NotificationTracking[NotificationTrackingKey],
  data: MessagePayload['data'],
) => {
  if (!isWebhookEvent(data)) {
    return
  }

  const key = getNotificationTrackingKey(data.chainId, data.type)
  const store = createNotificationTrackingIndexedDb()

  updateIndexedDb<NotificationTracking[NotificationTrackingKey] | undefined>(
    key,
    (notificationCount) => {
      if (notificationCount) {
        return {
          ...notificationCount,
          [property]: (notificationCount[property] ?? 0) + 1,
        }
      }

      return DEFAULT_WEBHOOK_TRACKING
    },
    store,
  ).catch(() => null)
}
</file>

<file path="src/services/safe-apps/AppCommunicator.ts">
import type { RefObject } from 'react'
import type { SDKMessageEvent, MethodToResponse, ErrorResponse, RequestId } from '@safe-global/safe-apps-sdk'
import { getSDKVersion, Methods, MessageFormatter } from '@safe-global/safe-apps-sdk'
import { asError } from '@safe-global/utils/services/exceptions/utils'

type MessageHandler = (
  msg: SDKMessageEvent,
) => void | MethodToResponse[Methods] | ErrorResponse | Promise<MethodToResponse[Methods] | ErrorResponse | void>

type AppCommunicatorConfig = {
  onMessage?: (msg: SDKMessageEvent) => void
  onError?: (error: Error, data: any) => void
}

class AppCommunicator {
  private iframeRef: RefObject<HTMLIFrameElement | null>
  private handlers = new Map<Methods, MessageHandler>()
  private config: AppCommunicatorConfig

  constructor(iframeRef: RefObject<HTMLIFrameElement | null>, config?: AppCommunicatorConfig) {
    this.iframeRef = iframeRef
    this.config = config || {}

    window.addEventListener('message', this.handleIncomingMessage)
  }

  on = (method: Methods, handler: MessageHandler): void => {
    this.handlers.set(method, handler)
  }

  private isValidMessage = (msg: SDKMessageEvent): boolean => {
    if (!msg.data) return false
    if (msg.data.hasOwnProperty('isCookieEnabled')) {
      return true
    }

    const sentFromIframe = this.iframeRef.current?.contentWindow === msg.source
    const knownMethod = Object.values(Methods).includes(msg.data.method)

    // TODO: move it to safe-app Methods types
    const isThemeInfoMethod = (msg.data.method as string) === 'getCurrentTheme'

    return sentFromIframe && (knownMethod || isThemeInfoMethod)
  }

  private canHandleMessage = (msg: SDKMessageEvent): boolean => {
    if (!msg.data) return false

    return Boolean(this.handlers.get(msg.data.method))
  }

  send = (data: unknown, requestId: RequestId, error = false): void => {
    const sdkVersion = getSDKVersion()
    const msg = error
      ? MessageFormatter.makeErrorResponse(requestId, data as string, sdkVersion)
      : MessageFormatter.makeResponse(requestId, data, sdkVersion)

    this.iframeRef.current?.contentWindow?.postMessage(msg, '*')
  }

  handleIncomingMessage = async (msg: SDKMessageEvent): Promise<void> => {
    const validMessage = this.isValidMessage(msg)
    const hasHandler = this.canHandleMessage(msg)

    if (validMessage && hasHandler) {
      const handler = this.handlers.get(msg.data.method)

      this.config?.onMessage?.(msg)

      try {
        // @ts-expect-error Handler existence is checked in this.canHandleMessage
        const response = await handler(msg)

        // If response is not returned, it means the response will be send somewhere else
        if (typeof response !== 'undefined') {
          this.send(response, msg.data.id)
        }
      } catch (e) {
        const error = asError(e)

        this.send(error.message, msg.data.id, true)
        this.config?.onError?.(error, msg.data)
      }
    }
  }

  clear = (): void => {
    window.removeEventListener('message', this.handleIncomingMessage)
    this.handlers.clear()
  }
}

export default AppCommunicator
</file>

<file path="src/services/safe-apps/manifest.ts">
import type { AllowedFeatures, SafeAppDataWithPermissions } from '@/components/safe-apps/types'
import { isRelativeUrl, trimTrailingSlash } from '@/utils/url'
import { SafeAppAccessPolicyTypes } from '@safe-global/safe-gateway-typescript-sdk'

type AppManifestIcon = {
  src: string
  sizes: string
  type?: string
  purpose?: string
}

export type AppManifest = {
  // SPEC: https://developer.mozilla.org/en-US/docs/Web/Manifest
  name: string
  short_name?: string
  description: string
  icons?: AppManifestIcon[]
  iconPath?: string
  safe_apps_permissions?: AllowedFeatures[]
}

const MIN_ICON_WIDTH = 128

const chooseBestIcon = (icons: AppManifestIcon[]): string => {
  const svgIcon = icons.find((icon) => icon?.sizes?.includes('any') || icon?.type === 'image/svg+xml')

  if (svgIcon) {
    return svgIcon.src
  }

  for (const icon of icons) {
    for (const size of icon.sizes.split(' ')) {
      if (Number(size.split('x')[0]) >= MIN_ICON_WIDTH) {
        return icon.src
      }
    }
  }

  return icons[0].src || ''
}

// The icons URL can be any of the following format:
// - https://example.com/icon.png
// - icon.png
// - /icon.png
// This function calculates the absolute URL of the icon taking into account the
// different formats.
const getAppLogoUrl = (appUrl: string, { icons = [], iconPath = '' }: AppManifest) => {
  const iconUrl = icons.length ? chooseBestIcon(icons) : iconPath
  const includesBaseUrl = iconUrl.startsWith('https://')
  if (includesBaseUrl) {
    return iconUrl
  }

  return `${appUrl}${isRelativeUrl(iconUrl) ? '' : '/'}${iconUrl}`
}

const fetchAppManifest = async (appUrl: string, timeout = 5000): Promise<unknown> => {
  const normalizedUrl = trimTrailingSlash(appUrl)
  const manifestUrl = `${normalizedUrl}/manifest.json`

  // A lot of apps are hosted on IPFS and IPFS never times out, so we add our own timeout
  const controller = new AbortController()
  const id = setTimeout(() => controller.abort(), timeout)

  const response = await fetch(manifestUrl, {
    signal: controller.signal,
  })
  clearTimeout(id)

  if (!response.ok) {
    throw new Error(`Failed to fetch manifest from ${manifestUrl}`)
  }

  return response.json()
}

const isAppManifestValid = (json: unknown): json is AppManifest => {
  return (
    json != null &&
    typeof json === 'object' &&
    'name' in json &&
    'description' in json &&
    ('icons' in json || 'iconPath' in json)
  )
}

const fetchSafeAppFromManifest = async (
  appUrl: string,
  currentChainId: string,
): Promise<SafeAppDataWithPermissions> => {
  const normalizedAppUrl = trimTrailingSlash(appUrl)
  const appManifest = await fetchAppManifest(appUrl)

  if (!isAppManifestValid(appManifest)) {
    throw new Error('Invalid Safe App manifest')
  }

  const iconUrl = getAppLogoUrl(normalizedAppUrl, appManifest)

  return {
    // Must satisfy https://docs.djangoproject.com/en/5.0/ref/models/fields/#positiveintegerfield
    id: Math.round(Math.random() * 1e9 + 1e6),
    url: normalizedAppUrl,
    name: appManifest.name,
    description: appManifest.description,
    accessControl: { type: SafeAppAccessPolicyTypes.NoRestrictions },
    tags: [],
    features: [],
    socialProfiles: [],
    developerWebsite: '',
    chainIds: [currentChainId],
    iconUrl,
    safeAppsPermissions: appManifest.safe_apps_permissions || [],
  }
}

export { fetchAppManifest, isAppManifestValid, getAppLogoUrl, fetchSafeAppFromManifest }
</file>

<file path="src/services/safe-apps/track-app-usage-count.ts">
import local from '@/services/local-storage/local'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'

export const APPS_DASHBOARD = 'SafeApps__dashboard'

const TX_COUNT_WEIGHT = 2
const OPEN_COUNT_WEIGHT = 1

export type AppTrackData = {
  [safeAppId: string]: {
    timestamp: number
    openCount: number
    txCount: number
  }
}

export const getAppsUsageData = (): AppTrackData => {
  return local.getItem<AppTrackData>(APPS_DASHBOARD) || {}
}

export const trackSafeAppOpenCount = (id: SafeAppData['id']): void => {
  const trackData = getAppsUsageData()
  const currentOpenCount = trackData[id]?.openCount ?? 0
  const currentTxCount = trackData[id]?.txCount ?? 0

  local.setItem(APPS_DASHBOARD, {
    ...trackData,
    [id]: {
      timestamp: Date.now(),
      openCount: currentOpenCount + 1,
      txCount: currentTxCount,
    },
  })
}

export const trackSafeAppTxCount = (id: SafeAppData['id']): void => {
  const trackData = getAppsUsageData()
  const currentTxCount = trackData[id]?.txCount ?? 0

  local.setItem(APPS_DASHBOARD, {
    ...trackData,
    // The object contains the openCount when we are creating a transaction
    [id]: { ...trackData[id], txCount: currentTxCount + 1 },
  })
}

// https://stackoverflow.com/a/55212064
const normalizeBetweenTwoRanges = (
  val: number,
  minVal: number,
  maxVal: number,
  newMin: number,
  newMax: number,
): number => {
  return newMin + ((val - minVal) * (newMax - newMin)) / (maxVal - minVal)
}

export const rankSafeApps = (safeApps: SafeAppData[]) => {
  const apps = getAppsUsageData()
  const appsWithScore = computeTrackedSafeAppsScore(apps)

  return Object.entries(appsWithScore)
    .sort((a, b) => b[1] - a[1])
    .map((app) => safeApps.find((safeApp) => String(safeApp.id) === app[0]))
    .filter(Boolean) as SafeAppData[]
}

export const computeTrackedSafeAppsScore = (apps: AppTrackData): Record<string, number> => {
  const scoredApps: Record<string, number> = {}

  const sortedByTimestamp = Object.entries(apps).sort((a, b) => {
    return a[1].timestamp - b[1].timestamp
  })

  for (const [idx, app] of Array.from(sortedByTimestamp.entries())) {
    // UNIX Timestamps add too much weight, so we normalize by uniformly distributing them to range [1..2]
    const timeMultiplier = normalizeBetweenTwoRanges(idx, 0, sortedByTimestamp.length, 1, 2)

    scoredApps[app[0]] = (TX_COUNT_WEIGHT * app[1].txCount + OPEN_COUNT_WEIGHT * app[1].openCount) * timeMultiplier
  }

  return scoredApps
}
</file>

<file path="src/services/safe-messages/safeMsgEvents.ts">
import type { RequestId } from '@safe-global/safe-apps-sdk'

import EventBus from '../EventBus'

export enum SafeMsgEvent {
  // Create message
  PROPOSE = 'PROPOSE',
  PROPOSE_FAILED = 'PROPOSE_FAILED',

  // Confirm message
  CONFIRM_PROPOSE = 'CONFIRM_PROPOSE',
  CONFIRM_PROPOSE_FAILED = 'CONFIRM_PROPOSE_FAILED',

  // Dispatched after the backend returns a new message signature
  // Used to clear the pending status of a message
  UPDATED = 'UPDATED',

  // Final signature prepared
  SIGNATURE_PREPARED = 'SIGNATURE_PREPARED',
}

type SafeMessageHash = { messageHash: string }

interface SignedMessageEvents {
  [SafeMsgEvent.PROPOSE]: SafeMessageHash
  [SafeMsgEvent.PROPOSE_FAILED]: SafeMessageHash & { error: Error }
  [SafeMsgEvent.CONFIRM_PROPOSE]: SafeMessageHash
  [SafeMsgEvent.CONFIRM_PROPOSE_FAILED]: SafeMessageHash & { error: Error }
  [SafeMsgEvent.UPDATED]: SafeMessageHash
  [SafeMsgEvent.SIGNATURE_PREPARED]: SafeMessageHash & { requestId?: RequestId; signature: string }
}

const safeMsgEventBus = new EventBus<SignedMessageEvents>()

export const safeMsgDispatch = safeMsgEventBus.dispatch.bind(safeMsgEventBus)

export const safeMsgSubscribe = safeMsgEventBus.subscribe.bind(safeMsgEventBus)

// Log all events
Object.values(SafeMsgEvent).forEach((event: SafeMsgEvent) => {
  safeMsgSubscribe<SafeMsgEvent>(event, (detail) => {
    console.info(`Message ${event} event received`, detail)
  })
})
</file>

<file path="src/services/safe-messages/safeMsgNotifications.ts">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { safeMsgDispatch, SafeMsgEvent } from './safeMsgEvents'

const isMessageFullySigned = (message: MessageItem): message is MessageItem & { preparedSignature: string } => {
  return message.confirmationsSubmitted >= message.confirmationsRequired && !!message.preparedSignature
}

/**
 * Dispatches a notification including the `preparedSignature` of the message if it is fully signed.
 *
 * @param chainId
 * @param safeMessageHash
 * @param onClose
 * @param requestId
 */
export const dispatchPreparedSignature = async (
  message: MessageItem,
  safeMessageHash: string,
  onClose: () => void,
  requestId?: string,
) => {
  if (isMessageFullySigned(message)) {
    safeMsgDispatch(SafeMsgEvent.SIGNATURE_PREPARED, {
      messageHash: safeMessageHash,
      requestId,
      signature: message.preparedSignature,
    })
    onClose()
  }
}
</file>

<file path="src/services/safe-messages/safeMsgSender.ts">
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { proposeSafeMessage, confirmSafeMessage } from '@safe-global/safe-gateway-typescript-sdk'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import type { Eip1193Provider } from 'ethers'

import { safeMsgDispatch, SafeMsgEvent } from './safeMsgEvents'
import {
  generateSafeMessageHash,
  isEIP712TypedData,
  tryOffChainMsgSigning,
} from '@safe-global/utils/utils/safe-messages'
import { normalizeTypedData } from '@safe-global/utils/utils/web3'
import { getAssertedChainSigner } from '@/services/tx/tx-sender/sdk'
import { asError } from '@safe-global/utils/services/exceptions/utils'

export const dispatchSafeMsgProposal = async ({
  provider,
  safe,
  message,
  origin = '',
}: {
  provider: Eip1193Provider
  safe: SafeState
  message: MessageItem['message']
  origin: string | undefined
}): Promise<void> => {
  const messageHash = generateSafeMessageHash(safe, message)

  try {
    const signer = await getAssertedChainSigner(provider)
    const signature = await tryOffChainMsgSigning(signer, safe, message)

    let normalizedMessage = message
    if (isEIP712TypedData(message)) {
      normalizedMessage = normalizeTypedData(message)
    }

    await proposeSafeMessage(safe.chainId, safe.address.value, {
      message: normalizedMessage,
      signature,
      origin,
    })
  } catch (error) {
    safeMsgDispatch(SafeMsgEvent.PROPOSE_FAILED, {
      messageHash,
      error: asError(error),
    })

    throw error
  }

  safeMsgDispatch(SafeMsgEvent.PROPOSE, {
    messageHash,
  })
}

export const dispatchSafeMsgConfirmation = async ({
  provider,
  safe,
  message,
}: {
  provider: Eip1193Provider
  safe: SafeState
  message: MessageItem['message']
}): Promise<void> => {
  const messageHash = generateSafeMessageHash(safe, message)

  try {
    const signer = await getAssertedChainSigner(provider)
    const signature = await tryOffChainMsgSigning(signer, safe, message)

    await confirmSafeMessage(safe.chainId, messageHash, {
      signature,
    })
  } catch (error) {
    safeMsgDispatch(SafeMsgEvent.CONFIRM_PROPOSE_FAILED, {
      messageHash,
      error: asError(error),
    })

    throw error
  }

  safeMsgDispatch(SafeMsgEvent.CONFIRM_PROPOSE, {
    messageHash,
  })
}
</file>

<file path="src/services/safe-wallet-provider/index.ts">
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { TransactionStatus } from '@safe-global/safe-gateway-typescript-sdk'
import type { TransactionReceipt } from 'ethers'
import { numberToHex } from '@/utils/hex'

type SafeInfo = {
  safeAddress: string
  chainId: number
}

type SafeSettings = {
  offChainSigning?: boolean
}

type Capability = {
  [key: string]: unknown
  optional?: boolean
}

type SendCallsParams = {
  version: '1.0'
  id?: string
  from?: `0x${string}`
  chainId: `0x${string}`
  calls: Array<{
    to?: `0x${string}`
    data?: `0x${string}`
    value?: `0x${string}`
    capabilities?: Record<string, Capability>
  }>
  capabilities?: Record<string, Capability>
}

type SendCallsResult = {
  id: string
  capabilities?: Record<string, any>
}

type GetCallsParams = `0x${string}`

type GetCallsResult = {
  version: string
  id: `0x${string}`
  chainId: `0x${string}`
  status: number // See "Status Codes"
  receipts?: Array<{
    logs: TransactionReceipt['logs']
    status: `0x${string}` // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`
    blockNumber: `0x${string}`
    gasUsed: `0x${string}`
    transactionHash: `0x${string}`
  }>
  capabilities?: Record<string, any>
}

type GetCapabilitiesResult = Record<`0x${string}`, Record<string, any>>

export type AppInfo = {
  id?: number
  name: string
  description: string
  url: string
  iconUrl: string
}

export type WalletSDK = {
  signMessage: (message: string, appInfo: AppInfo) => Promise<{ signature?: string }>
  signTypedMessage: (typedData: unknown, appInfo: AppInfo) => Promise<{ signature?: string }>
  send: (
    params: { txs: unknown[]; params: { safeTxGas: number } },
    appInfo: AppInfo,
  ) => Promise<{ safeTxHash: string; txHash?: string }>
  getBySafeTxHash: (safeTxHash: string) => Promise<TransactionDetails>
  showTxStatus: (safeTxHash: string) => void
  switchChain: (chainId: string, appInfo: AppInfo) => Promise<null>
  setSafeSettings: (safeSettings: SafeSettings) => SafeSettings
  proxy: (method: string, params?: Array<any> | Record<string, any>) => Promise<unknown>
  getCreateCallTransaction: (data: string) => {
    to: string
    data: string
    value: '0'
  }
}

interface RpcRequest {
  method: string
  params?: Array<any> | Record<string, any>
}

export enum RpcErrorCode {
  INVALID_PARAMS = -32602,
  USER_REJECTED = 4001,
  UNSUPPORTED_METHOD = 4200,
  UNSUPPORTED_CHAIN = 4901,
}

enum BundleStatus {
  PENDING = 100, // Batch has been received by the wallet but has not completed execution onchain (pending)
  CONFIRMED = 200, // Batch has been included onchain without reverts, receipts array contains info of all calls (confirmed)
  OFFCHAIN_FAILURE = 400, // Batch has not been included onchain and wallet will not retry (offchain failure)
  REVERTED = 500, // Batch reverted completely and only changes related to gas charge may have been included onchain (chain rules failure)
  PARTIALLY_REVERTED = 600, // Batch reverted partially and some changes related to batch calls may have been included onchain (partial chain rules failure)
}

const BundleTxStatuses: Record<TransactionStatus, BundleStatus> = {
  [TransactionStatus.AWAITING_CONFIRMATIONS]: BundleStatus.PENDING,
  [TransactionStatus.AWAITING_EXECUTION]: BundleStatus.PENDING,
  [TransactionStatus.SUCCESS]: BundleStatus.CONFIRMED,
  [TransactionStatus.CANCELLED]: BundleStatus.OFFCHAIN_FAILURE,
  [TransactionStatus.FAILED]: BundleStatus.REVERTED,
}

class RpcError extends Error {
  code: RpcErrorCode

  constructor(code: RpcErrorCode, message: string) {
    super(message)
    this.code = code
  }
}

export class SafeWalletProvider {
  private readonly safe: SafeInfo
  private readonly sdk: WalletSDK
  private submittedTxs = new Map<string, unknown>()

  constructor(safe: SafeInfo, sdk: WalletSDK) {
    this.safe = safe
    this.sdk = sdk
  }

  private async makeRequest(request: RpcRequest, appInfo: AppInfo): Promise<unknown> {
    const { method, params = [] } = request

    switch (method) {
      case 'wallet_switchEthereumChain': {
        return this.wallet_switchEthereumChain(...(params as [{ chainId: string }]), appInfo)
      }

      case 'eth_accounts':
      case 'eth_requestAccounts': {
        return this.eth_accounts()
      }

      case 'net_version':
      case 'eth_chainId': {
        return this.eth_chainId()
      }

      case 'personal_sign': {
        return this.personal_sign(...(params as [string, string]), appInfo)
      }

      case 'eth_sign': {
        return this.eth_sign(...(params as [string, string]), appInfo)
      }

      case 'eth_signTypedData':
      case 'eth_signTypedData_v4': {
        return this.eth_signTypedData(...(params as [string, unknown]), appInfo)
      }

      case 'eth_sendTransaction': {
        const tx = {
          value: '0',
          data: '0x',
          // @ts-ignore
          ...(params[0] as { gas: string | number; to: string }),
        }
        return this.eth_sendTransaction(tx, appInfo)
      }

      case 'eth_getTransactionByHash': {
        return this.eth_getTransactionByHash(...(params as [string]))
      }

      case 'eth_getTransactionReceipt': {
        return this.eth_getTransactionReceipt(...(params as [string]))
      }

      // EIP-5792
      // @see https://eips.ethereum.org/EIPS/eip-5792
      case 'wallet_sendCalls': {
        return this.wallet_sendCalls(...(params as [SendCallsParams]), appInfo)
      }

      case 'wallet_getCallsStatus': {
        return this.wallet_getCallsStatus(...(params as [GetCallsParams]))
      }

      case 'wallet_showCallsStatus': {
        this.wallet_showCallsStatus(...(params as [string]))
        return null
      }

      case 'wallet_getCapabilities': {
        return this.wallet_getCapabilities(...(params as [string]))
      }

      // Safe proprietary methods
      case 'safe_setSettings': {
        return this.safe_setSettings(...(params as [SafeSettings]))
      }

      default: {
        return await this.sdk.proxy(method, params)
      }
    }
  }

  async request(
    id: number,
    request: RpcRequest,
    appInfo: AppInfo,
  ): Promise<
    | {
        jsonrpc: string
        id: number
        result: unknown
      }
    | {
        jsonrpc: string
        id: number
        error: {
          code: number
          message: string
        }
      }
  > {
    try {
      return {
        jsonrpc: '2.0',
        id,
        result: await this.makeRequest(request, appInfo),
      }
    } catch (e) {
      return {
        jsonrpc: '2.0',
        id,
        error: {
          code: -32000,
          message: (e as Error).message,
        },
      }
    }
  }

  // Actual RPC methods

  async wallet_switchEthereumChain({ chainId }: { chainId: string }, appInfo: AppInfo) {
    try {
      await this.sdk.switchChain(chainId, appInfo)
    } catch (e) {
      throw new RpcError(RpcErrorCode.UNSUPPORTED_CHAIN, 'Unsupported chain')
    }
    return null
  }

  async eth_accounts() {
    return [this.safe.safeAddress]
  }

  async eth_chainId() {
    return `0x${this.safe.chainId.toString(16)}`
  }

  async personal_sign(message: string, address: string, appInfo: AppInfo): Promise<string> {
    if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase()) {
      throw new RpcError(RpcErrorCode.INVALID_PARAMS, 'The address or message hash is invalid')
    }

    const response = await this.sdk.signMessage(message, appInfo)
    const signature = 'signature' in response ? response.signature : undefined

    return signature || '0x'
  }

  async eth_sign(address: string, messageHash: string, appInfo: AppInfo): Promise<string> {
    if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase() || !messageHash.startsWith('0x')) {
      throw new RpcError(RpcErrorCode.INVALID_PARAMS, 'The address or message hash is invalid')
    }

    const response = await this.sdk.signMessage(messageHash, appInfo)
    const signature = 'signature' in response ? response.signature : undefined

    return signature || '0x'
  }

  async eth_signTypedData(address: string, typedData: unknown, appInfo: AppInfo): Promise<string> {
    const parsedTypedData = typeof typedData === 'string' ? JSON.parse(typedData) : typedData

    if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase()) {
      throw new RpcError(RpcErrorCode.INVALID_PARAMS, 'The address is invalid')
    }

    const response = await this.sdk.signTypedMessage(parsedTypedData, appInfo)
    const signature = 'signature' in response ? response.signature : undefined
    return signature || '0x'
  }

  async eth_sendTransaction(
    tx: { gas: string | number; to: string; value: string; data: string },
    appInfo: AppInfo,
  ): Promise<string> {
    // Some ethereum libraries might pass the gas as a hex-encoded string
    // We need to convert it to a number because the SDK expects a number and our backend only supports
    // Decimal numbers
    if (typeof tx.gas === 'string' && tx.gas.startsWith('0x')) {
      tx.gas = parseInt(tx.gas, 16)
    }

    const { safeTxHash, txHash } = await this.sdk.send(
      {
        txs: [tx],
        params: { safeTxGas: Number(tx.gas) },
      },
      appInfo,
    )

    if (txHash) return txHash

    // Store fake transaction
    this.submittedTxs.set(safeTxHash, {
      from: this.safe.safeAddress,
      hash: safeTxHash,
      gas: 0,
      gasPrice: '0x00',
      nonce: 0,
      input: tx.data,
      value: tx.value,
      to: tx.to,
      blockHash: null,
      blockNumber: null,
      transactionIndex: null,
    })

    return safeTxHash
  }

  async eth_getTransactionByHash(txHash: string): Promise<TransactionDetails> {
    try {
      const resp = await this.sdk.getBySafeTxHash(txHash)
      txHash = resp.txHash || txHash
    } catch (e) {}

    // Use fake transaction if we don't have a real tx hash
    if (this.submittedTxs.has(txHash)) {
      return this.submittedTxs.get(txHash) as TransactionDetails
    }

    return (await this.sdk.proxy('eth_getTransactionByHash', [txHash])) as Promise<TransactionDetails>
  }

  async eth_getTransactionReceipt(txHash: string): Promise<TransactionReceipt> {
    try {
      const resp = await this.sdk.getBySafeTxHash(txHash)
      txHash = resp.txHash || txHash
    } catch (e) {}
    return this.sdk.proxy('eth_getTransactionReceipt', [txHash]) as Promise<TransactionReceipt>
  }

  // EIP-5792
  // @see https://eips.ethereum.org/EIPS/eip-5792
  async wallet_sendCalls(bundle: SendCallsParams, appInfo: AppInfo): Promise<SendCallsResult> {
    if (bundle.chainId !== numberToHex(this.safe.chainId)) {
      throw new Error(`Safe is not on chain ${this.safe.chainId}`)
    }

    if (bundle.from !== this.safe.safeAddress) {
      throw Error('Invalid from address')
    }

    const txs = bundle.calls.map((call) => {
      if (!call.to && !call.value && !call.data) {
        throw new RpcError(RpcErrorCode.INVALID_PARAMS, 'Invalid call parameters.')
      }
      if (!call.to && !call.value && call.data) {
        // If only data is provided the call is a contract deployment
        // We have to use the CreateCall lib
        return this.sdk.getCreateCallTransaction(call.data)
      }
      if (!call.to) {
        // For all non-contract deployments we need a to address
        throw new RpcError(RpcErrorCode.INVALID_PARAMS, 'Invalid call parameters.')
      }
      return {
        to: call.to,
        data: call.data ?? '0x',
        value: call.value ?? '0',
      }
    })
    const { safeTxHash } = await this.sdk.send(
      {
        txs,
        params: { safeTxGas: 0 },
      },
      appInfo,
    )

    return { id: safeTxHash }
  }
  async wallet_getCallsStatus(safeTxHash: GetCallsParams): Promise<GetCallsResult> {
    let tx: TransactionDetails | undefined

    try {
      tx = await this.sdk.getBySafeTxHash(safeTxHash)
    } catch (e) {}

    if (!tx) {
      throw new Error('Transaction not found')
    }

    const result: GetCallsResult = {
      version: '1.0',
      id: safeTxHash,
      chainId: numberToHex(this.safe.chainId),
      status: BundleTxStatuses[tx.txStatus],
    }

    if (!tx.txHash) {
      return result
    }

    const receipt = await (this.sdk.proxy('eth_getTransactionReceipt', [
      tx.txHash,
    ]) as Promise<TransactionReceipt | null>)
    if (!receipt) {
      return result
    }

    const calls = tx.txData?.dataDecoded?.parameters?.[0].valueDecoded?.length ?? 1

    // Typed as number; is hex
    const blockNumber = Number(receipt.blockNumber)
    const gasUsed = Number(receipt.gasUsed)

    result.receipts = Array.from({ length: calls }, () => ({
      logs: receipt.logs,
      status: numberToHex(tx.txStatus === TransactionStatus.SUCCESS ? 1 : 0),
      blockHash: receipt.blockHash as `0x${string}`,
      blockNumber: numberToHex(blockNumber),
      gasUsed: numberToHex(gasUsed),
      transactionHash: tx.txHash as `0x${string}`,
    }))

    return result
  }
  async wallet_showCallsStatus(txHash: string): Promise<null> {
    this.sdk.showTxStatus(txHash)
    return null
  }

  async wallet_getCapabilities(walletAddress: string): Promise<GetCapabilitiesResult> {
    if (walletAddress === this.safe.safeAddress) {
      return {
        [`0x${this.safe.chainId.toString(16)}`]: {
          atomicBatch: {
            supported: true,
          },
        },
      }
    }
    return {}
  }

  // Safe proprietary methods
  async safe_setSettings(settings: SafeSettings): Promise<SafeSettings> {
    return this.sdk.setSafeSettings(settings)
  }
}
</file>

<file path="src/services/safe-wallet-provider/notifications.ts">
import { BRAND_NAME } from '@/config/constants'
import type { AppInfo } from '.'

export const showNotification = (title: string, options?: NotificationOptions) => {
  if (Notification.permission !== 'granted' || document.hasFocus()) {
    return
  }

  const notification = new Notification(title, {
    icon: '/images/safe-logo-green.png',
    ...options,
  })

  notification.onclick = () => {
    window.focus()
    notification.close()
  }

  setTimeout(() => {
    notification.close()
  }, 5_000)
}

export const NotificationMessages: Record<
  string,
  (appInfo: AppInfo) => { title: string; options: NotificationOptions }
> = {
  SIGNATURE_REQUEST: (appInfo: AppInfo) => ({
    title: 'Signature request',
    options: {
      body: `${appInfo.name} wants you to sign a message. Open the ${BRAND_NAME} to continue.`,
    },
  }),
  TRANSACTION_REQUEST: (appInfo: AppInfo) => ({
    title: 'Transaction request',
    options: {
      body: `${appInfo.name} wants to submit a transaction. Open the ${BRAND_NAME} to continue.`,
    },
  }),
}
</file>

<file path="src/services/safe-wallet-provider/useSafeWalletProvider.tsx">
import { useContext, useEffect, useMemo, useRef, useState } from 'react'
import { useRouter } from 'next/router'

import { RpcErrorCode } from '.'
import type { AppInfo, WalletSDK } from '.'
import { SafeWalletProvider } from '.'
import useSafeInfo from '@/hooks/useSafeInfo'
import { TxModalContext } from '@/components/tx-flow'
import { SignMessageFlow } from '@/components/tx-flow/flows'
import { safeMsgSubscribe, SafeMsgEvent } from '@/services/safe-messages/safeMsgEvents'
import { SafeAppsTxFlow } from '@/components/tx-flow/flows'
import { TxEvent, txSubscribe } from '@/services/tx/txEvents'
import { Methods } from '@safe-global/safe-apps-sdk'
import type { SafeSettings } from '@safe-global/safe-apps-sdk'
import type { TypedData } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { useWeb3ReadOnly } from '@/hooks/wallets/web3'
import { getTransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { Interface, getAddress } from 'ethers'
import { AppRoutes } from '@/config/routes'
import useChains, { useCurrentChain } from '@/hooks/useChains'
import { NotificationMessages, showNotification } from './notifications'
import { SignMessageOnChainFlow } from '@/components/tx-flow/flows'
import { useAppSelector } from '@/store'
import { selectOnChainSigning } from '@/store/settingsSlice'
import { isOffchainEIP1271Supported } from '@safe-global/utils/utils/safe-messages'
import { getCreateCallContractDeployment } from '@safe-global/utils/services/contracts/deployments'

export const useTxFlowApi = (chainId: string, safeAddress: string): WalletSDK | undefined => {
  const { safe } = useSafeInfo()
  const currentChain = useCurrentChain()
  const { setTxFlow } = useContext(TxModalContext)
  const web3ReadOnly = useWeb3ReadOnly()
  const router = useRouter()
  const { configs } = useChains()
  const pendingTxs = useRef<Record<string, string>>({})

  const onChainSigning = useAppSelector(selectOnChainSigning)
  const [settings, setSettings] = useState<SafeSettings>({
    offChainSigning: true,
  })

  useEffect(() => {
    const unsubscribe = txSubscribe(TxEvent.PROCESSING, async ({ txId, txHash }) => {
      if (!txId) return
      pendingTxs.current[txId] = txHash
    })
    return unsubscribe
  }, [])

  return useMemo<WalletSDK | undefined>(() => {
    if (!chainId || !safeAddress) return

    const signMessage = (
      message: string | TypedData,
      appInfo: AppInfo,
      method: Methods.signMessage | Methods.signTypedMessage,
    ): Promise<{ signature: string }> => {
      const id = Math.random().toString(36).slice(2)
      const shouldSignOffChain =
        isOffchainEIP1271Supported(safe, currentChain) && !onChainSigning && settings.offChainSigning

      const { title, options } = NotificationMessages.SIGNATURE_REQUEST(appInfo)
      showNotification(title, options)

      return new Promise((resolve, reject) => {
        let onClose = () => {
          reject({
            code: RpcErrorCode.USER_REJECTED,
            message: 'User rejected signature',
          })
          unsubscribe()
        }

        const unsubscribeSignaturePrepared = safeMsgSubscribe(
          SafeMsgEvent.SIGNATURE_PREPARED,
          ({ requestId, signature }) => {
            if (requestId === id) {
              resolve({ signature })
              unsubscribe()
            }
          },
        )

        const unsubscribe = () => {
          onClose = () => {}
          unsubscribeSignaturePrepared()
        }

        if (shouldSignOffChain) {
          setTxFlow(
            <SignMessageFlow
              logoUri={appInfo.iconUrl}
              name={appInfo.name}
              origin={appInfo.url}
              message={message}
              requestId={id}
            />,
            onClose,
          )
        } else {
          setTxFlow(<SignMessageOnChainFlow props={{ requestId: id, message, method }} />, onClose)
        }
      })
    }

    return {
      async signMessage(message, appInfo) {
        return await signMessage(message, appInfo, Methods.signMessage)
      },

      async signTypedMessage(typedData, appInfo) {
        return await signMessage(typedData as TypedData, appInfo, Methods.signTypedMessage)
      },

      async send(params: { txs: any[]; params: { safeTxGas: number } }, appInfo) {
        const id = Math.random().toString(36).slice(2)

        const transactions = params.txs.map(({ to, value, data }) => {
          return {
            to: getAddress(to),
            value: BigInt(value).toString(),
            data,
          }
        })

        const { title, options } = NotificationMessages.TRANSACTION_REQUEST(appInfo)
        showNotification(title, options)

        return new Promise((resolve, reject) => {
          let onClose = () => {
            reject({
              code: RpcErrorCode.USER_REJECTED,
              message: 'User rejected transaction',
            })
          }

          const onSubmit = (txId: string, safeTxHash: string) => {
            const txHash = pendingTxs.current[txId]
            onClose = () => {}
            resolve({ safeTxHash, txHash })
          }

          setTxFlow(
            <SafeAppsTxFlow
              data={{
                appId: undefined,
                app: appInfo,
                requestId: id,
                txs: transactions,
                params: params.params,
              }}
              onSubmit={onSubmit}
            />,
            onClose,
          )
        })
      },

      async getBySafeTxHash(safeTxHash) {
        return getTransactionDetails(chainId, safeTxHash)
      },

      async switchChain(hexChainId, appInfo) {
        const decimalChainId = parseInt(hexChainId, 16).toString()
        if (decimalChainId === chainId) {
          return null
        }

        const cfg = configs.find((c) => c.chainId === chainId)
        if (!cfg) {
          throw new Error(`Chain ${chainId} not supported`)
        }

        if (confirm(`${appInfo.name} wants to switch to ${cfg.shortName}. Do you want to continue?`)) {
          router.push({
            pathname: AppRoutes.index,
            query: {
              chain: cfg.shortName,
            },
          })
        }

        return null
      },

      async showTxStatus(safeTxHash) {
        router.push({
          pathname: AppRoutes.transactions.tx,
          query: {
            safe: router.query.safe,
            id: safeTxHash,
          },
        })
      },

      setSafeSettings(newSettings) {
        const res = {
          ...settings,
          ...newSettings,
        }

        setSettings(newSettings)

        return res
      },

      async proxy(method, params) {
        return web3ReadOnly?.send(method, params ?? [])
      },

      getCreateCallTransaction(data) {
        const createCallDeployment = currentChain
          ? getCreateCallContractDeployment(currentChain, safe.version)
          : undefined
        if (!createCallDeployment) {
          throw new Error('No CreateCall deployment found for chain and safe version')
        }
        const createCallAddress = createCallDeployment.networkAddresses[safe.chainId]

        const createCallInterface = new Interface(createCallDeployment.abi)
        const callData = createCallInterface.encodeFunctionData('performCreate', ['0', data])

        return {
          to: createCallAddress,
          data: callData,
          value: '0',
        }
      },
    }
  }, [chainId, safeAddress, safe, currentChain, onChainSigning, settings, setTxFlow, configs, router, web3ReadOnly])
}

const useSafeWalletProvider = (): SafeWalletProvider | undefined => {
  const { safe, safeAddress } = useSafeInfo()
  const { chainId } = safe

  const txFlowApi = useTxFlowApi(chainId, safeAddress)

  return useMemo(() => {
    if (!safeAddress || !chainId || !txFlowApi) return

    return new SafeWalletProvider(
      {
        safeAddress,
        chainId: Number(chainId),
      },
      txFlowApi,
    )
  }, [safeAddress, chainId, txFlowApi])
}

export default useSafeWalletProvider
</file>

<file path="src/services/siwe/utils/index.ts">
const getSignableMessage = (address: string, chainId: bigint, nonce: string) => {
  const message = {
    domain: window.location.host,
    address,
    statement:
      'By signing, you are agreeing to store this data in the Safe infrastructure. This does not initiate a transaction or cost any fees.',
    uri: window.location.origin,
    version: '1',
    chainId: Number(chainId),
    nonce,
    issuedAt: new Date(),
  }
  const signableMessage = `${message.domain} wants you to sign in with your Ethereum account:
${message.address}

${message.statement}

URI: ${message.uri}
Version: ${message.version}
Chain ID: ${message.chainId}
Nonce: ${message.nonce}
Issued At: ${message.issuedAt.toISOString()}`

  return signableMessage
}

export { getSignableMessage }
</file>

<file path="src/services/siwe/useSiwe.tsx">
import { useWeb3 } from '@/hooks/wallets/web3'
import { useAuthVerifyV1Mutation, useLazyAuthGetNonceV1Query } from '@safe-global/store/gateway/AUTO_GENERATED/auth'
import { useCallback } from 'react'
import { getSignableMessage } from './utils'
import { logError } from '../exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import useWallet from '@/hooks/wallets/useWallet'
import { isPKWallet } from '@/utils/wallets'

export const useSiwe = () => {
  const wallet = useWallet()
  const provider = useWeb3()
  const [fetchNonce] = useLazyAuthGetNonceV1Query()
  const [verifyAuthMutation] = useAuthVerifyV1Mutation()

  const signIn = useCallback(async () => {
    if (!provider || !wallet) return

    try {
      const { data } = await fetchNonce()
      if (!data) return

      const [network, signer] = await Promise.all([provider.getNetwork(), provider.getSigner()])
      const signableMessage = getSignableMessage(signer.address, network.chainId, data.nonce)

      let signature
      // Using the signer.signMessage hexlifies the message which doesn't work with the personal_sign of the PK module
      if (isPKWallet(wallet)) {
        signature = await provider.send('personal_sign', [signableMessage, signer.address.toLowerCase()])
      } else {
        signature = await signer.signMessage(signableMessage)
      }

      return verifyAuthMutation({ siweDto: { message: signableMessage, signature } })
    } catch (error) {
      logError(ErrorCodes._640)
    }
  }, [fetchNonce, provider, verifyAuthMutation, wallet])

  return {
    signIn,
  }
}
</file>

<file path="src/services/tracking/abTesting.ts">
/**
 * Holds current A/B test identifiers.
 */
export const enum AbTest {}

let _abTest: AbTest | null = null

export const setAbTest = (abTest: AbTest): void => {
  _abTest = abTest
}

export const getAbTest = (): AbTest | null => {
  return _abTest
}
</file>

<file path="src/services/tracking/useAbTesting.ts">
import { useEffect, useMemo } from 'react'

import useLocalStorage from '@/services/local-storage/useLocalStorage'
import { setAbTest } from './abTesting'
import type { AbTest } from './abTesting'

const useABTesting = (abTest: AbTest): boolean => {
  // Fallback AB test value if no `localStorage` exists
  const coinToss = useMemo(() => {
    return Math.random() >= 0.5
  }, [])

  const [isB = coinToss, setIsB] = useLocalStorage<boolean>(`AB_${abTest}`)

  // Save fallback value to `localStorage` if no cache exists
  useEffect(() => {
    setIsB((prev) => prev ?? coinToss)
  }, [coinToss, isB, setIsB])

  // Store AB test value in GTM
  useEffect(() => {
    if (isB) {
      setAbTest(abTest)
    }
  }, [abTest, isB])

  return isB
}

export default useABTesting
</file>

<file path="src/services/transactions/index.tests.ts">
import { getTimezone } from '.'

describe('getTimezone', () => {
  it('should return timezone', () => {
    const result = getTimezone()

    expect(result).toBeDefined()
  })
})
</file>

<file path="src/services/transactions/index.ts">
import { getModuleTransactions, getTransactionHistory } from '@safe-global/safe-gateway-typescript-sdk'

export const getTimezone = () => Intl.DateTimeFormat().resolvedOptions().timeZone

export const getTxHistory = (
  chainId: string,
  safeAddress: string,
  hideUntrustedTxs: boolean,
  hideImitationTxs: boolean,
  pageUrl?: string,
) => {
  return getTransactionHistory(
    chainId,
    safeAddress,
    {
      timezone: getTimezone(), // used for grouping txs by date
      // Untrusted and imitation txs are filtered together in the UI
      trusted: hideUntrustedTxs, // if false, include transactions marked untrusted in the UI
      imitation: !hideImitationTxs, // If true, include transactions marked imitation in the UI
    },
    pageUrl,
  )
}

/**
 * Fetch the ID of a module transaction for the given transaction hash
 */
export const getModuleTransactionId = async (chainId: string, safeAddress: string, txHash: string) => {
  const { results } = await getModuleTransactions(chainId, safeAddress, { transaction_hash: txHash })
  if (results.length === 0) throw new Error('module transaction not found')
  return results[0].transaction.id
}
</file>

<file path="src/services/tx/tx-sender/create.ts">
import { getReadOnlyGnosisSafeContract } from '@/services/contracts/safeContracts'
import { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'
import type { ChainInfo, TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { getTransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import type { AddOwnerTxParams, RemoveOwnerTxParams, SwapOwnerTxParams } from '@safe-global/protocol-kit'
import type { MetaTransactionData, SafeTransaction, SafeTransactionDataPartial } from '@safe-global/safe-core-sdk-types'
import extractTxInfo from '../extractTxInfo'
import { getAndValidateSafeSDK } from './sdk'

/**
 * Create a transaction from raw params
 */
export const createTx = async (txParams: SafeTransactionDataPartial, nonce?: number): Promise<SafeTransaction> => {
  if (nonce !== undefined) txParams = { ...txParams, nonce }
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createTransaction({ transactions: [txParams] })
}

/**
 * Create a multiSendCallOnly transaction from an array of MetaTransactionData and options
 * If only one tx is passed it will be created without multiSend and without onlyCalls.
 */
export const createMultiSendCallOnlyTx = async (txParams: MetaTransactionData[]): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createTransaction({ transactions: txParams, onlyCalls: true })
}

export const createRemoveOwnerTx = async (txParams: RemoveOwnerTxParams): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createRemoveOwnerTx(txParams)
}

export const createAddOwnerTx = async (
  chain: ChainInfo,
  isDeployed: boolean,
  txParams: AddOwnerTxParams,
): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  if (isDeployed) return safeSDK.createAddOwnerTx(txParams)

  const safeVersion = await safeSDK.getContractVersion()

  const contract = await getReadOnlyGnosisSafeContract(chain, safeVersion)
  // @ts-ignore
  const data = contract.encode('addOwnerWithThreshold', [txParams.ownerAddress, txParams.threshold])

  const tx = {
    to: await safeSDK.getAddress(),
    value: '0',
    data,
  }

  return safeSDK.createTransaction({
    transactions: [tx],
  })
}

export const createSwapOwnerTx = async (
  chain: ChainInfo,
  isDeployed: boolean,
  txParams: SwapOwnerTxParams,
): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  if (isDeployed) return safeSDK.createSwapOwnerTx(txParams)

  const safeVersion = await safeSDK.getContractVersion()

  const contract = await getReadOnlyGnosisSafeContract(chain, safeVersion)
  // @ts-ignore SwapOwnerTxParams is a union type and the method expects a specific one
  const data = contract.encode('swapOwner', [SENTINEL_ADDRESS, txParams.oldOwnerAddress, txParams.newOwnerAddress])

  const tx = {
    to: await safeSDK.getAddress(),
    value: '0',
    data,
  }

  return safeSDK.createTransaction({
    transactions: [tx],
  })
}

export const createUpdateThresholdTx = async (threshold: number): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createChangeThresholdTx(threshold)
}

export const createRemoveModuleTx = async (moduleAddress: string): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createDisableModuleTx(moduleAddress)
}

export const createRemoveGuardTx = async (): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createDisableGuardTx()
}

/**
 * Create a rejection tx
 */
export const createRejectTx = async (nonce: number): Promise<SafeTransaction> => {
  const safeSDK = getAndValidateSafeSDK()
  return safeSDK.createRejectionTransaction(nonce)
}

/**
 * Prepare a SafeTransaction from Client Gateway / Tx Queue
 */
export const createExistingTx = async (
  chainId: string,
  txId: string,
  txDetails?: TransactionDetails,
): Promise<SafeTransaction> => {
  // Get the tx details from the backend if not provided
  txDetails = txDetails || (await getTransactionDetails(chainId, txId))

  // Convert them to the Core SDK tx params
  const { txParams, signatures } = extractTxInfo(txDetails)

  // Create a tx and add pre-approved signatures
  const safeTx = await createTx(txParams, txParams.nonce)
  Object.entries(signatures).forEach(([signer, data]) => {
    safeTx.addSignature({
      signer,
      data,
      staticPart: () => data,
      dynamicPart: () => '',
      isContractSignature: false,
    })
  })

  return safeTx
}
</file>

<file path="src/services/tx/tx-sender/dispatch.ts">
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { isMultisigExecutionInfo } from '@/utils/transaction-guards'
import { isEthSignWallet, isSmartContractWallet } from '@/utils/wallets'
import type { MultiSendCallOnlyContractImplementationType } from '@safe-global/protocol-kit'
import { type ChainInfo, relayTransaction, type TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'

import type {
  SafeSignature,
  SafeTransaction,
  Transaction,
  TransactionOptions,
  TransactionResult,
} from '@safe-global/safe-core-sdk-types'
import { didRevert } from '@/utils/ethers-utils'
import { type SpendingLimitTxParams } from '@/components/tx-flow/flows/TokenTransfer/ReviewSpendingLimitTx'
import { getSpendingLimitContract } from '@/services/contracts/spendingLimitContracts'
import type { ContractTransactionResponse, Eip1193Provider, Overrides, TransactionResponse } from 'ethers'
import type { RequestId } from '@safe-global/safe-apps-sdk'
import proposeTx from '../proposeTransaction'
import { txDispatch, TxEvent } from '../txEvents'
import { waitForRelayedTx } from '@/services/tx/txMonitor'
import { getReadOnlyCurrentGnosisSafeContract } from '@/services/contracts/safeContracts'
import {
  getAndValidateSafeSDK,
  getSafeSDKWithSigner,
  tryOffChainTxSigning,
  getUncheckedSigner,
  prepareTxExecution,
  prepareApproveTxHash,
} from './sdk'
import { createWeb3, getUserNonce } from '@/hooks/wallets/web3'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import chains from '@/config/chains'
import { createExistingTx } from './create'

import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'

/**
 * Propose a transaction
 * If txId is passed, it's an existing tx being signed
 */
export const dispatchTxProposal = async ({
  chainId,
  safeAddress,
  sender,
  safeTx,
  txId,
  origin,
}: {
  chainId: string
  safeAddress: string
  sender: string
  safeTx: SafeTransaction
  txId?: string
  origin?: string
}): Promise<TransactionDetails> => {
  const safeSDK = getAndValidateSafeSDK()
  const safeTxHash = await safeSDK.getTransactionHash(safeTx)

  let proposedTx: TransactionDetails | undefined
  try {
    proposedTx = await proposeTx(chainId, safeAddress, sender, safeTx, safeTxHash, origin)
  } catch (error) {
    if (txId) {
      txDispatch(TxEvent.SIGNATURE_PROPOSE_FAILED, { txId, error: asError(error) })
    } else {
      txDispatch(TxEvent.PROPOSE_FAILED, { error: asError(error) })
    }
    throw error
  }

  // Dispatch a success event only if the tx is signed
  // Unsigned txs are proposed only temporarily and won't appear in the queue
  if (safeTx.signatures.size > 0) {
    txDispatch(txId ? TxEvent.SIGNATURE_PROPOSED : TxEvent.PROPOSED, {
      txId: proposedTx.txId,
      signerAddress: txId ? sender : undefined,
      nonce: safeTx.data.nonce,
    })
  }

  return proposedTx
}

/**
 * Sign a transaction
 */
export const dispatchTxSigning = async (
  safeTx: SafeTransaction,
  provider: Eip1193Provider,
  txId?: string,
): Promise<SafeTransaction> => {
  const sdk = await getSafeSDKWithSigner(provider)

  let signedTx: SafeTransaction | undefined
  try {
    signedTx = await tryOffChainTxSigning(safeTx, sdk)
  } catch (error) {
    txDispatch(TxEvent.SIGN_FAILED, {
      txId,
      error: asError(error),
    })
    throw error
  }

  txDispatch(TxEvent.SIGNED, { txId })

  return signedTx
}

// We have to manually sign because sdk.signTransaction doesn't support proposers
export const dispatchProposerTxSigning = async (safeTx: SafeTransaction, wallet: ConnectedWallet) => {
  const sdk = await getSafeSDKWithSigner(wallet.provider)

  let signature: SafeSignature
  if (isEthSignWallet(wallet)) {
    const txHash = await sdk.getTransactionHash(safeTx)
    signature = await sdk.signHash(txHash)
  } else {
    signature = await sdk.signTypedData(safeTx)
  }

  safeTx.addSignature(signature)

  return safeTx
}

const ZK_SYNC_ON_CHAIN_SIGNATURE_GAS_LIMIT = 4_500_000

/**
 * On-Chain sign a transaction
 */
export const dispatchOnChainSigning = async (
  safeTx: SafeTransaction,
  txId: string,
  provider: Eip1193Provider,
  chainId: SafeState['chainId'],
  signerAddress: string,
  safeAddress: string,
  isNestedSafe: boolean,
) => {
  const sdk = await getSafeSDKWithSigner(provider)
  const safeTxHash = await sdk.getTransactionHash(safeTx)
  const eventParams = { txId, nonce: safeTx.data.nonce }

  const options =
    chainId === chains.zksync || chainId === chains.lens
      ? { gasLimit: ZK_SYNC_ON_CHAIN_SIGNATURE_GAS_LIMIT }
      : undefined
  let txHashOrParentSafeTxHash: string
  try {
    // TODO: This is a workaround until there is a fix for unchecked transactions in the protocol-kit
    const encodedApproveHashTx = await prepareApproveTxHash(safeTxHash, provider)

    // Note: SafeWalletProvider returns transaction hash if it exists, otherwise the safeTxHash
    // If the parent immediately executes, this will be the transaction hash of the approveHash
    // otherwise the safeTxHash of it
    txHashOrParentSafeTxHash = await provider.request({
      method: 'eth_sendTransaction',
      params: [{ from: signerAddress, to: safeAddress, data: encodedApproveHashTx, gas: options?.gasLimit }],
    })

    txDispatch(TxEvent.ONCHAIN_SIGNATURE_REQUESTED, eventParams)
  } catch (err) {
    txDispatch(TxEvent.FAILED, { ...eventParams, error: asError(err) })
    throw err
  }

  txDispatch(TxEvent.ONCHAIN_SIGNATURE_SUCCESS, eventParams)

  if (isNestedSafe) {
    txDispatch(TxEvent.NESTED_SAFE_TX_CREATED, {
      ...eventParams,
      txHashOrParentSafeTxHash,
      parentSafeAddress: signerAddress,
    })
  }

  // Until the on-chain signature is/has been executed, the safeTx is not
  // signed so we don't return it
}

export const dispatchSafeTxSpeedUp = async (
  txOptions: Omit<TransactionOptions, 'nonce'> & { nonce: number },
  txId: string,
  provider: Eip1193Provider,
  chainId: SafeState['chainId'],
  signerAddress: string,
  safeAddress: string,
  nonce: number,
) => {
  const sdk = await getSafeSDKWithSigner(provider)
  const eventParams = { txId, nonce }
  const signerNonce = txOptions.nonce
  const isSmartAccount = await isSmartContractWallet(chainId, signerAddress)

  // Execute the tx
  let result: TransactionResult | undefined
  try {
    const safeTx = await createExistingTx(chainId, txId)

    // TODO: This is a workaround until there is a fix for unchecked transactions in the protocol-kit
    if (isSmartAccount) {
      const encodedTx = await prepareTxExecution(safeTx, provider)
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [{ from: signerAddress, to: safeAddress, data: encodedTx }],
      })

      result = {
        hash: txHash,
        transactionResponse: null,
      }
    } else {
      result = await sdk.executeTransaction(safeTx, txOptions)
    }
    txDispatch(TxEvent.EXECUTING, eventParams)
  } catch (error) {
    txDispatch(TxEvent.SPEEDUP_FAILED, { ...eventParams, error: asError(error) })
    throw error
  }

  txDispatch(TxEvent.PROCESSING, {
    ...eventParams,
    txHash: result.hash,
    signerAddress,
    signerNonce,
    gasLimit: txOptions.gasLimit,
    txType: 'SafeTx',
  })

  return result.hash
}

export const dispatchCustomTxSpeedUp = async (
  txOptions: Omit<TransactionOptions, 'nonce'> & { nonce: number },
  txId: string,
  to: string,
  data: string,
  provider: Eip1193Provider,
  signerAddress: string,
  nonce: number,
) => {
  const eventParams = { txId, nonce }
  const signerNonce = txOptions.nonce

  // Execute the tx
  let result: TransactionResponse | undefined
  try {
    const signer = await getUncheckedSigner(provider)
    result = await signer.sendTransaction({ to, data, ...txOptions })
    txDispatch(TxEvent.EXECUTING, eventParams)
  } catch (error) {
    txDispatch(TxEvent.SPEEDUP_FAILED, { ...eventParams, error: asError(error) })
    throw error
  }

  txDispatch(TxEvent.PROCESSING, {
    txHash: result.hash,
    signerAddress,
    signerNonce,
    data,
    to,
    groupKey: result?.hash,
    txType: 'Custom',
    nonce,
  })

  return result.hash
}

/**
 * Execute a transaction
 */
export const dispatchTxExecution = async (
  safeTx: SafeTransaction,
  txOptions: TransactionOptions,
  txId: string,
  provider: Eip1193Provider,
  signerAddress: string,
  safeAddress: string,
  isSmartAccount: boolean,
): Promise<string> => {
  const sdk = await getSafeSDKWithSigner(provider)
  const eventParams = { txId, nonce: safeTx.data.nonce }

  const signerNonce = txOptions.nonce ?? (await getUserNonce(signerAddress))

  // Execute the tx
  let result: TransactionResult | undefined
  try {
    // TODO: This is a workaround until there is a fix for unchecked transactions in the protocol-kit
    if (isSmartAccount) {
      const encodedTx = await prepareTxExecution(safeTx, provider)
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [{ from: signerAddress, to: safeAddress, data: encodedTx }],
      })

      result = {
        hash: txHash,
        transactionResponse: null,
      }
    } else {
      result = await sdk.executeTransaction(safeTx, txOptions)
    }
    txDispatch(TxEvent.EXECUTING, { ...eventParams })
  } catch (error) {
    txDispatch(TxEvent.FAILED, { ...eventParams, error: asError(error) })
    throw error
  }

  txDispatch(TxEvent.PROCESSING, {
    ...eventParams,
    nonce: safeTx.data.nonce,
    txHash: result.hash,
    signerAddress,
    signerNonce,
    gasLimit: txOptions.gasLimit,
    txType: 'SafeTx',
  })

  return result.hash
}

export const dispatchBatchExecution = async (
  txs: TransactionDetails[],
  multiSendContract: MultiSendCallOnlyContractImplementationType,
  multiSendTxData: string,
  provider: Eip1193Provider,
  signerAddress: string,
  safeAddress: string,
  overrides: Omit<Overrides, 'nonce'> & { nonce: number },
  nonce: number,
) => {
  const groupKey = multiSendTxData

  let result: ContractTransactionResponse
  const txIds = txs.map((tx) => tx.txId)
  let signerNonce = overrides.nonce
  let txData = multiSendContract.encode('multiSend', [multiSendTxData])

  try {
    if (signerNonce === undefined || signerNonce === null) {
      signerNonce = await getUserNonce(signerAddress)
    }
    const signer = await getUncheckedSigner(provider)
    // @ts-ignore
    result = await multiSendContract.contract.connect(signer).multiSend(multiSendTxData, overrides)

    txIds.forEach((txId) => {
      txDispatch(TxEvent.EXECUTING, { txId, groupKey, nonce })
    })
  } catch (err) {
    txIds.forEach((txId) => {
      txDispatch(TxEvent.FAILED, { txId, error: asError(err), groupKey, nonce })
    })
    throw err
  }
  const txTo = await multiSendContract.getAddress()

  txIds.forEach((txId) => {
    txDispatch(TxEvent.PROCESSING, {
      txId,
      txHash: result.hash,
      groupKey,
      signerNonce,
      signerAddress,
      txType: 'Custom',
      data: txData,
      to: txTo,
      nonce,
    })
  })

  return result!.hash
}

/**
 * Execute a module transaction
 */
export const dispatchModuleTxExecution = async (
  tx: Transaction,
  provider: Eip1193Provider,
  safeAddress: string,
): Promise<string> => {
  const id = JSON.stringify(tx)

  let result: TransactionResponse | undefined
  try {
    const browserProvider = createWeb3(provider)
    const signer = await browserProvider.getSigner()

    txDispatch(TxEvent.EXECUTING, { groupKey: id })
    result = await signer.sendTransaction(tx)
  } catch (error) {
    txDispatch(TxEvent.FAILED, { groupKey: id, error: asError(error) })
    throw error
  }

  txDispatch(TxEvent.PROCESSING_MODULE, {
    groupKey: id,
    txHash: result.hash,
  })

  result
    ?.wait()
    .then((receipt) => {
      if (receipt === null) {
        txDispatch(TxEvent.FAILED, { groupKey: id, error: new Error('No transaction receipt found') })
      } else if (didRevert(receipt)) {
        txDispatch(TxEvent.REVERTED, {
          groupKey: id,
          error: new Error('Transaction reverted by EVM'),
        })
      } else {
        txDispatch(TxEvent.PROCESSED, { groupKey: id, safeAddress, txHash: result?.hash })
      }
    })
    .catch((error) => {
      txDispatch(TxEvent.FAILED, { groupKey: id, error: asError(error) })
    })

  return result?.hash
}

export const dispatchSpendingLimitTxExecution = async (
  txParams: SpendingLimitTxParams,
  txOptions: TransactionOptions,
  provider: Eip1193Provider,
  chainId: SafeState['chainId'],
  safeAddress: string,
  safeModules: SafeState['modules'],
) => {
  const id = JSON.stringify(txParams)

  let result: ContractTransactionResponse | undefined
  try {
    const signer = await getUncheckedSigner(provider)
    const contract = getSpendingLimitContract(chainId, safeModules, signer)

    result = await contract.executeAllowanceTransfer(
      txParams.safeAddress,
      txParams.token,
      txParams.to,
      txParams.amount,
      txParams.paymentToken,
      txParams.payment,
      txParams.delegate,
      txParams.signature,
      txOptions,
    )
    txDispatch(TxEvent.EXECUTING, { groupKey: id })
  } catch (error) {
    txDispatch(TxEvent.FAILED, { groupKey: id, error: asError(error) })
    throw error
  }

  txDispatch(TxEvent.PROCESSING_MODULE, {
    groupKey: id,
    txHash: result.hash,
  })

  result
    ?.wait()
    .then((receipt) => {
      if (receipt === null) {
        txDispatch(TxEvent.FAILED, { groupKey: id, error: new Error('No transaction receipt found') })
      } else if (didRevert(receipt)) {
        txDispatch(TxEvent.REVERTED, {
          groupKey: id,
          error: new Error('Transaction reverted by EVM'),
        })
      } else {
        txDispatch(TxEvent.PROCESSED, { groupKey: id, safeAddress, txHash: result?.hash })
      }
    })
    .catch((error) => {
      txDispatch(TxEvent.FAILED, { groupKey: id, error: asError(error) })
    })

  return result?.hash
}

export const dispatchSafeAppsTx = async (
  safeTx: SafeTransaction,
  safeAppRequestId: RequestId,
  provider: Eip1193Provider,
  txId?: string,
): Promise<string> => {
  const sdk = await getSafeSDKWithSigner(provider)
  const safeTxHash = await sdk.getTransactionHash(safeTx)
  txDispatch(TxEvent.SAFE_APPS_REQUEST, { safeAppRequestId, safeTxHash, txId })
  return safeTxHash
}

export const dispatchTxRelay = async (
  safeTx: SafeTransaction,
  safe: SafeState,
  txId: string,
  chain: ChainInfo,
  gasLimit?: string | number,
) => {
  const readOnlySafeContract = await getReadOnlyCurrentGnosisSafeContract(safe)

  let transactionToRelay = safeTx
  const data = readOnlySafeContract.encode('execTransaction', [
    transactionToRelay.data.to,
    transactionToRelay.data.value,
    transactionToRelay.data.data,
    transactionToRelay.data.operation,
    transactionToRelay.data.safeTxGas,
    transactionToRelay.data.baseGas,
    transactionToRelay.data.gasPrice,
    transactionToRelay.data.gasToken,
    transactionToRelay.data.refundReceiver,
    transactionToRelay.encodedSignatures(),
  ])

  try {
    const relayResponse = await relayTransaction(safe.chainId, {
      to: safe.address.value,
      data,
      gasLimit: gasLimit?.toString(),
      version: safe.version ?? getLatestSafeVersion(chain),
    })
    const taskId = relayResponse.taskId

    if (!taskId) {
      throw new Error('Transaction could not be relayed')
    }

    txDispatch(TxEvent.RELAYING, { taskId, txId, nonce: safeTx.data.nonce })

    // Monitor relay tx
    waitForRelayedTx(taskId, [txId], safe.address.value, safeTx.data.nonce)
  } catch (error) {
    txDispatch(TxEvent.FAILED, { txId, error: asError(error), nonce: safeTx.data.nonce })
    throw error
  }
}

export const dispatchBatchExecutionRelay = async (
  txs: TransactionDetails[],
  multiSendContract: MultiSendCallOnlyContractImplementationType,
  multiSendTxData: string,
  chainId: string,
  safeAddress: string,
  safeVersion: string,
) => {
  const to = await multiSendContract.getAddress()
  const data = multiSendContract.contract.interface.encodeFunctionData('multiSend', [multiSendTxData])
  const groupKey = multiSendTxData

  let relayResponse
  try {
    relayResponse = await relayTransaction(chainId, {
      to,
      data,
      version: safeVersion,
    })
  } catch (error) {
    txs.forEach(({ txId }) => {
      txDispatch(TxEvent.FAILED, {
        txId,
        error: asError(error),
        groupKey,
      })
    })
    throw error
  }

  const taskId = relayResponse.taskId
  txs.forEach(({ txId, detailedExecutionInfo }) => {
    if (isMultisigExecutionInfo(detailedExecutionInfo)) {
      txDispatch(TxEvent.RELAYING, { taskId, txId, groupKey, nonce: detailedExecutionInfo.nonce })
    }
  })

  // Monitor relay tx
  waitForRelayedTx(
    taskId,
    txs.map((tx) => tx.txId),
    safeAddress,
    isMultisigExecutionInfo(txs[0].detailedExecutionInfo) ? txs[0].detailedExecutionInfo.nonce : 0,
    groupKey,
  )
}
</file>

<file path="src/services/tx/tx-sender/index.ts">
export * from './create'
export * from './dispatch'
export * from './spendingLimit'
</file>

<file path="src/services/tx/tx-sender/recommendedNonce.ts">
import {
  Operation,
  postSafeGasEstimation,
  getNonces as fetchNonces,
  type SafeTransactionEstimation,
} from '@safe-global/safe-gateway-typescript-sdk'
import type { MetaTransactionData, SafeTransactionDataPartial } from '@safe-global/safe-core-sdk-types'
import { Errors, logError } from '@/services/exceptions'
import { isLegacyVersion } from '@safe-global/utils/services/contracts/utils'

const fetchRecommendedParams = async (
  chainId: string,
  safeAddress: string,
  txParams: MetaTransactionData,
): Promise<SafeTransactionEstimation> => {
  return postSafeGasEstimation(chainId, safeAddress, {
    to: txParams.to,
    value: txParams.value,
    data: txParams.data,
    operation: (txParams.operation as unknown as Operation) || Operation.CALL,
  })
}

export const getSafeTxGas = async (
  chainId: string,
  safeAddress: string,
  safeVersion: string,
  safeTxData: SafeTransactionDataPartial,
): Promise<string | undefined> => {
  const isSafeTxGasRequired = isLegacyVersion(safeVersion)

  // For 1.3.0+ Safes safeTxGas is not required
  if (!isSafeTxGasRequired) return '0'

  try {
    const estimation = await fetchRecommendedParams(chainId, safeAddress, safeTxData)
    return estimation.safeTxGas
  } catch (e) {
    logError(Errors._616, e)
  }
}

export const getNonces = async (chainId: string, safeAddress: string) => {
  try {
    return await fetchNonces(chainId, safeAddress)
  } catch (e) {
    logError(Errors._616, e)
  }
}
</file>

<file path="src/services/tx/tx-sender/sdk.ts">
import { getSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import type Safe from '@safe-global/protocol-kit'
import { SafeProvider, SigningMethod } from '@safe-global/protocol-kit'
import {
  generatePreValidatedSignature,
  isSafeMultisigTransactionResponse,
  sameString,
} from '@safe-global/protocol-kit/dist/src/utils'
import type { Eip1193Provider, JsonRpcSigner } from 'ethers'
import { isHardwareWallet, isWalletConnect } from '@/utils/wallets'
import { OperationType, type SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { getChainConfig } from '@safe-global/safe-gateway-typescript-sdk'
import { createWeb3, getWeb3ReadOnly } from '@/hooks/wallets/web3'
import { toQuantity } from 'ethers'
import { connectWallet, getConnectedWallet } from '@/hooks/wallets/useOnboard'
import { type OnboardAPI } from '@web3-onboard/core'
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { UncheckedJsonRpcSigner } from '@/utils/providers/UncheckedJsonRpcSigner'
import get from 'lodash/get'
import { maybePlural } from '@safe-global/utils/utils/formatters'

export const getAndValidateSafeSDK = (): Safe => {
  const safeSDK = getSafeSDK()
  if (!safeSDK) {
    throw new Error(
      'The Safe SDK could not be initialized. Please be aware that we only support v1.0.0 Safe Accounts and up.',
    )
  }
  return safeSDK
}

export const getSafeProvider = () => {
  const provider = getWeb3ReadOnly()
  if (!provider) {
    throw new Error('Provider not found.')
  }

  return new SafeProvider({ provider: provider._getConnection().url })
}

async function switchOrAddChain(walletProvider: ConnectedWallet['provider'], chainId: string): Promise<void> {
  const UNKNOWN_CHAIN_ERROR_CODE = 4902
  const hexChainId = toQuantity(parseInt(chainId))

  try {
    return await walletProvider.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: hexChainId }],
    })
  } catch (error) {
    const errorCode = get(error, 'code') as number | undefined

    // Rabby emits the same error code as MM, but it is nested
    const nestedErrorCode = get(error, 'data.originalError.code') as number | undefined

    if (errorCode === UNKNOWN_CHAIN_ERROR_CODE || nestedErrorCode === UNKNOWN_CHAIN_ERROR_CODE) {
      const chain = await getChainConfig(chainId)

      return walletProvider.request({
        method: 'wallet_addEthereumChain',
        params: [
          {
            chainId: hexChainId,
            chainName: chain.chainName,
            nativeCurrency: chain.nativeCurrency,
            rpcUrls: [chain.publicRpcUri.value],
            blockExplorerUrls: [new URL(chain.blockExplorerUriTemplate.address).origin],
          },
        ],
      })
    }

    throw error
  }
}

export const switchWalletChain = async (onboard: OnboardAPI, chainId: string): Promise<ConnectedWallet | null> => {
  const currentWallet = getConnectedWallet(onboard.state.get().wallets)
  if (!currentWallet) return null

  // Onboard incorrectly returns WalletConnect's chainId, so it needs to be switched unconditionally
  if (currentWallet.chainId === chainId && !isWalletConnect(currentWallet)) {
    return currentWallet
  }

  // Hardware wallets cannot switch chains
  if (isHardwareWallet(currentWallet)) {
    await onboard.disconnectWallet({ label: currentWallet.label })
    const wallets = await connectWallet(onboard, { autoSelect: currentWallet.label })
    return wallets ? getConnectedWallet(wallets) : null
  }

  // Onboard doesn't update immediately and otherwise returns a stale wallet if we directly get its state
  return new Promise((resolve) => {
    const source$ = onboard.state.select('wallets').subscribe((newWallets) => {
      const newWallet = getConnectedWallet(newWallets)
      if (newWallet && newWallet.chainId === chainId) {
        source$.unsubscribe()
        resolve(newWallet)
      }
    })

    // Switch chain for all other wallets
    switchOrAddChain(currentWallet.provider, chainId).catch(() => {
      source$.unsubscribe()
      resolve(currentWallet)
    })
  })
}

export const assertWalletChain = async (onboard: OnboardAPI, chainId: string): Promise<ConnectedWallet> => {
  const wallet = getConnectedWallet(onboard.state.get().wallets)

  if (!wallet) {
    throw new Error('No wallet connected.')
  }

  const newWallet = await switchWalletChain(onboard, chainId)

  if (!newWallet) {
    throw new Error('No wallet connected.')
  }

  if (newWallet.chainId !== chainId) {
    throw new Error('Wallet connected to wrong chain.')
  }

  return newWallet
}

export const getAssertedChainSigner = async (provider: Eip1193Provider): Promise<JsonRpcSigner> => {
  const browserProvider = createWeb3(provider)
  return browserProvider.getSigner()
}

export const getUncheckedSigner = async (provider: Eip1193Provider) => {
  const browserProvider = createWeb3(provider)
  return new UncheckedJsonRpcSigner(browserProvider, (await browserProvider.getSigner()).address)
}

export const getSafeSDKWithSigner = async (provider: Eip1193Provider): Promise<Safe> => {
  const sdk = getAndValidateSafeSDK()

  return sdk.connect({ provider })
}

export const tryOffChainTxSigning = async (safeTx: SafeTransaction, sdk: Safe): Promise<SafeTransaction> => {
  return sdk.signTransaction(safeTx, SigningMethod.ETH_SIGN_TYPED_DATA)
}

export const isDelegateCall = (safeTx: SafeTransaction): boolean => {
  return safeTx.data.operation === OperationType.DelegateCall
}

// TODO: This is a workaround and a duplication of sdk.executeTransaction but it returns the encoded tx instead of executing it.
export const prepareTxExecution = async (safeTransaction: SafeTransaction, provider: Eip1193Provider) => {
  const sdk = await getSafeSDKWithSigner(provider)

  if (!sdk.getContractManager().safeContract) {
    throw new Error('Safe is not deployed')
  }

  const transaction = isSafeMultisigTransactionResponse(safeTransaction)
    ? await sdk.toSafeTransactionType(safeTransaction)
    : safeTransaction

  const signedSafeTransaction = await sdk.copyTransaction(transaction)

  const txHash = await sdk.getTransactionHash(signedSafeTransaction)
  const ownersWhoApprovedTx = await sdk.getOwnersWhoApprovedTx(txHash)
  for (const owner of ownersWhoApprovedTx) {
    signedSafeTransaction.addSignature(generatePreValidatedSignature(owner))
  }
  const owners = await sdk.getOwners()
  const threshold = await sdk.getThreshold()
  const signerAddress = await sdk.getSafeProvider().getSignerAddress()
  if (threshold > signedSafeTransaction.signatures.size && signerAddress && owners.includes(signerAddress)) {
    signedSafeTransaction.addSignature(generatePreValidatedSignature(signerAddress))
  }

  if (threshold > signedSafeTransaction.signatures.size) {
    const signaturesMissing = threshold - signedSafeTransaction.signatures.size
    throw new Error(
      `There ${signaturesMissing > 1 ? 'are' : 'is'} ${signaturesMissing} signature${maybePlural(
        signaturesMissing,
      )} missing`,
    )
  }

  const value = BigInt(signedSafeTransaction.data.value)
  if (value !== 0n) {
    const balance = await sdk.getBalance()
    if (value > balance) {
      throw new Error('Not enough Ether funds')
    }
  }

  return sdk.getEncodedTransaction(signedSafeTransaction)
}

// TODO: This is a duplication of sdk.approveTransactionHash but it returns the encoded tx instead of executing it.
export const prepareApproveTxHash = async (hash: string, provider: Eip1193Provider) => {
  const sdk = await getSafeSDKWithSigner(provider)

  const safeContract = sdk.getContractManager().safeContract

  if (!safeContract) {
    throw new Error('Safe is not deployed')
  }

  const owners = await sdk.getOwners()
  const signerAddress = await sdk.getSafeProvider().getSignerAddress()
  if (!signerAddress) {
    throw new Error('SafeProvider must be initialized with a signer to use this method')
  }
  const addressIsOwner = owners.some((owner: string) => signerAddress && sameString(owner, signerAddress))
  if (!addressIsOwner) {
    throw new Error('Transaction hashes can only be approved by Safe owners')
  }

  // @ts-ignore
  return safeContract.encode('approveHash', [hash])
}
</file>

<file path="src/services/tx/tx-sender/spendingLimit.ts">
import type { SpendingLimitState } from '@/store/spendingLimitsSlice'
import { getSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import {
  getLatestSpendingLimitAddress,
  getDeployedSpendingLimitModuleAddress,
} from '@/services/contracts/spendingLimitContracts'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'
import {
  createAddDelegateTx,
  createEnableModuleTx,
  createResetAllowanceTx,
  createSetAllowanceTx,
} from '@/services/tx/spendingLimitParams'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { parseUnits } from 'ethers'
import { currentMinutes } from '@safe-global/utils/utils/date'
import { createMultiSendCallOnlyTx } from '@/services/tx/tx-sender/create'

export type NewSpendingLimitData = {
  beneficiary: string
  tokenAddress: string
  amount: string
  resetTime: string
}

export const createNewSpendingLimitTx = async (
  data: NewSpendingLimitData,
  spendingLimits: SpendingLimitState[],
  chainId: string,
  chain: ChainInfo,
  safeModules: SafeState['modules'],
  deployed: boolean,
  tokenDecimals?: number | null,
  existingSpendingLimit?: SpendingLimitState,
) => {
  const sdk = getSafeSDK()
  if (!sdk) return

  let spendingLimitAddress = deployed && getDeployedSpendingLimitModuleAddress(chainId, safeModules)
  const isModuleEnabled = !!spendingLimitAddress
  if (!isModuleEnabled) {
    spendingLimitAddress = getLatestSpendingLimitAddress(chainId)
  }
  if (!spendingLimitAddress) return

  const txs: MetaTransactionData[] = []

  if (!deployed) {
    const enableModuleTx = await createEnableModuleTx(
      chain,
      await sdk.getAddress(),
      await sdk.getContractVersion(),
      spendingLimitAddress,
    )

    const tx = {
      to: enableModuleTx.to,
      value: '0',
      data: enableModuleTx.data,
    }

    txs.push(tx)
  } else {
    if (!isModuleEnabled) {
      const enableModuleTx = await sdk.createEnableModuleTx(spendingLimitAddress)

      const tx = {
        to: enableModuleTx.data.to,
        value: '0',
        data: enableModuleTx.data.data,
      }
      txs.push(tx)
    }
  }

  const existingDelegate = spendingLimits.find((spendingLimit) => spendingLimit.beneficiary === data.beneficiary)
  if (!existingDelegate) {
    txs.push(createAddDelegateTx(data.beneficiary, spendingLimitAddress))
  }

  if (existingSpendingLimit && existingSpendingLimit.spent !== '0') {
    txs.push(createResetAllowanceTx(data.beneficiary, data.tokenAddress, spendingLimitAddress))
  }

  const tx = createSetAllowanceTx(
    data.beneficiary,
    data.tokenAddress,
    parseUnits(data.amount, tokenDecimals ?? undefined).toString(),
    parseInt(data.resetTime),
    data.resetTime !== '0' ? currentMinutes() - 30 : 0,
    spendingLimitAddress,
  )

  txs.push(tx)

  return createMultiSendCallOnlyTx(txs)
}
</file>

<file path="src/services/tx/encodeSignatures.ts">
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { generatePreValidatedSignature } from '@safe-global/protocol-kit/dist/src/utils/signatures'

export const encodeSignatures = (
  safeTx: SafeTransaction,
  from: string | undefined,
  needsSignature: boolean,
): string => {
  const owner = from?.toLowerCase()
  const needsOwnerSig = needsSignature && owner !== undefined && !safeTx.signatures.has(owner)

  // https://docs.gnosis.io/safe/docs/contracts_signatures/#pre-validated-signatures
  if (needsOwnerSig) {
    const ownerSig = generatePreValidatedSignature(owner)
    safeTx.addSignature(ownerSig)
  }

  const encoded = safeTx.encodedSignatures()

  // Remove the "fake" signature we've just added
  if (needsOwnerSig) {
    safeTx.signatures.delete(owner)
  }

  return encoded
}
</file>

<file path="src/services/tx/extractTxInfo.ts">
import type { OperationType } from '@safe-global/safe-core-sdk-types'
import { type SafeTransactionData } from '@safe-global/safe-core-sdk-types'
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { Operation } from '@safe-global/safe-gateway-typescript-sdk'
import { isMultisigDetailedExecutionInfo } from '@/utils/transaction-guards'

const ZERO_ADDRESS: string = '0x0000000000000000000000000000000000000000'

/**
 * Convert the CGW tx type to a Safe Core SDK tx
 */
const extractTxInfo = (
  txDetails: TransactionDetails,
): { txParams: SafeTransactionData; signatures: Record<string, string> } => {
  const execInfo = isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo)
    ? txDetails.detailedExecutionInfo
    : undefined
  const txData = txDetails?.txData

  // Format signatures into a map
  const signatures =
    execInfo?.confirmations.reduce(
      (result, item) => {
        result[item.signer.value] = item.signature ?? ''
        return result
      },
      {} as Record<string, string>,
    ) ?? {}

  const nonce = execInfo?.nonce ?? 0
  const baseGas = execInfo?.baseGas ?? '0'
  const gasPrice = execInfo?.gasPrice ?? '0'
  const safeTxGas = execInfo?.safeTxGas ?? '0'
  const gasToken = execInfo?.gasToken ?? ZERO_ADDRESS
  const refundReceiver = execInfo?.refundReceiver.value ?? ZERO_ADDRESS

  const to = txData?.to.value ?? ZERO_ADDRESS
  const value = txData?.value ?? '0'
  const data = txData?.hexData ?? '0x'
  const operation = (txData?.operation ?? Operation.CALL) as unknown as OperationType

  return {
    txParams: {
      data,
      baseGas,
      gasPrice,
      safeTxGas,
      gasToken,
      nonce,
      refundReceiver,
      value,
      to,
      operation,
    },
    signatures,
  }
}

export default extractTxInfo
</file>

<file path="src/services/tx/proposeTransaction.ts">
import type { Operation, TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import { proposeTransaction } from '@safe-global/safe-gateway-typescript-sdk'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'

const proposeTx = async (
  chainId: string,
  safeAddress: string,
  sender: string,
  tx: SafeTransaction,
  safeTxHash: string,
  origin?: string,
): Promise<TransactionDetails> => {
  const signatures = tx.signatures.size > 0 ? tx.encodedSignatures() : undefined

  return proposeTransaction(chainId, safeAddress, {
    ...tx.data,
    safeTxHash,
    sender,
    value: tx.data.value.toString(),
    operation: tx.data.operation as unknown as Operation,
    nonce: tx.data.nonce.toString(),
    safeTxGas: tx.data.safeTxGas.toString(),
    baseGas: tx.data.baseGas.toString(),
    gasPrice: tx.data.gasPrice.toString(),
    signature: signatures,
    origin,
  })
}

export default proposeTx
</file>

<file path="src/services/tx/safeUpdateParams.ts">
import type { SafeContractImplementationType } from '@safe-global/protocol-kit/dist/src/types/contracts'
import type { MetaTransactionData, SafeVersion } from '@safe-global/safe-core-sdk-types'
import { OperationType } from '@safe-global/safe-core-sdk-types'
import type { ChainInfo, TransactionData } from '@safe-global/safe-gateway-typescript-sdk'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import semverSatisfies from 'semver/functions/satisfies'
import { getReadOnlyFallbackHandlerContract, getReadOnlyGnosisSafeContract } from '@/services/contracts/safeContracts'
import { SAFE_FEATURES } from '@safe-global/protocol-kit/dist/src/utils/safeVersions'
import { hasSafeFeature } from '@/utils/safe-versions'
import { createUpdateMigration, SAFE_TO_L2_MIGRATION_VERSION } from '@/utils/safe-migrations'
import { isMultiSendCalldata } from '@/utils/transaction-calldata'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'
import { Gnosis_safe__factory } from '@safe-global/utils/types/contracts/factories/@safe-global/safe-deployments/dist/assets/v1.1.1'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { determineMasterCopyVersion } from '@/features/counterfactual/utils'
import { getSafeMigrationDeployment } from '@safe-global/safe-deployments'
import { getLatestSafeVersion } from '@safe-global/utils/utils/chains'
import { assertValidSafeVersion } from '@safe-global/utils/services/contracts/utils'

const getChangeFallbackHandlerCallData = async (
  safeContractInstance: SafeContractImplementationType,
  chain: ChainInfo,
): Promise<string> => {
  if (!hasSafeFeature(SAFE_FEATURES.SAFE_FALLBACK_HANDLER, getLatestSafeVersion(chain))) {
    return '0x'
  }

  const fallbackHandlerAddress = await (
    await getReadOnlyFallbackHandlerContract(getLatestSafeVersion(chain))
  ).getAddress()
  // @ts-ignore
  return safeContractInstance.encode('setFallbackHandler', [fallbackHandlerAddress])
}

/**
 * For 1.3.0 Safes, does a delegate call to a migration contract.
 *
 * For older Safes, creates two transactions:
 * - change the mastercopy address
 * - set the fallback handler address
 */
export const createUpdateSafeTxs = async (safe: SafeState, chain: ChainInfo): Promise<MetaTransactionData[]> => {
  assertValidSafeVersion(safe.version)

  // 1.3.0 Safes are updated using a delegate call to a migration contract
  if (semverSatisfies(safe.version, '1.3.0')) {
    return [createUpdateMigration(chain, safe.version, safe.fallbackHandler?.value)]
  }

  // For older Safes, we need to create two transactions
  const latestMasterCopyAddress = await (
    await getReadOnlyGnosisSafeContract(chain, getLatestSafeVersion(chain))
  ).getAddress()
  const currentReadOnlySafeContract = await getReadOnlyGnosisSafeContract(chain, safe.version)

  const updatedReadOnlySafeContract = await getReadOnlyGnosisSafeContract(chain, getLatestSafeVersion(chain, true))

  // @ts-expect-error this was removed in 1.3.0 but we need to support it for older safe versions
  const changeMasterCopyCallData = currentReadOnlySafeContract.encode('changeMasterCopy', [latestMasterCopyAddress])
  const changeFallbackHandlerCallData = await getChangeFallbackHandlerCallData(updatedReadOnlySafeContract, chain)

  const txs: MetaTransactionData[] = [
    {
      to: safe.address.value,
      value: '0',
      data: changeMasterCopyCallData,
      operation: OperationType.Call,
    },
    {
      to: safe.address.value,
      value: '0',
      data: changeFallbackHandlerCallData,
      operation: OperationType.Call,
    },
  ]

  return txs
}
const SAFE_1_1_1_INTERFACE = Gnosis_safe__factory.createInterface()

export const extractTargetVersionFromUpdateSafeTx = (
  txData: TransactionData | undefined,
  safe: SafeState,
): SafeVersion | undefined => {
  if (!txData) {
    return
  }
  const data = txData.hexData ?? '0x'
  let migrationTxData: MetaTransactionData = {
    to: txData.to.value,
    data,
    value: txData.value ?? '0',
    operation: txData.operation as number,
  }
  if (isMultiSendCalldata(data)) {
    // Decode multisend and check the first call
    const txs = decodeMultiSendData(data)
    if (txs.length === 2) {
      // First tx is the upgrade. Second sets the fallback handler
      migrationTxData = txs[0]
    }
  }

  // Below Safe 1.3.0 the call will be to the Safe itself and call changeMasterCopy
  if (
    sameAddress(migrationTxData.to, safe.address.value) &&
    migrationTxData.data.startsWith(SAFE_1_1_1_INTERFACE.getFunction('changeMasterCopy').selector)
  ) {
    // Decode call and check which Safe version it is
    const decodedData = SAFE_1_1_1_INTERFACE.decodeFunctionData('changeMasterCopy', migrationTxData.data)
    return determineMasterCopyVersion(decodedData[0], safe.chainId)
  }

  const safeMigrationAddress = getSafeMigrationDeployment({
    version: SAFE_TO_L2_MIGRATION_VERSION,
    network: safe.chainId,
  })?.networkAddresses[safe.chainId]

  // Otherwise it must be a delegate call to the SafeMigration 1.4.1 contract
  if (migrationTxData.operation === 1 && sameAddress(safeMigrationAddress, migrationTxData.to)) {
    // This contract can only migrate to 1.4.1
    return SAFE_TO_L2_MIGRATION_VERSION
  }
}
</file>

<file path="src/services/tx/spendingLimitParams.ts">
import { getReadOnlyGnosisSafeContract } from '@/services/contracts/safeContracts'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'
import { getSpendingLimitInterface } from '@/services/contracts/spendingLimitContracts'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'

export const createEnableModuleTx = async (
  chain: ChainInfo,
  safeAddress: string,
  safeVersion: string,
  spendingLimitAddress: string,
): Promise<MetaTransactionData> => {
  const contract = await getReadOnlyGnosisSafeContract(chain, safeVersion)

  // @ts-ignore
  const data = contract.encode('enableModule', [spendingLimitAddress])

  return {
    to: safeAddress,
    value: '0',
    data,
  }
}

export const createAddDelegateTx = (delegate: string, spendingLimitAddress: string): MetaTransactionData => {
  const spendingLimitInterface = getSpendingLimitInterface()

  const data = spendingLimitInterface.encodeFunctionData('addDelegate', [delegate])

  return {
    to: spendingLimitAddress,
    value: '0',
    data,
  }
}

export const createResetAllowanceTx = (
  delegate: string,
  tokenAddress: string,
  spendingLimitAddress: string,
): MetaTransactionData => {
  const spendingLimitInterface = getSpendingLimitInterface()

  const data = spendingLimitInterface.encodeFunctionData('resetAllowance', [delegate, tokenAddress])

  return {
    to: spendingLimitAddress,
    value: '0',
    data,
  }
}

export const createSetAllowanceTx = (
  delegate: string,
  tokenAddress: string,
  amountInWei: string,
  resetTimeMin: number,
  resetBaseMin: number,
  spendingLimitAddress: string,
) => {
  const spendingLimitInterface = getSpendingLimitInterface()

  const data = spendingLimitInterface.encodeFunctionData('setAllowance', [
    delegate,
    tokenAddress,
    amountInWei,
    resetTimeMin,
    resetBaseMin,
  ])

  return {
    to: spendingLimitAddress,
    value: '0',
    data,
  }
}
</file>

<file path="src/services/tx/tokenTransferParams.ts">
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types'
import { ConfirmationViewTypes, type BaselineConfirmationView } from '@safe-global/safe-gateway-typescript-sdk'
import { safeParseUnits } from '@safe-global/utils/utils/formatters'
import { Interface } from 'ethers'
import { sameAddress } from '@safe-global/utils/utils/addresses'

// CryptoKitties Contract Addresses by network
// This is an exception made for a popular NFT that's not ERC721 standard-compatible,
// so we can allow the user to transfer the assets by using `transfer` instead of
// the standard `safeTransferFrom` method.
const CryptoKittiesContract = '0x06012c8cf97bead5deae237070f9587f8e7a266d'

const encodeERC20TransferData = (to: string, value: string): string => {
  const erc20Abi = ['function transfer(address to, uint256 value)']
  const contractInterface = new Interface(erc20Abi)
  return contractInterface.encodeFunctionData('transfer', [to, value])
}

const encodeERC721TransferData = (from: string, to: string, tokenId: string): string => {
  const erc721Abi = ['function safeTransferFrom(address from, address to, uint256 tokenId)']
  const contractInterface = new Interface(erc721Abi)
  return contractInterface.encodeFunctionData('safeTransferFrom', [from, to, tokenId])
}

export const createTokenTransferParams = (
  recipient: string,
  amount: string,
  decimals: number | null | undefined,
  tokenAddress: string,
): MetaTransactionData => {
  const isNativeToken = parseInt(tokenAddress, 16) === 0
  const value = safeParseUnits(amount, decimals)?.toString() || '0'

  return isNativeToken
    ? {
        to: recipient,
        value,
        data: '0x',
      }
    : {
        to: tokenAddress,
        value: '0',
        data: encodeERC20TransferData(recipient, value),
      }
}

export const createNftTransferParams = (
  from: string,
  to: string,
  tokenId: string,
  tokenAddress: string,
): MetaTransactionData => {
  let data = encodeERC721TransferData(from, to, tokenId)

  // An exception made for CryptoKitties, which is not ERC721 standard-compatible
  if (sameAddress(tokenAddress, CryptoKittiesContract)) {
    data = encodeERC20TransferData(to, tokenId)
  }

  return {
    to: tokenAddress,
    value: '0',
    data,
  }
}

export const getNativeTransferData = ({
  to,
  value,
}: Pick<MetaTransactionData, 'to' | 'value'>): BaselineConfirmationView => {
  return {
    type: ConfirmationViewTypes.GENERIC,
    method: '',
    parameters: [
      {
        name: 'to',
        type: 'address',
        value: to,
      },
      {
        name: 'value',
        type: 'uint256',
        value,
      },
    ],
  }
}
</file>

<file path="src/services/tx/txEvents.ts">
import EventBus from '@/services/EventBus'
import type { RequestId } from '@safe-global/safe-apps-sdk'

export enum TxEvent {
  SIGNED = 'SIGNED',
  SIGN_FAILED = 'SIGN_FAILED',
  PROPOSED = 'PROPOSED',
  PROPOSE_FAILED = 'PROPOSE_FAILED',
  DELETED = 'DELETED',
  SIGNATURE_PROPOSED = 'SIGNATURE_PROPOSED',
  SIGNATURE_PROPOSE_FAILED = 'SIGNATURE_PROPOSE_FAILED',
  SIGNATURE_INDEXED = 'SIGNATURE_INDEXED',
  ONCHAIN_SIGNATURE_REQUESTED = 'ONCHAIN_SIGNATURE_REQUESTED',
  ONCHAIN_SIGNATURE_SUCCESS = 'ONCHAIN_SIGNATURE_SUCCESS',
  NESTED_SAFE_TX_CREATED = 'NESTED_SAFE_TX_CREATED',
  EXECUTING = 'EXECUTING',
  PROCESSING = 'PROCESSING',
  PROCESSING_MODULE = 'PROCESSING_MODULE',
  PROCESSED = 'PROCESSED',
  REVERTED = 'REVERTED',
  RELAYING = 'RELAYING',
  FAILED = 'FAILED',
  SUCCESS = 'SUCCESS',
  SAFE_APPS_REQUEST = 'SAFE_APPS_REQUEST',
  BATCH_ADD = 'BATCH_ADD',
  SPEEDUP_FAILED = 'SPEEDUP_FAILED',
}

type Id = { txId: string; nonce: number; groupKey?: string } | { txId?: string; nonce?: number; groupKey: string }

interface TxEvents {
  [TxEvent.SIGNED]: { txId?: string }
  [TxEvent.SIGN_FAILED]: { txId?: string; error: Error }
  [TxEvent.PROPOSE_FAILED]: { error: Error }
  [TxEvent.PROPOSED]: { txId: string; nonce: number }
  [TxEvent.DELETED]: { safeTxHash: string }
  [TxEvent.SIGNATURE_PROPOSE_FAILED]: { txId: string; error: Error }
  [TxEvent.SIGNATURE_PROPOSED]: { txId: string; nonce: number; signerAddress: string }
  [TxEvent.SIGNATURE_INDEXED]: { txId: string }
  [TxEvent.ONCHAIN_SIGNATURE_REQUESTED]: Id
  [TxEvent.ONCHAIN_SIGNATURE_SUCCESS]: Id
  [TxEvent.NESTED_SAFE_TX_CREATED]: Id & { parentSafeAddress: string; txHashOrParentSafeTxHash: string }
  [TxEvent.EXECUTING]: Id
  [TxEvent.PROCESSING]: Id & {
    txHash: string
    signerAddress: string
    signerNonce: number
  } & ({ txType: 'Custom'; data: string; to: string } | { txType: 'SafeTx'; gasLimit: string | number | undefined })
  [TxEvent.SPEEDUP_FAILED]: Id & { error: Error }
  [TxEvent.PROCESSING_MODULE]: Id & { txHash: string }
  [TxEvent.PROCESSED]: Id & { safeAddress: string; txHash?: string }
  [TxEvent.REVERTED]: Id & { error: Error }
  [TxEvent.RELAYING]: Id & { taskId: string }
  [TxEvent.FAILED]: Id & { error: Error }
  [TxEvent.SUCCESS]: Id & { txHash?: string }
  [TxEvent.SAFE_APPS_REQUEST]: { safeAppRequestId: RequestId; safeTxHash: string; txId?: string }
  [TxEvent.BATCH_ADD]: Id
}

const txEventBus = new EventBus<TxEvents>()

export const txDispatch = txEventBus.dispatch.bind(txEventBus)

export const txSubscribe = txEventBus.subscribe.bind(txEventBus)

// Log all events
Object.values(TxEvent).forEach((event: TxEvent) => {
  txSubscribe<TxEvent>(event, (detail) => {
    console.info(`Transaction ${event} event received`, detail)
  })
})
</file>

<file path="src/services/tx/txMonitor.ts">
import { didRevert, type EthersError } from '@/utils/ethers-utils'

import { txDispatch, TxEvent } from '@/services/tx/txEvents'

import { POLLING_INTERVAL } from '@/config/constants'
import { Errors, logError } from '@/services/exceptions'
import { getSafeTransaction } from '@/utils/transactions'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { type JsonRpcProvider, type TransactionReceipt } from 'ethers'
import { SimpleTxWatcher } from '@/utils/SimpleTxWatcher'

export function _getRemainingTimeout(defaultTimeout: number, submittedAt?: number) {
  const timeoutInMs = defaultTimeout * 60_000
  const timeSinceSubmission = submittedAt !== undefined ? Date.now() - submittedAt : 0

  return Math.max(timeoutInMs - timeSinceSubmission, 1)
}

// Provider must be passed as an argument as it is undefined until initialised by `useInitWeb3`
export const waitForTx = async (
  provider: JsonRpcProvider,
  txIds: string[],
  txHash: string,
  safeAddress: string,
  walletAddress: string,
  walletNonce: number,
  nonce: number,
  chainId: string,
) => {
  const processReceipt = (receipt: TransactionReceipt | null, txIds: string[]) => {
    if (receipt === null) {
      txIds.forEach((txId) => {
        txDispatch(TxEvent.FAILED, {
          nonce,
          txId,
          error: new Error(`Transaction not found. It might have been replaced or cancelled in the connected wallet.`),
        })
      })
    } else if (didRevert(receipt)) {
      txIds.forEach((txId) => {
        txDispatch(TxEvent.REVERTED, {
          nonce,
          txId,
          error: new Error('Transaction reverted by EVM.'),
        })
      })
    } else {
      txIds.forEach((txId) => {
        txDispatch(TxEvent.PROCESSED, {
          nonce,
          txId,
          safeAddress,
          txHash,
        })
      })
    }
  }

  const processError = (err: any, txIds: string[]) => {
    const error = err as EthersError

    txIds.forEach((txId) => {
      txDispatch(TxEvent.FAILED, {
        nonce,
        txId,
        error: asError(error),
      })
    })
  }

  try {
    const isSafeTx = !!(await getSafeTransaction(txHash, chainId, safeAddress))
    if (isSafeTx) {
      // Poll for the transaction until it has a transactionHash and start the watcher
      const interval = setInterval(async () => {
        const safeTx = await getSafeTransaction(txHash, chainId, safeAddress)
        if (!safeTx?.txHash) return

        clearInterval(interval)

        const receipt = await SimpleTxWatcher.getInstance().watchTxHash(
          safeTx.txHash,
          walletAddress,
          walletNonce,
          provider,
        )
        processReceipt(receipt, txIds)
      }, POLLING_INTERVAL)
    } else {
      const receipt = await SimpleTxWatcher.getInstance().watchTxHash(txHash, walletAddress, walletNonce, provider)
      processReceipt(receipt, txIds)
    }
  } catch (error) {
    processError(error, txIds)
  }
}

export enum TaskState {
  CheckPending = 'CheckPending',
  ExecPending = 'ExecPending',
  ExecSuccess = 'ExecSuccess',
  ExecReverted = 'ExecReverted',
  WaitingForConfirmation = 'WaitingForConfirmation',
  Blacklisted = 'Blacklisted',
  Cancelled = 'Cancelled',
  NotFound = 'NotFound',
}

type TransactionStatusResponse = {
  chainId: number
  taskId: string
  taskState: TaskState
  creationDate: string
  lastCheckDate?: string
  lastCheckMessage?: string
  transactionHash?: string
  blockNumber?: number
  executionDate?: string
}

const TASK_STATUS_URL = 'https://relay.gelato.digital/tasks/status'
const getTaskTrackingUrl = (taskId: string) => `${TASK_STATUS_URL}/${taskId}`

export const getRelayTxStatus = async (taskId: string): Promise<{ task: TransactionStatusResponse } | undefined> => {
  const url = getTaskTrackingUrl(taskId)

  let response

  try {
    response = await fetch(url).then((res) => {
      // 404s can happen if gelato is a bit slow with picking up the taskID
      if (res.status !== 404 && res.ok) {
        return res.json()
      }

      return res.json().then((data) => {
        throw new Error(`${res.status} - ${res.statusText}: ${data?.message}`)
      })
    })
  } catch (error) {
    logError(Errors._632, error)
    return
  }

  return response
}

const WAIT_FOR_RELAY_TIMEOUT = 3 * 60_000 // 3 minutes

export const waitForRelayedTx = (
  taskId: string,
  txIds: string[],
  safeAddress: string,
  nonce: number,
  groupKey?: string,
): void => {
  let intervalId: NodeJS.Timeout
  let failAfterTimeoutId: NodeJS.Timeout

  intervalId = setInterval(async () => {
    const status = await getRelayTxStatus(taskId)

    // 404
    if (!status) {
      return
    }

    switch (status.task.taskState) {
      case TaskState.ExecSuccess:
        txIds.forEach((txId) =>
          txDispatch(TxEvent.PROCESSED, {
            nonce,
            txId,
            groupKey,
            safeAddress,
          }),
        )
        break
      case TaskState.ExecReverted:
        txIds.forEach((txId) =>
          txDispatch(TxEvent.REVERTED, {
            nonce,
            txId,
            error: new Error(`Relayed transaction reverted by EVM.`),
            groupKey,
          }),
        )
        break
      case TaskState.Blacklisted:
        txIds.forEach((txId) =>
          txDispatch(TxEvent.FAILED, {
            nonce,
            txId,
            error: new Error(`Relayed transaction was blacklisted by relay provider.`),
            groupKey,
          }),
        )
        break
      case TaskState.Cancelled:
        txIds.forEach((txId) =>
          txDispatch(TxEvent.FAILED, {
            nonce,
            txId,
            error: new Error(`Relayed transaction was cancelled by relay provider.`),
            groupKey,
          }),
        )
        break
      case TaskState.NotFound:
        txIds.forEach((txId) =>
          txDispatch(TxEvent.FAILED, {
            nonce,
            txId,
            error: new Error(`Relayed transaction was not found.`),
            groupKey,
          }),
        )
        break
      default:
        // Don't clear interval as we're still waiting for the tx to be relayed
        return
    }

    clearTimeout(failAfterTimeoutId)
    clearInterval(intervalId)
  }, POLLING_INTERVAL)

  failAfterTimeoutId = setTimeout(() => {
    txIds.forEach((txId) =>
      txDispatch(TxEvent.FAILED, {
        nonce,
        txId,
        error: new Error(
          `Transaction not relayed in ${
            WAIT_FOR_RELAY_TIMEOUT / 60_000
          } minutes. Be aware that it might still be relayed.`,
        ),
        groupKey,
      }),
    )

    clearInterval(intervalId)
  }, WAIT_FOR_RELAY_TIMEOUT)
}
</file>

<file path="src/services/EventBus.ts">
interface GeneralEventTypes {
  // the name of the event and the data it dispatches with
  // e.g. 'entryCreated': { count: 1 }
  [eventType: string]: any
}

class EventBus<EventTypes extends GeneralEventTypes> {
  private eventTarget: EventTarget

  constructor() {
    this.eventTarget = new EventTarget()
  }

  dispatch<T extends keyof EventTypes>(eventType: T, detail: EventTypes[T]): void {
    const e = new CustomEvent(String(eventType), { detail })
    this.eventTarget.dispatchEvent(e)
  }

  subscribe<T extends keyof EventTypes>(eventType: T, callback: (detail: EventTypes[T]) => void): () => void {
    const handler = (e: Event) => {
      if (e instanceof CustomEvent) {
        callback(e.detail)
      }
    }

    const eventName = String(eventType)

    this.eventTarget.addEventListener(eventName, handler)

    // Return an unsubscribe function
    return () => this.eventTarget.removeEventListener(eventName, handler)
  }
}

export default EventBus
</file>

<file path="src/services/onboard.ts">
import Onboard, { type OnboardAPI } from '@web3-onboard/core'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { getAllWallets } from '@/hooks/wallets/wallets'
import { getRpcServiceUrl } from '@/hooks/wallets/web3'
import { numberToHex } from '@/utils/hex'
import { BRAND_NAME } from '@/config/constants'
import type { EnvState } from '@safe-global/store/settingsSlice'

let onboard: OnboardAPI | null = null

export const createOnboard = (
  chainConfigs: ChainInfo[],
  currentChain: ChainInfo,
  rpcConfig: EnvState['rpc'] | undefined,
): OnboardAPI => {
  if (onboard) return onboard

  const wallets = getAllWallets(currentChain)

  const chains = chainConfigs.map((cfg) => ({
    // We cannot use ethers' toBeHex here as we do not want to pad it to an even number of characters.
    id: numberToHex(parseInt(cfg.chainId)),
    label: cfg.chainName,
    rpcUrl: rpcConfig?.[cfg.chainId] || getRpcServiceUrl(cfg.rpcUri),
    token: cfg.nativeCurrency.symbol,
    color: cfg.theme.backgroundColor,
    publicRpcUrl: cfg.publicRpcUri.value,
    blockExplorerUrl: new URL(cfg.blockExplorerUriTemplate.address).origin,
  }))

  onboard = Onboard({
    wallets,

    chains,

    accountCenter: {
      mobile: { enabled: false },
      desktop: { enabled: false },
    },

    notify: {
      enabled: false,
    },

    appMetadata: {
      name: BRAND_NAME,
      icon: location.origin + '/images/logo-round.svg',
      description: `${BRAND_NAME} – smart contract wallet for Ethereum (ex-Gnosis Safe multisig)`,
    },

    connect: {
      removeWhereIsMyWalletWarning: true,
      autoConnectLastWallet: false,
    },
  })

  return onboard
}
</file>

<file path="src/services/sentry.ts">
import { init, ErrorBoundary, captureException } from '@sentry/react'
import { SENTRY_DSN } from '@/config/constants'
import packageJson from '../../package.json'

init({
  dsn: SENTRY_DSN,
  release: `safe-wallet-web@${packageJson.version}`,
  sampleRate: 0.1,
  // ignore MetaMask errors we don't control
  ignoreErrors: ['Internal JSON-RPC error', 'JsonRpcEngine', 'Non-Error promise rejection captured with keys: code'],

  beforeSend: (event) => {
    // Remove sensitive URL query params
    const query = event.request?.query_string
    if (event.request && query) {
      const appUrl = typeof query !== 'string' && !Array.isArray(query) ? query.appUrl : ''
      if (appUrl) {
        event.request.query_string = { appUrl }
      } else {
        delete event.request.query_string
      }
    }
    return event
  },
})

export const SentryErrorBoundary = ErrorBoundary
export const sentryCaptureException = captureException
</file>

<file path="src/store/api/gateway/index.ts">
import { proposerEndpoints } from '@/store/api/gateway/proposers'
import { createApi, fakeBaseQuery } from '@reduxjs/toolkit/query/react'

import {
  type AllOwnedSafes,
  getAllOwnedSafes,
  getTransactionDetails,
  type TransactionDetails,
} from '@safe-global/safe-gateway-typescript-sdk'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { safeOverviewEndpoints } from './safeOverviews'
import { createSubmission, getSafe, getSafesByOwner, getSubmission } from '@safe-global/safe-client-gateway-sdk'

export async function buildQueryFn<T>(fn: () => Promise<T>) {
  try {
    return { data: await fn() }
  } catch (error) {
    return { error: asError(error) }
  }
}

export function makeSafeTag(chainId: string, address: string): `${number}:0x${string}` {
  return `${chainId}:${address}` as `${number}:0x${string}`
}

export const gatewayApi = createApi({
  reducerPath: 'gatewayApi',
  baseQuery: fakeBaseQuery<Error>(),
  tagTypes: ['OwnedSafes', 'Submissions'],
  endpoints: (builder) => ({
    getTransactionDetails: builder.query<TransactionDetails, { chainId: string; txId: string }>({
      queryFn({ chainId, txId }) {
        return buildQueryFn(() => getTransactionDetails(chainId, txId))
      },
    }),
    getMultipleTransactionDetails: builder.query<TransactionDetails[], { chainId: string; txIds: string[] }>({
      queryFn({ chainId, txIds }) {
        return buildQueryFn(() => Promise.all(txIds.map((txId) => getTransactionDetails(chainId, txId))))
      },
    }),
    getSafe: builder.query<getSafe, { chainId: string; safeAddress: string }>({
      queryFn({ chainId, safeAddress }) {
        return buildQueryFn(() => getSafe({ params: { path: { chainId, safeAddress } } }))
      },
    }),
    getAllOwnedSafes: builder.query<AllOwnedSafes, { walletAddress: string }>({
      queryFn({ walletAddress }) {
        return buildQueryFn(() => getAllOwnedSafes(walletAddress))
      },
    }),
    getOwnedSafes: builder.query<getSafesByOwner, { chainId: string; ownerAddress: string }>({
      queryFn({ chainId, ownerAddress }) {
        return buildQueryFn(() => getSafesByOwner({ params: { path: { chainId, ownerAddress } } }))
      },
      providesTags: (_res, _err, { chainId, ownerAddress }) => {
        return [{ type: 'OwnedSafes', id: makeSafeTag(chainId, ownerAddress) }]
      },
    }),
    getSubmission: builder.query<
      getSubmission,
      { outreachId: number; chainId: string; safeAddress: string; signerAddress: string }
    >({
      queryFn({ outreachId, chainId, safeAddress, signerAddress }) {
        return buildQueryFn(() =>
          getSubmission({ params: { path: { outreachId, chainId, safeAddress, signerAddress } } }),
        )
      },
      providesTags: ['Submissions'],
    }),
    createSubmission: builder.mutation<
      createSubmission,
      { outreachId: number; chainId: string; safeAddress: string; signerAddress: string }
    >({
      queryFn({ outreachId, chainId, safeAddress, signerAddress }) {
        return buildQueryFn(() =>
          createSubmission({
            params: {
              path: { outreachId, chainId, safeAddress, signerAddress },
            },
            body: { completed: true },
          }),
        )
      },
      invalidatesTags: ['Submissions'],
    }),
    ...proposerEndpoints(builder),
    ...safeOverviewEndpoints(builder),
  }),
})

export const {
  useGetTransactionDetailsQuery,
  useGetMultipleTransactionDetailsQuery,
  useLazyGetTransactionDetailsQuery,
  useGetProposersQuery,
  useDeleteProposerMutation,
  useAddProposerMutation,
  useGetSubmissionQuery,
  useCreateSubmissionMutation,
  useGetSafeQuery,
  useGetSafeOverviewQuery,
  useGetMultipleSafeOverviewsQuery,
  useGetAllOwnedSafesQuery,
  useGetOwnedSafesQuery,
} = gatewayApi
</file>

<file path="src/store/api/gateway/proposers.ts">
import { buildQueryFn, gatewayApi } from '@/store/api/gateway/index'
import { type fakeBaseQuery } from '@reduxjs/toolkit/query/react'
import type { EndpointBuilder } from '@reduxjs/toolkit/query/react'
import { deleteDelegate, deleteDelegateV2, postDelegate, postDelegateV2 } from '@safe-global/safe-client-gateway-sdk'
import { getDelegates } from '@safe-global/safe-gateway-typescript-sdk'
import type { Delegate, DelegateResponse } from '@safe-global/safe-gateway-typescript-sdk/dist/types/delegates'

export const proposerEndpoints = (
  builder: EndpointBuilder<ReturnType<typeof fakeBaseQuery<Error>>, 'OwnedSafes' | 'Submissions', 'gatewayApi'>,
) => ({
  getProposers: builder.query<DelegateResponse, { chainId: string; safeAddress: string }>({
    queryFn({ chainId, safeAddress }) {
      return buildQueryFn(() => getDelegates(chainId, { safe: safeAddress }))
    },
  }),
  deleteProposer: builder.mutation<
    void,
    {
      chainId: string
      safeAddress: string
      delegateAddress: string
      delegator: string
      signature: string
      shouldEthSign: boolean
    }
  >({
    queryFn({ chainId, safeAddress, delegateAddress, delegator, signature, shouldEthSign }) {
      const options = {
        params: { path: { chainId, delegateAddress } },
        body: { safe: safeAddress, signature, delegator },
      }
      return buildQueryFn(() =>
        shouldEthSign
          ? deleteDelegate({ params: options.params, body: { ...options.body, delegate: delegateAddress } })
          : deleteDelegateV2(options),
      )
    },
    // Optimistically update the cache and roll back in case the mutation fails
    async onQueryStarted({ chainId, safeAddress, delegateAddress, delegator }, { dispatch, queryFulfilled }) {
      const patchResult = dispatch(
        gatewayApi.util.updateQueryData('getProposers', { chainId, safeAddress }, (draft) => {
          draft.results = draft.results.filter(
            (delegate: Delegate) => delegate.delegate !== delegateAddress || delegate.delegator !== delegator,
          )
        }),
      )
      try {
        await queryFulfilled
      } catch {
        patchResult.undo()
      }
    },
  }),
  addProposer: builder.mutation<
    Delegate,
    {
      chainId: string
      safeAddress: string
      delegate: string
      delegator: string
      label: string
      signature: string
      shouldEthSign: boolean
    }
  >({
    queryFn({ chainId, safeAddress, delegate, delegator, label, signature, shouldEthSign }) {
      const options = {
        params: { path: { chainId } },
        body: { delegate, delegator, label, signature, safe: safeAddress },
      }

      return buildQueryFn(() => (shouldEthSign ? postDelegate(options) : postDelegateV2(options)))
    },
    // Optimistically update the cache and roll back in case the mutation fails
    async onQueryStarted({ chainId, safeAddress, delegate, delegator, label }, { dispatch, queryFulfilled }) {
      const patchResult = dispatch(
        gatewayApi.util.updateQueryData('getProposers', { chainId, safeAddress }, (draft) => {
          const existingProposer = draft.results.findIndex(
            (proposer: Delegate) => proposer.delegate === delegate && delegator === proposer.delegator,
          )

          if (existingProposer !== -1) {
            // Update the existing delegate's label
            draft.results[existingProposer] = {
              ...draft.results[existingProposer],
              label,
            }
          } else {
            draft.results.push({ delegate, delegator, label, safe: safeAddress })
          }
        }),
      )
      try {
        await queryFulfilled
      } catch {
        patchResult.undo()
      }
    },
  }),
})
</file>

<file path="src/store/api/gateway/safeOverviews.ts">
import { type EndpointBuilder } from '@reduxjs/toolkit/query/react'

import { type SafeOverview, getSafeOverviews } from '@safe-global/safe-gateway-typescript-sdk'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { RootState } from '../..'
import { selectCurrency } from '../../settingsSlice'
import { type SafeItem } from '@/features/myAccounts/hooks/useAllSafes'
import { asError } from '@safe-global/utils/services/exceptions/utils'
import { makeSafeTag } from '.'

type SafeOverviewQueueItem = {
  safeAddress: string
  walletAddress?: string
  chainId: string
  currency: string
  callback: (result: { data: SafeOverview | undefined; error?: never } | { data?: never; error: string }) => void
}

const _BATCH_SIZE = 10
const _FETCH_TIMEOUT = 300

class SafeOverviewFetcher {
  private requestQueue: SafeOverviewQueueItem[] = []

  private fetchTimeout: NodeJS.Timeout | null = null

  private async fetchSafeOverviews({
    safeIds,
    walletAddress,
    currency,
  }: {
    safeIds: `${number}:0x${string}`[]
    walletAddress?: string
    currency: string
  }) {
    return await getSafeOverviews(safeIds, {
      /**
       * This flag can only be set once for all cross chain `safeIds`.
       * If we set `trusted` to `true` we will get 0 as `fiatTotal` for all Safes on networks without Default tokenlists.
       */
      trusted: false,
      exclude_spam: true,
      currency,
      wallet_address: walletAddress,
    })
  }

  private async processQueuedItems() {
    // Dequeue the first BATCH_SIZE items
    const nextBatch = this.requestQueue.slice(0, _BATCH_SIZE)
    this.requestQueue = this.requestQueue.slice(_BATCH_SIZE)

    let overviews: SafeOverview[]
    try {
      this.fetchTimeout && clearTimeout(this.fetchTimeout)
      this.fetchTimeout = null

      if (nextBatch.length === 0) {
        // Nothing to process
        return
      }

      const safeIds = nextBatch.map((request) => makeSafeTag(request.chainId, request.safeAddress))
      const { walletAddress, currency } = nextBatch[0]
      overviews = await this.fetchSafeOverviews({ safeIds, currency, walletAddress })
    } catch (err) {
      // Overviews could not be fetched
      nextBatch.forEach((item) => item.callback({ error: 'Could not fetch Safe overview' }))
      return
    }

    nextBatch.forEach((item) => {
      const overview = overviews.find(
        (entry) => sameAddress(entry.address.value, item.safeAddress) && entry.chainId === item.chainId,
      )

      item.callback({ data: overview })
    })
  }

  private enqueueRequest(item: SafeOverviewQueueItem) {
    this.requestQueue.push(item)

    if (this.requestQueue.length >= _BATCH_SIZE) {
      this.processQueuedItems()
    }

    // If no timer is running start a timer
    if (this.fetchTimeout === null) {
      this.fetchTimeout = setTimeout(() => {
        this.processQueuedItems()
      }, _FETCH_TIMEOUT)
    }
  }

  async getOverview(item: Omit<SafeOverviewQueueItem, 'callback'>) {
    return new Promise<SafeOverview | undefined>((resolve, reject) => {
      this.enqueueRequest({
        ...item,
        callback: (result) => {
          if ('data' in result) {
            resolve(result.data)
          }
          reject(result.error)
        },
      })
    })
  }
}

const batchedFetcher = new SafeOverviewFetcher()

type MultiOverviewQueryParams = {
  currency: string
  walletAddress?: string
  safes: SafeItem[]
}

export const safeOverviewEndpoints = (builder: EndpointBuilder<any, 'OwnedSafes' | 'Submissions', 'gatewayApi'>) => ({
  getSafeOverview: builder.query<SafeOverview | null, { safeAddress: string; walletAddress?: string; chainId: string }>(
    {
      async queryFn({ safeAddress, walletAddress, chainId }, { getState }) {
        const state = getState() as RootState
        const currency = selectCurrency(state)

        if (!safeAddress) {
          return { data: null }
        }

        try {
          const safeOverview = await batchedFetcher.getOverview({ chainId, currency, walletAddress, safeAddress })
          return { data: safeOverview ?? null }
        } catch (error) {
          return { error: { status: 'CUSTOM_ERROR', error: asError(error).message } }
        }
      },
    },
  ),
  getMultipleSafeOverviews: builder.query<SafeOverview[], MultiOverviewQueryParams>({
    async queryFn(params) {
      const { safes, walletAddress, currency } = params

      try {
        const promisedSafeOverviews = safes.map((safe) =>
          batchedFetcher.getOverview({
            chainId: safe.chainId,
            safeAddress: safe.address,
            currency,
            walletAddress,
          }),
        )
        const safeOverviews = await Promise.all(promisedSafeOverviews)
        return { data: safeOverviews.filter(Boolean) as SafeOverview[] }
      } catch (error) {
        return { error: { status: 'CUSTOM_ERROR', error: (error as Error).message } }
      }
    },
  }),
})
</file>

<file path="src/store/api/ofac.ts">
import { createApi } from '@reduxjs/toolkit/query/react'
import { selectChainById } from '@/store/chainsSlice'
import { Contract } from 'ethers'
import { createWeb3ReadOnly } from '@/hooks/wallets/web3'
import type { RootState } from '..'
import { CHAINALYSIS_OFAC_CONTRACT } from '@/config/constants'
import chains from '@/config/chains'

// Chainalysis contract ABI and address
const contractAbi = [
  {
    inputs: [],
    stateMutability: 'nonpayable',
    type: 'constructor',
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'addr',
        type: 'address',
      },
    ],
    name: 'isSanctioned',
    outputs: [
      {
        internalType: 'bool',
        name: '',
        type: 'bool',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
]

const noopBaseQuery = async () => ({ data: null })

const createBadRequestError = (message: string) => ({
  error: { status: 400, statusText: 'Bad Request', data: message },
})

export const ofacApi = createApi({
  reducerPath: 'ofacApi',
  baseQuery: noopBaseQuery,
  endpoints: (builder) => ({
    getIsSanctioned: builder.query<boolean, string>({
      async queryFn(address, { getState }) {
        const state = getState()
        const chain = selectChainById(state as RootState, chains.eth)

        if (!chain) return createBadRequestError('Chain info not found')
        if (!address) return createBadRequestError('No address provided')

        const provider = createWeb3ReadOnly(chain)
        const contract = new Contract(CHAINALYSIS_OFAC_CONTRACT, contractAbi, provider)

        try {
          const isAddressBlocked: boolean = await contract['isSanctioned'](address)
          return { data: isAddressBlocked }
        } catch (error) {
          return { error }
        }
      },
      keepUnusedDataFor: 24 * 60 * 60, // 24 hours
    }),
  }),
})

// Export hooks for usage in functional components, which are
// auto-generated based on the defined endpoints
export const { useGetIsSanctionedQuery } = ofacApi
</file>

<file path="src/store/api/safePass.ts">
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import { GATEWAY_URL } from '@/config/gateway'

const GLOBAL_CAMPAIGN_IDS: Record<'1' | '11155111', string> = {
  '11155111': 'fa9f462b-8e8c-4122-aa41-2464e919b721',
  '1': '9ed78b8b-178d-4e25-9ef2-1517865991ee',
}

export type CampaignLeaderboardEntry = {
  holder: string
  position: number
  boost: string
  totalPoints: number
  totalBoostedPoints: number
}

export const safePassApi = createApi({
  reducerPath: 'safePassApi',
  baseQuery: fetchBaseQuery({ baseUrl: GATEWAY_URL }),
  endpoints: (builder) => ({
    getOwnGlobalCampaignRank: builder.query<
      CampaignLeaderboardEntry,
      { chainId: '1' | '11155111'; safeAddress: string }
    >({
      query: (request) => ({
        url: `v1/community/campaigns/${GLOBAL_CAMPAIGN_IDS[request.chainId]}/leaderboard/${request.safeAddress}`,
      }),
    }),
  }),
})

// Export hooks for usage in functional components, which are
// auto-generated based on the defined endpoints
export const { useGetOwnGlobalCampaignRankQuery } = safePassApi
</file>

<file path="src/store/addedSafesSlice.ts">
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'
import type { SafeState, AddressInfo } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import type { RootState } from '.'

export type AddedSafesOnChain = {
  [safeAddress: string]: {
    owners: AddressInfo[]
    threshold: number
    ethBalance?: string
  }
}

export type AddedSafesState = {
  [chainId: string]: AddedSafesOnChain
}

const initialState: AddedSafesState = {}

export const addedSafesSlice = createSlice({
  name: 'addedSafes',
  initialState,
  reducers: {
    migrate: (state, action: PayloadAction<AddedSafesState>) => {
      // Don't migrate if there's data already
      if (Object.keys(state).length > 0) return state
      // Otherwise, migrate
      return action.payload
    },
    setAddedSafes: (_, action: PayloadAction<AddedSafesState>) => {
      return action.payload
    },
    addOrUpdateSafe: (state, { payload }: PayloadAction<{ safe: SafeState }>) => {
      const { chainId, address, owners, threshold } = payload.safe

      state[chainId] ??= {}
      state[chainId][address.value] = {
        // Keep balance
        ...(state[chainId][address.value] ?? {}),
        owners,
        threshold,
      }
    },
    removeSafe: (state, { payload }: PayloadAction<{ chainId: string; address: string }>) => {
      const { chainId, address } = payload

      delete state[chainId]?.[address]

      if (Object.keys(state[chainId]).length === 0) {
        delete state[chainId]
      }
    },
    pinSafe: (state, { payload }: PayloadAction<{ chainId: string; address: string }>) => {
      const { chainId, address } = payload
      state[chainId] ??= {}
      state[chainId][address] = state[chainId][address] ?? {}
    },
    unpinSafe: (state, { payload }: PayloadAction<{ chainId: string; address: string }>) => {
      const { chainId, address } = payload

      delete state[chainId]?.[address]

      if (state[chainId] && Object.keys(state[chainId]).length === 0) {
        delete state[chainId]
      }
    },
  },
})

export const { addOrUpdateSafe, removeSafe, pinSafe, unpinSafe } = addedSafesSlice.actions

export const selectAllAddedSafes = (state: RootState): AddedSafesState => {
  return state[addedSafesSlice.name]
}

export const selectTotalAdded = (state: RootState): number => {
  return Object.values(state[addedSafesSlice.name])
    .map((item) => Object.keys(item))
    .flat().length
}

export const selectAddedSafes = createSelector(
  [selectAllAddedSafes, (_: RootState, chainId: string) => chainId],
  (allAddedSafes, chainId): AddedSafesOnChain | undefined => {
    return allAddedSafes?.[chainId]
  },
)
</file>

<file path="src/store/addressBookSlice.ts">
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'
import { validateAddress } from '@safe-global/utils/utils/validation'
import pickBy from 'lodash/pickBy'
import type { RootState } from '.'

export type AddressBook = { [address: string]: string }

export type AddressBookState = { [chainId: string]: AddressBook }

const initialState: AddressBookState = {}

export const addressBookSlice = createSlice({
  name: 'addressBook',
  initialState,
  reducers: {
    migrate: (state, action: PayloadAction<AddressBookState>): AddressBookState => {
      // Don't migrate if there's data already
      if (Object.keys(state).length > 0) return state
      // Otherwise, migrate
      return action.payload
    },

    setAddressBook: (_, action: PayloadAction<AddressBookState>): AddressBookState => {
      return action.payload
    },

    upsertAddressBookEntries: (state, action: PayloadAction<{ chainIds: string[]; address: string; name: string }>) => {
      const { chainIds, address, name } = action.payload
      if (name.trim() === '') {
        return
      }
      chainIds.forEach((chainId) => {
        if (!state[chainId]) state[chainId] = {}
        state[chainId][address] = name
      })
    },

    removeAddressBookEntry: (state, action: PayloadAction<{ chainId: string; address: string }>) => {
      const { chainId, address } = action.payload
      if (!state[chainId]) return state
      delete state[chainId][address]
      if (Object.keys(state[chainId]).length > 0) return state
      delete state[chainId]
    },
  },
})

export const { setAddressBook, upsertAddressBookEntries, removeAddressBookEntry } = addressBookSlice.actions

export const selectAllAddressBooks = (state: RootState): AddressBookState => {
  return state[addressBookSlice.name]
}

export const selectAddressBookByChain = createSelector(
  [selectAllAddressBooks, (_, chainId: string) => chainId],
  (allAddressBooks, chainId): AddressBook => {
    const chainAddresses = allAddressBooks[chainId]
    const validAddresses = pickBy(chainAddresses, (_, key) => validateAddress(key) === undefined)
    return chainId ? validAddresses || {} : {}
  },
)
</file>

<file path="src/store/authSlice.ts">
import type { listenerMiddlewareInstance, RootState } from '@/store/index'
import { createSlice, type PayloadAction } from '@reduxjs/toolkit'
import { cgwClient } from '@safe-global/store/gateway/cgwClient'

type AuthPayload = {
  sessionExpiresAt: number | null
  lastUsedSpace: string | null
}

const initialState: AuthPayload = {
  sessionExpiresAt: null,
  lastUsedSpace: null,
}

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setAuthenticated: (state, { payload }: PayloadAction<AuthPayload['sessionExpiresAt']>) => {
      state.sessionExpiresAt = payload
    },

    setUnauthenticated: (state) => {
      state.sessionExpiresAt = null
    },

    setLastUsedSpace: (state, { payload }: PayloadAction<AuthPayload['lastUsedSpace']>) => {
      state.lastUsedSpace = payload
    },
  },
})

export const { setAuthenticated, setUnauthenticated, setLastUsedSpace } = authSlice.actions

export const isAuthenticated = (state: RootState): boolean => {
  return !!state.auth.sessionExpiresAt && state.auth.sessionExpiresAt > Date.now()
}

export const lastUsedSpace = (state: RootState) => {
  return state.auth.lastUsedSpace
}

export const authListener = (listenerMiddleware: typeof listenerMiddlewareInstance) => {
  listenerMiddleware.startListening({
    actionCreator: authSlice.actions.setUnauthenticated,
    effect: (_action, { dispatch }) => {
      // @ts-ignore TS2322: Type string is not assignable to type FullTagDescription<never>
      dispatch(cgwClient.util.invalidateTags(['spaces']))
    },
  })
}
</file>

<file path="src/store/balancesSlice.ts">
import { type TokenInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { createSelector } from '@reduxjs/toolkit'
import { makeLoadableSlice } from './common'
import type { Balances } from '@safe-global/store/gateway/AUTO_GENERATED/balances'

export const initialBalancesState: Balances = {
  items: [],
  fiatTotal: '',
}

const { slice, selector } = makeLoadableSlice('balances', initialBalancesState)

export const balancesSlice = slice
export const selectBalances = selector

export const selectTokens = createSelector(selectBalances, (balancesState): TokenInfo[] =>
  balancesState.data.items.map(({ tokenInfo }) => tokenInfo),
)
</file>

<file path="src/store/batchSlice.ts">
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'
import type { TransactionDetails } from '@safe-global/safe-gateway-typescript-sdk'
import type { RootState } from '.'
import { selectChainIdAndSafeAddress } from '@/store/common'

export type DraftBatchItem = {
  id: string
  timestamp: number
  txDetails: TransactionDetails
}

type BatchTxsState = {
  [chainId: string]: {
    [safeAddress: string]: DraftBatchItem[]
  }
}

const initialState: BatchTxsState = {}

export const batchSlice = createSlice({
  name: 'batch',
  initialState,
  reducers: {
    // Add a tx to the batch
    addTx: (
      state,
      action: PayloadAction<{
        chainId: string
        safeAddress: string
        txDetails: TransactionDetails
      }>,
    ) => {
      const { chainId, safeAddress, txDetails } = action.payload
      state[chainId] = state[chainId] || {}
      state[chainId][safeAddress] = state[chainId][safeAddress] || []
      // @ts-expect-error
      state[chainId][safeAddress].push({
        id: Math.random().toString(36).slice(2),
        timestamp: Date.now(),
        txDetails,
      })
    },

    // Remove a tx to the batch by txId
    removeTx: (
      state,
      action: PayloadAction<{
        chainId: string
        safeAddress: string
        id: string
      }>,
    ) => {
      const { chainId, safeAddress, id } = action.payload
      state[chainId] = state[chainId] || {}
      state[chainId][safeAddress] = state[chainId][safeAddress] || []
      state[chainId][safeAddress] = state[chainId][safeAddress].filter((item) => item.id !== id)
    },
  },
})

export const { addTx, removeTx } = batchSlice.actions

const selectAllBatches = (state: RootState): BatchTxsState => {
  return state[batchSlice.name] || initialState
}

export const selectBatchBySafe = createSelector(
  [selectAllBatches, selectChainIdAndSafeAddress],
  (allBatches, [chainId, safeAddress]): DraftBatchItem[] => {
    return allBatches[chainId]?.[safeAddress] || []
  },
)
</file>

<file path="src/store/broadcast.ts">
import type { Store } from 'redux'
import type { Middleware } from '@reduxjs/toolkit'
import type { RootState } from '@/store'

const BC_NAME = 'SAFE__store-updates'
const tabId = Math.random().toString(32).slice(2)
let broadcast: BroadcastChannel | undefined

export const broadcastState = <K extends keyof RootState>(sliceNames: K[]): Middleware<{}, RootState> => {
  return () => (next) => (action: unknown) => {
    const result = next(action)

    // Broadcast actions that aren't being already broadcasted
    if (typeof action === 'object' && action !== null) {
      const actionObj = action as { _isBroadcasted?: boolean; type?: string }
      if (!actionObj._isBroadcasted && actionObj.type) {
        const sliceType = actionObj.type.split('/')[0]
        if (sliceNames.includes(sliceType as K)) {
          broadcast?.postMessage({ action, tabId })
        }
      }
    }

    return result
  }
}

export const listenToBroadcast = (store: Store<RootState>) => {
  broadcast = typeof BroadcastChannel !== 'undefined' ? new BroadcastChannel(BC_NAME) : undefined

  broadcast?.addEventListener('message', ({ data }) => {
    if (data.tabId !== tabId) {
      store.dispatch({ ...data.action, _isBroadcasted: true })
    }
  })
}
</file>

<file path="src/store/chainsSlice.ts">
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { createSelector } from '@reduxjs/toolkit'
import type { RootState } from '.'
import { makeLoadableSlice } from './common'

const initialState: ChainInfo[] = []

const { slice, selector } = makeLoadableSlice('chains', initialState)

export const chainsSlice = slice
export const selectChains = selector

export const selectChainById = createSelector(
  [selectChains, (_: RootState, chainId: string) => chainId],
  (chains, chainId) => {
    return chains.data.find((item: ChainInfo) => item.chainId === chainId)
  },
)
</file>

<file path="src/store/common.ts">
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'
import type { RootState } from '@/store/index'

export type Loadable<T> = {
  data: T
  loading: boolean
  error?: string
}

export const makeLoadableSlice = <N extends string, T>(name: N, data: T) => {
  type SliceState = Loadable<T>

  const initialState: SliceState = {
    data,
    loading: false,
  }

  const slice = createSlice({
    name,
    initialState,
    reducers: {
      set: (_, { payload }: PayloadAction<Loadable<T | undefined>>): SliceState => ({
        ...payload,
        data: payload.data ?? initialState.data, // fallback to initialState.data
      }),
    },
  })

  const selector = (state: Record<N, SliceState>): SliceState => state[name]

  return {
    slice,
    selector,
  }
}

// Memoized selector for chainId and safeAddress
export const selectChainIdAndSafeAddress = createSelector(
  [(_: RootState, chainId: string) => chainId, (_: RootState, _chainId: string, safeAddress: string) => safeAddress],
  (chainId, safeAddress) => [chainId, safeAddress] as const,
)

// Memoized selector for safeAddress
export const selectSafeAddress = createSelector(
  [(_: RootState, safeAddress: string) => safeAddress],
  (safeAddress) => [safeAddress] as const,
)
</file>

<file path="src/store/index.ts">
import {
  configureStore,
  combineReducers,
  createListenerMiddleware,
  type ThunkAction,
  type Action,
  type Middleware,
  type EnhancedStore,
  type ThunkDispatch,
} from '@reduxjs/toolkit'
import { useDispatch, useSelector, type TypedUseSelectorHook } from 'react-redux'
import merge from 'lodash/merge'
import { IS_PRODUCTION } from '@/config/constants'
import { getPreloadedState, persistState } from './persistStore'
import { broadcastState, listenToBroadcast } from './broadcast'
import {
  cookiesAndTermsSlice,
  cookiesAndTermsInitialState,
  safeMessagesListener,
  swapOrderListener,
  swapOrderStatusListener,
  txHistoryListener,
  txQueueListener,
  authListener,
} from './slices'
import * as slices from './slices'
import * as hydrate from './useHydrateStore'
import { ofacApi } from '@/store/api/ofac'
import { safePassApi } from './api/safePass'
import { version as termsVersion } from '@/markdown/terms/version'
import { cgwClient, setBaseUrl } from '@safe-global/store/gateway/cgwClient'
import { GATEWAY_URL } from '@/config/gateway'
import { setupListeners } from '@reduxjs/toolkit/query'

const rootReducer = combineReducers({
  [slices.chainsSlice.name]: slices.chainsSlice.reducer,
  [slices.safeInfoSlice.name]: slices.safeInfoSlice.reducer,
  [slices.balancesSlice.name]: slices.balancesSlice.reducer,
  [slices.sessionSlice.name]: slices.sessionSlice.reducer,
  [slices.txHistorySlice.name]: slices.txHistorySlice.reducer,
  [slices.txQueueSlice.name]: slices.txQueueSlice.reducer,
  [slices.swapOrderSlice.name]: slices.swapOrderSlice.reducer,
  [slices.addressBookSlice.name]: slices.addressBookSlice.reducer,
  [slices.notificationsSlice.name]: slices.notificationsSlice.reducer,
  [slices.pendingTxsSlice.name]: slices.pendingTxsSlice.reducer,
  [slices.addedSafesSlice.name]: slices.addedSafesSlice.reducer,
  [slices.settingsSlice.name]: slices.settingsSlice.reducer,
  [slices.cookiesAndTermsSlice.name]: slices.cookiesAndTermsSlice.reducer,
  [slices.popupSlice.name]: slices.popupSlice.reducer,
  [slices.spendingLimitSlice.name]: slices.spendingLimitSlice.reducer,
  [slices.safeAppsSlice.name]: slices.safeAppsSlice.reducer,
  [slices.safeMessagesSlice.name]: slices.safeMessagesSlice.reducer,
  [slices.pendingSafeMessagesSlice.name]: slices.pendingSafeMessagesSlice.reducer,
  [slices.batchSlice.name]: slices.batchSlice.reducer,
  [slices.undeployedSafesSlice.name]: slices.undeployedSafesSlice.reducer,
  [slices.swapParamsSlice.name]: slices.swapParamsSlice.reducer,
  [slices.visitedSafesSlice.name]: slices.visitedSafesSlice.reducer,
  [slices.orderByPreferenceSlice.name]: slices.orderByPreferenceSlice.reducer,
  [ofacApi.reducerPath]: ofacApi.reducer,
  [safePassApi.reducerPath]: safePassApi.reducer,
  [slices.gatewayApi.reducerPath]: slices.gatewayApi.reducer,
  [cgwClient.reducerPath]: cgwClient.reducer,
  [slices.authSlice.reducerPath]: slices.authSlice.reducer,
})

const persistedSlices: (keyof Partial<RootState>)[] = [
  slices.sessionSlice.name,
  slices.addressBookSlice.name,
  slices.pendingTxsSlice.name,
  slices.addedSafesSlice.name,
  slices.settingsSlice.name,
  slices.cookiesAndTermsSlice.name,
  slices.safeAppsSlice.name,
  slices.pendingSafeMessagesSlice.name,
  slices.batchSlice.name,
  slices.undeployedSafesSlice.name,
  slices.swapParamsSlice.name,
  slices.swapOrderSlice.name,
  slices.visitedSafesSlice.name,
  slices.orderByPreferenceSlice.name,
  slices.authSlice.name,
]

export const getPersistedState = () => {
  return getPreloadedState(persistedSlices)
}

export const listenerMiddlewareInstance = createListenerMiddleware<RootState>()

const middleware: Middleware<{}, RootState>[] = [
  persistState(persistedSlices),
  broadcastState(persistedSlices),
  listenerMiddlewareInstance.middleware,
  ofacApi.middleware,
  safePassApi.middleware,
  slices.gatewayApi.middleware,
]

const listeners = [
  safeMessagesListener,
  txHistoryListener,
  txQueueListener,
  swapOrderListener,
  swapOrderStatusListener,
  authListener,
]

export const _hydrationReducer: typeof rootReducer = (state, action) => {
  if (action.type === hydrate.HYDRATE_ACTION) {
    /**
     * When changing the schema of a Redux slice, previously stored data in LS might become incompatible.
     * To avoid this, we should always migrate the data on a case-by-case basis in the corresponding slice.
     * However, as a catch-all measure, we attempt to merge the stored data with the initial Redux state,
     * so that any newly added properties in the initial state are preserved, and existing properties are taken from the LS.
     *
     * @see https://lodash.com/docs/4.17.15#merge
     */
    const nextState = merge({}, state, action.payload) as RootState

    // Check if termsVersion matches
    if (nextState[cookiesAndTermsSlice.name] && nextState[cookiesAndTermsSlice.name].termsVersion !== termsVersion) {
      // Reset consent
      nextState[cookiesAndTermsSlice.name] = {
        ...cookiesAndTermsInitialState,
      }
    }

    return nextState
  }
  return rootReducer(state, action) as RootState
}

type MakeStoreOptions = {
  skipBroadcast?: boolean
}
export const makeStore = (
  initialState?: Partial<RootState>,
  options?: MakeStoreOptions,
): EnhancedStore<RootState, Action> => {
  setBaseUrl(GATEWAY_URL)

  const store = configureStore({
    reducer: _hydrationReducer,
    middleware: (getDefaultMiddleware) => {
      listeners.forEach((listener) => listener(listenerMiddlewareInstance))
      return getDefaultMiddleware({ serializableCheck: false }).concat(cgwClient.middleware).concat(middleware)
    },
    devTools: !IS_PRODUCTION,
    preloadedState: initialState,
  })

  if (!options?.skipBroadcast) {
    listenToBroadcast(store)
  }

  setupListeners(store.dispatch)

  return store
}

export type RootState = ReturnType<typeof rootReducer>
export type AppDispatch = ThunkDispatch<RootState, unknown, Action> & EnhancedStore<RootState, Action>['dispatch']
export type AppThunk<ReturnType = void> = ThunkAction<ReturnType, RootState, unknown, Action>

export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector

export const useHydrateStore = hydrate.useHydrateStore
</file>

<file path="src/store/notificationsSlice.ts">
import { createSlice, type PayloadAction } from '@reduxjs/toolkit'
import type { AlertColor } from '@mui/material'
import type { AppThunk, RootState } from '@/store'
import type { LinkProps } from 'next/link'

export type Notification = {
  id: string
  message: string
  detailedMessage?: string
  title?: string
  groupKey: string
  variant: AlertColor
  timestamp: number
  isDismissed?: boolean
  isRead?: boolean
  link?: { href: LinkProps['href']; title: string } | { onClick: () => void; title: string }
  onClose?: () => void
}

export type NotificationState = Notification[]

const initialState: NotificationState = []

export const notificationsSlice = createSlice({
  name: 'notifications',
  initialState,
  reducers: {
    enqueueNotification: (state, { payload }: PayloadAction<Notification>): NotificationState => {
      return [...state, payload]
    },
    closeNotification: (state, { payload }: PayloadAction<{ id: string }>): NotificationState => {
      return state.map((notification) => {
        return notification.id === payload.id ? { ...notification, isDismissed: true } : notification
      })
    },
    closeByGroupKey: (state, { payload }: PayloadAction<{ groupKey: string }>): NotificationState => {
      return state.map((notification) => {
        return notification.groupKey === payload.groupKey ? { ...notification, isDismissed: true } : notification
      })
    },
    deleteNotification: (state, { payload }: PayloadAction<Notification>) => {
      return state.filter((notification) => notification.id !== payload.id)
    },
    deleteAllNotifications: (): NotificationState => {
      return []
    },
    readNotification: (state, { payload }: PayloadAction<{ id: string }>): NotificationState => {
      return state.map((notification) => {
        return notification.id === payload.id ? { ...notification, isRead: true } : notification
      })
    },
  },
})

export const { closeNotification, closeByGroupKey, deleteNotification, deleteAllNotifications, readNotification } =
  notificationsSlice.actions

export const showNotification = (payload: Omit<Notification, 'id' | 'timestamp'>): AppThunk<string> => {
  return (dispatch) => {
    const id = Math.random().toString(32).slice(2)

    const notification: Notification = {
      ...payload,
      id,
      timestamp: new Date().getTime(),
    }

    dispatch(notificationsSlice.actions.enqueueNotification(notification))

    return id
  }
}

export const selectNotifications = (state: RootState): NotificationState => {
  return state[notificationsSlice.name]
}
</file>

<file path="src/store/orderByPreferenceSlice.ts">
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import type { RootState } from '@/store'

export enum OrderByOption {
  NAME = 'name',
  LAST_VISITED = 'lastVisited',
}

export type OrderByPreferenceState = { orderBy: OrderByOption }

const initialState: OrderByPreferenceState = { orderBy: OrderByOption.LAST_VISITED }

export const orderByPreferenceSlice = createSlice({
  name: 'orderByPreference',
  initialState,
  reducers: {
    setOrderByPreference: (state, { payload }: PayloadAction<{ orderBy: OrderByOption }>) => {
      const { orderBy } = payload
      state.orderBy = orderBy
    },
  },
})

export const { setOrderByPreference } = orderByPreferenceSlice.actions

export const selectOrderByPreference = (state: RootState): OrderByPreferenceState => {
  return state[orderByPreferenceSlice.name] || initialState
}
</file>

<file path="src/store/pendingSafeMessagesSlice.ts">
import { createSelector, createSlice } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'

import type { RootState } from '.'

export type PendingSafeMessagesState =
  | {
      [messageHash: string]: true
    }
  | Record<string, never>

const initialState: PendingSafeMessagesState = {}

export const pendingSafeMessagesSlice = createSlice({
  name: 'pendingSafeMessages',
  initialState,
  reducers: {
    setPendingSafeMessage: (state, action: PayloadAction<string>) => {
      state[action.payload] = true
    },
    clearPendingSafeMessage: (state, action: PayloadAction<string>) => {
      delete state[action.payload]
    },
  },
})

export const { setPendingSafeMessage, clearPendingSafeMessage } = pendingSafeMessagesSlice.actions

export const selectPendingSafeMessages = (state: RootState): PendingSafeMessagesState => {
  return state[pendingSafeMessagesSlice.name]
}

export const selectPendingSafeMessageByHash = createSelector(
  [selectPendingSafeMessages, (_: RootState, messageHash: string) => messageHash],
  (pendingSignedMessages, messageHash) => !!pendingSignedMessages[messageHash],
)
</file>

<file path="src/store/pendingTxsSlice.ts">
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'

import type { RootState } from '@/store'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { selectChainIdAndSafeAddress } from '@/store/common'

export enum PendingStatus {
  SIGNING = 'SIGNING',
  NESTED_SIGNING = 'NESTED_SIGNING',
  SUBMITTING = 'SUBMITTING',
  PROCESSING = 'PROCESSING',
  RELAYING = 'RELAYING',
  INDEXING = 'INDEXING',
}

export enum PendingTxType {
  CUSTOM_TX = 'CUSTOM',
  SAFE_TX = 'SAFE_TX',
}

export type PendingTxCommonProps = {
  chainId: string
  safeAddress: string
  nonce: number
  groupKey?: string
}

type PendingSigningTx = PendingTxCommonProps & {
  status: PendingStatus.SIGNING
  signerAddress: string
}

type PendingSubmittingTx = PendingTxCommonProps & {
  status: PendingStatus.SUBMITTING
}

export type PendingProcessingTx = PendingTxCommonProps &
  (
    | {
        txHash: string
        submittedAt: number
        signerNonce: number
        signerAddress: string
        gasLimit?: string | number | undefined
        status: PendingStatus.PROCESSING
        txType: PendingTxType.SAFE_TX
      }
    | {
        txHash: string
        submittedAt: number
        signerNonce: number
        signerAddress: string
        gasLimit?: string | number | undefined
        data: string
        to: string
        status: PendingStatus.PROCESSING
        txType: PendingTxType.CUSTOM_TX
      }
  )

type PendingRelayingTx = PendingTxCommonProps & {
  taskId: string
  status: PendingStatus.RELAYING
}

type PendingIndexingTx = PendingTxCommonProps & {
  status: PendingStatus.INDEXING
  txHash?: string
}

type PendingNestedSigningTx = PendingTxCommonProps & {
  signerAddress: string
  txHashOrParentSafeTxHash: string
  status: PendingStatus.NESTED_SIGNING
}

export type PendingTx =
  | PendingSigningTx
  | PendingSubmittingTx
  | PendingProcessingTx
  | PendingRelayingTx
  | PendingIndexingTx
  | PendingNestedSigningTx

export type PendingTxsState = {
  [txId: string]: PendingTx
}

const initialState: PendingTxsState = {}

export const pendingTxsSlice = createSlice({
  name: 'pendingTxs',
  initialState,
  reducers: {
    setPendingTx: (state, action: PayloadAction<PendingTx & { txId: string }>) => {
      const { txId, ...pendingTx } = action.payload
      state[txId] = pendingTx
    },
    clearPendingTx: (state, action: PayloadAction<{ txId: string }>) => {
      delete state[action.payload.txId]
    },
  },
})

export const { setPendingTx, clearPendingTx } = pendingTxsSlice.actions

export const selectPendingTxs = (state: RootState): PendingTxsState => {
  return state[pendingTxsSlice.name]
}

export const selectPendingTxById = createSelector(
  [selectPendingTxs, (_: RootState, txId: string) => txId],
  (pendingTxs, txId) => pendingTxs[txId],
)

export const selectPendingTxIdsBySafe = createSelector(
  [selectPendingTxs, selectChainIdAndSafeAddress],
  (pendingTxs, [chainId, safeAddress]) => {
    return Object.keys(pendingTxs).filter(
      (id) => pendingTxs[id].chainId === chainId && sameAddress(pendingTxs[id].safeAddress, safeAddress),
    )
  },
)
</file>

<file path="src/store/persistStore.ts">
import type { Middleware } from '@reduxjs/toolkit'

import local from '@/services/local-storage/local'
import type { RootState } from '@/store'

export const getPreloadedState = <K extends keyof RootState>(sliceNames: K[]): Partial<RootState> => {
  return sliceNames.reduce<Partial<RootState>>((preloadedState, sliceName) => {
    const sliceState = local.getItem<RootState[K]>(sliceName as string)

    if (sliceState) {
      preloadedState[sliceName] = sliceState
    }

    return preloadedState
  }, {})
}

export const persistState = <K extends keyof RootState>(sliceNames: K[]): Middleware<{}, RootState> => {
  return (store) => (next) => (action) => {
    const result = next(action)

    if (typeof action === 'object' && action !== null && 'type' in action) {
      // No need to persist broadcasted actions because they are persisted in another tab
      if ('_isBroadcasted' in action && action._isBroadcasted) return result

      const sliceType = (action as { type: string }).type.split('/')[0]
      const name = sliceNames.find((slice) => slice === sliceType)

      if (name) {
        const state = store.getState()
        const sliceState = state[name]

        if (sliceState) {
          local.setItem(name as string, sliceState)
        } else {
          local.removeItem(name as string)
        }
      }
    }

    return result
  }
}
</file>

<file path="src/store/popupSlice.ts">
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import type { CookieAndTermType } from './cookiesAndTermsSlice'
import type { RootState } from '.'

export enum PopupType {
  COOKIES = 'cookies',
  OUTREACH = 'outreach',
}

type PopupState = {
  [PopupType.COOKIES]: {
    open: boolean
    warningKey?: CookieAndTermType
  }
  [PopupType.OUTREACH]: {
    open: boolean
  }
}

const initialState: PopupState = {
  [PopupType.COOKIES]: {
    open: false,
  },
  [PopupType.OUTREACH]: {
    open: false,
  },
}

export const popupSlice = createSlice({
  name: 'popups',
  initialState,
  reducers: {
    openCookieBanner: (state, { payload }: PayloadAction<{ warningKey?: CookieAndTermType }>) => {
      state[PopupType.COOKIES] = {
        ...payload,
        open: true,
      }
    },
    closeCookieBanner: (state) => {
      state[PopupType.COOKIES] = { open: false }
    },
    openOutreachBanner: (state) => {
      state[PopupType.OUTREACH] = { open: true }
    },
    closeOutreachBanner: (state) => {
      state[PopupType.OUTREACH] = { open: false }
    },
  },
})

export const { openCookieBanner, closeCookieBanner, openOutreachBanner, closeOutreachBanner } = popupSlice.actions

export const selectCookieBanner = (state: RootState) => state[popupSlice.name][PopupType.COOKIES]
export const selectOutreachBanner = (state: RootState) => state[popupSlice.name][PopupType.OUTREACH]
</file>

<file path="src/store/safeAppsSlice.ts">
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSelector } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import type { SafeAppData } from '@safe-global/safe-gateway-typescript-sdk'
import type { RootState } from '@/store'

type SafeAppsPerChain = {
  pinned: Array<SafeAppData['id']>
  opened: Array<SafeAppData['id']>
}

export type SafeAppsState = {
  [chainId: string]: SafeAppsPerChain
}

const initialState: SafeAppsState = {}

export const safeAppsSlice = createSlice({
  name: 'safeApps',
  initialState,
  reducers: {
    setPinned: (state, { payload }: PayloadAction<{ chainId: string; pinned: SafeAppsPerChain['pinned'] }>) => {
      const { pinned, chainId } = payload

      // Initialise chain-specific state
      state[chainId] ??= { pinned: [], opened: [] }
      // If apps were opened before any were pinned, no pinned array exists
      state[chainId].pinned ??= []

      state[chainId].pinned = pinned
    },
    markOpened: (state, { payload }: PayloadAction<{ chainId: string; id: SafeAppData['id'] }>) => {
      const { id, chainId } = payload

      // Initialise chain-specific state
      state[chainId] ??= { pinned: [], opened: [] }
      // If apps were pinned before any were opened, no opened array exists
      state[chainId].opened ??= []

      if (!state[chainId].opened.includes(id)) {
        state[chainId].opened.push(id)
      }
    },
    setSafeApps: (_, { payload }: PayloadAction<SafeAppsState>) => {
      // We must return as we are overwriting the entire state
      return payload
    },
  },
})

export const { setPinned, markOpened } = safeAppsSlice.actions

export const selectSafeApps = (state: RootState): SafeAppsState => {
  return state[safeAppsSlice.name]
}

const selectSafeAppsPerChain = createSelector(
  [selectSafeApps, (_: RootState, chainId: string) => chainId],
  (safeApps, chainId) => {
    return safeApps[chainId]
  },
)

export const selectPinned = createSelector([selectSafeAppsPerChain], (safeAppsPerChain) => {
  return safeAppsPerChain?.pinned || []
})

export const selectOpened = createSelector([selectSafeAppsPerChain], (safeAppsPerChain) => {
  return safeAppsPerChain?.opened || []
})
</file>

<file path="src/store/safeInfoSlice.ts">
import { makeLoadableSlice } from './common'
import type { ExtendedSafeInfo } from '@safe-global/store/slices/SafeInfo/types'

const { slice, selector } = makeLoadableSlice('safeInfo', undefined as ExtendedSafeInfo | undefined)

export const safeInfoSlice = slice
export const selectSafeInfo = selector
</file>

<file path="src/store/safeMessagesSlice.ts">
import type { MessagePage } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import type { listenerMiddlewareInstance } from '.'

import { safeMsgDispatch, SafeMsgEvent } from '@/services/safe-messages/safeMsgEvents'
import { isSafeMessageListItem } from '@/utils/safe-message-guards'
import { makeLoadableSlice } from '@/store/common'
import { selectPendingSafeMessages } from '@/store/pendingSafeMessagesSlice'

const { slice, selector } = makeLoadableSlice('safeMessages', undefined as MessagePage | undefined)

export const safeMessagesSlice = slice
export const selectSafeMessages = selector

export const safeMessagesListener = (listenerMiddleware: typeof listenerMiddlewareInstance) => {
  listenerMiddleware.startListening({
    actionCreator: safeMessagesSlice.actions.set,
    effect: (action, listenerApi) => {
      if (!action.payload.data) {
        return
      }

      const pendingMsgs = selectPendingSafeMessages(listenerApi.getState())

      for (const result of action.payload.data.results) {
        if (!isSafeMessageListItem(result)) {
          continue
        }

        const { messageHash } = result
        if (pendingMsgs[messageHash]) {
          safeMsgDispatch(SafeMsgEvent.UPDATED, { messageHash })
        }
      }
    },
  })
}
</file>

<file path="src/store/sessionSlice.ts">
import { createSelector, createSlice, type PayloadAction } from '@reduxjs/toolkit'
import type { RootState } from '.'

type SessionState = {
  lastChainId: string
  lastSafeAddress: { [chainId: string]: string }
}

const initialState: SessionState = {
  lastChainId: '',
  lastSafeAddress: {},
}

export const sessionSlice = createSlice({
  name: 'session',
  initialState,
  reducers: {
    setLastChainId: (state, action: PayloadAction<SessionState['lastChainId']>) => {
      state.lastChainId = action.payload
    },
    setLastSafeAddress: (
      state,
      action: PayloadAction<{
        chainId: string
        safeAddress: string
      }>,
    ) => {
      const { chainId, safeAddress } = action.payload
      state.lastSafeAddress[chainId] = safeAddress
    },
  },
})

export const { setLastChainId, setLastSafeAddress } = sessionSlice.actions

export const selectSession = (state: RootState): SessionState => {
  return state[sessionSlice.name]
}

export const selectLastSafeAddress = createSelector(
  [selectSession, (_, chainId: string) => chainId],
  (session, chainId): string | undefined => {
    return session.lastSafeAddress[chainId]
  },
)
</file>

<file path="src/store/settingsSlice.ts">
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSelector, createSlice } from '@reduxjs/toolkit'
import merge from 'lodash/merge'

import type { RootState } from '@/store'
import isEqual from 'lodash/isEqual'
import type { EnvState } from '@safe-global/store/settingsSlice'

export enum TOKEN_LISTS {
  TRUSTED = 'TRUSTED',
  ALL = 'ALL',
}

export type SettingsState = {
  currency: string

  hiddenTokens: {
    [chainId: string]: string[]
  }

  tokenList: TOKEN_LISTS

  hideSuspiciousTransactions?: boolean

  shortName: {
    copy: boolean
    qr: boolean
  }
  theme: {
    darkMode?: boolean
  }
  env: EnvState
  signing: {
    onChainSigning: boolean
    blindSigning: boolean
  }
  transactionExecution: boolean
}

export const initialState: SettingsState = {
  currency: 'usd',

  tokenList: TOKEN_LISTS.TRUSTED,

  hiddenTokens: {},

  hideSuspiciousTransactions: true,

  shortName: {
    copy: true,
    qr: true,
  },
  theme: {},
  env: {
    rpc: {},
    tenderly: {
      url: '',
      accessToken: '',
    },
  },
  signing: {
    onChainSigning: false,
    blindSigning: false,
  },
  transactionExecution: true,
}

export const settingsSlice = createSlice({
  name: 'settings',
  initialState,
  reducers: {
    setCurrency: (state, { payload }: PayloadAction<SettingsState['currency']>) => {
      state.currency = payload
    },
    setCopyShortName: (state, { payload }: PayloadAction<SettingsState['shortName']['copy']>) => {
      state.shortName.copy = payload
    },
    setQrShortName: (state, { payload }: PayloadAction<SettingsState['shortName']['qr']>) => {
      state.shortName.qr = payload
    },
    setTransactionExecution: (state, { payload }: PayloadAction<SettingsState['transactionExecution']>) => {
      state.transactionExecution = payload
    },
    setDarkMode: (state, { payload }: PayloadAction<SettingsState['theme']['darkMode']>) => {
      state.theme.darkMode = payload
    },
    setHiddenTokensForChain: (state, { payload }: PayloadAction<{ chainId: string; assets: string[] }>) => {
      const { chainId, assets } = payload
      state.hiddenTokens[chainId] = assets
    },
    setTokenList: (state, { payload }: PayloadAction<SettingsState['tokenList']>) => {
      state.tokenList = payload
    },
    hideSuspiciousTransactions: (state, { payload }: PayloadAction<boolean>) => {
      state.hideSuspiciousTransactions = payload
    },
    setRpc: (state, { payload }: PayloadAction<{ chainId: string; rpc: string }>) => {
      const { chainId, rpc } = payload
      if (rpc) {
        state.env.rpc[chainId] = rpc
      } else {
        delete state.env.rpc[chainId]
      }
    },
    setTenderly: (state, { payload }: PayloadAction<EnvState['tenderly']>) => {
      state.env.tenderly = merge({}, state.env.tenderly, payload)
    },
    setOnChainSigning: (state, { payload }: PayloadAction<boolean>) => {
      state.signing.onChainSigning = payload
    },
    setBlindSigning: (state, { payload }: PayloadAction<boolean>) => {
      state.signing.blindSigning = payload
    },
    setSettings: (_, { payload }: PayloadAction<SettingsState>) => {
      // We must return as we are overwriting the entire state
      // Preserve default nested settings if importing without
      return merge({}, initialState, payload)
    },
  },
})

export const {
  setCurrency,
  setCopyShortName,
  setQrShortName,
  setDarkMode,
  setHiddenTokensForChain,
  setTokenList,
  hideSuspiciousTransactions,
  setRpc,
  setTenderly,
  setOnChainSigning,
  setTransactionExecution,
  setBlindSigning,
} = settingsSlice.actions

export const selectSettings = (state: RootState): SettingsState => state[settingsSlice.name]

export const selectCurrency = (state: RootState): SettingsState['currency'] => {
  return state[settingsSlice.name].currency || initialState.currency
}

export const selectTokenList = (state: RootState): SettingsState['tokenList'] => {
  return state[settingsSlice.name].tokenList || initialState.tokenList
}

export const selectHiddenTokensPerChain = createSelector(
  [selectSettings, (_, chainId) => chainId],
  (settings, chainId) => {
    return settings.hiddenTokens?.[chainId] || []
  },
)

export const selectRpc = createSelector(selectSettings, (settings) => settings.env.rpc)

export const selectTenderly = createSelector(selectSettings, (settings) => settings.env.tenderly)

export const isEnvInitialState = createSelector([selectSettings, (_, chainId) => chainId], (settings, chainId) => {
  return isEqual(settings.env.tenderly, initialState.env.tenderly) && !settings.env.rpc[chainId]
})

export const selectOnChainSigning = createSelector(selectSettings, (settings) => settings.signing.onChainSigning)
export const selectBlindSigning = createSelector(selectSettings, (settings) => settings.signing.blindSigning)
</file>

<file path="src/store/slices.ts">
export * from './chainsSlice'
export * from './safeInfoSlice'
export * from './balancesSlice'
export * from './sessionSlice'
export * from './txHistorySlice'
export * from './txQueueSlice'
export * from './addressBookSlice'
export * from './notificationsSlice'
export * from './pendingTxsSlice'
export * from './addedSafesSlice'
export * from './settingsSlice'
export * from './cookiesAndTermsSlice'
export * from './popupSlice'
export * from './spendingLimitsSlice'
export * from './safeAppsSlice'
export * from './safeMessagesSlice'
export * from './pendingSafeMessagesSlice'
export * from './batchSlice'
export * from '@/features/counterfactual/store/undeployedSafesSlice'
export * from '@/features/swap/store/swapParamsSlice'
export * from './swapOrderSlice'
export * from './api/gateway'
export * from './api/gateway/safeOverviews'
export * from './visitedSafesSlice'
export * from './orderByPreferenceSlice'
export * from './authSlice'
</file>

<file path="src/store/spendingLimitsSlice.ts">
import { createSelector } from '@reduxjs/toolkit'
import { makeLoadableSlice } from './common'

export type SpendingLimitState = {
  beneficiary: string
  token: {
    address: string
    symbol: string
    decimals?: number | null
    logoUri?: string
  }
  amount: string
  nonce: string
  resetTimeMin: string
  lastResetMin: string
  spent: string
}

const initialState: SpendingLimitState[] = []

const { slice, selector } = makeLoadableSlice('spendingLimits', initialState)

export const spendingLimitSlice = slice

export const selectSpendingLimits = createSelector(selector, (spendingLimits) => spendingLimits.data)
export const selectSpendingLimitsLoading = createSelector(selector, (spendingLimits) => spendingLimits.loading)
</file>

<file path="src/store/swapOrderSlice.ts">
import type { listenerMiddlewareInstance } from '@/store'
import { createSelector, createSlice } from '@reduxjs/toolkit'
import type { OrderStatuses } from '@safe-global/safe-gateway-typescript-sdk'
import type { RootState } from '@/store'
import { isSwapOrderTxInfo, isTransactionListItem } from '@/utils/transaction-guards'
import { txHistorySlice } from '@/store/txHistorySlice'
import { showNotification } from '@/store/notificationsSlice'
import { selectSafeInfo } from '@/store/safeInfoSlice'
import { selectChainById } from '@/store/chainsSlice'
import { getTxLink } from '@/utils/tx-link'

type AllStatuses = OrderStatuses | 'created'
type Order = {
  orderUid: string
  status: AllStatuses
  txId?: string
}

type SwapOrderState = {
  [orderUid: string]: Order
}

const initialState: SwapOrderState = {}

const slice = createSlice({
  name: 'swapOrders',
  initialState,
  reducers: {
    setSwapOrder: (state, { payload }: { payload: Order }): SwapOrderState => {
      return {
        ...state,
        [payload.orderUid]: {
          ...state[payload.orderUid],
          ...payload,
        },
      }
    },
    deleteSwapOrder: (state, { payload }: { payload: string }): SwapOrderState => {
      const newState = { ...state }
      delete newState[payload]
      return newState
    },
  },
})

export const { setSwapOrder, deleteSwapOrder } = slice.actions
const selector = (state: RootState) => state[slice.name]
export const swapOrderSlice = slice
export const selectAllSwapOrderStatuses = selector

export const selectSwapOrderStatus = createSelector(
  [selectAllSwapOrderStatuses, (_, uid: string) => uid],
  (allOrders, uid): undefined | AllStatuses => {
    return allOrders ? allOrders[uid]?.status : undefined
  },
)

const groupKey = 'swap-order-status'
/**
 * Listen for changes in the swap order status and determines if a notification should be shown
 *
 * Some gotchas:
 * If the status of an order is created, presignaturePending, open - we always display a notification.
 * Here it doesn't matter if the order was started through the UI or the gateway returned that order on a new browser instance.
 *
 * For fulfilled, expired, cancelled - we only display a notification if the old status is not undefined.
 * Why? Because if the status is undefined, it means that the order was just fetched from the gateway, and
 * it was already processed and there is no need to show a notification. If the status is != undefined, it means
 * that the user has started the swap through the UI (or has continued it from a previous state), and we should show a notification.
 *
 * @param listenerMiddleware
 */
export const swapOrderStatusListener = (listenerMiddleware: typeof listenerMiddlewareInstance) => {
  listenerMiddleware.startListening({
    actionCreator: slice.actions.setSwapOrder,
    effect: (action, listenerApi) => {
      const { dispatch } = listenerApi
      const swapOrder = action.payload
      const oldStatus = selectSwapOrderStatus(listenerApi.getOriginalState(), swapOrder.orderUid)
      const newStatus = swapOrder.status

      if (oldStatus === newStatus || newStatus === undefined) {
        return
      }
      const safeInfo = selectSafeInfo(listenerApi.getState())

      let link = undefined
      if (swapOrder.txId && safeInfo.data?.chainId && safeInfo.data?.address) {
        const chainInfo = selectChainById(listenerApi.getState(), safeInfo.data?.chainId)
        if (chainInfo !== undefined) {
          link = getTxLink(swapOrder.txId, chainInfo, safeInfo.data?.address.value)
        }
      }

      switch (newStatus) {
        case 'created':
          dispatch(
            showNotification({
              title: 'Order created',
              message:
                safeInfo.data?.threshold === 1
                  ? 'Waiting for the transaction to be executed'
                  : 'Waiting for confirmation from signers of your Safe',
              groupKey,
              variant: 'info',
              link,
            }),
          )

          break
        case 'presignaturePending':
          dispatch(
            showNotification({
              title: 'Order waiting for signature',
              message: 'Waiting for confirmation from signers of your Safe',
              groupKey,
              variant: 'info',
              link,
            }),
          )
          break
        case 'open':
          dispatch(
            showNotification({
              title: 'Order transaction confirmed',
              message: 'Waiting for order execution by the CoW Protocol',
              groupKey,
              variant: 'info',
              link,
            }),
          )
          break
        case 'fulfilled':
          dispatch(slice.actions.deleteSwapOrder(swapOrder.orderUid))
          if (oldStatus === undefined) {
            return
          }
          dispatch(
            showNotification({
              title: 'Order executed',
              message: 'Your order has been successful',
              groupKey,
              variant: 'success',
              link,
            }),
          )
          break
        case 'expired':
          dispatch(slice.actions.deleteSwapOrder(swapOrder.orderUid))
          if (oldStatus === undefined) {
            return
          }
          dispatch(
            showNotification({
              title: 'Order expired',
              message: 'Your order has reached the expiry time and has become invalid',
              groupKey,
              variant: 'warning',
              link,
            }),
          )
          break
        case 'cancelled':
          dispatch(slice.actions.deleteSwapOrder(swapOrder.orderUid))
          if (oldStatus === undefined) {
            return
          }
          dispatch(
            showNotification({
              title: 'Order cancelled',
              message: 'Your order has been cancelled',
              groupKey,
              variant: 'warning',
              link,
            }),
          )
          break
      }
    },
  })
}

/**
 * Listen for changes in the tx history, check if the transaction is a swap order and update the status of the order
 * @param listenerMiddleware
 */
export const swapOrderListener = (listenerMiddleware: typeof listenerMiddlewareInstance) => {
  listenerMiddleware.startListening({
    actionCreator: txHistorySlice.actions.set,
    effect: (action, listenerApi) => {
      if (!action.payload.data) {
        return
      }

      for (const result of action.payload.data.results) {
        if (!isTransactionListItem(result)) {
          continue
        }

        if (isSwapOrderTxInfo(result.transaction.txInfo)) {
          const swapOrder = result.transaction.txInfo
          const oldStatus = selectSwapOrderStatus(listenerApi.getOriginalState(), swapOrder.uid)

          const finalStatuses: AllStatuses[] = ['fulfilled', 'expired', 'cancelled']
          if (oldStatus === swapOrder.status || (oldStatus === undefined && finalStatuses.includes(swapOrder.status))) {
            continue
          }

          listenerApi.dispatch({
            type: slice.actions.setSwapOrder.type,
            payload: {
              orderUid: swapOrder.uid,
              status: swapOrder.status,
              txId: result.transaction.id,
            },
          })
        }
      }
    },
  })
}
</file>

<file path="src/store/txHistorySlice.ts">
import type { listenerMiddlewareInstance } from '@/store'
import { createSelector } from '@reduxjs/toolkit'
import type { TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import {
  isCreationTxInfo,
  isCustomTxInfo,
  isIncomingTransfer,
  isMultisigExecutionInfo,
  isTransactionListItem,
} from '@/utils/transaction-guards'
import { txDispatch, TxEvent } from '@/services/tx/txEvents'
import { clearPendingTx, selectPendingTxs } from './pendingTxsSlice'
import { makeLoadableSlice } from './common'
import { gatewayApi, makeSafeTag, selectSafeInfo } from './slices'

const { slice, selector } = makeLoadableSlice('txHistory', undefined as TransactionListPage | undefined)

export const txHistorySlice = slice
export const selectTxHistory = selector

export const selectOutgoingTransactions = createSelector(selectTxHistory, (txHistory) => {
  return txHistory.data?.results.filter(isTransactionListItem).filter((tx) => {
    return !isIncomingTransfer(tx.transaction.txInfo) && !isCreationTxInfo(tx.transaction.txInfo)
  })
})

export const txHistoryListener = (listenerMiddleware: typeof listenerMiddlewareInstance) => {
  listenerMiddleware.startListening({
    actionCreator: txHistorySlice.actions.set,
    effect: (action, listenerApi) => {
      if (!action.payload.data) {
        return
      }

      const pendingTxs = selectPendingTxs(listenerApi.getState())

      for (const result of action.payload.data.results) {
        if (!isTransactionListItem(result)) {
          continue
        }

        const pendingTxByNonce = Object.entries(pendingTxs).find(([, pendingTx]) =>
          isMultisigExecutionInfo(result.transaction.executionInfo)
            ? pendingTx.nonce === result.transaction.executionInfo.nonce
            : false,
        )

        if (!pendingTxByNonce) continue

        // Invalidate getOwnedSafe cache as nested Safe was (likely) created
        if (isCustomTxInfo(result.transaction.txInfo)) {
          const method = result.transaction.txInfo.methodName
          const deployedSafe = method === 'createProxyWithNonce'
          const likelyDeployedSafe = method === 'multiSend'

          if (deployedSafe || likelyDeployedSafe) {
            const safe = selectSafeInfo(listenerApi.getState())
            const safeAddress = safe.data?.address?.value
            const chainId = safe.data?.chainId

            if (chainId && safeAddress) {
              listenerApi.dispatch(
                gatewayApi.util.invalidateTags([
                  {
                    type: 'OwnedSafes',
                    id: makeSafeTag(chainId, safeAddress),
                  },
                ]),
              )
            }
          }
        }

        const txId = result.transaction.id

        const [pendingTxId, pendingTx] = pendingTxByNonce

        if (pendingTxId === txId) {
          const txHash = 'txHash' in pendingTx ? pendingTx.txHash : undefined
          txDispatch(TxEvent.SUCCESS, {
            nonce: pendingTx.nonce,
            txId,
            groupKey: pendingTxs[txId].groupKey,
            txHash,
          })
        } else {
          // There is a pending tx with the same nonce as a history tx but their txIds don't match
          listenerApi.dispatch(clearPendingTx({ txId: pendingTxId }))
        }
      }
    },
  })
}
</file>

<file path="src/store/txQueueSlice.ts">
import type { listenerMiddlewareInstance } from '@/store'
import { createSelector } from '@reduxjs/toolkit'
import type { TransactionListPage } from '@safe-global/safe-gateway-typescript-sdk'
import type { RootState } from '@/store'
import { makeLoadableSlice } from './common'
import { isMultisigExecutionInfo, isTransactionListItem } from '@/utils/transaction-guards'
import { PendingStatus, selectPendingTxs } from './pendingTxsSlice'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import { txDispatch, TxEvent } from '@/services/tx/txEvents'

const SIGNING_STATES = [PendingStatus.SIGNING, PendingStatus.NESTED_SIGNING]

const { slice, selector } = makeLoadableSlice('txQueue', undefined as TransactionListPage | undefined)

export const txQueueSlice = slice
export const selectTxQueue = selector

export const selectQueuedTransactions = createSelector(selectTxQueue, (txQueue) => {
  return txQueue.data?.results.filter(isTransactionListItem)
})

export const selectQueuedTransactionsByNonce = createSelector(
  selectQueuedTransactions,
  (_: RootState, nonce?: number) => nonce,
  (queuedTransactions, nonce?: number) => {
    return (queuedTransactions || []).filter((item) => {
      return isMultisigExecutionInfo(item.transaction.executionInfo) && item.transaction.executionInfo.nonce === nonce
    })
  },
)

export const txQueueListener = (listenerMiddleware: typeof listenerMiddlewareInstance) => {
  listenerMiddleware.startListening({
    actionCreator: txQueueSlice.actions.set,
    effect: (action, listenerApi) => {
      if (!action.payload.data) {
        return
      }

      const pendingTxs = selectPendingTxs(listenerApi.getState())

      for (const result of action.payload.data.results) {
        if (!isTransactionListItem(result)) {
          continue
        }

        const txId = result.transaction.id

        const pendingTx = pendingTxs[txId]
        if (!pendingTx || !SIGNING_STATES.includes(pendingTx.status) || !('signerAddress' in pendingTx)) {
          continue
        }

        // The transaction is waiting for a signature of awaitingSigner
        if (
          isMultisigExecutionInfo(result.transaction.executionInfo) &&
          !result.transaction.executionInfo.missingSigners?.some((address) =>
            sameAddress(address.value, pendingTx.signerAddress),
          )
        ) {
          txDispatch(TxEvent.SIGNATURE_INDEXED, { txId })
        }
      }
    },
  })
}
</file>

<file path="src/store/useHydrateStore.ts">
import { useEffect } from 'react'
import { getPersistedState, type makeStore } from '@/store'

export const HYDRATE_ACTION = '@@HYDRATE'

export const useHydrateStore = (store: ReturnType<typeof makeStore>) => {
  useEffect(() => {
    store.dispatch({
      type: HYDRATE_ACTION,
      payload: getPersistedState(),
    })
  }, [store])
}
</file>

<file path="src/store/visitedSafesSlice.ts">
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import type { RootState } from '@/store'

export type VisitedSafesState = {
  [chainId: string]: {
    [safeAddress: string]: {
      lastVisited: number
    }
  }
}

const initialState: VisitedSafesState = {}

export const visitedSafesSlice = createSlice({
  name: 'visitedSafes',
  initialState,
  reducers: {
    upsertVisitedSafe: (
      state,
      { payload }: PayloadAction<{ chainId: string; address: string; lastVisited: number }>,
    ) => {
      const { chainId, address, lastVisited } = payload
      state[chainId] ??= {}
      state[chainId][address] = { lastVisited }
    },
    setVisitedSafes: (_, { payload }: PayloadAction<VisitedSafesState>) => {
      // We must return as we are overwriting the entire state
      return payload
    },
  },
})

export const { upsertVisitedSafe } = visitedSafesSlice.actions

export const selectAllVisitedSafes = (state: RootState): VisitedSafesState => {
  return state[visitedSafesSlice.name] || initialState
}
</file>

<file path="src/stories/Configure.mdx">
import { Meta } from "@storybook/blocks";

export const RightArrow = () => <svg
    viewBox="0 0 14 14"
    width="8px"
    height="14px"
    style={{
      marginLeft: '4px',
      display: 'inline-block',
      shapeRendering: 'inherit',
      verticalAlign: 'middle',
      fill: 'currentColor',
      'path fill': 'currentColor'
    }}
>
  <path d="m11.1 7.35-5.5 5.5a.5.5 0 0 1-.7-.7L10.04 7 4.9 1.85a.5.5 0 1 1 .7-.7l5.5 5.5c.2.2.2.5 0 .7Z" />
</svg>

<Meta title="Documentation" />

<div className="sb-container">
  <div className='sb-section-title'>
    # Getting started

    Storybook is a tool for builidng UI components and pages in isolation. It allows us to write, test and document UI components in isolation.

    Storybook is installed as a dependency in the project and can be started by running the following command:

    ```
    yarn storybook
    ```

    This will start the Storybook server and open the browser to the Storybook UI (by default http://localhost:6006).
  </div>


</div>

<style>
  {`
  .sb-container {
    margin-bottom: 48px;
  }

  .sb-section {
    width: 100%;
    display: flex;
    flex-direction: row;
    gap: 20px;
  }

  img {
    object-fit: cover;
  }

  .sb-section-title {
    margin-bottom: 32px;
  }

  .sb-section a:not(h1 a, h2 a, h3 a) {
    font-size: 14px;
  }


  @media screen and (max-width: 600px) {
    .sb-section {
      flex-direction: column;
    }

  }
  `}
</style>
</file>

<file path="src/stories/storeDecorator.tsx">
import { makeStore } from '@/store'
import { Provider } from 'react-redux'
import { type ReactNode } from 'react'

type StoreDecoratorProps = {
  initialState: Record<string, any>
  children: ReactNode
}

export const StoreDecorator = ({ initialState, children }: StoreDecoratorProps) => {
  const store = makeStore(initialState)
  return <Provider store={store}>{children}</Provider>
}
</file>

<file path="src/styles/accordion.module.css">
/* TODO: Apply this style in the MUI theme once its part of this repository */

.accordion {
  min-height: 56px !important;
}
</file>

<file path="src/styles/globals.css">
@import url(./vars.css);
@import url(./onboard.css);
@import url(/fonts/fonts.css);
/**
* ^^^^^^^
* Some IDEs show the fonts file above as not existing, but it is.
* If you modify the path to it make sure that the file is also loaded on the
* actual website.
* Fun fact: if this comment block is above the @import url(/fonts/fonts.css);
* nextjs's build will incorrectly place the @import in the middle of the file
* and the fonts won't load. More info on @import:
* https://developer.mozilla.org/en-US/docs/Web/CSS/@import#description
*/

html,
body {
  padding: 0;
  margin: 0;
  font-family:
    DM Sans,
    sans-serif;
  background-color: var(--color-background-paper);
}

main {
  width: 100%;
}

a {
  color: inherit;
  text-decoration: none;
}

button {
  font: inherit;
}

:focus-visible {
  outline: 5px auto Highlight;
  outline: 5px auto -webkit-focus-ring-color;
}

* {
  box-sizing: border-box;
}

:root {
  --header-height: 52px;
  --footer-height: 67px;
}

input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* Firefox */
input[type='number'] {
  -moz-appearance: textfield;
}

.illustration-main-fill {
  fill: var(--color-primary-main);
}

.illustration-light-fill {
  fill: var(--color-border-main);
}

.illustration-background-fill {
  fill: var(--color-logo-background);
}

.illustration-background-warning-fill {
  fill: var(--color-warning-background);
}

.illustration-background-paper-fill {
  fill: var(--color-background-paper);
}

.illustration-secondary-light-fill {
  fill: var(--color-secondary-light);
}

.illustration-text-primary-fill {
  fill: var(--color-text-primary);
}

/* Note: a fallback `stroke` property must be on the svg to work */
.illustration-main-stroke {
  stroke: var(--color-primary-main);
}

.illustration-light-stroke {
  stroke: var(--color-border-main);
}

.illustration-very-light-stroke {
  stroke: var(--color-border-light);
}

.illustration-background-stroke {
  stroke: var(--color-logo-background);
}

@media (max-width: 599.95px) {
  .sticky {
    position: sticky;
    right: 0;
    background: var(--color-background-paper);
  }
}

body.beamerAnnouncementBarTopActive {
  padding-top: 0 !important;
}

#beamerLastPostTitle {
  left: 120px !important;
}
</file>

<file path="src/styles/inputs.module.css">
/* TODO: Apply these styles in the MUI theme once its part of this repository */
.input :global .MuiFormHelperText-root {
  position: absolute;
  bottom: -20px;
}

.input :global .MuiFormLabel-root:not(.MuiInputLabel-shrink) {
  transform: translate(16px, 22px) scale(1);
}

.input :global .MuiInputBase-root {
  background-color: var(--color-background-paper);
  border-radius: 6px;
  height: 66px;
  padding: 12px var(--space-2);
}

.input input {
  padding: 0;
}

.input :global .MuiInputBase-root fieldset {
  border-width: 1px !important;
}

.input :global .MuiInputBase-root:not(.Mui-error) fieldset {
  border-color: var(--color-border-light) !important;
}

@media (max-width: 899.95px) {
  .input :global .MuiFormHelperText-root {
    position: relative;
    bottom: 0;
  }
}
</file>

<file path="src/styles/onboard.css">
:root {
  --w3o-background-color: var(--color-background-paper);
  --w3o-foreground-color: var(--color-border-light);
  --w3o-text-color: var(--color-text-primary);
  --w3o-border-color: var(--color-border-light);
  --w3o-action-color: var(--color-primary-main);
  --w3o-border-radius: 6px;
  --w3o-font-family: DM Sans, sans-serif;

  --onboard-border-radius-1: var(--w3o-border-radius);
  --onboard-border-radius-2: var(--w3o-border-radius);
  --onboard-border-radius-3: var(--w3o-border-radius);

  /* Palette */
  --onboard-white: var(--color-background-paper);
  --onboard-black: var(--color-text-primary);

  --onboard-primary-1: var(--color-secondary-main);
  --onboard-primary-100: var(--color-secondary-background);
  --onboard-primary-200: var(--color-primary-light);
  --onboard-primary-300: var(--color-primary-light);
  --onboard-primary-400: var(--color-primary-light);
  --onboard-primary-500: var(--color-primary-main);
  --onboard-primary-600: var(--color-primary-main);
  --onboard-primary-700: var(--color-secondary-main);

  --onboard-gray-100: var(--color-border-light);
  --onboard-gray-200: var(--color-border-main);
  --onboard-gray-300: var(--color-primary-light);
  --onboard-gray-400: var(--color-primary-main);
  --onboard-gray-500: var(--color-primary-main);
  --onboard-gray-600: var(--color-border-main);
  --onboard-gray-700: var(--color-text-primary);

  --onboard-success-100: var(--color-secondary-background);
  --onboard-success-600: var(--color-secondary-light);
  --onboard-success-700: var(--color-success-dark);

  --onboard-danger-500: var(--color-error-main);
  --onboard-danger-600: var(--color-error-main);
  --onboard-danger-700: var(--color-error-dark);

  --onboard-warning-100: var(--color-error-background);
  --onboard-warning-400: var(--color-error-light);
  --onboard-warning-500: var(--color-error-light);
  --onboard-warning-600: var(--color-error-main);
  --onboard-warning-700: var(--color-error-dark);

  /* Connect modal */
  --onboard-modal-z-index: 1301;

  --onboard-modal-backdrop: rgba(99, 102, 105, 0.75);

  --onboard-modal-border-radius: var(--w3o-border-radius);

  --onboard-connect-sidebar-progress-background: var(--color-border-main);

  --onboard-link-color: var(--color-primary-main);

  --onboard-wallet-app-icon-border-color: var(--color-border-light);
  --onboard-wallet-app-icon-background-transparent: rgba(255, 255, 255, 0.2);
  --onboard-wallet-app-icon-background-light-gray: rgba(255, 255, 255, 0.5);

  --onboard-wallet-button-border-radius: var(--w3o-border-radius);
  --onboard-wallet-button-background-hover: var(--color-background-light);

  /* Account select (modal) */

  --account-select-white: var(--onboard-white);
  --account-select-black: var(--onboard-black);

  --account-select-primary-100: var(--onboard-primary-100);
  --account-select-primary-200: var(--onboard-primary-200);
  --account-select-primary-300: var(--onboard-primary-300);
  --account-select-primary-500: var(--onboard-primary-500);
  --account-select-primary-600: var(--onboard-primary-600);

  --account-select-gray-100: var(--onboard-gray-100);
  --account-select-gray-200: var(--onboard-gray-200);
  --account-select-gray-300: var(--onboard-gray-300);
  --account-select-gray-500: var(--onboard-gray-500);
  --account-select-gray-700: var(--onboard-gray-700);

  --account-select-danger-500: var(--onboard-danger-500);

  --onboard-account-select-modal-z-index: 1301;
}

#walletconnect-qrcode-modal {
  padding: 20px !important;
}

#walletconnect-wrapper {
  color: #162d45;
}

#walletconnect-wrapper .walletconnect-modal__footer {
  flex-wrap: wrap;
  gap: 5px;
}

/* Keystone modal */
#kv_sdk_container + .ReactModalPortal > div {
  z-index: 1301 !important;
}
#kv_sdk_container + .ReactModalPortal .ReactModal__Content {
  padding: 0 !important;
}
</file>

<file path="src/styles/spacings.ts">
export const base = 8

const getSpacings = (max: number) => {
  const spacings: Record<number, number> = {}

  for (let i = 1; i <= max; i++) {
    spacings[i] = base * i
  }

  return spacings
}

const spacings = getSpacings(12)

export default spacings
</file>

<file path="src/styles/vars.css">
/* This file is generated from the MUI theme colors. Do not edit directly. */

:root {
  --color-text-primary: #121312;
  --color-text-secondary: #a1a3a7;
  --color-text-disabled: #dddee0;
  --color-primary-dark: #3c3c3c;
  --color-primary-main: #121312;
  --color-primary-light: #636669;
  --color-secondary-dark: #0fda6d;
  --color-secondary-main: #12ff80;
  --color-secondary-light: #b0ffc9;
  --color-secondary-background: #effff4;
  --color-border-main: #a1a3a7;
  --color-border-light: #dcdee0;
  --color-border-background: #f4f4f4;
  --color-error-dark: #ac2c3b;
  --color-error-main: #ff5f72;
  --color-error-light: #ffb4bd;
  --color-error-background: #ffe6ea;
  --color-success-dark: #028d4c;
  --color-success-main: #00b460;
  --color-success-light: #d3f2e4;
  --color-success-background: #effaf1;
  --color-info-dark: #52bfdc;
  --color-info-main: #5fddff;
  --color-info-light: #d7f6ff;
  --color-info-background: #effcff;
  --color-warning-dark: #c04c32;
  --color-warning-main: #ff8061;
  --color-warning-light: #ffbc9f;
  --color-warning-background: #fff1e0;
  --color-background-default: #f4f4f4;
  --color-background-main: #f4f4f4;
  --color-background-paper: #ffffff;
  --color-background-light: #effff4;
  --color-backdrop-main: #636669;
  --color-logo-main: #121312;
  --color-logo-background: #eeeff0;
  --color-static-main: #121312;
  --space-1: 8px;
  --space-2: 16px;
  --space-3: 24px;
  --space-4: 32px;
  --space-5: 40px;
  --space-6: 48px;
  --space-7: 56px;
  --space-8: 64px;
  --space-9: 72px;
  --space-10: 80px;
  --space-11: 88px;
  --space-12: 96px;
}

[data-theme='dark'] {
  --color-text-primary: #ffffff;
  --color-text-secondary: #636669;
  --color-text-disabled: #636669;
  --color-primary-dark: #0cb259;
  --color-primary-main: #12ff80;
  --color-primary-light: #a1a3a7;
  --color-secondary-dark: #636669;
  --color-secondary-main: #ffffff;
  --color-secondary-light: #b0ffc9;
  --color-secondary-background: #1b2a22;
  --color-border-main: #636669;
  --color-border-light: #303033;
  --color-border-background: #121312;
  --color-error-dark: #ac2c3b;
  --color-error-main: #ff5f72;
  --color-error-light: #ffb4bd;
  --color-error-background: #2f2527;
  --color-success-dark: #388e3c;
  --color-success-main: #00b460;
  --color-success-light: #81c784;
  --color-success-background: #1f2920;
  --color-info-dark: #52bfdc;
  --color-info-main: #5fddff;
  --color-info-light: #b7f0ff;
  --color-info-background: #19252c;
  --color-warning-dark: #c04c32;
  --color-warning-main: #ff8061;
  --color-warning-light: #ffbc9f;
  --color-warning-background: #2f2318;
  --color-background-default: #121312;
  --color-background-main: #121312;
  --color-background-paper: #1c1c1c;
  --color-background-light: #1b2a22;
  --color-backdrop-main: #636669;
  --color-logo-main: #ffffff;
  --color-logo-background: #303033;
  --color-static-main: #121312;
}

/* The same as above for the brief moment before JS loads */
@media (prefers-color-scheme: dark) {
  :root:not([data-theme='light']) {
    --color-text-primary: #ffffff;
    --color-text-secondary: #636669;
    --color-text-disabled: #636669;
    --color-primary-dark: #0cb259;
    --color-primary-main: #12ff80;
    --color-primary-light: #a1a3a7;
    --color-secondary-dark: #636669;
    --color-secondary-main: #ffffff;
    --color-secondary-light: #b0ffc9;
    --color-secondary-background: #1b2a22;
    --color-border-main: #636669;
    --color-border-light: #303033;
    --color-border-background: #121312;
    --color-error-dark: #ac2c3b;
    --color-error-main: #ff5f72;
    --color-error-light: #ffb4bd;
    --color-error-background: #2f2527;
    --color-success-dark: #388e3c;
    --color-success-main: #00b460;
    --color-success-light: #81c784;
    --color-success-background: #1f2920;
    --color-info-dark: #52bfdc;
    --color-info-main: #5fddff;
    --color-info-light: #b7f0ff;
    --color-info-background: #19252c;
    --color-warning-dark: #c04c32;
    --color-warning-main: #ff8061;
    --color-warning-light: #ffbc9f;
    --color-warning-background: #2f2318;
    --color-background-default: #121312;
    --color-background-main: #121312;
    --color-background-paper: #1c1c1c;
    --color-background-light: #1b2a22;
    --color-backdrop-main: #636669;
    --color-logo-main: #ffffff;
    --color-logo-background: #303033;
    --color-static-main: #121312;
  }
}
</file>

<file path="src/utils/providers/UncheckedJsonRpcSigner.ts">
import { JsonRpcSigner, type TransactionRequest, type TransactionResponse } from 'ethers'

/**
 * This class is basically a copy of the UncheckedJonRpcSigner from ethers.js v 5.7:
 * https://github.com/ethers-io/ethers.js/blob/v5.7/packages/providers/src.ts/json-rpc-provider.ts#L370
 *
 * Why do we need this?
 * If you have 2 Wallets - a Parent wallet and a Child Wallet. The parent is the owner of the child.
 * You connect the child to the Parent through Walletconnect and then use the parent to sign and execute tx.
 *
 * In such case if you use the normal JsonRpcSigner from ethers.js to sign a transaction off-chain the UI will be
 * stuck, because the signer will wait for the transaction receipt to come back from the RPC Server (which won't happen
 * because we are just signing and not executing the tx on chain). In such cases however we need to return immediately
 * with a hash. If we don't the UI in the child is stuck. Waiting for the promise to resolve.
 */
export class UncheckedJsonRpcSigner extends JsonRpcSigner {
  async sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse> {
    return this.sendUncheckedTransaction(transaction).then((hash) => {
      return <TransactionResponse>(<unknown>{
        hash,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations?: number) => {
          return this.provider.waitForTransaction(hash, confirmations)
        },
      })
    })
  }
}
</file>

<file path="src/utils/chains.ts">
import { AppRoutes } from '@/config/routes'
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { getExplorerLink } from '@safe-global/utils/utils/gateway'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

export const FeatureRoutes = {
  [AppRoutes.apps.index]: FEATURES.SAFE_APPS,
  [AppRoutes.swap]: FEATURES.NATIVE_SWAPS,
  [AppRoutes.stake]: FEATURES.STAKING,
  [AppRoutes.balances.nfts]: FEATURES.ERC721,
  [AppRoutes.settings.notifications]: FEATURES.PUSH_NOTIFICATIONS,
  [AppRoutes.bridge]: FEATURES.BRIDGE,
}

export const getBlockExplorerLink = (
  chain: ChainInfo,
  address: string,
): { href: string; title: string } | undefined => {
  if (chain.blockExplorerUriTemplate) {
    return getExplorerLink(address, chain.blockExplorerUriTemplate)
  }
}

export const isRouteEnabled = (route: string, chain?: ChainInfo) => {
  if (!chain) return false
  const featureRoute = FeatureRoutes[route]
  return !featureRoute || hasFeature(chain, featureRoute)
}
</file>

<file path="src/utils/clipboard.ts">
import { logError, Errors } from '@/services/exceptions'

export const isClipboardSupported = (): boolean => {
  // 'clipboard-read' and `readText` are not supported by Firefox
  // @see https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/readText#browser_compatibility
  return navigator.userAgent.includes('Firefox')
}

export const isClipboardGranted = async (): Promise<boolean> => {
  if (isClipboardSupported()) {
    return false
  }

  let isGranted = false

  try {
    // @ts-expect-error navigator permissions types don't include clipboard
    const permission = await navigator.permissions.query({ name: 'clipboard-read' })
    isGranted = permission.state === 'granted'
  } catch (e) {
    logError(Errors._707, e)
  }

  return isGranted
}

export const getClipboard = async (): Promise<string> => {
  if (isClipboardSupported()) return ''

  let clipboard = ''

  try {
    clipboard = await navigator.clipboard.readText()
  } catch (e) {
    logError(Errors._708, e)
  }

  return clipboard
}
</file>

<file path="src/utils/createEmotionCache.ts">
import createCache from '@emotion/cache'

const isBrowser = typeof document !== 'undefined'

// On the client side, Create a meta tag at the top of the <head> and set it as insertionPoint.
// This assures that MUI styles are loaded first.
// It allows developers to easily override MUI styles with other styling solutions, like CSS modules.
export default function createEmotionCache() {
  let insertionPoint

  if (isBrowser) {
    const emotionInsertionPoint = document.querySelector<HTMLMetaElement>('meta[name="emotion-insertion-point"]')
    insertionPoint = emotionInsertionPoint ?? undefined
  }

  return createCache({ key: 'mui-style', insertionPoint })
}
</file>

<file path="src/utils/ethers-utils.ts">
import type { TransactionReceipt } from 'ethers'
import type { ErrorCode } from 'ethers'
import { Signature, type SignatureLike } from 'ethers'

// https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse
export enum EthersTxReplacedReason {
  repriced = 'repriced',
  cancelled = 'cancelled',
  replaced = 'replaced',
}

// TODO: Replace this with ethers v6 types once released and create similar helper to `asError`
export type EthersError = Error & { code: ErrorCode; reason?: EthersTxReplacedReason; receipt?: TransactionReceipt }

export const didRevert = (receipt?: { status?: number | null }): boolean => {
  return receipt?.status === 0
}

export const didReprice = (error: EthersError): boolean => {
  return error.reason === EthersTxReplacedReason.repriced
}

type TimeoutError = Error & {
  timeout: number
  code: 'TIMEOUT'
}

export const isTimeoutError = (value?: Error): value is TimeoutError => {
  return !!value && 'reason' in value && value.reason === 'timeout' && 'code' in value
}

export const splitSignature = (sigBytes: string): Signature => {
  return Signature.from(sigBytes)
}
export const joinSignature = (splitSig: SignatureLike): string => {
  return Signature.from(splitSig).serialized
}
</file>

<file path="src/utils/featureToggled.tsx">
import type { ComponentType } from 'react'
import { useHasFeature } from '@/hooks/useChains'
import type { FEATURES } from '@safe-global/utils/utils/chains'
export { FEATURES } from '@safe-global/utils/utils/chains'
export const featureToggled = <P extends Record<string, unknown>>(Component: ComponentType<P>, feature: FEATURES) => {
  const ToggledComponent = (props: P) => {
    const hasFeature = useHasFeature(feature)
    return hasFeature ? <Component {...props} /> : null
  }
  ToggledComponent.displayName = Component.displayName || Component.name
  return ToggledComponent
}
</file>

<file path="src/utils/gateway.ts">
import type { JsonRpcSigner } from 'ethers'
import { deleteTransaction } from '@safe-global/safe-gateway-typescript-sdk'
import { signTypedData } from '@safe-global/utils/utils/web3'

export const signTxServiceMessage = async (
  chainId: string,
  safeAddress: string,
  safeTxHash: string,
  signer: JsonRpcSigner,
): Promise<string> => {
  return await signTypedData(signer, {
    types: {
      DeleteRequest: [
        { name: 'safeTxHash', type: 'bytes32' },
        { name: 'totp', type: 'uint256' },
      ],
    },
    domain: {
      name: 'Safe Transaction Service',
      version: '1.0',
      chainId: Number(chainId),
      verifyingContract: safeAddress,
    },
    message: {
      safeTxHash,
      totp: Math.floor(Date.now() / 3600e3),
    },
    primaryType: 'DeleteRequest',
  })
}

export const deleteTx = async ({
  chainId,
  safeAddress,
  safeTxHash,
  signer,
}: {
  chainId: string
  safeAddress: string
  safeTxHash: string
  signer: JsonRpcSigner
}) => {
  const signature = await signTxServiceMessage(chainId, safeAddress, safeTxHash, signer)
  return await deleteTransaction(chainId, safeTxHash, signature)
}
</file>

<file path="src/utils/helpers.ts">
// `assert` does not work with arrow functions
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { type ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { OnboardAPI } from '@web3-onboard/core'
import type { Eip1193Provider } from 'ethers'
import { invariant } from '@safe-global/utils/utils/helpers'

export function assertTx(safeTx: SafeTransaction | undefined): asserts safeTx {
  return invariant(safeTx, 'Transaction not provided')
}

export function assertWallet(wallet: ConnectedWallet | null): asserts wallet {
  return invariant(wallet, 'Wallet not connected')
}

export function assertOnboard(onboard: OnboardAPI | undefined): asserts onboard {
  return invariant(onboard, 'Onboard not connected')
}

export function assertChainInfo(chainInfo: ChainInfo | undefined): asserts chainInfo {
  return invariant(chainInfo, 'No chain config available')
}

export function assertProvider(provider: Eip1193Provider | undefined | null): asserts provider {
  return invariant(provider, 'Provider not found')
}

export const getKeyWithTrueValue = (obj: Record<string, boolean>) => {
  return Object.entries(obj).find(([, value]) => !!value)?.[0]
}
</file>

<file path="src/utils/hex.ts">
export const isEmptyHexData = (encodedData: string): boolean => encodedData !== '' && isNaN(parseInt(encodedData, 16))

export const numberToHex = (value: number | bigint): `0x${string}` => `0x${value.toString(16)}`
</file>

<file path="src/utils/mad-props.tsx">
import type { ComponentType, FC } from 'react'
import React, { memo } from 'react'

type HookMap<P> = {
  [K in keyof P]?: () => P[K]
}

/**
 * Injects props into a component using hooks.
 * This allows to keep the original component pure and testable.
 *
 * @param Component The component to wrap
 * @param hookMap A map of hooks to use, keys are the props to inject, values are the hooks
 * @returns A new component with the props injected
 */
const madProps = <P extends Record<string, unknown>, H extends keyof P>(
  Component: ComponentType<P>,
  hookMap: HookMap<Pick<P, H>>,
): FC<Omit<P, H>> => {
  const MadComponent = (externalProps: Omit<P, H>) => {
    let newProps: P = { ...externalProps } as P

    for (const key in hookMap) {
      const hook = hookMap[key]
      if (hook !== undefined) {
        newProps[key as H] = hook()
      }
    }

    return <Component {...newProps} />
  }

  MadComponent.displayName = Component.displayName || Component.name

  // Wrapping MadComponent with React.memo and casting to FC<Omit<P, H>>
  // The casting is only needed because of memo, the component itself satisfies the type
  return memo(MadComponent) as unknown as FC<Omit<P, H>>
}

export default madProps
</file>

<file path="src/utils/nested-safe-wallet.ts">
import { type Eip1193Provider, getAddress, type JsonRpcProvider } from 'ethers'
import { SafeWalletProvider, type WalletSDK } from '@/services/safe-wallet-provider'
import { getTransactionDetails, type SafeInfo } from '@safe-global/safe-gateway-typescript-sdk'
import { type NextRouter } from 'next/router'
import { AppRoutes } from '@/config/routes'
import proposeTx from '@/services/tx/proposeTransaction'
import { isSmartContractWallet } from '@/utils/wallets'
import { type ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { initSafeSDK } from '@/hooks/coreSDK/safeCoreSDK'
import { logError } from '@/services/exceptions'
import ErrorCodes from '@safe-global/utils/services/exceptions/ErrorCodes'
import { tryOffChainTxSigning } from '@/services/tx/tx-sender/sdk'
import type { TransactionResult } from '@safe-global/safe-core-sdk-types'

export type NestedWallet = {
  address: string
  chainId: string
  provider: Eip1193Provider | null
  isSafe: true
}

export const getNestedWallet = (
  actualWallet: ConnectedWallet,
  safeInfo: SafeInfo,
  web3ReadOnly: JsonRpcProvider,
  router: NextRouter,
): NestedWallet => {
  let requestId = 0
  const nestedSafeSdk: WalletSDK = {
    getBySafeTxHash(safeTxHash) {
      return getTransactionDetails(safeInfo.chainId, safeTxHash)
    },
    async switchChain() {
      return Promise.reject('Switching chains is not supported yet')
    },
    getCreateCallTransaction() {
      throw new Error('Unsupported method')
    },

    async signMessage(): Promise<{ signature: string }> {
      return Promise.reject('signMessage is not supported yet')
    },

    async proxy(method, params) {
      return web3ReadOnly?.send(method, params ?? [])
    },

    async send(params) {
      const safeCoreSDK = await initSafeSDK({
        provider: web3ReadOnly,
        chainId: safeInfo.chainId,
        address: safeInfo.address.value,
        version: safeInfo.version,
        implementationVersionState: safeInfo.implementationVersionState,
        implementation: safeInfo.implementation.value,
      })

      const connectedSDK = await safeCoreSDK?.connect({ provider: actualWallet.provider })

      if (!connectedSDK) {
        return Promise.reject('Could not initialize core sdk')
      }

      const transactions = params.txs.map(({ to, value, data }: any) => {
        return {
          to: getAddress(to),
          value: BigInt(value).toString(),
          data,
          operation: 0,
        }
      })

      const safeTx = await connectedSDK.createTransaction({
        transactions,
        onlyCalls: true,
      })

      const safeTxHash = await connectedSDK.getTransactionHash(safeTx)

      let result: TransactionResult | null = null

      try {
        if (await isSmartContractWallet(safeInfo.chainId, actualWallet.address)) {
          // With the unchecked signer, the contract call resolves once the tx
          // has been submitted in the wallet not when it has been executed

          // First we propose so the backend will pick it up
          await proposeTx(safeInfo.chainId, safeInfo.address.value, actualWallet.address, safeTx, safeTxHash)
          result = await connectedSDK.approveTransactionHash(safeTxHash)
        } else {
          // Sign off-chain
          if (safeInfo.threshold === 1) {
            // Always propose the tx so the resulting link to the parentTx does not error out
            await proposeTx(safeInfo.chainId, safeInfo.address.value, actualWallet.address, safeTx, safeTxHash)

            // Directly execute the tx
            result = await connectedSDK.executeTransaction(safeTx)
          } else {
            const signedTx = await tryOffChainTxSigning(safeTx, connectedSDK)
            await proposeTx(safeInfo.chainId, safeInfo.address.value, actualWallet.address, signedTx, safeTxHash)
          }
        }
      } catch (err) {
        logError(ErrorCodes._817, err)
        throw err
      }

      return {
        safeTxHash,
        txHash: result?.hash,
      }
    },

    setSafeSettings() {
      throw new Error('setSafeSettings is not supported yet')
    },

    showTxStatus(safeTxHash) {
      router.push({
        pathname: AppRoutes.transactions.tx,
        query: {
          safe: router.query.safe,
          id: safeTxHash,
        },
      })
    },

    async signTypedMessage() {
      return Promise.reject('signTypedMessage is not supported yet')
    },
  }

  const nestedSafeProvider = new SafeWalletProvider(
    {
      chainId: Number(safeInfo.chainId),
      safeAddress: safeInfo.address.value,
    },
    nestedSafeSdk,
  )

  return {
    provider: {
      async request(request) {
        const result = await nestedSafeProvider.request(requestId++, request, {
          url: '',
          description: '',
          iconUrl: '',
          name: 'Nested Safe',
        })

        if ('result' in result) {
          return result.result
        }

        if ('error' in result) {
          throw new Error(result.error.message)
        }
      },
    },
    address: safeInfo.address.value,
    chainId: safeInfo.chainId,
    isSafe: true,
  }
}
</file>

<file path="src/utils/nested-safes.ts">
import type { DataDecoded, InternalTransaction, TransactionData } from '@safe-global/safe-gateway-typescript-sdk'

export function isNestedSafeCreation(txData: TransactionData): boolean {
  try {
    _getFactoryAddressAndSetupData(txData)
    return true
  } catch {
    return false
  }
}

export function _getFactoryAddressAndSetupData(txData: TransactionData): {
  factoryAddress: string
  singleton: string
  initializer: string
  saltNonce: string
} {
  let factoryAddress: string | undefined
  let dataDecoded: DataDecoded | undefined

  if (isCreateProxyWithNonce(txData)) {
    factoryAddress = txData.to.value
    dataDecoded = txData.dataDecoded
  } else if (isMultiSend(txData)) {
    const batchTxData = txData.dataDecoded?.parameters
      ?.find((parameter) => parameter?.name === 'transactions')
      ?.valueDecoded?.find(isCreateProxyWithNonce)

    factoryAddress = batchTxData?.to
    dataDecoded = batchTxData?.dataDecoded
  } else {
    throw new Error('Invalid method')
  }

  if (!factoryAddress) {
    throw new Error('Missing factory address')
  }

  if (!Array.isArray(dataDecoded?.parameters)) {
    throw new Error('Invalid parameters')
  }

  const [singleton, initializer, saltNonce] = dataDecoded.parameters

  if (
    typeof singleton.value !== 'string' ||
    typeof initializer.value !== 'string' ||
    typeof saltNonce.value !== 'string'
  ) {
    throw new Error('Invalid parameter values')
  }

  return {
    factoryAddress,
    singleton: singleton.value,
    initializer: initializer.value,
    saltNonce: saltNonce.value,
  }
}

function isCreateProxyWithNonce(txData: TransactionData | InternalTransaction) {
  return txData.dataDecoded?.method === 'createProxyWithNonce'
}

function isMultiSend(txData: TransactionData) {
  return txData.dataDecoded?.method === 'multiSend'
}
</file>

<file path="src/utils/relaying.ts">
import type { RelayCountResponse } from '@safe-global/safe-gateway-typescript-sdk'

export const hasRemainingRelays = (relays?: RelayCountResponse): boolean => {
  return !!relays && relays.remaining > 0
}
</file>

<file path="src/utils/safe-hashes.ts">
import { TypedDataEncoder } from 'ethers'
import semverSatisfies from 'semver/functions/satisfies'
import { getEip712MessageTypes, getEip712TxTypes } from '@safe-global/protocol-kit/dist/src/utils'
import type { SafeTransactionData, SafeVersion } from '@safe-global/safe-core-sdk-types'
import type { MessageItem } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import { generateSafeMessageMessage } from '@safe-global/utils/utils/safe-messages'

const NEW_DOMAIN_TYPE_HASH_VERSION = '>=1.3.0'
const NEW_SAFE_TX_TYPE_HASH_VERSION = '>=1.0.0'

export function getDomainHash({
  chainId,
  safeAddress,
  safeVersion,
}: {
  chainId: string
  safeAddress: string
  safeVersion: SafeVersion
}): string {
  const includeChainId = semverSatisfies(safeVersion, NEW_DOMAIN_TYPE_HASH_VERSION)
  return TypedDataEncoder.hashDomain({
    ...(includeChainId && { chainId }),
    verifyingContract: safeAddress,
  })
}

export function getSafeTxMessageHash({
  safeVersion,
  safeTxData,
}: {
  safeVersion: SafeVersion
  safeTxData: SafeTransactionData
}): string {
  const usesBaseGas = semverSatisfies(safeVersion, NEW_SAFE_TX_TYPE_HASH_VERSION)
  const SafeTx = getEip712TxTypes(safeVersion).SafeTx

  // Clone to not modify the original
  const tx: any = { ...safeTxData }

  if (!usesBaseGas) {
    tx.dataGas = tx.baseGas
    delete tx.baseGas

    SafeTx[5].name = 'dataGas'
  }

  return TypedDataEncoder.hashStruct('SafeTx', { SafeTx }, tx)
}

export function getSafeMessageMessageHash({
  message,
  safeVersion,
}: {
  message: MessageItem['message']
  safeVersion: SafeVersion
}): string {
  const SafeMessage = getEip712MessageTypes(safeVersion).SafeMessage
  return TypedDataEncoder.hashStruct('SafeMessage', { SafeMessage }, { message: generateSafeMessageMessage(message) })
}
</file>

<file path="src/utils/safe-message-guards.ts">
import type { MessageItem, DateLabel } from '@safe-global/store/gateway/AUTO_GENERATED/messages'
import type { SafeMessageListItem } from '@safe-global/store/gateway/types'

export const isSafeMessageListDateLabel = (item: SafeMessageListItem): item is DateLabel => {
  return item.type === 'DATE_LABEL'
}

export const isSafeMessageListItem = (item: SafeMessageListItem): item is MessageItem => {
  return item.type === 'MESSAGE'
}
</file>

<file path="src/utils/safe-migrations.ts">
import { Safe_migration__factory } from '@safe-global/utils/types/contracts'
import { getCompatibilityFallbackHandlerDeployments } from '@safe-global/safe-deployments'
import { hasMatchingDeployment } from '@safe-global/utils/services/contracts/deployments'

import { getSafeMigrationDeployment } from '@safe-global/safe-deployments'
import { type MetaTransactionData, OperationType, type SafeVersion } from '@safe-global/safe-core-sdk-types'
import type { ChainInfo, TransactionData } from '@safe-global/safe-gateway-typescript-sdk'

import { LATEST_SAFE_VERSION } from '@safe-global/utils/config/constants'
import { sameAddress } from '@safe-global/utils/utils/addresses'

export const SAFE_TO_L2_MIGRATION_VERSION = '1.4.1'

export const createUpdateMigration = (
  chain: ChainInfo,
  safeVersion: string,
  fallbackHandler?: string,
): MetaTransactionData => {
  const deployment = getSafeMigrationDeployment({
    version: chain.recommendedMasterCopyVersion || LATEST_SAFE_VERSION,
    released: true,
    network: chain.chainId,
  })

  if (!deployment) {
    throw new Error('Migration deployment not found')
  }

  // Keep fallback handler if it's not a default one
  const keepFallbackHandler =
    !!fallbackHandler &&
    !hasMatchingDeployment(getCompatibilityFallbackHandlerDeployments, fallbackHandler, chain.chainId, [
      safeVersion as SafeVersion,
    ])

  const method = (
    keepFallbackHandler
      ? chain.l2
        ? 'migrateL2Singleton'
        : 'migrateSingleton'
      : chain.l2
        ? 'migrateL2WithFallbackHandler'
        : 'migrateWithFallbackHandler'
  ) as 'migrateSingleton' // apease typescript

  const interfce = Safe_migration__factory.createInterface()

  const tx: MetaTransactionData = {
    operation: OperationType.DelegateCall, // delegate call required
    data: interfce.encodeFunctionData(method),
    to: deployment.defaultAddress,
    value: '0',
  }

  return tx
}

export const createMigrateToL2 = (chain: ChainInfo) => {
  const deployment = getSafeMigrationDeployment({
    version: SAFE_TO_L2_MIGRATION_VERSION, // This is the only version that has this contract deployed
    released: true,
    network: chain.chainId,
  })

  if (!deployment) {
    throw new Error('Migration deployment not found')
  }

  const interfce = Safe_migration__factory.createInterface()

  const tx: MetaTransactionData = {
    operation: OperationType.DelegateCall, // delegate call required
    data: interfce.encodeFunctionData('migrateL2Singleton'),
    to: deployment.defaultAddress,
    value: '0',
  }

  return tx
}

export const isMigrateL2SingletonCall = (txData: TransactionData): boolean => {
  // We always use the 1.4.1 version for this contract as it is only deployed for 1.4.1 Safes
  const safeMigrationDeployment = getSafeMigrationDeployment({ version: SAFE_TO_L2_MIGRATION_VERSION })
  const safeMigrationAddress = safeMigrationDeployment?.defaultAddress
  const safeMigrationInterface = Safe_migration__factory.createInterface()

  return (
    txData.hexData !== undefined &&
    txData.hexData !== null &&
    txData.hexData.startsWith(safeMigrationInterface.getFunction('migrateL2Singleton').selector) &&
    sameAddress(txData.to.value, safeMigrationAddress)
  )
}
</file>

<file path="src/utils/safe-versions.ts">
import {
  hasSafeFeature as sdkHasSafeFeature,
  type SAFE_FEATURES,
} from '@safe-global/protocol-kit/dist/src/utils/safeVersions'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'

// Note: backend returns `SafeInfo['version']` as `null` for unsupported contracts
export const hasSafeFeature = (feature: SAFE_FEATURES, version: SafeState['version']): boolean => {
  if (!version) {
    return false
  }
  return sdkHasSafeFeature(feature, version)
}
</file>

<file path="src/utils/signers.ts">
import type { ConnectedWallet } from '@/hooks/wallets/useOnboard'
import type { SafeTransaction } from '@safe-global/safe-core-sdk-types'
import { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import { checksumAddress } from '@safe-global/utils/utils/addresses'

export const getAvailableSigners = (
  wallet: ConnectedWallet | null | undefined,
  nestedSafeOwners: string[] | null,
  safe: SafeState,
  tx: SafeTransaction | undefined,
) => {
  if (!wallet || !nestedSafeOwners || !tx) {
    return []
  }
  const walletAddress = checksumAddress(wallet.address)

  const isDirectOwner = safe.owners.map((owner) => checksumAddress(owner.value)).includes(walletAddress)
  const isFullySigned = tx.signatures.size >= safe.threshold
  const availableSigners = nestedSafeOwners ? nestedSafeOwners.map(checksumAddress) : []

  const signers = Array.from(tx.signatures.keys()).map(checksumAddress)

  if (isDirectOwner && !signers.includes(walletAddress)) {
    availableSigners.push(walletAddress)
  }

  if (!isFullySigned) {
    // Filter signers that already signed
    return availableSigners.filter((signer) => !signers.includes(signer))
  }
  return availableSigners
}
</file>

<file path="src/utils/SimpleTxWatcher.ts">
import { type JsonRpcProvider, type TransactionReceipt } from 'ethers'

/**
 * Singleton class for watching pending txs.
 *
 * Offers two methods:
 * - {@linkplain watchTxHash} to watch a new pending tx
 * - {@linkplain stopWatchingTxHash} to stop an active watcher for a pending tx
 */
export class SimpleTxWatcher {
  private static INSTANCE: SimpleTxWatcher | undefined
  private readonly unsubFunctions: Record<string, () => void>
  private static readonly REPLACED_BLOCK_THRESHOLD = 2

  private constructor() {
    this.unsubFunctions = {}
  }

  static getInstance() {
    if (!SimpleTxWatcher.INSTANCE) {
      SimpleTxWatcher.INSTANCE = new SimpleTxWatcher()
    }
    return SimpleTxWatcher.INSTANCE
  }

  /**
   * Watches a transaction and returns the {@linkplain TransactionReceipt} if the transaction executes.
   * If the transaction gets replaced, sped up or cancelled in the connected wallet the watcher rejects with an error.
   * @param txHash hash of the pending tx
   * @param walletAddress from address of the pending tx (executing wallet)
   * @param walletNonce used nonce of the connected wallet for the pending tx
   * @param provider RPC provider
   * @returns
   */
  watchTxHash(txHash: string, walletAddress: string, walletNonce: number, provider: JsonRpcProvider) {
    return new Promise<TransactionReceipt>((resolve, reject) => {
      const unsubscribe = () => {
        provider.off('block', checkTx)
      }

      let replacedBlockCount = 0

      const checkTx = async () => {
        // try to retrieve the receipt
        const testReceipt = await provider.getTransactionReceipt(txHash)
        if (testReceipt !== null) {
          unsubscribe()
          resolve(testReceipt)
        } else {
          // Check if tx was replaced
          const currentNonce = await provider.getTransactionCount(walletAddress)
          if (currentNonce > walletNonce) {
            if (replacedBlockCount >= SimpleTxWatcher.REPLACED_BLOCK_THRESHOLD) {
              unsubscribe()
              reject(`Transaction not found. It might have been replaced or cancelled in the connected wallet.`)
            }
            replacedBlockCount++
          }
        }
      }

      // Subscribe
      provider.on('block', checkTx)
      this.unsubFunctions[txHash] = unsubscribe
    })
  }

  /**
   * Stops an active watcher for the given txHash
   */
  stopWatchingTxHash = async (txHash: string) => {
    this.unsubFunctions[txHash]?.()
    delete this.unsubFunctions[txHash]
  }
}
</file>

<file path="src/utils/tokens.ts">
import { getWeb3ReadOnly } from '@/hooks/wallets/web3'
import { ERC20__factory, ERC721__factory } from '@safe-global/utils/types/contracts'
import { parseBytes32String } from '@ethersproject/strings'
import { TokenType } from '@safe-global/safe-gateway-typescript-sdk'
import { ERC721_IDENTIFIER } from '@safe-global/utils/utils/tokens'
import { type Erc20Token } from '@safe-global/store/gateway/AUTO_GENERATED/transactions'

/**
 * Fetches ERC20 token symbol and decimals from on-chain.
 * @param address address of erc20 token
 */
export const getERC20TokenInfoOnChain = async (
  address: string,
): Promise<Omit<Erc20Token, 'name' | 'logoUri'> | undefined> => {
  const web3 = getWeb3ReadOnly()
  if (!web3) return

  const erc20 = ERC20__factory.connect(address, web3)

  const symbol = await erc20
    .symbol()
    .then((symbol) => symbol)
    .catch((error) => parseBytes32String(error.value)) // Some older contracts use bytes32 instead of string
    .finally(() => '')

  const decimals = await erc20.decimals()

  return {
    address,
    symbol,
    decimals: Number(decimals),
    type: TokenType.ERC20,
  }
}

export const getErc721Symbol = async (address: string) => {
  const web3 = getWeb3ReadOnly()
  if (!web3) return ''

  const erc721 = ERC721__factory.connect(address, web3)

  try {
    return await erc721.symbol()
  } catch (e) {
    return ''
  }
}

export const isErc721Token = async (address: string) => {
  const web3 = getWeb3ReadOnly()
  if (!web3) return false

  const erc721 = ERC721__factory.connect(address, web3)

  try {
    return await erc721.supportsInterface(ERC721_IDENTIFIER)
  } catch (e) {
    return false
  }
}
</file>

<file path="src/utils/transaction-calldata.ts">
import { id } from 'ethers'
import type { FunctionFragment } from 'ethers'
import type { BaseTransaction } from '@safe-global/safe-apps-sdk'

import { Multi_send__factory } from '@safe-global/utils/types/contracts/factories/@safe-global/safe-deployments/dist/assets/v1.3.0'
import { ERC20__factory } from '@safe-global/utils/types/contracts/factories/@openzeppelin/contracts/build/contracts/ERC20__factory'
import { ERC721__factory } from '@safe-global/utils/types/contracts/factories/@openzeppelin/contracts/build/contracts/ERC721__factory'
import { Safe__factory } from '@safe-global/utils/types/contracts'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'

export const isCalldata = (data: string, fragment: FunctionFragment): boolean => {
  const signature = fragment.format()
  const signatureId = id(signature).slice(0, 10)
  return data.startsWith(signatureId)
}

// ERC-20
const erc20Interface = ERC20__factory.createInterface()
const transferFragment = erc20Interface.getFunction('transfer')
const isErc20TransferCalldata = (data: string): boolean => {
  return isCalldata(data, transferFragment)
}

// ERC-721
const erc721Interface = ERC721__factory.createInterface()
const transferFromFragment = erc721Interface.getFunction('transferFrom')
const isErc721TransferFromCalldata = (data: string): boolean => {
  return isCalldata(data, transferFromFragment)
}

const safeTransferFromFragment = erc721Interface.getFunction('safeTransferFrom(address,address,uint256)')
const isErc721SafeTransferFromCalldata = (data: string): boolean => {
  return isCalldata(data, safeTransferFromFragment)
}

const safeTransferFromWithBytesFragment = erc721Interface.getFunction('safeTransferFrom(address,address,uint256,bytes)')
const isErc721SafeTransferFromWithBytesCalldata = (data: string): boolean => {
  return isCalldata(data, safeTransferFromWithBytesFragment)
}

// Safe
const safeInterface = Safe__factory.createInterface()

const addOwnerWithThresholdFragment = safeInterface.getFunction('addOwnerWithThreshold')
export function isAddOwnerWithThresholdCalldata(data: string): boolean {
  return isCalldata(data, addOwnerWithThresholdFragment)
}

const removeOwnerFragment = safeInterface.getFunction('removeOwner')
export function isRemoveOwnerCalldata(data: string): boolean {
  return isCalldata(data, removeOwnerFragment)
}

const swapOwnerFagment = safeInterface.getFunction('swapOwner')
export function isSwapOwnerCalldata(data: string): boolean {
  return isCalldata(data, swapOwnerFagment)
}

const changeThresholdFragment = safeInterface.getFunction('changeThreshold')
export function isChangeThresholdCalldata(data: string): boolean {
  return isCalldata(data, changeThresholdFragment)
}

// MultiSend
const multiSendInterface = Multi_send__factory.createInterface()
const multiSendFragment = multiSendInterface.getFunction('multiSend')
export const isMultiSendCalldata = (data: string): boolean => {
  return isCalldata(data, multiSendFragment)
}

export const getTransactionRecipients = ({ data, to }: BaseTransaction): Array<string> => {
  // ERC-20
  if (isErc20TransferCalldata(data)) {
    const [to] = erc20Interface.decodeFunctionData(transferFragment, data)
    return [to]
  }

  // ERC-721
  if (isErc721TransferFromCalldata(data)) {
    const [, to] = erc721Interface.decodeFunctionData(transferFromFragment, data)
    return [to]
  }

  if (isErc721SafeTransferFromCalldata(data)) {
    const [, to] = erc721Interface.decodeFunctionData(safeTransferFromFragment, data)
    return [to]
  }

  if (isErc721SafeTransferFromWithBytesCalldata(data)) {
    const [, to] = erc721Interface.decodeFunctionData(safeTransferFromWithBytesFragment, data)
    return [to]
  }

  // multiSend
  if (isMultiSendCalldata(data)) {
    return decodeMultiSendData(data).flatMap(getTransactionRecipients)
  }

  // Other (e.g. native transfer)
  return [to]
}
</file>

<file path="src/utils/transaction-guards.ts">
import type {
  BaselineConfirmationView,
  Cancellation,
  ConflictHeader,
  Creation,
  Custom,
  DateLabel,
  DetailedExecutionInfo,
  Erc20Transfer,
  Erc721Transfer,
  ExecutionInfo,
  Label,
  ModuleExecutionDetails,
  ModuleExecutionInfo,
  MultiSend,
  MultisigExecutionDetails,
  MultisigExecutionInfo,
  NativeCoinTransfer,
  NativeStakingDepositConfirmationView,
  Order,
  AnyConfirmationView,
  AnySwapOrderConfirmationView,
  SafeInfo,
  SettingsChange,
  SwapOrder,
  SwapOrderConfirmationView,
  Transaction,
  TransactionInfo,
  TransactionListItem,
  TransactionSummary,
  Transfer,
  TransferInfo,
  TwapOrder,
  TwapOrderConfirmationView,
  AnyStakingConfirmationView,
  StakingTxExitInfo,
  StakingTxDepositInfo,
  StakingTxWithdrawInfo,
  NativeStakingWithdrawConfirmationView,
  NativeStakingValidatorsExitConfirmationView,
  StakingTxInfo,
  TransactionData,
} from '@safe-global/safe-gateway-typescript-sdk'
import { type AddressInfo } from '@safe-global/store/gateway/AUTO_GENERATED/safes'
import {
  ConfirmationViewTypes,
  ConflictType,
  DetailedExecutionInfoType,
  Operation,
  TransactionInfoType,
  TransactionListItemType,
  TransactionStatus,
  TransactionTokenType,
  TransferDirection,
} from '@safe-global/safe-gateway-typescript-sdk'
import { getDeployedSpendingLimitModuleAddress } from '@/services/contracts/spendingLimitContracts'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { NamedAddress } from '@/components/new-safe/create/types'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'
import { ethers } from 'ethers'
import {
  getSafeToL2MigrationDeployment,
  getSafeMigrationDeployment,
  getMultiSendDeployments,
} from '@safe-global/safe-deployments'
import { Safe__factory, Safe_to_l2_migration__factory } from '@safe-global/utils/types/contracts'
import { hasMatchingDeployment } from '@safe-global/utils/services/contracts/deployments'
import { isMultiSendCalldata } from './transaction-calldata'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'
import { OperationType } from '@safe-global/safe-core-sdk-types'
import { LATEST_SAFE_VERSION } from '@safe-global/utils/config/constants'

export const isTxQueued = (value: TransactionStatus): boolean => {
  return [TransactionStatus.AWAITING_CONFIRMATIONS, TransactionStatus.AWAITING_EXECUTION].includes(value)
}

export const isAwaitingExecution = (txStatus: TransactionStatus): boolean =>
  TransactionStatus.AWAITING_EXECUTION === txStatus

const isAddressEx = (owners: AddressInfo[] | NamedAddress[]): owners is AddressInfo[] => {
  return (owners as AddressInfo[]).every((owner) => owner.value !== undefined)
}

export const isOwner = (safeOwners: AddressInfo[] | NamedAddress[] = [], walletAddress?: string) => {
  if (isAddressEx(safeOwners)) {
    return safeOwners.some((owner) => sameAddress(owner.value, walletAddress))
  }

  return safeOwners.some((owner) => sameAddress(owner.address, walletAddress))
}

export const isMultisigDetailedExecutionInfo = (value?: DetailedExecutionInfo): value is MultisigExecutionDetails => {
  return value?.type === DetailedExecutionInfoType.MULTISIG
}

export const isModuleDetailedExecutionInfo = (value?: DetailedExecutionInfo): value is ModuleExecutionDetails => {
  return value?.type === DetailedExecutionInfoType.MODULE
}

const isMigrateToL2CallData = (value: {
  to: string
  data: string | undefined
  operation?: OperationType | undefined
}) => {
  const safeToL2MigrationDeployment = getSafeToL2MigrationDeployment()
  const safeToL2MigrationAddress = safeToL2MigrationDeployment?.defaultAddress
  const safeToL2MigrationInterface = Safe_to_l2_migration__factory.createInterface()

  if (value.operation === OperationType.DelegateCall && sameAddress(value.to, safeToL2MigrationAddress)) {
    const migrateToL2Selector = safeToL2MigrationInterface?.getFunction('migrateToL2')?.selector
    return migrateToL2Selector && value.data ? value.data.startsWith(migrateToL2Selector) : false
  }
  return false
}

export const isMigrateToL2TxData = (value: TransactionData | undefined, chainId: string | undefined): boolean => {
  if (!value) {
    return false
  }

  if (
    chainId &&
    value?.hexData &&
    isMultiSendCalldata(value?.hexData) &&
    hasMatchingDeployment(getMultiSendDeployments, value.to.value, chainId, ['1.3.0', '1.4.1'])
  ) {
    // Its a multiSend to the MultiSend contract (not CallOnly)
    const decodedMultiSend = decodeMultiSendData(value.hexData)
    const firstTx = decodedMultiSend[0]

    // We only trust the tx if the first tx is the only delegateCall
    const hasMoreDelegateCalls = decodedMultiSend
      .slice(1)
      .some((value) => value.operation === OperationType.DelegateCall)

    if (!hasMoreDelegateCalls && firstTx && isMigrateToL2CallData(firstTx)) {
      return true
    }
  }

  return isMigrateToL2CallData({ to: value.to.value, data: value.hexData, operation: value.operation as 0 | 1 })
}

// TransactionInfo type guards
export const isTransferTxInfo = (value: TransactionInfo): value is Transfer => {
  return value.type === TransactionInfoType.TRANSFER || isSwapTransferOrderTxInfo(value)
}

/**
 * A fulfillment transaction for swap, limit or twap order is always a SwapOrder
 * It cannot be a TWAP order
 *
 * @param value
 */
export const isSwapTransferOrderTxInfo = (value: TransactionInfo): value is SwapOrder => {
  return value.type === TransactionInfoType.SWAP_TRANSFER
}

export const isSettingsChangeTxInfo = (value: TransactionInfo): value is SettingsChange => {
  return value.type === TransactionInfoType.SETTINGS_CHANGE
}

export const isCustomTxInfo = (value: TransactionInfo): value is Custom => {
  return value.type === TransactionInfoType.CUSTOM
}

export const isMultiSendTxInfo = (value: TransactionInfo): value is MultiSend => {
  return (
    value.type === TransactionInfoType.CUSTOM &&
    value.methodName === 'multiSend' &&
    typeof value.actionCount === 'number'
  )
}

export const isOrderTxInfo = (value: TransactionInfo): value is Order => {
  return isSwapOrderTxInfo(value) || isTwapOrderTxInfo(value)
}

export const isMigrateToL2TxInfo = (value: TransactionInfo): value is Custom => {
  const safeToL2MigrationDeployment = getSafeToL2MigrationDeployment()
  const safeToL2MigrationAddress = safeToL2MigrationDeployment?.defaultAddress

  return isCustomTxInfo(value) && sameAddress(value.to.value, safeToL2MigrationAddress)
}

export const isSwapOrderTxInfo = (value: TransactionInfo): value is SwapOrder => {
  return value.type === TransactionInfoType.SWAP_ORDER
}

export const isTwapOrderTxInfo = (value: TransactionInfo): value is TwapOrder => {
  return value.type === TransactionInfoType.TWAP_ORDER
}

export const isStakingTxDepositInfo = (value: TransactionInfo): value is StakingTxDepositInfo => {
  return value.type === TransactionInfoType.NATIVE_STAKING_DEPOSIT
}

export const isStakingTxExitInfo = (value: TransactionInfo): value is StakingTxExitInfo => {
  return value.type === TransactionInfoType.NATIVE_STAKING_VALIDATORS_EXIT
}

export const isStakingTxWithdrawInfo = (value: TransactionInfo): value is StakingTxWithdrawInfo => {
  return value.type === TransactionInfoType.NATIVE_STAKING_WITHDRAW
}

export const isAnyStakingTxInfo = (value: TransactionInfo): value is StakingTxInfo => {
  return isStakingTxDepositInfo(value) || isStakingTxExitInfo(value) || isStakingTxWithdrawInfo(value)
}

export const isTwapConfirmationViewOrder = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is TwapOrderConfirmationView => {
  if (decodedData && 'type' in decodedData) {
    return decodedData.type === ConfirmationViewTypes.COW_SWAP_TWAP_ORDER
  }

  return false
}

export const isSwapConfirmationViewOrder = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is SwapOrderConfirmationView => {
  if (decodedData && 'type' in decodedData) {
    return decodedData.type === ConfirmationViewTypes.COW_SWAP_ORDER
  }

  return false
}

export const isAnySwapConfirmationViewOrder = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is AnySwapOrderConfirmationView => {
  return isSwapConfirmationViewOrder(decodedData) || isTwapConfirmationViewOrder(decodedData)
}

export const isStakingDepositConfirmationView = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is NativeStakingDepositConfirmationView => {
  if (decodedData && 'type' in decodedData) {
    return decodedData?.type === ConfirmationViewTypes.KILN_NATIVE_STAKING_DEPOSIT
  }
  return false
}

export const isStakingExitConfirmationView = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is NativeStakingValidatorsExitConfirmationView => {
  if (decodedData && 'type' in decodedData) {
    return decodedData?.type === ConfirmationViewTypes.KILN_NATIVE_STAKING_VALIDATORS_EXIT
  }
  return false
}

export const isStakingWithdrawConfirmationView = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is NativeStakingWithdrawConfirmationView => {
  if (decodedData && 'type' in decodedData) {
    return decodedData?.type === ConfirmationViewTypes.KILN_NATIVE_STAKING_WITHDRAW
  }
  return false
}

export const isAnyStakingConfirmationView = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is AnyStakingConfirmationView => {
  return (
    isStakingDepositConfirmationView(decodedData) ||
    isStakingExitConfirmationView(decodedData) ||
    isStakingWithdrawConfirmationView(decodedData)
  )
}

export const isGenericConfirmation = (
  decodedData: AnyConfirmationView | undefined,
): decodedData is BaselineConfirmationView => {
  if (decodedData && 'type' in decodedData) {
    return decodedData.type === ConfirmationViewTypes.GENERIC
  }
  return false
}

export const isCancelledSwapOrder = (value: TransactionInfo) => {
  return isSwapOrderTxInfo(value) && value.status === 'cancelled'
}

export const isOpenSwapOrder = (value: TransactionInfo) => {
  return isSwapOrderTxInfo(value) && value.status === 'open'
}

export const isCancellationTxInfo = (value: TransactionInfo): value is Cancellation => {
  return isCustomTxInfo(value) && value.isCancellation
}

export const isCreationTxInfo = (value: TransactionInfo): value is Creation => {
  return value.type === TransactionInfoType.CREATION
}

export const isOutgoingTransfer = (txInfo: TransactionInfo): boolean => {
  return isTransferTxInfo(txInfo) && txInfo.direction.toUpperCase() === TransferDirection.OUTGOING
}

export const isIncomingTransfer = (txInfo: TransactionInfo): boolean => {
  return isTransferTxInfo(txInfo) && txInfo.direction.toUpperCase() === TransferDirection.INCOMING
}

// TransactionListItem type guards
export const isLabelListItem = (value: TransactionListItem): value is Label => {
  return value.type === TransactionListItemType.LABEL
}

export const isConflictHeaderListItem = (value: TransactionListItem): value is ConflictHeader => {
  return value.type === TransactionListItemType.CONFLICT_HEADER
}

export const isDateLabel = (value: TransactionListItem): value is DateLabel => {
  return value.type === TransactionListItemType.DATE_LABEL
}

export const isTransactionListItem = (value: TransactionListItem): value is Transaction => {
  return value.type === TransactionListItemType.TRANSACTION
}

export function isRecoveryQueueItem(value: TransactionListItem | RecoveryQueueItem): value is RecoveryQueueItem {
  const EVENT_SIGNATURE = 'TransactionAdded(uint256,bytes32,address,uint256,bytes,uint8)'
  return 'fragment' in value && ethers.id(EVENT_SIGNATURE) === value.fragment.topicHash
}

// Narrows `Transaction`
// TODO: Consolidate these types with the new sdk
export const isMultisigExecutionInfo = (
  value?: ExecutionInfo | DetailedExecutionInfo,
): value is MultisigExecutionInfo => {
  return value?.type === 'MULTISIG'
}

export const isModuleExecutionInfo = (value?: ExecutionInfo | DetailedExecutionInfo): value is ModuleExecutionInfo =>
  value?.type === 'MODULE'

export const isSignableBy = (txSummary: TransactionSummary, walletAddress: string): boolean => {
  const executionInfo = isMultisigExecutionInfo(txSummary.executionInfo) ? txSummary.executionInfo : undefined
  return !!executionInfo?.missingSigners?.some((address) => address.value === walletAddress)
}

export const isConfirmableBy = (txSummary: TransactionSummary, walletAddress: string): boolean => {
  if (!txSummary.executionInfo || !isMultisigExecutionInfo(txSummary.executionInfo)) {
    return false
  }
  const { confirmationsRequired, confirmationsSubmitted } = txSummary.executionInfo
  return (
    confirmationsSubmitted >= confirmationsRequired ||
    (confirmationsSubmitted === confirmationsRequired - 1 && isSignableBy(txSummary, walletAddress))
  )
}

export const isExecutable = (
  txSummary: TransactionSummary,
  walletAddress: string,
  safe: Pick<SafeInfo, 'nonce'>,
): boolean => {
  if (
    !txSummary.executionInfo ||
    !isMultisigExecutionInfo(txSummary.executionInfo) ||
    safe.nonce !== txSummary.executionInfo.nonce
  ) {
    return false
  }
  return isConfirmableBy(txSummary, walletAddress)
}

// Spending limits
enum SPENDING_LIMIT_METHODS_NAMES {
  ADD_DELEGATE = 'addDelegate',
  SET_ALLOWANCE = 'setAllowance',
  EXECUTE_ALLOWANCE_TRANSFER = 'executeAllowanceTransfer',
  DELETE_ALLOWANCE = 'deleteAllowance',
}

export type SpendingLimitMethods = 'setAllowance' | 'deleteAllowance'

export const isSetAllowance = (method?: string): method is SpendingLimitMethods => {
  return method === SPENDING_LIMIT_METHODS_NAMES.SET_ALLOWANCE
}

export const isDeleteAllowance = (method?: string): method is SpendingLimitMethods => {
  return method === SPENDING_LIMIT_METHODS_NAMES.DELETE_ALLOWANCE
}

export const isSpendingLimitMethod = (method?: string): boolean => {
  return isSetAllowance(method) || isDeleteAllowance(method)
}

export const isSupportedSpendingLimitAddress = (txInfo: TransactionInfo, chainId: string): boolean => {
  const toAddress = isCustomTxInfo(txInfo) ? txInfo.to.value : ''
  const spendingLimitModuleAddress = getDeployedSpendingLimitModuleAddress(chainId, [{ value: toAddress }])
  return !!spendingLimitModuleAddress
}

// Method parameter types
export const isArrayParameter = (parameter: string): boolean => /(\[\d*?])+$/.test(parameter)
export const isAddress = (type: string): boolean => type.indexOf('address') === 0
export const isByte = (type: string): boolean => type.indexOf('byte') === 0

export const isNoneConflictType = (transaction: Transaction) => {
  return transaction.conflictType === ConflictType.NONE
}
export const isHasNextConflictType = (transaction: Transaction) => {
  return transaction.conflictType === ConflictType.HAS_NEXT
}
export const isEndConflictType = (transaction: Transaction) => {
  return transaction.conflictType === ConflictType.END
}

export const isNativeTokenTransfer = (value: TransferInfo): value is NativeCoinTransfer => {
  return value.type === TransactionTokenType.NATIVE_COIN
}

export const isERC20Transfer = (value: TransferInfo): value is Erc20Transfer => {
  return value.type === TransactionTokenType.ERC20
}

export const isERC721Transfer = (value: TransferInfo): value is Erc721Transfer => {
  return value.type === TransactionTokenType.ERC721
}

const safeInterface = Safe__factory.createInterface()
/**
 * True if the tx calls `approveHash`
 */
export const isOnChainConfirmationTxData = (data?: TransactionData): boolean => {
  const approveHashSelector = safeInterface.getFunction('approveHash').selector
  return Boolean(data && data.hexData?.startsWith(approveHashSelector))
}

export const isOnChainConfirmationTxInfo = (info: TransactionInfo): info is Custom => {
  if (isCustomTxInfo(info)) {
    return info.methodName === 'approveHash' && info.dataSize === '36'
  }
  return false
}

/**
 * True if the tx calls `execTransaction`
 */
export const isExecTxData = (data?: TransactionData): boolean => {
  const execTransactionSelector = safeInterface.getFunction('execTransaction').selector
  return Boolean(data && data.hexData?.startsWith(execTransactionSelector))
}

export const isExecTxInfo = (info: TransactionInfo): info is Custom => {
  if (isCustomTxInfo(info)) {
    return info.methodName === 'execTransaction'
  }
  return false
}

export const isNestedConfirmationTxInfo = (info: TransactionInfo): boolean => {
  return isCustomTxInfo(info) && (isOnChainConfirmationTxInfo(info) || isExecTxInfo(info))
}

export const isSafeUpdateTxData = (data?: TransactionData): boolean => {
  if (!data) return false

  // Must be a trusted delegate call
  if (!(data.trustedDelegateCallTarget && data.operation === Operation.DELEGATE)) {
    return false
  }

  // For 1.3.0+ Safes
  const migrationContract = getSafeMigrationDeployment({ version: LATEST_SAFE_VERSION })
  if (migrationContract && sameAddress(data.to.value, migrationContract.defaultAddress)) {
    return true
  }

  // For older Safes
  return (
    isMultiSendCalldata(data.hexData || '') &&
    Boolean(
      data.dataDecoded?.parameters?.[0]?.valueDecoded?.some((tx) => tx.dataDecoded?.method === 'changeMasterCopy'),
    )
  )
}

export const isSafeMigrationTxData = (data?: TransactionData): boolean => {
  if (!data) return false
  return isMigrateToL2CallData({
    data: data.hexData,
    to: data.to.value,
    operation: data.operation as number,
  })
}
</file>

<file path="src/utils/transactions.ts">
import type {
  ChainInfo,
  ExecutionInfo,
  MultisigExecutionDetails,
  MultisigExecutionInfo,
  SafeAppData,
  Transaction,
  TransactionDetails,
  TransactionListPage,
  TransactionSummary,
} from '@safe-global/safe-gateway-typescript-sdk'
import { ConflictType, getTransactionDetails, TransactionListItemType } from '@safe-global/safe-gateway-typescript-sdk'
import {
  isERC20Transfer,
  isModuleDetailedExecutionInfo,
  isMultisigDetailedExecutionInfo,
  isMultisigExecutionInfo,
  isTransactionListItem,
  isTransferTxInfo,
  isTxQueued,
} from './transaction-guards'
import type { MetaTransactionData } from '@safe-global/safe-core-sdk-types/dist/src/types'
import { OperationType } from '@safe-global/safe-core-sdk-types/dist/src/types'
import { getReadOnlyGnosisSafeContract } from '@/services/contracts/safeContracts'
import extractTxInfo from '@/services/tx/extractTxInfo'
import type { AdvancedParameters } from '@/components/tx/AdvancedParams'
import type { SafeTransaction, TransactionOptions } from '@safe-global/safe-core-sdk-types'
import uniqBy from 'lodash/uniqBy'
import { Errors, logError } from '@/services/exceptions'
import { type BaseTransaction } from '@safe-global/safe-apps-sdk'
import { isEmptyHexData } from '@/utils/hex'
import { isMultiSendCalldata } from './transaction-calldata'
import { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'
import { getOriginPath } from './url'
import { FEATURES, hasFeature } from '@safe-global/utils/utils/chains'

export const makeTxFromDetails = (txDetails: TransactionDetails): Transaction => {
  const getMissingSigners = ({
    signers,
    confirmations,
    confirmationsRequired,
  }: MultisigExecutionDetails): MultisigExecutionInfo['missingSigners'] => {
    if (confirmations.length >= confirmationsRequired) return

    const missingSigners = signers.filter(({ value }) => {
      const hasConfirmed = confirmations?.some(({ signer }) => signer?.value === value)
      return !hasConfirmed
    })

    return missingSigners.length > 0 ? missingSigners : undefined
  }

  const getMultisigExecutionInfo = ({
    detailedExecutionInfo,
  }: TransactionDetails): MultisigExecutionInfo | undefined => {
    if (!isMultisigDetailedExecutionInfo(detailedExecutionInfo)) return undefined

    return {
      type: detailedExecutionInfo.type,
      nonce: detailedExecutionInfo.nonce,
      confirmationsRequired: detailedExecutionInfo.confirmationsRequired,
      confirmationsSubmitted: detailedExecutionInfo.confirmations?.length ?? 0,
      missingSigners: getMissingSigners(detailedExecutionInfo),
    }
  }

  const executionInfo: ExecutionInfo | undefined = isModuleDetailedExecutionInfo(txDetails.detailedExecutionInfo)
    ? (txDetails.detailedExecutionInfo as ExecutionInfo)
    : getMultisigExecutionInfo(txDetails)

  // Will only be used as a fallback whilst waiting on backend tx creation cache
  const now = Date.now()
  const timestamp = isTxQueued(txDetails.txStatus)
    ? isMultisigDetailedExecutionInfo(txDetails.detailedExecutionInfo)
      ? txDetails.detailedExecutionInfo.submittedAt
      : now
    : (txDetails.executedAt ?? now)

  return {
    type: TransactionListItemType.TRANSACTION,
    transaction: {
      id: txDetails.txId,
      timestamp,
      txStatus: txDetails.txStatus,
      txInfo: txDetails.txInfo,
      executionInfo,
      safeAppInfo: txDetails?.safeAppInfo,
      txHash: txDetails?.txHash || null,
    },
    conflictType: ConflictType.NONE,
  }
}

const getSignatures = (confirmations: Record<string, string>) => {
  return Object.entries(confirmations)
    .filter(([, signature]) => Boolean(signature))
    .sort(([signerA], [signerB]) => signerA.toLowerCase().localeCompare(signerB.toLowerCase()))
    .reduce((prev, [, signature]) => {
      return prev + signature.slice(2)
    }, '0x')
}

export const getMultiSendTxs = async (
  txs: TransactionDetails[],
  chain: ChainInfo,
  safeAddress: string,
  safeVersion: string,
): Promise<MetaTransactionData[]> => {
  const readOnlySafeContract = await getReadOnlyGnosisSafeContract(chain, safeVersion)

  return txs
    .map((tx) => {
      if (!isMultisigDetailedExecutionInfo(tx.detailedExecutionInfo)) return

      const args = extractTxInfo(tx)
      const sigs = getSignatures(args.signatures)

      // @ts-ignore
      const data = readOnlySafeContract.encode('execTransaction', [
        args.txParams.to,
        args.txParams.value,
        args.txParams.data,
        args.txParams.operation,
        args.txParams.safeTxGas,
        args.txParams.baseGas,
        args.txParams.gasPrice,
        args.txParams.gasToken,
        args.txParams.refundReceiver,
        sigs,
      ])

      return {
        operation: OperationType.Call,
        to: safeAddress,
        value: '0',
        data,
      }
    })
    .filter(Boolean) as MetaTransactionData[]
}

export const getTxOptions = (params: AdvancedParameters, currentChain: ChainInfo | undefined): TransactionOptions => {
  const txOptions: TransactionOptions = {
    gasLimit: params.gasLimit?.toString(),
    maxFeePerGas: params.maxFeePerGas?.toString(),
    maxPriorityFeePerGas: params.maxPriorityFeePerGas?.toString(),
    nonce: params.userNonce,
  }

  // Some chains don't support EIP-1559 gas price params
  if (currentChain && !hasFeature(currentChain, FEATURES.EIP1559)) {
    txOptions.gasPrice = txOptions.maxFeePerGas
    delete txOptions.maxFeePerGas
    delete txOptions.maxPriorityFeePerGas
  }

  return txOptions
}

export const getQueuedTransactionCount = (txPage?: TransactionListPage): string => {
  if (!txPage) {
    return '0'
  }

  const queuedTxs = txPage.results.filter(isTransactionListItem)

  const queuedTxsByNonce = uniqBy(queuedTxs, (item) =>
    isMultisigExecutionInfo(item.transaction.executionInfo) ? item.transaction.executionInfo.nonce : '',
  )

  if (txPage.next) {
    return `> ${queuedTxsByNonce.length}`
  }

  return queuedTxsByNonce.length.toString()
}

export const getTxOrigin = (app?: Partial<SafeAppData>): string | undefined => {
  if (!app) return

  const MAX_ORIGIN_LENGTH = 200
  const { url = '', name = '' } = app
  let origin: string | undefined

  try {
    // Must include empty string to avoid including the length of `undefined`
    const maxUrlLength = MAX_ORIGIN_LENGTH - JSON.stringify({ url: '', name: '' }).length
    const trimmedUrl = getOriginPath(url).slice(0, maxUrlLength)

    const maxNameLength = Math.max(0, maxUrlLength - trimmedUrl.length)
    const trimmedName = name.slice(0, maxNameLength)

    origin = JSON.stringify({ url: trimmedUrl, name: trimmedName })
  } catch (e) {
    logError(Errors._808, e)
  }

  return origin
}

export const decodeSafeTxToBaseTransactions = (safeTx: SafeTransaction): BaseTransaction[] => {
  const txs: BaseTransaction[] = []
  const safeTxData = safeTx.data.data
  if (isMultiSendCalldata(safeTxData)) {
    txs.push(...decodeMultiSendData(safeTxData))
  } else {
    txs.push({
      data: safeTxData,
      value: safeTx.data.value,
      to: safeTx.data.to,
    })
  }
  return txs
}

export const isRejectionTx = (tx?: SafeTransaction) => {
  return !!tx && !!tx.data.data && isEmptyHexData(tx.data.data) && tx.data.value === '0'
}

export const isTrustedTx = (tx: TransactionSummary) => {
  return (
    isMultisigExecutionInfo(tx.executionInfo) ||
    isModuleDetailedExecutionInfo(tx.executionInfo) ||
    !isTransferTxInfo(tx.txInfo) ||
    !isERC20Transfer(tx.txInfo.transferInfo) ||
    Boolean(tx.txInfo.transferInfo.trusted)
  )
}

export const isImitation = ({ txInfo }: TransactionSummary): boolean => {
  return isTransferTxInfo(txInfo) && isERC20Transfer(txInfo.transferInfo) && Boolean(txInfo.transferInfo.imitation)
}

export const getSafeTransaction = async (safeTxHash: string, chainId: string, safeAddress: string) => {
  const txId = `multisig_${safeAddress}_${safeTxHash}`

  try {
    return await getTransactionDetails(chainId, txId)
  } catch (e) {
    return undefined
  }
}
</file>

<file path="src/utils/tx-history-filter.ts">
import { useMemo } from 'react'
import { useRouter } from 'next/router'
import {
  getIncomingTransfers,
  getModuleTransactions,
  getMultisigTransactions,
  type TransactionListPage,
} from '@safe-global/safe-gateway-typescript-sdk'
import type { operations } from '@safe-global/safe-gateway-typescript-sdk/dist/types/api'
import type { ParsedUrlQuery } from 'querystring'
import { startOfDay, endOfDay } from 'date-fns'

import type { TxFilterFormState } from '@/components/transactions/TxFilterForm'
import { getTimezone } from '@/services/transactions'

type IncomingTxFilter = NonNullable<operations['incoming_transfers']['parameters']['query']>
type MultisigTxFilter = NonNullable<operations['multisig_transactions']['parameters']['query']>
type ModuleTxFilter = NonNullable<operations['module_transactions']['parameters']['query']>

export enum TxFilterType {
  INCOMING = 'Incoming',
  MULTISIG = 'Outgoing',
  MODULE = 'Module-based',
}

export type TxFilter = {
  type: TxFilterType
  filter: IncomingTxFilter | MultisigTxFilter | ModuleTxFilter // CGW filter
}

export const _omitNullish = (data: { [key: string]: any }) => {
  return Object.fromEntries(
    Object.entries(data).filter(([, value]) => {
      return value !== '' && value != null
    }),
  )
}

export const _isValidTxFilterType = (type: unknown) => {
  return !!type && Object.values(TxFilterType).includes(type as TxFilterType)
}

export const _isModuleFilter = (filter: TxFilter['filter']): filter is ModuleTxFilter => {
  return 'module' in filter
}

// Spread TxFilter basically
type TxFilterUrlQuery = {
  type: TxFilter['type']
} & TxFilter['filter']

export const txFilter = {
  parseUrlQuery: ({ type, ...filter }: ParsedUrlQuery): TxFilter | null => {
    if (!_isValidTxFilterType(type)) return null

    return {
      type: type as TxFilterType,
      filter: filter as TxFilter['filter'],
    }
  },

  parseFormData: ({ type, ...formData }: TxFilterFormState): TxFilter => {
    const filter: TxFilter['filter'] = _omitNullish({
      ...formData,
      execution_date__gte: formData.execution_date__gte
        ? startOfDay(formData.execution_date__gte).toISOString()
        : undefined,
      execution_date__lte: formData.execution_date__lte
        ? endOfDay(formData.execution_date__lte).toISOString()
        : undefined,
      value: formData.value,
    })

    return {
      type,
      filter,
    }
  },

  formatUrlQuery: ({ type, filter }: TxFilter): TxFilterUrlQuery => {
    return {
      type,
      ...filter,
    }
  },

  formatFormData: ({ type, filter }: TxFilter): Partial<TxFilterFormState> => {
    const isModule = _isModuleFilter(filter)

    return {
      type,
      ...filter,
      execution_date__gte: !isModule && filter.execution_date__gte ? new Date(filter.execution_date__gte) : null,
      execution_date__lte: !isModule && filter.execution_date__lte ? new Date(filter.execution_date__lte) : null,
      value: isModule ? '' : filter.value,
    }
  },
}

export const useTxFilter = (): [TxFilter | null, (filter: TxFilter | null) => void] => {
  const router = useRouter()
  const filter = useMemo(() => txFilter.parseUrlQuery(router.query), [router.query])

  const setQuery = (filter: TxFilter | null) => {
    router.push({
      pathname: router.pathname,
      query: {
        safe: router.query.safe,
        ...(filter && txFilter.formatUrlQuery(filter)),
      },
    })
  }

  return [filter, setQuery]
}

export const fetchFilteredTxHistory = async (
  chainId: string,
  safeAddress: string,
  filterData: TxFilter,
  hideUntrustedTxs: boolean,
  hideImitationTxs: boolean,
  pageUrl?: string,
): Promise<TransactionListPage> => {
  const fetchPage = () => {
    const query = {
      ...filterData.filter,
      timezone: getTimezone(),
      trusted: hideUntrustedTxs,
      imitation: !hideImitationTxs,
      executed: filterData.type === TxFilterType.MULTISIG ? 'true' : undefined,
    }

    switch (filterData.type) {
      case TxFilterType.INCOMING: {
        return getIncomingTransfers(chainId, safeAddress, query, pageUrl)
      }
      case TxFilterType.MULTISIG: {
        return getMultisigTransactions(chainId, safeAddress, query, pageUrl)
      }
      case TxFilterType.MODULE: {
        return getModuleTransactions(chainId, safeAddress, query, pageUrl)
      }
      default: {
        return { results: [] }
      }
    }
  }

  return await fetchPage()
}
</file>

<file path="src/utils/tx-link.ts">
import type { ChainInfo } from '@safe-global/safe-gateway-typescript-sdk'
import type { LinkProps } from 'next/link'
import { AppRoutes } from '@/config/routes'

export const getTxLink = (
  txId: string,
  chain: ChainInfo,
  safeAddress: string,
): { href: LinkProps['href']; title: string } => {
  return {
    href: {
      pathname: AppRoutes.transactions.tx,
      query: { id: txId, safe: `${chain?.shortName}:${safeAddress}` },
    },
    title: 'View transaction',
  }
}
</file>

<file path="src/utils/tx-list.ts">
import { TransactionInfoType } from '@safe-global/safe-gateway-typescript-sdk'
import type { Transaction, TransactionListItem } from '@safe-global/safe-gateway-typescript-sdk'

import { isConflictHeaderListItem, isNoneConflictType, isTransactionListItem } from '@/utils/transaction-guards'
import { sameAddress } from '@safe-global/utils/utils/addresses'
import type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'

type GroupedTxs = Array<TransactionListItem | Transaction[]>

export const groupTxs = (list: TransactionListItem[]) => {
  const groupedByConflicts = groupConflictingTxs(list)
  return groupBulkTxs(groupedByConflicts)
}

/**
 * Group txs by conflict header
 */
export const groupConflictingTxs = (list: TransactionListItem[]): GroupedTxs => {
  return list
    .reduce<GroupedTxs>((resultItems, item) => {
      if (isConflictHeaderListItem(item)) {
        return resultItems.concat([[]])
      }

      const prevItem = resultItems[resultItems.length - 1]
      if (Array.isArray(prevItem) && isTransactionListItem(item) && !isNoneConflictType(item)) {
        prevItem.push(item)
        return resultItems
      }

      return resultItems.concat(item)
    }, [])
    .map((item) => {
      if (Array.isArray(item)) {
        return item.sort((a, b) => b.transaction.timestamp - a.transaction.timestamp)
      }
      return item
    })
}

/**
 * Group txs by tx hash
 */
const groupBulkTxs = (list: GroupedTxs): GroupedTxs => {
  return list
    .reduce<GroupedTxs>((resultItems, item) => {
      if (Array.isArray(item) || !isTransactionListItem(item)) {
        return resultItems.concat([item])
      }
      const currentTxHash = item.transaction.txHash

      const prevItem = resultItems[resultItems.length - 1]
      if (!Array.isArray(prevItem)) return resultItems.concat([[item]])
      const prevTxHash = prevItem[0].transaction.txHash

      if (currentTxHash && currentTxHash === prevTxHash) {
        prevItem.push(item)
        return resultItems
      }

      return resultItems.concat([[item]])
    }, [])
    .map((item) => (Array.isArray(item) && item.length === 1 ? item[0] : item))
}

export function _getRecoveryCancellations(moduleAddress: string, transactions: Array<Transaction>) {
  const CANCELLATION_TX_METHOD_NAME = 'setTxNonce'

  return transactions.filter(({ transaction }) => {
    const { txInfo } = transaction
    return (
      txInfo.type === TransactionInfoType.CUSTOM &&
      sameAddress(txInfo.to.value, moduleAddress) &&
      txInfo.methodName === CANCELLATION_TX_METHOD_NAME
    )
  })
}

type GroupedRecoveryQueueItem = Transaction | RecoveryQueueItem

export function groupRecoveryTransactions(queue: Array<TransactionListItem>, recoveryQueue: Array<RecoveryQueueItem>) {
  const transactions = queue.filter(isTransactionListItem)

  return recoveryQueue.reduce<Array<RecoveryQueueItem | Array<GroupedRecoveryQueueItem>>>((acc, item) => {
    const cancellations = _getRecoveryCancellations(item.address, transactions)

    if (cancellations.length === 0) {
      acc.push(item)
    } else {
      acc.push([item, ...cancellations])
    }

    return acc
  }, [])
}

export const getLatestTransactions = (list: TransactionListItem[] = []): Transaction[] => {
  return (
    groupConflictingTxs(list)
      // Get latest transaction if there are conflicting ones
      .map((group) => (Array.isArray(group) ? group[0] : group))
      .filter(isTransactionListItem)
  )
}
</file>

<file path="src/utils/url.ts">
export const trimTrailingSlash = (url: string): string => {
  return url.replace(/\/$/, '')
}

export const isSameUrl = (url1: string, url2: string): boolean => {
  return trimTrailingSlash(url1) === trimTrailingSlash(url2)
}
export const prefixedAddressRe = /[a-z0-9-]+\:0x[a-f0-9]{40}/i
const invalidProtocolRegex = /^(\W*)(javascript|data|vbscript)/im
const ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim
const urlSchemeRegex = /^([^:]+):/gm
const relativeFirstCharacters = ['.', '/']
export const isRelativeUrl = (url: string): boolean => {
  return relativeFirstCharacters.indexOf(url[0]) > -1
}

export const sanitizeUrl = (url: string): string => {
  const sanitizedUrl = url.replace(ctrlCharactersRegex, '').trim()

  if (isRelativeUrl(sanitizedUrl)) {
    return sanitizedUrl
  }

  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex)
  if (!urlSchemeParseResults) {
    return sanitizedUrl
  }

  const urlScheme = urlSchemeParseResults[0]
  if (invalidProtocolRegex.test(urlScheme)) {
    throw new Error('Invalid protocol')
  }

  return sanitizedUrl
}

export const getOriginPath = (url: string): string => {
  try {
    const { origin, pathname } = new URL(url)
    return origin + (pathname === '/' ? '' : pathname)
  } catch (e) {
    console.error('Error parsing URL', url, e)
    return url
  }
}
</file>

<file path="src/utils/wallets.ts">
import type { EthersError } from '@/utils/ethers-utils'
import { getWalletConnectLabel, type ConnectedWallet } from '@/hooks/wallets/useOnboard'
import { getWeb3ReadOnly } from '@/hooks/wallets/web3'
import { WALLET_KEYS } from '@/hooks/wallets/consts'
import { EMPTY_DATA } from '@safe-global/protocol-kit/dist/src/utils/constants'
import memoize from 'lodash/memoize'
import { PRIVATE_KEY_MODULE_LABEL } from '@/services/private-key-module'
import { type JsonRpcProvider } from 'ethers'

const WALLETCONNECT = 'WalletConnect'
const WC_LEDGER = 'Ledger Wallet'

const isWCRejection = (err: Error): boolean => {
  return /rejected/.test(err?.message)
}

const isEthersRejection = (err: EthersError): boolean => {
  return err.code === 'ACTION_REJECTED'
}

export const isWalletRejection = (err: EthersError | Error): boolean => {
  return isEthersRejection(err as EthersError) || isWCRejection(err)
}

export const isEthSignWallet = (wallet: ConnectedWallet): boolean => {
  return [WALLET_KEYS.TREZOR, WALLET_KEYS.KEYSTONE].includes(wallet.label.toUpperCase() as WALLET_KEYS)
}

export const isLedgerLive = (wallet: ConnectedWallet): boolean => {
  return getWalletConnectLabel(wallet) === WC_LEDGER
}

export const isLedger = (wallet: ConnectedWallet): boolean => {
  return wallet.label.toUpperCase() === WALLET_KEYS.LEDGER || isLedgerLive(wallet)
}

export const isWalletConnect = (wallet: ConnectedWallet): boolean => {
  return wallet.label.toLowerCase().startsWith(WALLETCONNECT.toLowerCase())
}

export const isHardwareWallet = (wallet: ConnectedWallet): boolean => {
  return [WALLET_KEYS.LEDGER, WALLET_KEYS.TREZOR, WALLET_KEYS.KEYSTONE].includes(
    wallet.label.toUpperCase() as WALLET_KEYS,
  )
}

export const isPKWallet = (wallet: ConnectedWallet): boolean => {
  return wallet.label.toUpperCase() === WALLET_KEYS.PK
}

export const isSmartContract = async (address: string, provider?: JsonRpcProvider): Promise<boolean> => {
  const web3 = provider ?? getWeb3ReadOnly()

  if (!web3) {
    throw new Error('Provider not found')
  }

  const code = await web3.getCode(address)

  return code !== EMPTY_DATA
}

export const isSmartContractWallet = memoize(
  async (_chainId: string, address: string): Promise<boolean> => {
    return isSmartContract(address)
  },
  (chainId, address) => chainId + address,
)

/* Check if the wallet is unlocked. */
export const isWalletUnlocked = async (walletName: string): Promise<boolean | undefined> => {
  if ([PRIVATE_KEY_MODULE_LABEL, WALLETCONNECT].includes(walletName)) return true

  const METAMASK_LIKE = ['MetaMask', 'Rabby Wallet', 'Zerion']

  // Only MetaMask exposes a method to check if the wallet is unlocked
  if (METAMASK_LIKE.includes(walletName)) {
    if (typeof window === 'undefined' || !window.ethereum?._metamask) return false
    try {
      return await window.ethereum?._metamask.isUnlocked()
    } catch {
      return false
    }
  }

  return false
}
</file>

<file path="src/definitions.d.ts">
import type React from 'react'
import type { BeamerConfig, BeamerMethods } from '@services/beamer/types'

declare global {
  interface Window {
    isDesktop?: boolean
    ethereum?: {
      autoRefreshOnNetworkChange: boolean
      isMetaMask: boolean
      _metamask: {
        isUnlocked: () => Promise<boolean>
      }
      isConnected?: () => boolean
    }
    beamer_config?: BeamerConfig
    Beamer?: BeamerMethods
    dataLayer?: any[]
    gtag?: (...args: any[]) => void
    Cypress?
  }
}

declare module '@mui/material/Button' {
  interface ButtonPropsVariantOverrides {
    danger: true
  }
}

declare module '*.svg' {
  const content: any
  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>
  export default content
}

export {}
</file>

<file path=".dockerignore">
Dockerfile
.dockerignore
node_modules
npm-debug.log
.next
.git
coverage
.DS_Store
.idea
dist

build/
coverage/
cypress/
out/
</file>

<file path=".env.example">
NEXT_PUBLIC_INFURA_TOKEN=1234567890
NEXT_PUBLIC_WC_PROJECT_ID=0987654321
NEXT_PUBLIC_IS_OFFICIAL_HOST=false
</file>

<file path=".gitignore">
# Auto-generated service workers
public/*.js
public/*.map
</file>

<file path="cypress.config.js">
import { defineConfig } from 'cypress'
import 'dotenv/config'
import * as fs from 'fs'
import { configureVisualRegression } from 'cypress-visual-regression'
import { version } from './src/markdown/terms/version.js'

export default defineConfig({
  projectId: 'exhdra',
  trashAssetsBeforeRuns: true,
  reporter: 'junit',
  reporterOptions: {
    mochaFile: 'reports/junit-[hash].xml',
  },
  retries: {
    runMode: 3,
    openMode: 0,
  },
  e2e: {
    screenshotsFolder: './cypress/snapshots/actual',
    setupNodeEvents(on, config) {
      // Set Cookie term version on the cypress env - this way we can access it in the tests
      config.env.CURRENT_COOKIE_TERMS_VERSION = version

      configureVisualRegression(on),
        on('task', {
          log(message) {
            console.log(message)
            return null
          },
        })

      on('after:spec', (spec, results) => {
        if (results && results.video) {
          const failures = results.tests.some((test) => test.attempts.some((attempt) => attempt.state === 'failed'))
          if (!failures) {
            fs.unlinkSync(results.video)
          }
        }
      })

      return config
    },
    env: {
      ...process.env,
      visualRegressionType: 'regression',
      visualRegressionBaseDirectory: 'cypress/snapshots/actual',
      visualRegressionDiffDirectory: 'cypress/snapshots/diff',
      visualRegressionGenerateDiff: 'fail',
    },
    baseUrl: 'http://localhost:3000',
    testIsolation: false,
    hideXHR: true,
    defaultCommandTimeout: 10000,
    pageLoadTimeout: 60000,
    numTestsKeptInMemory: 20,
  },

  chromeWebSecurity: false,
})
</file>

<file path="Dockerfile">
FROM node:18-alpine
RUN apk add --no-cache libc6-compat git python3 py3-pip make g++ libusb-dev eudev-dev linux-headers

# Set working directory
WORKDIR /app

# Copy root
COPY . .

# Set working directory to the web app
WORKDIR apps/web

# Enable corepack and configure yarn
RUN corepack enable
RUN yarn config set httpTimeout 300000

# Run any custom post-install scripts
RUN yarn install --immutable
RUN yarn after-install

# Set environment variables
ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1
ENV PORT 3000

# Expose the port
EXPOSE 3000

# Command to start the application
CMD ["yarn", "static-serve"]
</file>

<file path="eslint.config.mjs">
import unusedImports from 'eslint-plugin-unused-imports'
import typescriptEslint from '@typescript-eslint/eslint-plugin'
import noOnlyTests from 'eslint-plugin-no-only-tests'
import tsParser from '@typescript-eslint/parser'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import js from '@eslint/js'
import { FlatCompat } from '@eslint/eslintrc'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
})

export default [
  {
    ignores: ['**/node_modules/', '**/.next/', '**/.github/', '**/cypress/', '**/src/types/contracts/'],
  },
  ...compat.extends('next', 'prettier', 'plugin:prettier/recommended', 'plugin:storybook/recommended'),
  {
    plugins: {
      'unused-imports': unusedImports,
      '@typescript-eslint': typescriptEslint,
      'no-only-tests': noOnlyTests,
    },

    languageOptions: {
      parser: tsParser,
      ecmaVersion: 5,
      sourceType: 'script',

      parserOptions: {
        project: ['./tsconfig.json'],
      },
    },

    rules: {
      '@next/next/no-img-element': 'off',
      '@next/next/google-font-display': 'off',
      '@next/next/google-font-preconnect': 'off',
      '@next/next/no-page-custom-font': 'off',
      'unused-imports/no-unused-imports': 'error',
      '@typescript-eslint/consistent-type-imports': 'error',
      '@typescript-eslint/await-thenable': 'error',
      'no-constant-condition': 'warn',

      'unused-imports/no-unused-vars': [
        'error',
        {
          varsIgnorePattern: '^_',
        },
      ],

      'react-hooks/exhaustive-deps': [
        'warn',
        {
          additionalHooks: 'useAsync',
        },
      ],

      'no-only-tests/no-only-tests': 'error',
      'object-shorthand': ['error', 'properties'],
      'jsx-quotes': ['error', 'prefer-double'],

      'react/jsx-curly-brace-presence': [
        'error',
        {
          props: 'never',
          children: 'never',
        },
      ],
    },
  },
]
</file>

<file path="jest.config.cjs">
const nextJest = require('next/jest')
const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
})

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],

  moduleNameMapper: {
    // Handle module aliases (this will be automatically configured for you soon)
    '^@/(.*)$': '<rootDir>/src/$1',
    '^react$': '<rootDir>/node_modules/react',
    '^react-dom$': '<rootDir>/node_modules/react-dom',
    '^.+\\.(svg)$': '<rootDir>/mocks/svg.js',
    '^.+/markdown/terms/terms\\.md$': '<rootDir>/mocks/terms.md.js',
    isows: '<rootDir>/node_modules/isows/_cjs/index.js',
    '^@safe-global/utils/(.*)$': '<rootDir>/../../packages/utils/src/$1',
  },
  // https://github.com/mswjs/jest-fixed-jsdom
  // without this environment it is basically impossible to run tests with msw
  testEnvironment: 'jest-fixed-jsdom',

  testEnvironmentOptions: {
    url: 'http://localhost/balances?safe=rin:0xb3b83bf204C458B461de9B0CD2739DB152b4fa5A',
    // https://github.com/mswjs/msw/issues/1786#issuecomment-2426900455
    // without this line 4 tests related to firefox fail
    customExportConditions: ['node'],
  },
  coveragePathIgnorePatterns: ['/node_modules/', '/src/tests/', '/src/types/contracts/'],
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = async () => ({
  ...(await createJestConfig(customJestConfig)()),
  transformIgnorePatterns: [
    'node_modules/(?!(uint8arrays|multiformats|@web3-onboard/common|@walletconnect/(.*)/uint8arrays)/)',
  ],
})
</file>

<file path="jest.setup.js">
// Used for __tests__/testing-library.js
// Learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom'
import { server } from '@/tests/server'

jest.mock('@web3-onboard/coinbase', () => jest.fn())
jest.mock('@web3-onboard/injected-wallets', () => ({ ProviderLabel: { MetaMask: 'MetaMask' } }))
jest.mock('@web3-onboard/walletconnect', () => jest.fn())
jest.mock('@safe-global/safe-client-gateway-sdk')

const mockOnboardState = {
  chains: [],
  walletModules: [],
  wallets: [],
  accountCenter: {},
}

jest.mock('@web3-onboard/core', () => () => ({
  connectWallet: jest.fn(),
  disconnectWallet: jest.fn(),
  setChain: jest.fn(),
  state: {
    select: (key) => ({
      subscribe: (next) => {
        next(mockOnboardState[key])

        return {
          unsubscribe: jest.fn(),
        }
      },
    }),
    get: () => mockOnboardState,
  },
}))

// This is required for jest.spyOn to work with imported modules.
// After Next 13, imported modules have `configurable: false` for named exports,
// which means that `jest.spyOn` cannot modify the exported function.
const defineProperty = Object.defineProperty
Object.defineProperty = (obj, prop, desc) => {
  if (prop !== 'prototype') {
    desc.configurable = true
  }
  return defineProperty(obj, prop, desc)
}

beforeAll(() => {
  server.listen()
})

afterEach(() => server.resetHandlers())
afterAll(() => server.close())
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.
</file>

<file path="next.config.mjs">
import path from 'path'
import withBundleAnalyzer from '@next/bundle-analyzer'
import withPWAInit from '@ducanh2912/next-pwa'
import remarkGfm from 'remark-gfm'
import remarkHeadingId from 'remark-heading-id'
import createMDX from '@next/mdx'
import remarkFrontmatter from 'remark-frontmatter'
import remarkMdxFrontmatter from 'remark-mdx-frontmatter'
import { readFile } from 'fs/promises'
import { fileURLToPath } from 'url'

const SERVICE_WORKERS_PATH = './src/service-workers'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const pkgPath = path.join(__dirname, 'package.json')
const data = await readFile(pkgPath, 'utf-8')
const pkg = JSON.parse(data)

const withPWA = withPWAInit({
  dest: 'public',
  workboxOptions: {
    mode: 'production',
  },
  reloadOnOnline: false,
  publicExcludes: [],
  buildExcludes: [/./],
  customWorkerSrc: SERVICE_WORKERS_PATH,
  // Prefer InjectManifest for Web Push
  swSrc: `${SERVICE_WORKERS_PATH}/index.ts`,

  runtimeCaching: [
    {
      urlPattern: /\.(js|css|png|jpg|jpeg|gif|webp|svg|ico|ttf|woff|woff2|eot)$/,
      handler: 'CacheFirst',
      options: {
        cacheName: 'static-assets',
        expiration: {
          maxEntries: 1000,
          maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        },
      },
    },
  ],

  cacheId: pkg.version,
})

/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // static site export

  transpilePackages: ['@safe-global/store'],
  images: {
    unoptimized: true,
  },

  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
  reactStrictMode: false,
  productionBrowserSourceMaps: true,
  eslint: {
    dirs: ['src', 'cypress'],
  },
  experimental: {
    optimizePackageImports: [
      '@mui/material',
      '@mui/icons-material',
      'lodash',
      'date-fns',
      '@sentry/react',
      '@gnosis.pm/zodiac',
    ],
  },
  webpack(config, { dev }) {
    config.module.rules.push({
      test: /\.svg$/i,
      issuer: { and: [/\.(js|ts|md)x?$/] },
      use: [
        {
          loader: '@svgr/webpack',
          options: {
            prettier: false,
            svgo: false,
            svgoConfig: {
              plugins: [
                {
                  name: 'preset-default',
                  params: {
                    overrides: { removeViewBox: false },
                  },
                },
              ],
            },
            titleProp: true,
          },
        },
      ],
    })

    config.resolve.alias = {
      ...config.resolve.alias,
      'bn.js': path.resolve('../../node_modules/bn.js/lib/bn.js'),
      'mainnet.json': path.resolve('../..node_modules/@ethereumjs/common/dist.browser/genesisStates/mainnet.json'),
      '@mui/material$': path.resolve('./src/components/common/Mui'),
      react: path.resolve('./node_modules/react'),
      'react-dom': path.resolve('./node_modules/react-dom'),
    }

    if (dev) {
      config.optimization.splitChunks = {
        ...config.optimization.splitChunks,
        cacheGroups: {
          ...config.optimization.splitChunks.cacheGroups,
          customModule: {
            test: /[\\/]..[\\/]..[\\/]node_modules[\\/](@safe-global|ethers)[\\/]/,
            name: 'protocol-kit-ethers',
            chunks: 'all',
          },
        },
      }
      config.optimization.minimize = false
    }

    return config
  },
}
const withMDX = createMDX({
  extension: /\.(md|mdx)?$/,
  jsx: true,
  options: {
    remarkPlugins: [remarkFrontmatter, [remarkMdxFrontmatter, { name: 'metadata' }], remarkHeadingId, remarkGfm],
    rehypePlugins: [],
  },
})

export default withBundleAnalyzer({
  enabled: process.env.ANALYZE === 'true',
})(withPWA(withMDX(nextConfig)))
</file>

<file path="package.json">
{
  "name": "@safe-global/web",
  "homepage": "https://github.com/safe-global/safe-wallet-web",
  "license": "GPL-3.0",
  "version": "1.56.2",
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "start": "next dev",
    "build": "next build",
    "lint": "tsc && next lint",
    "lint:fix": "next lint --fix",
    "prettier": "prettier -w \"{src,cypress,mocks,scripts}/**/*.{ts,tsx,css,js}\"",
    "fix": "yarn lint:fix && ts-prune && yarn prettier",
    "test": "cross-env TZ=CET DEBUG_PRINT_LIMIT=30000 jest",
    "test:ci": "yarn test --ci --silent --coverage --json --watchAll=false --testLocationInResults --outputFile=report.json",
    "test:coverage": "yarn test --coverage --watchAll=false",
    "cmp": "./scripts/cmp.sh",
    "routes": "node scripts/generate-routes.js > src/config/routes.ts && prettier -w src/config/routes.ts && cat src/config/routes.ts",
    "css-vars": "npx -y tsx ./scripts/css-vars.ts > ./src/styles/vars.css && prettier -w src/styles/vars.css",
    "generate-types": "typechain --target ethers-v6 --out-dir ../../packages/utils/src/types/contracts ../../node_modules/@safe-global/safe-deployments/dist/assets/**/*.json ../../node_modules/@safe-global/safe-modules-deployments/dist/assets/**/*.json ../../node_modules/@openzeppelin/contracts/build/contracts/ERC20.json ../../node_modules/@openzeppelin/contracts/build/contracts/ERC721.json",
    "after-install": "yarn generate-types",
    "postinstall": "yarn after-install",
    "analyze": "cross-env ANALYZE=true yarn build",
    "cypress:open": "cross-env TZ=UTC cypress open --e2e",
    "cypress:canary": "cross-env TZ=UTC cypress open --e2e -b chrome:canary",
    "cypress:run": "cypress run",
    "cypress:ci": "yarn cypress:run --config baseUrl=http://localhost:8080 --spec cypress/e2e/smoke/*.cy.js",
    "serve": "sh -c 'npx -y serve out -p ${REVERSE_PROXY_UI_PORT:=8080}'",
    "static-serve": "yarn build && yarn serve",
    "prepare": "husky",
    "storybook": "storybook dev -p 6006",
    "build-storybook": "storybook build --quiet",
    "integrity": "node scripts/integrity-hashes.cjs"
  },
  "engines": {
    "node": ">=18"
  },
  "dependencies": {
    "@cowprotocol/widget-react": "^0.13.0",
    "@datadog/browser-logs": "^6.6.3",
    "@ducanh2912/next-pwa": "^10.2.9",
    "@emotion/cache": "^11.13.5",
    "@emotion/react": "^11.13.5",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.13.5",
    "@gnosis.pm/zodiac": "^4.0.3",
    "@ledgerhq/context-module": "^1.3.1",
    "@ledgerhq/device-management-kit": "^0.6.5",
    "@ledgerhq/device-signer-kit-ethereum": "^1.3.3",
    "@ledgerhq/device-transport-kit-web-hid": "^1.1.0",
    "@mui/icons-material": "^6.1.6",
    "@mui/material": "^6.3.0",
    "@mui/x-date-pickers": "^7.23.3",
    "@next/third-parties": "^15.2.0",
    "@reduxjs/toolkit": "^2.5.0",
    "@reown/walletkit": "^1.2.1",
    "@safe-global/api-kit": "^2.4.6",
    "@safe-global/protocol-kit": "^4.1.7",
    "@safe-global/safe-apps-sdk": "^9.1.0",
    "@safe-global/safe-client-gateway-sdk": "v1.60.1",
    "@safe-global/safe-deployments": "^1.37.31",
    "@safe-global/safe-gateway-typescript-sdk": "3.22.9",
    "@safe-global/safe-modules-deployments": "^2.2.7",
    "@safe-global/store": "workspace:^",
    "@sentry/react": "^7.91.0",
    "@spindl-xyz/attribution-lite": "^1.8.1",
    "@walletconnect/core": "^2.19.1",
    "@walletconnect/utils": "^2.17.3",
    "@web3-onboard/coinbase": "^2.4.2",
    "@web3-onboard/core": "2.24.0",
    "@web3-onboard/hw-common": "^2.3.3",
    "@web3-onboard/injected-wallets": "^2.11.2",
    "@web3-onboard/walletconnect": "^2.6.1",
    "blo": "^1.1.1",
    "classnames": "^2.5.1",
    "date-fns": "^2.30.0",
    "ethers": "^6.13.4",
    "exponential-backoff": "^3.1.0",
    "firebase": "^11.1.0",
    "fuse.js": "^7.1.0",
    "idb-keyval": "^6.2.1",
    "js-cookie": "^3.0.1",
    "lodash": "^4.17.21",
    "next": "patch:next@15.2.4#../../.yarn/patches/next-npm-15.2.4-06a6671f62.patch",
    "papaparse": "^5.3.2",
    "qrcode.react": "^3.1.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.2.3",
    "react-hook-form": "7.41.1",
    "react-papaparse": "^4.0.2",
    "react-redux": "^9.1.2",
    "semver": "^7.7.1",
    "zodiac-roles-deployments": "^2.3.4"
  },
  "devDependencies": {
    "@chromatic-com/storybook": "^1.3.1",
    "@cowprotocol/app-data": "^2.4.0",
    "@eslint/eslintrc": "^3.3.1",
    "@eslint/js": "^9.18.0",
    "@faker-js/faker": "^9.0.3",
    "@mdx-js/loader": "^3.0.1",
    "@mdx-js/react": "^3.0.1",
    "@next/bundle-analyzer": "^15.0.4",
    "@next/mdx": "^15.0.4",
    "@openzeppelin/contracts": "^4.9.6",
    "@safe-global/safe-core-sdk-types": "^5.0.1",
    "@safe-global/test": "workspace:^",
    "@sentry/types": "^7.74.0",
    "@storybook/addon-designs": "^8.0.3",
    "@storybook/addon-essentials": "^8.0.6",
    "@storybook/addon-interactions": "^8.0.6",
    "@storybook/addon-links": "^8.3.4",
    "@storybook/addon-onboarding": "^8.0.6",
    "@storybook/addon-themes": "^8.0.6",
    "@storybook/blocks": "^8.0.6",
    "@storybook/nextjs": "^8.0.6",
    "@storybook/react": "^8.0.6",
    "@storybook/test": "^8.0.6",
    "@svgr/webpack": "^8.1.0",
    "@testing-library/cypress": "^10.0.2",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "^14.5.2",
    "@typechain/ethers-v6": "^0.5.1",
    "@types/jest": "^29.5.4",
    "@types/js-cookie": "^3.0.6",
    "@types/lodash": "^4.14.182",
    "@types/mdx": "^2.0.13",
    "@types/node": "22.13.1",
    "@types/qrcode": "^1.5.5",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@types/semver": "^7.3.10",
    "@typescript-eslint/eslint-plugin": "^7.6.0",
    "@typescript-eslint/parser": "^8.18.1",
    "cheerio": "^1.0.0",
    "cross-env": "^7.0.3",
    "cypress": "^13.15.2",
    "cypress-file-upload": "^5.0.8",
    "cypress-visual-regression": "^5.2.2",
    "eslint": "^9.20.1",
    "eslint-config-next": "^15.0.4",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-no-only-tests": "^3.3.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-storybook": "^0.11.0",
    "eslint-plugin-unused-imports": "^4.1.4",
    "fake-indexeddb": "^4.0.2",
    "husky": "^9.0.11",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "jest-fixed-jsdom": "^0.0.9",
    "mockdate": "^3.0.5",
    "msw": "^2.7.3",
    "prettier": "^3.3.3",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.0",
    "remark-heading-id": "^1.0.1",
    "remark-mdx-frontmatter": "^5.0.0",
    "storybook": "^8.3.4",
    "ts-prune": "^0.10.3",
    "typechain": "^8.3.2",
    "typescript": "^5.4.5",
    "typescript-plugin-css-modules": "^4.2.2"
  },
  "nextBundleAnalysis": {
    "budget": null,
    "budgetPercentIncreaseRed": 20,
    "minimumChangeThreshold": 0,
    "showDetails": true
  },
  "packageManager": "yarn@4.5.3"
}
</file>

<file path="README.md">
# <img src="https://github.com/user-attachments/assets/b8249113-d515-4c91-a12a-f134813614e8" height="60" valign="middle" alt="Safe{Wallet}" style="background: #fff; padding: 20px; margin: 0 -20px" />

[![License](https://img.shields.io/github/license/safe-global/safe-wallet-web)](https://github.com/safe-global/safe-wallet-web/blob/main/LICENSE)
![Tests](https://img.shields.io/github/actions/workflow/status/safe-global/safe-wallet-web/test.yml?branch=main&label=tests)
![GitHub package.json version (branch)](https://img.shields.io/github/package-json/v/safe-global/safe-wallet-web)
[![GitPOAP Badge](https://public-api.gitpoap.io/v1/repo/safe-global/safe-wallet-web/badge)](https://www.gitpoap.io/gh/safe-global/safe-wallet-web)

# Safe{Wallet} web app

This project is now part of the **@safe-global/safe-wallet** monorepo! The monorepo setup allows centralized management
of multiple
applications and shared libraries. This workspace (`apps/web`) is the frontend of the Safe{Wallet} web app.

Safe{Wallet} is a smart contract wallet for Ethereum and other EVM chains. Based on Gnosis Safe multisig contracts.

You can run commands for this workspace in two ways:

1. **From the root of the monorepo using `yarn workspace` commands**
2. **From within the `apps/web` directory**

## Prerequisites

Except for the main monorepo prerequisites, no additional prerequisites are required for this workspace.

## Setup the Project

1. Install all dependencies from the **root of the monorepo**:

```bash
yarn install
```

## Contributing

Contributions, be it a bug report or a pull request, are very welcome. Please check
our [contribution guidelines](CONTRIBUTING.md) beforehand.

## Getting started with local development

### Environment variables

Create a `.env` file with environment variables. You can use the `.env.example` file as a reference.

Here's the list of all the environment variables:

| Env variable                                 | Description                                                                                                                                                                                   |
| -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `NEXT_PUBLIC_BRAND_NAME`                     | The name of the app, defaults to "Wallet fork"                                                                                                                                                |
| `NEXT_PUBLIC_BRAND_LOGO`                     | The URL of the app logo displayed in the header                                                                                                                                               |
| `NEXT_PUBLIC_INFURA_TOKEN` ❕                | [Infura](https://docs.infura.io/infura/networks/ethereum/how-to/secure-a-project/project-id) RPC API token. **Required for wallet connection and transacting!**                               |
| `NEXT_PUBLIC_SAFE_APPS_INFURA_TOKEN`         | Infura token for Safe Apps, falls back to `NEXT_PUBLIC_INFURA_TOKEN`                                                                                                                          |
| `NEXT_PUBLIC_IS_PRODUCTION`                  | Set to `true` to build a minified production app                                                                                                                                              |
| `NEXT_PUBLIC_DEFAULT_TESTNET_CHAIN_ID`       | The default chain ID used when `NEXT_PUBLIC_IS_PRODUCTION` is set to `false`. Defaults to 11155111 (sepolia)                                                                                  |
| `NEXT_PUBLIC_DEFAULT_MAINNET_CHAIN_ID`       | The default chain ID used when `NEXT_PUBLIC_IS_PRODUCTION` is set to `true`. Defaults to 1 (mainnet). Must be set to another value if mainnet isn't configured in the chain configs from CGW. |
| `NEXT_PUBLIC_GATEWAY_URL_PRODUCTION`         | The base URL for the [Safe Client Gateway](https://github.com/safe-global/safe-client-gateway)                                                                                                |
| `NEXT_PUBLIC_GATEWAY_URL_STAGING`            | The base CGW URL on staging                                                                                                                                                                   |
| `NEXT_PUBLIC_SAFE_VERSION`                   | The latest version of the Safe contract, defaults to 1.4.1                                                                                                                                    |
| `NEXT_PUBLIC_WC_PROJECT_ID`                  | [WalletConnect v2](https://docs.walletconnect.com/2.0/cloud/relay) project ID                                                                                                                 |
| `NEXT_PUBLIC_TENDERLY_ORG_NAME`              | [Tenderly](https://tenderly.co) org name for Transaction Simulation                                                                                                                           |
| `NEXT_PUBLIC_TENDERLY_PROJECT_NAME`          | Tenderly project name                                                                                                                                                                         |
| `NEXT_PUBLIC_TENDERLY_SIMULATE_ENDPOINT_URL` | Tenderly simulation URL                                                                                                                                                                       |
| `NEXT_PUBLIC_BEAMER_ID`                      | [Beamer](https://www.getbeamer.com) is a news feed for in-app announcements                                                                                                                   |
| `NEXT_PUBLIC_PROD_GA_TRACKING_ID`            | Prod GA property id                                                                                                                                                                           |
| `NEXT_PUBLIC_TEST_GA_TRACKING_ID`            | Test GA property id                                                                                                                                                                           |
| `NEXT_PUBLIC_SAFE_APPS_GA_TRACKING_ID`       | Safe Apps GA property id                                                                                                                                                                      |
| `NEXT_PUBLIC_SENTRY_DSN`                     | [Sentry](https://sentry.io) id for tracking runtime errors                                                                                                                                    |
| `NEXT_PUBLIC_IS_OFFICIAL_HOST`               | Whether it's the official distribution of the app, or a fork; has legal implications. Set to true only if you also update the legal pages like Imprint and Terms of use                       |
| `NEXT_PUBLIC_BLOCKAID_CLIENT_ID`                   | Blockaid client id                                                                                                                                                                          |
| `NEXT_PUBLIC_FIREBASE_OPTIONS_PRODUCTION`    | Firebase Cloud Messaging (FCM) `initializeApp` options on production                                                                                                                          |
| `NEXT_PUBLIC_FIREBASE_VAPID_KEY_PRODUCTION`  | FCM vapid key on production                                                                                                                                                                   |
| `NEXT_PUBLIC_FIREBASE_OPTIONS_STAGING`       | FCM `initializeApp` options on staging                                                                                                                                                        |
| `NEXT_PUBLIC_FIREBASE_VAPID_KEY_STAGING`     | FCM vapid key on staging                                                                                                                                                                      |
| `NEXT_PUBLIC_SPINDL_SDK_KEY`                 | [Spindl](http://spindl.xyz) SDK key                                                                                                                                                           |

If you don't provide some of the variables, the corresponding features will be disabled in the UI.

### Running the app locally

From the root of the monorepo:

```bash
yarn workspace @safe-global/web start
```

Or directly from the `apps/web` directory:

```bash
yarn start
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the app.

> [!NOTE]
>
> From now on for brevity we will only show the command to run from the root of the monorepo. You can always run the command from the `apps/web` directory you just need to omit the `workspace @safe-global/web`.

## Lint

ESLint:

```
yarn workspace @safe-global/web lint --fix
```

Prettier:

```
yarn workspace @safe-global/web prettier
```

## Tests

Unit tests:

```
yarn workspace @safe-global/web test --watch
```

### Cypress tests

Build a static site:

```
yarn workspace @safe-global/web build
```

Serve the static files:

```
yarn workspace @safe-global/web serve
```

Launch the Cypress UI:

```
yarn workspace @safe-global/web cypress:open
```

You can then choose which e2e tests to run.
Some tests will require signer private keys, please include them in your .env file

## Component template

To create a new component from a template:

```
yarn workspace @safe-global/web cmp MyNewComponent
```

## Pre-push hooks

This repo has a pre-push hook that runs the linter (always) and the tests (if the `RUN_TESTS_ON_PUSH` env variable is
set to true)
before pushing. If you want to skip the hooks, you can use the `--no-verify` flag.

## Frameworks

This app is built using the following frameworks:

- [Safe Core SDK](https://github.com/safe-global/safe-core-sdk)
- [Safe Gateway SDK](https://github.com/safe-global/safe-gateway-typescript-sdk)
- Next.js
- React
- Redux
- MUI
- ethers.js
- web3-onboard
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@safe-global/safe-apps-sdk/*": ["../../node_modules/@safe-global/safe-apps-sdk/*"],
      "@gnosis.pm/zodiac/*": ["../../node_modules/@gnosis.pm/zodiac/*"],
      "@cowprotocol/app-data": ["../../node_modules/@cowprotocol/app-data"],
      "@/public/*": ["./public/*"],
      "@safe-global/store/*": ["../../packages/store/src/*"],
      "@safe-global/utils/*": ["../../packages/utils/src/*"],
    },
    "plugins": [
      {
        "name": "typescript-plugin-css-modules"
      },
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "apps/web/next-env.d.ts",
    "src/definitions.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "./jest.setup.js",
    "./eslint.config.mjs"
  ],
  "exclude": ["node_modules", "src/types/contracts"]
}
</file>

</files>
