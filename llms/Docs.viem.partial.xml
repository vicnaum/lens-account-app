This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: actions/test/**/*,  chains/celo.md,  eip7702.mdx,  eip7702/**/*,  siwe/**/*,  compatibility.mdx,  faq.mdx,  installation.mdx,  utilities/blobs*.md,  utilities/commitments*.md,  utilities/commitment*.md,  utilities/fromBase*.md,  utilities/fromBlobs.md,  utilities/defineKzg.md,  utilities/setupKzg.md,  utilities/ripemd160.md,  utilities/sidecars*.md,  utilities/toBase*.md,  utilities/toBlobs.md,  accounts/local/**/*,  contract/deployContract.md,  contract/encodeDeployData.md,  contract/decodeDeployData.md,  actions/public/create*Filter.md,  actions/public/uninstallFilter.md,  actions/public/getFilter*.md,  actions/public/watch*.md,  actions/public/getProof.md,  actions/public/simulateBlocks.md,  actions/wallet/addChain.md,  actions/wallet/getPermissions.md,  actions/wallet/requestPermissions.md,  actions/wallet/switchChain.md,  actions/wallet/watchAsset.md,  ens/actions/**/*,  ens/utilities/!(namehash.md|normalize.md)*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
abi/
  decodeAbiParameters.md
  encodeAbiParameters.md
  encodePacked.md
  getAbiItem.md
  parseAbi.md
  parseAbiItem.md
  parseAbiParameter.md
  parseAbiParameters.md
accounts/
  local/
    createNonceManager.md
    hdKeyToAccount.md
    mnemonicToAccount.md
    privateKeyToAccount.md
    signMessage.md
    signTransaction.md
    signTypedData.md
    toAccount.md
  jsonRpc.md
  local.md
actions/
  public/
    call.md
    createAccessList.md
    createBlockFilter.md
    createEventFilter.md
    createPendingTransactionFilter.md
    estimateFeesPerGas.md
    estimateGas.md
    estimateMaxPriorityFeePerGas.md
    getBalance.md
    getBlobBaseFee.md
    getBlock.md
    getBlockNumber.md
    getBlockTransactionCount.md
    getChainId.md
    getEip712Domain.md
    getFeeHistory.md
    getFilterChanges.md
    getFilterLogs.md
    getGasPrice.md
    getLogs.md
    getProof.md
    getTransaction.md
    getTransactionConfirmations.md
    getTransactionCount.md
    getTransactionReceipt.md
    introduction.md
    simulateBlocks.md
    simulateCalls.md
    uninstallFilter.md
    verifyMessage.md
    verifyTypedData.md
    waitForTransactionReceipt.md
    watchBlockNumber.md
    watchBlocks.md
    watchEvent.md
    watchPendingTransactions.md
  wallet/
    addChain.md
    getAddresses.md
    getPermissions.md
    introduction.md
    prepareTransactionRequest.md
    requestAddresses.md
    requestPermissions.md
    sendRawTransaction.md
    sendTransaction.md
    signMessage.md
    signTransaction.md
    signTypedData.md
    switchChain.md
    watchAsset.md
chains/
  celo.md
  fees.md
  formatters.md
  introduction.md
  serializers.md
  zksync.md
clients/
  transports/
    custom.md
    fallback.md
    http.md
    ipc.md
    websocket.md
  custom.md
  intro.md
  public.md
  test.md
  wallet.md
contract/
  createContractEventFilter.md
  decodeDeployData.md
  decodeErrorResult.md
  decodeEventLog.md
  decodeFunctionData.md
  decodeFunctionResult.md
  deployContract.md
  encodeDeployData.md
  encodeErrorResult.md
  encodeEventTopics.md
  encodeFunctionData.md
  encodeFunctionResult.md
  estimateContractGas.md
  getCode.md
  getContract.md
  getContractEvents.md
  getStorageAt.md
  multicall.md
  parseEventLogs.md
  readContract.md
  simulateContract.md
  watchContractEvent.md
  writeContract.md
eip7702/
  contract-writes.md
  hashAuthorization.md
  prepareAuthorization.md
  recoverAuthorizationAddress.md
  sending-transactions.md
  signAuthorization.md
  verifyAuthorization.md
ens/
  actions/
    getEnsAddress.md
    getEnsAvatar.md
    getEnsName.md
    getEnsResolver.md
    getEnsText.md
  utilities/
    labelhash.md
    namehash.md
    normalize.md
glossary/
  errors.md
  terms.md
  types.md
guides/
  blob-transactions.md
siwe/
  actions/
    verifySiweMessage.md
  utilities/
    createSiweMessage.md
    generateSiweNonce.md
    parseSiweMessage.md
    validateSiweMessage.md
utilities/
  blobsToCommitments.md
  blobsToProofs.md
  commitmentsToVersionedHashes.md
  commitmentToVersionedHash.md
  compactSignatureToSignature.md
  concat.md
  defineKzg.md
  extractChain.md
  formatEther.md
  formatGwei.md
  formatUnits.md
  fromBase58.md
  fromBase64.md
  fromBlobs.md
  fromBytes.md
  fromHex.md
  fromRlp.md
  getAddress.md
  getContractAddress.md
  hashMessage.md
  hashTypedData.md
  isAddress.md
  isAddressEqual.md
  isBytes.md
  isErc6492Signature.md
  isHex.md
  keccak256.md
  pad.md
  parseCompactSignature.md
  parseErc6492Signature.md
  parseEther.md
  parseGwei.md
  parseSignature.md
  parseTransaction.md
  parseUnits.md
  recoverAddress.md
  recoverMessageAddress.md
  recoverPublicKey.md
  recoverTransactionAddress.md
  recoverTypedDataAddress.md
  ripemd160.md
  serializeCompactSignature.md
  serializeErc6492Signature.md
  serializeSignature.md
  serializeTransaction.md
  setupKzg.md
  sha256.md
  sidecarsToVersionedHashes.md
  signatureToCompactSignature.md
  size.md
  slice.md
  toBase58.md
  toBase64.md
  toBlobs.md
  toBlobSidecars.md
  toBytes.md
  toEventHash.md
  toEventSelector.md
  toEventSignature.md
  toFunctionHash.md
  toFunctionSelector.md
  toFunctionSignature.md
  toHex.md
  toRlp.md
  trim.md
  verifyMessage.md
  verifyTypedData.md
compatibility.mdx
eip7702.mdx
error-handling.mdx
ethers-migration.mdx
faq.mdx
getting-started.mdx
installation.mdx
introduction.mdx
migration-guide.mdx
typescript.mdx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="abi/decodeAbiParameters.md">
# decodeAbiParameters [Decodes ABI encoded data.]

Decodes ABI encoded data using the [ABI specification](https://solidity.readthedocs.io/en/latest/abi-spec), given a set of ABI parameters (`inputs`/`outputs`) and the encoded ABI data.

The `decodeAbiParameters` function is used by the other contract decoding utilities (ie. `decodeFunctionData`, `decodeEventLog`, etc).

## Install

```ts
import { decodeAbiParameters } from 'viem'
```

## Usage

The `decodeAbiParameters` function takes in two parameters:

- a set of ABI Parameters (`params`), that can be in the shape of the `inputs` or `outputs` attribute of an ABI Item.
- the ABI encoded data (`data`) that correspond to the given `params`.

```ts
import { decodeAbiParameters } from 'viem'

const values = decodeAbiParameters(
  [
    { name: 'x', type: 'string' },
    { name: 'y', type: 'uint' },
    { name: 'z', type: 'bool' }
  ],
  '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',
)
// ['wagmi', 420n, true]
```

### Human Readable

You can also pass in [Human Readable](/docs/glossary/terms#human-readable-abi) parameters with the [`parseAbiParameters` utility](/docs/abi/parseAbiParameters).

```ts
import { decodeAbiParameters, parseAbiParameters } from 'viem'

const values = decodeAbiParameters(
  parseAbiParameters('string x, uint y, bool z'),
  '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000'
)
// ['wagmi', 420n, true]
```

## Return Value

The decoded data. Type is inferred from the ABI.

## Parameters

### params

- **Type**: [`AbiParameter[]`](/docs/glossary/types#abiparameter)

The set of ABI parameters to decode against `data`, in the shape of the `inputs` or `outputs` attribute of an ABI event/function.

These parameters must include valid [ABI types](https://docs.soliditylang.org/en/develop/abi-spec#types).

```ts
const values = decodeAbiParameters(
  [{ name: 'x', type: 'uint32' }], // [!code focus]
  '0x0000000000000000000000000000000000000000000000000000000000010f2c',
)
```

### data

- **Type:** [`Hex`](/docs/glossary/types#hex)

The ABI encoded data.

```ts
const values = decodeAbiParameters(
  [{ name: 'x', type: 'uint32' }],
  '0x0000000000000000000000000000000000000000000000000000000000010f2c', // [!code focus]
)
```

## More Examples

### Simple struct

:::code-group

```ts [example.ts]
import { abi } from './abi'

const values = decodeAbiParameters(
  abi[0].outputs,
  '0x00000000000000000000000000000000000000000000000000000000000001a40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',
)
// { x: 420n, y: true, z: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC' }
```

```ts [abi.ts]
export const abi = [
  {
    name: 'staticStruct',
    outputs: [
      {
        components: [
          {
            name: 'x',
            type: 'uint256',
          },
          {
            name: 'y',
            type: 'bool',
          },
          {
            name: 'z',
            type: 'address',
          },
        ],
        name: 'foo',
        type: 'tuple',
      },
    ],
  }
] as const
```

```solidity [Example.sol]
contract Example {
  struct Foo {
    uint256 x;
    bool y;
    address z;
  }

  function staticStruct(...) returns (Foo calldata foo) { 
    ... 
    return foo;
  }
}
```

:::

### Simple bytes

A simple `bytes` that contains an ABI-encoded `uint256` value.

:::code-group

```ts [example.ts]
const values = decodeAbiParameters(
  [
    { name: "response", type: "bytes" },
  ],
  '0x' +
  '0000000000000000000000000000000000000000000000000000000000000020' + // offset pointer
  '0000000000000000000000000000000000000000000000000000000000000020' + // length
  '0000000000000000000000000000000000000000000000000000000000000001',  // data
)
// 0x0000000000000000000000000000000000000000000000000000000000000001
```

```solidity [Example.sol]
contract Example {
  function simpleBytes() public pure returns (bytes memory) {
    bytes memory value = abi.encode(1);
    return abi.encode(value);
  }
}
```

:::
</file>

<file path="abi/encodeAbiParameters.md">
---
description: Generates ABI encoded data.
---

# encodeAbiParameters

Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec.html), given a set of ABI parameters (`inputs`/`outputs`) and their corresponding values.

The `encodeAbiParameters` function is used by the other contract encoding utilities (ie. `encodeFunctionData`, `encodeEventTopics`, etc).

## Import

```ts
import { encodeAbiParameters } from 'viem'
```

## Usage

The `encodeAbiParameters` function takes in two parameters:

- a set of ABI Parameters (`params`), that can be in the shape of the `inputs` or `outputs` attribute of an ABI Item.
- a set of values (`values`) that correspond to the given `params`.


```ts
import { encodeAbiParameters } from 'viem'

const encodedData = encodeAbiParameters(
  [
    { name: 'x', type: 'string' },
    { name: 'y', type: 'uint' },
    { name: 'z', type: 'bool' }
  ],
  ['wagmi', 420n, true]
)
// 0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000
```

### Human Readable

You can also pass in [Human Readable](/docs/glossary/terms#human-readable-abi) parameters with the [`parseAbiParameters` utility](/docs/abi/parseAbiParameters).

```ts
import { encodeAbiParameters, parseAbiParameters } from 'viem'

const encodedData = encodeAbiParameters(
  parseAbiParameters('string x, uint y, bool z'),
  ['wagmi', 420n, true]
)
// 0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The ABI encoded data.

## Parameters

### params

- **Type**: [`AbiParameter[]`](/docs/glossary/terms#abiparameter)

The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI event/function.

These parameters must include valid [ABI types](https://docs.soliditylang.org/en/develop/abi-spec#types).

```ts
encodeAbiParameters(
  [{ name: 'x', type: 'uint32' }], // [!code focus]
  [69420]
)
```

### values

- **Type**: [`AbiParametersToPrimitiveTypes<AbiParameter[]>`](/docs/glossary/terms#abiparameterstoprimitivetypes)

The set of primitive values that correspond to the ABI types defined in `params`.

```ts
encodeAbiParameters(
  [{ name: 'x', type: 'uint32' }],
  [69420] // [!code focus]
)
```

## More Examples

### Simple struct

:::code-group

```ts [example.ts]
import { abi } from './abi'

const encodedData = encodeAbiParameters(
  abi[0].inputs,
  [{
    x: 420n,
    y: true,
    z: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  }],
)
// 0x00000000000000000000000000000000000000000000000000000000000001a40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac
```

```ts [abi.ts]
export const abi = [
  {
    name: 'staticStruct',
    inputs: [
      {
        components: [
          {
            name: 'x',
            type: 'uint256',
          },
          {
            name: 'y',
            type: 'bool',
          },
          {
            name: 'z',
            type: 'address',
          },
        ],
        name: 'foo',
        type: 'tuple',
      },
    ],
  }
] as const
```

```solidity [Example.sol]
contract Example {
  struct Foo {
    uint256 x;
    bool y;
    address z;
  }

  function staticStruct(Foo calldata foo) { ... }
}
```

:::
</file>

<file path="abi/encodePacked.md">
---
description: Generates ABI encoded data.
---

# encodePacked

Generates [ABI non-standard packed encoded data](https://docs.soliditylang.org/en/v0.8.18/abi-spec#non-standard-packed-mode) given a set of solidity types compatible with packed encoding.

## Import

```ts
import { encodePacked } from 'viem'
```

## Usage

```ts
encodePacked(
  ['address', 'string', 'bytes16[]'], 
  [
    '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
    'hello world',
    ['0xdeadbeefdeadbeefdeadbeefdeadbeef', '0xcafebabecafebabecafebabecafebabe']
  ]
)
// 0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64deadbeefdeadbeefdeadbeefdeadbeef00000000000000000000000000000000cafebabecafebabecafebabecafebabe00000000000000000000000000000000
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The encoded packed data.

## Parameters

### types

- **Type**: `PackedAbiType[]`

Set of ABI types to pack encode.

```ts
encodePacked(
  ['address', 'string', 'bytes16[]'], // [!code focus]
  [
    '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
    'hello world',
    ['0xdeadbeefdeadbeefdeadbeefdeadbeef', '0xcafebabecafebabecafebabecafebabe']
  ]
)
```

### values

- **Type**: [`AbiParametersToPrimitiveTypes<PackedAbiType[]>`](/docs/glossary/terms#abiparameterstoprimitivetypes)

The set of primitive values that correspond to the ABI types defined in `types`.

```ts
encodePacked(
  ['address', 'string', 'bytes16[]'],
  [ // [!code focus:5]
    '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
    'hello world',
    ['0xdeadbeefdeadbeefdeadbeefdeadbeef', '0xcafebabecafebabecafebabecafebabe']
  ]
)
```
</file>

<file path="abi/getAbiItem.md">
---
description: Retrieves an item from the ABI array.
---

# getAbiItem

Retrieves an item from the ABI.

## Import

```ts
import { getAbiItem } from 'viem'
```

## Usage

```ts
import { getAbiItem } from 'viem'

const encodedData = getAbiItem({
  abi: [
    { 
      name: 'x', 
      type: 'function', 
      inputs: [{ type: 'uint256' }], 
      outputs: [],
      stateMutability: 'payable'
    },
    { 
      name: 'y', 
      type: 'event', 
      inputs: [{ type: 'address' }], 
      outputs: [{ type: 'uint256' }],
      stateMutability: 'view'
    },
    { 
      name: 'z', 
      type: 'function', 
      inputs: [{ type: 'string' }],
      outputs: [{ type: 'uint256' }],
      stateMutability: 'view'
    }
  ],
  name: 'y',
})
/**
 * { 
 *  name: 'y', 
 *  type: 'event', 
 *  inputs: [{ type: 'address' }], 
 *  outputs: [{ type: 'uint256' }],
 *  stateMutability: 'view'
 * }
 */
```

## Returns

`AbiItem`

The ABI item.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const encodedData = getAbiItem({
  abi: [...], // [!code focus]
  name: 'x',
})
```

### name

- **Type:** `string`

Name of the ABI item to extract.

```ts
const encodedData = getAbiItem({
  abi: [...],
  name: 'x', // [!code focus]
})
```

You can also provide the ABI item's 4byte selector:

```ts
const encodedData = getAbiItem({
  abi: [...],
  name: '0x70a08231', // [!code focus]
})
```

### args (optional)

- **Type:** Inferred.

Optional arguments to identify function overrides.

```ts
const encodedData = getAbiItem({
  abi: [...],
  name: 'y',
  args: ['0x0000000000000000000000000000000000000000'], // [!code focus]
})
```
</file>

<file path="abi/parseAbi.md">
---
description: Parses human-readable ABI into JSON.
---

# parseAbi

Parses human-readable ABI into JSON [`Abi`](/docs/glossary/types#abi). Re-exported from [ABIType](https://abitype.dev/api/human#parseabi-1).

## Import

```ts
import { parseAbi } from 'viem'
```

## Usage

```ts
import { parseAbi } from 'viem'

const abi = parseAbi([
  //  ^? const abi: readonly [{ name: "balanceOf"; type: "function"; stateMutability:...
  'function balanceOf(address owner) view returns (uint256)',
  'event Transfer(address indexed from, address indexed to, uint256 amount)',
])
```

## Returns

[`Abi`](/docs/glossary/types#abi)

The JSON ABI.

## Parameters

### signatures

- **Type:** `string[]`

Human-readable ABI.

```ts
import { parseAbi } from 'viem'

const abi = parseAbi([
  //  ^? const abi: readonly [{ name: "balanceOf"; type: "function"; stateMutability:...
  'function balanceOf(address owner) view returns (uint256)',
  'event Transfer(address indexed from, address indexed to, uint256 amount)',
])
```
</file>

<file path="abi/parseAbiItem.md">
---
description: Parses human-readable ABI item (e.g. error, event, function) into ABI item.
---

# parseAbiItem

Parses human-readable ABI item (e.g. error, event, function) into ABI item. Re-exported from [ABIType](https://abitype.dev/api/human#parseabiitem-1).

## Import

```ts
import { parseAbiItem } from 'viem'
```

## Usage

```ts
import { parseAbiItem } from 'viem'

const abiItem = parseAbiItem(
  //  ^? const abiItem: { name: "balanceOf"; type: "function"; stateMutability: "view";...
  'function balanceOf(address owner) view returns (uint256)',
)
```

## Returns

[`Abi`](/docs/glossary/types#abi)

Parsed ABI item.

## Parameters

### signatures

- **Type:** `string[]`

Human-Readable ABI item.

```ts
import { parseAbiItem } from 'viem'

const abiItem = parseAbiItem([
  //  ^? const abiItem: { name: "foo"; type: "function"; stateMutability: "view"; inputs:...
  'function foo(Baz bar) view returns (string)',
  'struct Baz { string name; }',
])
```
</file>

<file path="abi/parseAbiParameter.md">
---
description: Parses human-readable ABI parameter into ABI parameter.
---

# parseAbiParameter

Parses human-readable ABI parameter into [`AbiParameter`](/docs/glossary/types#abiparameter). Re-exported from [ABIType](https://abitype.dev/api/human#parseabiparameter-1).

## Import

```ts
import { parseAbiParameter } from 'viem'
```

## Usage

```ts
import { parseAbiParameter } from 'viem'

const abiParameter = parseAbiParameter('address from')
//    ^? const abiParameter: { type: "address"; name: "from"; }
```

## Returns

[`Abi`](/docs/glossary/types#abi)

Parsed ABI parameter.

## Parameters

### signature

- **Type:** `string | string[]`

Human-Readable ABI parameter.

```ts
import { parseAbiParameter } from 'viem'

const abiParameter = parseAbiParameter([
  //  ^? const abiParameter: { type: "tuple"; components: [{ type: "string"; name:...
  'Baz bar',
  'struct Baz { string name; }',
])
```
</file>

<file path="abi/parseAbiParameters.md">
---
description: Parses human-readable ABI parameters into ABI parameters.
---

# parseAbiParameters

Parses human-readable ABI parameters into [`AbiParameter`s](/docs/glossary/types#abiparameter). Re-exported from [ABIType](https://abitype.dev/api/human#parseabiparameters-1).

## Import

```ts
import { parseAbiParameters } from 'viem'
```

## Usage

```ts
import { parseAbiParameters } from 'viem'

const abiParameters = parseAbiParameters(
  //  ^? const abiParameters: [{ type: "address"; name: "from"; }, { type: "address";...
  'address from, address to, uint256 amount',
)
```

## Returns

[`Abi`](/docs/glossary/types#abi)

Parsed ABI parameters.

## Parameters

### params

- **Type:** `string | string[]`

Human-Readable ABI parameters.

```ts
import { parseAbiParameters } from 'viem'

const abiParameters = parseAbiParameters([
  //  ^? const abiParameters: [{ type: "tuple"; components: [{ type: "string"; name:...
  'Baz bar',
  'struct Baz { string name; }',
])
```
</file>

<file path="accounts/local/createNonceManager.md">
# createNonceManager [Creates a Nonce Manager for automatic nonce generation]

Creates a new Nonce Manager instance to be used with a [Local Account](/docs/accounts/local). The Nonce Manager is used to automatically manage & generate nonces for transactions.

:::warning
A Nonce Manager can only be used with [Local Accounts](/docs/accounts/local) (ie. Private Key, Mnemonic, etc). 

For [JSON-RPC Accounts](/docs/accounts/jsonRpc) (ie. Browser Extension, WalletConnect, Backend, etc), the Wallet or Backend will manage the nonces.
:::

## Import

```ts twoslash
import { createNonceManager } from 'viem/nonce'
```

## Usage

A Nonce Manager can be instantiated with the `createNonceManager` function with a provided `source`. 

The example below demonstrates how to create a Nonce Manager with a JSON-RPC source (ie. uses `eth_getTransactionCount` as the source of truth).

```ts twoslash
import { createNonceManager, jsonRpc } from 'viem/nonce'

const nonceManager = createNonceManager({
  source: jsonRpc()
})
```

:::tip
Viem also exports a default `nonceManager` instance that you can use directly.

```ts twoslash
import { nonceManager } from 'viem'
```
:::

### Integration with Local Accounts

A `nonceManager` can be passed as an option to [Local Accounts](/docs/accounts/local) to automatically manage nonces for transactions.

:::code-group

```ts twoslash [example.ts]
import { privateKeyToAccount, nonceManager } from 'viem/accounts' // [!code focus]
import { client } from './config'

const account = privateKeyToAccount('0x...', { nonceManager }) // [!code focus]

const hashes = await Promise.all([ // [!code focus]
// @log:   ↓ nonce = 0
  client.sendTransaction({ // [!code focus]
    account, // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
    value: parseEther('0.1'), // [!code focus]
  }), // [!code focus]
// @log:   ↓ nonce = 1
  client.sendTransaction({ // [!code focus]
    account, // [!code focus]
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
    value: parseEther('0.2'), // [!code focus]
  }), // [!code focus]
]) // [!code focus]
```

```ts twoslash [config.ts] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createWalletClient({
  chain: mainnet,
  transport: http(),
})
```

:::

## Return Type

`NonceManager`

The Nonce Manager.

## Parameters

### source

- **Type:** `NonceManagerSource`

The source of truth for the Nonce Manager.

Available sources: 

- `jsonRpc`

```ts twoslash
import { createNonceManager, jsonRpc } from 'viem/nonce'

const nonceManager = createNonceManager({
  source: jsonRpc() // [!code focus]
})
```
</file>

<file path="accounts/local/hdKeyToAccount.md">
# hdKeyToAccount [A function to create a Hierarchical Deterministic (HD) Account.]

A [Hierarchical Deterministic (HD)](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#abstract) Account is derived from a [HD Key](https://github.com/paulmillr/scure-bip32#usage) and an optional HD path.

It has the ability to sign transactions and messages with the private key derived from the HD Node.

:::info
viem internally uses [`@scure/bip32`](https://github.com/paulmillr/scure-bip32), an **audited** implementation of [BIP-32 HD wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#abstract), for hierarchical deterministic (HD) wallet derivation.
:::

## Import

```ts twoslash
import { HDKey, hdKeyToAccount } from 'viem/accounts'
```

> Note: viem [re-exports `HDKey`](https://github.com/paulmillr/scure-bip32#usage) from `@scure/bip32`.

## Usage

To initialize a HD Account, you will need to pass a [`HDKey` instance](https://github.com/paulmillr/scure-bip32#usage) to `hdKeyToAccount`.

The `HDKey` instance comes with a few static methods to derive a HD Key:

- `fromMasterSeed`
- `fromExtendedKey`
- `fromJSON`

```ts twoslash
// @noErrors
import { createWalletClient, http } from 'viem'
import { HDKey, hdKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const hdKey = HDKey.fromMasterSeed(...) // [!code focus:3]
const hdKey = HDKey.fromExtendedKey(...)
const hdKey = HDKey.fromJSON({ xpriv: ... })

const account = hdKeyToAccount(hdKey) // [!code focus]

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http(),
})
```

## Parameters

### hdKey

- **Type:** `string`

The BIP-39 mnemonic phrase.

```ts twoslash
// @noErrors
import { hdKeyToAccount } from 'viem/accounts'
// ---cut---
const hdKey = HDKey.fromMasterSeed(...)

const account = hdKeyToAccount(
  hdKey, // [!code focus]
)
```

### options.accountIndex

- **Type:** `number`
- **Default:** `0`

The account index to use in the path (`"m/44'/60'/${accountIndex}'/0/0"`) to derive a private key.

```ts twoslash
// @noErrors
import { hdKeyToAccount } from 'viem/accounts'
// ---cut---
const hdKey = HDKey.fromMasterSeed(...)

const account = hdKeyToAccount(
  hdKey,
  {
    accountIndex: 1 // [!code focus]
  }
)
```

### options.addressIndex

- **Type:** `number`
- **Default:** `0`

The address index to use in the path (`"m/44'/60'/0'/0/${addressIndex}"`) to derive a private key.

```ts twoslash
// @noErrors
import { hdKeyToAccount } from 'viem/accounts'
// ---cut---
const hdKey = HDKey.fromMasterSeed(...)

const account = hdKeyToAccount(
  hdKey,
  {
    accountIndex: 1,
    addressIndex: 6 // [!code focus]
  }
)
```

### options.changeIndex

- **Type:** `number`
- **Default:** `0`

The change index to use in the path (`"m/44'/60'/0'/${changeIndex}/0"`) to derive a private key.

```ts twoslash
// @noErrors
import { hdKeyToAccount } from 'viem/accounts'
// ---cut---
const hdKey = HDKey.fromMasterSeed(...)

const account = hdKeyToAccount(
  hdKey,
  {
    accountIndex: 1,
    addressIndex: 6,
    changeIndex: 2 // [!code focus]
  }
)
```

### options.path

- **Type:** `"m/44'/60'/${string}"`

The HD path to use to derive a private key.

```ts twoslash
// @noErrors
import { hdKeyToAccount } from 'viem/accounts'
// ---cut---
const hdKey = HDKey.fromMasterSeed(...)

const account = hdKeyToAccount(
  hdKey,
  {
    path: "m/44'/60'/5'/0/2" // [!code focus]
  }
)
```
</file>

<file path="accounts/local/mnemonicToAccount.md">
# mnemonicToAccount [A function to create a Mnemonic Account.]

A Mnemonic Account is a [Hierarchical Deterministic (HD) Account](/docs/accounts/local/hdKeyToAccount) that is derived from a [BIP-39 mnemonic phrase](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) and an optional HD path.

It has the ability to sign transactions and messages with the private key derived from the HD Node.

:::info
viem internally uses [`@scure/bip32`](https://github.com/paulmillr/scure-bip32), an **audited** implementation of [BIP-32 HD wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#abstract), for hierarchical deterministic (HD) wallet derivation.
:::

## Import

```ts twoslash
import { mnemonicToAccount } from 'viem/accounts'
```

## Usage

To initialize a Mnemonic Account, you will need to pass a mnemonic phrase to `mnemonicToAccount`:

```ts twoslash
import { createWalletClient, http } from 'viem'
import { mnemonicToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = mnemonicToAccount('legal winner thank year wave sausage worth useful legal winner thank yellow') // [!code focus]

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
})
```

> Note: the above is a valid mnemonic, but it is not a "real" mnemonic. Please do not use it for anything other than testing.

### Generating Mnemonics

You can generate a random BIP-39 mnemonic using the `generateMnemonic` function with a wordlist:

```ts twoslash
import { english, generateMnemonic } from 'viem/accounts'

const mnemonic = generateMnemonic(english)
```

:::tip
You can customize the strength of the generated mnemonic by passing a value between 128 and 256 as the second argument to the `generateMnemonic` function. This value must be a multiple of 32.
:::

Available wordlists:

- `czech`
- `english`
- `french`
- `italian`
- `japanese`
- `korean`
- `portuguese`
- `simplifiedChinese`
- `spanish`
- `traditionalChinese`

## Parameters

### mnemonic

- **Type:** `string`

The BIP-39 mnemonic phrase.

```ts twoslash
import { mnemonicToAccount } from 'viem/accounts'
// ---cut---
const account = mnemonicToAccount(
  'legal winner thank year wave sausage worth useful legal winner thank yellow' // [!code focus]
)
```

### options.accountIndex

- **Type:** `number`
- **Default:** `0`

The account index to use in the path (`"m/44'/60'/${accountIndex}'/0/0"`) to derive a private key.

```ts twoslash
import { mnemonicToAccount } from 'viem/accounts'
// ---cut---
const account = mnemonicToAccount(
  'legal winner thank year wave sausage worth useful legal winner thank yellow',
  {
    accountIndex: 1 // [!code focus]
  }
)
```

### options.addressIndex

- **Type:** `number`
- **Default:** `0`

The address index to use in the path (`"m/44'/60'/0'/0/${addressIndex}"`) to derive a private key.

```ts twoslash
import { mnemonicToAccount } from 'viem/accounts'
// ---cut---
const account = mnemonicToAccount(
  'legal winner thank year wave sausage worth useful legal winner thank yellow',
  {
    accountIndex: 1,
    addressIndex: 6 // [!code focus]
  }
)
```

### options.changeIndex

- **Type:** `number`
- **Default:** `0`

The change index to use in the path (`"m/44'/60'/0'/${changeIndex}/0"`) to derive a private key.

```ts twoslash
import { mnemonicToAccount } from 'viem/accounts'
// ---cut---
const account = mnemonicToAccount(
  'legal winner thank year wave sausage worth useful legal winner thank yellow',
  {
    accountIndex: 1,
    addressIndex: 6,
    changeIndex: 2 // [!code focus]
  }
)
```

### options.path

- **Type:** `"m/44'/60'/${string}"`

The HD path to use to derive a private key.

```ts twoslash
import { mnemonicToAccount } from 'viem/accounts'
// ---cut---
const account = mnemonicToAccount(
  'legal winner thank year wave sausage worth useful legal winner thank yellow',
  {
    path: "m/44'/60'/5'/0/2" // [!code focus]
  }
)
```
</file>

<file path="accounts/local/privateKeyToAccount.md">
# privateKeyToAccount [A function to create a Private Key Account.]

A Private Key Account is an interface that has the ability to sign transactions and messages with a given private key.

:::info
viem internally uses [`@noble/curves`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [secp256k1](https://www.secg.org/sec2-v2.pdf), for our private key & signing implementation.
:::

## Import

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
```

## Usage

To initialize a Private Key Account, you will need to pass a private key to `privateKeyToAccount`:

```ts twoslash
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80') // [!code focus]

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
})
```

> Note: the above is a valid private key, but it is not a "real" private key. Please do not use it for anything other than testing.

### Generating Private Keys

You can generate a random private key using the `generatePrivateKey` function:

```ts twoslash
import { generatePrivateKey } from 'viem/accounts'

const privateKey = generatePrivateKey()
```

## Parameters

### privateKey

- **Type:** `Hex`

The private key to use for the Account.
</file>

<file path="accounts/local/signMessage.md">
# signMessage (Local Account) [Signs a message with the Account's private key.]

Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.

With the calculated signature, you can:

- use [`verifyMessage`](/docs/utilities/verifyMessage) to verify the signature,
- use [`recoverMessageAddress`](/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.

## Usage

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')

const signature = await account.signMessage({
  // Hex data representation of message.
  message: { raw: '0x68656c6c6f20776f726c64' },
})
// @log: Output: "0xa461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b"
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The signed message.

## Parameters

### message

- **Type:** `string | { raw: Hex | ByteArray }`

Message to sign.

By default, viem signs the UTF-8 representation of the message.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signMessage({
  message: 'hello world', // [!code focus:1]
})
```

To sign the data representation of the message, you can use the `raw` attribute.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signMessage({
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus:1]
})
```
</file>

<file path="accounts/local/signTransaction.md">
# signTransaction (Local Account) [Signs a transaction with the Account's private key.]

Signs a transaction with the Account's private key.

## Usage

```ts twoslash
import { parseGwei } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')

const signature = await account.signTransaction({
  chainId: 1,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('3'),
  gas: 21000n,
  nonce: 69,
  to: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
})
// @log: Output: "0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33"
```

### Custom serializer

viem has a built-in serializer for **Legacy**, **EIP-2930** (`0x01`) and **EIP-1559** (`0x02`) transaction types. If you would like to serialize on another transaction type that viem does not support internally, you can pass a custom serializer.

```ts 
import { parseGwei } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')

const signature = await account.signTransaction({
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('3'),
  gas: 21000n,
  nonce: 69,
  to: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
}, {
  serializer(transaction) { // [!code focus:16]
    const {
      chainId,
      nonce,
      // ...
    } = transaction

    return concatHex([
      '0x69',
      toRlp([
        toHex(chainId),
        nonce ? toHex(nonce) : '0x',
        // ...
      ]),
    ])
  }
})
```

## Returns

[`Hex`](/docs/glossary/types#Hex)

The signed transaction.

## Parameters

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  chainId: 1,
})
```

### authorizationList (optional)

- **Type:** `AuthorizationList`

Signed EIP-7702 Authorization list.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const authorization = await account.signAuthorization({
  contractAddress: '0x...',
  chainId: 1,
  nonce: 1,
})

const signature = await account.signTransaction({
  authorizationList: [authorization], // [!code focus]
  chainId: 1,
})
```

### blobs (optional)

- **Type:** `Hex[]`

Blobs for [Blob Transactions](/docs/guides/blob-transactions). 

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) 

const hash = await account.signTransaction({
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### chainId (optional)

- **Type:** `number`

The chain ID.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  chainId: 1, // [!code focus]
})
```

### data (optional)

- **Type:** `0x${string}`

Transaction data.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2' // [!code focus]
})
```

### gas (optional)

- **Type:** `bigint`

The gas limit for the transaction.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  gas: 69420n, // [!code focus]
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
import { parseGwei } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  gasPrice: parseGwei('20'), // [!code focus]
})
```

### kzg (optional)

- **Type:** `KZG`

KZG implementation for [Blob Transactions](/docs/guides/blob-transactions). 

See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]

const signature = await account.signTransaction({
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
import { parseGwei } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  chainId: 1,
  maxFeePerGas: parseGwei('20'), // [!code focus]
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
import { parseGwei } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  chainId: 1,
  maxPriorityFeePerGas: parseGwei('3'), // [!code focus]
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  nonce: 69 // [!code focus]
})
```

### to (optional)

- **Type:** `Address`

The transaction recipient.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  to: '0x...' // [!code focus]
})
```

### type (optional)

- **Type:** `"legacy" | "eip2930" | "eip1559"`

The transaction type.

```ts twoslash
// @noErrors
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  type: 'eip1559' // [!code focus]
})
```

### value (optional)

- **Type:** `bigint`

Value in wei sent with this transaction.

```ts twoslash
import { parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
const account = privateKeyToAccount('0x...')
// ---cut---
const signature = await account.signTransaction({
  value: parseEther('1'), // [!code focus]
})
```
</file>

<file path="accounts/local/signTypedData.md">
# signTypedData (Local Account) [Signs typed data with the Account's private key.]

Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message)))`

## Usage

:::code-group

```ts twoslash [example.ts]
import { privateKeyToAccount } from 'viem/accounts'
import { domain, types } from './data'

const account = privateKeyToAccount('0x...')

const signature = await account.signTypedData({
  domain,
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

```ts twoslash [data.ts] filename="data.ts"
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
 
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```

:::

## Returns

`0x${string}`

The signed data.

## Parameters

### domain

**Type:** `TypedDataDomain`

The typed data domain.

```ts
const signature = await account.signTypedData({
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### types

The type definitions for the typed data.

```ts
const signature = await account.signTypedData({
  domain,
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### primaryType

**Type:** Inferred `string`.

The primary type to extract from `types` and use in `value`.

```ts
const signature = await account.signTypedData({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### message

**Type:** Inferred from `types` & `primaryType`.

```ts
const signature = await account.signTypedData({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', 
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
</file>

<file path="accounts/local/toAccount.md">
# toAccount [A function to create a Custom Account.]

Creates an Account from a custom signing implementation

## Import

```ts
import { toAccount } from 'viem/accounts'
```

## Usage

```ts
import { 
  signMessage, 
  signTransaction, 
  signTypedData, 
  privateKeyToAddress,
  toAccount 
} from 'viem/accounts'

const privateKey = '0x...'

const account = toAccount({ // [!code focus:15]
  address: getAddress(privateKey),

  async signMessage({ message }) {
    return signMessage({ message, privateKey })
  },

  async signTransaction(transaction, { serializer }) {
    return signTransaction({ privateKey, transaction, serializer })
  },

  async signTypedData(typedData) {
    return signTypedData({ ...typedData, privateKey })
  },
})
```

## Parameters

### address

- **Type:** `Address`

The Address of the Account.

```ts
const account = toAccount({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // [!code focus]
  async signMessage({ message }) {
    return signMessage({ message, privateKey })
  },
  async signTransaction(transaction, { serializer }) {
    return signTransaction({ privateKey, transaction, serializer })
  },
  async signTypedData(typedData) {
    return signTypedData({ ...typedData, privateKey })
  },
})
```

### signMessage

Function to sign a message in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191).

```ts
const account = toAccount({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',

  async signMessage({ message }) { // [!code focus:3]
    return signMessage({ message, privateKey })
  },
  async signTransaction(transaction, { serializer }) {
    return signTransaction({ privateKey, transaction, serializer })
  },
  async signTypedData(typedData) {
    return signTypedData({ ...typedData, privateKey })
  },
})
```

### signTransaction

Function to sign a transaction.

```ts
const account = toAccount({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  async signMessage({ message }) {
    return signMessage({ message, privateKey })
  },
  async signTransaction(transaction, { serializer }) {  // [!code focus:3]
    return signTransaction({ privateKey, transaction, serializer })
  },
  async signTypedData(typedData) {
    return signTypedData({ ...typedData, privateKey })
  },
})
```

### signTypedData

Function to sign [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data.

```ts
const account = toAccount({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  async signMessage({ message }) {
    return signMessage({ message, privateKey })
  },
  async signTransaction(transaction, { serializer }) {
    return signTransaction({ privateKey, transaction, serializer })
  },
  async signTypedData(typedData) {  // [!code focus:3]
    return signTypedData({ ...typedData, privateKey })
  },
})
```
</file>

<file path="accounts/jsonRpc.md">
# JSON-RPC Account [A function to create a JSON-RPC Account.]

A JSON-RPC Account is an Account whose signing keys are stored on the external Wallet. It **defers** signing of transactions & messages to the target Wallet over JSON-RPC. An example of such Wallet could be a Browser Extension Wallet, or Mobile Wallet over WalletConnect.

## Usage

A JSON-RPC Account can just be initialized as an [Address](/docs/glossary/types#address) string. In the usage below, we are extracting the address from a Browser Extension Wallet (e.g. MetaMask) with the `window.ethereum` Provider via `eth_requestAccounts`:

```ts twoslash
// @noErrors
import 'viem/window'
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const [address] = await window.ethereum.request({ // [!code focus:3]
  method: 'eth_requestAccounts' 
})

const client = createWalletClient({
  account: address, // [!code focus]
  chain: mainnet,
  transport: custom(window.ethereum!)
})
```
</file>

<file path="accounts/local.md">
# Local Accounts (Private Key, Mnemonic, etc)

A Local Account is an Account whose signing keys are stored on the consuming user's machine. It performs signing of transactions & messages with a private key **before** broadcasting the transaction or message over JSON-RPC.

There are three types of Local Accounts in viem:

- [Private Key Account](/docs/accounts/local/privateKeyToAccount)
- [Mnemonic Account](/docs/accounts/local/mnemonicToAccount)
- [Hierarchical Deterministic (HD) Account](/docs/accounts/local/hdKeyToAccount)

## Instantiation

### 1. Initialize a Wallet Client

Before we set up our Account and start consuming Wallet Actions, we will need to set up our Wallet Client with the [`http` Transport](/docs/clients/transports/http):

```ts twoslash
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})
```

### 2. Set up your Local Account

Next, we will instantiate a Private Key Account using `privateKeyToAccount`:

```ts twoslash
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts' // [!code focus]
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})

const account = privateKeyToAccount('0x...') // [!code focus:1]
```

### 3. Consume [Wallet Actions](/docs/actions/wallet/introduction)

Now you can use that Account within Wallet Actions that need a signature from the user:

```ts twoslash
import { createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})

const account = privateKeyToAccount('0x...')

const hash = await client.sendTransaction({ // [!code focus:5]
  account,
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

### 4. Optional: Hoist the Account

If you do not wish to pass an account around to every Action that requires an `account`, you can also hoist the account into the Wallet Client.

```ts twoslash
import { createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

const client = createWalletClient({ // [!code focus:99]
  account, // [!code ++]
  chain: mainnet,
  transport: http()
})

const hash = await client.sendTransaction({
  account, // [!code --]
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

### 5. Optional: Extend with Public Actions

When using a Local Account, you may be finding yourself using a [Public Client](/docs/clients/public) instantiated with the same parameters (`transport`, `chain`, etc) as your Wallet Client.

In this case, you can extend your Wallet Client with [Public Actions](/docs/actions/public/introduction) to avoid having to handle multiple Clients.

```ts twoslash {12}
// @noErrors
import { createWalletClient, http, publicActions } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
}).extend(publicActions) // [!code ++]

const { request } = await client.simulateContract({ ... }) // Public Action
const hash = await client.writeContract(request) // Wallet Action
```
</file>

<file path="actions/public/call.md">
# call [An Action for executing a new message call.]

Executes a new message call immediately without submitting a transaction to the network.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, publicClient } from './config'

const data = await publicClient.call({ // [!code focus:7]
  account,
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// @log: ↓ JSON-RPC Account
export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'

// @log: ↓ Local Account
// export const account = privateKeyToAccount(...)

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Deployless Calls

It is possible to call a function on a contract that has not been deployed yet. For instance, we may want
to call a function on an [ERC-4337 Smart Account](https://eips.ethereum.org/EIPS/eip-4337) contract which has not been deployed.

Viem offers two ways of performing a Deployless Call, via:

- [Bytecode](#bytecode)
- a [Deploy Factory](#deploy-factory): "temporarily deploys" a contract with a provided [Deploy Factory](https://docs.alchemy.com/docs/create2-an-alternative-to-deriving-contract-addresses#create2-contract-factory), and calls the function on the deployed contract.

:::tip
The **Deployless Call** pattern is also accessible via the [`readContract`](/docs/contract/readContract#deployless-reads) & [Contract Instance](/docs/contract/getContract) APIs.
:::

#### Bytecode

The example below demonstrates how we can utilize a Deployless Call **via Bytecode** to call the `name` function on the [Wagmi Example ERC721 contract](https://etherscan.io/address/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2#code) which has not been deployed:

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData, parseAbi } from 'viem'
import { publicClient } from './config'

const data = await publicClient.call({
  // Bytecode of the contract. Accessible here: https://etherscan.io/address/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2#code
  code: '0x...',
  // Function to call on the contract.
  data: encodeFunctionData({
    abi: parseAbi(['function name() view returns (string)']),
    functionName: 'name'
  }),
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

#### Deploy Factory

The example below demonstrates how we can utilize a Deployless Call **via a [Deploy Factory](https://docs.alchemy.com/docs/create2-an-alternative-to-deriving-contract-addresses#create2-contract-factory)** to call the `entryPoint` function on an [ERC-4337 Smart Account](https://eips.ethereum.org/EIPS/eip-4337) which has not been deployed:

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData, parseAbi } from 'viem'
import { owner, publicClient } from './config'

const data = await publicClient.call({
  // Address of the contract deployer (e.g. Smart Account Factory).
  factory: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',

  // Function to execute on the factory to deploy the contract.
  factoryData: encodeFunctionData({
    abi: parseAbi(['function createAccount(address owner, uint256 salt)']),
    functionName: 'createAccount',
    args: [owner, 0n],
  }),

  // Function to call on the contract (e.g. Smart Account contract).
  data: encodeFunctionData({
    abi: parseAbi(['function entryPoint() view returns (address)']),
    functionName: 'entryPoint'
  }),

  // Address of the contract.
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const owner = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

:::note
This example utilizes the [SimpleAccountFactory](https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccountFactory.sol).
:::

## Returns

`0x${string}`

The call data.

## Parameters

### account

- **Type:** `Account | Address`

The Account to call from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### data

- **Type:** `0x${string}`

A contract hashed method call with encoded args.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### to

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address or recipient.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the call against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  blockNumber: 15121123n, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the call against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  blockTag: 'safe', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### code (optional)

- **Type:**

Bytecode to perform the call against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  code: '0x...', // [!code focus]
  data: '0xdeadbeef',
})
```

### factory (optional)

- **Type:**

Contract deployment factory address (ie. Create2 factory, Smart Account factory, etc).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  factory: '0x0000000000ffe8b47b3e2130213b802212439497', // [!code focus]
  factoryData: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### factoryData (optional)

- **Type:**

Calldata to execute on the factory to deploy the contract.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  factory: '0x0000000000ffe8b47b3e2130213b802212439497',
  factoryData: '0xdeadbeef', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### gas (optional)

- **Type:** `bigint`

The gas provided for transaction execution.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  gas: 1_000_000n, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseGwei } from 'viem'

const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseGwei } from 'viem'

const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  maxFeePerGas: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseGwei } from 'viem'

const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### nonce (optional)

- **Type:** `bigint`

Unique number identifying this transaction.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  nonce: 420, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### stateOverride (optional)

- **Type:** [`StateOverride`](/docs/glossary/types#stateoverride)

The state override set is an optional address-to-state mapping, where each entry specifies some state to be ephemerally overridden prior to executing the call.

```ts
const data = await publicClient.call({
  account,
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  stateOverride: [ // [!code focus]
    { // [!code focus]
      address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
      balance: parseEther('1'), // [!code focus]
      stateDiff: [ // [!code focus]
        { // [!code focus]
          slot: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0', // [!code focus]
          value: '0x00000000000000000000000000000000000000000000000000000000000001a4', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    } // [!code focus]
  ], // [!code focus]
})
```

### value (optional)

- **Type:** `bigint`

Value (in wei) sent with this transaction.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const data = await publicClient.call({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
})
```

## JSON-RPC Methods

[`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)
</file>

<file path="actions/public/createAccessList.md">
# createAccessList

Creates an [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list based on a transaction request.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, publicClient } from './config'

const result = await publicClient.createAccessList({ // [!code focus:7]
  data: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`{ accessList: AccessList, gasUsed: bigint }`

The access list and gas used.

## Parameters

### account (optional)

- **Type:** `Account | Address`

The Account to create an access list for.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  data: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### blockNumber (optional)

- **Type:** `number`

Block number to create an access list for.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const result = await publicClient.createAccessList({
  blockNumber: 15121123n, // [!code focus]
  data: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Block tag to create an access list for.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const result = await publicClient.createAccessList({
  blockTag: 'safe', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### data (optional)

- **Type:** `0x${string}`

Contract function selector with encoded arguments.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef',
  maxFeePerGas: parseGwei('20'),  // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### to (optional)

- **Type:** [`Address`](/docs/glossary/types#address)

Transaction recipient.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
})
```

### value (optional)

- **Type:** `bigint`

Value (in wei) sent with this transaction.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const result = await publicClient.createAccessList({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: '0xdeadbeef',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') // [!code focus]
})
```
</file>

<file path="actions/public/createBlockFilter.md">
# createBlockFilter [An Action for creating a new Block Filter.]

Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](/docs/actions/public/getFilterChanges).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createBlockFilter() // [!code focus:99]
// @log: { id: "0x345a6572337856574a76364e457a4366", type: 'block' }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`Filter`](/docs/glossary/types#filter)

## JSON-RPC Methods

[`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)
</file>

<file path="actions/public/createEventFilter.md">
# createEventFilter [An Action for creating a new Event Filter.]

Creates a Filter to listen for new events that can be used with [`getFilterChanges`](/docs/actions/public/getFilterChanges).

## Usage

By default, an Event Filter with no arguments will query for/listen to all events.

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createEventFilter()
// @log: { id: "0x345a6572337856574a76364e457a4366", type: 'event' }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

:::tip
Check out [`createContractEventFilter`](/docs/contract/createContractEventFilter) if you are after a first-class solution for querying events on a contract without needing to manually craft ABI event parameters.
:::

## Scoping

You can also scope a Filter to a set of given attributes (listed below).

### Address

A Filter can be scoped to an **address**:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createEventFilter({
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2' // [!code focus]
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Event

A Filter can be scoped to an **event**.

The `event` argument takes in an event in ABI format – we have a [`parseAbiItem` utility](/docs/abi/parseAbiItem) that you can use to convert from a human-readable event signature → ABI.

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem' // [!code focus]
import { publicClient } from './client'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'), // [!code focus]
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

By default, `event` accepts the [`AbiEvent`](/docs/glossary/types#abievent) type:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createEventFilter(publicClient, {
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: { // [!code focus:99]
    name: 'Transfer', 
    inputs: [
      { type: 'address', indexed: true, name: 'from' },
      { type: 'address', indexed: true, name: 'to' },
      { type: 'uint256', indexed: false, name: 'value' }
    ] 
  }
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Arguments

A Filter can be scoped to given **_indexed_ arguments**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```

Only indexed arguments in `event` are candidates for `args`.

A Filter Argument can also be an array to indicate that other values can exist in the position:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:8]
    // '0xd8da...' OR '0xa5cc...' OR '0xa152...'
    from: [
      '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
      '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',
      '0xa152f8bb749c55e9943a3a0a3111d18ee2b3f94e',
    ],
  }
})
```

### Block Range

A Filter can be scoped to a **block range**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  fromBlock: 16330000n, // [!code focus]
  toBlock: 16330050n // [!code focus]
})
```

### Multiple Events

A Filter can be scoped to **multiple events**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbi } from 'viem'

const filter = await publicClient.createEventFilter({
  events: parseAbi([ // [!code focus:4]
    'event Approval(address indexed owner, address indexed sender, uint256 value)',
    'event Transfer(address indexed from, address indexed to, uint256 value)',
  ]),
})
```

Note: A Filter scoped to multiple events cannot be also scoped with [indexed arguments](#arguments) (`args`).

### Strict Mode

By default, `createEventFilter` will include logs that [do not conform](/docs/glossary/terms#non-conforming-log) to the indexed & non-indexed arguments on the `event`.
viem will not return a value for arguments that do not conform to the ABI, thus, some arguments on `args` may be undefined.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
})
const logs = await publicClient.getFilterLogs({ filter })

logs[0].args
//      ^?






```

You can turn on `strict` mode to only return logs that conform to the indexed & non-indexed arguments on the `event`, meaning that `args` will always be defined. The trade-off is that non-conforming logs will be filtered out.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  strict: true
})
const logs = await publicClient.getFilterLogs({ filter })

logs[0].args
//      ^?






```

## Returns

[`Filter`](/docs/glossary/types#filter)

## Parameters

### address (optional)

- **Type:** `Address | Address[]`

The contract address or a list of addresses from which Logs should originate.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createEventFilter({
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2' // [!code focus]
})
```

### event (optional)

- **Type:** [`AbiEvent`](/docs/glossary/types#abievent)

The event in ABI format.

A [`parseAbiItem` utility](/docs/abi/parseAbiItem) is exported from viem that converts from a human-readable event signature → ABI.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem' // [!code focus]

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'), // [!code focus]
})
```

### args (optional)

- **Type:** Inferred.

A list of _indexed_ event arguments.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const filter = await publicClient.createEventFilter({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```

### fromBlock (optional)

- **Type:** `bigint`

Block to start querying/listening from.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createEventFilter({
  fromBlock: 69420n // [!code focus]
})
```

### toBlock (optional)

- **Type:** `bigint`

Block to query/listen until.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createEventFilter({
  toBlock: 70120n // [!code focus]
})
```

## JSON-RPC Methods

[`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)
</file>

<file path="actions/public/createPendingTransactionFilter.md">
# createPendingTransactionFilter [An Action for creating a new pending transaction filter.]

Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](/docs/actions/public/getFilterChanges).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createPendingTransactionFilter() // [!code focus:99]
// @log: Output: { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`Filter`](/docs/glossary/types#filter)

## JSON-RPC Methods

[`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)
</file>

<file path="actions/public/estimateFeesPerGas.md">
---
description: Returns an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.
---

# estimateFeesPerGas 

Returns an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

If [`chain.fees.estimateFeesPerGas`](/docs/actions/public/estimateFeesPerGas) is set on the [Client Chain](/docs/clients/public#chain-optional) or [override Chain](#chain-optional), it will use the returned value.

Otherwise, for EIP-1559 Transactions, viem will estimate the fees using a combination of the block's base fee per gas (to derive `maxFeePerGas`) + the [`estimateMaxPriorityFeePerGas` Action](/docs/actions/public/estimateMaxPriorityFeePerGas) (to derive `maxPriorityFeePerGas`). For Legacy Transactions, viem will estimate the fee based on the gas price (via the [`getGasPrice` Action](/docs/actions/public/getGasPrice)).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const {
  maxFeePerGas,
  maxPriorityFeePerGas
} = await publicClient.estimateFeesPerGas()
// @log: {
// @log:   maxFeePerGas: 15_000_000_000n,
// @log:   maxPriorityFeePerGas: 1_000_000_000n,
// @log: }

const { gasPrice } = await publicClient.estimateFeesPerGas({
  type: 'legacy'
})
// @log: { gasPrice: 15_000_000_000n } 
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`FeeValues`](/docs/glossary/types#feevalues)

An estimate (in wei) for the fees per gas.

## Parameters

### chain (optional)

- **Type:** [Chain](/docs/glossary/types#chain)
- **Default:** [`client.chain`](/docs/clients/public#chain-optional)

Optional Chain override. Used to infer the fees per gas from [`chain.fees.estimateFeesPerGas`](/docs/actions/public/estimateFeesPerGas).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { optimism } from 'viem/chains' // [!code focus]

const { maxFeePerGas, maxPriorityFeePerGas } = 
  await publicClient.estimateFeesPerGas({
    chain: optimism // [!code focus]
  })
```

### type (optional)

- **Type:** `"legacy" | "eip1559"`
- **Default:** `"eip1559"`

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const { gasPrice } = await publicClient.estimateFeesPerGas({
  type: 'legacy' // [!code focus]
})
```
</file>

<file path="actions/public/estimateGas.md">
# estimateGas [An Action for estimating gas for a transaction.]

Estimates the gas necessary to complete a transaction without submitting it to the network.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, publicClient } from './config'

const gas = await publicClient.estimateGas({ // [!code focus:7]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// @log: ↓ JSON-RPC Account
export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'

// @log: ↓ Local Account
// export const account = privateKeyToAccount('0x...')

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`bigint`

The gas estimate (in gas).

## Parameters

### account

- **Type:** `Account | Address`

The Account to estimate gas from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const gas = await publicClient.estimateGas({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### data (optional)

- **Type:** `0x${string}`

Contract code or a hashed method call with encoded args which can be generated using [encodeFunctionData](/docs/contract/encodeFunctionData).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const gas = await publicClient.estimateGas({
  data: '0x...', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const gas = await publicClient.estimateGas({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') 
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const gas = await publicClient.estimateGas({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  maxFeePerGas: parseGwei('20'),  // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const gas = await publicClient.estimateGas({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### to (optional)

- **Type:** [`Address`](/docs/glossary/types#address)

Transaction recipient.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const gas = await publicClient.estimateGas({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
  value: parseEther('1')
})
```

### value (optional)

- **Type:** `bigint`

Value (in wei) sent with this transaction.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const gas = await publicClient.estimateGas({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the gas estimate against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const gas = await publicClient.estimateGas({
  blockNumber: 15121123n, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') 
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the gas estimate against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseEther } from 'viem'

const gas = await publicClient.estimateGas({
  blockTag: 'safe', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') 
})
```

### stateOverride (optional)

- **Type:** [`StateOverride`](/docs/glossary/types#stateoverride)

The state override set is an optional address-to-state mapping, where each entry specifies some state to be ephemerally overridden prior to executing the call.

```ts
const data = await publicClient.estimateGas({
  account,
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  stateOverride: [ // [!code focus]
    { // [!code focus]
      address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
      balance: parseEther('1'), // [!code focus]
      stateDiff: [ // [!code focus]
        { // [!code focus]
          slot: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0', // [!code focus]
          value: '0x00000000000000000000000000000000000000000000000000000000000001a4', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    } // [!code focus]
  ], // [!code focus]
})
```

## JSON-RPC Methods

[`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)
</file>

<file path="actions/public/estimateMaxPriorityFeePerGas.md">
---
description: Returns an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.
---

# estimateMaxPriorityFeePerGas

Returns an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.

If [`chain.fees.defaultPriorityFee`](/docs/chains/fees#feesdefaultpriorityfee) is set on the [Client Chain](/docs/clients/public#chain-optional) or [override Chain](#chain-optional), it will use that value.

Otherwise, the Action will either call [`eth_maxPriorityFeePerGas`](https://github.com/ethereum/execution-apis/blob/fe8e13c288c592ec154ce25c534e26cb7ce0530d/src/eth/fee_market.yaml#L9-L16) (if supported) or manually calculate the max priority fee per gas based on the current block base fee per gas + gas price.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const maxPriorityFeePerGas = await publicClient.estimateMaxPriorityFeePerGas()
// @log: Output: 1_000_000_000n
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`bigint`

An estimate (in wei) for the max priority fee per gas.

## Parameters

### chain (optional)

- **Type:** [Chain](/docs/glossary/types#chain)
- **Default:** [`client.chain`](/docs/clients/public#chain-optional)

Optional Chain override. Used to infer the default `maxPriorityFeePerGas` from [`chain.fees.defaultPriorityFee`](/docs/chains/fees#feesdefaultpriorityfee).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { optimism } from 'viem/chains' // [!code focus]

const maxPriorityFeePerGas = 
  await publicClient.estimateMaxPriorityFeePerGas({
    chain: optimism // [!code focus]
  })
```
</file>

<file path="actions/public/getBalance.md">
---
description: Returns the balance of an address in wei.
---

# getBalance

Returns the balance of an address in wei.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const balance = await publicClient.getBalance({ // [!code focus:4]
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
})
// @log: > 10000000000000000000000n (wei)
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/publicClient.ts]
```

:::

## Returns

`bigint`

The balance of the address in wei.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The address of the account.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const balance = await publicClient.getBalance({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `bigint`

The balance of the account at a block number.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const balance = await publicClient.getBalance({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  blockNumber: 69420n  // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

The balance of the account at a block tag.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const balance = await publicClient.getBalance({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  blockTag: 'safe'  // [!code focus]
})
```

## Tips

- You can convert the balance to ether units with [`formatEther`](/docs/utilities/formatEther).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { formatEther } from 'viem' // [!code focus]

const balance = await publicClient.getBalance({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  blockTag: 'safe'
})
const balanceAsEther = formatEther(balance) // [!code focus:2]
// "6.942"
```

## JSON-RPC Method

[`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
</file>

<file path="actions/public/getBlobBaseFee.md">
---
description: Returns the current blob base fee (in wei).
---

# getBlobBaseFee

Returns the current blob base fee (in wei).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const baseFee = await publicClient.getBlobBaseFee() // [!code focus]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`bigint`

the blob base fee (in wei).

## JSON-RPC Method

[`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
</file>

<file path="actions/public/getBlock.md">
---
description: Returns information about a block at a block number, hash or tag.
---

# getBlock

Returns information about a block at a block number, hash or tag.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const block = await publicClient.getBlock() // [!code focus:99]
// @log: Output: {
// @log:  baseFeePerGas: 10789405161n,
// @log:  difficulty: 11569232145203128n,
// @log:  extraData: '0x75732d656173742d38',
// @log:  ...
// @log: }
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/publicClient.ts]
```

:::

## Returns

[`Block`](/docs/glossary/types#block)

Information about the block.

## Parameters

### blockHash (optional)

- **Type:** [`Hash`](/docs/glossary/types#hash)

Information at a given block hash.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlock({
  blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `bigint`

Information at a given block number.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlock({
  blockNumber: 42069n // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Information at a given block tag.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlock({
  blockTag: 'safe' // [!code focus]
})
```

### includeTransactions (optional)

- **Type:** `boolean`

Whether or not to include transactions (as a structured array of `Transaction` objects).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlock({
  includeTransactions: true // [!code focus]
})
```

## Example

Check out the usage of `getBlock` in the live [Fetching Blocks Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Method

- Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.
- Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.
</file>

<file path="actions/public/getBlockNumber.md">
---
description: Returns the number of the most recent block seen.
---

# getBlockNumber

Returns the number of the most recent block seen.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const blockNumber = await publicClient.getBlockNumber() // [!code focus:99]
// @log: Output: 69420n
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/publicClient.ts]
```

:::

## Returns

`bigint`

The number of the block.

## Parameters

### cacheTime (optional)

- **Type:** `number`
- **Default:** [Client's `cacheTime`](/docs/clients/public#cachetime-optional)

Time (in ms) that cached block number will remain in memory.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlockNumber({
  cacheTime: 4_000 // [!code focus]
})
```

By default, block numbers are cached for the period of the [Client's `cacheTime`](/docs/clients/public#cacheTime-optional).

- Setting a value of above zero will make block number remain in the cache for that period.
- Setting a value of `0` will disable the cache, and always retrieve a fresh block number.

## Example

Check out the usage of `getBlockNumber` in the live [Fetching Blocks Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Method

[`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)
</file>

<file path="actions/public/getBlockTransactionCount.md">
---
description: Returns the number of Transactions at a block number, hash or tag.
---

# getBlockTransactionCount

Returns the number of Transactions at a block number, hash or tag.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const count = await publicClient.getBlockTransactionCount() // [!code focus:99]
// @log: Output: 23
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`number`

The block transaction count.

## Parameters

### blockHash (optional)

- **Type:** [`Hash`](/docs/glossary/types#hash)

Count at a given block hash.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const count = await publicClient.getBlockTransactionCount({
  blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d' // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `bigint`

Count at a given block number.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlockTransactionCount({
  blockNumber: 42069n // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Count at a given block tag.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const block = await publicClient.getBlockTransactionCount({
  blockTag: 'safe' // [!code focus]
})
```

## JSON-RPC Method

- Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.
- Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.
</file>

<file path="actions/public/getChainId.md">
---
description: Returns the chain ID associated with the current network
---

# getChainId

Returns the chain ID associated with the current network

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const chainId = await publicClient.getChainId() // [!code focus:99]
// @log: 1
```

```ts [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`number`

The current chain ID.

## JSON-RPC Method

- Calls [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid).
</file>

<file path="actions/public/getEip712Domain.md">
---
description: Reads the EIP-712 domain from a contract.
---

# getEip712Domain

Reads the EIP-712 domain from a contract, based on the [ERC-5267 specification](https://eips.ethereum.org/EIPS/eip-5267).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const { domain, extensions, fields } = await publicClient.getEip712Domain({ 
  address: '0x57ba3ec8df619d4d243ce439551cce713bb17411',
})
```

```ts [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Counterfactual Call

It is possible to read the EIP-712 domain on a contract that **has not been deployed** by providing deployment factory (`factory` + `factoryData`) parameters:

:::code-group

```ts twoslash [example.ts]
import { factory, publicClient } from './config'

const { domain, extensions, fields } = await publicClient.getEip712Domain({ 
  address: '0x57ba3ec8df619d4d243ce439551cce713bb17411',
  factory: factory.address,
  factoryData: encodeFunctionData({
    abi: factory.abi,
    functionName: 'createAccount',
    args: ['0x0000000000000000000000000000000000000000', 0n]
  }),
})
```

```ts [client.ts] filename="config.ts"
import { createPublicClient, http, parseAbi } from 'viem'
import { mainnet } from 'viem/chains'

export const factory = {
  address: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',
  abi: parseAbi(['function createAccount(address owner, uint256 salt)']),
} as const

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`GetEip712DomainReturnType`

The EIP-712 domain (`domain`) for the contract, with `fields` and `extensions`, as per [ERC-5267](https://eips.ethereum.org/EIPS/eip-5267).

## Parameters

### address

- **Type:** `string`

The address of the contract to read the EIP-712 domain from.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const result = await publicClient.getEip712Domain({ 
  address: '0x57ba3ec8df619d4d243ce439551cce713bb17411', // [!code focus]
})
```

### factory (optional)

- **Type:**

Contract deployment factory address (ie. Create2 factory, Smart Account factory, etc).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const result = await publicClient.getEip712Domain({ 
  address: '0x57ba3ec8df619d4d243ce439551cce713bb17411',
  factory: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb', // [!code focus]
  factoryData: '0xdeadbeef',
})
```

### factoryData (optional)

- **Type:**

Calldata to execute on the factory to deploy the contract.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const result = await publicClient.getEip712Domain({ 
  address: '0x57ba3ec8df619d4d243ce439551cce713bb17411',
  factory: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',
  factoryData: '0xdeadbeef', // [!code focus]
})
```
</file>

<file path="actions/public/getFeeHistory.md">
---
description: Returns a collection of historical gas information.
---

# getFeeHistory

Returns a collection of historical gas information.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const feeHistory = await publicClient.getFeeHistory({ // [!code focus:4]
  blockCount: 4,
  rewardPercentiles: [25, 75]
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`FeeHistory`](/docs/glossary/types#feehistory)

The fee history.

## Parameters

### blockCount

- **Type:** `number`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const feeHistory = await publicClient.getFeeHistory({
  blockCount: 4, // [!code focus]
  rewardPercentiles: [25, 75]
})
```

### rewardPercentiles

- **Type:** `number[]`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const feeHistory = await publicClient.getFeeHistory({
  blockCount: 4,
  rewardPercentiles: [25, 75] // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

Highest number block of the requested range.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const feeHistory = await publicClient.getFeeHistory({
  blockCount: 4,
  blockNumber: 1551231n, // [!code focus]
  rewardPercentiles: [25, 75]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Highest number block of the requested range.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const feeHistory = await publicClient.getFeeHistory({
  blockCount: 4,
  blockTag: 'safe', // [!code focus]
  rewardPercentiles: [25, 75]
})
```

## JSON-RPC Method

- Calls [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory).
</file>

<file path="actions/public/getFilterChanges.md">
---
description: Returns a list of logs or hashes based on a Filter.
---

# getFilterChanges

Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.

A Filter can be created from the following actions:

- [`createBlockFilter`](/docs/actions/public/createBlockFilter)
- [`createContractEventFilter`](/docs/contract/createContractEventFilter)
- [`createEventFilter`](/docs/actions/public/createEventFilter)
- [`createPendingTransactionFilter`](/docs/actions/public/createPendingTransactionFilter)

## Usage

### Blocks

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createBlockFilter() // [!code focus:99]
const hashes = await publicClient.getFilterChanges({ filter })
// @log: Output: ["0x10d86dc08ac2f18f00ef0daf7998dcc8673cbcf1f1501eeb2fac1afd2f851128", ...]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Contract Events

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createContractEventFilter({ // [!code focus:99]
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  abi: wagmiAbi,
  eventName: 'Transfer'
})
const logs = await publicClient.getFilterChanges({ filter })
// @log: Output: [{ ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Raw Events

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem'
import { publicClient } from './client'

const filter = await publicClient.createEventFilter({ // [!code focus:99]
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
})
const logs = await publicClient.getFilterChanges({ filter })
// @log: Output: [{ ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Transactions

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createPendingTransactionFilter() // [!code focus:99]
const hashes = await publicClient.getFilterChanges({ filter })
// @log: Output: ["0x89b3aa1c01ca4da5d15eca9fab459d062db5c0c9b76609acb0741901f01f6d19", ...]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`Log[]`](/docs/glossary/types#log)

If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.

**OR**

`"0x${string}"[]`

If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.

**OR**

`"0x${string}"[]`

If the filter was created with `createBlockFilter`, it returns a list of block hashes.

## Parameters

### filter

- **Type:** [`Filter`](/docs/glossary/types#filter)

A created filter.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createPendingTransactionFilter()
const logs = await publicClient.getFilterChanges({
  filter, // [!code focus]
})
```

## JSON-RPC Method

- Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
</file>

<file path="actions/public/getFilterLogs.md">
---
description: Returns a list of event logs since the filter was created. 
---

# getFilterLogs

Returns a list of **event** logs since the filter was created. 

Note: `getFilterLogs` is only compatible with **event filters**.

## Usage

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem'
import { publicClient } from './client'

const filter = await publicClient.createEventFilter({ // [!code focus:99]
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
})
const logs = await publicClient.getFilterLogs({ filter })
// @log: [{ ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::


## Returns

[`Log[]`](/docs/glossary/types#log)

A list of event logs.

## Parameters

### filter

- **Type:** [`Filter`](/docs/glossary/types#filter)

An **event** filter.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createEventFilter()
const logs = await publicClient.getFilterChanges({
  filter, // [!code focus]
})
```

## JSON-RPC Method

[`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)
</file>

<file path="actions/public/getGasPrice.md">
---
description: Returns the current price of gas (in wei).
---

# getGasPrice

Returns the current price of gas (in wei).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const gasPrice = await publicClient.getGasPrice() // [!code focus:4]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`bigint`

The gas price (in wei).

## JSON-RPC Method

[`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
</file>

<file path="actions/public/getLogs.md">
---
description: Returns a list of event logs matching the provided parameters. 
---

# getLogs

Returns a list of **event** logs matching the provided parameters.

## Usage

By default, `getLogs` returns all events. In practice, you must use scoping to filter for specific events.

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const logs = await publicClient.getLogs()  // [!code focus:99]
// @log: Output: [{ ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Scoping

You can also scope to a set of given attributes.

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem'
import { publicClient } from './client'

const logs = await publicClient.getLogs({  // [!code focus:99]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256)'),
  args: {
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  fromBlock: 16330000n,
  toBlock: 16330050n
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

By default, `event` accepts the [`AbiEvent`](/docs/glossary/types#abievent) type:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const logs = await publicClient.getLogs(publicClient, {
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: { // [!code focus:8]
    name: 'Transfer', 
    inputs: [
      { type: 'address', indexed: true, name: 'from' },
      { type: 'address', indexed: true, name: 'to' },
      { type: 'uint256', indexed: false, name: 'value' }
    ] 
  },
  args: {
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  fromBlock: 16330000n,
  toBlock: 16330050n
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Address

Logs can be scoped to an **address**:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const logs = await publicClient.getLogs({
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2' // [!code focus]
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Event

Logs can be scoped to an **event**.

The `event` argument takes in an event in ABI format – we have a [`parseAbiItem` utility](/docs/abi/parseAbiItem) that you can use to convert from a human-readable event signature → ABI.

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem' // [!code focus]
import { publicClient } from './client'

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'), // [!code focus]
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Arguments

Logs can be scoped to given **_indexed_ arguments**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```

Only indexed arguments in `event` are candidates for `args`.

An argument can also be an array to indicate that other values can exist in the position:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:8]
    // '0xd8da...' OR '0xa5cc...' OR '0xa152...'
    from: [
      '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
      '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',
      '0xa152f8bb749c55e9943a3a0a3111d18ee2b3f94e',
    ],
  }
})
```

### Block Range

Logs can be scoped to a **block range**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  fromBlock: 16330000n, // [!code focus]
  toBlock: 16330050n // [!code focus]
})
```

### Multiple Events

Logs can be scoped to **multiple events**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbi } from 'viem'

const logs = await publicClient.getLogs({
  events: parseAbi([ // [!code focus:4]
    'event Approval(address indexed owner, address indexed sender, uint256 value)',
    'event Transfer(address indexed from, address indexed to, uint256 value)',
  ]),
})
```

Note: Logs scoped to multiple events cannot be also scoped with [indexed arguments](#arguments) (`args`).

### Strict Mode

By default, `getLogs` will include logs that [do not conform](/docs/glossary/terms#non-conforming-log) to the indexed & non-indexed arguments on the `event`.
viem will not return a value for arguments that do not conform to the ABI, thus, some arguments on `args` may be undefined.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem' 

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)')
})

logs[0].args
//      ^? 






```

You can turn on `strict` mode to only return logs that conform to the indexed & non-indexed arguments on the `event`, meaning that `args` will always be defined. The trade-off is that non-conforming logs will be filtered out.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem' 

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  strict: true
})

logs[0].args
//      ^?






```

## Returns

[`Log[]`](/docs/glossary/types#log)

A list of event logs.

## Parameters

### address

- **Type:** [`Address | Address[]`](/docs/glossary/types#address)

A contract address or a list of contract addresses. Only logs originating from the contract(s) will be included in the result.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const logs = await publicClient.getLogs({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
})
```

### event

- **Type:** [`AbiEvent`](/docs/glossary/types#abievent)

The event in ABI format.

A [`parseAbiItem` utility](/docs/abi/parseAbiItem) is exported from viem that converts from a human-readable event signature → ABI.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const logs = await publicClient.getLogs({
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'), // [!code focus]
})
```

### args

- **Type:** Inferred.

A list of _indexed_ event arguments.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const logs = await publicClient.getLogs({
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
})
```

### fromBlock

- **Type:** `bigint | 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Block to start including logs from. Mutually exclusive with `blockHash`.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createEventFilter({
  fromBlock: 69420n // [!code focus]
})
```

### toBlock

- **Type:** `bigint | 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Block to stop including logs from. Mutually exclusive with `blockHash`.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createEventFilter({
  toBlock: 70120n // [!code focus]
})
```

### blockHash

- **Type:** `'0x${string}'`

Block hash to include logs from. Mutually exclusive with `fromBlock`/`toBlock`.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const logs = await publicClient.getLogs({
  blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d' // [!code focus]
})
```

## Live Example

Check out the usage of `getLogs` in the live [Event Logs Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Method

[`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
</file>

<file path="actions/public/getProof.md">
---
description: Returns the account and storage values of the specified account including the Merkle-proof.
---

# getProof

Returns the account and storage values of the specified account including the Merkle-proof.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const proof = await publicClient.getProof({ 
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { optimism } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: optimism,
  transport: http()
})
```

:::

## Returns

`Proof`

Proof data.

## Parameters

### address

- **Type:** `bigint`

Account address.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const proof = await publicClient.getProof({
  address: '0x4200000000000000000000000000000000000016', // [!code focus]
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
  blockNumber: 42069n
})
```

### storageKeys

- **Type:** `Hash[]`

Array of storage-keys that should be proofed and included.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const proof = await publicClient.getProof({
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [ // [!code focus:3]
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
  blockNumber: 42069n
})
```

### blockNumber (optional)

- **Type:** `bigint`

Proof at a given block number.

```ts
const proof = await publicClient.getProof({
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
  blockNumber: 42069n // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Proof at a given block tag.

```ts
const proof = await publicClient.getProof({
  address: '0x4200000000000000000000000000000000000016',
  storageKeys: [
    '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
  ],
  blockTag: 'latest' // [!code focus]
})
```

## JSON-RPC Method

- Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186).
</file>

<file path="actions/public/getTransaction.md">
---
description: Returns information about a transaction given a hash or block identifier.
---

# getTransaction

Returns information about a [Transaction](/docs/glossary/terms#transaction) given a hash or block identifier.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const transaction = await publicClient.getTransaction({ // [!code focus:99]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d'
})
// @log: {
// @log:  blockHash: '0xaf1dadb8a98f1282e8f7b42cc3da8847bfa2cf4e227b8220403ae642e1173088',
// @log:  blockNumber: 15132008n,
// @log:  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
// @log:  ...
// @log: }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`Transaction`](/docs/glossary/types#transaction)

The transaction information.

## Parameters

### hash (optional)

- **Type:** `'0x${string}'`

Get information about a transaction given a transaction hash.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.getTransaction({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d' // [!code focus]
})
```

### blockHash (optional)

- **Type:** `'0x${string}'`

Get information about a transaction given a block hash (and index).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.getTransaction({
  blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', // [!code focus:2]
  index: 0
})
```

### blockNumber (optional)

- **Type:** `'0x${string}'`

Get information about a transaction given a block number (and index).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.getTransaction({
  blockNumber: 69420n, // [!code focus:2]
  index: 0
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Get information about a transaction given a block tag (and index).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.getTransaction({
  blockTag: 'safe', // [!code focus:2]
  index: 0
})
```

### index (optional)

- **Type:** `number`

An index to be used with a block identifier (number, hash or tag).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.getTransaction({
  blockTag: 'safe',
  index: 0 // [!code focus]
})
```

## Example

Check out the usage of `getTransaction` in the live [Fetching Transactions Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Method

[`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)
</file>

<file path="actions/public/getTransactionConfirmations.md">
---
description: Returns the number of blocks passed (confirmations) since the transaction was processed on a block.
---

# getTransactionConfirmations

Returns the number of blocks passed (confirmations) since the transaction was processed on a block.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const transactionReceipt = await publicClient.getTransactionReceipt({ hash: '...' })
const confirmations = await publicClient.getTransactionConfirmations({  // [!code focus:99]
  transactionReceipt
})
// 15n
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

You can also fetch confirmations by Transaction hash:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const confirmations = await publicClient.getTransactionConfirmations({  // [!code focus:99]
  hash: '0x...'
})
// @log: 15n
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`bigint`

The number of blocks passed since the transaction was processed. If confirmations is `0`, then the Transaction has not been confirmed & processed yet.

## Parameters

### transactionReceipt

- **Type:** [`TransactionReceipt`](/docs/glossary/types#transactionreceipt)

The transaction receipt.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
// @noErrors
const balance = await publicClient.getTransactionConfirmations({
  transactionReceipt: { ... }, // [!code focus]
})
```

### hash

- **Type:** [`Hash`](/docs/glossary/types#hash)

The hash of the transaction.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const balance = await publicClient.getTransactionConfirmations({
  hash: '0x...'  // [!code focus]
})
```

## Example

Check out the usage of `getTransactionConfirmations` in the live [Fetching Transactions Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Method

[`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)
</file>

<file path="actions/public/getTransactionCount.md">
---
description: Returns the number of Transactions an Account has sent.
---

# getTransactionCount

Returns the number of [Transactions](/docs/glossary/terms#transaction) an Account has broadcast / sent.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const transactionCount = await publicClient.getTransactionCount({  // [!code focus:99]
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
})
// @log: > 420
```

```ts [client.ts] filename="client.ts"
// [!include ~/snippets/publicClient.ts]
```

:::

## Returns

`number`

The number of transactions an account has sent. 

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The address of the account.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transactionCount = await publicClient.getTransactionCount({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `bigint`

Get the count at a block number.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transactionCount = await publicClient.getTransactionCount({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  blockNumber: 69420n  // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Get the count at a block tag.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transactionCount = await publicClient.getTransactionCount({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  blockTag: 'safe'  // [!code focus]
})
```

## Notes

- The transaction count of an account can also be used as a nonce.

## JSON-RPC Method

[`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)
</file>

<file path="actions/public/getTransactionReceipt.md">
---
description: Returns the transaction receipt given a transaction hash.
---

# getTransactionReceipt

Returns the [Transaction Receipt](/docs/glossary/terms#transaction-receipt) given a [Transaction](/docs/glossary/terms#transaction) hash.

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const transaction = await publicClient.getTransactionReceipt({ // [!code focus:99]
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d'
})
// @log: {
// @log:  blockHash: '0xaf1dadb8a98f1282e8f7b42cc3da8847bfa2cf4e227b8220403ae642e1173088',
// @log:  blockNumber: 15132008n,
// @log:  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
// @log:  ...
// @log:  status: 'success',
// @log: }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`TransactionReceipt`](/docs/glossary/types#transactionreceipt)

The transaction receipt.

## Parameters

### hash

- **Type:** `'0x${string}'`

A transaction hash.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.getTransactionReceipt({
  hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d' // [!code focus]
})
```

## Example

Check out the usage of `getTransactionReceipt` in the live [Fetching Transactions Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Method

[`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt)
</file>

<file path="actions/public/introduction.md">
# Introduction to Public Actions [A brief introduction on what Public Actions are in viem.]

A Public Action is an action that maps one-to-one with a "public" Ethereum RPC method (`eth_blockNumber`, `eth_getBalance`, etc). They are used with a [Public Client](/docs/clients/public).

Public Actions do not require any special permissions nor do they provide signing capabilities to the user. Examples of Public Actions include [getting the balance of an account](/docs/actions/public/getBalance), [retrieving the details of a specific transaction](/docs/actions/public/getTransactionReceipt), and [getting the current block number](/docs/actions/public/getBlockNumber) of the network.

Public Actions provide a simple and secure way to access public data on the Ethereum blockchain. They are widely used by dapps and other applications that need to retrieve information about transactions, accounts, blocks and other data on the network.
</file>

<file path="actions/public/simulateBlocks.md">
---
description: Simulates a set of calls on block(s).
---

# simulateBlocks

Simulates a set of calls on block(s) with optional block and state overrides. Internally uses the [`eth_simulateV1` JSON-RPC method](https://github.com/ethereum/execution-apis/pull/484).

## Usage

:::code-group

```ts twoslash [example.ts]
import { parseEther } from 'viem'
import { client } from './config'
 
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: {
      number: 69420n,
    },
    calls: [
      {
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
        to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
        value: parseEther('2'),
      },
      {
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      },
    ],
    stateOverrides: [{
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
      balance: parseEther('10'),
    }],
  }]
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

### Contract Calls

The `calls` property also accepts **Contract Calls**, and can be used via the `abi`, `functionName`, and `args` properties.

:::code-group

```ts twoslash [example.ts]
import { parseAbi, parseEther } from 'viem'
import { client } from './config'

const abi = parseAbi([
  'function approve(address, uint256) returns (bool)',
  'function transferFrom(address, address, uint256) returns (bool)',
])
 
const result = await client.simulateBlocks({ // [!code focus:99]
  blocks: [{
    calls: [
      {
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1')
      },
      {
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
        to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        abi,
        functionName: 'approve',
        args: [
          '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
          100n
        ],
      },
      {
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
        to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        abi,
        functionName: 'transferFrom',
        args: [
          '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
          '0x0000000000000000000000000000000000000000',
          100n
        ],
      },
    ],
  }]
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

## Return Value

`SimulateBlocksReturnType`

Simulation results.

## Parameters

### blocks

Blocks to simulate.

### blocks.calls

- **Type:** `TransactionRequest[]`

Calls to simulate. Each call can consist of transaction request properties.

```ts twoslash
import { client } from './config'
// ---cut---
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: {
      number: 69420n,
    },
    calls: [ // [!code focus]
      { // [!code focus]
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', // [!code focus]
        data: '0xdeadbeef', // [!code focus]
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
      }, // [!code focus]
      { // [!code focus]
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', // [!code focus]
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
        value: parseEther('1'), // [!code focus]
      }, // [!code focus]
    ], // [!code focus]
    stateOverrides: [{
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
      balance: parseEther('10'),
    }],
  }]
})
```

### blocks.blockOverrides

- **Type:** `BlockOverrides`

Values to override on the block.

```ts twoslash
import { client } from './config'
// ---cut---
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: { // [!code focus]
      number: 69420n, // [!code focus]
    }, // [!code focus]
    calls: [ 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        data: '0xdeadbeef', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
      }, 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        value: parseEther('1'), 
      }, 
    ], 
    stateOverrides: [{
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
      balance: parseEther('10'),
    }],
  }]
})
```

### blocks.stateOverrides

- **Type:** `StateOverride`

State overrides.

```ts twoslash
import { client } from './config'
// ---cut---
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: {
      number: 69420n,
    },
    calls: [ 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        data: '0xdeadbeef', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
      }, 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        value: parseEther('1'), 
      }, 
    ], 
    stateOverrides: [{ // [!code focus]
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', // [!code focus]
      balance: parseEther('10'), // [!code focus]
    }], // [!code focus]
  }]
})
```

### returnFullTransactions

- **Type:** `boolean`

Whether to return the full transactions.

```ts twoslash
import { client } from './config'
// ---cut---
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: {
      number: 69420n,
    },
    calls: [ 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        data: '0xdeadbeef', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
      }, 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        value: parseEther('1'), 
      }, 
    ], 
    stateOverrides: [{
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
      balance: parseEther('10'),
    }],
  }],
  returnFullTransactions: true, // [!code focus]
})
```

### traceTransfers

- **Type:** `boolean`

Whether to trace transfers.

```ts twoslash
import { client } from './config'
// ---cut---
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: {
      number: 69420n,
    },
    calls: [ 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        data: '0xdeadbeef', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
      }, 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        value: parseEther('1'), 
      }, 
    ], 
    stateOverrides: [{
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
      balance: parseEther('10'),
    }],
  }],
  traceTransfers: true, // [!code focus]
})
```

### validation

- **Type:** `boolean`

Whether to enable validation mode.

```ts twoslash
import { client } from './config'
// ---cut---
const result = await client.simulateBlocks({
  blocks: [{
    blockOverrides: {
      number: 69420n,
    },
    calls: [ 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        data: '0xdeadbeef', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
      }, 
      { 
        from: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', 
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        value: parseEther('1'), 
      }, 
    ], 
    stateOverrides: [{
      address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
      balance: parseEther('10'),
    }],
  }],
  validation: true, // [!code focus]
})
```
</file>

<file path="actions/public/simulateCalls.md">
---
description: Simulates a set of calls on block(s).
---

# simulateCalls

Simulates a set of calls for a block, and optionally provides asset changes. Internally uses the [`eth_simulateV1` JSON-RPC method](https://github.com/ethereum/execution-apis/pull/484).

## Usage

:::code-group

```ts twoslash [example.ts]
import { parseEther } from 'viem'
import { client } from './config'
 
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [
    {
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    },
  ],
})

console.log(results)
// @log: [
// @log:   {
// @log:     gasUsed: 21000n,
// @log:     logs: [],
// @log:     status: "success",
// @log:   },
// @log:   {
// @log:     gasUsed: 21000n,
// @log:     logs: [],
// @log:     status: "success",
// @log:   },
// @log: ]
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

### Contract Calls

The `calls` property also accepts **Contract Calls**, and can be used via the `abi`, `functionName`, and `args` properties.

:::code-group

```ts twoslash [example.ts]
import { parseAbi, parseEther } from 'viem'
import { client } from './config'

const abi = parseAbi([
  'function mint()',
  'function transfer(address, uint256) returns (bool)',
])
 
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1')
    },
    {
      to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
    },
    {
      to: '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE',
      abi,
      functionName: 'transfer',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        100n
      ],
    },
  ],
})

console.log(results)
// @log: [
// @log:   {
// @log:     gasUsed: 21000n,
// @log:     logs: [],
// @log:     result: undefined,
// @log:     status: "success",
// @log:   },
// @log:   {
// @log:     gasUsed: 78394n,
// @log:     logs: [...],
// @log:     result: undefined,
// @log:     status: "success",
// @log:   },
// @log:   {
// @log:     gasUsed: 51859n,
// @log:     logs: [...],
// @log:     result: true,
// @log:     status: "success",
// @log:   },
// @log: ]
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

### Asset Changes

Providing the `traceAssetChanges` parameter (with an `account`) will return asset balance changes for the calls.

:::code-group

```ts twoslash [example.ts]
import { parseAbi, parseEther } from 'viem'
import { client } from './config'

const abi = parseAbi([
  'function mint()',
  'function transfer(address, uint256) returns (bool)',
])
 
const { assetChanges, results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [
    {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1.5')
    },
    {
      to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'mint',
    },
    {
      to: '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE',
      abi,
      functionName: 'transfer',
      args: [
        '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        100n
      ],
    },
  ],
  traceAssetChanges: true, // [!code hl]
})

console.log(assetChanges)
// @log: [
// @log:   {
// @log:     token: {
// @log:       address: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
// @log:       decimals: 18,
// @log:       symbol: "ETH",
// @log:     },
// @log:     value: {
// @log:       diff: -1500000000000000000n,
// @log:       post: 9850000000000000000000n,
// @log:       pre: 10000000000000000000000n,
// @log:     },
// @log:   }
// @log:   {
// @log:     token: {
// @log:       address: "0xfba3912ca04dd458c843e2ee08967fc04f3579c2",
// @log:       decimals: 1,
// @log:       symbol: "WAGMI",
// @log:     },
// @log:     value: {
// @log:       diff: 1n,
// @log:       post: 1n,
// @log:       pre: 0n,
// @log:     },
// @log:   },
// @log:   {
// @log:     token: {
// @log:       address: "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
// @log:       decimals: 18,
// @log:       symbol: "SHIB",
// @log:     },
// @log:     value: {
// @log:       diff: -1000000000000000000n,
// @log:       post: 410429569258816445970930282571360n,
// @log:       pre: 410429569258817445970930282571360n,
// @log:     },
// @log:   }
// @log: ]
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

### Reading Contracts

It is also worth noting that `simulateCalls` also supports "reading" contracts. 

:::code-group

```ts twoslash [example.ts]
import { parseAbi } from 'viem'
import { client } from './config'

const abi = parseAbi([
  'function totalSupply() returns (uint256)',
  'function ownerOf(uint256) returns (address)',
])
 
const { results } = await client.simulateCalls({
  calls: [
    {
      to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'totalSupply',
    },
    {
      to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'ownerOf',
      args: [69420n],
    },
    {
      to: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi,
      functionName: 'ownerOf',
      args: [13371337n],
    },
  ],
})

console.log(results)
// @log: [
// @log:   {
// @log:     result: 424122n,
// @log:     status: "success",
// @log:   },
// @log:   {
// @log:     result: "0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b",
// @log:     status: "success",
// @log:   },
// @log:   {
// @log:     error: [ContractFunctionExecutionError: token has no owner],
// @log:     status: "failure",
// @log:   },
// @log: ]
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::


## Return Value

`SimulateCallsReturnType`

Simulation results.

## Parameters

### calls

- **Type:** `Calls`

Calls to simulate.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ // [!code focus]
    { // [!code focus]
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D', // [!code focus]
      value: parseEther('2'), // [!code focus]
    }, // [!code focus] 
    { // [!code focus]
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
      value: parseEther('1'), // [!code focus]
    }, // [!code focus]
  ], // [!code focus]
})
```

### calls.data

- **Type:** `Hex`

Calldata to broadcast (typically a contract function selector with encoded arguments, or contract deployment bytecode).

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      data: '0xdeadbeef', // [!code focus]
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D', 
      value: parseEther('2'), 
    },  
  ], 
})
```

### calls.to

- **Type:** `Address`

The recipient address.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D', // [!code focus]
      value: parseEther('2'),
    },  
  ], 
})
```

### calls.value

- **Type:** `Address`

Value to send with the call.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'), // [!code focus]
    },  
  ], 
})
```

### account (optional)

- **Type:** `Account | Address`

The account to simulate the calls from.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', // [!code focus]
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
})
```

### blockNumber (optional)

- **Type:** `bigint`

The block number to simulate the calls at.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  blockNumber: 17030000n, // [!code focus]
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
})
```

### blockTag (optional)

- **Type:** `BlockTag`

The block tag to simulate the calls at.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  blockTag: 'pending', // [!code focus]
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
})
```

### stateOverrides (optional)

- **Type:** `StateOverride`

The state overrides to simulate the calls with.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
  stateOverrides: [{ // [!code focus]
    address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929', // [!code focus]
    balance: parseEther('10000'), // [!code focus]
  }], // [!code focus]
})
```

### traceAssetChanges (optional)

- **Type:** `boolean`

Whether to trace asset changes.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
  traceAssetChanges: true, // [!code focus]
})
```

### traceTransfers (optional)

- **Type:** `boolean`

Whether to trace transfers.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
  traceTransfers: true, // [!code focus]
})
```

### validation (optional)

- **Type:** `boolean`

Whether to enable validation mode.

```ts twoslash
import { parseEther } from 'viem'
import { client } from './config'
// ---cut---
const { results } = await client.simulateCalls({
  account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
  calls: [ 
    { 
      to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
      value: parseEther('2'),
    },  
  ], 
  validation: true, // [!code focus]
})
```
</file>

<file path="actions/public/uninstallFilter.md">
---
description: Destroys a Filter.
---

# uninstallFilter

Destroys a [`Filter`](/docs/glossary/types#filter) that was created from one of the following Actions:

- [`createBlockFilter`](/docs/actions/public/createBlockFilter)
- [`createEventFilter`](/docs/actions/public/createEventFilter)
- [`createPendingTransactionFilter`](/docs/actions/public/createPendingTransactionFilter)

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const filter = await publicClient.createPendingTransactionFilter()
const uninstalled = await publicClient.uninstallFilter({ filter }) // [!code focus:99]
// true
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`boolean`

A boolean indicating if the Filter was successfully uninstalled.

## Parameters

### filter

- **Type:** [`Filter`](/docs/glossary/terms#filter)

A created filter.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const filter = await publicClient.createPendingTransactionFilter()
const uninstalled = await publicClient.uninstallFilter({
  filter, // [!code focus]
})
```

## JSON-RPC Method

[`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)
</file>

<file path="actions/public/verifyMessage.md">
---
description: Verifies if a signed message was generated by the provided address.
---

# verifyMessage

Verify that a message was signed by the provided address.

:::info
**Why should I use this over the [`verifyMessage`](/docs/utilities/verifyMessage) util?**

This Action supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account. The [`verifyMessage`](/docs/utilities/verifyMessage.md) util only supports Externally Owned Accounts. This is getting increasingly important as more wallets implement [Account Abstraction](https://eips.ethereum.org/EIPS/eip-4337). 
:::

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient, publicClient } from './client'

const signature = await walletClient.signMessage({
  account,
  message: 'hello world',
})
// [!code focus:99]
const valid = await publicClient.verifyMessage({
  address: account.address,
  message: 'hello world',
  signature,
})
// @log: true
```

```ts twoslash [client.ts] filename="client.ts"
import 'viem/window'
// ---cut---
import { createPublicClient, createWalletClient, custom, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

export const walletClient = createWalletClient({
  transport: custom(window.ethereum!)
})

// @log: ↓ JSON-RPC Account
export const [account] = await walletClient.getAddresses()

// @log: ↓ Local Account
// export const account = privateKeyToAccount(...)
```

:::

## Returns

`boolean`

Whether the signed message is valid for the given address.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The Ethereum address that signed the original message.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
  message: 'hello world',
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### message

- **Type:** `string`

The message to be verified.

By default, viem verifies the UTF-8 representation of the message.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world', // [!code focus:1]
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

To verify the data representation of the message, you can use the `raw` attribute.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus:1]
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature that was generated by signing the message with the address's signer.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: // [!code focus:2]
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', 
})
```

### blockNumber (optional)

- **Type:** `bigint`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyMessage({
  blockNumber: 42069n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyMessage({
  blockTag: 'safe', // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

## JSON-RPC Method

[`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) to a deployless [universal signature validator contract](https://eips.ethereum.org/EIPS/eip-6492).
</file>

<file path="actions/public/verifyTypedData.md">
---
description: Verifies a typed data signature
---

# verifyTypedData

Verify that typed data was signed by the provided address.

:::info 
**Why should I use this over the [`verifyTypedData`](/docs/utilities/verifyTypedData) util?**

This Action supports verifying typed data that was signed by either a Smart Contract Account or Externally Owned Account (via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492)). The [`verifyTypedData`](/docs/utilities/verifyTypedData) util only supports Externally Owned Accounts. This is getting increasingly important as more wallets implement [Account Abstraction](https://eips.ethereum.org/EIPS/eip-4337). 
:::

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient, publicClient } from './client'
import { domain, types } from './data'

const message = {
  from: {
    name: 'Cow',
    wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
  },
  to: {
    name: 'Bob',
    wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
  },
  contents: 'Hello, Bob!',
}

const signature = await walletClient.signTypedData({
  account,
  domain,
  types,
  primaryType: 'Mail',
  message,
})
// [!code focus:99]
const valid = await publicClient.verifyTypedData({
  address: account.address,
  domain,
  types,
  primaryType: 'Mail',
  message,
  signature,
})
// true
```

```ts twoslash [data.ts] filename="data.ts"
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```

```ts twoslash [client.ts] filename="client.ts"
import 'viem/window'
// ---cut---
import { createPublicClient, createWalletClient, custom, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

export const walletClient = createWalletClient({
  transport: custom(window.ethereum!)
})

// @log: ↓ JSON-RPC Account
export const [account] = await walletClient.getAddresses()

// @log: ↓ Local Account
// export const account = privateKeyToAccount(...)
```

:::

## Returns

`boolean`

Whether the signed message is valid for the given address.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The Ethereum address that signed the original message.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### domain

**Type:** `TypedDataDomain`

The typed data domain.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### types

The type definitions for the typed data.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### primaryType

**Type:** Inferred `string`.

The primary type to extract from `types` and use in `value`.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { 
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### message

**Type:** Inferred from `types` & `primaryType`.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature of the typed data.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `bigint`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  blockNumber: 42069n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const valid = await publicClient.verifyTypedData({
  blockNumber: 42069n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

## JSON-RPC Method

[`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) to a deployless [universal signature validator contract](https://eips.ethereum.org/EIPS/eip-6492).
</file>

<file path="actions/public/waitForTransactionReceipt.md">
---
description: Retrieves a Transaction Receipt for a given Transaction hash.
---

# waitForTransactionReceipt

Waits for the [Transaction](/docs/glossary/terms#transaction) to be included on a [Block](/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](/docs/glossary/terms#transaction-receipt).

The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).

## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const transaction = await publicClient.waitForTransactionReceipt( // [!code focus:99]
  { hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d' }
)
// @log: {
// @log:  blockHash: '0xaf1dadb8a98f1282e8f7b42cc3da8847bfa2cf4e227b8220403ae642e1173088',
// @log:  blockNumber: 15132008n,
// @log:  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
// @log:  ...
// @log:  status: 'success',
// @log: }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

[`TransactionReceipt`](/docs/glossary/types#transactionreceipt)

The transaction receipt.

## Parameters

### confirmations (optional)

- **Type:** `number`
- **Default:** `1`

The number of confirmations (blocks that have passed) to wait before resolving.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.waitForTransactionReceipt(
  { 
    confirmations: 5, // [!code focus:1]
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d' 
  }
)
```

### onReplaced (optional)

- **Type:** `({ reason: 'replaced' | 'repriced' | 'cancelled', replacedTransaction: Transaction, transaction: Transaction, transactionReceipt: TransactionReceipt }) => void`

Optional callback to emit if the transaction has been replaced.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.waitForTransactionReceipt(
  { 
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    onReplaced: replacement => console.log(replacement) // [!code focus:1]
  }
)
```

### pollingInterval (optional)

- **Type:** `number`

Polling frequency (in ms). Defaults to the Client's `pollingInterval` config.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.waitForTransactionReceipt(
  { 
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    pollingInterval: 12_000, // [!code focus:1]
  }
)
```

### retryCount (optional)

- **Type:** `number`
- **Default:** `6`

Number of times to retry if the transaction or block is not found.

```ts
const transaction = await publicClient.waitForTransactionReceipt(
  { 
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    retryCount: 3, // [!code focus:1]
  }
)
```

### retryDelay (optional)

- **Type:** `number | (({ count: number; error: Error }) => number)`
- **Default:** `({ count }) => ~~(1 << count) * 200` (exponential backoff)

Time to wait (in ms) between retries.

```ts
const transaction = await publicClient.waitForTransactionReceipt(
  { 
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    retryDelay: 10_000, // [!code focus:1]
  }
)
```

### timeout (optional)

- **Type:** `number`
- **Default:** `180_000`

Optional timeout (in milliseconds) to wait before stopping polling.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const transaction = await publicClient.waitForTransactionReceipt(
  { 
    hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    timeout: 60_000, // [!code focus:1]
  }
)
```

### Notes

- Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.
- There are 3 types of Transaction Replacement reasons:
  - `repriced`: The gas price has been modified (ie. different `maxFeePerGas`)
  - `cancelled`: The Transaction has been cancelled (ie. `value === 0n`)
  - `replaced`: The Transaction has been replaced (ie. different `value` or `data`)

## Live Example

Check out the usage of `waitForTransactionReceipt` in the live [Sending Transactions Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>


## JSON-RPC Methods

- Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.
- If a Transaction has been replaced:
  - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions
  - Checks if one of the Transactions is a replacement
  - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).
</file>

<file path="actions/public/watchBlockNumber.md">
---
description: Watches and returns incoming block numbers.
---

# watchBlockNumber

Watches and returns incoming block numbers.

## Usage

Pass through your Public Client, along with a listener.

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const unwatch = publicClient.watchBlockNumber( // [!code focus:99]
  { onBlockNumber: blockNumber => console.log(blockNumber) }
)
// @log: > 69420n
// @log: > 69421n
// @log: > 69422n
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Listener

`(blockNumber: bigint) => void`

The block number.

## Returns

`UnwatchFn`

A function that can be invoked to stop watching for new block numbers.

## Parameters

### emitMissed (optional)

- **Type:** `boolean`
- **Default:** `false`

Whether or not to emit missed block numbers to the callback. 

Missed block numbers may occur in instances where internet connection is lost, or the block time is lesser than the [polling interval](/docs/clients/public#pollinginterval-optional) of the client.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlockNumber(
  { 
    emitMissed: true, // [!code focus]
    onBlockNumber: blockNumber => console.log(blockNumber),
  }
)
```

### emitOnBegin (optional)

- **Type:** `boolean`
- **Default:** `false`

Whether or not to emit the latest block number to the callback when the subscription opens.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlockNumber(
  { 
    emitOnBegin: true, // [!code focus]
    onBlockNumber: blockNumber => console.log(blockNumber),
  }
)
```

### poll (optional)

- **Type:** `boolean`
- **Default:** `false` for WebSocket Transports, `true` for non-WebSocket Transports

Whether or not to use a polling mechanism to check for new block numbers instead of a WebSocket subscription.

This option is only configurable for Clients with a [WebSocket Transport](/docs/clients/transports/websocket).

```ts twoslash
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({
  chain: mainnet,
  transport: webSocket()
})

const unwatch = publicClient.watchBlockNumber(
  { 
    onBlockNumber: blockNumber => console.log(blockNumber),
    poll: true, // [!code focus]
  }
)
```

### pollingInterval (optional)

- **Type:** `number`

Polling frequency (in ms). Defaults to Client's `pollingInterval` config.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlockNumber(
  { 
    onBlockNumber: blockNumber => console.log(blockNumber),
    pollingInterval: 12_000, // [!code focus]
  }
)
```

## Example

Check out the usage of `watchBlockNumber` in the live [Watch Block Numbers Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Methods

- When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.
- When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
</file>

<file path="actions/public/watchBlocks.md">
---
description: Watches and returns information for incoming blocks.
---

# watchBlocks

Watches and returns information for incoming blocks.

## Usage

Pass through your Public Client, along with a listener.

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const unwatch = publicClient.watchBlocks( // [!code focus:99]
  { onBlock: block => console.log(block) }
)
// @log: > {
// @log:  baseFeePerGas: 10789405161n,
// @log:  difficulty: 11569232145203128n,
// @log:  extraData: '0x75732d656173742d38',
// @log:  ...
// @log: }

// @log: > {
// @log:  baseFeePerGas: 12394051511n,
// @log:  difficulty: 11512315412421123n,
// @log:  extraData: '0x5123ab1512dd14aa',
// @log:  ...
// @log: }
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`UnwatchFn`

A function that can be invoked to stop watching for new blocks.

## Parameters

### onBlock

- **Type:** `(block: Block) => void`

The block information.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { onBlock: block => console.log(block) } // [!code focus:1]
)
```

### onError (optional)

- **Type:** `(error: Error) => void`

Error thrown from getting a block.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { 
    onBlock: block => console.log(block),
    onError: error => console.log(error) // [!code focus:1]
  }
)
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Watch for new blocks on a given tag.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { 
    blockTag: 'safe',
    onBlock: block => console.log(block), // [!code focus]
  }
)
```

### emitMissed (optional)

- **Type:** `boolean`
- **Default:** `false`

Whether or not to emit missed blocks to the callback.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the [polling interval](/docs/clients/public#pollinginterval-optional) of the client.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { 
    emitMissed: true, // [!code focus]
    onBlock: block => console.log(block),
  }
)
```

### emitOnBegin (optional)

- **Type:** `boolean`
- **Default:** `false`

Whether or not to emit the block to the callback when the subscription opens.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { 
    emitOnBegin: true, // [!code focus]
    onBlock: block => console.log(block),
  }
)
```

### includeTransactions (optional)

- **Type:** `boolean`

Whether or not to include transactions (as a structured array of `Transaction` objects).

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { 
    includeTransactions: true,  // [!code focus]
    onBlock: block => console.log(block),
  }
)
```

### poll (optional)

- **Type:** `boolean`
- **Default:** `false` for WebSocket Clients, `true` for non-WebSocket Clients

Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.

This option is only configurable for Clients with a [WebSocket Transport](/docs/clients/transports/websocket).

```ts twoslash
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({
  chain: mainnet,
  transport: webSocket()
})

const unwatch = publicClient.watchBlocks(
  { 
    onBlock: block => console.log(block),
    poll: true, // [!code focus]
  }
)
```

### pollingInterval (optional)

- **Type:** `number`

Polling frequency (in ms). Defaults to the Client's `pollingInterval` config.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchBlocks(
  { 
    onBlock: block => console.log(block),
    pollingInterval: 1_000, // [!code focus]
  }
)
```

## Example

Check out the usage of `watchBlocks` in the live [Watch Blocks Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Methods

- When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.
- When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
</file>

<file path="actions/public/watchEvent.md">
---
description: Watches and returns emitted Event Logs.
---

# watchEvent

Watches and returns emitted [Event Logs](/docs/glossary/terms#event-log).

This Action will batch up all the Event Logs found within the [`pollingInterval`](#pollinginterval-optional), and invoke them via [`onLogs`](#onlogs).

`watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (ie. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](/docs/actions/public/getLogs) instead.

## Usage

By default, you can watch all broadcasted events to the blockchain by just passing `onLogs`.

These events will be batched up into [Event Logs](/docs/glossary/terms#event-log) and sent to `onLogs`:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const unwatch = publicClient.watchEvent({
  onLogs: logs => console.log(logs)
})
// @log: > [{ ... }, { ... }, { ... }]
// @log: > [{ ... }, { ... }]
// @log: > [{ ... }, { ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Scoping

You can also scope `watchEvent` to a set of given attributes (listed below).

### Address

`watchEvent` can be scoped to an **address**:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const unwatch = publicClient.watchEvent({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // [!code focus]
  onLogs: logs => console.log(logs)
})
// @log: > [{ ... }, { ... }, { ... }]
// @log: > [{ ... }, { ... }]
// @log: > [{ ... }, { ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Event

`watchEvent` can be scoped to an **event**.

The `event` argument takes in an event in ABI format – we have a [`parseAbiItem` utility](/docs/abi/parseAbiItem) that you can use to convert from a human-readable event signature → ABI.

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem' // [!code focus]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const unwatch = publicClient.watchEvent({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'), // [!code focus]
  onLogs: logs => console.log(logs)
})
// @log: > [{ ... }, { ... }, { ... }]
// @log: > [{ ... }, { ... }]
// @log: > [{ ... }, { ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

By default, `event` accepts the [`AbiEvent`](/docs/glossary/types#abievent) type:

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const unwatch = publicClient.watchEvent(publicClient, {
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: { // [!code focus:8]
    name: 'Transfer', 
    inputs: [
      { type: 'address', indexed: true, name: 'from' },
      { type: 'address', indexed: true, name: 'to' },
      { type: 'uint256', indexed: false, name: 'value' }
    ] 
  },
  onLogs: logs => console.log(logs)
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Arguments

`watchEvent` can be scoped to given **_indexed_ arguments** on the event:

:::code-group

```ts twoslash [example.ts]
import { parseAbiItem } from 'viem'
import { publicClient } from './client'

const unwatch = publicClient.watchEvent({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  onLogs: logs => console.log(logs)
})
// > [{ ... }, { ... }, { ... }]
// > [{ ... }, { ... }]
// > [{ ... }, { ... }, { ... }, { ... }]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

Only indexed arguments in `event` are candidates for `args`.

These arguments can also be an array to indicate that other values can exist in the position:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const unwatch = publicClient.watchEvent({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: { // [!code focus:8]
    // '0xd8da...' OR '0xa5cc...' OR '0xa152...'
    from: [
      '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
      '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',
      '0xa152f8bb749c55e9943a3a0a3111d18ee2b3f94e',
    ],
  },
  onLogs: logs => console.log(logs)
})
```

### Multiple Events

`watchEvent` can be scoped to **multiple events**:

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbi } from 'viem'

const unwatch = publicClient.watchEvent({
  events: parseAbi([ // [!code focus:5]
    'event Approval(address indexed owner, address indexed sender, uint256 value)',
    'event Transfer(address indexed from, address indexed to, uint256 value)',
  ]),
  onLogs: logs => console.log(logs)
})
```

Note: `watchEvent` scoped to multiple events cannot be also scoped with [indexed arguments](#arguments) (`args`).

## Returns

`UnwatchFn`

A function that can be invoked to stop watching for new Event Logs.

## Parameters

### onLogs

- **Type:** `(logs: Log[]) => void`

The new Event Logs.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchEvent(
  { onLogs: logs => console.log(logs) } // [!code focus:1]
)
```

### address (optional)

- **Type:** `Address | Address[]`

The contract address or a list of addresses from which Logs should originate.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchEvent(
  { 
    address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', // [!code focus]
    onLogs: logs => console.log(logs) 
  }
)
```

### event (optional)

- **Type:** [`AbiEvent`](/docs/glossary/types#abievent)

The event in ABI format.

A [`parseAbiItem` utility](/docs/abi/parseAbiItem) is exported from viem that converts from a human-readable event signature → ABI.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem' // [!code focus]

const unwatch = publicClient.watchEvent(
  { 
    address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
    event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'), // [!code focus]
    onLogs: logs => console.log(logs) 
  }
)
```

### args (optional)

- **Type:** Inferred.

A list of _indexed_ event arguments.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
import { parseAbiItem } from 'viem'

const unwatch = publicClient.watchEvent(
  { 
    address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
    event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
    args: { // [!code focus:4]
      from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
      to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
    },
    onLogs: logs => console.log(logs) 
  }
)
```

### batch (optional)

- **Type:** `boolean`
- **Default:** `true`

Whether or not to batch the Event Logs between polling intervals.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchEvent(
  { 
    batch: false, // [!code focus]
    onLogs: logs => console.log(logs),
  }
)
```

### onError (optional)

- **Type:** `(error: Error) => void`

Error thrown from listening for new Event Logs.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchEvent(
  { 
    onError: error => console.log(error), // [!code focus:1]
    onLogs: logs => console.log(logs),
  }
)
```

### poll (optional)

- **Type:** `boolean`
- **Default:** `false` for WebSocket Clients, `true` for non-WebSocket Clients

Whether or not to use a polling mechanism to check for new logs instead of a WebSocket subscription.

This option is only configurable for Clients with a [WebSocket Transport](/docs/clients/transports/websocket).

```ts twoslash
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({
  chain: mainnet,
  transport: webSocket()
})

const unwatch = publicClient.watchEvent(
  { 
    onLogs: logs => console.log(logs),
    poll: true, // [!code focus]
  }
)
```

### pollingInterval (optional)

- **Type:** `number`

Polling frequency (in ms). Defaults to the Client's `pollingInterval` config.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchEvent(
  { 
    pollingInterval: 1_000, // [!code focus]
    onLogs: logs => console.log(logs),
  }
)
```

### fromBlock (optional)

- **Type:** `bigint`

The block number to start listening for logs from.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchEvent(
  { 
    fromBlock: 1n, // [!code focus]
    onLogs: logs => console.log(logs),
  }
)
```

## Live Example

Check out the usage of `watchEvent` in the live [Event Logs Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Methods

**When poll `true` and RPC Provider supports `eth_newFilter`:**

- Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).
- On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).

**When poll `true` RPC Provider does not support `eth_newFilter`:**

- Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.

**When poll `false` and WebSocket Transport:**

- Uses a WebSocket subscription via `eth_subscribe` and the "logs" event.
</file>

<file path="actions/public/watchPendingTransactions.md">
---
description: Watches and returns pending transaction hashes.
---

# watchPendingTransactions

Watches and returns pending transaction hashes.

This Action will batch up all the pending transactions found within the [`pollingInterval`](#pollinginterval-optional), and invoke them via [`onTransactions`](#ontransactions).


## Usage

:::code-group

```ts twoslash [example.ts]
import { publicClient } from './client'

const unwatch = publicClient.watchPendingTransactions( // [!code focus:99]
  { onTransactions: hashes => console.log(hashes) }
)
// @log: > ['0x...', '0x...', '0x...']
// @log: > ['0x...', '0x...']
// @log: > ['0x...', '0x...', '0x...', ...]
```

```ts twoslash [client.ts] filename="client.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`UnwatchFn`

A function that can be invoked to stop watching for new pending transaction hashes.

## Parameters

### onTransactions

- **Type:** `(hashes: '0x${string}'[]) => void`

The new pending transaction hashes.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchPendingTransactions(
  { onTransactions: hashes => console.log(hashes) } // [!code focus:1]
)
```

### batch (optional)

- **Type:** `boolean`
- **Default:** `true`

Whether or not to batch the transaction hashes between polling intervals.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const unwatch = publicClient.watchPendingTransactions(
  { 
    batch: false, // [!code focus]
    onTransactions: hashes => console.log(hashes),
  }
)
```

### onError (optional)

- **Type:** `(error: Error) => void`

Error thrown from listening for new pending transactions.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
// @noErrors
const unwatch = publicClient.watchPendingTransactions(
  { 
    onError: error => console.log(error), // [!code focus:1]
    onTransactions: hashes => console.log(hashes),
  }
)
```

### poll (optional)

- **Type:** `boolean`
- **Default:** `false` for WebSocket Clients, `true` for non-WebSocket Clients

Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.

This option is only configurable for Clients with a [WebSocket Transport](/docs/clients/transports/websocket).

```ts twoslash
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({
  chain: mainnet,
  transport: webSocket()
})

const unwatch = publicClient.watchPendingTransactions(
  { 
    onTransactions: transactions => console.log(transactions),
    poll: true, // [!code focus]
  }
)
```

### pollingInterval (optional)

- **Type:** `number`

Polling frequency (in ms). Defaults to the Client's `pollingInterval` config.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
// @noErrors
const unwatch = publicClient.watchPendingTransactions(
  { 
    pollingInterval: 1_000, // [!code focus]
    onTransactions: hashes => console.log(hashes),
  }
)
```

## JSON-RPC Methods

- When `poll: true`
  - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.
  - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.
- When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event.
</file>

<file path="actions/wallet/addChain.md">
---
description: Adds an EVM chain to the wallet.
---

# addChain

Adds an EVM chain to the wallet.

## Usage

:::code-group

```ts twoslash [example.ts]
import { avalanche } from 'viem/chains'
import { walletClient } from './client'
 
await walletClient.addChain({ chain: avalanche }) // [!code focus]
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::

## Parameters

### chain

- **Type:** [`Chain`](/docs/glossary/types#chain)

The chain to add to the wallet.

## JSON-RPC Methods

[`wallet_addEtherereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
</file>

<file path="actions/wallet/getAddresses.md">
---
description: Returns a list of addresses owned by the wallet or client.
---

# getAddresses

Returns a list of account addresses owned by the wallet or client.

## Usage

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const accounts = await walletClient.getAddresses() // [!code focus:99]
// ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::

## Returns

[`Address[]`](/docs/glossary/types#address)

A list of checksummed addresses.


## JSON-RPC Methods

[`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
</file>

<file path="actions/wallet/getPermissions.md">
---
description: Gets the wallets current permissions.
---

# getPermissions

Gets the wallets current permissions.

## Usage

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const permissions = await walletClient.getPermissions() // [!code focus:99]
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::

## Returns

[`WalletPermission[]`](/docs/glossary/types#walletpermission)

The wallet permissions.

## JSON-RPC Methods

[`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
</file>

<file path="actions/wallet/introduction.md">
# Introduction to Wallet Actions [A brief introduction to Wallet Actions in viem.]

Wallet Actions are actions that map one-to-one with a "wallet" or "signable" Ethereum RPC method (`eth_requestAccounts`, `eth_sendTransaction`, etc). They are used with a [Wallet Client](/docs/clients/wallet).

Wallet Actions require special permissions and provide signing capabilities. Examples of Wallet Actions include [retrieving the user's account addresses](/docs/actions/wallet/getAddresses), [sending a transaction](/docs/actions/wallet/sendTransaction), and [signing a message](/docs/actions/wallet/signMessage).

Wallet Actions provide a secure and flexible way to access the user's accounts and perform actions on the Ethereum network. They are commonly used by dapps and other applications that need to execute transactions, interact with smart contracts, or sign messages.
</file>

<file path="actions/wallet/prepareTransactionRequest.md">
---
description: Prepares a transaction request for signing.
---

# prepareTransactionRequest

Prepares a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient } from './config'
 
const request = await walletClient.prepareTransactionRequest({ // [!code focus:16]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
// @log: {
// @log:   account: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
// @log:   to: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
// @log:   maxFeePerGas: 150000000000n,
// @log:   maxPriorityFeePerGas: 1000000000n,
// @log:   nonce: 69,
// @log:   type: 'eip1559',
// @log:   value: 1000000000000000000n
// @log: }


const serializedTransaction = await walletClient.signTransaction(request)
const hash = await walletClient.sendRawTransaction({ serializedTransaction })
```

```ts twoslash [config.ts] filename="config.ts"
import 'viem/window'
// ---cut---
import { createWalletClient, custom } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})

// @log: ↓ JSON-RPC Account
export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'

// @log: ↓ Local Account
// export const account = privateKeyToAccount(...)
```

:::

### Account Hoisting

If you do not wish to pass an `account` to every `prepareTransactionRequest`, you can also hoist the Account on the Wallet Client (see `config.ts`).

[Learn more](/docs/clients/wallet#account).

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
 
const request = await walletClient.prepareTransactionRequest({ // [!code focus:16]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
// @log: {
// @log:   account: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
// @log:   to: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
// @log:   maxFeePerGas: 150000000000n,
// @log:   maxPriorityFeePerGas: 1000000000n,
// @log:   nonce: 69,
// @log:   type: 'eip1559',
// @log:   value: 1000000000000000000n
// @log: }


const serializedTransaction = await walletClient.signTransaction(request)
const hash = await walletClient.sendRawTransaction({ serializedTransaction })
```

```ts [config.ts (JSON-RPC Account)]
import { createWalletClient, custom } from 'viem'

// Retrieve Account from an EIP-1193 Provider.
const [account] = await window.ethereum.request({ 
  method: 'eth_requestAccounts' 
})

export const walletClient = createWalletClient({
  account,
  transport: custom(window.ethereum!)
})
```

```ts twoslash [config.ts (Local Account)] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  transport: http()
})
```

:::

## Returns

[`TransactionRequest`](/docs/glossary/types#transactionrequest)

The transaction request.

## Parameters

### account

- **Type:** `Account | Address`

The Account to send the transaction from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### to

- **Type:** `0x${string}`

The transaction recipient or contract address.

```ts twoslash
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
  value: 1000000000000000000n,
  nonce: 69
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts twoslash
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### authorizationList (optional)

- **Type:** `AuthorizationList`

Signed EIP-7702 Authorization list.

```ts twoslash
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: http(),
})
// ---cut---
const authorization = await walletClient.signAuthorization({ 
  account,
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
}) 

const request = await walletClient.prepareTransactionRequest({
  account,
  authorizationList: [authorization], // [!code focus]
  data: '0xdeadbeef',
  to: account.address,
})
```

:::note
**References**
- [EIP-7702 Overview](/docs/eip7702)
- [`signAuthorization` Docs](/docs/eip7702/signAuthorization)
:::

### blobs (optional)

- **Type:** `Hex[]`

Blobs for [Blob Transactions](/docs/guides/blob-transactions). 

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) 

const request = await walletClient.prepareTransactionRequest({
  account,
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### chain (optional)

- **Type:** [`Chain`](/docs/glossary/types#chain)
- **Default:** `walletClient.chain`

The target chain. If there is a mismatch between the wallet's current chain & the target chain, an error will be thrown.

The chain is also used to infer its request type (e.g. the Celo chain has a `gatewayFee` that you can pass through to `prepareTransactionRequest`).

```ts twoslash
// [!include config.ts]
// ---cut---
import { optimism } from 'viem/chains' // [!code focus]

const request = await walletClient.prepareTransactionRequest({
  chain: optimism, // [!code focus]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### data (optional)

- **Type:** `0x${string}`

A contract hashed method call with encoded args.

```ts twoslash
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
// [!include config.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const request = await walletClient.prepareTransactionRequest({
  account,
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') 
})
```

### kzg (optional)

- **Type:** `KZG`

KZG implementation for [Blob Transactions](/docs/guides/blob-transactions). 

See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]

const request = await walletClient.prepareTransactionRequest({
  account,
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include config.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const request = await walletClient.prepareTransactionRequest({
  account,
  maxFeePerGas: parseGwei('20'),  // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include config.ts]
// ---cut---
import { parseEther, parseGwei } from 'viem'

const request = await walletClient.prepareTransactionRequest({
  account,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts twoslash
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n,
  nonce: 69 // [!code focus]
})
```

### nonceManager (optional)

- **Type:** `NonceManager | undefined`

Nonce Manager to consume and increment the Account nonce for the transaction request.

```ts twoslash
// @noErrors
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n,
  nonceManager: account.nonceManager // [!code focus]
})
```

### parameters (optional)

- **Type:** `("fees" | "gas" | "nonce" | "type")[]`
- **Default:** `["fees", "gas", "nonce", "type"]`

Parameters to prepare. 

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

```ts twoslash
// [!include config.ts]
// ---cut---
const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n,
  nonce: 69 // [!code focus]
})
```

### value (optional)

- **Type:** `bigint`

Value in wei sent with this transaction.

```ts twoslash
// [!include config.ts]
// ---cut---
import { parseEther } from 'viem'

const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
  nonce: 69
})
```
</file>

<file path="actions/wallet/requestAddresses.md">
---
description: Requests a list of accounts managed by a wallet.
---

# requestAddresses

Requests a list of accounts managed by a wallet.

`requestAddresses` sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).

This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.

## Usage

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const accounts = await walletClient.requestAddresses() // [!code focus:99]
// ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::

## Returns

[`Address[]`](/docs/glossary/types#address)

## JSON-RPC Methods

[`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)
</file>

<file path="actions/wallet/requestPermissions.md">
---
description: Requests permissions for a wallet.
---

# requestPermissions

Requests permissions for a wallet.

## Usage

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const permissions = await walletClient.requestPermissions({ eth_accounts: {} }) // [!code focus:99]
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::

## Returns

[`WalletPermission[]`](/docs/glossary/types#walletpermission)

The wallet permissions.

## JSON-RPC Methods

[`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
</file>

<file path="actions/wallet/sendRawTransaction.md">
---
description: Sends a signed transaction to the network
---

# sendRawTransaction

Sends a **signed** transaction to the network. Can be used with both [Public Clients](/docs/clients/public) and [Wallet Clients](/docs/clients/wallet)

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient } from './config'
 
const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})

const serializedTransaction = await walletClient.signTransaction(request)

const hash = await walletClient.sendRawTransaction({ serializedTransaction }) // [!code focus]
```

```ts twoslash [config.ts] filename="config.ts"
// [!include ~/snippets/walletClient.ts]

export const [account] = await walletClient.getAddresses()
// @log: ↑ JSON-RPC Account

// export const account = privateKeyToAccount(...)
// @log: ↑ Local Account
```

:::

## Returns

[`Hash`](/docs/glossary/types#hash)

The [Transaction](/docs/glossary/terms#transaction) hash.

## Parameters

### serializedTransaction

- **Type:** `Hex`

The signed serialized transaction.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.sendRawTransaction({
  serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' // [!code focus]
})
```
</file>

<file path="actions/wallet/sendTransaction.md">
---
description: Creates, signs, and sends a new transaction to the network.
---

# sendTransaction

Creates, signs, and sends a new transaction to the network.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient } from './config'
 
const hash = await walletClient.sendTransaction({ // [!code focus:99]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
// '0x...'
```

```ts twoslash [config.ts] filename="config.ts"
// [!include ~/snippets/walletClient.ts]

export const [account] = await walletClient.getAddresses()
// @log: ↑ JSON-RPC Account

// export const account = privateKeyToAccount(...)
// @log: ↑ Local Account
```

:::

### Account Hoisting

If you do not wish to pass an `account` to every `sendTransaction`, you can also hoist the Account on the Wallet Client (see `config.ts`).

[Learn more](/docs/clients/wallet#account).

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
 
const hash = await walletClient.sendTransaction({ // [!code focus:99]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
// '0x...'
```

```ts [config.ts (JSON-RPC Account)]
import { createWalletClient, custom } from 'viem'

// Retrieve Account from an EIP-1193 Provider.
const [account] = await window.ethereum.request({ 
  method: 'eth_requestAccounts' 
})

export const walletClient = createWalletClient({
  account,
  transport: custom(window.ethereum!)
})
```

```ts twoslash [config.ts (Local Account)] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  transport: http()
})
```

:::

## Returns

[`Hash`](/docs/glossary/types#hash)

The [Transaction](/docs/glossary/terms#transaction) hash.

## Parameters

### account

- **Type:** `Account | Address | null`

The Account to send the transaction from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc). If set to `null`, it is assumed that the transport will handle filling the sender of the transaction.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### to

- **Type:** `0x${string}`

The transaction recipient or contract address.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
  value: 1000000000000000000n,
  nonce: 69
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### authorizationList (optional)

- **Type:** `AuthorizationList`

Signed EIP-7702 Authorization list.

```ts twoslash
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: http(),
})
// ---cut---
const authorization = await walletClient.signAuthorization({ 
  account,
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
}) 

const hash = await walletClient.sendTransaction({
  account,
  authorizationList: [authorization], // [!code focus]
  data: '0xdeadbeef',
  to: account.address,
})
```

:::note
**References**
- [EIP-7702 Overview](/docs/eip7702)
- [`signAuthorization` Docs](/docs/eip7702/signAuthorization)
:::

### blobs (optional)

- **Type:** `Hex[]`

Blobs for [Blob Transactions](/docs/guides/blob-transactions). 

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) 

const hash = await walletClient.sendTransaction({
  account,
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### chain (optional)

- **Type:** [`Chain`](/docs/glossary/types#chain)
- **Default:** `walletClient.chain`

The target chain. If there is a mismatch between the wallet's current chain & the target chain, an error will be thrown.

The chain is also used to infer its request type (e.g. the Celo chain has a `gatewayFee` that you can pass through to `sendTransaction`).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
import { optimism } from 'viem/chains' // [!code focus]

const hash = await walletClient.sendTransaction({
  chain: optimism, // [!code focus]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### data (optional)

- **Type:** `0x${string}`

A contract hashed method call with encoded args.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account,
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') 
})
```

### kzg (optional)

- **Type:** `KZG`

KZG implementation for [Blob Transactions](/docs/guides/blob-transactions). 

See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]

const hash = await walletClient.sendTransaction({
  account,
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account,
  maxFeePerGas: parseGwei('20'),  // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n,
  nonce: 69 // [!code focus]
})
```

### value (optional)

- **Type:** `bigint`

Value in wei sent with this transaction.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const hash = await walletClient.sendTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
  nonce: 69
})
```

## Tips

- For dapps: When using this action, it is assumed that the user has connected to their wallet (e.g. given permission for the dapp to access their accounts via [`requestAddresses`](/docs/actions/wallet/requestAddresses)). You can also check if the user has granted access to their accounts via [`getAddresses`](/docs/actions/wallet/getAddresses)

## Live Example

Check out the usage of `sendTransaction` in the live [Sending Transactions Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Methods

- JSON-RPC Accounts:
  - [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
- Local Accounts:
  - [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)
</file>

<file path="actions/wallet/signMessage.md">
---
description: Signs a message with the Account's private key.
---

# signMessage

Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.

With the calculated signature, you can:
- use [`verifyMessage`](/docs/utilities/verifyMessage) to verify the signature,
- use [`recoverMessageAddress`](/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient } from './config'
 
const signature_1 = await walletClient.signMessage({ // [!code focus:99]
  account,
  message: 'hello world',
})
// @log: Output: "0xa461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b"

const signature_2 = await walletClient.signMessage({
  account,
  // Hex data representation of message.
  message: { raw: '0x68656c6c6f20776f726c64' },
})
// @log: Output: "0xa461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b"
```

```ts twoslash [config.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]

export const [account] = await walletClient.getAddresses()
// @log: ↑ JSON-RPC Account

// export const account = privateKeyToAccount(...)
// @log: ↑ Local Account
```

:::

### Account Hoisting

If you do not wish to pass an `account` to every `signMessage`, you can also hoist the Account on the Wallet Client (see `config.ts`).

[Learn more](/docs/clients/wallet#withaccount).

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
 
const signature = await walletClient.signMessage({ // [!code focus:99]
  message: 'hello world',
})
// @log: "0xa461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b"
```

```ts [config.ts (JSON-RPC Account)]
import { createWalletClient, custom } from 'viem'

// Retrieve Account from an EIP-1193 Provider.
const [account] = await window.ethereum.request({ 
  method: 'eth_requestAccounts' 
})

export const walletClient = createWalletClient({
  account,
  transport: custom(window.ethereum!)
})
```

```ts twoslash [config.ts (Local Account)] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  transport: http()
})
```

:::

## Returns

[`Hex`](/docs/glossary/types#hex)

The signed message.

## Parameters

### account

- **Type:** `Account | Address`

Account to use for signing.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signMessage({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
  message: 'hello world',
})
```

### message

- **Type:** `string | { raw: Hex | ByteArray }`

Message to sign.

By default, viem signs the UTF-8 representation of the message.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signMessage({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world', // [!code focus:1]
})
```

To sign the data representation of the message, you can use the `raw` attribute.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signMessage({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus:1]
})
```

## JSON-RPC Methods

- JSON-RPC Accounts:
  - [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)
- Local Accounts
  - Signs locally. No JSON-RPC request.
</file>

<file path="actions/wallet/signTransaction.md">
---
description: Signs a transaction.
---

# signTransaction

Signs a transaction.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient } from './config'
 
const request = await walletClient.prepareTransactionRequest({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})

const signature = await walletClient.signTransaction(request) // [!code focus:2]
// 0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33

const hash = await walletClient.sendRawTransaction(signature)
```

```ts twoslash [config.ts] filename="config.ts"
// [!include ~/snippets/walletClient.ts]

export const [account] = await walletClient.getAddresses()
// @log: ↑ JSON-RPC Account

// export const account = privateKeyToAccount(...)
// @log: ↑ Local Account
```

:::

### Account Hoisting

If you do not wish to pass an `account` to every `prepareTransactionRequest`, you can also hoist the Account on the Wallet Client (see `config.ts`).

[Learn more](/docs/clients/wallet#account).

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
 
const request = await walletClient.prepareTransactionRequest({
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})

const signature = await walletClient.signTransaction(request) // [!code focus:2]
// 0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33

const hash = await walletClient.sendRawTransaction(signature)
```

```ts [config.ts (JSON-RPC Account)]
import { createWalletClient, custom } from 'viem'

// Retrieve Account from an EIP-1193 Provider.
const [account] = await window.ethereum.request({ 
  method: 'eth_requestAccounts' 
})

export const walletClient = createWalletClient({
  account,
  transport: custom(window.ethereum!)
})
```

```ts twoslash [config.ts (Local Account)] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  transport: http()
})
```

:::

## Returns

[`Hex`](/docs/glossary/types#hex)

The signed serialized transaction.

## Parameters

### account

- **Type:** `Account | Address`

The Account to send the transaction from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### to

- **Type:** `0x${string}`

The transaction recipient or contract address.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]
  value: 1000000000000000000n,
  nonce: 69
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  accessList: [ // [!code focus:6]
    {
      address: '0x1',
      storageKeys: ['0x1'],
    },
  ],
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
})
```

### authorizationList (optional)

- **Type:** `AuthorizationList`

Signed EIP-7702 Authorization list.

```ts twoslash
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: http(),
})
// ---cut---
const authorization = await walletClient.signAuthorization({ 
  account,
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
}) 

const signature = await walletClient.signTransaction({
  account,
  authorizationList: [authorization], // [!code focus]
  data: '0xdeadbeef',
  to: account.address,
})
```

:::note
**References**
- [EIP-7702 Overview](/docs/eip7702)
- [`signAuthorization` Docs](/docs/eip7702/signAuthorization)
:::

### blobs (optional)

- **Type:** `Hex[]`

Blobs for [Blob Transactions](/docs/guides/blob-transactions). 

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) 

const hash = await walletClient.signTransaction({
  account,
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```

### chain (optional)

- **Type:** [`Chain`](/docs/glossary/types#chain)
- **Default:** `walletClient.chain`

The target chain. If there is a mismatch between the wallet's current chain & the target chain, an error will be thrown.

The chain is also used to infer its request type (e.g. the Celo chain has a `gatewayFee` that you can pass through to `signTransaction`).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
import { optimism } from 'viem/chains' // [!code focus]

const signature = await walletClient.signTransaction({
  chain: optimism, // [!code focus]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### data (optional)

- **Type:** `0x${string}`

A contract hashed method call with encoded args.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account,
  gasPrice: parseGwei('20'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1') 
})
```

### kzg (optional)

- **Type:** `KZG`

KZG implementation for [Blob Transactions](/docs/guides/blob-transactions). 

See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts
import * as cKzg from 'c-kzg'
import { toBlobs, setupKzg, stringToHex } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]

const signature = await walletClient.signTransaction({
  account,
  blobs: toBlobs({ data: stringToHex('blobby blob!') }), // [!code focus]
  kzg, // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
})
```


### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account,
  maxFeePerGas: parseGwei('20'),  // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n,
  nonce: 69 // [!code focus]
})
```

### value (optional)

- **Type:** `bigint`

Value in wei sent with this transaction.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
// @noErrors
const signature = await walletClient.signTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1'), // [!code focus]
  nonce: 69
})
```
</file>

<file path="actions/wallet/signTypedData.md">
---
description: Signs typed data with the Account's private key.
---

# signTypedData

Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message)))`

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient } from './config'
import { domain, types } from './data'

const signature = await walletClient.signTypedData({
  account,
  domain,
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

```ts twoslash [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
 
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```

```ts twoslash [config.ts] filename="config.ts"
// [!include ~/snippets/walletClient.ts]

export const [account] = await walletClient.getAddresses()
// @log: ↑ JSON-RPC Account

// export const account = privateKeyToAccount(...)
// @log: ↑ Local Account
```

:::

### Account Hoisting

If you do not wish to pass an `account` to every `signTypedData`, you can also hoist the Account on the Wallet Client (see `config.ts`).

[Learn more](/docs/clients/wallet#withaccount).

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
import { domain, types } from './data'

const signature = await walletClient.signTypedData({
  domain,
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

```ts twoslash [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
 
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```

```ts [config.ts (JSON-RPC Account)]
import { createWalletClient, custom } from 'viem'

// Retrieve Account from an EIP-1193 Provider.
const [account] = await window.ethereum.request({ 
  method: 'eth_requestAccounts' 
})

export const walletClient = createWalletClient({
  account,
  transport: custom(window.ethereum!)
})
```

```ts twoslash [config.ts (Local Account)] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  transport: http()
})
```

:::

## Returns

`0x${string}`

The signed data.

## Parameters

### account

- **Type:** `Account | Address`

The Account to use for signing.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signTypedData({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### domain

**Type:** `TypedDataDomain`

The typed data domain.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signTypedData({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### types

The type definitions for the typed data.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signTypedData({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { 
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### primaryType

**Type:** Inferred `string`.

The primary type to extract from `types` and use in `value`.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signTypedData({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { 
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### message

**Type:** Inferred from `types` & `primaryType`.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const signature = await walletClient.signTypedData({
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { 
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', 
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

## Live Example

Check out the usage of `signTypedData` in the live [Sign Typed Data Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/signing_typed-data) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/signing_typed-data?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>

## JSON-RPC Methods

- JSON-RPC Accounts:
  - [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)
- Local Accounts
  - Signs locally. No JSON-RPC request.
</file>

<file path="actions/wallet/switchChain.md">
---
description: Switch the target chain in a wallet.
---

# switchChain

Switch the target chain in a wallet.

## Usage

:::code-group

```ts twoslash [example.ts]
import { avalanche } from 'viem/chains'
import { walletClient } from './client'
 
await walletClient.switchChain({ id: avalanche.id }) // [!code focus]
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::


## Parameters

### id

- **Type:** `number`

The Chain ID.

## JSON-RPC Methods

[`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)
</file>

<file path="actions/wallet/watchAsset.md">
---
description: Requests that the user tracks the token in their wallet.
---

# watchAsset

Requests that the user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

## Usage

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const success = await walletClient.watchAsset({ // [!code focus:99]
  type: 'ERC20',
  options: {
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    decimals: 18,
    symbol: 'WETH',
  },
})
```

```ts twoslash [client.ts] filename="client.ts"
// [!include ~/snippets/walletClient.ts]
```

:::

## Returns

`boolean`

Boolean indicating if the token was successfully added.

## Parameters

### type

- **Type:** `string`

Token type.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut--
const success = await walletClient.watchAsset({
  type: 'ERC20', // [!code focus]
  options: {
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    decimals: 18,
    symbol: 'WETH',
  },
});
```

### options.address

- **Type:** [`Address`](/docs/glossary/types#address)

The address of the token contract.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const success = await walletClient.watchAsset({
  type: 'ERC20',
  options: {
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // [!code focus]
    decimals: 18,
    symbol: 'WETH',
  },
});
```

### options.decimals

- **Type:** `number`

The number of token decimals.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const success = await walletClient.watchAsset({
  type: 'ERC20',
  options: {
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    decimals: 18, // [!code focus]
    symbol: 'WETH',
  },
});
```

### options.symbol

- **Type:** `string`

A ticker symbol or shorthand, up to 11 characters.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const success = await walletClient.watchAsset({
  type: 'ERC20',
  options: {
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    decimals: 18,
    symbol: 'WETH', // [!code focus]
  }
})
```

### options.image

- **Type:** `string`

A string url of the token logo.

```ts twoslash
// [!include ~/snippets/walletClient.ts]
// ---cut---
const success = await walletClient.watchAsset({
  type: 'ERC20',
  options: {
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    decimals: 18,
    symbol: 'WETH',
    image: 'https://weth.com/icon.png', // [!code focus]
  }
})
```

## JSON-RPC Methods

[`wallet_watchAsset`](https://eips.ethereum.org/EIPS/eip-747)
</file>

<file path="chains/celo.md">
# Celo [Integrating with Celo in Viem]

Viem provides first-class support for chains implemented on [Celo](https://celo.org/).

## Chains

The following Viem chains are implemented on Celo:

```ts
import {
  celo, // [!code hl]
  celoAlfajores, // [!code hl]
} from 'viem/chains'
```

### Configuration

Viem exports Celo's chain [formatters](/docs/chains/formatters) & [serializers](/docs/chains/serializers) via `chainConfig`. This is useful if you need to define another chain which is implemented on Celo.

```ts
import { defineChain } from 'viem'
import { chainConfig } from 'viem/celo'

export const celoExample = defineChain({
  ...chainConfig,
  name: 'Celo Example',
  // ...
})
```

## Utilities

### `parseTransaction`

Parses a serialized RLP-encoded transaction. Supports signed & unsigned CIP-64, EIP-1559, EIP-2930 and Legacy Transactions.

Celo-flavored version of [Viem's `parseTransaction`](/docs/utilities/parseTransaction).

#### Parameters

- `serializedTransaction` (`Hex`): The serialized transaction.

```ts
import { parseTransaction } from 'viem/celo'

const transaction = parseTransaction('0x7cf84682a4ec80847735940084773594008094765de816845861e75a25fca122bb6898b8b1282a808094f39fd6e51aad88f6f4ce6ab8827279cfffb92266880de0b6b3a764000080c0')
```

### `serializeTransaction`

Serializes a transaction object. Supports CIP-64, EIP-1559, EIP-2930, and Legacy transactions.

Celo-flavored version of [Viem's `serializeTransaction`](/docs/utilities/serializeTransaction).

#### Parameters

- `transaction` (`TransactionSerializable`): The transaction object to serialize.
- `signature` (`Signature`): Optional signature to include.

```ts
import { serializeTransaction } from 'viem/celo'

const serialized = serializeTransaction({
  chainId: 42220,
  gas: 21001n,
  feeCurrency: "0x2F25deB3848C207fc8E0c34035B3Ba7fC157602B" // whitelisted adapter for USDC
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  to: '0x1234512345123451234512345123451234512345',
  value: parseEther('0.01'),
})
```
</file>

<file path="chains/fees.md">
# Fees [Configure chain-based fee data in Viem]

You can modify how fees are derived by using the `fees` property on the Chain.

## Usage

```tsx
import { defineChain } from 'viem'

export const example = defineChain({
  /* ... */
  fees: { 
    baseFeeMultiplier: 1.2, 
    defaultPriorityFee: parseGwei('0.01'), 
  } 
})
```

## API

### `fees.baseFeeMultiplier`

- **Type**: `number`
- **Default**: `1.2`

The fee multiplier to use to account for fee fluctuations. Used in the [`estimateFeesPerGas` Action](/docs/actions/public/estimateFeesPerGas) against the latest block's base fee per gas to derive a final `maxFeePerGas` (EIP-1193), or gas price to derive a final `gasPrice` (Legacy).

**Parameters**

- `block`: The latest block.
- `client`: The Client instance.
- `request`: The transaction request (if exists).

```ts
import { defineChain } from 'viem'

const example = defineChain({ 
  /* ... */
  fees: { // [!code focus:8]
    baseFeeMultiplier: 1.2,
    // or
    async baseFeeMultiplier({ block, request }) {
      // some async work
      return // ...
    },
  },
})
```

### `fees.defaultPriorityFee`

- **Type**: `number | ((args: FeesFnParameters) => Promise<bigint> | bigint)`

The default `maxPriorityFeePerGas` to use when a priority fee is not defined upon sending a transaction.

Also overrides the return value in the [`estimateMaxPriorityFeePerGas` Action](/docs/actions/public/estimateMaxPriorityFeePerGas) and `maxPriorityFeePerGas` value in [`estimateFeesPerGas`](/docs/actions/public/estimateFeesPerGas).

**Parameters**

- `block`: The latest block.
- `client`: The Client instance.
- `request`: The transaction request (if exists).

```ts
import { defineChain } from 'viem'

const example = defineChain({
  /* ... */
  fees: { // [!code focus:8]
    defaultPriorityFee: parseGwei('0.01'),
    // or
    async defaultPriorityFee({ block, request }) {
      // some async work
      return // ...
    },
  },
})
```

### `fees.estimateFeesPerGas`

- **Type**: `(args: FeesFnParameters) => Promise<EstimateFeesPerGasResponse>`

Allows customization of fee per gas values (ie. `maxFeePerGas`, `maxPriorityFeePerGas`, `gasPrice`).

Also overrides the return value in [`estimateFeesPerGas`](/docs/actions/public/estimateFeesPerGas).

**Parameters**

- `block`: The latest block.
- `client`: The Client instance.
- `multiply`: A function to apply the `baseFeeMultiplier` to the provided value.
- `request`: The transaction request (if exists).
- `type`: The transaction type (ie. `legacy` or `eip1559`).

```ts
import { defineChain } from 'viem'

const example = defineChain({
  /* ... */
  fees: { // [!code focus:13]
    async estimateFeesPerGas({ client, multiply, type }) {
      const gasPrice = // ...
      const baseFeePerGas = // ...
      const maxPriorityFeePerGas = // ...

      if (type === 'legacy') return { gasPrice: multiply(gasPrice) }
      return {
        maxFeePerGas: multiply(baseFeePerGas) + maxPriorityFeePerGas,
        maxPriorityFeePerGas
      },
    },
  },
})
```
</file>

<file path="chains/formatters.md">
# Formatters [Configure chain-based formatters in Viem]

You can modify how Blocks & Transactions are formatted by using the `formatters` property on the Chain.

This is useful for chains that have a different Block or Transaction structure than Mainnet (e.g. Celo & OP Stack chains).

## Usage

```tsx
import { 
  defineBlock,
  defineChain,
  defineTransaction, 
  defineTransactionReceipt, 
  defineTransactionRequest 
} from 'viem' 

export const example = defineChain({
  /* ... */
  formatters: { 
    block: defineBlock(/* ... */),
    transaction: defineTransaction(/* ... */),
    transactionReceipt: defineTransactionReceipt(/* ... */),
    transactionRequest: defineTransactionRequest(/* ... */),
  } 
})
```

## API

### `formatters.block`

You can modify how Blocks are formatted by using the `formatters.block` property on the Chain.

You can either pass in the Block overrides, or the whole Block itself to the `format` function of `defineBlock`. You can also exclude certain properties with `exclude`.

```ts
import { defineBlock, defineChain, hexToBigInt } from 'viem'

type RpcBlockOverrides = { // [!code focus:6]
  secondaryFee: `0x${string}`
}
type BlockOverrides = {
  secondaryFee: bigint
}

const example = defineChain({
  /* ... */
  formatters: { // [!code focus:10]
    block: defineBlock({
      exclude: ['difficulty'],
      format(args: RpcBlockOverrides): BlockOverrides {
        return {
          secondaryFee: hexToBigInt(args.secondaryFee)
        }
      },
    }),
  },
})

const block = await client.getBlock() // [!code focus:2]
//    ^? { ..., difficulty: never, secondaryFee: bigint, ... }
```

### `formatters.transaction`

You can modify how Transactions are formatted by using the `formatters.transaction` property on the Chain.

You can either pass in the Transaction overrides, or the whole Transaction itself to the `format` function of `defineTransaction`. You can also exclude certain properties with `exclude`.

```ts
import { defineTransaction, defineChain, hexToBigInt } from 'viem'

type RpcTransactionOverrides = { // [!code focus:6]
  mint: `0x${string}`
}
type TransactionOverrides = {
  mint: bigint
}

const example = defineChain({
  /* ... */
  formatters: { // [!code focus:10]
    transaction: defineTransaction({
      exclude: ['gasPrice'],
      format(args: RpcTransactionOverrides): TransactionOverrides {
        return {
          mint: hexToBigInt(args.mint)
        }
      },
    }),
  },
})

const transaction = await client.getTransaction({ hash: '0x...' }) // [!code focus:2]
//    ^? { ..., gasPrice: never, mint: bigint, ... }
```

### `formatters.transactionReceipt`

You can modify how Transaction Receipts are formatted by using the `formatters.transactionReceipt` property on the Chain.

You can either pass in the Transaction Receipt overrides, or the whole Transaction Receipt itself to the `format` function of `defineTransactionReceipt`. You can also exclude certain properties with `exclude`.

```ts
import { defineTransactionReceipt, defineChain, hexToBigInt } from 'viem'

type RpcTransactionReceiptOverrides = { // [!code focus:6]
  l1Fee: `0x${string}`
}
type TransactionReceiptOverrides = {
  l1Fee: bigint
}

const example = defineChain({
  /* ... */
  formatters: { // [!code focus:11]
    transactionReceipt: defineTransactionReceipt({
      exclude: ['effectiveGasPrice'],
      format(args: RpcTransactionReceiptOverrides): 
        TransactionReceiptOverrides {
        return {
          l1Fee: hexToBigInt(args.l1Fee)
        }
      },
    }),
  },
})

const receipt = await client.getTransactionReceipt({ hash: '0x...' }) // [!code focus:2]
//    ^? { ..., effectiveGasPrice: never, l1Fee: bigint, ... }
```

### `formatters.transactionRequest`

You can modify how Transaction Requests are formatted by using the `formatters.transactionRequest` property on the Chain.

You can either pass in the Transaction Request overrides, or the whole Transaction Request itself to the `format` function of `defineTransactionRequest`. You can also exclude certain properties with `exclude`.

```ts
import { defineTransactionRequest, defineChain, hexToBigInt } from 'viem'

type RpcTransactionRequestOverrides = { // [!code focus:6]
  secondaryFee: `0x${string}`
}
type TransactionRequestOverrides = {
  secondaryFee: bigint
}

const example = defineChain({
  /* ... */
  formatters: { // [!code focus:11]
    transactionRequest: defineTransactionRequest({
      exclude: ['effectiveGasPrice'],
      format(args: TransactionRequestOverrides): 
        RpcTransactionRequestOverrides {
        return {
          secondaryFee: numberToHex(args.secondaryFee)
        }
      },
    }),
  },
})

const receipt = await client.getTransactionReceipt({ hash: '0x...' }) // [!code focus:2]
//    ^? { ..., effectiveGasPrice: never, l1Fee: bigint, ... }
```
</file>

<file path="chains/introduction.md">
# Chains

The `viem/chains` entrypoint contains references to popular EVM-compatible chains such as: Polygon, Optimism, Avalanche, Base, Zora, and more.

## Usage

Import your chain from the entrypoint and use them in the consuming viem code:

```tsx
import { createPublicClient, http } from 'viem'
import { zora } from 'viem/chains' // [!code focus]

const client = createPublicClient({
  chain: zora, // [!code focus]
  transport: http()
})
```

[See here for a list of supported chains](https://github.com/wagmi-dev/viem/tree/main/src/chains/index.ts).

> Want to add a chain that's not listed in viem? Read the [Contributing Guide](https://github.com/wagmi-dev/viem/blob/main/.github/CONTRIBUTING.md#chains), and then open a Pull Request with your chain.

## Custom Chains

You can also extend viem to support other EVM-compatible chains by building your own chain object that inherits the `Chain` type.

```ts
import { defineChain } from 'viem'

export const zora = defineChain({
  id: 7777777,
  name: 'Zora',
  nativeCurrency: {
    decimals: 18,
    name: 'Ether',
    symbol: 'ETH',
  },
  rpcUrls: {
    default: {
      http: ['https://rpc.zora.energy'],
      webSocket: ['wss://rpc.zora.energy'],
    },
  },
  blockExplorers: {
    default: { name: 'Explorer', url: 'https://explorer.zora.energy' },
  },
  contracts: {
    multicall3: {
      address: '0xcA11bde05977b3631167028862bE2a173976CA11',
      blockCreated: 5882,
    },
  },
})
```
</file>

<file path="chains/serializers.md">
# Serializers [Configure chain-based serializers in Viem]

## Usage

```ts
import { defineChain, serializeTransaction } from 'viem'

const example = defineChain({
  /* ... */
  serializers: {
    transaction(transaction, signature) {
      return serializeTransaction(transaction, signature)
    },
  },
})
```

## API

### `serializers.transaction`

- **Type**: `(transaction: Transaction, signature?: Signature) => "0x${string}"`

You can modify how Transactions are serialized by using the `serializers.transaction` property on the Chain.

**Parameters**

- `transaction`: The transaction to serialize.
- `signature`: The transaction signature (if exists).

```ts
import { defineChain, serializeTransaction } from 'viem'

const example = defineChain({
  /* ... */
  serializers: { // [!code focus:5]
    transaction(transaction, signature) {
      return serializeTransaction(transaction, signature)
    },
  },
})
```
</file>

<file path="chains/zksync.md">
# ZKsync [Integrating with ZKsync in Viem]

Viem provides first-class support for chains implemented on [ZKsync](https://zksync.io/).

## Chains

The following Viem chains are implemented on ZKsync:

```ts
import {
  zksync, // [!code hl]
  zksyncSepoliaTestnet, // [!code hl]
} from 'viem/chains'
```

### Configuration

Viem exports ZKsync's chain [formatters](/docs/chains/formatters) & [serializers](/docs/chains/serializers) via `chainConfig`. This is useful if you need to define another chain which is implemented on ZKsync.

```ts
import { defineChain } from 'viem'
import { chainConfig } from 'viem/zksync'

export const zkSyncExample = defineChain({
  ...chainConfig,
  name: 'ZKsync Example',
  // ...
})
```

## Utilities

### `serializeTransaction`

Serializes a transaction object. Supports EIP-712, EIP-1559, EIP-2930, and Legacy transactions.

ZKsync-flavored version of [Viem's `serializeTransaction`](/docs/utilities/serializeTransaction).

#### Parameters

- `transaction` (`TransactionSerializable`): The transaction object to serialize.
- `signature` (`Signature`): Optional signature to include.

```ts
import { serializeTransaction } from 'viem/zksync'

const serialized = serializeTransaction({
  chainId: 1,
  gas: 21001n,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  paymaster: '0x4B5DF730c2e6b28E17013A1485E5d9BC41Efe021',
  paymasterInput:
    '0x8c5a344500000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000',
  to: '0x1234512345123451234512345123451234512345',
  type: 'eip712',
  value: parseEther('0.01'),
})
```
</file>

<file path="clients/transports/custom.md">
# Custom Transport [A function to create a Custom Transport for a Client]

The `custom` Transport accepts an [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request-1) as a parameter. This transport is useful for integrating with injected wallets, wallets that provide an EIP-1193 provider (eg. WalletConnect or Coinbase SDK), or even providing your own custom `request` function.

## Import

```ts twoslash
import { custom } from 'viem'
```

## Usage

You can use any [EIP-1193 compatible](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider with the `custom` Transport:

```ts twoslash
import 'viem/window'
// ---cut---
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})
```

Or you can define your own:

```ts twoslash
// @noErrors
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'
import { customRpc } from './rpc'

const client = createWalletClient({ 
  chain: mainnet,
  transport: custom({
    async request({ method, params }) {
      const response = await customRpc.request(method, params)
      return response
    }
  })
})
```

## Parameters

### provider

- **Type:** `custom`

An [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request) function.

```ts twoslash
// @noErrors
import { custom } from 'viem'
// ---cut---
import { customRpc } from './rpc'

const transport = custom({
  async request({ method, params }) { // [!code focus:3]
    const response = await customRpc.request(method, params)
    return response
  }
})
```

### key (optional)

- **Type:** `string`
- **Default:** `"custom"`

A key for the Transport.

```ts twoslash
import 'viem/window'
import { custom } from 'viem'
// ---cut---
const transport = custom(
  window.ethereum!,
  { 
    key: 'windowProvider', // [!code focus]
  }
)
```

### name (optional)

- **Type:** `string`
- **Default:** `"Ethereum Provider"`

A name for the Transport

```ts twoslash
import 'viem/window'
import { custom } from 'viem'
// ---cut---
const transport = custom(
  window.ethereum!,
  { 
    name: 'Window Ethereum Provider', // [!code focus]
  }
)
```

### retryCount (optional)

- **Type:** `number`
- **Default:** `3`

The max number of times to retry when a request fails.

```ts twoslash
import 'viem/window'
import { custom } from 'viem'
// ---cut---
const transport = custom(window.ethereum!, {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

- **Type:** `number`
- **Default:** `150`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts twoslash
import 'viem/window'
import { custom } from 'viem'
// ---cut---
const transport = custom(window.ethereum!, {
  retryDelay: 100, // [!code focus]
})
```

## Gotchas

- If you are pairing the `custom` Transport with a [Public Client](/docs/clients/public), ensure that your provider supports [Public Actions](/docs/actions/public/introduction).
</file>

<file path="clients/transports/fallback.md">
# Fallback Transport [A function to create a Fallback Transport for a Client]

The `fallback` Transport consumes **multiple** Transports. If a Transport request fails, it will fall back to the next one in the list.

## Import

```ts twoslash
import { fallback } from 'viem'
```

## Usage

```ts twoslash 
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: fallback([ // [!code focus]
    http('https://1.rpc.thirdweb.com/...'), // [!code focus]
    http('https://mainnet.infura.io/v3/...') // [!code focus]
  ]), // [!code focus]
})
```

### Transport Ranking

Transport Ranking enables each of the Transports passed to the `fallback` Transport are automatically ranked based on their **latency** & **stability** via a weighted moving score algorithm. 

Every 10 seconds (`interval`), the `fallback` Transport will ping each transport in the list. For the past 10 pings (`sampleCount`), they will be ranked based on if they responded (stability) and how fast they responded (latency). The algorithm applies a weight of `0.7` to the stability score, and a weight of `0.3` to the latency score to derive the final score which it is ranked on. 

The Transport that has the best latency & stability score over the sample period is prioritized first. 

You can turn on automated ranking with the `rank` option:

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createPublicClient({
  chain: mainnet,
  transport: fallback([ 
    http('https://1.rpc.thirdweb.com/...'), 
    http('https://mainnet.infura.io/v3/...') 
  ], { rank: true }), // [!code focus]
})
```

You can also modify the default rank config:

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createPublicClient({
  chain: mainnet,
  transport: fallback(
    [
      http('https://1.rpc.thirdweb.com/...'), 
      http('https://mainnet.infura.io/v3/...') 
    ],
    { // [!code focus:9]
      rank: {
        interval: 60_000,
        sampleCount: 5,
        timeout: 500,
        weights: {
          latency: 0.3,
          stability: 0.7
        }
      }
    }
  ),
})
```

## Parameters

### rank (optional)

- **Type:** `boolean | RankOptions`
- **Default:** `false`

Whether or not to automatically rank the Transports based on their latency & stability. Set to `false` to disable automatic ranking.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: false, // [!code focus]
})
```

### rank.interval (optional)

- **Type:** `number`
- **Default:** `client.pollingInterval`

The polling interval (in ms) at which the ranker should ping the RPC URL.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: { // [!code focus:3]
    interval: 5_000
  },
})
```

### rank.ping (optional)

- **Type:** `({ transport }: { transport: Transport }) => Promise<unknown>`
- **Default:** `({ transport }) => transport.request({ method: 'net_listening' })`

Function to call to ping the Transport. Defaults to calling the `net_listening` method to check if the Transport is online.

```ts twoslash
// @noErrors
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: { // [!code focus:3]
    ping: ({ transport }) => transport.request({ method: 'eth_blockNumber' })
  },
})
```

### rank.sampleCount (optional)

- **Type:** `number`
- **Default:** `10`

The number of previous samples to perform ranking on.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: { // [!code focus:3]
    sampleCount: 10
  },
})
```

### rank.timeout (optional)

- **Type:** `number`
- **Default:** `1_000`

Timeout when sampling transports.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: { // [!code focus:3]
    timeout: 500
  },
})
```

### rank.weights.latency (optional)

- **Type:** `number`
- **Default:** `0.3`

The weight to apply to the latency score. The weight is proportional to the other values in the `weights` object.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: {
    weights: {
      latency: 0.4, // [!code focus:3]
      stability: 0.6
    }
  },
})
```

### rank.weights.stability (optional)

- **Type:** `number`
- **Default:** `0.7`

The weight to apply to the stability score. The weight is proportional to the other values in the `weights` object.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  rank: {
    weights: {
      latency: 0.4,
      stability: 0.6 // [!code focus:3]
    }
  },
})
```

### retryCount (optional)

- **Type:** `number`
- **Default:** `3`

The max number of times to retry when a request fails. 

> Note: The fallback will first try all the Transports before retrying.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

- **Type:** `number`
- **Default:** `150`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  retryDelay: 100, // [!code focus]
})
```

### shouldThrow (optional)

- **Type:** `function`

Whether the `fallback` Transport should immediately throw an error, or continue and try the next Transport.

```ts twoslash
import { createPublicClient, fallback, http } from 'viem'
import { mainnet } from 'viem/chains'
const thirdweb = http('') 
const infura = http('') 
// ---cut---
const transport = fallback([thirdweb, infura], {
  shouldThrow: (err: Error) => { // [!code focus]
    return err.message.includes('sad times') // [!code focus]
  }, // [!code focus]
})
```
</file>

<file path="clients/transports/http.md">
# HTTP Transport [A function to create a HTTP Transport for a Client]

The `http` Transport connects to a JSON-RPC API via HTTP.

## Import

```ts twoslash
import { http } from 'viem'
```

## Usage

```ts twoslash {4}
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http('https://1.rpc.thirdweb.com/...'), // [!code focus]
})
```

:::warning[Warning]
If no `url` is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.
:::

### Batch JSON-RPC

The `http` Transport supports Batch JSON-RPC. This means that multiple JSON-RPC requests can be sent in a single HTTP request.

The Transport will batch up Actions over a given period and execute them in a single Batch JSON-RPC HTTP request. By default, this period is a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays) meaning that the batch request will be executed at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue). Consumers can specify a custom time period `wait` (in ms).

You can enable Batch JSON-RPC by setting the `batch` flag to `true`:

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  batch: true // [!code focus]
})
```

Now when you invoke Actions, the `http` Transport will batch and send over those requests at the end of the message queue (or custom time period) in a single Batch JSON-RPC HTTP request:

```ts twoslash
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http('https://1.rpc.thirdweb.com/...'), 
})
// ---cut---
// The below will send a single Batch JSON-RPC HTTP request to the RPC Provider.
const [blockNumber, balance, ensName] = await Promise.all([
  client.getBlockNumber(),
  client.getBalance({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B' }),
  client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B' }),
])
```

## Parameters

### url (optional)

- **Type:** `string`
- **Default:** `chain.rpcUrls.default.http[0]`

URL of the JSON-RPC API.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...')
```

### batch (optional)

- **Type:** `boolean | BatchOptions`
- **Default:** `false`

Toggle to enable Batch JSON-RPC

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  batch: true // [!code focus]
})
```

### batch.batchSize (optional)

- **Type:** `number`
- **Default:** `1_000`

The maximum number of JSON-RPC requests to send in a batch.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  batch: {
    batchSize: 2_000 // [!code focus]
  }
})
```

### batch.wait (optional)

- **Type:** `number`
- **Default:** `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays))

The maximum number of milliseconds to wait before sending a batch.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  batch: {
    wait: 16 // [!code focus]
  }
})
```

### fetchOptions (optional)

- **Type:** [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)

[Fetch options](https://developer.mozilla.org/en-US/docs/Web/API/fetch) to pass to the internal `fetch` function. Useful for passing auth headers or cache options.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  fetchOptions: { // [!code focus:5]
    headers: {
      'Authorization': 'Bearer ...'
    }
  }
})
```

### key (optional)

- **Type:** `string`
- **Default:** `"http"`

A key for the Transport.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  key: 'alchemy', // [!code focus]
})
```

### methods (optional)

- **Type:** `{ include?: string[], exclude?: string[] }`

Methods to include or exclude from sending RPC requests.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  methods: {
    include: ['eth_sendTransaction', 'eth_signTypedData_v4'],
  },
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"HTTP JSON-RPC"`

A name for the Transport

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  name: 'Alchemy HTTP Provider', // [!code focus]
})
```

### onFetchRequest (optional)

- **Type:** `(request: Request) => void`

A callback to handle the fetch request. Useful for logging or debugging.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  onFetchRequest(request) {
    console.log(request) // [!code focus]
  }
})
```

### onFetchResponse (optional)

- **Type:** `(response: Response) => void`

A callback to handle the fetch response. Useful for logging or debugging.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  onFetchResponse(response) {
    console.log(response) // [!code focus]
  }
})
```

### retryCount (optional)

- **Type:** `number`
- **Default:** `3`

The max number of times to retry when a request fails.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

- **Type:** `number`
- **Default:** `150`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  retryDelay: 100, // [!code focus]
})
```

### timeout (optional)

- **Type:** `number`
- **Default:** `10_000`

The timeout for requests.

```ts twoslash
import { http } from 'viem'
// ---cut---
const transport = http('https://1.rpc.thirdweb.com/...', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="clients/transports/ipc.md">
# IPC Transport [A function to create an IPC Transport for a Client]

The `ipc` Transport connects to a JSON-RPC API via IPC (inter-process communication).

## Import

```ts twoslash
import { ipc } from 'viem/node'
```

## Usage

```ts twoslash
import { createPublicClient } from 'viem'
import { ipc } from 'viem/node'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet, 
  transport: ipc('/tmp/reth.ipc'), // [!code hl]
})
```

## Parameters

### path

- **Type:** `string`

IPC Path the transport should connect to.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc')
```

### key (optional)

- **Type:** `string`
- **Default:** `"ipc"`

A key for the Transport.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', { 
  key: 'reth-ipc',  // [!code focus]
})
```

### methods (optional)

- **Type:** `{ include?: string[], exclude?: string[] }`

Methods to include or exclude from sending RPC requests.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  methods: {
    include: ['eth_sendTransaction', 'eth_signTypedData_v4'],
  },
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"IPC JSON-RPC"`

A name for the Transport

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', { 
  name: 'Reth IPC',  // [!code focus]
})
```

### reconnect (optional)

- **Type:** `boolean | { maxAttempts?: number, delay?: number }`
- **Default:** `true`

Whether or not to attempt to reconnect on socket failure.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  reconnect: false, // [!code focus]
})
```

#### reconnect.attempts (optional)

- **Type:** `number`
- **Default:** `5`

The max number of times to attempt to reconnect.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  reconnect: {
    attempts: 10, // [!code focus]
  }
})
```

#### reconnect.delay (optional)

- **Type:** `number`
- **Default:** `2_000`

Retry delay (in ms) between reconnect attempts.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  reconnect: {
    delay: 1_000, // [!code focus]
  }
})
```

### retryCount (optional)

- **Type:** `number`
- **Default:** `3`

The max number of times to retry when a request fails.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

- **Type:** `number`
- **Default:** `150`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  retryDelay: 100, // [!code focus]
})
```

### timeout (optional)

- **Type:** `number`
- **Default:** `10_000`

The timeout for async IPC requests.

```ts twoslash
import { ipc } from 'viem/node'
// ---cut---
const transport = ipc('/tmp/reth.ipc', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="clients/transports/websocket.md">
# WebSocket Transport [A function to create a WebSocket Transport for a Client]

The `webSocket` Transport connects to a JSON-RPC API via a WebSocket.

## Import

```ts twoslash
import { webSocket } from 'viem'
```

## Usage

```ts twoslash {4}
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet, 
  transport: webSocket('wss://1.rpc.thirdweb.com/...'), // [!code focus]
})
```

:::warning[Warning]
If no `url` is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.
:::

## Parameters

### url

- **Type:** `string`

URL of the JSON-RPC API.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...')
```

### keepAlive (optional)

- **Type:** `boolean | { interval?: number }`
- **Default:** `true`

Whether or not to send keep-alive ping messages.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  keepAlive: { interval: 1_000 }, // [!code focus]
})
```

### key (optional)

- **Type:** `string`
- **Default:** `"webSocket"`

A key for the Transport.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', { 
  key: 'alchemy',  // [!code focus]
})
```

### methods (optional)

- **Type:** `{ include?: string[], exclude?: string[] }`

Methods to include or exclude from sending RPC requests.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  methods: {
    include: ['eth_sendTransaction', 'eth_signTypedData_v4'],
  },
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"WebSocket JSON-RPC"`

A name for the Transport

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', { 
  name: 'Alchemy WebSocket Provider',  // [!code focus]
})
```

### reconnect (optional)

- **Type:** `boolean | { maxAttempts?: number, delay?: number }`
- **Default:** `true`

Whether or not to attempt to reconnect on socket failure.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  reconnect: false, // [!code focus]
})
```

#### reconnect.attempts (optional)

- **Type:** `number`
- **Default:** `5`

The max number of times to attempt to reconnect.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  reconnect: {
    attempts: 10, // [!code focus]
  }
})
```

#### reconnect.delay (optional)

- **Type:** `number`
- **Default:** `2_000`

Retry delay (in ms) between reconnect attempts.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  reconnect: {
    delay: 1_000, // [!code focus]
  }
})
```

### retryCount (optional)

- **Type:** `number`
- **Default:** `3`

The max number of times to retry when a request fails.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  retryCount: 5, // [!code focus]
})
```

### retryDelay (optional)

- **Type:** `number`
- **Default:** `150`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  retryDelay: 100, // [!code focus]
})
```

### timeout (optional)

- **Type:** `number`
- **Default:** `10_000`

The timeout for async WebSocket requests.

```ts twoslash
import { webSocket } from 'viem'
// ---cut---
const transport = webSocket('wss://1.rpc.thirdweb.com/...', {
  timeout: 60_000, // [!code focus]
})
```
</file>

<file path="clients/custom.md">
# Build your own Client

You can build your own viem Client by using the `createClient` function and optionally extending (`.extend`) it – this is how viem's internal Clients ([Public](/docs/clients/public), [Wallet](/docs/clients/wallet), and [Test](/docs/clients/test)) are built.

Building your own Client is useful if you have specific requirements for how the Client should behave, and if you want to extend that Client with custom functionality (ie. create a [geth Debug](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-debug) Client).

The `createClient` function sets up a base viem Client with a given [Transport](/docs/clients/intro) configured with a [Chain](/docs/chains/introduction). After that, you can extend the Client with custom properties (that could be Actions or other configuration).

## Import

```ts twoslash
import { createClient } from 'viem'
```

## Usage

Initialize a Client with your desired [Chain](/docs/chains/introduction) (e.g. `mainnet`) and [Transport](/docs/clients/intro) (e.g. `http`).

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createClient({ 
  chain: mainnet,
  transport: http()
})
```

Next, you can either [extend your Client with Actions or configuration](#extending-with-actions-or-configuration), or you can use it as-is for the purpose of [maximizing tree-shaking in your app](#tree-shaking).

### Extending with Actions or configuration

You can extend your Client with custom Actions or configuration by using the `.extend` function.

Below is a naive implementation of implementing a [geth Debug](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-debug) Client with a `traceCall` Action that uses the `debug_traceCall` RPC method.

```ts twoslash {12-21,23-29}
// @noErrors
import { 
  createClient, 
  http,
  formatTransactionRequest,
  type CallParameters
} from 'viem'
import { mainnet } from 'viem/chains'

const debugClient = createClient({ 
  chain: mainnet,
  transport: http(),
}).extend(client => ({
  // ...
  async traceCall(args: CallParameters) {
    return client.request({
      method: 'debug_traceCall',
      params: [formatTransactionRequest(args), 'latest', {}]
    })
  },
  // ...
}))

const response = await debugClient.traceCall({
  account: '0xdeadbeef29292929192939494959594933929292',
  to: '0xde929f939d939d393f939393f93939f393929023',
  gas: 69420n,
  data: '0xf00d4b5d00000000000000000000000001291230982139282304923482304912923823920000000000000000000000001293123098123928310239129839291010293810'
})
// { failed: false, gas: 69420, returnValue: '...', structLogs: [] }
```

For a more succinct implementation of using `.extend`, check out viem's [Public Client implementation](https://github.com/wagmi-dev/viem/blob/29c053f5069a5b44e3791972c221368a2c71a254/src/clients/createPublicClient.ts#L48-L68) extended with [Public Actions](https://github.com/wagmi-dev/viem/blob/29c053f5069a5b44e3791972c221368a2c71a254/src/clients/decorators/public.ts#L1377-L1425).

### Tree-shaking

You can use the Client as-is, with no decorated Actions, to maximize tree-shaking in your app. This is useful if you are pedantic about bundle size and want to only include the Actions you use.

In the example below, instead of calling `getBlock` from the Public Client, we are importing the Action directly from `viem` and then injecting our Client as the first parameter to the Action.

```ts twoslash {3,10-11}
// @noErrors
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { getBlock, sendTransaction } from 'viem/actions'

const client = createClient({ 
  chain: mainnet,
  transport: http()
})

const blockNumber = await getBlock(client, { blockTag: 'latest' })
const hash = await sendTransaction(client, { ... })
```

## Parameters

### transport

- **Type:** [Transport](/docs/glossary/types#transport)

The [Transport](/docs/clients/intro) of the Public Client.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  chain: mainnet,
  transport: http(), // [!code focus]
})
```

### account (optional)

- **Type:** `Account | Address`

The Account to use for the Client. This will be used for Actions that require an `account` as an argument.

Accepts a [JSON-RPC Account](/docs/accounts/jsonRpc) or [Local Account (Private Key, etc)](/docs/accounts/local/privateKeyToAccount).

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
import { privateKeyToAccount } from 'viem/accounts'

const client = createClient({
  account: privateKeyToAccount('0x...'), // [!code focus]
  chain: mainnet,
  transport: http(),
})
```

### chain (optional)

- **Type:** [Chain](/docs/glossary/types#chain)

The [Chain](/docs/chains/introduction) of the Public Client.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  chain: mainnet, // [!code focus]
  transport: http(),
})
```

### batch (optional)

Flags for batch settings.

### batch.multicall (optional)

- **Type:** `boolean | MulticallBatchOptions`
- **Default:** `false`

Toggle to enable `eth_call` multicall aggregation.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  batch: {
    multicall: true, // [!code focus]
  },
  chain: mainnet,
  transport: http(),
})
```

### batch.multicall.batchSize (optional)

- **Type:** `number`
- **Default:** `1_024`

The maximum size (in bytes) for each multicall (`aggregate3`) calldata chunk.

> Note: Some RPC Providers limit the amount of calldata that can be sent in a single request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  batch: {
    multicall: {
      batchSize: 512, // [!code focus]
    },
  },
  chain: mainnet,
  transport: http(),
})
```

### batch.multicall.wait (optional)

- **Type:** `number`
- **Default:** `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays))

The maximum number of milliseconds to wait before sending a batch.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  batch: {
    multicall: {
      wait: 16, // [!code focus]
    },
  },
  chain: mainnet,
  transport: http(),
})
```

### key (optional)

- **Type:** `string`
- **Default:** `"public"`

A key for the Client.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  chain: mainnet,
  key: 'public', // [!code focus]
  transport: http(),
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"Public Client"`

A name for the Client.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  chain: mainnet,
  name: 'Public Client', // [!code focus]
  transport: http(),
})
```

### pollingInterval (optional)

- **Type:** `number`
- **Default:** `4_000`

Frequency (in ms) for polling enabled Actions.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createClient({
  chain: mainnet,
  pollingInterval: 10_000, // [!code focus]
  transport: http(),
})
```

### rpcSchema (optional)

- **Type:** `RpcSchema`
- **Default:** `WalletRpcSchema`

Typed JSON-RPC schema for the client.

```ts twoslash
import { createClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// @noErrors
// ---cut---
import { rpcSchema } from 'viem'

type CustomRpcSchema = [{ // [!code focus]
  Method: 'eth_wagmi', // [!code focus]
  Parameters: [string] // [!code focus]
  ReturnType: string // [!code focus]
}] // [!code focus]

const client = createClient({
  chain: mainnet,
  rpcSchema: rpcSchema<CustomRpcSchema>(), // [!code focus]
  transport: http()
})

const result = await client.request({ // [!code focus]
  method: 'eth_wa // [!code focus] 
//               ^|
  params: ['hello'], // [!code focus]
}) // [!code focus]
```
</file>

<file path="clients/intro.md">
# Introduction to Clients & Transports [A brief introduction to Clients & Transports.]

## Clients

A **Client** provides access to a subset of **Actions**. 

> A **Client** in the context of viem is similar to an [Ethers.js Provider](https://docs.ethers.org/v5/api/providers/).

There are three types of **Clients** in viem:

- A [Public Client](/docs/clients/public) which provides access to [Public Actions](/docs/actions/public/introduction), such as `getBlockNumber` and `getBalance`. 
- A [Wallet Client](/docs/clients/wallet) which provides access to [Wallet Actions](/docs/actions/wallet/introduction), such as `sendTransaction` and `signMessage`.
- A [Test Client](/docs/clients/test) which provides access to [Test Actions](/docs/actions/test/introduction), such as `mine` and `impersonate`.

## Transports

A **Client** is instantiated with a **Transport**, which is the intermediary layer that is responsible for executing outgoing requests (ie. RPC requests).

There are three types of Transports in viem: 

- A [HTTP Transport](/docs/clients/transports/http) that executes requests via a HTTP JSON-RPC API.
- A [WebSocket Transport](/docs/clients/transports/websocket) that executes requests via a WebSocket JSON-RPC API.
- A [Custom Transport](/docs/clients/transports/custom) that executes requests via an [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193).
</file>

<file path="clients/public.md">
# Public Client [A function to create a Public Client]

A Public Client is an interface to "public" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).

The `createPublicClient` function sets up a Public Client with a given [Transport](/docs/clients/intro) configured for a [Chain](/docs/chains/introduction).

## Import

```ts twoslash
import { createPublicClient } from 'viem'
```

## Usage

Initialize a Client with your desired [Chain](/docs/chains/introduction) (e.g. `mainnet`) and [Transport](/docs/clients/intro) (e.g. `http`).

```ts twoslash
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({ 
  chain: mainnet,
  transport: http()
})
```

Then you can consume [Public Actions](/docs/actions/public/introduction):

```ts twoslash
// [!include ~/snippets/publicClient.ts]
// ---cut---
const blockNumber = await publicClient.getBlockNumber() // [!code focus:10]
```

## Optimization

The Public Client also supports [`eth_call` Aggregation](#multicall) for improved performance.

### `eth_call` Aggregation (via Multicall)

The Public Client supports the aggregation of `eth_call` requests into a single multicall (`aggregate3`) request.

This means for every Action that utilizes an `eth_call` request (ie. `readContract`), the Public Client will batch the requests (over a timed period) and send it to the RPC Provider in a single multicall request. This can dramatically improve network performance, and decrease the amount of [Compute Units (CU)](https://docs.alchemy.com/reference/compute-units) used by RPC Providers like Alchemy, Infura, etc.

The Public Client schedules the aggregation of `eth_call` requests over a given time period. By default, it executes the batch request at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue) (a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays)), however, consumers can specify a custom `wait` period (in ms).

You can enable `eth_call` aggregation by setting the `batch.multicall` flag to `true`:

```ts twoslash
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const publicClient = createPublicClient({
  batch: {
    multicall: true, // [!code focus]
  },
  chain: mainnet,
  transport: http(),
})
```

> You can also [customize the `multicall` options](#batchmulticallbatchsize-optional).

Now, when you start to utilize `readContract` Actions, the Public Client will batch and send over those requests at the end of the message queue (or custom time period) in a single `eth_call` multicall request:

:::code-group

```ts twoslash [example.ts]
// @filename: client.ts
// [!include ~/snippets/publicClient.ts]

// @filename: abi.ts
// [!include ~/snippets/erc20Abi.ts]

// @filename: example.ts
const address = '0x'
// ---cut---
import { getContract } from 'viem'
import { abi } from './abi'
import { publicClient } from './client'

const contract = getContract({ address, abi, client: publicClient })

// The below will send a single request to the RPC Provider.
const [name, totalSupply, symbol, balance] = await Promise.all([
  contract.read.name(),
  contract.read.totalSupply(),
  contract.read.symbol(),
  contract.read.balanceOf([address]),
])
```

```ts twoslash [client.ts]
// [!include ~/snippets/publicClient.ts]
```

```ts twoslash [abi.ts]
// [!include ~/snippets/erc20Abi.ts]
```

:::

> Read more on [Contract Instances](/docs/contract/getContract).

## Parameters

### transport

- **Type:** [Transport](/docs/glossary/types#transport)

The [Transport](/docs/clients/intro) of the Public Client.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(), // [!code focus]
})
```

### chain (optional)

- **Type:** [Chain](/docs/glossary/types#chain)

The [Chain](/docs/chains/introduction) of the Public Client.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  chain: mainnet, // [!code focus]
  transport: http(),
})
```

### batch (optional)

Flags for batch settings.

### batch.multicall (optional)

- **Type:** `boolean | MulticallBatchOptions`
- **Default:** `false`

Toggle to enable `eth_call` multicall aggregation.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  batch: {
    multicall: true, // [!code focus]
  },
  chain: mainnet,
  transport: http(),
})
```

### batch.multicall.batchSize (optional)

- **Type:** `number`
- **Default:** `1_024`

The maximum size (in bytes) for each multicall (`aggregate3`) calldata chunk.

> Note: Some RPC Providers limit the amount of calldata that can be sent in a single request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  batch: {
    multicall: {
      batchSize: 512, // [!code focus]
    },
  },
  chain: mainnet,
  transport: http(),
})
```

### batch.multicall.wait (optional)

- **Type:** `number`
- **Default:** `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays))

The maximum number of milliseconds to wait before sending a batch.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  batch: {
    multicall: {
      wait: 16, // [!code focus]
    },
  },
  chain: mainnet,
  transport: http(),
})
```

### cacheTime (optional)

- **Type:** `number`
- **Default:** `client.pollingInterval`

Time (in ms) that cached data will remain in memory.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  cacheTime: 10_000, // [!code focus]
  chain: mainnet,
  transport: http(),
})
```

### ccipRead (optional)

- **Type:** `(parameters: CcipRequestParameters) => Promise<CcipRequestReturnType> | false`
- **Default:** `true`

[CCIP Read](https://eips.ethereum.org/EIPS/eip-3668) configuration.

CCIP Read is enabled by default, but if set to `false`, the client will not support offchain CCIP lookups.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  ccipRead: false, // [!code focus]
  chain: mainnet,
  transport: http(),
})
```

### ccipRead.request (optional)

- **Type:** `(parameters: CcipRequestParameters) => Promise<CcipRequestReturnType>`

A function that will be called to make the [offchain CCIP lookup request](https://eips.ethereum.org/EIPS/eip-3668#client-lookup-protocol).

```ts twoslash
// @noErrors
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  ccipRead: { // [!code focus]
    async request({ data, sender, urls }) { // [!code focus]
      // ... // [!code focus]
    } // [!code focus]
  }, // [!code focus]
  chain: mainnet,
  transport: http(),
})
```

### key (optional)

- **Type:** `string`
- **Default:** `"public"`

A key for the Client.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  chain: mainnet,
  key: 'public', // [!code focus]
  transport: http(),
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"Public Client"`

A name for the Client.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  chain: mainnet,
  name: 'Public Client', // [!code focus]
  transport: http(),
})
```

### pollingInterval (optional)

- **Type:** `number`
- **Default:** `4_000`

Frequency (in ms) for polling enabled Actions.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// ---cut---
const publicClient = createPublicClient({
  chain: mainnet,
  pollingInterval: 10_000, // [!code focus]
  transport: http(),
})
```

### rpcSchema (optional)

- **Type:** `RpcSchema`
- **Default:** `PublicRpcSchema`

Typed JSON-RPC schema for the client.

```ts twoslash
// [!include ~/snippets/publicClient.ts:imports]
// @noErrors
// ---cut---
import { rpcSchema } from 'viem'

type CustomRpcSchema = [{ // [!code focus]
  Method: 'eth_wagmi', // [!code focus]
  Parameters: [string] // [!code focus]
  ReturnType: string // [!code focus]
}] // [!code focus]

const publicClient = createPublicClient({
  chain: mainnet,
  rpcSchema: rpcSchema<CustomRpcSchema>(), // [!code focus]
  transport: http(),
})

const result = await publicClient.request({ // [!code focus]
  method: 'eth_wa // [!code focus] 
//               ^|
  params: ['hello'], // [!code focus]
}) // [!code focus]
```

## Live Example

Check out the usage of `createPublicClient` in the live [Public Client Example](https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/clients_public-client) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/clients_public-client?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="clients/test.md">
# Test Client [A function to create a Test Client]

A Test Client is an interface to "test" JSON-RPC API methods accessible through a local Ethereum test node such as [Anvil](https://book.getfoundry.sh/anvil/) or [Hardhat](https://hardhat.org/) such as mining blocks, impersonating accounts, setting fees, etc through [Test Actions](/docs/actions/test/introduction).

The `createTestClient` function sets up a Test RPC Client with a given [Transport](/docs/clients/intro).

## Import

```ts twoslash
import { createTestClient } from 'viem'
```

## Usage

Initialize a Client with your desired [Chain](/docs/chains/introduction), [Transport](/docs/clients/intro) (e.g. `http`) and [mode](#mode) (e.g. `"anvil"`).

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'

const client = createTestClient({
  chain: foundry,
  mode: 'anvil',
  transport: http(), 
})
```

Then you can consume [Test Actions](/docs/actions/test/introduction):

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'

const client = createTestClient({
  chain: foundry,
  mode: 'anvil',
  transport: http(), 
})
// ---cut---
const mine = await client.mine({ blocks: 1 }) // [!code focus:10]
```

### Extending with Public & Wallet Actions

When interacting with a Ethereum test node, you may also find yourself wanting to interact with [Public Actions](/docs/actions/public/introduction) and [Wallet Actions](/docs/actions/wallet/introduction) with the same `chain` and `transport`. Instead of creating three different Clients, you can instead just extend the Test Client with those actions:

```ts twoslash
// @noErrors
import { createTestClient, http, publicActions, walletActions } from 'viem'
import { foundry } from 'viem/chains'

const client = createTestClient({
  chain: foundry,
  mode: 'anvil',
  transport: http(), 
})
  .extend(publicActions) // [!code hl]
  .extend(walletActions) // [!code hl]

const blockNumber = await client.getBlockNumber() // Public Action
const hash = await client.sendTransaction({ ... }) // Wallet Action
const mine = await client.mine({ blocks: 1 }) // Test Action
```

## Parameters

### mode

- **Type:** `"anvil" | "hardhat" | "ganache"`

Mode of the Test Client.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
const client = createTestClient({
  chain: foundry,
  mode: 'anvil', // [!code focus]
  transport: http(), 
})
```

### transport

- **Type:** [Transport](/docs/glossary/types#transport)

[Transport](/docs/clients/intro) of the Test Client.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
const client = createTestClient({
  chain: foundry,
  mode: 'anvil', 
  transport: http(),  // [!code focus]
})
```

### account (optional)

- **Type:** `Account | Address`

The Account to use for the Client. This will be used for Actions that require an `account` as an argument.

Accepts a [JSON-RPC Account](/docs/accounts/jsonRpc) or [Local Account (Private Key, etc)](/docs/accounts/local/privateKeyToAccount).

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
import { privateKeyToAccount } from 'viem/accounts'

const client = createTestClient({
  account: privateKeyToAccount('0x...'), // [!code focus]
  chain: foundry,
  mode: 'anvil',
  transport: http(),
})
```

### chain (optional)

- **Type:** [Chain](/docs/glossary/types#chain)

[Chain](/docs/chains/introduction) of the Test Client.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
const client = createTestClient({
  chain: foundry, // [!code focus]
  mode: 'anvil',
  transport: http(), 
})
```

### cacheTime (optional)

- **Type:** `number`
- **Default:** `client.pollingInterval`

Time (in ms) that cached data will remain in memory.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
const client = createTestClient({
  cacheTime: 10_000, // [!code focus]
  chain: foundry,
  mode: 'anvil',
  transport: http(),
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"Test Client"`

A name for the Client.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
const client = createTestClient({
  chain: foundry,
  mode: 'anvil', 
  name: 'Anvil Client',  // [!code focus]
  transport: http(),
})
```

### pollingInterval (optional)

- **Type:** `number`
- **Default:** `4_000`

Frequency (in ms) for polling enabled Actions.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// ---cut---
const client = createTestClient({
  chain: foundry,
  mode: 'anvil', 
  pollingInterval: 10_000,  // [!code focus]
  transport: http(),
})
```

### rpcSchema (optional)

- **Type:** `RpcSchema`
- **Default:** `TestRpcSchema`

Typed JSON-RPC schema for the client.

```ts twoslash
import { createTestClient, http } from 'viem'
import { foundry } from 'viem/chains'
// @noErrors
// ---cut---
import { rpcSchema } from 'viem'

type CustomRpcSchema = [{ // [!code focus]
  Method: 'eth_wagmi', // [!code focus]
  Parameters: [string] // [!code focus]
  ReturnType: string // [!code focus]
}] // [!code focus]

const client = createTestClient({
  chain: foundry,
  rpcSchema: rpcSchema<CustomRpcSchema>(), // [!code focus]
  transport: http()
})

const result = await client.request({ // [!code focus]
  method: 'eth_wa // [!code focus] 
//               ^|
  params: ['hello'], // [!code focus]
}) // [!code focus]
```
</file>

<file path="clients/wallet.md">
# Wallet Client [A function to create a Wallet Client.]

A Wallet Client is an interface to interact with [Ethereum Account(s)](https://ethereum.org/en/glossary/#account) and provides the ability to retrieve accounts, execute transactions, sign messages, etc through [Wallet Actions](/docs/actions/wallet/introduction).

The `createWalletClient` function sets up a Wallet Client with a given [Transport](/docs/clients/intro).

The Wallet Client supports signing over:

- [JSON-RPC Accounts](#json-rpc-accounts) (e.g. Browser Extension Wallets, WalletConnect, etc.).
- [Local Accounts](#local-accounts-private-key-mnemonic-etc) (e.g. private key/mnemonic wallets).

## Import

```ts
import { createWalletClient } from 'viem'
```

## JSON-RPC Accounts

A [JSON-RPC Account](/docs/accounts/jsonRpc) **defers** signing of transactions & messages to the target Wallet over JSON-RPC. An example could be sending a transaction via a Browser Extension Wallet (e.g. MetaMask) with the `window.ethereum` Provider.

Below is an example of how you can set up a JSON-RPC Account.

#### 1: Initialize a Wallet Client

Before we set up our Account and start consuming Wallet Actions, we will need to set up our Wallet Client with the [`custom` Transport](/docs/clients/transports/custom), where we will pass in the `window.ethereum` Provider:

```ts twoslash
import 'viem/window'
// ---cut---
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})
```

#### 2: Set up your JSON-RPC Account

We will want to retrieve an address that we can access in our Wallet (e.g. MetaMask).

```ts twoslash
import 'viem/window'
// ---cut---
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})

const [address] = await client.getAddresses() // [!code focus:10]
// or: const [address] = await client.requestAddresses() // [!code focus:10]
```

> Note: Some Wallets (like MetaMask) may require you to request access to Account addresses via [`client.requestAddresses`](/docs/actions/wallet/requestAddresses) first.

#### 3: Consume [Wallet Actions](/docs/actions/wallet/introduction)

Now you can use that address within Wallet Actions that require a signature from the user:

```ts twoslash
import 'viem/window'
// ---cut---
import { createWalletClient, custom, parseEther } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})

const [address] = await client.getAddresses()

const hash = await client.sendTransaction({ // [!code focus:10]
  account: address,
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

#### Optional: Hoist the Account

If you do not wish to pass an account around to every Action that requires an `account`, you can also hoist the account into the Wallet Client.

```ts twoslash
import 'viem/window'
// ---cut---
import { createWalletClient, http, parseEther } from 'viem'
import { mainnet } from 'viem/chains'

const [account] = await window.ethereum!.request({ method: 'eth_requestAccounts' })

const client = createWalletClient({ // [!code focus:99]
  account, // [!code ++]
  chain: mainnet,
  transport: http()
})

const hash = await client.sendTransaction({
  account, // [!code --]
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

## Local Accounts (Private Key, Mnemonic, etc)

A Local Account performs signing of transactions & messages with a private key **before** executing a method over JSON-RPC.

There are three types of Local Accounts in viem:

- [Private Key Account](/docs/accounts/local/privateKeyToAccount)
- [Mnemonic Account](/docs/accounts/local/mnemonicToAccount)
- [Hierarchical Deterministic (HD) Account](/docs/accounts/local/hdKeyToAccount)

Below are the steps to integrate a **Private Key Account**, but the same steps can be applied to **Mnemonic & HD Accounts**.

#### 1: Initialize a Wallet Client

Before we set up our Account and start consuming Wallet Actions, we will need to set up our Wallet Client with the [`http` Transport](/docs/clients/transports/http):

```ts twoslash
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})
```

#### 2: Set up your Local Account

Next, we will instantiate a Private Key Account using `privateKeyToAccount`:

```ts twoslash
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts' // [!code focus]
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})

const account = privateKeyToAccount('0x...') // [!code focus:1]
```

#### 3: Consume [Wallet Actions](/docs/actions/wallet/introduction)

Now you can use that Account within Wallet Actions that need a signature from the user:

```ts twoslash
import { createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})

const account = privateKeyToAccount('0x...')

const hash = await client.sendTransaction({ // [!code focus:5]
  account,
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

#### Optional: Hoist the Account

If you do not wish to pass an account around to every Action that requires an `account`, you can also hoist the account into the Wallet Client.

```ts twoslash
import { createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

const client = createWalletClient({ // [!code focus:99]
  account, // [!code ++]
  chain: mainnet,
  transport: http()
})

const hash = await client.sendTransaction({
  account, // [!code --]
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

#### Optional: Extend with Public Actions

When using a Local Account, you may be finding yourself using a [Public Client](/docs/clients/public) instantiated with the same parameters (`transport`, `chain`, etc) as your Wallet Client.

In this case, you can extend your Wallet Client with [Public Actions](/docs/actions/public/introduction) to avoid having to handle multiple Clients.

```ts twoslash
// @noErrors
import { createWalletClient, http, publicActions } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

const client = createWalletClient({ // [!code focus]
  account,
  chain: mainnet,
  transport: http()
}).extend(publicActions) // [!code ++] // [!code focus]

const { request } = await client.simulateContract({ ... }) // Public Action // [!code focus]
const hash = await client.writeContract(request) // Wallet Action // [!code focus]
```

## Parameters

### account (optional)

- **Type:** `Account | Address`

The Account to use for the Wallet Client. This will be used for Actions that require an `account` as an argument.

Accepts a [JSON-RPC Account](#json-rpc-accounts) or [Local Account (Private Key, etc)](#local-accounts-private-key-mnemonic-etc).

```ts twoslash
import 'viem/window'
// ---cut---
import { createWalletClient, custom, parseEther } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  account: '0x...', // [!code focus]
  chain: mainnet,
  transport: custom(window.ethereum!)
})

const hash = await client.sendTransaction({
  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  value: parseEther('0.001')
})
```

### chain (optional)

- **Type:** [Chain](/docs/glossary/types#chain)

The [Chain](/docs/chains/introduction) of the Wallet Client.

Used in the [`sendTransaction`](/docs/actions/wallet/sendTransaction) & [`writeContract`](/docs/contract/writeContract) Actions to assert that the chain matches the wallet's active chain.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createWalletClient({
  chain: mainnet, // [!code focus]
  transport: custom(window.ethereum!)
})
```

### cacheTime (optional)

- **Type:** `number`
- **Default:** `client.pollingInterval`

Time (in ms) that cached data will remain in memory.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'
// ---cut---
const client = createWalletClient({
  cacheTime: 10_000, // [!code focus]
  chain: mainnet,
  transport: custom(window.ethereum!)
})
```

### ccipRead (optional)

- **Type:** `(parameters: CcipRequestParameters) => Promise<CcipRequestReturnType> | false`
- **Default:** `true`

[CCIP Read](https://eips.ethereum.org/EIPS/eip-3668) configuration.

CCIP Read is enabled by default, but if set to `false`, the client will not support offchain CCIP lookups.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
// ---cut---
const client = createWalletClient({
  ccipRead: false, // [!code focus]
  transport: custom(window.ethereum!)
})
```

### ccipRead.request (optional)

- **Type:** `(parameters: CcipRequestParameters) => Promise<CcipRequestReturnType>`

A function that will be called to make the [offchain CCIP lookup request](https://eips.ethereum.org/EIPS/eip-3668#client-lookup-protocol).

```ts twoslash
// @noErrors
import 'viem/window'
import { createWalletClient, custom } from 'viem'
// ---cut---
const client = createWalletClient({
  ccipRead: { // [!code focus]
    async request({ data, sender, urls }) { // [!code focus]
      // ... // [!code focus]
    } // [!code focus]
  }, // [!code focus]
  transport: custom(window.ethereum!)
})
```

### key (optional)

- **Type:** `string`
- **Default:** `"wallet"`

A key for the Client.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
// ---cut---
const client = createWalletClient({
  key: 'foo', // [!code focus]
  transport: custom(window.ethereum!)
})
```

### name (optional)

- **Type:** `string`
- **Default:** `"Wallet Client"`

A name for the Client.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
// ---cut---
const client = createWalletClient({
  name: 'Foo Wallet Client', // [!code focus]
  transport: custom(window.ethereum!)
})
```

### pollingInterval (optional)

- **Type:** `number`
- **Default:** `4_000`

Frequency (in ms) for polling enabled Actions.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
// ---cut---
const client = createWalletClient({
  pollingInterval: 10_000, // [!code focus]
  transport: custom(window.ethereum!)
})
```

### rpcSchema (optional)

- **Type:** `RpcSchema`
- **Default:** `WalletRpcSchema`

Typed JSON-RPC schema for the client.

```ts twoslash
import 'viem/window'
import { createWalletClient, custom } from 'viem'
// @noErrors
// ---cut---
import { rpcSchema } from 'viem'

type CustomRpcSchema = [{ // [!code focus]
  Method: 'eth_wagmi', // [!code focus]
  Parameters: [string] // [!code focus]
  ReturnType: string // [!code focus]
}] // [!code focus]

const client = createWalletClient({
  rpcSchema: rpcSchema<CustomRpcSchema>(), // [!code focus]
  transport: custom(window.ethereum!)
})

const result = await client.request({ // [!code focus]
  method: 'eth_wa // [!code focus] 
//               ^|
  params: ['hello'], // [!code focus]
}) // [!code focus]
```
</file>

<file path="contract/createContractEventFilter.md">
# createContractEventFilter [Creates a Filter to retrieve contract event logs.]

Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](/docs/actions/public/getFilterChanges) or [`getFilterLogs`](/docs/actions/public/getFilterLogs).

## Usage

By default, an Event Filter with an ABI (`abi`) will retrieve events defined on the ABI.

:::code-group

```ts [example.ts]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi
})
/**
 *  {
 *    abi: [...],
 *    id: '0x345a6572337856574a76364e457a4366',
 *    type: 'event'
 *  }
 */
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address",
      },
      { indexed: true, name: "to", type: "address" },
      {
        indexed: true,
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Scoping

You can also scope a Filter to a set of given attributes (listed below).

### Address

A Filter can be scoped to an **address**:

```ts 
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2' // [!code focus]
})
```

### Event

A Filter can be scoped to an **event**:

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
  eventName: 'Transfer' // [!code focus]
})
```

### Arguments

A Filter can be scoped to given **_indexed_ arguments**:

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
  eventName: 'Transfer',
  args: {  // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```

Only indexed arguments in `event` are candidates for `args`.

A Filter Argument can also be an array to indicate that other values can exist in the position:

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
  eventName: 'Transfer',
  args: { // [!code focus:8]
    // '0xd8da...' OR '0xa5cc...' OR '0xa152...'
    from: [
      '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
      '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',
      '0xa152f8bb749c55e9943a3a0a3111d18ee2b3f94e',
    ],
  }
})
```

### Block Range

A Filter can be scoped to a **block range**:

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
  eventName: 'Transfer',
  fromBlock: 16330000n, // [!code focus]
  toBlock: 16330050n // [!code focus]
})
```

### Strict Mode

By default, `createContractEventFilter` will include logs that [do not conform](/docs/glossary/terms#non-conforming-log) to the indexed & non-indexed arguments on the `event`.
viem will not return a value for arguments that do not conform to the ABI, thus, some arguments on `args` may be undefined.

```ts
const filter = await publicClient.createContractEventFilter({
  eventName: 'Transfer',
})
const logs = await publicClient.getFilterLogs({ filter })

logs[0].args // [!code focus]
//      ^? { address?: Address, to?: Address, value?: bigint } // [!code focus]
```

You can turn on `strict` mode to only return logs that conform to the indexed & non-indexed arguments on the `event`, meaning that `args` will always be defined. The trade-off is that non-conforming logs will be filtered out.

```ts 
const filter = await publicClient.createContractEventFilter({
  eventName: 'Transfer',
  strict: true
})
const logs = await publicClient.getFilterLogs({ filter })

logs[0].args // [!code focus]
//      ^? { address: Address, to: Address, value: bigint } // [!code focus]
```

## Returns

[`Filter`](/docs/glossary/types#filter)

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi, // [!code focus]
})
```

### address (optional)

- **Type:** `Address | Address[]`

The contract address or a list of addresses from which Logs should originate. If no addresses are provided, then it will query all events matching the event signatures on the ABI.

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2' // [!code focus]
})
```

### eventName (optional)

- **Type:** `string`

The event name.

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  eventName: 'Transfer' // [!code focus]
})
```

### args (optional)

- **Type:** Inferred.

A list of _indexed_ event arguments.

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  eventName: 'Transfer',
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```

### fromBlock (optional)

- **Type:** `bigint`

Block to start querying/listening from.

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  fromBlock: 69420n // [!code focus]
})
```

### toBlock (optional)

- **Type:** `bigint`

Block to query/listen until.

```ts
const filter = await publicClient.createContractEventFilter({
  abi: wagmiAbi,
  toBlock: 70120n // [!code focus]
})
```
</file>

<file path="contract/decodeDeployData.md">
---
description: Decodes ABI encoded deploy data (bytecode & arguments).
---

# decodeDeployData

Decodes ABI encoded deploy data (bytecode & arguments).

The opposite of [`encodeDeployData`](/docs/contract/encodeDeployData).

## Install

```ts
import { decodeDeployData } from 'viem'
```

## Usage

:::code-group

```ts [example.ts]
import { decodeDeployData } from 'viem'
import { wagmiAbi } from './abi.ts'

const { args } = decodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c63430008070033',
  data: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c634300080700330000000000000000000000000000000000000000000000000000000000010f2c'
})
// { args: [69420n], bytecode: '0x6080604...' }
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        name: 'a',
        type: 'uint256',
      },
    ],
    stateMutability: 'nonpayable',
    type: 'constructor',
  },
  ...
] as const;
```

:::

## Return Value

```ts
{
  args: unknown[] | undefined;
  bytecode: Hex;
}
```

Decoded deploy data.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const { args } = decodeDeployData({
  abi: wagmiAbi, // [!code focus]
  bytecode: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c63430008070033',
  data: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c634300080700330000000000000000000000000000000000000000000000000000000000010f2c'
})
```

### bytecode

- **Type:** [`Hex`](/docs/glossary/types#hex)

Contract bytecode.

```ts
const { args } = decodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c63430008070033', // [!code focus]
  data: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c634300080700330000000000000000000000000000000000000000000000000000000000010f2c'
})
```

### data

- **Type:** [`Hex`](/docs/glossary/types#hex)

The encoded calldata.

```ts
const { args } = decodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c63430008070033',
  data: '0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220116554d4ba29ee08da9e97dc54ff9a2a65d67a648140d616fc225a25ff08c86364736f6c634300080700330000000000000000000000000000000000000000000000000000000000010f2c' // [!code focus]
})
```
</file>

<file path="contract/decodeErrorResult.md">
---
description: Decodes reverted error from a contract function call.
---

# decodeErrorResult

Decodes reverted error from a contract function call.

## Install

```ts
import { decodeErrorResult } from 'viem'
```

## Usage

:::code-group

```ts [example.ts]
import { decodeErrorResult } from 'viem'
import { wagmiAbi } from './abi.ts'

const value = decodeErrorResult({
  abi: wagmiAbi,
  data: '0xb758934b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000'
})
// { errorName: 'InvalidTokenError', args: ['sold out'] }
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
		inputs: [
			{
				name: "reason",
				type: "string"
			}
		],
		name: "InvalidTokenError",
		type: "error"
	},
  ...
] as const;
```

:::

## Return Value

The decoded error.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const value = decodeErrorResult({
  abi: wagmiAbi, // [!code focus]
  data: '0xb758934b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000'
})
```

### data

- **Type:** [`Hex`](/docs/glossary/types#hex)

The calldata.

```ts
const value = decodeErrorResult({
  abi: wagmiAbi,
  data: '0xb758934b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000' // [!code focus]
})
```
</file>

<file path="contract/decodeEventLog.md">
---
description: Decodes ABI encoded event topics & data.
---

# decodeEventLog

Decodes ABI encoded event topics & data (from an [Event Log](/docs/glossary/terms#event-log)) into an event name and structured arguments (both indexed & non-indexed).

## Install

```ts
import { decodeEventLog } from 'viem'
```

## Usage

:::code-group

```ts [example.ts]
import { decodeEventLog } from 'viem'
import { wagmiAbi } from './abi.ts'

const topics = decodeEventLog({
  abi: wagmiAbi,
  data: '0x0000000000000000000000000000000000000000000000000000000000000001',
  topics: [
    '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
    '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
  ]
})
/**
 *  {
 *    eventName: 'Transfer',
 *    args: {
 *      from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 *      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
 *      value: 1n
 *    }
 *  }
 */
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  ...
] as const;
```

:::

### Partial Decode

By default, if the `topics` and `data` does not conform to the ABI (a mismatch between the number of indexed/non-indexed arguments), `decodeEventLog` will throw an error.

For example, the following will throw an error as there is a mismatch in non-`indexed` arguments & `data` length.

```ts
decodeEventLog({
  abi: parseAbi(['event Transfer(address indexed, address, uint256)']), // [!code focus]
  // `data` should be 64 bytes, but is only 32 bytes. // [!code focus]
  data: '0x0000000000000000000000000000000000000000000000000000000000000001', // [!code focus]
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
    '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  ]
})
// [DecodeLogDataMismatch]: Data size of 32 bytes is too small for non-indexed event parameters.
```

It is possible for `decodeEventLog` to try and partially decode the Log, this can be done by setting the `strict` argument to `false`:

```ts 
decodeEventLog({ // [!code focus]
  abi: parseAbi(['event Transfer(address indexed, address, uint256)']), // [!code focus]
  data: '0x0000000000000000000000000000000000000000000000000000000000000001', // [!code focus]
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
    '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  ],
  strict: false // [!code ++]
})
/**
 * {
 *   eventName: 'Transfer',
 *   args: ['0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266']
 * }
 */
```

## Return Value

```ts
{
  eventName: string;
  args: Inferred;
}
```

Decoded ABI event topics.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const topics = decodeEventLog({
  abi: wagmiAbi, // [!code focus]
  data: '0x0000000000000000000000000000000000000000000000000000000000000001',
  topics: [
    '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
    '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
  ]
})
```

### topics

- **Type:** `[Hex, ...(Hex | Hex[] | null)[]]`

A set of topics (encoded indexed args) from the [Event Log](/docs/glossary/terms#event-log).

```ts
const topics = decodeEventLog({
  abi: wagmiAbi,
  data: '0x0000000000000000000000000000000000000000000000000000000000000001',
  topics: [ // [!code focus:5]
    '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
    '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
  ]
})
```

### data (optional)

- **Type:** `string`

The data (encoded non-indexed args) from the [Event Log](/docs/glossary/terms#event-log).

```ts
const topics = decodeEventLog({
  abi: wagmiAbi,
  data: '0x0000000000000000000000000000000000000000000000000000000000000001', // [!code focus]
  topics: [
    '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
    '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
  ]
})
```

### eventName (optional)

- **Type:** `string`

An event name from the ABI. Provide an `eventName` to infer the return type of `decodeEventLog`.

```ts
const topics = decodeEventLog({
  abi: wagmiAbi,
  eventName: 'Transfer', // [!code focus]
  topics: [
    '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
    '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
  ]
})
```

### strict (optional)

- **Type:** `boolean`
- **Default:** `true`

If `true`, `decodeEventLog` will throw an error if the `data` & `topics` lengths to not conform to the event on the ABI. 
If `false`, `decodeEventLog` will try and [partially decode](#partial-decode).

```ts
const topics = decodeEventLog({
  abi: wagmiAbi,
  strict: false, // [!code focus]
  topics: [
    '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
    '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
  ]
})
```
</file>

<file path="contract/decodeFunctionData.md">
---
description: Decodes ABI encoded data (4 byte selector & arguments) into a function name and arguments.
---

# decodeFunctionData

Decodes ABI encoded data (4 byte selector & arguments) into a function name and arguments.

The opposite of [`encodeFunctionData`](/docs/contract/encodeFunctionData).

## Install

```ts
import { decodeFunctionData } from 'viem'
```

## Usage

Below is a very basic example of how to decode a function to calldata.

:::code-group

```ts [example.ts]
import { decodeFunctionData } from 'viem'
import { wagmiAbi } from './abi.ts'

const { functionName } = decodeFunctionData({
  abi: wagmiAbi,
  data: '0x18160ddd'
})
// { functionName: 'totalSupply' }
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

:::

### Extracting Arguments

If your calldata includes argument(s) after the 4byte function signature, you can extract them with the `args` return value.

:::code-group

```ts [example.ts]
import { decodeFunctionData } from 'viem'
import { wagmiAbi } from './abi'

// [!code word:args:1]
const { functionName, args } = decodeFunctionData({
  abi: wagmiAbi,
  data: '0x70a08231000000000000000000000000fba3912ca04dd458c843e2ee08967fc04f3579c2'
})
// { functionName: 'balanceOf', args: ["0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2"] }
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

:::

## Return Value

```ts
{
  functionName: string;
  args: unknown[] | undefined;
}
```

Decoded ABI function data.

### functionName

- **Type**: `string`

The decoded function name.

### args

- **Type**: `unknown[] | undefined`

The decoded function arguments.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const { functionName } = decodeFunctionData({
  abi: wagmiAbi, // [!code focus]
  data: '0x18160ddd'
})
```

### data

- **Type:** [`Hex`](/docs/glossary/types#hex)

The encoded calldata.

```ts
const { functionName } = decodeFunctionData({
  abi: wagmiAbi,
  data: '0x18160ddd' // [!code focus]
})
```
</file>

<file path="contract/decodeFunctionResult.md">
---
description: Decodes the result of a function call on a contract.
---

# decodeFunctionResult

Decodes the result of a function call on a contract.

## Install

```ts
import { decodeFunctionResult } from 'viem'
```

## Usage

Given an ABI (`abi`) and a function (`functionName`), pass through the encoded calldata (`data`) to retrieve the decoded value:

:::code-group

```ts [example.ts]
import { decodeFunctionResult } from 'viem'
import { wagmiAbi } from './abi.ts'

const value = decodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf',
  data: '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac'
})
// '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    name: 'ownerOf',
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  ...
] as const;
```

:::

### Without `functionName`

If your `abi` contains only one ABI item, you can omit the `functionName` (it becomes optional):

:::code-group

```ts [example.ts]
import { decodeFunctionResult } from 'viem'
import { abiItem } from './abi.ts'

const value = decodeFunctionResult({
  abi: [abiItem],
  functionName: 'ownerOf', // [!code --]
  data: '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac'
})
// '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
```
```ts [abi.ts]
const abiItem = {
  inputs: [{ name: 'tokenId', type: 'uint256' }],
  name: 'ownerOf',
  outputs: [{ name: '', type: 'address' }],
  stateMutability: 'view',
  type: 'function',
}

```
:::


### A more complex example

:::code-group

```ts [example.ts]
import { decodeFunctionResult } from 'viem'

const value = decodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'getInfo',
  data: '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac0000000000000000000000000000000000000000000000000000000000010f2c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac0000000000000000000000000000000000000000000000000000000000000045'
})
/**
 * {
 *  foo: {
 *    sender: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 *    x: 69420n,
 *    y: true
 *  },
 *  sender: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 *  z: 69
 * }
 */
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: 'getInfo',
    outputs: [
      {
        components: [
          {
            components: [
              {
                name: 'sender',
                type: 'address',
              },
              {
                name: 'x',
                type: 'uint256',
              },
              {
                name: 'y',
                type: 'bool',
              },
            ],
            name: 'foo',
            type: 'tuple',
          },
          {
            name: 'sender',
            type: 'address',
          },
          {
            name: 'z',
            type: 'uint32',
          },
        ],
        name: 'res',
        type: 'tuple',
      },
    ],
    stateMutability: 'pure',
    type: 'function',
  },
  ...
] as const;
```

:::

## Return Value

The decoded data. Type is inferred from the ABI.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const value = decodeFunctionResult({
  abi: wagmiAbi, // [!code focus]
  functionName: 'ownerOf',
  data: '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac'
})
```

### functionName

- **Type:** `string`

The function to encode from the ABI.

```ts
const value = decodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf', // [!code focus]
  data: '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac'
})
```

### data

- **Type:** [`Hex`](/docs/glossary/types#hex)

The calldata.

```ts
const value = decodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf',
  data: '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac' // [!code focus]
})
```
</file>

<file path="contract/deployContract.md">
---
description: Deploys a contract to the network, given bytecode & constructor arguments.
---

# deployContract

Deploys a contract to the network, given bytecode & constructor arguments.

## Usage

:::code-group

```ts [example.ts]
import { wagmiAbi } from './abi'
import { account, walletClient } from './config'

const hash = await walletClient.deployContract({
  abi,
  account,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```

```ts [client.ts]
import { createWalletClient, custom } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount(...)
```

:::

### Deploying with Constructor Args

:::code-group

```ts [example.ts] {8}
import { deployContract } from 'viem'
import { wagmiAbi } from './abi'
import { account, walletClient } from './config'

const hash = await walletClient.deployContract({
  abi,
  account,
  args: [69420],
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```

```ts [abi.ts] {4}
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "x", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  ...
] as const;
```

```ts [client.ts]
import { createWalletClient, custom } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount(...)
```

:::

## Returns

[`Hash`](/docs/glossary/types#hash)

The [Transaction](/docs/glossary/terms#transaction) hash.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const hash = await walletClient.deployContract({
  abi: wagmiAbi, // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```

### account

- **Type:** `Account | Address`

The Account to deploy the contract from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts
const hash = await walletClient.deployContract({
  abi: wagmiAbi, 
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
})
```

### bytecode

- **Type:** [`Hex`](/docs/glossary/types#hex)

The contract's bytecode.

```ts
const hash = await walletClient.deployContract({
  abi: wagmiAbi,
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...', // [!code focus]
})
```

### args (if required)

- **Type:** Inferred from ABI.

Constructor arguments to call upon deployment.

```ts
const hash = await walletClient.deployContract({
  abi: wagmiAbi,
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  args: [69] // [!code focus]
})
```

## Live Example

Check out the usage of `deployContract` in the live [Deploying Contracts Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="contract/encodeDeployData.md">
---
description: Encodes deploy data (bytecode & constructor args) into an ABI encoded value.
---

# encodeDeployData

Encodes deploy data (bytecode & constructor args) into an ABI encoded value.

## Install

```ts
import { encodeDeployData } from 'viem'
```

## Usage

Below is a very basic example of how to encode deploy data.

:::code-group

```ts [example.ts]
import { encodeDeployData } from 'viem'
import { wagmiAbi } from './abi.ts'

const data = encodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...'
})
// 0x608060405260405161083e38038061083e833981016040819052610...
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  { 
    inputs: [], 
    stateMutability: 'nonpayable', 
    type: 'constructor' 
  },
  ...
] as const;
```

:::

### Passing Arguments

If your constructor requires argument(s), you can pass them through with the `args` attribute.

TypeScript types for `args` will be inferred from the constructor & ABI, to guard you from inserting the wrong values.

For example, the `constructor` below requires an **address** argument, and it is typed as `["0x${string}"]`.

:::code-group

```ts [example.ts]
import { encodeDeployData } from 'viem'
import { wagmiAbi } from './abi'

const data = encodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
// 0x608060405260405161083e38038061083e833981016040819052610...00000000000000000000000000000000a5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: 'owner', type: 'address' }],
    stateMutability: 'nonpayable',
    type: 'constructor',
  },
  ...
] as const;
```

:::

## Return Value

[`Hex`](/docs/glossary/types#hex)

ABI encoded data (bytecode & constructor arguments).

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const data = encodeDeployData({
  abi: wagmiAbi, // [!code focus]
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

### bytecode

- **Type:** [`Hex`](/docs/glossary/types#hex)

Contract bytecode.

```ts
const data = encodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...', // [!code focus]
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

### args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
const data = encodeDeployData({
  abi: wagmiAbi,
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC'] // [!code focus]
})
```
</file>

<file path="contract/encodeErrorResult.md">
---
description: Encodes a reverted error from a function call.
---

# encodeErrorResult

Encodes a reverted error from a function call. The opposite of [`decodeErrorResult`](/docs/contract/decodeErrorResult).

## Install

```ts
import { encodeErrorResult } from 'viem'
```

## Usage

:::code-group

```ts [example.ts]
import { decodeErrorResult } from 'viem'
import { wagmiAbi } from './abi.ts'

const value = encodeErrorResult({
  abi: wagmiAbi,
  errorName: 'InvalidTokenError',
  args: ['sold out']
})
// 0xb758934b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
		inputs: [
			{
				name: "reason",
				type: "string"
			}
		],
		name: "InvalidTokenError",
		type: "error"
	},
  ...
] as const;
```

:::

### Without `errorName`

If your `abi` contains only one ABI item, you can omit the `errorName` (it becomes optional):

```ts
import { decodeErrorResult } from 'viem'

const abiItem = {
  inputs: [{ name: 'reason', type: 'string' }],
  name: 'InvalidTokenError',
  type: 'error'
}

const value = encodeErrorResult({
  abi: [abiItem],
  errorName: 'InvalidTokenError', // [!code --]
  args: ['sold out']
})
// 0xb758934b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000
```

## Return Value

[`Hex`](/docs/glossary/types#hex)

The encoded error.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const value = decodeErrorResult({
  abi: wagmiAbi, // [!code focus]
  errorName: 'InvalidTokenError',
  args: ['sold out']
})
```

### errorName

- **Type:** `string`

The error name on the ABI.

```ts
const value = encodeErrorResult({
  abi: wagmiAbi,
  errorName: 'InvalidTokenError', // [!code focus]
  args: ['sold out']
})
```

### args (optional)

- **Type:** Inferred.

Arguments (if required) to pass to the error.

```ts
const value = encodeErrorResult({
  abi: wagmiAbi,
  errorName: 'InvalidTokenError',
  args: ['sold out'] // [!code focus]
})
```
</file>

<file path="contract/encodeEventTopics.md">
---
description: Encodes an event (with optional arguments) into filter topics.
---

# encodeEventTopics

Encodes an event (with optional arguments) into filter topics.

## Install

```ts
import { encodeEventTopics } from 'viem'
```

## Usage

Below is a very basic example of how to encode event topics without arguments.

:::code-group

```ts [example.ts]
import { encodeEventTopics } from 'viem'
import { wagmiAbi } from './abi.ts'

const topics = encodeEventTopics({
  abi: wagmiAbi,
  eventName: 'Transfer'
})
// ["0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0"]
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  ...
] as const;
```

:::

### Passing Arguments

If your event has indexed parameters, you can pass their values through with the `args` attribute.

TypeScript types for `args` will be inferred from the event name & ABI, to guard you from inserting the wrong values.

For example, the `Transfer` event below accepts an **address** argument for the `from` and `to` attributes, and it is typed as `"0x${string}"`.

:::code-group

```ts [example.ts]
import { encodeEventTopics } from 'viem'

const topics = encodeEventTopics({
  abi: wagmiAbi,
  eventName: 'Transfer'
  args: {
    from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8'
  }
})
// ["0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0", "0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266", "0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8"]
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  ...
] as const;
```

:::

### Without `eventName`

If your `abi` contains only one ABI item, you can omit the `eventName` (it becomes optional):

```ts
import { encodeEventTopics } from 'viem'

const abiItem = {
  inputs: [
    {
      indexed: true,
      name: 'from',
      type: 'address',
    },
    { indexed: true, name: 'to', type: 'address' },
    {
      indexed: false,
      name: 'value',
      type: 'uint256',
    },
  ],
  name: 'Transfer',
  type: 'event',
}

const topics = encodeEventTopics({
  abi: [abiItem],
  eventName: 'Transfer' // [!code --]
})
// ["0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0"]
```

## Return Value

Encoded topics.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const data = encodeEventTopics({
  abi: wagmiAbi, // [!code focus]
  functionName: 'Transfer',
})
```

### eventName

- **Type:** `string`

Name of the event.

```ts
const data = encodeEventTopics({
  abi: wagmiAbi,
  eventName: 'Transfer', // [!code focus]
})
```

### args (optional)

- **Type:** `string`

A list of _indexed_ event arguments.

```ts
const data = encodeEventTopics({
  abi: wagmiAbi,
  eventName: 'Transfer',
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```
</file>

<file path="contract/encodeFunctionData.md">
---
description: Encodes the function name and parameters into an ABI encoded value (4 byte selector & arguments).
---

# encodeFunctionData

Encodes the function name and parameters into an ABI encoded value (4 byte selector & arguments).

## Install

```ts
import { encodeFunctionData } from 'viem'
```

## Usage

Below is a very basic example of how to encode a function to calldata.

:::code-group

```ts [example.ts]
import { encodeFunctionData } from 'viem'
import { wagmiAbi } from './abi.ts'

const data = encodeFunctionData({
  abi: wagmiAbi,
  functionName: 'totalSupply'
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

:::

### Passing Arguments

If your function requires argument(s), you can pass them through with the `args` attribute.

TypeScript types for `args` will be inferred from the function name & ABI, to guard you from inserting the wrong values.

For example, the `balanceOf` function name below requires an **address** argument, and it is typed as `["0x${string}"]`.

:::code-group

```ts [example.ts]
import { encodeFunctionData } from 'viem'
import { wagmiAbi } from './abi'

const data = encodeFunctionData({
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

:::

### Without `functionName`

If your `abi` contains only one ABI item, you can omit the `functionName` (it becomes optional):

```ts
import { encodeFunctionData } from 'viem'

const abiItem = {
  inputs: [{ name: 'owner', type: 'address' }],
  name: 'balanceOf',
  outputs: [{ name: '', type: 'uint256' }],
  stateMutability: 'view',
  type: 'function',
}

const data = encodeFunctionData({
  abi: [abiItem],
  functionName: 'balanceOf', // [!code --]
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

### Preparation (Performance Optimization)

If you are calling the same function multiple times, you can prepare the function selector once and reuse it.

```ts
import { prepareEncodeFunctionData, encodeFunctionData } from 'viem'

const transfer = prepareEncodeFunctionData({
  abi: erc20Abi,
  functionName: 'transfer',
})

for (const address of addresses) {
  const data = encodeFunctionData({
    ...transfer,
    args: [address, 69420n],
  })
}
```

## Return Value

[`Hex`](/docs/glossary/types#hex)

ABI encoded data (4byte function selector & arguments).

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const data = encodeFunctionData({
  abi: wagmiAbi, // [!code focus]
  functionName: 'totalSupply',
})
```

### functionName

- **Type:** `string`

The function to encode from the ABI.

```ts
const data = encodeFunctionData({
  abi: wagmiAbi,
  functionName: 'totalSupply', // [!code focus]
})
```

### args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
const data = encodeFunctionData({
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC'] // [!code focus]
})
```
</file>

<file path="contract/encodeFunctionResult.md">
---
description: Encodes structured return data into ABI encoded data.
---

# encodeFunctionResult

Encodes structured return data into ABI encoded data. It is the opposite of [`decodeFunctionResult`](/docs/contract/decodeFunctionResult).

## Install

```ts
import { encodeFunctionResult } from 'viem';
```

## Usage

Given an ABI (`abi`) and a function (`functionName`), pass through the values (`values`) to encode:

:::code-group

```ts [example.ts]
import { encodeFunctionResult } from 'viem';
import { wagmiAbi } from './abi.ts'

const data = encodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf',
  value: ['0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'],
});
// '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac'
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    name: 'ownerOf',
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  ...
] as const;
```

:::

### A more complex example

:::code-group

```ts [example.ts]
import { decodeFunctionResult } from 'viem'

const data = decodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'getInfo',
  value: [
    {
      foo: {
        sender: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        x: 69420n,
        y: true
      },
      sender: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
      z: 69
    }
  ]
})
// 0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac0000000000000000000000000000000000000000000000000000000000010f2c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac0000000000000000000000000000000000000000000000000000000000000045
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: 'getInfo',
    outputs: [
      {
        components: [
          {
            components: [
              {
                name: 'sender',
                type: 'address',
              },
              {
                name: 'x',
                type: 'uint256',
              },
              {
                name: 'y',
                type: 'bool',
              },
            ],
            name: 'foo',
            type: 'tuple',
          },
          {
            name: 'sender',
            type: 'address',
          },
          {
            name: 'z',
            type: 'uint32',
          },
        ],
        name: 'res',
        type: 'tuple',
      },
    ],
    stateMutability: 'pure',
    type: 'function',
  },
  ...
] as const;
```

:::

### Without `functionName`

If your `abi` contains only one ABI item, you can omit the `functionName` (it becomes optional):

```ts
import { encodeFunctionResult } from 'viem';

const abiItem = {
  inputs: [{ name: 'owner', type: 'address' }],
  name: 'balanceOf',
  outputs: [{ name: '', type: 'uint256' }],
  stateMutability: 'view',
  type: 'function',
}

const data = encodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf', // [!code --]
  value: ['0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'],
});
// '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac'
```

## Return Value

The decoded data. Type is inferred from the ABI.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const data = encodeFunctionResult({
  abi: wagmiAbi, // [!code focus]
  functionName: 'ownerOf',
  value: ['0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'],
});
```

### functionName

- **Type:** `string`

The function to encode from the ABI.

```ts
const data = encodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf', // [!code focus]
  value: ['0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'],
});
```

### values

- **Type**: [`Hex`](/docs/glossary/types#hex)

Return values to encode.

```ts
const data = encodeFunctionResult({
  abi: wagmiAbi,
  functionName: 'ownerOf',
  value: ['0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'], // [!code focus]
});
```
</file>

<file path="contract/estimateContractGas.md">
---
description: Estimates the gas required to successfully execute a contract write function call.
---

# estimateContractGas

Estimates the gas required to successfully execute a contract write function call.

Internally, `estimateContractGas` uses a [Public Client](/docs/clients/public) to call the [`estimateGas` action](/docs/actions/public/estimateGas) with [ABI-encoded `data`](/docs/contract/encodeFunctionData).

## Usage

Below is a very basic example of how to estimate gas (with no arguments).

The `mint` function accepts no arguments, and returns a token ID.

:::code-group

```ts [example.ts]
import { account, publicClient } from './config'
import { wagmiAbi } from './abi'

const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
})
// 69420n
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "mint",
    outputs: [{ name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createPublicClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// JSON-RPC Account
export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
// Local Account
export const account = privateKeyToAccount(...)

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Passing Arguments

If your function requires argument(s), you can pass them through with the `args` attribute.

TypeScript types for `args` will be inferred from the function name & ABI, to guard you from inserting the wrong values.

For example, the `mint` function name below requires a **tokenId** argument, and it is typed as `[number]`.

:::code-group

```ts [example.ts] {8}
import { account, publicClient } from './config'
import { wagmiAbi } from './abi'

const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
})
// 69420n
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "owner", type: "uint32" }],
    name: "mint",
    outputs: [{ name: "", type: "uint32" }],
    stateMutability: "nonpayable",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createPublicClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// JSON-RPC Account
export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
// Local Account
export const account = privateKeyToAccount(...)

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Return Value

`bigint`

The gas estimate.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  abi: wagmiAbi,
  functionName: 'mint',
  account,
})
```

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi, // [!code focus]
  functionName: 'mint',
  account,
})
```

### functionName

- **Type:** `string`

A function to extract from the ABI.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint', // [!code focus]
  account,
})
```

### account

- **Type:** `Account | Address`

The Account to estimate gas from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266' // [!code focus]
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  accessList: [{ // [!code focus:4]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    storageKeys: ['0x1'],
  }],
  account,
})
```

### args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC'], // [!code focus]
  account,
})
```

### dataSuffix (optional)

- **Type:** `Hex`

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  dataSuffix: '0xdeadbeef' // [!code focus]
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
  gasPrice: parseGwei('20'), // [!code focus]
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
  maxFeePerGas: parseGwei('20'),  // [!code focus]
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
  nonce: 69 // [!code focus]
})
```

### value (optional)

- **Type:** `number`

Value in wei sent with this transaction.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
  value: parseEther('1') // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const gas = await publicClient.estimateContractGas({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
  blockTag: 'safe', // [!code focus]
})
```
</file>

<file path="contract/getCode.md">
---
description: Retrieves the bytecode at an address.
---

# getCode

Retrieves the bytecode at an address.

## Usage

:::code-group

```ts [example.ts]
import { publicClient } from './client'

const bytecode = await publicClient.getCode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
})
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Return Value

[`Hex`](/docs/glossary/types#hex)

The contract's bytecode.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const bytecode = await publicClient.getCode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the bytecode read against.

```ts
const bytecode = await publicClient.getCode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the bytecode read against.

```ts
const bytecode = await publicClient.getCode({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  blockTag: 'safe', // [!code focus]
})
```

## JSON-RPC Method

[`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)
</file>

<file path="contract/getContract.md">
---
description: A Contract Instance is a type-safe interface for performing contract-related actions with a specific ABI and address, created by the getContract function.
---

# Contract Instances

A Contract Instance is a type-safe interface for performing contract-related actions with a specific ABI and address, created by the `getContract` function.

## Import

```ts
import { getContract } from 'viem'
```

## Usage

You can create a Contract Instance with the `getContract` function by passing in a [ABI](/docs/glossary/types#abi), address, and [Public](/docs/clients/public) and/or [Wallet Client](/docs/clients/wallet). Once created, you can call contract methods, fetch for events, listen to events, etc.

:::code-group

```ts [example.ts]
import { getContract } from 'viem'
import { wagmiAbi } from './abi'
import { publicClient, walletClient } from './client'

// 1. Create contract instance
const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  // 1a. Insert a single client
  client: publicClient,
  // 1b. Or public and/or wallet clients
  client: { public: publicClient, wallet: walletClient }
})

// 2. Call contract methods, fetch events, listen to events, etc.
const result = await contract.read.totalSupply()
const logs = await contract.getEvents.Transfer()
const unwatch = contract.watchEvent.Transfer(
  { from: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e' },
  { onLogs(logs) { console.log(logs) } }
)
```

```ts [client.ts]
import { createPublicClient, createWalletClient, http, custom } from 'viem'
import { mainnet } from 'viem/chains'
import { EthereumProvider } from '@walletconnect/ethereum-provider'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
})

// eg: Metamask
export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!),
})

// eg: WalletConnect
const provider = await EthereumProvider.init({
  projectId: "abcd1234",
  showQrModal: true,
  chains: [1],
})

export const walletClientWC = createWalletClient({
  chain: mainnet,
  transport: custom(provider),
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: 'totalSupply',
    outputs: [{ type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    name: 'Transfer',
    type: 'event',
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: true,
        name: 'tokenId',
        type: 'uint256',
      },
    ],
  },
  ...
] as const;
```

:::

Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properties every time you perform contract actions, e.g. [`readContract`](/docs/contract/readContract), [`writeContract`](/docs/contract/writeContract), [`estimateContractGas`](/docs/contract/estimateContractGas), etc. Switch between the tabs below to see the difference between standalone Contract Actions and Contract Instance Actions:

:::code-group

```ts [contract-instance.ts]
import { getContract } from 'viem'
import { wagmiAbi } from './abi'
import { publicClient, walletClient } from './client'

const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  client: {
    public: publicClient,
    wallet: walletClient,
  }
})

const balance = await contract.read.balanceOf([
  '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
])
const hash = await contract.write.mint([69420])
const logs = await contract.getEvents.Transfer()
const unwatch = contract.watchEvent.Transfer(
  {
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  { onLogs: logs => console.log(logs) }
)
```

```ts [contract-actions.ts]
import { wagmiAbi } from './abi'
import { publicClient, walletClient } from './client'

const balance = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
const hash = await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420]
})
const unwatch = publicClient.watchContractEvent({
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
  abi: wagmiAbi,
  eventName: 'Transfer',
  args: {
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  onLogs: logs => console.log(logs)
})
```

:::

:::tip
While Contract Instances are great for reducing code duplication, they pull in multiple contract actions (e.g. `createContractEventFilter`, `estimateContractGas`, `readContract`, `simulateContract`, `watchContractEvent`, `writeContract`), so they can be a bit heavier than individual calls. If you only need a couple contract methods and you care about minimizing bundle size to the fullest extent, you may want to use individual calls instead.
:::

## Return Value

Contract instance object. Type is inferred.

Depending on if you create a contract instance with a Public Client, Wallet Client, or both, the methods available on the contract instance will vary.

#### With Public Client

If you pass in a [`publicClient`](https://viem.sh/docs/clients/public), the following methods are available:

- [`createEventFilter`](/docs/contract/createContractEventFilter)
- [`estimateGas`](/docs/contract/estimateContractGas)
- [`getEvents`](/docs/contract/getContractEvents)
- [`read`](/docs/contract/readContract)
- [`simulate`](/docs/contract/simulateContract)
- [`watchEvent`](/docs/contract/watchContractEvent)

#### With Wallet Client

If you pass in a [`walletClient`](/docs/clients/wallet), the following methods are available:

- [`estimateGas`](/docs/contract/estimateContractGas)
- [`write`](/docs/contract/writeContract)

#### Calling methods

If you are using [TypeScript](/docs/typescript) with viem, your editor will be able to provide autocomplete suggestions for the methods available on the contract instance, as well as the arguments and other options for each method.

In general, contract instance methods follow the following format:

```ts
// function
contract.(estimateGas|read|simulate|write).(functionName)(args, options)

// event
contract.(createEventFilter|getEvents|watchEvent).(eventName)(args, options)
```

If the contract function/event you are using does not accept arguments (e.g. function has no inputs, event has no indexed inputs), then you can omit the `args` parameter so `options` is the first and only parameter.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  abi: wagmiAbi,
  client: publicClient
})
```

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi, // [!code focus]
  client: publicClient
})
```

### client

- **Type:** [`Client | { public: Client; wallet: Client }`](/docs/clients/public)

The Client used for performing [contract actions](/docs/contract/getContract#return-value).

```ts
const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  client: publicClient, // [!code focus]
})
```

You can also pass in multiple clients (ie. a Wallet Client and a Public Client):

```ts
const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  client: { // [!code focus]
    public: publicClient, // [!code focus]
    wallet: walletClient // [!code focus]
  }, // [!code focus]
})
```
</file>

<file path="contract/getContractEvents.md">
---
description: Returns a list of event logs matching the provided parameters. 
---

# getContractEvents

Returns a list of contract **event logs** matching the provided parameters.

## Usage

By default, `getContractEvents` returns all matched events on the ABI. In practice, you must use scoping to filter for specific events.

:::code-group

```ts [example.ts]
import { publicClient } from './client'
import { erc20Abi } from './abi'

// Fetch event logs for every event on every ERC-20 contract. // [!code focus:99]
const logs = await publicClient.getContractEvents({ 
  abi: erc20Abi 
})
// [{ ... }, { ... }, { ... }]
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      {
        indexed: true,
        name: 'to',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Scoping

You can also scope to a set of given attributes.

:::code-group

```ts [example.ts]
import { parseAbiItem } from 'viem'
import { publicClient } from './client'
import { erc20Abi } from './abi'

const usdcContractAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' // [!code focus:99]

const logs = await publicClient.getContractEvents({ 
  address: usdcContractAddress,
  abi: erc20Abi,
  eventName: 'Transfer',
  args: {
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  fromBlock: 16330000n,
  toBlock: 16330050n
})
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      {
        indexed: true,
        name: 'to',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Address

Logs can be scoped to an **address**:

:::code-group

```ts [example.ts]
import { publicClient } from './client'
import { erc20Abi } from './abi'

const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', // [!code focus]
})
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      {
        indexed: true,
        name: 'to',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Event

Logs can be scoped to an **event**.

:::code-group

```ts [example.ts]
import { parseAbiItem } from 'viem' // [!code focus]
import { publicClient } from './client'
import { erc20Abi } from './abi'

const logs = await publicClient.getContractEvents({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  abi: erc20Abi,
  eventName: 'Transfer', // [!code focus]
})
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      {
        indexed: true,
        name: 'to',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Arguments

Logs can be scoped to given **_indexed_ arguments**:

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  eventName: 'Transfer',
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  }
})
```

Only indexed arguments in `event` are candidates for `args`.

An argument can also be an array to indicate that other values can exist in the position:

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  eventName: 'Transfer',
  args: { // [!code focus:8]
    // '0xd8da...' OR '0xa5cc...' OR '0xa152...'
    from: [
      '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 
      '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',
      '0xa152f8bb749c55e9943a3a0a3111d18ee2b3f94e',
    ],
  }
})
```

### Block Range

Logs can be scoped to a **block range**:

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  eventName: 'Transfer',
  fromBlock: 16330000n, // [!code focus]
  toBlock: 16330050n // [!code focus]
})
```

### Strict Mode

By default, `getContractEvents` will include logs that [do not conform](/docs/glossary/terms#non-conforming-log) to the indexed & non-indexed arguments on the `event`.
viem will not return a value for arguments that do not conform to the ABI, thus, some arguments on `args` may be undefined.

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  eventName: 'Transfer',
})

logs[0].args // [!code focus]
//      ^? { address?: Address, to?: Address, value?: bigint } // [!code focus]
```

You can turn on `strict` mode to only return logs that conform to the indexed & non-indexed arguments on the `event`, meaning that `args` will always be defined. The trade-off is that non-conforming logs will be filtered out.

```ts 
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  eventName: 'Transfer',
  strict: true
})

logs[0].args // [!code focus]
//      ^? { address: Address, to: Address, value: bigint } // [!code focus]
```

## Returns

[`Log[]`](/docs/glossary/types#log)

A list of event logs.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi, // [!code focus]
})
```

### address

- **Type:** [`Address | Address[]`](/docs/glossary/types#address)

A contract address or a list of contract addresses. Only logs originating from the contract(s) will be included in the result.

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
})
```

### eventName

- **Type:** `string`

An event name on the `abi`.

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  eventName: 'Transfer' // [!code focus]
})
```

### args

- **Type:** Inferred.

A list of _indexed_ event arguments.

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  eventName: 'Transfer',
  args: { // [!code focus:4]
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
})
```

### fromBlock

- **Type:** `bigint | 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Block to start including logs from. Mutually exclusive with `blockHash`.

```ts
const filter = await publicClient.getContractEvents({
  abi: erc20Abi,
  fromBlock: 69420n // [!code focus]
})
```

### toBlock

- **Type:** `bigint | 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Block to stop including logs from. Mutually exclusive with `blockHash`.

```ts
const filter = await publicClient.getContractEvents({
  abi: erc20Abi,
  toBlock: 70120n // [!code focus]
})
```

### blockHash

- **Type:** `'0x${string}'`

Block hash to include logs from. Mutually exclusive with `fromBlock`/`toBlock`.

```ts
const logs = await publicClient.getContractEvents({
  abi: erc20Abi,
  blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d' // [!code focus]
})
```

## JSON-RPC Method

[`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getLogs)
</file>

<file path="contract/getStorageAt.md">
---
description: Returns the value from a storage slot at a given address.
---

# getStorageAt

Returns the value from a storage slot at a given address.

## Usage

:::code-group

```ts [example.ts]
import { toHex } from 'viem'
import { wagmiAbi } from './abi'
import { publicClient } from './client'

const data = await publicClient.getStorageAt({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: toHex(0)
})
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Return Value

[`Hex`](/docs/glossary/types#hex)

The value of the storage slot.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const data = await publicClient.getStorageAt({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  slot: toHex(0)
})
```

### slot

- **Type**: [`Hex`](/docs/glossary/types#hex)

The storage position (as a hex encoded value).

```ts
const data = await publicClient.getStorageAt({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: toHex(0) // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the storage slot read against.

```ts
const bytecode = await publicClient.getStorageAt({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: toHex(0),
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the storage slot read against.

```ts
const bytecode = await publicClient.getStorageAt({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  slot: toHex(0),
  blockTag: 'safe', // [!code focus]
})
```

## JSON-RPC Method

[`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)
</file>

<file path="contract/multicall.md">
# multicall [Batches up multiple functions on a contract in a single call.]

Similar to [`readContract`](/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). 

## Usage

:::code-group

```ts [example.ts]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const wagmiContract = {
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi
} as const

const results = await publicClient.multicall({
  contracts: [
    {
      ...wagmiContract,
      functionName: 'totalSupply',
    },
    {
      ...wagmiContract,
      functionName: 'ownerOf',
      args: [69420n]
    },
    {
      ...wagmiContract,
      functionName: 'mint'
    }
  ]
})
/**
 * [
 *  { result: 424122n, status: 'success' },
 *  { result: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b', status: 'success' },
 *  { error: [ContractFunctionExecutionError: ...], status: 'failure' }
 * ]
 */
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ name: "tokenId", type: "uint256" }],
    name: "ownerOf",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "mint",
    outputs: [],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Return Value

`({ data: <inferred>, status: 'success' } | { error: string, status: 'reverted' })[]`

An array of results with accompanying status.

Additionally, when [`allowFailure`](#allowfailure-optional) is set to `false`, it directly returns an array of inferred data:

`(<inferred>)[]`

## Parameters

### contracts.address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
      abi: wagmiAbi,
      functionName: 'totalSupply',
    },
    ...
  ]
})
```

### contracts.abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract ABI.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi, // [!code focus]
      functionName: 'totalSupply',
    },
    ...
  ]
})
```

### contracts.functionName

- **Type**: `string`

The function name to call.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'totalSupply', // [!code focus]
    },
    ...
  ]
})
```

### contracts.args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'balanceOf',
      args: ['0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b'] // [!code focus]
    },
    ...
  ]
})
```

### allowFailure (optional)

- **Type:** `boolean`
- **Default:** `true`

Whether or not the `multicall` function should throw if a call reverts. If set to `true` (default), and a call reverts, then `multicall` will fail silently and its error will be logged in the `results` array.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'totalSupply',
    },
    ...
  ],
  allowFailure: false // [!code focus]
})
```

### batchSize (optional)

- **Type:** `number`
- **Default:** [`client.batch.multicall.batchSize`](/docs/clients/public#batch-multicall-batchsize-optional) (if set) or `1024`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'totalSupply',
    },
    ...
  ],
  batchSize: 4096 // 4kB // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'totalSupply',
    },
    ...
  ],
  blockNumber: 15121123n, // [!code focus]
})
```

### multicallAddress (optional)

- **Type:** [`Address`](/docs/glossary/types#address)
- **Default:** `client.chain.contracts.multicall3.address`

Address of Multicall Contract.

```ts
const results = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'totalSupply',
    },
    ...
  ],
  multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11' // [!code focus]
})
```

### stateOverride (optional)

- **Type:** [`StateOverride`](/docs/glossary/types#stateoverride)

The state override set is an optional address-to-state mapping, where each entry specifies some state to be ephemerally overridden prior to executing the call.

```ts
const data = await publicClient.multicall({
  contracts: [
    {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: wagmiAbi,
      functionName: 'totalSupply',
    },
    ...
  ],
  stateOverride: [ // [!code focus]
    { // [!code focus]
      address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
      balance: parseEther('1'), // [!code focus]
      stateDiff: [ // [!code focus]
        { // [!code focus]
          slot: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0', // [!code focus]
          value: '0x00000000000000000000000000000000000000000000000000000000000001a4', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    } // [!code focus]
  ], // [!code focus]
})
```

## Live Example

Check out the usage of `multicall` in the live [Multicall Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_multicall) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_multicall?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="contract/parseEventLogs.md">
---
description: 'Extracts & decodes logs from a set of opaque logs.'
---

# parseEventLogs

Extracts & decodes logs matching the provided `abi` (and optional `eventName`) from a set of opaque logs.

Useful for decoding logs on Transaction Receipts.

## Install

```ts
import { parseEventLogs } from 'viem'
```

## Usage

:::code-group

```ts [example.ts]
import { parseEventLogs } from 'viem'
import { erc20Abi } from './abi'
import { client } from './client'

const receipt = await getTransactionReceipt(client, {
  hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
})

const logs = parseEventLogs({ 
  abi: erc20Abi, 
  logs: receipt.logs,
})
// [
//   { args: { ... }, eventName: 'Transfer', logIndex: 3 ... },  
//   { args: { ... }, eventName: 'Approval', logIndex: 5 ... },
//   ...
// ]
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  {
    inputs: [
      {
        indexed: true,
        name: 'owner',
        type: 'address',
      },
      {
        indexed: true,
        name: 'spender',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Approval',
    type: 'event',
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Scoping to Event Name(s)

You can scope the logs to a specific event name by providing the `eventName` argument:

:::code-group

```ts [example.ts]
import { parseEventLogs } from 'viem'
import { erc20Abi } from './abi'
import { client } from './client'

const receipt = await getTransactionReceipt(client, {
  hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
})

const logs = parseEventLogs({ 
  abi: erc20Abi, 
  eventName: 'Transfer', // [!code hl]
  logs: receipt.logs,
})
// [
//   { args: { ... }, eventName: 'Transfer', logIndex: 3, ... },  
//   { args: { ... }, eventName: 'Transfer', logIndex: 7, ... },
//   ...
// ]
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  {
    inputs: [
      {
        indexed: true,
        name: 'owner',
        type: 'address',
      },
      {
        indexed: true,
        name: 'spender',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Approval',
    type: 'event',
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

You can also pass an array to scope multiple event names:

:::code-group

```ts [example.ts]
import { parseEventLogs } from 'viem'
import { erc20Abi } from './abi'
import { client } from './client'

const receipt = await getTransactionReceipt(client, {
  hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
})

const logs = parseEventLogs({ 
  abi: erc20Abi, 
  eventName: ['Transfer', 'Approval'], // [!code hl]
  logs: receipt.logs,
})
// [
//   { args: { ... }, eventName: 'Transfer', logIndex: 3, ... },  
//   { args: { ... }, eventName: 'Approval', logIndex: 5, ... },  
//   { args: { ... }, eventName: 'Transfer', logIndex: 7, ... },
//   ...
// ]
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  {
    inputs: [
      {
        indexed: true,
        name: 'owner',
        type: 'address',
      },
      {
        indexed: true,
        name: 'spender',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Approval',
    type: 'event',
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Scoping to Arguments

You can scope the logs to arguments by providing the `args` argument:

:::code-group

```ts [example.ts]
import { parseEventLogs } from 'viem'
import { erc20Abi } from './abi'
import { client } from './client'

const receipt = await getTransactionReceipt(client, {
  hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
})

const logs = parseEventLogs({ 
  abi: erc20Abi, 
  args: { // [!code focus]
    from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  }, // [!code focus]
  logs: receipt.logs,
})
// [
//   { args: { from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', ... }, eventName: '...', logIndex: 3, ... },  
//   { args: { from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', ... }, eventName: '...', logIndex: 7, ... },
//   ...
// ]
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  {
    inputs: [
      {
        indexed: true,
        name: 'owner',
        type: 'address',
      },
      {
        indexed: true,
        name: 'spender',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Approval',
    type: 'event',
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

You can also pass an array to scope multiple values of an argument:

:::code-group

```ts [example.ts]
import { parseEventLogs } from 'viem'
import { erc20Abi } from './abi'
import { client } from './client'

const receipt = await getTransactionReceipt(client, {
  hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
})

const logs = parseEventLogs({ 
  abi: erc20Abi, 
  args: { // [!code focus]
    from: [ // [!code focus]
      '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
      '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', // [!code focus]
    ], // [!code focus]
  }, // [!code focus]
  logs: receipt.logs,
})
// [
//   { args: { from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', ... }, eventName: '...', logIndex: 3, ... },  
//   { args: { from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', ... }, eventName: '...', logIndex: 7, ... },
//   ...
// ]
```

```ts [abi.ts]
export const erc20Abi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: 'from',
        type: 'address',
      },
      { indexed: true, name: 'to', type: 'address' },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Transfer',
    type: 'event',
  },
  {
    inputs: [
      {
        indexed: true,
        name: 'owner',
        type: 'address',
      },
      {
        indexed: true,
        name: 'spender',
        type: 'address',
      },
      {
        indexed: false,
        name: 'value',
        type: 'uint256',
      },
    ],
    name: 'Approval',
    type: 'event',
  }
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Partial Decode

By default, if the `topics` and `data` does not conform to the ABI (a mismatch between the number of indexed/non-indexed arguments), `parseEventLogs` will not return return the decoded log.

For example, the following will not return the nonconforming log as there is a mismatch in non-`indexed` arguments & `data` length.

```ts
parseEventLogs({
  abi: parseAbi(['event Transfer(address indexed, address, uint256)']),
  logs: [{
    // `data` should be 64 bytes, but is only 32 bytes. // [!code hl]
    data: '0x0000000000000000000000000000000000000000000000000000000000000001', // [!code hl]
    topics: [
      '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
      '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    ]
    // ...
  }]
})
// []
```

It is possible for `parseEventLogs` to try and partially decode the Log, this can be done by setting the `strict` argument to `false`:

```ts
parseEventLogs({
  abi: parseAbi(['event Transfer(address indexed, address, uint256)']),
  logs: [{
    data: '0x0000000000000000000000000000000000000000000000000000000000000001',
    topics: [
      '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
      '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    ]
    // ...
  }]
  strict: false // [!code ++]
})
/**
 * [
 *  {
 *    eventName: 'Transfer',
 *    args: ['0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'],
 *    blockNumber: 42069420n,
 *    logIndex: 69,
 *    ...
 *  }
 * ]
 */
```

## Return Value

`Log[]`

Decoded logs.

## Parameters

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const topics = parseEventLogs({
  abi: wagmiAbi, // [!code focus]
  logs: [{
    blockNumber: 69420n,
    data: '0x0000000000000000000000000000000000000000000000000000000000000001',
    logIndex: 1,
    topics: [
      '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
      '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
    ]
    // ...
  }]
})
```

### logs

- **Type:** `Log[]`

An array of logs to parse.

```ts
const topics = parseEventLogs({
  abi: wagmiAbi,
  logs: [{ // [!code focus]
    blockNumber: 69420n, // [!code focus]
    data: '0x0000000000000000000000000000000000000000000000000000000000000001', // [!code focus]
    logIndex: 1, // [!code focus]
    topics: [ // [!code focus]
      '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',  // [!code focus]
      '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
      '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8' // [!code focus]
    ] // [!code focus]
    // ... // [!code focus]
  }] // [!code focus]
})
```

### args (optional)

- **Type:** `{ [property: string]: string | string[] | null }`

Arguments to scope the logs to.

```ts
const topics = parseEventLogs({
  abi: wagmiAbi,
  args: { // [!code focus]
    from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]
  }, // [!code focus]
  logs: [{
    blockNumber: 69420n,
    data: '0x0000000000000000000000000000000000000000000000000000000000000001',
    logIndex: 1,
    topics: [
      '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
      '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
    ]
    // ...
  }]
})
```

### eventName (optional)

- **Type:** `string`

An event name from the ABI.

```ts
const topics = parseEventLogs({
  abi: wagmiAbi,
  eventName: 'Transfer', // [!code focus]
  logs: [{
    blockNumber: 69420n,
    data: '0x0000000000000000000000000000000000000000000000000000000000000001',
    logIndex: 1,
    topics: [
      '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
      '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
    ]
    // ...
  }]
})
```

### strict (optional)

- **Type:** `boolean`
- **Default:** `true`

If `true`, `parseEventLogs` will not return [nonconforming logs](#partial-decode). 
If `false`, `parseEventLogs` will try and [partially decode](#partial-decode) nonconforming logs.

```ts
const topics = parseEventLogs({
  abi: wagmiAbi,
  eventName: 'Transfer',
  logs: [{
    blockNumber: 69420n,
    data: '0x0000000000000000000000000000000000000000000000000000000000000001',
    logIndex: 1,
    topics: [
      '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0', 
      '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'
    ]
    // ...
  }],
  strict: false // [!code focus]
})
```
</file>

<file path="contract/readContract.md">
---
description: Calls a read-only function on a contract, and returns the response.
---

# readContract

Calls a read-only function on a contract, and returns the response.

A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

Internally, `readContract` uses a [Public Client](/docs/clients/public) to call the [`call` action](/docs/actions/public/call) with [ABI-encoded `data`](/docs/contract/encodeFunctionData).

## Usage

Below is a very basic example of how to call a read-only function on a contract (with no arguments).

:::code-group

```ts [example.ts]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
})
// 69420n
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Passing Arguments

If your function requires argument(s), you can pass them through with the `args` attribute.

TypeScript types for `args` will be inferred from the function name & ABI, to guard you from inserting the wrong values.

For example, the `balanceOf` function name below requires an **address** argument, and it is typed as `["0x${string}"]`.

:::code-group

```ts [example.ts] {8}
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Deployless Reads

It is possible to call a function on a contract that has not been deployed yet. For instance, we may want
to call a function on an [ERC-4337 Smart Account](https://eips.ethereum.org/EIPS/eip-4337) contract which has not been deployed.

Viem offers two ways of performing a Deployless Call, via:

- [Bytecode](#bytecode)
- a [Deploy Factory](#deploy-factory): "temporarily deploys" a contract with a provided [Deploy Factory](https://docs.alchemy.com/docs/create2-an-alternative-to-deriving-contract-addresses#create2-contract-factory), and calls the function on the deployed contract.

:::tip
The **Deployless Call** pattern is also accessible via the [Contract Instance](/docs/contract/getContract) API.
:::

#### Bytecode

The example below demonstrates how we can utilize a Deployless Call **via Bytecode** to call the `name` function on the [Wagmi Example ERC721 contract](https://etherscan.io/address/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2#code) which has not been deployed:

:::code-group

```ts twoslash [example.ts]
import { parseAbi } from 'viem'
import { publicClient } from './config'

const data = await publicClient.readContract({
  abi: parseAbi(['function name() view returns (string)']),
  code: '0x...', // Accessible here: https://etherscan.io/address/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2#code
  functionName: 'name'
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

#### Deploy Factory

The example below demonstrates how we can utilize a Deployless Call **via a [Deploy Factory](https://docs.alchemy.com/docs/create2-an-alternative-to-deriving-contract-addresses#create2-contract-factory)** to call the `entryPoint` function on an [ERC-4337 Smart Account](https://eips.ethereum.org/EIPS/eip-4337) which has not been deployed:

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData, parseAbi } from 'viem'
import { account, publicClient } from './config'

const data = await publicClient.readContract({
  // Address of the Smart Account deployer (factory).
  factory: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',

  // Function to execute on the factory to deploy the Smart Account.
  factoryData: encodeFunctionData({
    abi: parseAbi(['function createAccount(address owner, uint256 salt)']),
    functionName: 'createAccount',
    args: [account, 0n],
  }),

  // Function to call on the Smart Account.
  abi: account.abi,
  address: account.address,
  functionName: 'entryPoint',
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, http, parseAbi } from 'viem'
import { mainnet } from 'viem/chains'

export const account = {
  address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  abi: parseAbi(['function entryPoint() view returns (address)'])
} as const

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

:::note
This example utilizes the [SimpleAccountFactory](https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccountFactory.sol).
:::

## Return Value

The response from the contract. Type is inferred.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  abi: wagmiAbi,
  functionName: 'totalSupply',
})
```

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi, // [!code focus]
  functionName: 'totalSupply',
})
```

### functionName

- **Type:** `string`

A function to extract from the ABI.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply', // [!code focus]
})
```

### args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
const data = await publicClient.readContract({
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC'] // [!code focus]
})
```

### account (optional)

- **Type:** `Account | Address`

Optional Account sender override.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266' // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
  blockTag: 'safe', // [!code focus]
})
```

### factory (optional)

- **Type:**

Contract deployment factory address (ie. Create2 factory, Smart Account factory, etc).

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
  factory: '0x0000000000ffe8b47b3e2130213b802212439497', // [!code focus]
  factoryData: '0xdeadbeef',
})
```

### factoryData (optional)

- **Type:**

Calldata to execute on the factory to deploy the contract.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
  factory: '0x0000000000ffe8b47b3e2130213b802212439497',
  factoryData: '0xdeadbeef', // [!code focus]
})
```

### stateOverride (optional)

- **Type:** [`StateOverride`](/docs/glossary/types#stateoverride)

The state override set is an optional address-to-state mapping, where each entry specifies some state to be ephemerally overridden prior to executing the call.

```ts
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
  stateOverride: [ // [!code focus]
    { // [!code focus]
      address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
      balance: parseEther('1'), // [!code focus]
      stateDiff: [ // [!code focus]
        { // [!code focus]
          slot: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0', // [!code focus]
          value: '0x00000000000000000000000000000000000000000000000000000000000001a4', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    } // [!code focus]
  ], // [!code focus]
})
```

## Live Example

Check out the usage of `readContract` in the live [Reading Contracts Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="contract/simulateContract.md">
# simulateContract [Simulates & validates a contract interaction.]

The `simulateContract` function **simulates**/**validates** a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.

This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](/docs/contract/readContract), but also supports contract write functions.

Internally, `simulateContract` uses a [Public Client](/docs/clients/public) to call the [`call` action](/docs/actions/public/call) with [ABI-encoded `data`](/docs/contract/encodeFunctionData).

## Usage

Below is a very basic example of how to simulate a write function on a contract (with no arguments).

The `mint` function accepts no arguments, and returns a token ID.

:::code-group

```ts [example.ts]
import { account, publicClient } from './config'
import { wagmiAbi } from './abi'

const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "mint",
    outputs: [{ name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createPublicClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// JSON-RPC Account
export const [account] = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
// Local Account
export const account = privateKeyToAccount(...)

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Passing Arguments

If your function requires argument(s), you can pass them through with the `args` attribute.

TypeScript types for `args` will be inferred from the function name & ABI, to guard you from inserting the wrong values.

For example, the `mint` function name below requires a **tokenId** argument, and it is typed as `[number]`.

:::code-group

```ts [example.ts]
import { account, publicClient } from './config'
import { wagmiAbi } from './abi'

const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420], // [!code focus]
  account,
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "owner", type: "uint32" }],
    name: "mint",
    outputs: [{ name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createPublicClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// JSON-RPC Account
export const [account] = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
// Local Account
export const account = privateKeyToAccount(...)

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Pairing with `writeContract`

The `simulateContract` function also pairs well with `writeContract`.

In the example below, we are **validating** if the contract write will be successful via `simulateContract`. If no errors are thrown, then we are all good. After that, we perform a contract write to execute the transaction.

:::code-group

```ts [example.ts]
import { account, walletClient, publicClient } from './config'
import { wagmiAbi } from './abi'

const { request } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
})
const hash = await walletClient.writeContract(request)
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "mint",
    outputs: [{ name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createPublicClient, custom, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// JSON-RPC Account
export const [account] = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
// Local Account
export const account = privateKeyToAccount(...)

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Handling Custom Errors

In the example below, we are **catching** a [custom error](https://blog.soliditylang.org/2021/04/21/custom-errors/) thrown by the `simulateContract`. It is important to include the custom error item in the contract `abi`.

You can access the custom error through the `data` attribute of the error:

:::code-group

```ts [example.ts] {13-27}
import { BaseError, ContractFunctionRevertedError } from 'viem';
import { account, walletClient, publicClient } from './config'
import { wagmiAbi } from './abi'

try {
  await publicClient.simulateContract({
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    abi: wagmiAbi,
    functionName: 'mint',
    account,
  })
} catch (err) {
  if (err instanceof BaseError) {
    const revertError = err.walk(err => err instanceof ContractFunctionRevertedError)
    if (revertError instanceof ContractFunctionRevertedError) {
      const errorName = revertError.data?.errorName ?? ''
      // do something with `errorName`
    }
  }
}

```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "mint",
    outputs: [{ name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function",
  },
  // Custom solidity error
  {
    type: 'error',
    inputs: [],
    name: 'MintIsDisabled'
  },
  ...
] as const;
```

```solidity [WagmiExample.sol]
// ...
error MintIsDisabled();
contract WagmiExample {
  // ...

    function mint() public {
      // ...
      revert MintIsDisabled();
      // ...
    }

  // ...
}
```

```ts [config.ts]
import { createPublicClient, custom, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// JSON-RPC Account
export const [account] = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
// Local Account
export const account = privateKeyToAccount(...)

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### State Overrides

When using `simulateContract`, there sometimes needs to be an initial state change to make the transaction pass. A common use case would be an approval. For that, there are [state overrides](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-eth#eth-call). In the example below, we are simulating sending a token on behalf of another user. To do this, we need to modify the state of the token contract to have maximum approve from the token owner.

:::code-group

```ts twoslash [example.ts]
import { account, publicClient } from './config'
import { abi, address } from './contract'

// Allowance slot: A 32 bytes hex string representing the allowance slot of the sender.
const allowanceSlot = '0x....'

// Max allowance: A 32 bytes hex string representing the maximum allowance (2^256 - 1)
const maxAllowance = numberToHex(maxUint256)

const { result } = await publicClient.simulateContract({
  abi,
  address,
  account,
  functionName: 'transferFrom',
  args: [
    '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
    account.address, 
    69420n
  ],
  stateOverride: [ // [!code hl]
    { // [!code hl]
      // modifying the state of the token contract // [!code hl]
      address, // [!code hl]
      stateDiff: [ // [!code hl]
        { // [!code hl]
          slot: allowanceSlot, // [!code hl]
          value: maxAllowance, // [!code hl]
        }, // [!code hl]
      ], // [!code hl]
    }, // [!code hl]
  ], // [!code hl]
})

console.log(result)
// @log: Output: true
```

```ts twoslash [contract.ts] filename="contract.ts"
export const address = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

export const abi = [
  {
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: 'sender',
        type: 'address',
      },
      {
        name: 'recipient',
        type: 'address',
      },
      {
        name: 'amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        type: 'bool',
      },
    ],
  },
] as const
```

```ts twoslash [config.ts] filename="config.ts"
import { createPublicClient, custom, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const account = privateKeyToAccount('0x...')
 
export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Return Value

The simulation result and write request. Type is inferred.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  abi: wagmiAbi,
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
})
```

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi, // [!code focus]
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
})
```

### functionName

- **Type:** `string`

A function to extract from the ABI.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint', // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
})
```

### account

- **Type:** `Account | Address | null`

The Account to simulate the contract method from.

Accepts a [JSON-RPC Account](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc). If set to `null`, it is assumed that the transport will handle the filling the sender of the transaction.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266' // [!code focus]
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  accessList: [{ // [!code focus:4]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    storageKeys: ['0x1'],
  }],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
})
```

### authorizationList (optional)

- **Type:** `AuthorizationList`

Signed EIP-7702 Authorization list.

```ts
const authorization = await walletClient.signAuthorization({ 
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
}) 

const { result } = await publicClient.simulateContract({
  address: account.address,
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  authorizationList: [authorization], // [!code focus]
})
```

:::note
**References**
- [EIP-7702 Overview](/docs/eip7702)
- [`signAuthorization` Docs](/docs/eip7702/signAuthorization)
:::

### args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
const { result } = await publicClient.simulateContract({
  address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC'], // [!code focus]
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  blockTag: 'safe', // [!code focus]
})
```

### dataSuffix (optional)

- **Type:** `Hex`

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  dataSuffix: '0xdeadbeef' // [!code focus]
})
```

### gas (optional)

- **Type:** `bigint`

The gas limit for the transaction.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  gas: 69420n, // [!code focus]
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  gasPrice: parseGwei('20'), // [!code focus]
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  maxFeePerGas: parseGwei('20'),  // [!code focus]
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  nonce: 69 // [!code focus]
})
```

### stateOverride (optional)

- **Type:** [`StateOverride`](/docs/glossary/types#stateoverride)

The state override set is an optional address-to-state mapping, where each entry specifies some state to be ephemerally overridden prior to executing the call.

> Note: By using state overrides, you simulate the contract based on a fake state. Using this is useful for testing purposes, but making a transaction based on the returned `request` object might fail regardless of the simulation result.

```ts
const data = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  stateOverride: [ // [!code focus]
    { // [!code focus]
      address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', // [!code focus]
      balance: parseEther('1'), // [!code focus]
      stateDiff: [ // [!code focus]
        { // [!code focus]
          slot: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0', // [!code focus]
          value: '0x00000000000000000000000000000000000000000000000000000000000001a4', // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    } // [!code focus]
  ], // [!code focus]
})
```

### value (optional)

- **Type:** `number`

Value in wei sent with this transaction.

```ts
const { result } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
  value: parseEther('1') // [!code focus]
})
```

## Live Example

Check out the usage of `simulateContract` in the live [Writing to Contracts Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="contract/watchContractEvent.md">
---
description: Watches and returns emitted contract event logs.
---

# watchContractEvent

Watches and returns emitted contract event logs.

This Action will batch up all the event logs found within the [`pollingInterval`](#pollinginterval-optional), and invoke them via [`onLogs`](#onlogs).

`watchContractEvent` will attempt to create an [Event Filter](/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (ie. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](/docs/actions/public/getLogs) instead.

## Usage

:::code-group

```ts [example.ts]
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  onLogs: logs => console.log(logs)
})
// > [{ ... }, { ... }, { ... }]
// > [{ ... }, { ... }]
// > [{ ... }, { ... }, { ... }, { ... }]
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Scoping to an Event Name

You can scope to an event on the given ABI.

:::code-group

```ts [example.ts] {8}
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  eventName: 'Transfer',
  onLogs: logs => console.log(logs)
})
// > [{ ... }, { ... }, { ... }]
// > [{ ... }, { ... }]
// > [{ ... }, { ... }, { ... }, { ... }]
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address",
      },
      { indexed: true, name: "to", type: "address" },
      {
        indexed: true,
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

### Scoping to Event Arguments

You can scope to given **indexed event arguments**.

In the example below, we want to filter out `Transfer`s that were sent by the address `"0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b"`.

> Only **`indexed`** arguments on the event ABI are candidates for `args` (see `abi.ts`).

:::code-group

```ts [example.ts] {8-9}
import { publicClient } from './client'
import { wagmiAbi } from './abi'

const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  eventName: 'Transfer',
  args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },
  onLogs: logs => console.log(logs)
})
// > [{ ... }, { ... }, { ... }]
// > [{ ... }, { ... }]
// > [{ ... }, { ... }, { ... }, { ... }]
```

```ts [abi.ts] {6-8}
export const wagmiAbi = [
  ...
  {
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address",
      },
      { 
        indexed: true, 
        name: "to", 
        type: "address" 
      },
      {
        indexed: false,
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  ...
] as const;
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`UnwatchFn`

A function that can be invoked to stop watching for new event logs.

## Arguments

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi, // [!code focus]
  onLogs: logs => console.log(logs)
})
```

### onLogs

- **Type:** `(Log[]) => void`

The new event logs.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  onLogs: logs => console.log(logs) // [!code focus]
})
```

### address (optional)

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address. If no address is provided, then it will emit all events matching the event signatures on the ABI.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  abi: wagmiAbi,
  onLogs: logs => console.log(logs)
})
```

### args (optional)

- **Type:** Inferred from ABI.

Event arguments to filter logs.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  eventName: 'Transfer', // [!code focus]
  args: ['0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b'], // [!code focus]
  onLogs: logs => console.log(logs)
})
```

### eventName (optional)

- **Type:** `string`

An event name to filter logs.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  eventName: 'Transfer', // [!code focus]
  onLogs: logs => console.log(logs)
})
```

### batch (optional)

- **Type:** `boolean`
- **Default:** `true`

Whether or not to batch logs between polling intervals.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  batch: false, // [!code focus]
  onLogs: logs => console.log(logs)
})
```

### onError (optional)

- **Type:** `(error: Error) => void`

Error thrown from listening for new event logs.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  onError: error => console.log(error), // [!code focus]
  onLogs: logs => console.log(logs)
})
```

### poll (optional)

- **Type:** `boolean`
- **Default:** `false` for WebSocket Clients, `true` for non-WebSocket Clients

Whether or not to use a polling mechanism to check for new logs instead of a WebSocket subscription.

This option is only configurable for Clients with a [WebSocket Transport](/docs/clients/transports/websocket).

```ts
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({
  chain: mainnet,
  transport: webSocket()
})

const unwatch = publicClient.watchContractEvent(
  { 
    address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    abi: wagmiAbi,
    poll: true, // [!code focus]
  }
)
```

### pollingInterval (optional)

- **Type:** `number`

Polling frequency (in ms). Defaults to the Client's `pollingInterval` config.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  pollingInterval: 1_000, // [!code focus]
  onLogs: logs => console.log(logs)
})
```

### fromBlock (optional)

- **Type:** `bigint`

The block number to start listening for logs from.

```ts
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  onLogs: logs => console.log(logs),
  fromBlock: 1n // [!code focus]
})
```

## JSON-RPC Methods

**When poll `true` and RPC Provider supports `eth_newFilter`:**

- Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).
- On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).

**When poll `true` RPC Provider does not support `eth_newFilter`:**

- Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.

**When poll `false` and WebSocket Transport:**

- Uses a WebSocket subscription via `eth_subscribe` and the "logs" event.
</file>

<file path="contract/writeContract.md">
---
description: Executes a write function on a contract.
---

# writeContract

Executes a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](/docs/glossary/terms) is needed to be broadcast in order to change the state.

Internally, `writeContract` uses a [Wallet Client](/docs/clients/wallet) to call the [`sendTransaction` action](/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](/docs/contract/encodeFunctionData).

:::warning

The `writeContract` internally sends a transaction – it **does not** validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `simulateContract`](#usage) before you execute it.

:::

## Usage

Below is a very basic example of how to execute a write function on a contract (with no arguments).

While you can use `writeContract` [by itself](#standalone), it is highly recommended to pair it with [`simulateContract`](/docs/contract/simulateContract) to validate that the contract write will execute without errors.

:::code-group

```ts [example.ts]
import { account, publicClient, walletClient } from './config'
import { wagmiAbi } from './abi'

const { request } = await publicClient.simulateContract({
  account,
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
})
await walletClient.writeContract(request)
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createWalletClient, custom, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount(...)
```

:::

### Passing Arguments

If your function requires argument(s), you can pass them through with the `args` attribute.

TypeScript types for `args` will be inferred from the function name & ABI, to guard you from inserting the wrong values.

For example, the `mint` function name below requires a **tokenId** argument, and it is typed as `[number]`.

:::code-group

```ts [example.ts] {8}
import { account, walletClient } from './client'
import { wagmiAbi } from './abi'

const { request } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account
})
await walletClient.writeContract(request)
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [{ name: "tokenId", type: "uint32" }],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createWalletClient, custom, http} from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount('0x...')
```

:::

### Standalone

If you don't need to perform validation on the contract write, you can also use it by itself:

:::code-group

```ts [example.ts]
import { account, walletClient } from './config'
import { wagmiAbi } from './abi'

await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
})
```

```ts [abi.ts]
export const wagmiAbi = [
  ...
  {
    inputs: [],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  ...
] as const;
```

```ts [config.ts]
import { createWalletClient, custom, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount('0x...')
```

:::


## Return Value

[`Hash`](/docs/glossary/types#hash)

A [Transaction Hash](/docs/glossary/terms#hash).

Unlike [`readContract`](/docs/contract/readContract), `writeContract` only returns a [Transaction Hash](/docs/glossary/terms#hash). If you would like to retrieve the return data of a write function, you can use the [`simulateContract` action](/docs/contract/simulateContract) – this action does not execute a transaction, and does not require gas (it is very similar to `readContract`).

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The contract address.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420]
})
```

### abi

- **Type:** [`Abi`](/docs/glossary/types#abi)

The contract's ABI.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi, // [!code focus]
  functionName: 'mint',
  args: [69420]
})
```

### functionName

- **Type:** `string`

A function to extract from the ABI.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint', // [!code focus]
  args: [69420]
})
```

### account

- **Type:** `Account | Address | null`

The Account to write to the contract from.

Accepts a [JSON-RPC Account (or Address)](/docs/clients/wallet#json-rpc-accounts) or [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc). If set to `null`, it is assumed that the transport will handle the filling the sender of the transaction.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266' // [!code focus]
})
```

### accessList (optional)

- **Type:** [`AccessList`](/docs/glossary/types#accesslist)

The access list.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  accessList: [{ // [!code focus:4]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    storageKeys: ['0x1'],
  }],
})
```

### authorizationList (optional)

- **Type:** `AuthorizationList`

Signed EIP-7702 Authorization list.

```ts
const authorization = await walletClient.signAuthorization({ 
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
}) 

await walletClient.writeContract({
  address: account.address,
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  authorizationList: [authorization], // [!code focus]
})
```

:::note
**References**
- [EIP-7702 Overview](/docs/eip7702)
- [`signAuthorization` Docs](/docs/eip7702/signAuthorization)
:::

### args (optional)

- **Type:** Inferred from ABI.

Arguments to pass to function call.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420] // [!code focus]
})
```

### chain (optional)

- **Type:** [`Chain`](/docs/glossary/types#chain)
- **Default:** `walletClient.chain`

The target chain. If there is a mismatch between the wallet's current chain & the target chain, an error will be thrown.

The chain is also used to infer its request type (e.g. the Celo chain has a `gatewayFee` that you can pass through to `sendTransaction`).

```ts
import { optimism } from 'viem/chains' // [!code focus]

await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  chain: optimism, // [!code focus]
})
```

### dataSuffix

- **Type:** `Hex`

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  dataSuffix: '0xdeadbeef' // [!code focus]
})
```

### gas (optional)

- **Type:** `bigint`

The gas limit for the transaction. Note that passing a gas limit also skips the gas estimation step.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  gas: 69420n, // [!code focus]
})
```

### gasPrice (optional)

- **Type:** `bigint`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](/docs/glossary/terms#legacy-transaction).

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  gasPrice: parseGwei('20'), // [!code focus]
})
```

### maxFeePerGas (optional)

- **Type:** `bigint`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  maxFeePerGas: parseGwei('20'),  // [!code focus]
})
```

### maxPriorityFeePerGas (optional)

- **Type:** `bigint`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](/docs/glossary/terms#eip-1559-transaction)

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'), // [!code focus]
})
```

### nonce (optional)

- **Type:** `number`

Unique number identifying this transaction.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  nonce: 69 // [!code focus]
})
```

### value (optional)

- **Type:** `number`

Value in wei sent with this transaction.

```ts
await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  value: parseEther('1') // [!code focus]
})
```

## Live Example

Check out the usage of `writeContract` in the live [Writing to Contracts Example](https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="eip7702/contract-writes.md">
# Contract Writes with EIP-7702

The guide below demonstrates how to perform Contract Writes with EIP-7702 to invoke Contract functions on an Externally Owned Account (EOA).

## Overview

Here is an end-to-end overview of how to perform a Contract Write to send a batch of Calls. We will break it down into [Steps](#steps) below.

:::code-group

```ts twoslash [example.ts]
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './config'
import { abi, contractAddress } from './contract'

const eoa = privateKeyToAccount('0x...')

// 1. Authorize designation of the Contract onto the EOA.
const authorization = await walletClient.signAuthorization({
  account: eoa,
  contractAddress,
})

// 2. Designate the Contract on the EOA, and invoke the 
//    `initialize` function.
const hash = await walletClient.writeContract({
  abi,
  address: eoa.address,
  authorizationList: [authorization],
  //                  ↑ 3. Pass the Authorization as a parameter.
  functionName: 'initialize',
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts' 

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```solidity [Delegation.sol]
pragma solidity ^0.8.20;

contract Delegation {
  event Log(string message);

  function initialize() external payable {
    emit Log('Hello, world!');
  }

  function ping() external pure {
    emit Log('Pong!');
  }
}
```

:::

## Steps

### 1. Set up Smart Contract

We will need to set up a Smart Contract to designate on the Account. For the purposes of this guide, we will [create](https://book.getfoundry.sh/reference/forge/forge-init) and [deploy](https://book.getfoundry.sh/forge/deploying) a simple demonstration `Delegation.sol` contract, however, you can use any existing deployed contract.

Firstly, [deploy a Contract](https://book.getfoundry.sh/forge/deploying) to the Network with the following source:

```solidity [Delegation.sol]
pragma solidity ^0.8.20;

contract Delegation {
  event Log(string message);

  function initialize() external payable {
    emit Log('Hello, world!');
  }

  function ping() external pure {
    emit Log('Pong!');
  }
}
```

### 2. Set up Client & Account

Next, we will need to set up a Client and a "Relay Account" that will be responsible for executing the EIP-7702 Contract Write.

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::info

In this demo, we will be using a "Relay Account" (not the EOA) to execute the Transaction. This is typically how EIP-7702 is used in practice, as the relayer can sponsor the gas fees to perform the Transaction.

However, it is also possible for the EOA to sign and also execute the Transaction. [See more](#note-self-executing-eip-7702).
:::

### 3. Authorize Contract Designation

We will need to sign an Authorization to designate the Contract to the Account.

In the example below, we are instantiating an existing EOA (`account`) and using it to sign the Authorization – this will be the Account that will be used for delegation.

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
import { contractAddress } from './contract'

const eoa = privateKeyToAccount('0x...') // [!code focus]
 
const authorization = await walletClient.signAuthorization({ // [!code focus]
  account: eoa, // [!code focus]
  contractAddress, // [!code focus]
}) // [!code focus]
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::

:::info
If the EOA is also executing the Transaction, you will need to pass `executor: 'self'` to `signAuthorization`. [See more](#note-self-executing-eip-7702).
:::

### 4. Execute Contract Write

We can now designate the Contract on the Account (and execute the `initialize` function) by sending an EIP-7702 Contract Write.

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
import { abi, contractAddress } from './contract'

const eoa = privateKeyToAccount('0x...')
 
const authorization = await walletClient.signAuthorization({
  account: eoa,
  contractAddress,
})

const hash = await walletClient.writeContract({ // [!code focus]
  abi, // [!code focus]
  address: eoa.address, // [!code focus]
  authorizationList: [authorization], // [!code focus]
  functionName: 'initialize', // [!code focus]
}) // [!code focus]
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::

### 5. (Optional) Interact with the Delegated Account

Now that we have designated a Contract onto the Account, we can interact with it by invoking its functions. 

Note that we no longer need to use an Authorization!

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
import { abi } from './contract'

const eoa = privateKeyToAccount('0x...')

const hash = await walletClient.writeContract({
  abi,
  address: eoa.address,
  functionName: 'ping', // [!code hl]
})
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::


### Note: Self-executing EIP-7702

If the signer of the Authorization (ie. the EOA) is also executing the Transaction, you will need to pass `executor: 'self'` to `signAuthorization`. 

This is because `authorization.nonce` must be incremented by 1 over `transaction.nonce`, so we will need to hint to `signAuthorization` that this is the case.

:::tip
In the example below, we are attaching an EOA to the Wallet Client (see `config.ts`), and using it for signing the Authorization and executing the Transaction.
:::

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
import { abi, contractAddress } from './contract'

const authorization = await walletClient.signAuthorization({
  account: eoa, // [!code --]
  contractAddress,
  executor: 'self', // [!code ++]
})

const hash = await walletClient.writeContract({
  abi,
  address: eoa.address, // [!code --]
  address: walletClient.account.address, // [!code ++]
  authorizationList: [authorization],
  functionName: 'initialize',
})
```

```ts twoslash [config.ts]
// @noErrors
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...') // [!code --]
export const eoa = privateKeyToAccount('0x...') // [!code ++]
 
export const walletClient = createWalletClient({
  account: relay, // [!code --]
  account: eoa, // [!code ++]
  chain: sepolia,
  transport: http(),
})
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

:::
</file>

<file path="eip7702/hashAuthorization.md">
---
description: Calculates an Authorization object hash in EIP-7702 format.
---

# hashAuthorization

Calculates an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.

## Import

```ts twoslash
import { hashAuthorization } from 'viem/utils'
```

## Usage

```ts twoslash
import { hashAuthorization } from 'viem/utils'

hashAuthorization({
  contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
  chainId: 1,
  nonce: 0,
})
// 0xd428ed36e6098e46b40a4cb99b83b930b0ca1f054f40b5996589eda33c295663
```

## Returns

[`Hash`](/docs/glossary/types#hash)

The hashed Authorization.

## Parameters

### address

- **Type:** `Address`

Address of the contract to set as code for the Authority.

```ts twoslash
import { hashAuthorization } from 'viem/utils'

hashAuthorization({
  contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', // [!code focus]
  chainId: 1,
  nonce: 0,
}) 
```

### chainId

- **Type:** `number`

Chain ID to authorize.

```ts twoslash
import { hashAuthorization } from 'viem/utils'

hashAuthorization({
  contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
  chainId: 1, // [!code focus]
  nonce: 0,
}) 
```

### nonce

- **Type:** `number`

Nonce of the Authority to authorize.

```ts twoslash
import { hashAuthorization } from 'viem/utils'

hashAuthorization({
  contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
  chainId: 1,
  nonce: 0, // [!code focus]
}) 
```

### to

- **Type:** `"hex" | "bytes"`
- **Default:** `"hex"`

Output format.

```ts twoslash
import { hashAuthorization } from 'viem/utils'

hashAuthorization({
  contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
  chainId: 1,
  nonce: 0, 
  to: 'bytes', // [!code focus]
}) 
```
</file>

<file path="eip7702/prepareAuthorization.md">
---
description: Prepares an EIP-7702 Authorization for signing.
---

# prepareAuthorization

Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) for signing. 
This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).

With the prepared Authorization object, you can use [`signAuthorization`](/docs/eip7702/signAuthorization) to sign over it.

## Usage

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const authorization = await walletClient.prepareAuthorization({ // [!code focus]
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
}) // [!code focus]
// @log: {
// @log:   chainId: 1,
// @log:   contractAddress: "0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2",
// @log:   nonce: 1,
// @log: }

const signedAuthorization = await walletClient.signAuthorization(authorization)
```

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  chain: mainnet,
  transport: http(),
})
```

:::

### Explicit Scoping

We can explicitly set a `nonce` and/or `chainId` by supplying them as parameters:

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'
 
const authorization = await walletClient.prepareAuthorization({
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  chainId: 10, // [!code focus]
})
// @log: {
// @log:   chainId: 10,
// @log:   contractAddress: "0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2",
// @log:   nonce: 420,
// @log: }

const signedAuthorization = await walletClient.signAuthorization(authorization)
```

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  chain: mainnet,
  transport: http(),
})
```

:::

## Returns

`Authorization`

A prepared & unsigned Authorization object.

## Parameters

### account

- **Type:** `Account`

Account to use to prepare the Authorization object. 

Accepts a [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'), // [!code focus]
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
}) 
```

### chainId (optional)

- **Type:** `Address`
- **Default:** `client.chain.id` or Network chain ID

The Chain ID to scope the Authorization to. If set to zero (`0`), then the Authorization will
be valid on all chains.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  chainId: 1, // [!code focus]
}) 
```

### contractAddress

- **Type:** `Address`

The target Contract to designate onto the Account.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2' // [!code focus]
}) 
```

### executor (optional)

- **Type:** `'self' | undefined`

Whether the EIP-7702 Transaction will be executed by the Account that signed the Authorization.

If not specified, it will be assumed that the EIP-7702 Transaction will be executed by another Account (ie. a relayer Account).

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  executor: 'self', // [!code focus]
}) 
```

### nonce (optional)

- **Type:** `Address`
- **Default:** Account's next available nonce.

The nonce to scope the Authorization to.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  nonce: 69, // [!code focus]
}) 
```
</file>

<file path="eip7702/recoverAuthorizationAddress.md">
---
description: Recovers the original signing address from a signed Authorization object.
---

# recoverAuthorizationAddress

Recovers the original signing address from a signed Authorization object.

## Import

```ts twoslash
import { recoverAuthorizationAddress } from 'viem/utils'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { privateKeyToAccount } from 'viem/accounts'
import { recoverAuthorizationAddress } from 'viem/utils' // [!code focus]
import { walletClient } from './client'

const eoa = privateKeyToAccount('0x...')

const authorization = await walletClient.signAuthorization({
  account: eoa,
  authorization: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
})

const address = await recoverAuthorizationAddress({ // [!code focus]
  authorization, // [!code focus]
}) // [!code focus]
```

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: http(),
})
```

:::

## Returns

`Address`

The address that signed the Authorization object.

## Parameters

### authorization

- **Type:** `Authorization | SignedAuthorization`

The Authorization object that was signed.

```ts twoslash
import { recoverAuthorizationAddress } from 'viem/utils'
import { walletClient } from './client'
  // ---cut---
const authorization = await walletClient.signAuthorization({
  authorization: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
})
const address = await recoverAuthorizationAddress({
  authorization, // [!code focus]
}) 
```

### signature

- **Type:** `Hex | ByteArray | Signature | SignedAuthorization`

The signature that was generated by signing the Authorization object with the address's private key.

```ts twoslash
import { recoverAuthorizationAddress } from 'viem/utils'
import { walletClient } from './client'
  // ---cut---
const signature = await walletClient.signAuthorization({
  contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
  chainId: 1,
  nonce: 0,
})

const address = await recoverAuthorizationAddress({
  authorization: {
    contractAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    chainId: 1,
    nonce: 0,
  },
  signature, // [!code focus]
}) 
```
</file>

<file path="eip7702/sending-transactions.md">
# Sending Transactions with EIP-7702

The guide below demonstrates how to send EIP-7702 Transactions to invoke Contract functions on an Externally Owned Account (EOA).

## Overview

Here is an end-to-end overview of how to execute an EIP-7702 Transaction to emit a simple event on the EOA's designated contract. We will break it down into [Steps](#steps) below.

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './config'
import { abi, contractAddress } from './contract'

const eoa = privateKeyToAccount('0x...')

// 1. Authorize designation of the Contract onto the EOA.
const authorization = await walletClient.signAuthorization({
  account: eoa,
  contractAddress,
})

// 2. Designate the Contract on the EOA, and invoke the 
//    `initialize` function.
const hash = await walletClient.sendTransaction({
  authorizationList: [authorization],
  //                  ↑ 3. Pass the Authorization as a parameter.
  data: encodeFunctionData({
    abi,
    functionName: 'initialize',
  }),
  to: eoa.address,
})
```

```ts twoslash [config.ts] filename="config.ts"
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts' 

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```solidity [Delegation.sol]
pragma solidity ^0.8.20;

contract Delegation {
  event Log(string message);

  function initialize() external payable {
    emit Log('Hello, world!');
  }

  function ping() external pure {
    emit Log('Pong!');
  }
}
```

:::

## Steps

### 1. Set up Smart Contract

We will need to set up a Smart Contract to designate on the Account. For the purposes of this guide, we will [create](https://book.getfoundry.sh/reference/forge/forge-init) and [deploy](https://book.getfoundry.sh/forge/deploying) a simple demonstration `Delegation.sol` contract, however, you can use any existing deployed contract.

Firstly, [deploy a Contract](https://book.getfoundry.sh/forge/deploying) to the Network with the following source:

```solidity [Delegation.sol]
pragma solidity ^0.8.20;

contract Delegation {
  event Log(string message);

  function initialize() external payable {
    emit Log('Hello, world!');
  }


  function ping() external pure {
    emit Log('Pong!');
  }
}
```

### 2. Set up Client & Account

Next, we will need to set up a Client and a "Relay Account" that will be responsible for executing the EIP-7702 Transaction.

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::info

In this demo, we will be using a "Relay Account" (not the EOA) to execute the Transaction. This is typically how EIP-7702 is used in practice, as the relayer can sponsor the gas fees to perform the Transaction.

However, it is also possible for the EOA to sign and also execute the Transaction. [See more](#note-self-executing-eip-7702).
:::

### 3. Authorize Contract Designation

We will need to sign an Authorization to designate the Contract to the Account.

In the example below, we are instantiating an existing EOA (`account`) and using it to sign the Authorization – this will be the Account that will be used for delegation.

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './config'
import { contractAddress } from './contract'

const eoa = privateKeyToAccount('0x...') // [!code focus]
 
const authorization = await walletClient.signAuthorization({ // [!code focus]
  account: eoa, // [!code focus]
  contractAddress, // [!code focus]
}) // [!code focus]
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::

:::info
If the EOA is also executing the Transaction, you will need to pass `executor: 'self'` to `signAuthorization`. [See more](#note-self-executing-eip-7702).
:::


### 4. Execute Transaction

We can now designate the Contract on the Account (and execute the `initialize` function) by sending an EIP-7702 Transaction.

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData } from 'viem'
import { walletClient } from './config'
import { contractAddress } from './contract'

const eoa = privateKeyToAccount('0x...')
 
const authorization = await walletClient.signAuthorization({
  account: eoa,
  contractAddress,
})

const hash = await walletClient.sendTransaction({ // [!code focus]
  authorizationList: [authorization], // [!code focus]
  data: encodeFunctionData({ // [!code focus]
    abi, // [!code focus]
    functionName: 'initialize', // [!code focus]
  }), // [!code focus]
  to: eoa.address, // [!code focus]
}) // [!code focus]
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::

### 5. (Optional) Interact with the Delegated Account

Now that we have designated a Contract onto the Account, we can interact with it by invoking its functions. 

Note that we no longer need to use an Authorization!

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData } from 'viem'
import { walletClient } from './config'

const eoa = privateKeyToAccount('0x...')

const hash = await walletClient.sendTransaction({
  data: encodeFunctionData({
    abi,
    functionName: 'ping',
  }),
  to: eoa.address,
})
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

```ts twoslash [config.ts]
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...')
 
export const walletClient = createWalletClient({
  account: relay,
  chain: sepolia,
  transport: http(),
})
```

:::

### Note: Self-executing EIP-7702

If the signer of the Authorization (ie. the EOA) is also executing the Transaction, you will need to pass `executor: 'self'` to `signAuthorization`. 

This is because `authorization.nonce` must be incremented by 1 over `transaction.nonce`, so we will need to hint to `signAuthorization` that this is the case.

:::tip
In the example below, we are attaching an EOA to the Wallet Client (see `config.ts`), and using it for signing the Authorization and executing the Transaction.
:::

:::code-group

```ts twoslash [example.ts]
import { encodeFunctionData } from 'viem'
import { walletClient } from './config'
import { contractAddress } from './contract'

const authorization = await walletClient.signAuthorization({
  account: eoa, // [!code --]
  contractAddress,
  executor: 'self', // [!code ++]
})

const hash = await walletClient.sendTransaction({
  authorizationList: [authorization],
  data: encodeFunctionData({
    abi,
    functionName: 'initialize',
  }),
  to: eoa.address, // [!code --]
  to: walletClient.account.address, // [!code ++]
})
```

```ts twoslash [config.ts]
// @noErrors
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

export const relay = privateKeyToAccount('0x...') // [!code --]
export const eoa = privateKeyToAccount('0x...') // [!code ++]
 
export const walletClient = createWalletClient({
  account: relay, // [!code --]
  account: eoa, // [!code ++]
  chain: sepolia,
  transport: http(),
})
```

```ts twoslash [contract.ts] filename="contract.ts"
export const abi = [
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ping",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
] as const

export const contractAddress = '0x...'
```

:::
</file>

<file path="eip7702/signAuthorization.md">
---
description: Signs an EIP-7702 Authorization object.
---

# signAuthorization

Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702). The signed Authorization can be used in Transaction APIs like [`sendTransaction`](/docs/actions/wallet/sendTransaction#authorizationlist-optional) and [`writeContract`](/docs/contract/writeContract#authorizationlist-optional) to delegate an authorized Contract onto an Account.

## Usage

A Contract can be authorized by supplying a `contractAddress`. By default, it will be signed over the Account's next available Nonce and the current Chain ID. You can also [explicitly set the `nonce` and `chainId`](#scoping).

:::code-group

```ts twoslash [example.ts]
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const eoa = privateKeyToAccount('0x...')
 
const authorization = await walletClient.signAuthorization({ // [!code focus]
  account: eoa, // [!code focus]
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', // [!code focus]
}) // [!code focus]
// @log: {
// @log:   chainId: 1,
// @log:   contractAddress: "0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2",
// @log:   nonce: 1,
// @log:   r: "0xf507fb8fa33ffd05a7f26c980bbb8271aa113affc8f192feba87abe26549bda1",
// @log:   s: "0x1b2687608968ecb67230bbf7944199560fa2b3cffe9cc2b1c024e1c8f86a9e08",
// @log:   yParity: 0,
// @log: }

const hash = await walletClient.sendTransaction({
  authorizationList: [authorization],
  data: '0xdeadbeef',
  to: eoa.address,
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const relay = privateKeyToAccount('0x...')

export const walletClient = createWalletClient({
  account: relay,
  chain: mainnet,
  transport: http(),
})
```

:::

### Explicit Scoping

We can explicitly sign over a provided `nonce` and/or `chainId` by supplying them as parameters:

:::code-group

```ts twoslash [example.ts]
import { walletClient } from './client'

const eoa = privateKeyToAccount('0x...')
 
const authorization = await walletClient.signAuthorization({
  account: eoa,
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  chainId: 10, // [!code focus]
  nonce: 420, // [!code focus]
})
// @log: {
// @log:   chainId: 10,
// @log:   contractAddress: "0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2",
// @log:   nonce: 420,
// @log:   r: "0xf507fb8fa33ffd05a7f26c980bbb8271aa113affc8f192feba87abe26549bda1",
// @log:   s: "0x1b2687608968ecb67230bbf7944199560fa2b3cffe9cc2b1c024e1c8f86a9e08",
// @log:   yParity: 0,
// @log: }

const hash = await walletClient.sendTransaction({
  authorizationList: [authorization],
  data: '0xdeadbeef',
  to: eoa.address,
})
```

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const relay = privateKeyToAccount('0x...')

export const walletClient = createWalletClient({
  account: relay,
  chain: mainnet,
  transport: http(),
})
```

:::

## Returns

`SignedAuthorization`

A signed Authorization object.

## Parameters

### account

- **Type:** `Account`

Account to use for delegation.

Accepts a [Local Account (Private Key, etc)](/docs/clients/wallet#local-accounts-private-key-mnemonic-etc).

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.signAuthorization({
  account: privateKeyToAccount('0x...'), // [!code focus]
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
}) 
```

### chainId (optional)

- **Type:** `Address`
- **Default:** `client.chain.id` or Network chain ID

The Chain ID to scope the Authorization to.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.signAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  chainId: 1, // [!code focus]
}) 
```

### contractAddress

- **Type:** `Address`

The target Contract to delegate to the Account.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.signAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2' // [!code focus]
}) 
```

### executor (optional)

- **Type:** `'self' | undefined`

Whether the EIP-7702 Transaction will be executed by the Account that signed the Authorization.

If not specified, it will be assumed that the EIP-7702 Transaction will be executed by another Account (ie. a relayer Account).

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.signAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  executor: 'self', // [!code focus]
}) 
```

### nonce (optional)

- **Type:** `Address`
- **Default:** Account's next available nonce.

The nonce to scope the Authorization to.

```ts twoslash
import { privateKeyToAccount } from 'viem/accounts'
import { walletClient } from './client'

const authorization = await walletClient.signAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  nonce: 69, // [!code focus]
}) 
```
</file>

<file path="eip7702/verifyAuthorization.md">
---
description: Verifies that an Authorization object was signed by the provided address.
---

# verifyAuthorization

Verifies that an Authorization object was signed by the provided address.

## Import

```ts twoslash
import { verifyAuthorization } from 'viem/utils'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { privateKeyToAccount } from 'viem/accounts'
import { verifyAuthorization } from 'viem/utils' // [!code focus]
import { walletClient } from './client'

const eoa = privateKeyToAccount('0x...')

const authorization = await walletClient.signAuthorization({
  account: eoa,
  authorization: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
})

const valid = await verifyAuthorization({ // [!code focus]
  address: eoa.address, // [!code focus]
  authorization, // [!code focus]
}) // [!code focus]
```

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet,
  transport: http(),
})
```

:::

## Returns

`boolean`

Whether the signature is valid for the provided Authorization object.

## Parameters

### address

- **Type:** `Address`

The address that signed the Authorization object.

```ts twoslash
import { verifyAuthorization } from 'viem/utils'
import { walletClient } from './client'

const authorization = await walletClient.signAuthorization({
  authorization: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
})
// ---cut---
const valid = await verifyAuthorization({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // [!code focus]
  authorization,
}) 
```

### authorization

- **Type:** `Authorization | SignedAuthorization`

The Authorization object to be verified.

```ts twoslash
import { verifyAuthorization } from 'viem/utils'
import { walletClient } from './client'
// ---cut---
const authorization = await walletClient.signAuthorization({
  authorization: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'
})

const valid = await verifyAuthorization({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  authorization, // [!code focus]
}) 
```

### signature

- **Type:** `Hex | ByteArray | Signature | SignedAuthorization`

The signature that was generated by signing the Authorization object with the address's private key.

```ts twoslash
import { verifyAuthorization } from 'viem/utils'
import { walletClient } from './client'
// ---cut---
const signature = await walletClient.signAuthorization({
  authorization: {
    address: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    chainId: 1,
    nonce: 0,
  }
})

const valid = await verifyAuthorization({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  authorization: {
    address: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    chainId: 1,
    nonce: 0,
  },
  signature, // [!code focus]
}) 
```
</file>

<file path="ens/actions/getEnsAddress.md">
---
description: Gets address for ENS name.
---

# getEnsAddress

Gets address for ENS name.

Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract to resolve the ENS name to address.

## Usage

:::code-group

```ts [example.ts]
import { normalize } from 'viem/ens'
import { publicClient } from './client'
 
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'),
})
// '0xd2135CfB216b74109775236E36d4b433F1DF507B'
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

:::warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](/docs/ens/utilities/normalize) function for this.
:::

## Returns

[`Address`](/docs/glossary/types#address)

The address that resolves to provided ENS name.

Returns `null` if ENS name does not resolve to address.

## Parameters

### name

- **Type:** `string`

Name to get the address for.

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'), // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'),
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'),
  blockTag: 'safe', // [!code focus]
})
```

### coinType (optional)

- **Type:** `number`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'), 
  coinType: 60, // [!code focus]
})
```

### gatewayUrls (optional)

- **Type:** `string[]`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'), 
  gatewayUrls: ["https://ccip.ens.xyz"], // [!code focus]
})
```

### strict (optional)

- **Type:** `boolean`
- **Default:** `false`

A boolean value that when set to true will strictly propagate all ENS Universal Resolver Contract errors.

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'), 
  strict: true, // [!code focus]
})
```

### universalResolverAddress (optional)

- **Type:** [`Address`](/docs/glossary/types#address)
- **Default:** `client.chain.contracts.ensUniversalResolver.address`

Address of ENS Universal Resolver Contract.

```ts
const ensAddress = await publicClient.getEnsAddress({
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```

## Live Example

Check out the usage of `getEnsAddress` in the live [ENS Examples](https://stackblitz.com/github/wevm/viem/tree/main/examples/ens) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/ens?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="ens/actions/getEnsAvatar.md">
---
description: Gets the avatar of an ENS name.
---

# getEnsAvatar

Gets the avatar of an ENS name.

Calls [`getEnsText`](/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.

## Usage

:::code-group

```ts [example.ts]
import { normalize } from 'viem/ens'
import { publicClient } from './client'
 
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'),
})
// 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'

import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

:::warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](/docs/ens/utilities/normalize) function for this.
:::

## Returns

`string | null`

The avatar URI for ENS name.

Returns `null` if the avatar cannot be resolved from the ENS name.

## Parameters

### name

- **Type:** `string`

ENS name to get Text for.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'), // [!code focus]
})
```

### assetGatewayUrls (optional)

- **Type:** `{ ipfs?: string; arweave?: string }`

Gateway urls to resolve IPFS and/or Arweave assets.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'),
  assetGatewayUrls: { // [!code focus:3]
    ipfs: 'https://cloudflare-ipfs.com'
  }
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'),
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'),
  blockTag: 'safe', // [!code focus]
})
```

### gatewayUrls (optional)

- **Type:** `string[]`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'), 
  gatewayUrls: ["https://ccip.ens.xyz"], // [!code focus]
})
```

### strict (optional)

- **Type:** `boolean`
- **Default:** `false`

A boolean value that when set to true will strictly propagate all ENS Universal Resolver Contract errors.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'), 
  strict: true, // [!code focus]
})
```

### universalResolverAddress (optional)

- **Type:** [`Address`](/docs/glossary/types#address)
- **Default:** `client.chain.contracts.ensUniversalResolver.address`

Address of ENS Universal Resolver Contract.

```ts
const ensText = await publicClient.getEnsAvatar({
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
</file>

<file path="ens/actions/getEnsName.md">
---
description: Gets primary name for specified address.
---

# getEnsName

Gets primary name for specified address.

Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.

## Usage

:::code-group

```ts [example.ts]
import { publicClient } from './client'
 
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
})
// 'wevm.eth'
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

## Returns

`string`

The primary ENS name for the address.

Returns `null` if address does not have primary name assigned.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

Address to get primary ENS name for.

```ts
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  blockTag: 'safe', // [!code focus]
})
```

### gatewayUrls (optional)

- **Type:** `string[]`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

```ts
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  gatewayUrls: ["https://ccip.ens.xyz"], // [!code focus]
})
```

### strict (optional)

- **Type:** `boolean`
- **Default:** `false`

A boolean value that when set to true will strictly propagate all ENS Universal Resolver Contract errors.

```ts
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  strict: true, // [!code focus]
})
```

### universalResolverAddress (optional)

- **Type:** [`Address`](/docs/glossary/types#address)
- **Default:** `client.chain.contracts.ensUniversalResolver.address`

Address of ENS Universal Resolver Contract.

```ts
const ensName = await publicClient.getEnsName({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```

## Live Example

Check out the usage of `getEnsName` in the live [ENS Examples](https://stackblitz.com/github/wevm/viem/tree/main/examples/ens) below.

<iframe frameBorder="0" width="100%" height="500px" src="https://stackblitz.com/github/wevm/viem/tree/main/examples/ens?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=0&ctl=1"></iframe>
</file>

<file path="ens/actions/getEnsResolver.md">
---
description: Gets resolver for ENS name.
---

# getEnsResolver

Gets resolver for ENS name.

Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.

## Usage

:::code-group

```ts [example.ts]
import { normalize } from 'viem/ens'
import { publicClient } from './client'
 
const resolverAddress = await publicClient.getEnsResolver({
  name: normalize('wevm.eth'),
})
// '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
})
```

:::

:::warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsResolver`. You can use the built-in [`normalize`](/docs/ens/utilities/normalize) function for this.
:::

## Returns

[`Address`](/docs/glossary/types#address)

The address of the resolver.

## Parameters

### name

- **Type:** `string`

Name to get the address for.

```ts
const ensName = await publicClient.getEnsResolver({
  name: normalize('wevm.eth'), // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const ensName = await publicClient.getEnsResolver({
  name: normalize('wevm.eth'),
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const ensName = await publicClient.getEnsResolver({
  name: normalize('wevm.eth'),
  blockTag: 'safe', // [!code focus]
})
```

### universalResolverAddress (optional)

- **Type:** [`Address`](/docs/glossary/types#address)
- **Default:** `client.chain.contracts.ensUniversalResolver.address`

Address of ENS Universal Resolver Contract.

```ts
const ensName = await publicClient.getEnsResolver({
  name: normalize('wevm.eth'),
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
</file>

<file path="ens/actions/getEnsText.md">
---
description: Gets a text record for specified ENS name.
---

# getEnsText

Gets a text record for specified ENS name.

Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.

## Usage

:::code-group

```ts [example.ts]
import { normalize } from 'viem/ens'
import { publicClient } from './client'
 
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter',
})
// 'wevm_dev'
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'

import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::

:::warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsText`. You can use the built-in [`normalize`](/docs/ens/utilities/normalize) function for this.
:::

## Returns

`string | null`

The text record for ENS name.

Returns `null` if name does not have text assigned.

## Parameters

### name

- **Type:** `string`

ENS name to get Text for.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'), // [!code focus]
  key: 'com.twitter',
})
```

### key

- **Type:** `string`

ENS key to get Text for.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `number`

The block number to perform the read against.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  blockNumber: 15121123n, // [!code focus]
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

The block tag to perform the read against.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  blockTag: 'safe', // [!code focus]
})
```

### gatewayUrls (optional)

- **Type:** `string[]`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  gatewayUrls: ["https://ccip.ens.xyz"], // [!code focus]
})
```

### strict (optional)

- **Type:** `boolean`
- **Default:** `false`

A boolean value that when set to true will strictly propagate all ENS Universal Resolver Contract errors.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  strict: true, // [!code focus]
})
```


### universalResolverAddress (optional)

- **Type:** [`Address`](/docs/glossary/types#address)
- **Default:** `client.chain.contracts.ensUniversalResolver.address`

Address of ENS Universal Resolver Contract.

```ts
const ensText = await publicClient.getEnsText({
  name: normalize('wevm.eth'),
  key: 'com.twitter',
  universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', // [!code focus]
})
```
</file>

<file path="ens/utilities/labelhash.md">
---
description: Hashes ENS label.
---

# labelhash

Hashes ENS label.

## Import

```ts
import { labelhash, normalize } from 'viem/ens'
```

## Usage

```ts
import { labelhash, normalize } from 'viem/ens'

labelhash(normalize('awkweb')) // [!code focus:2]
// '0x7aaad03ddcacc63166440f59c14a1a2c97ee381014b59c58f55b49ab05f31a38'
```

:::warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](/docs/ens/utilities/normalize) function for this.
:::

## Returns

`string`

The hashed ENS label.

## Parameters

### name

- **Type:** `string`

A ENS label.
</file>

<file path="ens/utilities/namehash.md">
---
description: Hashes ENS name.
---

# namehash

Hashes ENS name.

## Import

```ts
import { namehash, normalize } from 'viem/ens'
```

## Usage

```ts
import { namehash, normalize } from 'viem/ens'

namehash('wevm.eth') // [!code focus:2]
// '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'
```

:::warning
Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](/docs/ens/utilities/normalize) function for this.
:::

## Returns

`string`

The hashed ENS name.

## Parameters

### name

- **Type:** `string`

A ENS name.
</file>

<file path="ens/utilities/normalize.md">
---
description: Normalizes ENS name to UTS46.
---

# normalize

Normalizes ENS name to [UTS51](https://unicode.org/reports/tr51) and [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).

Internally uses [`@adraffy/ens-normalize`](https://github.com/adraffy/ens-normalize.js).

## Import

```ts
import { normalize } from 'viem/ens'
```

## Usage

```ts
import { normalize } from 'viem/ens'

normalize('wagmi-d𝝣v.eth') // [!code focus:2]
// 'wagmi-dξv.eth'
```

## Returns

`string`

The normalized ENS label.

## Parameters

### name

- **Type:** `string`

A ENS name.
</file>

<file path="glossary/errors.md">
# Errors [Glossary of Errors in viem.]

All errors in viem extend the [`BaseError`](https://github.com/wevm/viem/blob/main/src/errors/base.ts).

## ABI

### `AbiConstructorNotFoundError`
### `AbiConstructorParamsNotFoundError`
### `AbiDecodingDataSizeInvalidError`
### `AbiDecodingDataSizeTooSmallError`
### `AbiDecodingZeroDataError`
### `AbiEncodingArrayLengthMismatchError`
### `AbiEncodingBytesSizeMismatchError`
### `AbiEncodingLengthMismatchError`
### `AbiErrorInputsNotFoundError`
### `AbiErrorNotFoundError`
### `AbiErrorSignatureNotFoundError`
### `AbiEventNotFoundError`
### `AbiEventSignatureEmptyTopicsError`
### `AbiEventSignatureNotFoundError`
### `AbiFunctionNotFoundError`
### `AbiFunctionOutputsNotFoundError`
### `AbiFunctionSignatureNotFoundError`
### `BytesSizeMismatchError`
### `DecodeLogTopicsMismatch`
### `InvalidAbiDecodingTypeError`
### `InvalidAbiEncodingTypeError`
### `InvalidArrayError`
### `InvalidDefinitionTypeError`
### `UnsupportedPackedAbiType`

## Account

### `AccountNotFoundError`

When no account is provided to an action that requires an account.

## Address

### `InvalidAddressError`

When address is invalid.

## Block

### `BlockNotFoundError`

## Chain

### `ChainDoesNotSupportContract`
### `ChainMismatchError`
### `ChainNotFoundError`
### `ClientChainNotConfiguredError`
### `InvalidChainIdError`

## Contract

### `CallExecutionError`
### `ContractFunctionExecutionError`
### `ContractFunctionRevertedError`
### `ContractFunctionZeroDataError`
### `RawContractError`

## Data

### `SizeExceedsPaddingSizeError`

## Encoding

### `DataLengthTooLongError`
### `DataLengthTooShortError`
### `IntegerOutOfRangeError`
### `InvalidBytesBooleanError`
### `InvalidHexBooleanError`
### `InvalidHexValueError`
### `OffsetOutOfBoundsError`
### `SizeOverflowError`

## ENS

### `EnsAvatarInvalidMetadataError`
### `EnsAvatarInvalidNftUriError`
### `EnsAvatarUnsupportedNamespaceError`
### `EnsAvatarUriResolutionError`

## Estimate Gas

### `EstimateGasExecutionError`

## Log

### `FilterTypeNotSupportedError`

## Node

### `ExecutionRevertedError`
### `FeeCapTooHighError`
### `FeeCapTooLowError`
### `InsufficientFundsError`
### `IntrinsicGasTooHighError`
### `IntrinsicGasTooLowError`
### `NonceMaxValueError`
### `NonceTooHighError`
### `NonceTooLowError`
### `TipAboveFeeCapError`
### `TransactionTypeNotSupportedError`
### `UnknownNodeError`

## Request

### `HttpRequestError`
### `RpcRequestError`
### `TimeoutError`
### `WebSocketRequestError`

## RPC

### `ChainDisconnectedError`
### `InternalRpcError`
### `InvalidInputRpcError`
### `InvalidParamsRpcError`
### `InvalidRequestRpcError`
### `JsonRpcVersionUnsupportedError`
### `LimitExceededRpcError`
### `MethodNotFoundRpcError`
### `MethodNotSupportedRpcError`
### `ParseRpcError`
### `ProviderDisconnectedError`
### `ProviderRpcError`
### `ResourceNotFoundRpcError`
### `ResourceUnavailableRpcError`
### `RpcError`
### `SwitchChainError`
### `TransactionRejectedRpcError`
### `UnauthorizedProviderError`
### `UnknownRpcError`
### `UnsupportedProviderMethodError`
### `UserRejectedRequestError`

## SIWE

### CreateSiweMessageErrorType
### SiweInvalidMessageFieldErrorType
### VerifySiweMessageErrorType

## Transaction

### `FeeConflictError`
### `InvalidLegacyVError`
### `InvalidSerializableTransactionError`
### `InvalidSerializedTransactionError`
### `InvalidSerializedTransactionTypeError`
### `InvalidStorageKeySizeError`
### `TransactionExecutionError`
### `TransactionNotFoundError`
### `TransactionReceiptNotFoundError`
### `WaitForTransactionReceiptTimeoutError`

## Transport

### `UrlRequiredError`
</file>

<file path="glossary/terms.md">
# Terms [Glossary of Terms in viem.]

## Block

A block is a bundled unit of information that include an ordered list of transactions and consensus-related information. Blocks are proposed by proof-of-stake validators, at which point they are shared across the entire peer-to-peer network, where they can easily be independently verified by all other nodes. Consensus rules govern what contents of a block are considered valid, and any invalid blocks are disregarded by the network. The ordering of these blocks and the transactions therein create a deterministic chain of events with the end representing the current state of the network.

## Chain

A Chain refers to a specific blockchain network or protocol that maintains a decentralized, distributed ledger of transactions and other data. Each Chain has its own rules, consensus mechanism, and native cryptocurrency (if any).

Examples of Chains include: Ethereum Mainnet, Polygon, Optimism, Avalanche, Binance Smart Chain, etc.

## EIP-1559 Transaction

EIP-1559 is an Ethereum Improvement Proposal that was implemented in August 2021 as part of the London hard fork. It introduced a new transaction format for Ethereum transactions, which is referred to as an EIP-1559 transaction (aka "transaction type 2").

When a user creates an EIP-1559 transaction, they specify the maximum fee they are willing to pay (`maxFeePerGas`) as well as a tip (`maxPriorityFeePerGas`) to incentivize the miner. The actual fee paid by the user is then determined by the network based on the current demand for block space and the priority of the transaction.

## Event Log

An Event Log is a record of an event emitted by a smart contract. Events are a type of function in a smart contract that can be triggered by specific actions or conditions, and they can be used to notify dapps of changes on the network.

[See more](https://ethereum.org/en/developers/docs/smart-contracts/anatomy/#events-and-logs)

## Filter

In Ethereum, a filter is a mechanism used to query the Ethereum blockchain for specific events or information.

There are three types of filters in Ethereum:

1. Block filters - these filters allow users to monitor the blockchain for new blocks that have been added.

2. Pending Transaction filters - these filters allow users to monitor the blockchain for new pending transactions in the mempool.

3. Event filters - these filters allow users to monitor the blockchain for specific events emitted by smart contracts, such as a token transfer.

When a filter is created, it returns a filter ID, which can be used to retrieve the results of the filter at a later time. Users can then periodically poll the filter for new events or changes that match the filter criteria.

## Human-Readable ABI

Human-Readable ABIs compress JSON ABIs into signatures that are nicer to read and less verbose to write. For more info, check out the [ABIType](https://abitype.dev/api/human) docs.

## Legacy Transaction

A Legacy Transaction in Ethereum refers to a transaction that was created using an older version of Ethereum's transaction format, known as "transaction type 0". This transaction format was used prior to the introduction of the EIP-1559 upgrade, which was implemented in August 2021.

## Non-conforming Log

A non-conforming log is a log where its `topics` & `data` do not match the **indexed** & **non-indexed** arguments on the `event`. `topics` correspond to **indexed** arguments, while `data` corresponds to **non-indexed** arguments.

For example, here is an event definition that has 3 indexed arguments & 1 non-indexed arguments:

```solidity
event Transfer(
  bool indexed foo, 
  uint256 baz, 
  string indexed bar, 
  boolean indexed barry
)
```

A conforming log for the above signature would be:

```ts
const log = {
  ...
  data: '0x
    00...23c346 // ✅ non-indexed argument (baz)
  ',
  topics: [
    '0xdd...23b3ef', // event signature
    '0x00...000001', // ✅ indexed argument (foo)
    '0xae...e1cc58', // ✅ indexed argument (bar)
    '0x00...000000', // ✅ indexed argument (barry)
  ],
  ...
}
```

A non-conforming log for the above signature would be:

```ts
const log = {
  ...
  data: '0x
    00...23c346 // ✅ non-indexed argument (baz)
    00...ae0000 // ❌ indexed argument (bar)
    00...000001 // ❌ indexed argument (barry)
  ',
  topics: [
    '0xdd...23b3ef', // event signature
    '0x00...b92266', // ✅ indexed argument (foo)
  ],
  ...
}
```

A non-conforming log can arise when another contract could be using the same event signature, but with a different number of indexed & non-indexed arguments. For example, the definition for the above log would be:

```solidity
event Transfer(
  bool indexed foo, 
  uint256 baz, 
  string bar, 
  boolean barry
)
```

## Transaction

A transaction is a message sent by an Account requesting to perform an action on the Ethereum blockchain. Transactions can be used to transfer Ether between accounts, execute smart contract code, deploy smart contracts, etc.

## Transaction Receipt

A Transaction Receipt is a record of the result of a specific transaction on the Ethereum blockchain. When a transaction is submitted to the Ethereum network, it is processed by miners and included in a block. Once the block is added to the blockchain, a transaction receipt is generated and stored on the blockchain.

A transaction receipt contains information about the transaction, including:

- The transaction hash: a unique identifier for the transaction.
- The block number and block hash: the block in which the transaction was included.
- The gas used: the amount of gas consumed by the transaction.
- The status of the transaction: "success" if the transaction was executed, otherwise "reverted" if the transaction reverted. 
- The logs generated by the transaction: any log events generated by the smart contract during the transaction execution.

## Transport

A Transport is the intermediary layer that is responsible for executing outgoing requests (ie. RPC requests) in viem.
</file>

<file path="glossary/types.md">
# Types [Glossary of Types in viem.]

## `Abi`

Type matching the [Contract ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html#json)

Re-exported from [ABIType](https://abitype.dev/api/types#abi).

## `AbiError`

ABI [Error](https://docs.soliditylang.org/en/latest/abi-spec#errors) type.

Re-exported from [ABIType](https://abitype.dev/api/types#abierror).

## `AbiEvent`

ABI [Event](https://docs.soliditylang.org/en/latest/abi-spec#events) type.

Re-exported from [ABIType](https://abitype.dev/api/types#abievent).

## `AbiFunction`

ABI [Function](https://docs.soliditylang.org/en/latest/abi-spec#argument-encoding) type.

Re-exported from [ABIType](https://abitype.dev/api/types#abifunction).

## `AbiParameter`

`inputs` and `outputs` item for ABI functions, events, and errors.

Re-exported from [ABIType](https://abitype.dev/api/types#abiparameter).

## `AbiParameterToPrimitiveTypes`

Converts `AbiParameter` to corresponding TypeScript primitive type.

[See more](https://abitype.dev/api/utilities#abiparametertoprimitivetype)

## `AbiParametersToPrimitiveTypes`

Converts array of `AbiParameter` to corresponding TypeScript primitive types.

[See more](https://abitype.dev/api/utilities#abiparameterstoprimitivetypes)

## `AccessList`

An access list.

## `Address`

An address.

Re-exported from [ABIType](https://abitype.dev/api/types#address).

## `Block`

A type for a [Block](/docs/glossary/terms#block).

[See Type](https://github.com/wevm/viem/blob/main/src/types/block.ts)

## `Chain`

A type for a [Chain](/docs/glossary/terms#chain).

[See Type](https://github.com/wevm/viem/blob/main/src/types/chain.ts)

## `CompactSignature`

A type for [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098) compact signatures.

[See Type](https://github.com/wevm/viem/blob/main/src/types/misc.ts)

## `FeeHistory`

A type for fee history.

[See Type](https://github.com/wevm/viem/blob/main/src/types/fee.ts)

## `FeeValues`

A type for fee values.

[See Type](https://github.com/wevm/viem/blob/main/src/types/fee.ts)

## `Filter`

A type for a [Filter](/docs/glossary/terms#filter).

[See Type](https://github.com/wevm/viem/blob/main/src/types/filter.ts)

## `Hash`

Type for a hashed value – a "0x"-prefixed string: `"0x${string}"`

## `Hex`

Type for a hex value – a "0x"-prefixed string: `"0x${string}"`

## `Log`

A type for [Event Logs](/docs/glossary/terms#event-log).

[See Type](https://github.com/wevm/viem/blob/main/src/types/log.ts)

## `Signature`

A type for a structured signature.

[See Type](https://github.com/wevm/viem/blob/main/src/types/misc.ts)

## `Transaction`

A type for [Transactions](/docs/glossary/terms#transaction).

[See Type](https://github.com/wevm/viem/blob/main/src/types/transaction.ts)

## `TransactionReceipt`

A type for [Transaction Receipts](/docs/glossary/terms#transaction-receipt).

[See Type](https://github.com/wevm/viem/blob/main/src/types/transaction.ts)

## `Transport`

A type for [Transports](/docs/glossary/terms#transports).

[See Type](https://github.com/wevm/viem/blob/main/src/clients/transports/createTransport.ts)

## `WalletPermission`

A type for wallet (JSON-RPC Account) permissions.

[See Type](https://github.com/wevm/viem/blob/main/src/types/eip1193.ts)

## `TransactionSerializedEIP1559`

EIP-1559 transaction hex value – a "0x02"-prefixed string: `"0x02${string}"`

## `TransactionSerializedEIP2930`

EIP-2930 transaction hex value – a "0x01"-prefixed string: `"0x01${string}"`

## `TransactionSerializedLegacy`

Legacy transaction hex value – a "0x"-prefixed string: `"0x${string}"`

## `TransactionType`

All types of transactions. `"eip1559" | "eip2930" | "eip4844" | "eip7702" | "legacy"`

## `TransactionRequest`

A type for all transaction requests.

[See Type](https://github.com/wevm/viem/blob/main/src/types/transaction.ts).

## `StateOverride`

A type defining state overrides for `eth_call` method. [See more](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-eth#eth-call)
</file>

<file path="guides/blob-transactions.md">
# Blob Transactions [Sending your first Blob Transaction with Viem.]

Blob Transactions are a new type of transaction in Ethereum (introduced in [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)) that allows you to broadcast BLObs (Binary Large Objects) to the Ethereum network. Blob Transactions are like any other transaction, but with the added ability to carry a payload of Blobs. Blobs are extremely larger than regular calldata (~128kB), however unlike regular calldata, they are not accessible on the EVM. The EVM can only view the commitments of the blobs. Blobs are also transient, and only last for 4096 epochs (approx. 18 days).

To read more on Blob Transactions and EIP-4844, check out these resources: 

- [EIP-4844 Spec](https://eips.ethereum.org/EIPS/eip-4844)
- [EIP-4844 Website](https://www.eip4844.com/#faq)
- [EIP-4844 FAQ](https://notes.ethereum.org/@vbuterin/proto_danksharding_faq#Proto-Danksharding-FAQ)

In this guide, we will walk you through how to send your first Blob Transaction with Viem.

::::steps

## Set up Client

We will first set up our Viem Client. 

Let's create a `client.ts` file that holds our Client.

```ts twoslash [client.ts] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

export const account = privateKeyToAccount('0x...')

export const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
})
```

## Install KZG bindings

Next, we will need to install some KZG bindings. KZG will be used to compute the commitments of the blobs, and generate proofs from the blobs & commitments. The commitments and proofs are needed to serialize and sign the Blob Transaction before we send it off.

A couple of KZG implementations we recommend are:
- [c-kzg](https://github.com/ethereum/c-kzg-4844): Node.js bindings to c-kzg.
- [kzg-wasm](https://github.com/ethereumjs/kzg-wasm): WebAssembly bindings to c-kzg.

:::code-group

```bash [npm]
npm i c-kzg
# or
npm i kzg-wasm
```

```bash [pnpm]
pnpm i c-kzg
# or
pnpm i kzg-wasm
```

```bash [bun]
bun i c-kzg
# or
bun i kzg-wasm
```

:::

## Set up KZG interface

After that, we will need to hook up the KZG bindings to Viem.

Let's create a `kzg.ts` file that holds our KZG interface.

:::code-group

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

```ts twoslash [client.ts]
// [!include client.ts]
```

:::

## Send Blob Transaction

Now that we have our Client and KZG interface set up, we can send our first Blob Transaction.

For demonstration purposes, we will construct a blob with a simple string: `"hello world"`, and send it to the zero address.

:::code-group

```ts twoslash [example.ts]
import { parseGwei, stringToHex, toBlobs } from 'viem'
import { account, client } from './client'
import { kzg } from './kzg'

const blobs = toBlobs({ data: stringToHex('hello world') })

const hash = await client.sendTransaction({
  blobs,
  kzg,
  maxFeePerBlobGas: parseGwei('30'),
  to: '0x0000000000000000000000000000000000000000',
})
```

```ts twoslash [kzg.ts]
// [!include kzg.ts]
```

```ts twoslash [client.ts]
// [!include client.ts]
```

:::

::::

## That's it!

You've just sent your first Blob Transaction with Viem. 

With the `hash` you received in Step 4, you can now track your Blob Transaction on a blob explorer like [Blobscan](https://blobscan.com/).
</file>

<file path="siwe/actions/verifySiweMessage.md">
---
description: Verifies EIP-4361 formatted message was signed.
---

# verifySiweMessage

Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.

See [`createSiweMessage`](/docs/siwe/utilities/createSiweMessage) for info on how to create a EIP-4361 formatted message.

## Usage

:::code-group

```ts twoslash [example.ts]
import { account, walletClient, publicClient } from './client'
import { message } from './message'

const signature = await walletClient.signMessage({ account, message })
// [!code focus:99]
const valid = await publicClient.verifySiweMessage({
  message,
  signature,
})
// @log: true
```

```ts twoslash [client.ts] filename="client.ts"
import 'viem/window'
// ---cut---
import { createPublicClient, createWalletClient, custom, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

export const walletClient = createWalletClient({
  transport: custom(window.ethereum!)
})

// @log: ↓ JSON-RPC Account
export const [account] = await walletClient.getAddresses()

// @log: ↓ Local Account
// export const account = privateKeyToAccount(...)
```

```ts twoslash [message.ts] filename="message.ts"
// ---cut---
import { createSiweMessage, generateSiweNonce } from 'viem/siwe'
import { mainnet } from 'viem/chains'
import { account } from './client'

export const message = createSiweMessage({
  address: account.address,
  chainId: mainnet.id,
  domain: 'example.com',
  nonce: generateSiweNonce(),
  uri: 'https://example.com/path',
  version: '1',
})
```

:::

## Returns

`boolean`

Whether the signed message is valid for the given address.

## Parameters

### message

- **Type:** `string`

[EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message to be verified.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
import { createSiweMessage, generateSiweNonce } from 'viem/siwe'
// ---cut---
const valid = await publicClient.verifySiweMessage({
  message: createSiweMessage({ // [!code focus:1]
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
    chainId: 1, // [!code focus:1]
    domain: 'example.com', // [!code focus:1]
    nonce: generateSiweNonce(), // [!code focus:1]
    uri: 'https://example.com/path', // [!code focus:1]
    version: '1', // [!code focus:1]
  }), // [!code focus:1]
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### signature

- **Type:** `Hex`

The signature that was generated by signing the message with the address's signer.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', // [!code focus:1]
})
```

### address (optional)

- **Type:** `Address`

Ethereum address to check against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### blockNumber (optional)

- **Type:** `number`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  blockNumber: 42069n, // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  blockTag: 'safe', // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### domain (optional)

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority to check against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  domain: 'viem.sh', // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### nonce (optional)

- **Type:** `string`

Random string to check against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
import { generateSiweNonce } from 'viem/siwe'
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  nonce: generateSiweNonce(), // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### scheme (optional)

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme to check against.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  scheme: 'https', // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### time (optional)

- **Type:** `Date`
- **Default:** `new Date()`

Current time to check optional [`expirationTime`](/docs/siwe/utilities/createSiweMessage#expirationtime-optional) and [`notBefore`](/docs/siwe/utilities/createSiweMessage#notbefore-optional) message fields.

```ts twoslash
// [!include ~/snippets/publicClient.ts]
declare const message: string
// ---cut---
const valid = await publicClient.verifySiweMessage({
  time: new Date(), // [!code focus:1]
  message,
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
</file>

<file path="siwe/utilities/createSiweMessage.md">
---
description: Creates EIP-4361 formatted message.
---

# createSiweMessage

Creates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.

## Import

```ts twoslash
import { createSiweMessage } from 'viem/siwe'
```

## Usage

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
})
```

## Returns

`string`

EIP-4361 formatted message.

## Parameters

### address

- **Type:** `Address`

The Ethereum address performing the signing.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', // [!code focus]
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
})
```

### chainId

- **Type:** `number`

The [EIP-155](https://eips.ethereum.org/EIPS/eip-155) Chain ID to which the session is bound.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
  chainId: 1, // [!code focus]
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
})
```

### domain

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority that is requesting the signing.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com', // [!code focus]
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
})
```

### nonce

- **Type:** `string`

A random string typically chosen by the relying party and used to prevent replay attacks.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz', // [!code focus]
  uri: 'https://example.com/path',
  version: '1',
})
```

### uri

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI referring to the resource that is the subject of the signing (as in the subject of a claim).

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path', // [!code focus]
  version: '1',
})
```

### version

- **Type:** `'1'`

The current version of the SIWE Message.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1', // [!code focus]
})
```

### expirationTime (optional)

- **Type:** `Date`

Time when the signed authentication message is no longer valid.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  expirationTime: new Date(),  // [!code focus]
})
```

### issuedAt (optional)

- **Type:** `Date`

Time when the message was generated, typically the current time.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  issuedAt: new Date(),  // [!code focus]
})
```

### notBefore (optional)

- **Type:** `Date`

Time when the signed authentication message will become valid.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  notBefore: new Date(),  // [!code focus]
})
```

### requestId (optional)

- **Type:** `string`

A system-specific identifier that may be used to uniquely refer to the sign-in request.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  requestId: '123e4567-e89b-12d3-a456-426614174000', // [!code focus]
})
```

### resources (optional)

- **Type:** `string[]`

A list of information or references to information the user wishes to have resolved as part of authentication by the relying party.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  resources: [ // [!code focus]
    'https://example.com/foo', // [!code focus]
    'https://example.com/bar', // [!code focus]
    'https://example.com/baz', // [!code focus]
  ], // [!code focus]
})
```

### scheme (optional)

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme of the origin of the request.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  scheme: 'https', // [!code focus]
})
```

### statement (optional)

- **Type:** `string`

A human-readable ASCII assertion that the user will sign.

```ts twoslash
import { createSiweMessage } from 'viem/siwe'

const message = createSiweMessage({
  address: '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
  chainId: 1,
  domain: 'example.com',
  nonce: 'foobarbaz',
  uri: 'https://example.com/path',
  version: '1',
  statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos', // [!code focus]
})
```
</file>

<file path="siwe/utilities/generateSiweNonce.md">
---
description: Generates random EIP-4361 nonce.
---

# generateSiweNonce

Generates random [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) nonce.

## Import

```ts twoslash
import { generateSiweNonce } from 'viem/siwe'
```

## Usage

```ts twoslash
import { generateSiweNonce } from 'viem/siwe'

const nonce = generateSiweNonce()
```

## Returns

`string`

A randomly generated EIP-4361 nonce.
</file>

<file path="siwe/utilities/parseSiweMessage.md">
---
description: Parses EIP-4361 formatted message into message fields object.
---

# parseSiweMessage

Parses [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message into message fields object.

## Import

```ts twoslash
import { parseSiweMessage } from 'viem/siwe'
```

## Usage

```ts twoslash
import { parseSiweMessage } from 'viem/siwe'

const message = `example.com wants you to sign in with your Ethereum account:
0xA0Cf798816D4b9b9866b5330EEa46a18382f251e

I accept the ExampleOrg Terms of Service: https://example.com/tos

URI: https://example.com/path
Version: 1
Chain ID: 1
Nonce: foobarbaz
Issued At: 2023-02-01T00:00:00.000Z`
const fields = parseSiweMessage(message)
fields.address
//     ^?



```

## Returns

`SiweMessage`

EIP-4361 fields object

## Parameters

### message

- **Type:** `string`

EIP-4361 formatted message
</file>

<file path="siwe/utilities/validateSiweMessage.md">
---
description: Validates EIP-4361 message.
---

# validateSiweMessage

Validates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message.

## Import

```ts twoslash
import { validateSiweMessage } from 'viem/siwe'
```

## Usage

```ts twoslash
import { validateSiweMessage } from 'viem/siwe'

const valid = validateSiweMessage({
  address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
  message: {
    address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    chainId: 1,
    domain: 'example.com',
    nonce: 'foobarbaz',
    uri: 'https://example.com/path',
    version: '1',
  },
})
```

## Returns

`boolean`

Whether the message fields are valid.

## Parameters

### message

- **Type:** `Partial<SiweMessage>`

EIP-4361 message fields.

### address (optional)

- **Type:** `string`

Ethereum address to check against.

### domain (optional)

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority to check against.

### nonce (optional)

- **Type:** `string`

Random string to check against.

### scheme (optional)

- **Type:** `string`

[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme to check against.

### time (optional)

- **Type:** `Date`
- **Default:** `new Date()`

Current time to check optional [`expirationTime`](http://localhost:5173/docs/siwe/utilities/createSiweMessage#expirationtime-optional) and [`notBefore`](/docs/siwe/utilities/createSiweMessage#notbefore-optional) message fields.
</file>

<file path="utilities/blobsToCommitments.md">
---
description: Compute commitments from a list of blobs.
---

# blobsToCommitments

Compute commitments from a list of blobs.

## Import

```ts twoslash
import { blobsToCommitments } from 'viem'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { blobsToCommitments, toBlobs } from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x1234' })
const commitments = blobsToCommitments({ blobs, kzg }) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

:::

## Returns

`Hex[] | ByteArray[]`

List of commitments corresponding to the input blobs.

## Parameters

### blobs

- **Type:** `Hex[] | ByteArray[]`

List of blobs to transform into commitments.

```ts twoslash
import { defineKzg } from 'viem'
const kzg = defineKzg({} as any)

// ---cut---
import { blobsToCommitments, toBlobs } from 'viem'

const commitments = blobsToCommitments({ 
  blobs: toBlobs({ data: '0x1234' }), // [!code focus]  
  kzg, 
}) 
```

### kzg

- **Type:** `KZG`

KZG implementation. See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg'
import { blobsToCommitments, setupKzg, toBlobs } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]

const commitments = blobsToCommitments({ 
  blobs: toBlobs({ data: '0x1234' }),  
  kzg, // [!code focus]
}) 
```

### to

- **Type:** `"bytes" | "hex"`

The output type.

```ts twoslash
import { defineKzg } from 'viem'
const kzg = defineKzg({} as any)

// ---cut---
import { blobsToCommitments, toBlobs } from 'viem'

const commitments = blobsToCommitments({ 
  blobs: toBlobs({ data: '0x1234' }),
  kzg, 
  to: 'bytes', // [!code focus]  
}) 

commitments // [!code focus]
// ^?


```
</file>

<file path="utilities/blobsToProofs.md">
---
description: Compute the proofs for a list of blobs and their commitments.
---

# blobsToProofs

Compute the proofs for a list of blobs and their commitments.

## Import

```ts twoslash
import { blobsToProofs } from 'viem'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { blobsToCommitments, blobsToProofs, toBlobs } from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' })
const commitments = blobsToCommitments({ blobs, kzg })
const proofs = blobsToProofs({ blobs, commitments, kzg }) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'

export const kzg = setupKzg('./trusted-setup.json', cKzg)
```

:::

## Returns

`Hex[] | ByteArray[]`

Proofs from the input blobs and commitments.

## Parameters

### blobs

- **Type:** `Hex[] | ByteArray[]`

Blobs to transform into proofs.

```ts twoslash
import { blobsToCommitments, blobsToProofs, toBlobs } from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' }) // [!code focus]
const commitments = blobsToCommitments({ blobs, kzg })

const proofs = blobsToProofs({ 
  blobs, // [!code focus]
  commitments, 
  kzg 
})
```

### commitments

- **Type:** `Hex[] | ByteArray[]`

Commitments corresponding to the input blobs.

```ts twoslash
import { blobsToCommitments, blobsToProofs, toBlobs } from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' })
const commitments = blobsToCommitments({ blobs, kzg }) // [!code focus]

const proofs = blobsToProofs({ 
  blobs,
  commitments,  // [!code focus]
  kzg 
})
```

### kzg

- **Type:** `KZG`

KZG implementation. See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg'
import { blobsToProofs, setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const blobs = toBlobs({ data: '0x...' })
const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]
const commitments = blobsToCommitments({ blobs, kzg })

const proofs = blobsToProofs({ 
  blobs,
  commitments,
  kzg, // [!code focus]
}) 
```
</file>

<file path="utilities/commitmentsToVersionedHashes.md">
---
description: Transform a list of commitments to their versioned hashes.
---

# commitmentsToVersionedHashes

Transform a list of commitments to their versioned hashes.

## Import

```ts twoslash
import { commitmentsToVersionedHashes } from 'viem'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { 
  blobsToCommitments, 
  commitmentsToVersionedHashes, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x1234' })
const commitments = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentsToVersionedHashes({  // [!code focus]
  commitments,  // [!code focus]
}) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

:::

## Returns

`Hex[] | ByteArray[]`

List of versioned hashes corresponding to the input commitments.

## Parameters

### commitments

- **Type:** `Hex[] | ByteArray[]`

List of commitments to transform into versioned hashes.

```ts twoslash
import { 
  blobsToCommitments, 
  commitmentsToVersionedHashes, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'
// ---cut---
const blobs = toBlobs({ data: '0x1234' })
const commitments = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentsToVersionedHashes({ 
  commitments,  // [!code focus]
  kzg, 
})
```

### to

- **Type:** `"bytes" | "hex"`

The output type.

```ts twoslash
import { 
  blobsToCommitments, 
  commitmentsToVersionedHashes, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'
// ---cut---
const blobs = toBlobs({ data: '0x1234' })
const commitments = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentsToVersionedHashes({ 
  commitments, 
  to: 'bytes' // [!code focus]
})
versionedHashes // [!code focus]
//  ^?


```

### version

- **Type:** `number`
- **Default:** `1`

Version to tag onto the hashes. Defaults to `1`.

```ts twoslash
import { 
  blobsToCommitments, 
  commitmentsToVersionedHashes, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'
// ---cut---
const blobs = toBlobs({ data: '0x1234' })
const commitments = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentsToVersionedHashes({ 
  commitments, 
  version: 69, // [!code focus]
})
```
</file>

<file path="utilities/commitmentToVersionedHash.md">
---
description: Transform a commitment to it's versioned hash.
---

# commitmentToVersionedHash

Transform a commitment to it's versioned hash.

## Import

```ts twoslash
import { commitmentToVersionedHash } from 'viem'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { 
  blobsToCommitments, 
  commitmentToVersionedHash, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x1234' })
const [commitment] = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentToVersionedHash({  // [!code focus]
  commitment,  // [!code focus]
}) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

:::

## Returns

`Hex | ByteArray`

Versioned hash corresponding to the commitment.

## Parameters

### commitment

- **Type:** `Hex | ByteArray`

Commitment to transform into a versioned hash.

```ts twoslash
import { 
  blobsToCommitments, 
  commitmentToVersionedHash, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'
// ---cut---
const blobs = toBlobs({ data: '0x1234' })
const [commitment] = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentToVersionedHash({ 
  commitment,  // [!code focus]
})
```

### to

- **Type:** `"bytes" | "hex"`

The output type.

```ts twoslash
import { 
  blobsToCommitments, 
  commitmentToVersionedHash, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'
// ---cut---
const blobs = toBlobs({ data: '0x1234' })
const [commitment] = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentToVersionedHash({ 
  commitment, 
  to: 'bytes' // [!code focus]
})
versionedHashes // [!code focus]
//  ^?


```

### version

- **Type:** `number`
- **Default:** `1`

Version to tag onto the hash. Defaults to `1`.

```ts twoslash
import { 
  blobsToCommitments, 
  commitmentToVersionedHash, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'
// ---cut---
const blobs = toBlobs({ data: '0x1234' })
const [commitment] = blobsToCommitments({ blobs, kzg })
const versionedHashes = commitmentToVersionedHash({ 
  commitment, 
  version: 69, // [!code focus]
})
```
</file>

<file path="utilities/compactSignatureToSignature.md">
---
description: Parses a compact signature into signature format.
---

# compactSignatureToSignature

Parses a [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098) compact signature into signature format.

## Import

```ts
import { compactSignatureToSignature } from 'viem'
```

## Usage

```ts
import { compactSignatureToSignature } from 'viem'

compactSignatureToSignature({ // [!code focus:10]
  r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
  yParityAndS:
    '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
})
// {
//   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
//   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
//   yParity: 0,
// }
```

## Returns

[`Signature`](/docs/glossary/types#signature)

The signature.

## Parameters

### compactSignature

The compact signature.

- **Type:** [`CompactSignature`](/docs/glossary/types#CompactSignature)
</file>

<file path="utilities/concat.md">
---
description: Concatenates a set of hex values or byte arrays.
---

# concat

Concatenates a set of hex values or byte arrays.

## Install

```ts
import { concat } from 'viem'
```

## Usage

```ts
import { concat } from 'viem'

concat(['0x00000069', '0x00000420'])
// 0x0000006900000420

concat([new Uint8Array([69]), new Uint8Array([420])])
// Uint8Array [69, 420]
```

## Returns

`Hex | ByteArray`

The concatenated value.
</file>

<file path="utilities/defineKzg.md">
---
description: Defines a KZG interface.
---

# defineKzg

Defines a [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) compatible [KZG interface](https://notes.ethereum.org/@vbuterin/proto_danksharding_faq#How-%E2%80%9Ccomplicated%E2%80%9D-and-%E2%80%9Cnew%E2%80%9D-is-KZG). The KZG interface is used in the blob transaction signing process to generate KZG commitments & proofs.

`defineKzg` accepts a KZG interface that implements two functions:

- `blobToKzgCommitment`: A function that takes a blob and returns it's KZG commitment.
- `computeBlobKzgProof`: A function that takes a blob and it's commitment, and returns the KZG proof.

A couple of KZG implementations we recommend are:
- [c-kzg](https://github.com/ethereum/c-kzg-4844): Node.js bindings to c-kzg.
- [kzg-wasm](https://github.com/ethereumjs/kzg-wasm): WebAssembly bindings to c-kzg.

## Import

```ts twoslash
import { defineKzg } from 'viem'
```

## Usage

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg'
import { defineKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

cKzg.loadTrustedSetup(mainnetTrustedSetupPath)

const kzg = defineKzg(cKzg)
```

## Returns

`Kzg`

The KZG interface.

## Parameters

### blobToKzgCommitment

- **Type:** `(blob: ByteArray) => ByteArray`

Convert a blob to a KZG commitment.

### computeBlobKzgProof

- **Type:** `(blob: ByteArray, commitment: ByteArray) => ByteArray`

Given a blob, return the KZG proof that is used to verify it against the commitment.
</file>

<file path="utilities/extractChain.md">
# extractChain

Extracts a type-safe chain by ID from a set of chains.

## Usage

```ts
import { extractChain } from 'viem'
import { mainnet, base, optimism, zora } from 'viem/chains'

const optimism = extractChain({
  chains: [mainnet, base, optimism, zora],
  id: 10,
})

optimism.id
//       ^? (property) id: 10
optimism.name
//       ^? (property) name: "OP Mainnet"
```

It is also possible to use **all chains** from the `viem/chains` module:

```ts
import { extractChain } from 'viem'
import { mainnet, base, optimism, zora } from 'viem/chains' // [!code --]
import * as chains from 'viem/chains' // [!code ++]

const optimism = extractChain({
  chains: [mainnet, base, optimism, zora], // [!code --]
  chains: Object.values(chains), // [!code ++]
  id: 10,
})

optimism.id
//       ^? (property) id: 10
optimism.name
//       ^? (property) name: "OP Mainnet"
```

:::warning
By importing all chains from `viem/chains`, this will significantly increase the size of your bundle. It is only recommended to use this method where bundle size is not a concern (ie. server-side, scripts, etc).
:::

## Returns

- **Type:** `Chain` (inferred)

The extracted chain.

## Parameters

### chains

- **Type:** `readonly Chain[]`

The set of chains where the chain will be extracted from.

### id

- **Type:** `number`

The ID of the chain to extract.
</file>

<file path="utilities/formatEther.md">
---
description: Converts numerical wei to a string representation of ether.
---

# formatEther

Converts numerical wei to a string representation of ether.

## Import

```ts
import { formatEther } from 'viem'
```

## Usage

```ts
import { formatEther } from 'viem'

formatEther(1000000000000000000n) // [!code focus:2]
// '1'
```

## Returns

`string`

## Parameters

### value

- **Type:** `bigint`

The wei value.
</file>

<file path="utilities/formatGwei.md">
---
description: Converts numerical wei to a string representation of gwei.
---

# formatGwei

Converts numerical wei to a string representation of gwei.

## Import

```ts
import { formatGwei } from 'viem'
```

## Usage

```ts
import { formatGwei } from 'viem'

formatGwei(1000000000n) // [!code focus:2]
// '1'
```

## Returns

`string`

## Parameters

### value

- **Type:** `bigint`

The wei value.
</file>

<file path="utilities/formatUnits.md">
---
description: Divides a number by a given exponent of base 10, and formats it into a string representation of the number.
---

# formatUnits

Divides a number by a given exponent of base 10 (10<sup>exponent</sup>), and formats it into a string representation of the number.

## Import

```ts
import { formatUnits } from 'viem'
```

## Usage

```ts
import { formatUnits } from 'viem'

formatUnits(420000000000n, 9) // [!code focus:2]
// '420'
```

## Returns

`string`

## Parameters

### value

- **Type:** `bigint`

The number to divide.

### exponent 

- **Type:** `number`

The exponent.
</file>

<file path="utilities/fromBase58.md">
# fromBase58

Coming soon.
</file>

<file path="utilities/fromBase64.md">
# fromBase64

Coming soon.
</file>

<file path="utilities/fromBlobs.md">
---
description: Transforms blobs into the originating data.
---

# fromBlobs

Transforms Viem-shaped blobs into the originating data. 

:::warning
This function transforms data from Viem-shaped blobs. It is designed to be used with Viem's `toBlobs` function to convert arbitrary data to blobs.
:::

## Import

```ts twoslash
import { fromBlobs } from 'viem'
```

## Usage

```ts twoslash [example.ts]
import { fromBlobs } from 'viem'

const data = fromBlobs({ blobs: ['0x...'] })
```

## Returns

`Hex | ByteArray`

Data extracted from blobs.

## Parameters

### blobs

- **Type:** `Hex[] | ByteArray[]`

Transforms blobs into the originating data.

```ts twoslash
import { fromBlobs } from 'viem'

const data = fromBlobs({ 
  blobs: ['0x...'] // [!code focus]
})
```

### to

- **Type:** `"bytes" | "hex"`

The output type.

```ts twoslash
import { fromBlobs } from 'viem'

const data = fromBlobs({ 
  blobs: ['0x...'],
  to: 'bytes' // [!code focus]
})

data // [!code focus]
// ^?


```
</file>

<file path="utilities/fromBytes.md">
---
description: Decodes a byte array to a string, hex value, boolean or number.
---

# fromBytes

Decodes a byte array to a string, hex value, boolean or number.

Shortcut Functions:

- [bytesToHex](#bytestohex)
- [bytesToString](#bytestostring)
- [bytesToNumber](#bytestonumber)
- [bytesToBigInt](#bytestobigint)
- [bytesToBool](#bytestobool)

## Import

```ts
import { fromBytes } from 'viem'
```

## Usage

```ts
import { fromBytes } from 'viem'

fromBytes(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), 
  'string'
)
// 'Hello world'

fromBytes(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), 
  'hex'
)
// '0x48656c6c6f20576f726c6421'

fromBytes(new Uint8Array([1, 164]), 'number')
// 420

fromBytes(new Uint8Array([1]), 'boolean')
// true
```

## Returns

`string | Hex | number | bigint | boolean`

The targeted type.

## Parameters

### value

- **Type:** `ByteArray`

The byte array to decode.

### toOrOptions

- **Type:** `"string" | "hex" | "number" | "bigint" | "boolean" | Options`

The output type or options.

```ts 
fromBytes(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), 
  'string' // [!code focus]
)
// 'Hello world'
```

```ts 
fromBytes(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 
  { // [!code focus]
    size: 32, // [!code focus]
    to: 'string' // [!code focus]
  } // [!code focus]
)
// 'Hello world'
```

## Shortcut Functions

### bytesToHex

- **Type:** `Hex`

Decodes a byte array to a hex value.

```ts
import { bytesToHex } from 'viem'

bytesToHex( // [!code focus:4]
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
)
// '0x48656c6c6f20576f726c6421'

bytesToHex( // [!code focus:5]
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 
  { size: 32 }
)
// '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
```

### bytesToString

- **Type:** `Hex`

Decodes a byte array to a string.

```ts
import { bytesToString } from 'viem'

bytesToString( // [!code focus:4]
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
)
// 'Hello world'

bytesToString( // [!code focus:5]
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 
  { size: 32 }
)
// 'Hello world'
```

### bytesToNumber

- **Type:** `number`

Decodes a byte array to a number.

```ts
import { bytesToNumber } from 'viem'

bytesToNumber(new Uint8Array([1, 164])) // [!code focus:2]
// 420

bytesToNumber( // [!code focus:5]
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 164]), 
  { size: 32 }
)
// 420
```

### bytesToBigInt

- **Type:** `number`

Decodes a byte array to a number.

```ts
import { bytesToBigInt } from 'viem'

bytesToBigInt( // [!code focus:4]
  new Uint8Array([12, 92, 243, 146, 17, 135, 111, 181, 229, 136, 67, 39, 250, 86, 252, 11, 117])
)
// 4206942069420694206942069420694206942069n

bytesToBigInt( // [!code focus:5]
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 92, 243, 146, 17, 135, 111, 181, 229, 136, 67, 39, 250, 86, 252, 11, 117]),
  { size: 32 }
)
// 4206942069420694206942069420694206942069n
```

### bytesToBool

- **Type:** `boolean`

Decodes a byte array to a boolean.

```ts
import { bytesToBool } from 'viem'

bytesToBool(new Uint8Array([1])) // [!code focus:2]
// true

bytesToBool( // [!code focus:5]
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
  { size: 32 }
) 
// true
```
</file>

<file path="utilities/fromHex.md">
---
description: Decodes a hex value to a string, number or byte array.
---

# fromHex

Decodes a hex value to a string, number or byte array.

Shortcut Functions:

- [hexToNumber](#hextonumber)
- [hexToBigInt](#hextobigint)
- [hexToString](#hextostring)
- [hexToBytes](#hextobytes)
- [hexToBool](#hextobool)

## Import

```ts
import { fromHex } from 'viem'
```

## Usage

```ts
import { fromHex } from 'viem'

fromHex('0x1a4', 'number')
// 420

fromHex('0xc5cf39211876fb5e5884327fa56fc0b75', 'bigint')
// 4206942069420694206942069420694206942069n

fromHex('0x48656c6c6f20776f726c642e', 'string')
// "Hello world"

fromHex('0x48656c6c6f20576f726c6421', 'bytes')
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])

fromHex('0x1', 'boolean')
// true
```

## Returns

`string | bigint | number | ByteArray`

The targeted type.

## Parameters

### hex

- **Type:** `Hex`

The hex value to decode.

### toOrOptions

- **Type:** `"string" | "hex" | "number" | "bigint" | "boolean" | Options`

The output type or options.

```ts 
fromHex(
  '0x48656c6c6f20776f726c642e', 
  'string' // [!code focus]
)
// 'Hello world'
```

```ts 
fromHex(
  '0x48656c6c6f20776f726c642e0000000000000000000000000000000000000000', 
  { // [!code focus]
    size: 32, // [!code focus]
    to: 'string' // [!code focus]
  } // [!code focus]
)
// 'Hello world'
```

## Shortcut Functions

### hexToNumber

- **Type:** `Hex`

Decodes a hex value to a number.

```ts
import { hexToNumber } from 'viem'

hexToNumber('0x1a4')
// 420

hexToNumber(
  '0x00000000000000000000000000000000000000000000000000000000000001a4', 
  { size: 32 }
)
// 420
```

### hexToBigInt

- **Type:** `Hex`

Decodes a hex value to a bigint.

```ts
import { hexToBigInt } from 'viem'

hexToBigInt('0xc5cf39211876fb5e5884327fa56fc0b75')
// 4206942069420694206942069420694206942069n

hexToBigInt(
  '0x0000000000000000000000000000000c5cf39211876fb5e5884327fa56fc0b75', 
  { size: 32 }
)
// 4206942069420694206942069420694206942069n
```

### hexToString

- **Type:** `Hex`

Decodes a hex value to a string.

```ts
import { hexToString } from 'viem'

hexToString('0x48656c6c6f20576f726c6421')
// "Hello World!"

hexToString(
  '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000',
  { size: 32 }
)
// "Hello World!"
```

### hexToBytes

- **Type:** `Hex`

Decodes a hex value to a byte array.

```ts
import { hexToBytes } from 'viem'

hexToBytes('0x48656c6c6f20576f726c6421')
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])

hexToBytes(
  '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000',
  { size: 32 }
)
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```

### hexToBool

- **Type:** `Hex`

Decodes a hex value to a boolean.

```ts
import { hexToBool } from 'viem'

hexToBool('0x1')
// true

hexToBool(
  '0x00000000000000000000000000000000000000000000000000000000000001',
  { size: 32 }
)
// true
```
</file>

<file path="utilities/fromRlp.md">
---
description: Decodes a RLP value into a decoded hex value or byte array.
---

# fromRlp

Decodes a [Recursive-Length Prefix (RLP)](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp) value into a decoded hex value or byte array.

## Import

```ts
import { fromRlp } from 'viem'
```

## Usage

```ts
import { fromRlp } from 'viem'

fromRlp('0x850123456789', 'hex')
// "0x123456789"

fromRlp('0xc67f7f838081e8', 'hex')
// ['0x7f', '0x7f', '0x8081e8']

fromRlp('0x89010203040506070809', 'bytes')
//  Uint8Array [1, 2, 3, 4, 5, 6, 7, 8, 9]

fromRlp(new Uint8Array ([133, 1, 35, 69, 103, 137]), 'hex')
// "0x123456789"
```

## Returns

`Hex | ByteArray`

The hex value or byte array.

## Parameters

### value

- **Type:** `Hex | ByteArray`

The RLP value to decode.

### to

- **Type:** `"bytes" | "hex"`

The output type.
</file>

<file path="utilities/getAddress.md">
---
description: Converts an address into an address that is checksum encoded.
---

# getAddress

Converts an address into an address that is [checksum encoded](https://eips.ethereum.org/EIPS/eip-55). Supports [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).

## Import

```ts
import { getAddress } from 'viem'
```

## Usage

```ts
import { getAddress } from 'viem'

getAddress('0xa5cc3c03994db5b0d9a5eEdD10Cabab0813678ac') // [!code focus:2]
// '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC'
```

## Returns

[`Address`](/docs/glossary/types#address)

The checksummed address.

## Parameters

### address

- **Type:** `string`

An Ethereum address.

### chainId (optional)

- **Type:** `number`

The chain ID of the network the address is on. Complies to [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).

:::warning[Warning]
EIP-1191 checksum addresses are generally not backwards compatible with 
the wider Ethereum ecosystem, meaning it will break when validated against 
an application/tool that relies on EIP-55 checksum encoding (checksum without chainId).

It is highly recommended to not use this feature unless you know what you are doing.

See more: https://github.com/ethereum/EIPs/issues/1121
:::
</file>

<file path="utilities/getContractAddress.md">
---
description: Retrieves a contract address.
---

# getContractAddress

Retrieves the contract address generated by the [`CREATE`](https://ethereum.stackexchange.com/a/68945) or [`CREATE2`](https://eips.ethereum.org/EIPS/eip-1014) opcode – invoked after deploying a contract to the network.

## Import

```ts
import { getContractAddress } from 'viem'
```

## Usage

```ts
import { getContractAddress } from 'viem'

getContractAddress({ // [!code focus:99]
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
  nonce: 69420n
})
// '0xDf2e056f7062790dF95A472f691670717Ae7b1B6'
```

## Returns

[`Address`](/docs/glossary/types#address)

The contract address.

## Parameters

### from (optional)

- **Type:** [`Address`](/docs/glossary/types#address)

The address the contract was deployed from.

```ts
getContractAddress({
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b', // [!code focus:1]
  nonce: 69420n
})
```

### nonce (optional)

- **Type:** [`Address`](/docs/glossary/types#address)

The nonce of the transaction which deployed the contract.

```ts
getContractAddress({
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
  nonce: 69420n // [!code focus:1]
})
```

### opcode (optional)

- **Type:** `"CREATE" | "CREATE2"`
- **Default:** `"CREATE"`

The opcode to invoke the contract deployment. Defaults to `"CREATE"`.

[Learn more about `CREATE2`](https://eips.ethereum.org/EIPS/eip-1014).

```ts
getContractAddress({
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
  opcode: 'CREATE2', // [!code focus:1]
  salt: toBytes('wagmi'),
})
```

### bytecode (optional)

- **Type:** `ByteArray` | [`Hex`](/docs/glossary/types#hex)
- **Only applicable for `opcode: 'CREATE2'` deployments**

The to-be-deployed contract’s bytecode

```ts
getContractAddress({
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...', // [!code focus:1]
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
  opcode: 'CREATE2',
  salt: toBytes('wagmi'),
})
```

### bytecodeHash (optional)

- **Type:** `ByteArray` | [`Hex`](/docs/glossary/types#hex)
- **Only applicable for `opcode: 'CREATE2'` deployments**

A hash of the to-be-deployed contract’s bytecode

```ts
getContractAddress({
  bytecodeHash: '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54', // [!code focus:1]
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
  opcode: 'CREATE2',
  salt: toBytes('wagmi'),
})
```

### salt (optional)

- **Type:** `ByteArray` | [`Hex`](/docs/glossary/types#hex)
- **Only applicable for `opcode: 'CREATE2'` deployments**

An arbitrary value provided by the sender.

```ts
getContractAddress({
  bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
  from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
  opcode: 'CREATE2',
  salt: toBytes('wagmi'), // [!code focus:1]
})
```
</file>

<file path="utilities/hashMessage.md">
---
description: Hashes a message in EIP-191 format.
---

# hashMessage

Calculates an Ethereum-specific hash in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.

## Import

```ts
import { hashMessage } from 'viem'
```

## Usage

```ts
import { hashMessage } from 'viem'

hashMessage('hello world') // [!code focus:2]
// 0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68

// Hash a hex data value.  // [!code focus:3]
hashMessage({ raw: '0x68656c6c6f20776f726c64' })
// 0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68

// Hash a bytes data value.  // [!code focus:6]
hashMessage({ 
  raw: Uint8Array.from([
    104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100,
  ])})
// 0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hashed message.

## Parameters

### message

Message to hash.

- **Type:** `string | { raw: Hex | ByteArray }`
</file>

<file path="utilities/hashTypedData.md">
# hashTypedData [Hashes EIP-712 typed data.]

Calculates an Ethereum-specific hash in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))`.

## Import

```ts
import { hashTypedData } from 'viem'
```

## Usage

```ts
import { hashTypedData } from 'viem'

hashTypedData({
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hashed message.

## Parameters

### domain

**Type:** `TypedDataDomain`

The typed data domain.

```ts
const hash = hashTypedData({
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### types

The type definitions for the typed data.

```ts
const hash = hashTypedData({
  domain,
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### primaryType

**Type:** Inferred `string`.

The primary type to extract from `types` and use in `value`.

```ts
const hash = hashTypedData({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### message

**Type:** Inferred from `types` & `primaryType`.

```ts
const hash = hashTypedData({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', 
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```
</file>

<file path="utilities/isAddress.md">
---
description: Checks if the address is valid.
---

# isAddress

Checks if the address is valid. By default, it also verifies whether the address is in checksum format.

## Import

```ts
import { isAddress } from 'viem'
```

## Usage

```ts
import { isAddress } from 'viem'

isAddress('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC') // [!code focus:2]
// true
```

## Returns

`boolean`

Whether or not the address is valid.

## Parameters

### address

- **Type:** `string`

An Ethereum address.

### options.strict (optional)

- **Type:** `boolean`
- **Default:** `true`

Enables strict mode. If enabled, it also verifies whether the address is in checksum format.

```ts
isAddress('0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac', { strict: false })
// true

isAddress('0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac', { strict: true })
// false

isAddress('lol', { strict: false })
// false
```
</file>

<file path="utilities/isAddressEqual.md">
---
description: Checks if the given addresses (checksummed) are equal.
---

# isAddressEqual

Checks if the given addresses (checksummed) are equal.

## Import

```ts
import { isAddressEqual } from 'viem'
```

## Usage

```ts
import { isAddressEqual } from 'viem'

isAddressEqual('0xa5cc3c03994db5b0d9a5eEdD10Cabab0813678ac', '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC') // [!code focus:2]
// true
```

## Returns

`boolean`

Whether or not the addresses are equal.
</file>

<file path="utilities/isBytes.md">
---
description: Checks whether the value is a byte array or not.
---

# isBytes

Checks whether the value is a byte array or not.

## Install

```ts
import { isBytes } from 'viem'
```

## Usage

```ts
import { isBytes } from 'viem'

isBytes(new Uint8Array([1, 69, 420]))
// true

isBytes([1, 69, 420])
// false
```

## Returns

`boolean`

Returns truthy is the value is a byte array.
</file>

<file path="utilities/isErc6492Signature.md">
---
description: Checks whether the signature is in ERC-6492 format.
---

# isErc6492Signature

Checks whether the signature is in [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492) format.

## Import

```ts
import { isErc6492Signature } from 'viem/utils'
```

## Usage

```ts twoslash
import { isErc6492Signature } from 'viem/utils'

const result = isErc6492Signature('0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492')
```

## Returns

`boolean`

Whether the signature is in ERC-6492 format.

## Parameters

### signature

- **Type:** [`Hex`](/docs/glossary/types#hex)

The signature to check.
</file>

<file path="utilities/isHex.md">
---
description: Checks whether the value is a hex value or not.
---

# isHex

Checks whether the value is a hex value or not.

## Install

```ts
import { isHex } from 'viem'
```

## Usage

```ts
import { isHex } from 'viem'

isHex('0x1a4')
// true

isHex('0x1a4z')
isHex('foo')
// false
```

## Returns

`boolean`

Returns truthy is the value is a hex value.

## Parameters

### value

- **Type:** `unknown`

The value to check.

```ts
isHex(
  '0x1a4' // [!code focus]
)
// true
```

### options.strict

- **Type:** `boolean`
- **Default:** `true`

When enabled, checks if the value strictly consists of only hex characters (`"0x[0-9a-fA-F]*"`).
When disabled, checks if the value loosely matches hex format (`value.startsWith('0x')`).

```ts
isHex('0xlol', { strict: false })
// true

isHex('0xlol', { strict: true })
// false

isHex('lol', { strict: false })
// false
```
</file>

<file path="utilities/keccak256.md">
---
description: Calculates the Keccak256 hash of a byte array.
---

# keccak256

Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a byte array or hex value.

This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes) – an audited & minimal JS hashing library.

## Install

```ts
import { keccak256 } from 'viem'
```

## Usage

```ts
import { keccak256 } from 'viem'

keccak256(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
// 0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0

keccak256('0xdeadbeef')
// 0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1

// hash utf-8 string
keccak256(toHex('hello world'))
// 0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0
```

## Returns

`Hex | ByteArray`

The hashed value.

## Parameters

### value

- **Type:** `Hex | ByteArray`

The hex value or byte array to hash.

### to

- **Type:** `"bytes" | "hex"`
- **Default:** `"hex"`

The output type.

```ts
import { keccak256 } from 'viem'

keccak256(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33],
  'bytes' // [!code focus]
)
// Uint8Array [62, 162, 241, 208, 171, 243, 252, 102, 207, 41, 238, 187, 112, 203, 212, 231, 254, 118, 46, 248, 160, 155, 204, 6, 200, 237, 246, 65, 35, 10, 254, 192] // [!code focus]
```
</file>

<file path="utilities/pad.md">
---
description: Pads a hex value or byte array with leading or trailing zeros.
---

# pad

Pads a hex value or byte array with leading or trailing zeros.

## Install

```ts
import { pad } from 'viem'
```

## Usage

By default, `pad` will pad a value with leading zeros up to 32 bytes (64 hex chars).

```ts
import { pad } from 'viem'

pad('0xa4e12a45')
// 0x00000000000000000000000000000000000000000000000000000000a4e12a45

pad(new Uint8Array([1, 122, 51, 123]))
// Uint8Array [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,122,51,123]
```

## Returns

`Hex | ByteArray`

The value with padded zeros.

## Parameters

### dir

- **Type:** `"left" | "right"`
- **Default:** `"left"`

The direction in which to pad the zeros – either leading (left), or trailing (right).

```ts
pad('0xa4e12a45', {
  dir: 'right'
})
// 0xa4e12a4500000000000000000000000000000000000000000000000000000000
```

### size

- **Type:** `number`
- **Default:** `32`

Size (in bytes) of the targeted value.

```ts
pad('0xa4e12a45', {
  size: 16
})
// 0x000000000000000000000000a4e12a45
```
</file>

<file path="utilities/parseCompactSignature.md">
---
description: Parses a hex formatted compact signature into a structured compact signature.
---

# parseCompactSignature

Parses a hex formatted compact signature into a structured ("split") compact signature.

## Import

```ts
import { parseCompactSignature } from 'viem'
```

## Usage

```ts
import { parseCompactSignature } from 'viem'

parseCompactSignature('0x9328da16089fcba9bececa81663203989f2df5fe1faa6291a45381c81bd17f76939c6d6b623b42da56557e5e734a43dc83345ddfadec52cbe24d0cc64f550793') // [!code focus:7]
/**
 * {
 *   r: '0x9328da16089fcba9bececa81663203989f2df5fe1faa6291a45381c81bd17f76',
 *   yParityAndS: '0x939c6d6b623b42da56557e5e734a43dc83345ddfadec52cbe24d0cc64f550793'
 * }
 */
```

## Returns

[`CompactSignature`](/docs/glossary/types#compactsignature)

The structured ("split") compact signature.

## Parameters

### signatureHex

The compact signature in hex format.

- **Type:** [`Hex`](/docs/glossary/types#hex)
</file>

<file path="utilities/parseErc6492Signature.md">
---
description: Parses a hex-formatted ERC-6492 flavoured signature.
---

# parseErc6492Signature

Parses a hex-formatted [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492) flavoured signature.

If the signature is not in ERC-6492 format, then the underlying (original) signature is returned.

## Import

```ts
import { parseErc6492Signature } from 'viem/utils'
```

## Usage

```ts twoslash
import { parseErc6492Signature } from 'viem/utils'

const { // [!code focus:99]
  address,
  data,
  signature,
} = parseErc6492Signature('0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492')
/**
 * {
 *   address: '0xCafEBAbECAFEbAbEcaFEbabECAfebAbEcAFEBaBe',
 *   data: '0xdeadbeef',
 *   signature: '0xa461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b'
 * }
 */
```

## Returns

`ParseErc6492SignatureReturnType`

The ERC-6492 signature components.

## Parameters

### signature

- **Type:** [`Hex`](/docs/glossary/types#hex)

The ERC-6492 signature in hex format.
</file>

<file path="utilities/parseEther.md">
---
description: Converts a string representation of ether to numerical wei.
---

# parseEther

Converts a string representation of ether to numerical wei.

## Import

```ts
import { parseEther } from 'viem'
```

## Usage

```ts
import { parseEther } from 'viem'

parseEther('420') // [!code focus:2]
// 420000000000000000000n
```

## Returns

`bigint`

## Parameters

### value

- **Type:** `string`

The string representation of ether.
</file>

<file path="utilities/parseGwei.md">
---
description: Converts a string representation of gwei to numerical wei.
---

# parseGwei

Converts a string representation of gwei to numerical wei.

## Import

```ts
import { parseGwei } from 'viem'
```

## Usage

```ts
import { parseGwei } from 'viem'

parseGwei('420') // [!code focus:2]
// 420000000000n
```

## Returns

`bigint`

## Parameters

### value

- **Type:** `string`

The string representation of gwei.
</file>

<file path="utilities/parseSignature.md">
---
description: Parses a hex formatted signature into a structured signature.
---

# parseSignature

Parses a hex formatted signature into a structured ("split") signature.

## Import

```ts
import { parseSignature } from 'viem'
```

## Usage

```ts
import { parseSignature } from 'viem'

parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c') // [!code focus:8]
/**
 * {
 *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',
 *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',
 *   yParity: 1
 * }
 */
```

## Returns

[`Signature`](/docs/glossary/types#signature)

The structured ("split") signature.

## Parameters

### signatureHex

The signature in hex format.

- **Type:** [`Hex`](/docs/glossary/types#hex)
</file>

<file path="utilities/parseTransaction.md">
---
description: Converts a serialized transaction to a structured transaction.
---

# parseTransaction

Parses a serialized RLP-encoded transaction. Supports signed & unsigned EIP-1559, EIP-2930 and Legacy Transactions.

## Import
```ts
import { parseTransaction } from 'viem'
```

## Usage
```ts
import { parseTransaction } from 'viem'

const transaction = parseTransaction('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')
```

## Returns

`TransactionSerializable`

The parsed transaction object.

## Parameters

### serializedTransaction

- **Type:** `Hex`

The serialized transaction.
</file>

<file path="utilities/parseUnits.md">
---
description: Multiplies a string representation of a number by a given exponent of base 10.
---

# parseUnits

Multiplies a string representation of a number by a given exponent of base 10 (10<sup>exponent</sup>).

## Import

```ts
import { parseUnits } from 'viem'
```

## Usage

```ts
import { parseUnits } from 'viem'

parseUnits('420', 9) // [!code focus:2]
// 420000000000n
```

## Returns

`bigint`

## Parameters

### value

- **Type:** `string`

The string representation of the number to multiply.

### exponent 

- **Type:** `number`

The exponent.
</file>

<file path="utilities/recoverAddress.md">
---
description: Recovers the signing address from a hash & signature.
---

# recoverAddress

Recovers the original signing address from a hash & signature.

## Usage

```ts [example.ts]
import { recoverAddress } from 'viem'
 
const address = await recoverAddress({
  hash: '0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c'
})
// 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```

## Returns

[`Address`](/docs/glossary/types#address)

The signing address.

## Parameters

### hash

- **Type:** `string`

The hash that was signed.

```ts
const address = await recoverAddress({ 
  hash: '0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c'
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature of the hash.

```ts
const address = await recoverAddress({ 
  hash: '0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c' // [!code focus]
})
```
</file>

<file path="utilities/recoverMessageAddress.md">
---
description: Recovers the signing address from a message & signature.
---

# recoverMessageAddress

Recovers the original signing address from a message & signature.

Useful for obtaining the address of a message that was signed with [`signMessage`](/docs/actions/wallet/signMessage).

## Usage

:::code-group

```ts [example.ts]
import { recoverMessageAddress } from 'viem';
import { account, walletClient } from './config'
 
const signature = await walletClient.signMessage({
  account,
  message: 'hello world',
})

const address = await recoverMessageAddress({ // [!code focus:99]
  message: 'hello world',
  signature,
})
```

```ts [config.ts]
import { createWalletClient, custom } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount('0x...')
```

:::

## Returns

[`Address`](/docs/glossary/types#address)

The signing address.

## Parameters

### message

- **Type:** `string | { raw: Hex | ByteArray }`

The message that was signed.

By default, viem verifies the UTF-8 representation of the message.

```ts
const address = await recoverMessageAddress({ 
  message: 'hello world', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c'
})
```

To verify the data representation of the message, you can use the `raw` attribute.

```ts
const address = await recoverMessageAddress({ 
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus:1]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c'
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature of the message.

```ts
const address = await recoverMessageAddress({ 
  message: 'hello world',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c' // [!code focus]
})
```
</file>

<file path="utilities/recoverPublicKey.md">
---
description: Recovers the signing public key from a hash & signature.
---

# recoverPublicKey

Recovers the original signing 64-byte public key from a hash & signature.

## Usage

```ts [example.ts]
import { recoverPublicKey } from 'viem'
 
const publicKey = await recoverPublicKey({
  hash: '0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c'
})
// 0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The signing public key.

## Parameters

### hash

- **Type:** `string`

The hash that was signed.

```ts
const publicKey = await recoverPublicKey({ 
  hash: '0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68', // [!code focus]
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c'
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature of the hash.

```ts
const publicKey = await recoverPublicKey({ 
  hash: '0xd9eba16ed0ecae432b71fe008c98cc872bb4cc214d3220a36f365326cf807d68',
  signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c' // [!code focus]
})
```
</file>

<file path="utilities/recoverTransactionAddress.md">
---
description: Recovers the signing address from a transaction & signature.
---

# recoverTransactionAddress

Recovers the original signing address from a transaction & signature.

## Usage

:::code-group

```ts twoslash [example.ts]
import { recoverTransactionAddress } from 'viem'
import { walletClient } from './client'

const request = await walletClient.prepareTransactionRequest({
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})

const serializedTransaction = await walletClient.signTransaction(request)

const address = await recoverTransactionAddress({ // [!code focus:99]
  serializedTransaction,
})
```

```ts [client.ts (JSON-RPC Account)]
import { createWalletClient, custom } from 'viem'

// Retrieve Account from an EIP-1193 Provider.
const [account] = await window.ethereum.request({ 
  method: 'eth_requestAccounts' 
})

export const walletClient = createWalletClient({
  account,
  transport: custom(window.ethereum!)
})
```

```ts twoslash [config.ts (Local Account)] filename="client.ts"
import { createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  account: privateKeyToAccount('0x...'),
  transport: http()
})
```

:::

## Returns

[`Address`](/docs/glossary/types#address)

The signing address.

## Parameters

### serializedTransaction

- **Type:** `TransactionSerialized`

The RLP serialized transaction.

### signature (optional)

- **Type:** `Signature | Hex | ByteArray`
- **Default:** Signature inferred on `serializedTransaction` (if exists)

The signature.
</file>

<file path="utilities/recoverTypedDataAddress.md">
---
description: Recovers the signing address from EIP-712 typed data & signature.
---

# recoverTypedDataAddress

Recovers the original signing address from EIP-712 typed data & signature.

Useful for obtaining the address of a message that was signed with [`signTypedData`](/docs/actions/wallet/signTypedData).

## Usage

:::code-group

```ts [example.ts]
import { recoverTypedDataAddress } from 'viem'
import { account, walletClient } from './client'

const message = {
  from: {
    name: 'Cow',
    wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
  },
  to: {
    name: 'Bob',
    wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
  },
  contents: 'Hello, Bob!',
} as const
 
const signature = await walletClient.signTypedData({
  account,
  domain,
  types,
  primaryType: 'Mail',
  message,
})

const address = await recoverTypedDataAddress({ // [!code focus:99]
  domain,
  types,
  primaryType: 'Mail',
  message,
  signature,
})
```

```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const
 
// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```

```ts [client.ts]
import { createWalletClient, custom, getAccount } from 'viem'

export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'

export const walletClient = createWalletClient({
  transport: custom(window.ethereum)
})
```

:::

## Returns

[`Address`](/docs/glossary/types#address)

The signing address.

## Parameters

### domain

**Type:** `TypedDataDomain`

The typed data domain.

```ts
const address = await recoverTypedDataAddress({
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...'
})
```

### types

The type definitions for the typed data.

```ts
const address = await recoverTypedDataAddress({
  domain,
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...'
})
```

### primaryType

**Type:** Inferred `string`.

The primary type to extract from `types` and use in `value`.

```ts
const address = await recoverTypedDataAddress({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...'
})
```

### message

**Type:** Inferred from `types` & `primaryType`.

```ts
const address = await recoverTypedDataAddress({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', 
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...'
})
```

### signature

- **Type:** `Hex | ByteArray`

The signature of the typed data.

```ts
const address = await recoverTypedDataAddress({
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', 
  message: { 
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...' // [!code focus]
})
```
</file>

<file path="utilities/ripemd160.md">
---
description: Calculates the Ripemd160 hash of a byte array.
---

# ripemd160

Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a byte array or hex value.

This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes) – an audited & minimal JS hashing library.

## Install

```ts
import { ripemd160 } from 'viem'
```

## Usage

```ts
import { ripemd160 } from 'viem'

ripemd160(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
// 0x8476ee4631b9b30ac2754b0ee0c47e161d3f724c

ripemd160('0xdeadbeef')
// 0x226821c2f5423e11fe9af68bd285c249db2e4b5a
```

## Returns

`Hex | ByteArray`

The hashed value.

## Parameters

### value

- **Type:** `Hex | ByteArray`

The hex value or byte array to hash.

### to

- **Type:** `"bytes" | "hex"`
- **Default:** `"hex"`

The output type.

```ts
import { ripemd160 } from 'viem'

ripemd160(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33],
  'bytes' // [!code focus]
)
// Uint8Array [132, 118, 238, 70, 49, 185, 179, 10, 194, 117, 75, 14, 224, 196, 126, 22, 29, 63, 114, 76] // [!code focus]
```
</file>

<file path="utilities/serializeCompactSignature.md">
---
description: Serializes a compact signature into hex format.
---

# serializeCompactSignature

Serializes a [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098) compact signature into hex format.

## Import

```ts
import { serializeCompactSignature } from 'viem'
```

## Usage

```ts
import { serializeCompactSignature } from 'viem'

serializeCompactSignature({ // [!code focus:8]
  r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
  yParityAndS:
    '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
})
// "0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064"
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hex formatted signature.

## Parameters

### compactSignature

The compact signature.

- **Type:** [`CompactSignature`](/docs/glossary/types#CompactSignature)
</file>

<file path="utilities/serializeErc6492Signature.md">
---
description: Serializes a ERC-6492 flavoured signature into hex format.
---

# serializeErc6492Signature

Serializes a [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492) flavoured signature into hex format.

## Import

```ts
import { serializeErc6492Signature } from 'viem/utils'
```

## Usage

```ts twoslash
import { serializeErc6492Signature } from 'viem/utils'

serializeErc6492Signature({ // [!code focus:99]
  address: '0xcafebabecafebabecafebabecafebabecafebabe',
  data: '0xdeadbeef',
  signature: '0x41a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b',
})
// "0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492"
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hex formatted signature.

## Parameters

### address

- **Type:** `Address`

The ERC-4337 Account Factory or preparation address to use for counterfactual verification.

### data

- **Type:** `Hex`

Calldata to pass to deploy the ERC-4337 Account (if not deployed) for counterfactual verification.

### signature

- **Type:** `Hex`

The original signature.
</file>

<file path="utilities/serializeSignature.md">
---
description: Serializes a structured signature into hex format.
---

# serializeSignature

Serializes a structured signature into hex format.

## Import

```ts
import { serializeSignature } from 'viem'
```

## Usage

```ts
import { serializeSignature } from 'viem'

serializeSignature({
  r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',
  s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',
  yParity: 1
}) // [!code focus:8]
// "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hex formatted signature.

## Parameters

### signature

The signature.

- **Type:** [`Signature`](/docs/glossary/types#signature)
</file>

<file path="utilities/serializeTransaction.md">
---
description: Serializes a transaction object.
---

# serializeTransaction

Serializes a transaction object. Supports EIP-1559, EIP-2930, and Legacy transactions.

## Import

```ts
import { serializeTransaction } from 'viem'
```

## Usage

```ts
import { serializeTransaction } from 'viem'

const serialized = serializeTransaction({
  chainId: 1,
  gas: 21001n,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  to: "0x1234512345123451234512345123451234512345",
  value: parseEther('0.01'),
})
```

## Returns

Returns a template `Hex` value based on transaction type:

- `eip1559`: [TransactionSerializedEIP1559](/docs/glossary/types#TransactionSerializedEIP1559)
- `eip2930`: [TransactionSerializedEIP2930](/docs/glossary/types#TransactionSerializedEIP2930)
- `eip4844`: [TransactionSerializedEIP4844](/docs/glossary/types#TransactionSerializedEIP4844)
- `eip7702`: [TransactionSerializedEIP7702](/docs/glossary/types#TransactionSerializedEIP7702)
- `legacy`: [TransactionSerializedLegacy](/docs/glossary/types#TransactionSerializedLegacy) 

## Parameters

### transaction

- **Type:** `TransactionSerializable`

The transaction object to serialize.

```ts
const serialized = serializeTransaction({
  chainId: 1,
  gas: 21001n,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  to: '0x1234512345123451234512345123451234512345',
  value: parseEther('0.01'),
})
```

### signature

- **Type:** `Hex`

Optional signature to include.

```ts
const serialized = serializeTransaction({
  chainId: 1,
  gas: 21001n,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  to: '0x1234512345123451234512345123451234512345',
  value: parseEther('0.01'),
}, { // [!code focus:5]
  r: '0x123451234512345123451234512345123451234512345123451234512345',
  s: '0x123451234512345123451234512345123451234512345123451234512345',
  yParity: 1
})
```
</file>

<file path="utilities/setupKzg.md">
---
description: Sets up and returns a KZG interface.
---

# setupKzg

Sets up and defines a [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) compatible [KZG interface](https://notes.ethereum.org/@vbuterin/proto_danksharding_faq#How-%E2%80%9Ccomplicated%E2%80%9D-and-%E2%80%9Cnew%E2%80%9D-is-KZG). The KZG interface is used in the blob transaction signing process to generate KZG commitments & proofs.

`setupKzg` accepts a KZG interface that implements three functions:

- `loadTrustedSetup`: A function to initialize the KZG trusted setup.
- `blobToKzgCommitment`: A function that takes a blob and returns it's KZG commitment.
- `computeBlobKzgProof`: A function that takes a blob and it's commitment, and returns the KZG proof.

A couple of KZG implementations we recommend are:
- [c-kzg](https://github.com/ethereum/c-kzg-4844): Node.js bindings to c-kzg.
- [kzg-wasm](https://github.com/ethereumjs/kzg-wasm): WebAssembly bindings to c-kzg.

## Import

```ts twoslash
import { setupKzg } from 'viem'
```

## Usage

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

### Trusted Setups

As seen above, when you set up your KZG interface, you will need to provide a trusted setup file. You can either import a trusted setup via the [`viem/node` entrypoint](#viemnode-entrypoint) (if you're using an engine that supports Node.js' `node:fs` module), or you can directly import the trusted setup `.json` via the [`viem/trusted-setups` entrypoint](#viemtrusted-setups-entrypoint).

Viem exports the following trusted setups:

- `mainnet.json`: For Ethereum Mainnet & it's Testnets (Sepolia, Goerli, etc).
- `minimal.json`: For low-resource local dev testnets, and spec-testing.

The trusted setup files are retrieved from the Ethereum [consensus-specs repository](https://github.com/ethereum/consensus-specs/tree/dev/presets).

#### `viem/node` Entrypoint

Viem exports **paths to the trusted setup** via the `viem/node` entrypoint, designed to be used with `setupKzg`. 

```ts
import {
  mainnetTrustedSetupPath,
  minimalTrustedSetupPath,
} from 'viem/node'
```

#### `viem/trusted-setups` Entrypoint

Alternatively, you can directly import the **contents of the trusted setup** file from the `viem/trusted-setups` entrypoint.

```ts
import mainnetTrustedSetup from 'viem/trusted-setups/mainnet.json'
import minimalTrustedSetup from 'viem/trusted-setups/minimal.json'
```

## Returns

`Kzg`

The KZG interface.

## Parameters

### kzg

- **Type:** `Kzg & { loadTrustedSetup(path: string): void }`

The [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) compatible [KZG interface](https://notes.ethereum.org/@vbuterin/proto_danksharding_faq#How-%E2%80%9Ccomplicated%E2%80%9D-and-%E2%80%9Cnew%E2%80%9D-is-KZG).

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg' // [!code focus]
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(
  cKzg, // [!code focus]
  mainnetTrustedSetupPath
)
```

### path

- **Type:** `string`

The path to the trusted setup file. 

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node' // [!code focus]

const kzg = setupKzg(
  cKzg, 
  mainnetTrustedSetupPath // [!code focus]
)
```
</file>

<file path="utilities/sha256.md">
---
description: Calculates the Sha256 hash of a byte array.
---

# sha256

Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a byte array or hex value.

This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes) – an audited & minimal JS hashing library.

## Install

```ts
import { sha256 } from 'viem'
```

## Usage

```ts
import { sha256 } from 'viem'

sha256(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
// 0x7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069

sha256('0xdeadbeef')
// 0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953
```

## Returns

`Hex | ByteArray`

The hashed value.

## Parameters

### value

- **Type:** `Hex | ByteArray`

The hex value or byte array to hash.

### to

- **Type:** `"bytes" | "hex"`
- **Default:** `"hex"`

The output type.

```ts
import { sha256 } from 'viem'

sha256(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33],
  'bytes' // [!code focus]
)
// Uint8Array [95, 120, 195, 50, 116, 228, 63, 169, 222, 86, 89, 38, 92, 29, 145, 126, 37, 192, 55, 34, 220, 176, 184, 210, 125, 184, 213, 254, 170, 129, 57, 83] // [!code focus]
```
</file>

<file path="utilities/sidecarsToVersionedHashes.md">
---
description: Transforms a list of sidecars to their versioned hashes.
---

# sidecarsToVersionedHashes

Transforms a list of sidecars to their versioned hashes.

## Import

```ts twoslash
import { sidecarsToVersionedHashes } from 'viem'
```

## Usage

:::code-group

```ts twoslash [example.ts]
import { toBlobSidecars, sidecarsToVersionedHashes } from 'viem'
import { kzg } from './kzg'

const sidecars = toBlobSidecars({ data: '0x...', kzg })
const versionedHashes = sidecarsToVersionedHashes({ sidecars }) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

:::

## Returns

`Hex[] | ByteArray[]`

Versioned hashes from the input sidecars.

## Parameters

### sidecars

- **Type:** `BlobSidecars<Hex | ByteArray>`

Sidecars to transform to versioned hashes.

```ts twoslash 
import { toBlobSidecars, sidecarsToVersionedHashes } from 'viem'
import { kzg } from './kzg'

const sidecars = toBlobSidecars({ data: '0x...', kzg })

const versionedHashes = sidecarsToVersionedHashes({ 
  sidecars, // [!code focus]
})
```

### to

- **Type:** `"bytes" | "hex"`

Commitments corresponding to the input blobs.

```ts twoslash 
import { toBlobSidecars, sidecarsToVersionedHashes } from 'viem'
import { kzg } from './kzg'

const sidecars = toBlobSidecars({ data: '0x...', kzg })

const versionedHashes = sidecarsToVersionedHashes({ 
  sidecars,
  to: 'bytes', // [!code focus]
})
versionedHashes  // [!code focus]
// ^?


```

### version

- **Type:** `number`
- **Default:** `1`

Version to tag onto the hashes. Defaults to `1`.

```ts twoslash 
import { toBlobSidecars, sidecarsToVersionedHashes } from 'viem'
import { kzg } from './kzg'

const sidecars = toBlobSidecars({ data: '0x...', kzg })

const versionedHashes = sidecarsToVersionedHashes({ 
  sidecars,
  version: 69, // [!code focus]
})
```
</file>

<file path="utilities/signatureToCompactSignature.md">
---
description: Parses a signature into a compact signature.
---

# signatureToCompactSignature

Parses a signature into a [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098) compact signature.

## Import

```ts
import { signatureToCompactSignature } from 'viem'
```

## Usage

```ts
import { signatureToCompactSignature, Signature } from 'viem'

signatureToCompactSignature({  // [!code focus:9]
  r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
  s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064' 
  yParity: 0
})
// {
//   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
//   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
// }
```

## Returns

[`CompactSignature`](/docs/glossary/types#compactsignature)

The compact signature.

## Parameters

### signature

The signature.

- **Type:** [`Signature`](/docs/glossary/types#signature)
</file>

<file path="utilities/size.md">
---
description: Retrieves the size of the value (in bytes).
---

# size

Retrieves the size of the value (in bytes).

## Install

```ts
import { size } from 'viem'
```

## Usage

```ts
import { size } from 'viem'

size('0xa4') // 1
size('0xa4e12a45') // 4
size(new Uint8Array([1, 122, 51, 123])) // 4
```

## Returns

`number`

The size of the value (in bytes).

## Parameters

### value

- **Type:** [`Hex`](/docs/glossary/types#hex) | `ByteArray`

The value (hex or byte array) to retrieve the size of.
</file>

<file path="utilities/slice.md">
---
description: Returns a section of the hex or byte array given a start/end bytes offset.
---

# slice

Returns a section of the hex or byte array given a start/end bytes offset.

## Install

```ts
import { slice } from 'viem'
```

## Usage

```ts
import { slice } from 'viem'

slice('0x0123456789', 1, 4)
// 0x234567

slice(new Uint8Array([1, 122, 51, 123]), 1, 3)
// Uint8Array [122, 51]
```

## Returns

`Hex | ByteArray`

The section of the sliced value.

## Parameters

### value

- **Type:** `Hex | ByteArray`

The hex or byte array to slice.

```ts
slice(
  '0x0123456789', // [!code focus]
  1,
  4
)
```

### start (optional)

- **Type:** `number`

The start offset (in bytes).

```ts
slice(
  '0x0123456789', 
  1 // [!code focus]
)
```

### end (optional)

- **Type:** `number`

The end offset (in bytes).

```ts
slice(
  '0x0123456789', 
  1,
  4 // [!code focus]
)
```

#### options.strict (optional)

- **Type:** `boolean`
- **Default:** `false`


Whether or not the end offset should be inclusive of the bounds of the data.

```ts
slice('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678', 0, 20, { strict: true })
// [SliceOffsetOutOfBoundsError] Slice ending at offset "20" is out-of-bounds (size: 19).

slice('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 0, 20, { strict: true })
// 0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC
```
</file>

<file path="utilities/toBase58.md">
# toBase58

Coming soon.
</file>

<file path="utilities/toBase64.md">
# toBase64

Coming soon.
</file>

<file path="utilities/toBlobs.md">
---
description: Transforms arbitrary data into blobs.
---

# toBlobs

Transforms arbitrary data into Viem-shaped blobs. 

:::warning
This function transforms data into Viem-shaped blobs. It is designed to be used with Viem's `fromBlobs` function to convert back to the data.
:::

## Import

```ts twoslash
import { toBlobs } from 'viem'
```

## Usage

```ts twoslash [example.ts]
import { toBlobs } from 'viem'

const blobs = toBlobs({ data: '0x...' })
```

## Returns

`Hex[] | ByteArray[]`

Blobs from the input data.

## Parameters

### data

- **Type:** `Hex | ByteArray`

Data to transform into blobs.

```ts twoslash
import { toBlobs } from 'viem'

const blobs = toBlobs({ 
  data: '0x...' // [!code focus]
})
```

### to

- **Type:** `"bytes" | "hex"`

The output type.

```ts twoslash
import { toBlobs } from 'viem'

const blobs = toBlobs({ 
  data: '0x...',
  to: 'bytes' // [!code focus]
})

blobs // [!code focus]
// ^?


```
</file>

<file path="utilities/toBlobSidecars.md">
---
description: Transforms arbitrary data into blob sidecars.
---

# toBlobSidecars

Transforms arbitrary data (or blobs, commitments, & proofs) into a blob sidecar array.

## Import

```ts twoslash
import { toBlobSidecars } from 'viem'
```

## Usage

### With Arbitrary Data

You can generate blob sidecars from arbitrary data without having to compute the blobs, commitments, and proofs first (that's done internally).

:::code-group

```ts twoslash [example.ts]
import { toBlobSidecars } from 'viem'
import { kzg } from './kzg'

const sidecars = toBlobSidecars({ data: '0x...', kzg }) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

:::

### With Blobs, Commitments, and Proofs

Alternatively, you can reach for the lower-level API and insert the blobs, commitments, and proofs directly.

:::code-group

```ts twoslash [example.ts]
import { 
  blobsToCommitments, 
  blobsToProofs,
  toBlobSidecars, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' })
const commitments = blobsToCommitments({ blobs, kzg })
const proofs = blobsToProofs({ blobs, commitments, kzg })
const sidecars = toBlobSidecars({ blobs, commitments, proofs }) // [!code focus]
```

```ts twoslash [kzg.ts] filename="kzg.ts"
// @noErrors
import * as cKzg from 'c-kzg'
import { setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

export const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
```

:::

## Returns

`BlobSidecars`

Blob sidecars from the input data.

## Parameters

### blobs

- **Type:** `Hex[] | ByteArray[]`

Blobs to transform into blob sidecars.

```ts twoslash
import { 
  blobsToCommitments, 
  blobsToProofs,
  toBlobSidecars, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' }) // [!code focus]
const commitments = blobsToCommitments({ blobs, kzg })
const proofs = blobsToProofs({ blobs, commitments, kzg })

const sidecars = toBlobSidecars({ 
  blobs, // [!code focus]
  commitments,
  proofs,
})
```

### commitments

- **Type:** `Hex[] | ByteArray[]`

Commitments corresponding to the input blobs.

```ts twoslash
import { 
  blobsToCommitments, 
  blobsToProofs,
  toBlobSidecars, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' })
const commitments = blobsToCommitments({ blobs, kzg }) // [!code focus]
const proofs = blobsToProofs({ blobs, commitments, kzg })

const sidecars = toBlobSidecars({ 
  blobs,
  commitments, // [!code focus]
  proofs,
})
```

### data

- **Type:** `Hex | ByteArray`

Data to transform into blob sidecars.

```ts twoslash
import { toBlobSidecars } from 'viem'
import { kzg } from './kzg'

const sidecars = toBlobSidecars({ 
  data: '0x...', // [!code focus]
  kzg,
})
```

### kzg

- **Type:** `KZG`

KZG implementation. See [`setupKzg`](/docs/utilities/setupKzg) for more information.

```ts twoslash
// @noErrors
import * as cKzg from 'c-kzg'
import { toBlobSidecars, setupKzg } from 'viem'
import { mainnetTrustedSetupPath } from 'viem/node'

const kzg = setupKzg(cKzg, mainnetTrustedSetupPath) // [!code focus]

const sidecars = toBlobSidecars({ 
  data: '0x...',
  kzg, // [!code focus]
}) 
```

### proofs

- **Type:** `Hex[] | ByteArray[]`

Proofs corresponding to the input blobs.

```ts twoslash
import { 
  blobsToCommitments, 
  blobsToProofs,
  toBlobSidecars, 
  toBlobs 
} from 'viem'
import { kzg } from './kzg'

const blobs = toBlobs({ data: '0x...' })
const commitments = blobsToCommitments({ blobs, kzg })
const proofs = blobsToProofs({ blobs, commitments, kzg }) // [!code focus]

const sidecars = toBlobSidecars({ 
  blobs,
  commitments,
  proofs, // [!code focus]
})
```

### to

- **Type:** `"bytes" | "hex"`

The output type.

```ts twoslash
import { defineKzg } from 'viem'
const kzg = defineKzg({} as any)

// ---cut---
import { toBlobSidecars, toBlobs } from 'viem'

const sidecars = toBlobSidecars({ 
  data: '0x1234',
  kzg, 
  to: 'bytes', // [!code focus]  
}) 

sidecars // [!code focus]
// ^?


```
</file>

<file path="utilities/toBytes.md">
---
description: Encodes a string, hex value, number or boolean to a byte array.
---

# toBytes

Encodes a string, hex value, number or boolean to a byte array.

Shortcut Functions:

- [hexToBytes](#hextobytes)
- [stringToBytes](#stringtobytes)
- [numberToBytes](#numbertobytes)
- [boolToBytes](#booltobytes)

## Import

```ts
import { toBytes } from 'viem'
```

## Usage

```ts
import { toBytes } from 'viem'

toBytes('Hello world')
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])

toBytes('0x48656c6c6f20576f726c6421')
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])

toBytes(420)
// Uint8Array([1, 164])

toBytes(true)
// Uint8Array([1])
```

## Returns

`ByteArray`

The byte array represented as a `Uint8Array`.

## Parameters

### value

- **Type:** `string | Hex`

The value to encode as bytes.

```ts 
toBytes(
  'Hello world' // [!code focus]
)
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
```

### options

```ts 
toBytes(
  'Hello world', 
  { size: 32 } // [!code focus]
)
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```

## Shortcut Functions

### hexToBytes

- **Type:** `Hex`

Encodes a hex value to a byte array.

```ts
import { hexToBytes } from 'viem'

hexToBytes('0x48656c6c6f20576f726c6421') // [!code focus:2]
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])

hexToBytes('0x48656c6c6f20576f726c6421', { size: 32 }) // [!code focus:2]
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```

### stringToBytes

- **Type:** `Hex`

Encodes a string to a byte array.

```ts
import { stringToBytes } from 'viem'

stringToBytes('Hello world') // [!code focus:2]
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])

stringToBytes('Hello world', { size: 32 }) // [!code focus:2]
// Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```

### numberToBytes

- **Type:** `number | bigint`

Encodes a number to a byte array.

```ts
import { numberToBytes } from 'viem'

numberToBytes(420) // [!code focus:2]
// Uint8Array([1, 164])

numberToBytes(420, { size: 32 }) // [!code focus:2]
// Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 164])
```

### boolToBytes

- **Type:** `boolean`

Encodes a boolean to a byte array.

```ts
import { boolToBytes } from 'viem'

boolToBytes(true) // [!code focus:2]
// Uint8Array([1])

boolToBytes(true, { size: 32 }) // [!code focus:2]
// Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
```
</file>

<file path="utilities/toEventHash.md">
---
description: Returns the hash (of the event signature) for a given event definition.
---

# toEventHash

Returns the hash (of the event signature) for a given event definition.

## Install

```ts
import { toEventHash } from 'viem'
```

## Usage

```ts twoslash
import { toEventHash } from 'viem'

const hash_1 = toEventHash('event Transfer(address,address,uint256)')
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

const hash_2 = toEventHash({
  name: 'Transfer',
  type: 'event',
  inputs: [
    { name: 'from', type: 'address', indexed: true },
    { name: 'to', type: 'address', indexed: true },
    { name: 'amount', type: 'uint256', indexed: false },
  ],
})
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hash of the event signature.

## Parameters

### event

- **Type:** `string` | [`AbiEvent`](https://abitype.dev/api/types#abievent)

The event to generate a hash for.
</file>

<file path="utilities/toEventSelector.md">
---
description: Returns the event selector for a given event definition.
---

# toEventSelector

Returns the event selector for a given event definition.

## Install

```ts
import { toEventSelector } from 'viem'
```

## Usage

```ts twoslash
import { toEventSelector } from 'viem'

const selector_1 = toEventSelector('Transfer(address,address,uint256)')
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

const selector_2 = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

// or from an `AbiEvent` on your contract ABI
const selector_3 = toEventSelector({
  name: 'Transfer',
  type: 'event',
  inputs: [
    { name: 'from', type: 'address', indexed: true },
    { name: 'to', type: 'address', indexed: true },
    { name: 'amount', type: 'uint256', indexed: false },
  ],
})
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The selector as a hex value.

## Parameters

### event

- **Type:** `string |`[`AbiEvent`](https://abitype.dev/api/types#abievent)

The event to generate a selector for.
</file>

<file path="utilities/toEventSignature.md">
---
description: Returns the signature for a given event or event definition.
---

# toEventSignature

Returns the signature for a given event definition.

:::tip
This only returns the **event signature**. If you need the **full human-readable definition**, check out ABIType's [`formatAbiItem`](https://abitype.dev/api/human#formatabiitem-1).
:::

## Install

```ts
import { toEventSignature } from 'viem'
```

## Usage

```ts twoslash
import { toEventSignature } from 'viem'

// from event definition
const signature_1 = toEventSignature('event Transfer(address indexed from, address indexed to, uint256 amount)')
// @log: Output: Transfer(address,address,uint256)

// from an `AbiEvent` on your contract ABI
const signature_2 = toEventSignature({
  name: 'Transfer',
  type: 'event',
  inputs: [
    { name: 'address', type: 'address', indexed: true },
    { name: 'address', type: 'address', indexed: true },
    { name: 'uint256', type: 'uint256', indexed: false },
  ],
})
// @log: Output: Transfer(address,address,uint256)
```

## Returns

`string`

The signature as a string value.

## Parameters

### definition

- **Type:** `string | AbiEvent`

The event definition to generate a signature for.
</file>

<file path="utilities/toFunctionHash.md">
---
description: Returns the hash (of the function signature) for a given function definition.
---

# toFunctionHash

Returns the hash (of the function signature) for a given function definition.

## Install

```ts
import { toFunctionHash } from 'viem'
```

## Usage

```ts twoslash
import { toFunctionHash } from 'viem'

const hash_1 = toFunctionHash('function ownerOf(uint256)')
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

// or from an `AbiEvent` on your contract ABI
const hash_2 = toFunctionHash({
  name: 'ownerOf',
  type: 'function',
  inputs: [{ name: 'tokenId', type: 'uint256' }],
  outputs: [],
  stateMutability: 'view',
})
// @log: Output: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hash of the function signature.

## Parameters

### function

- **Type:** `string` | [`AbiFunction`](https://abitype.dev/api/types#abifunction)

The function to generate a hash for.
</file>

<file path="utilities/toFunctionSelector.md">
---
description: Returns the function selector (4 byte encoding) for a given function definition.
---

# toFunctionSelector

Returns the function selector (4 byte encoding) for a given function definition.

## Install

```ts
import { toFunctionSelector } from 'viem'
```

## Usage

```ts twoslash
import { toFunctionSelector } from 'viem'

const selector_1 = toFunctionSelector('function ownerOf(uint256 tokenId)')
// @log: Output: 0x6352211e

const selector_2 = toFunctionSelector('ownerOf(uint256)')
// @log: Output: 0x6352211e

// or from an `AbiFunction` on your contract ABI
const selector_3 = toFunctionSelector({
  name: 'ownerOf',
  type: 'function',
  inputs: [{ name: 'tokenId', type: 'uint256' }],
  outputs: [],
  stateMutability: 'view',
})
// @log: Output: 0x6352211e
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The selector as a hex value.

## Parameters

### function

- **Type:** `string |`[`AbiFunction`](https://abitype.dev/api/types#abifunction)

The function to generate a selector for.
</file>

<file path="utilities/toFunctionSignature.md">
---
description: Returns the signature for a given function definition.
---

# toFunctionSignature

Returns the signature for a given function definition.

:::tip
This only returns the **function signature**. If you need the **full human-readable definition**, check out ABIType's [`formatAbiItem`](https://abitype.dev/api/human#formatabiitem-1).
:::

## Install

```ts
import { toFunctionSignature } from 'viem'
```

## Usage

```ts twoslash
import { toFunctionSignature } from 'viem'

// from function definition
const signature_1 = toFunctionSignature('function ownerOf(uint256 tokenId)')
// @log: Output: ownerOf(uint256)

// from an `AbiFunction` on your contract ABI
const signature_2 = toFunctionSignature({
  name: 'ownerOf',
  type: 'function',
  inputs: [{ name: 'tokenId', type: 'uint256' }],
  outputs: [],
  stateMutability: 'view',
})
// @log: Output: ownerOf(uint256)
```

## Returns

`string`

The signature as a string value.

## Parameters

### definition

- **Type:** `string | AbiFunction`

The function definition to generate a signature for.
</file>

<file path="utilities/toHex.md">
---
description: Encodes a string, number, boolean or byte array to a hex value value.
---

# toHex

Encodes a string, number, boolean or byte array to a hex value value.

Shortcut Functions: 

- [numberToHex](#numbertohex)
- [stringToHex](#stringtohex)
- [bytesToHex](#bytestohex)
- [boolToHex](#booltohex)

## Import

```ts
import { toHex } from 'viem'
```

## Usage

```ts
import { toHex } from 'viem'

toHex(420)
// "0x1a4"

toHex('Hello world')
// "0x48656c6c6f20776f726c642e"

toHex(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
)
// "0x48656c6c6f20576f726c6421"

toHex(true)
// "0x1"
```

## Returns

[`Hex`](/docs/glossary/types#hex)

The hex value.

## Parameters

### value

- **Type:** `string | number | bigint | ByteArray`

The value to hex encode.

```ts 
toHex(
  'Hello world' // [!code focus]
)
// '0x48656c6c6f20776f726c642e'
```

### options

```ts 
toHex(
  'Hello world', 
  { size: 32 } // [!code focus]
)
// '0x48656c6c6f20776f726c642e0000000000000000000000000000000000000000'
```

## Shortcut Functions

### numberToHex

- **Type:** `number | bigint`

Encodes a number value to a hex value.

```ts
import { numberToHex } from 'viem'

numberToHex(420)
// "0x1a4"

numberToHex(4206942069420694206942069420694206942069n)
// "0xc5cf39211876fb5e5884327fa56fc0b75"

numberToHex(420, { size: 32 })
// "0x00000000000000000000000000000000000000000000000000000000000001a4"

numberToHex(4206942069420694206942069420694206942069n, { size: 32 })
// "0x0000000000000000000000000000000c5cf39211876fb5e5884327fa56fc0b75"
```

### stringToHex

- **Type:** `string`

Encodes a UTF-8 string value to a hex value.

```ts
import { stringToHex } from 'viem'

stringToHex('Hello World!')
// "0x48656c6c6f20576f726c6421"

stringToHex('Hello World!', { size: 32 })
// "0x48656c6c6f20576f726c64210000000000000000000000000000000000000000"
```

### bytesToHex

- **Type:** `ByteArray`

Encodes a byte array to a hex value.

```ts
import { bytesToHex } from 'viem'

bytesToHex(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),
)
// "0x48656c6c6f20576f726c6421"

bytesToHex(
  new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),
  { size: 32 }
)
// "0x48656c6c6f20576f726c64210000000000000000000000000000000000000000"
```

### boolToHex

- **Type:** `boolean`

Encodes a boolean to a hex value.

```ts
import { boolToHex } from 'viem'

boolToHex(true)
// "0x1"

boolToHex(true, { size: 32 })
// "0x0000000000000000000000000000000000000000000000000000000000000001"
```
</file>

<file path="utilities/toRlp.md">
---
description: Encodes a hex value or byte array into a RLP encoded value.
---

# toRlp

Encodes a hex value or byte array into a [Recursive-Length Prefix (RLP)](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) encoded value.

## Import

```ts
import { toRlp } from 'viem'
```

## Usage

```ts
import { toRlp } from 'viem'

toRlp('0x123456789')
// "0x850123456789"

toRlp(['0x7f', '0x7f', '0x8081e8'])
// "0xc67f7f838081e8"

toRlp(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9]))
// "0x89010203040506070809"

toRlp('0x123456789', 'bytes')
// Uint8Array [133, 1, 35, 69, 103, 137]
```

## Returns

`Hex | ByteArray`

The hex value or byte array.

## Parameters

### value

- **Type:** `Hex | ByteArray`

The value to RLP encode.

### to

- **Type:** `"bytes" | "hex"`
- **Default:** `"hex"`

The output type.

```ts
toRlp('0x123456789', 'bytes')
// Uint8Array [133, 1, 35, 69, 103, 137]
```
</file>

<file path="utilities/trim.md">
---
description: Trims the leading or trailing zero byte data from a hex value or byte array.
---

# trim

Trims the leading or trailing zero byte data from a hex value or byte array.

## Install

```ts
import { trim } from 'viem'
```

## Usage

By default, `trim` will trim the leading zero byte data from a hex value or byte array.

```ts
import { trim } from 'viem'

trim('0x00000000000000000000000000000000000000000000000000000001a4e12a45')
// 0x01a4e12a45

trim(new Uint8Array([0, 0, 0, 0, 0, 0, 1, 122, 51, 123]))
// Uint8Array [1,122,51,123]
```

## Returns

`Hex | ByteArray`

The trimmed value.

## Parameters

### dir

- **Type:** `"left" | "right"`
- **Default:** `"left"`

The direction in which to trim the zero byte data – either leading (left), or trailing (right).

```ts
trim('0xa4e12a4510000000000000000000000000000000000000000000000000000000', {
  dir: 'right'
})
// 0xa4e12a4510
```
</file>

<file path="utilities/verifyMessage.md">
---
description: Verifies if a signed message was generated by the provided address.
---

# verifyMessage

Verify that a message was signed by the provided address.

:::warning[Warning]
This utility can only verify a message that was signed by an Externally Owned Account (EOA).
To verify messages from Contract Accounts (& EOA), use the [`publicClient.verifyMessage` Action](/docs/actions/public/verifyMessage) instead.
:::

## Usage

:::code-group

```ts [example.ts]
import { verifyMessage } from 'viem'
import { account, walletClient } from './client'

const signature = await walletClient.signMessage({
  account,
  message: 'hello world',
})

const valid = await verifyMessage({ // [!code focus:99]
  address: account.address,
  message: 'hello world',
  signature,
})
// true
```

```ts [config.ts]
import { createWalletClient, custom } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

export const walletClient = createWalletClient({
  transport: custom(window.ethereum)
})

// JSON-RPC Account
export const [account] = await walletClient.getAddresses()
// Local Account
export const account = privateKeyToAccount(...)
```

:::

## Returns

`boolean`

Whether the provided `address` generated the `signature`.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The Ethereum address that signed the original message.

```ts
const valid = await verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
  message: 'hello world',
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### message

- **Type:** `string`

The message to be verified.

By default, viem signs the UTF-8 representation of the message.

```ts
const valid = await verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world', // [!code focus:1]
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

To sign the data representation of the message, you can use the `raw` attribute.

```ts
const valid = await verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: { raw: '0x68656c6c6f20776f726c64' }, // [!code focus:1]
  signature:
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature that was generated by signing the message with the address's private key.

```ts
const valid = await verifyMessage({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  message: 'hello world',
  signature: // [!code focus:2]
    '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
})
```
</file>

<file path="utilities/verifyTypedData.md">
---
description: Verifies a typed data signature
---

# verifyTypedData

Verify that typed data was signed by the provided address.

:::warning[Warning]
This utility can only verify typed data that was signed by an Externally Owned Account (EOA).
To verify messages from Contract Accounts (& EOA), use the [`publicClient.verifyTypedData` Action](/docs/actions/public/verifyTypedData) instead.
:::

## Usage

:::code-group

```ts [example.ts]
import { verifyTypedData } from 'viem'
import { account, walletClient } from './client'

const message = {
  from: {
    name: 'Cow',
    wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
  },
  to: {
    name: 'Bob',
    wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
  },
  contents: 'Hello, Bob!',
} as const

const signature = await walletClient.signTypedData({
  account,
  domain,
  types,
  primaryType: 'Mail',
  message,
})
// [!code focus:99]
const valid = await verifyTypedData({
  address: account.address,
  domain,
  types,
  primaryType: 'Mail',
  message,
  signature,
})
// true
```

```ts [data.ts]
// All properties on a domain are optional
export const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
} as const

// The named list of all type definitions
export const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
} as const
```

```ts [client.ts]
import { createWalletClient, custom } from 'viem'

export const account = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'

export const walletClient = createWalletClient({
  transport: custom(window.ethereum),
})
```

:::

## Returns

`boolean`

Whether the provided `address` generated the `signature`.

## Parameters

### address

- **Type:** [`Address`](/docs/glossary/types#address)

The Ethereum address that signed the original message.

```ts
const valid = await verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus:1]
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### domain

**Type:** `TypedDataDomain`

The typed data domain.

```ts
const valid = await verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: { // [!code focus:6]
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### types

The type definitions for the typed data.

```ts
const valid = await verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain,
  types: { // [!code focus:11]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### primaryType

**Type:** Inferred `string`.

The primary type to extract from `types` and use in `value`.

```ts
const valid = await verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [ // [!code focus:5]
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail', // [!code focus]
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### message

**Type:** Inferred from `types` & `primaryType`.

```ts
const valid = await verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: { // [!code focus:11]
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### signature

- **Type:** `Hex | ByteArray | Signature`

The signature of the typed data.

```ts
const valid = await verifyTypedData({
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain,
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...', // [!code focus]
})
```

### blockNumber (optional)

- **Type:** `bigint`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

```ts
const valid = await verifyTypedData({
  blockNumber: 42069n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

### blockTag (optional)

- **Type:** `'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`
- **Default:** `'latest'`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

```ts
const valid = await verifyTypedData({
  blockNumber: 42069n, // [!code focus]
  address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types,
  primaryType: 'Mail',
  message: {
    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
  signature: '0x...',
})
```

## JSON-RPC Method

[`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) to a deployless [universal signature validator contract](https://eips.ethereum.org/EIPS/eip-6492).
</file>

<file path="compatibility.mdx">
# Platform Compatibility [Platforms compatible with Viem]

**Viem supports all modern browsers (Chrome, Edge, Firefox, etc) & runtime environments (Node 18+, Deno, Bun, etc).**

Viem uses modern EcmaScript features such as:

- [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
- [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
- Error [`cause`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause)
- TextEncoder [`encode`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode)

You can check support for these features on [Can I use...](https://caniuse.com/)

## Polyfills

If your platform does not support one of the required features, it is also possible to import a polyfill.

### `fetch`

- [isomorphic-unfetch](https://github.com/developit/unfetch/tree/main/packages/isomorphic-unfetch)
- [node-fetch](https://github.com/node-fetch/node-fetch#providing-global-access)

### Error `cause`

- [core-js](https://github.com/zloirock/core-js)

### `TextEncoder`
- [FastestSmallestTextEncoderDecoder](https://github.com/anonyco/FastestSmallestTextEncoderDecoder)
</file>

<file path="eip7702.mdx">
---
description: An Overview of EIP-7702
---

# EIP-7702 Overview

EIP-7702 is a proposal to add a new Transaction type to allow an EOA to designate a Smart Contract as its "implementation".

The main difference between an EIP-7702 Transaction and other transactions is the inclusion of a **"authorization list"** property, a set of `(chain_id, contract_address, nonce, y_parity, r, s)` tuples that depict what Contracts should be delegated onto the Externally Owned Account. 

:::note
In Viem, you won't need to worry about constructing these Authorization Tuples manually as you can use [`signAuthorization`](/docs/eip7702/signAuthorization) to generate them and use them in [Transaction APIs](/docs/eip7702/contract-writes).
:::

Applications of EIP-7702 include:

- **Batching**: allowing multiple operations from the same user in one atomic transaction. One common example is an ERC-20 approval followed by spending that approval, a common workflow in DEXes that requires two transactions today. Advanced use cases of batching occasionally involve dependencies: the output of the first operation is part of the input to the second operation.
- **Sponsorship**: account X pays for a transaction on behalf of account Y. Account X could be paid in some other ERC-20 for this service, or it could be an application operator including the transactions of its users for free.
- **Privilege de-escalation**: users can sign sub-keys, and give them specific permissions that are much weaker than global access to the account. For example, you could imagine a permission to spend ERC-20 tokens but not ETH, or to spend up to 1% of total balance per day, or to interact only with a specific application.

## Next Steps

- [Contract Writes](/docs/eip7702/contract-writes)
- [Sending Transactions](/docs/eip7702/sending-transactions)
</file>

<file path="error-handling.mdx">
# Error Handling 

Every module in viem exports an accompanying error type which you can use to strongly type your `catch` statements.

These types come in the form of `<Module>ErrorType`. For example, the `getBlockNumber` action exports a `GetBlockNumberErrorType` type.

Unfortunately, [TypeScript doesn't have an abstraction for typed exceptions](https://github.com/microsoft/TypeScript/issues/13219), so the most pragmatic & vanilla approach would be to explicitly cast error types in the `catch` statement.

:::code-group

```ts [example.ts] twoslash
// @noErrors
// @filename: client.ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
// @filename: index.ts
// ---cut---
import { type GetBlockNumberErrorType } from 'viem'
import { client } from './client'

try {
  const blockNumber = await client.getBlockNumber()
} catch (e) {
  const error = e as GetBlockNumberErrorType
  error.name 
//      ^?






  if (error.name === 'InternalRpcError')
    error.code
    //    ^?


  if (error.name === 'HttpRequestError') {
    error.headers
    //    ^?


    error.status
    //    ^?
  }
}
```

```ts [client.ts]
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

:::
</file>

<file path="ethers-migration.mdx">
# Ethers v5 → viem Migration Guide [Migrate from Ethers v5 to viem]

This is a long document. Feel free to use the search bar above (⌘ K) or the Table of Contents to the side. If there is an API you need which is missing or cannot find, create a [Parity Request here](https://github.com/wagmi-dev/viem/discussions/new?category=feature-request&title=Parity%20Request:).

You may notice some of the APIs in viem are a little more verbose than Ethers. We prefer boring code and we want to strongly embrace [clarity & composability](/docs/introduction#developer-experience). We believe that [verbose APIs are more flexible](https://www.youtube.com/watch?v=4anAwXYqLG8&t=789s) to move, change and remove compared to code that is prematurely abstracted and hard to change.

## Provider → Client

### getDefaultProvider 

#### Ethers

```ts 
import { getDefaultProvider } from 'ethers'

const provider = getDefaultProvider() // [!code hl]
```

#### viem

```ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http() // [!code hl]
}) // [!code hl]
```

> We are more verbose here – we want to be explicit and clear what chain you are connecting to & what transport you are using to avoid any confusion. :)

### JsonRpcProvider

#### Ethers

This is also interchangeable with `StaticJsonRpcProvider`.

```ts 
import { providers } from 'ethers'

const provider = new providers.JsonRpcProvider('https://cloudflare-eth.com') // [!code hl]
```

Custom Chain:

```ts 
import { providers } from 'ethers'

const provider = new providers.JsonRpcProvider('https://250.rpc.thirdweb.com', { // [!code hl]
  name: 'Fantom', // [!code hl]
  id: 250 // [!code hl]
}) // [!code hl]
```


#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http('https://cloudflare-eth.com') // [!code hl]
}) // [!code hl]
```

Custom Chain:

```ts 
import { createPublicClient, http } from 'viem'
import { fantom } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: fantom, // [!code hl]
  transport: http('https://250.rpc.thirdweb.com') // [!code hl]
}) // [!code hl]
```

> viem exports custom EVM chains in the `viem/chains` entrypoint.

### InfuraProvider

#### Ethers

```ts
import { providers } from 'ethers'

const provider = new providers.InfuraProvider('homestead', '<apiKey>') // [!code hl]
```

#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http('https://mainnet.infura.io/v3/<apiKey>') // [!code hl]
}) // [!code hl]
```

> viem does not have custom API Provider clients – you can just pass in their RPC URL.

### AlchemyProvider

#### Ethers

```ts 
import { providers } from 'ethers'

const provider = new providers.AlchemyProvider('homestead', '<apiKey>') // [!code hl]
```

#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http('https://eth-mainnet.g.alchemy.com/v2/<apiKey>') // [!code hl]
}) // [!code hl]
```

> viem does not have custom API Provider clients – you can just pass in their RPC URL.

### CloudflareProvider

#### Ethers

```ts
import { providers } from 'ethers'

const provider = new providers.CloudflareProvider() // [!code hl]
```

#### viem

```ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http('https://cloudflare-eth.com/') // [!code hl]
}) // [!code hl]
```

> viem does not have custom API Provider clients – you can just pass in their RPC URL.

### PocketProvider

#### Ethers

```ts 
import { providers } from 'ethers'

const provider = new providers.PocketProvider('homestead', '<apiKey>') // [!code hl]
```

#### viem

```ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http('https://eth-mainnet.gateway.pokt.network/v1/lb/<apiKey>') // [!code hl]
}) // [!code hl]
```

> viem does not have custom API Provider clients – you can just pass in their RPC URL.

### AnkrProvider

#### Ethers

```ts 
import { providers } from 'ethers'

const provider = new providers.AnkrProvider('homestead', '<apiKey>') // [!code hl]
```

#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: http('https://rpc.ankr.com/eth/<apiKey>') // [!code hl]
}) // [!code hl]
```

> viem does not have custom API Provider clients – you can just pass in their RPC URL.

### FallbackProvider

#### Ethers

```ts
import { providers } from 'ethers'

const alchemy = new providers.AlchemyProvider('homestead', '<apiKey>') // [!code hl]
const infura = new providers.InfuraProvider('homestead', '<apiKey>') // [!code hl]
const provider = new providers.FallbackProvider([alchemy, infura]) // [!code hl]
```

#### viem

```ts 
import { createPublicClient, http, fallback } from 'viem'
import { mainnet } from 'viem/chains'

const alchemy = http('https://eth-mainnet.g.alchemy.com/v2/<apiKey>') // [!code hl]
const infura = http('https://mainnet.infura.io/v3/<apiKey>') // [!code hl]

const client = createPublicClient({
  chain: mainnet,
  transport: fallback([alchemy, infura]) // [!code hl]
})
```

### IpcProvider

Coming soon.

### JsonRpcBatchProvider

Coming soon.

### Web3Provider

#### Ethers

```ts 
import { providers } from 'ethers'

const provider = new providers.Web3Provider(window.ethereum) // [!code hl]
```

#### viem

```ts 
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({ // [!code hl]
  chain: mainnet, // [!code hl] 
  transport: custom(window.ethereum) // [!code hl]
}) // [!code hl]
```

### WebSocketProvider

#### Ethers

```ts 
import { providers } from 'ethers'

const provider = new providers.WebSocketProvider('wss://eth-mainnet.g.alchemy.com/v2/<apiKey>') // [!code hl]
```

#### viem

```ts
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code hl]
  chain: mainnet, // [!code hl]
  transport: webSocket('wss://eth-mainnet.g.alchemy.com/v2/<apiKey>') // [!code hl]
}) // [!code hl]
```

## Signers → Accounts

### JsonRpcSigner

#### Ethers

```ts
import { providers } from 'ethers'

const provider = new providers.Web3Provider(window.ethereum)

const [address] = await provider.listAccounts() // [!code hl]
const signer = provider.getSigner(address) // [!code hl]

signer.sendTransaction({ ... })
```

#### viem

```ts
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' }) // [!code hl]

const client = createWalletClient({
  account, // [!code hl]
  chain: mainnet,
  transport: custom(window.ethereum)
})

client.sendTransaction({ ... })
```

> viem uses the term ["Account"](https://ethereum.org/en/developers/docs/accounts/) rather than "Signer".

### Wallet

#### Ethers

```ts 
import { providers, Wallet } from 'ethers'

const provider = new providers.Web3Provider(window.ethereum)

const wallet = new Wallet('0x...', provider) // [!code hl]

wallet.sendTransaction({ ... })
```

#### viem

```ts
import { createWalletClient, custom } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...') // [!code hl]

const client = createWalletClient({
  account, // [!code hl]
  chain: mainnet,
  transport: custom(window.ethereum)
})

client.sendTransaction({ ... })
```

> viem uses the term ["Account"](https://ethereum.org/en/developers/docs/accounts/) rather than "Signer".

## Provider Methods

#### Ethers

```ts
import { getDefaultProvider } from 'ethers'

const provider = getDefaultProvider()

provider.getBlock(...) // [!code hl]
provider.getTransaction(...) // [!code hl]
...
```

#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

client.getBlock(...) // [!code hl]
client.getTransaction(...) // [!code hl]
...
```

> Methods that extend off the Public Client are **Public Actions**. [Read more](/docs/actions/public/introduction).

> There are API differences in all of these methods. Use the search bar at the top of the page to learn more about them.

## Signer Methods

### JsonRpcSigner

#### Ethers

```ts
import { providers } from 'ethers'

const provider = new providers.Web3Provider(window.ethereum)

const [address] = await provider.listAccounts()
const signer = provider.getSigner(address)

signer.sendTransaction(...) // [!code hl]
signer.signMessage(...) // [!code hl]
...
```

#### viem

```ts 
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' })

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: custom(window.ethereum)
})

client.sendTransaction({ ... }) // [!code hl]
client.signMessage({ ... }) // [!code hl]
...
```

> Methods that extend off the Wallet Client are **Wallet Actions**. [Read more](/docs/actions/wallet/introduction).

> There are API differences in all of these methods. Use the search bar at the top of the page to learn more about them.

## Contract Interaction

### Reading from Contracts

#### Ethers

```ts
import { getDefaultProvider } from 'ethers'
import { wagmiContractConfig } from './abi'

const provider = getDefaultProvider()

const { abi, address } = wagmiContractConfig // [!code hl]
const contract = new Contract(address, abi, provider) // [!code hl]
const supply = await contract.totalSupply() // [!code hl]
```

#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { wagmiContractConfig } from './abi'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

const supply = await client.readContract({ // [!code hl]
  ...wagmiContractConfig, // [!code hl]
  functionName: 'totalSupply' // [!code hl]
}) // [!code hl]
```

### Writing to Contracts

#### Ethers

```ts 
import { Contract, providers } from 'ethers'
import { wagmiContractConfig } from './abi'

const provider = new providers.Web3Provider(window.ethereum)

const [address] = await provider.listAccounts()
const signer = provider.getSigner(address)

const { abi, address } = wagmiContractConfig // [!code hl]
const contract = new Contract(address, abi, signer) // [!code hl]
const hash = await contract.mint() // [!code hl]
```

#### viem

```ts
import { createPublicClient, createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { wagmiContractConfig } from './abi'

const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

const [address] = await walletClient.getAddresses()

const hash = await walletClient.writeContract({ // [!code hl]
  ...wagmiContractConfig, // [!code hl]
  functionName: 'mint', // [!code hl]
  account: address, // [!code hl]
}) // [!code hl]
```

### Deploying Contracts

#### Ethers

```ts 
import { ContractFactory, providers } from 'ethers'
import { abi, bytecode } from './abi'

const provider = new providers.Web3Provider(window.ethereum)

const [address] = await provider.listAccounts()
const signer = provider.getSigner(address)

const contract = new ContractFactory(abi, bytecode, signer) // [!code hl]
await contract.deploy() // [!code hl]
```

#### viem

```ts
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { abi, bytecode } from './abi'

const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum)
})

const [address] = await walletClient.getAddresses()

await walletClient.deployContract({ // [!code hl]
  abi, // [!code hl]
  account: address, // [!code hl]
  bytecode, // [!code hl]
}) // [!code hl]
```

### Contract Events

#### Ethers

```ts 
import { getDefaultProvider } from 'ethers'
import { wagmiContractConfig } from './abi'

const provider = getDefaultProvider()

const { abi, address } = wagmiContractConfig // [!code hl]
const contract = new Contract(address, abi, provider) // [!code hl]

const listener = (from, to, amount, event) => { // [!code hl]
  // ... // [!code hl]
} // [!code hl]
contract.on('Transfer', listener) // [!code hl]

// unsubscribe // [!code hl]
contract.off('Transfer', listener) // [!code hl]
```

#### viem

```ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { wagmiContractConfig } from './abi'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

const unwatch = client.watchContractEvent({ // [!code hl]
  ...wagmiContractConfig, // [!code hl]
  eventName: 'Transfer', // [!code hl]
  onLogs: logs => { // [!code hl]
    const { args: { from, to, amount }, eventName } = logs[0] // [!code hl]
    // ... // [!code hl]
  }, // [!code hl]
}) // [!code hl]

// unsubscribe // [!code hl]
unwatch() // [!code hl]
```

> Note: Logs are batched between polling intervals in viem to avoid excessive callback invocations. You can disable this behavior with `batch: false` however.

### Gas Estimation

#### Ethers

```ts 
import { getDefaultProvider } from 'ethers'
import { wagmiContractConfig } from './abi'

const provider = getDefaultProvider()

const { abi, address } = wagmiContractConfig // [!code hl]
const contract = new Contract(address, abi, provider) // [!code hl]
const gas = await contract.estimateGas.mint() // [!code hl]
```

#### viem

```ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { wagmiContractConfig } from './abi'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

const gas = await client.estimateContractGas({ // [!code hl]
  ...wagmiContractConfig,  // [!code hl]
  functionName: 'mint' // [!code hl]
}) // [!code hl]
```

### Call

#### Ethers

```ts 
import { getDefaultProvider } from 'ethers'
import { wagmiContractConfig } from './abi'

const provider = getDefaultProvider()

const { abi, address } = wagmiContractConfig // [!code hl]
const contract = new Contract(address, abi, provider) // [!code hl]
await contract.callStatic.mint() // [!code hl]
```

#### viem

```ts 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { wagmiContractConfig } from './abi'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

await client.simulateContract({ // [!code hl]
  ...wagmiContractConfig,  // [!code hl]
  functionName: 'mint' // [!code hl]
}) // [!code hl]
```

### Contract Instances

#### Ethers

```ts 
import { getDefaultProvider } from 'ethers'
import { wagmiContractConfig } from './abi'

const provider = getDefaultProvider()

const { abi, address } = wagmiContractConfig // [!code hl]
const contract = new Contract(address, abi, provider) // [!code hl]

const supply = await contract.totalSupply()
const listener = (from, to, amount, event) => {
  // ...
}
contract.on('Transfer', listener)
contract.off('Transfer', listener)
```

#### viem

```ts 
import { createPublicClient, http, getContract } from 'viem'
import { mainnet } from 'viem/chains'
import { wagmiContractConfig } from './abi'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

const contract = getContract({ // [!code hl]
  ...wagmiContractConfig, // [!code hl]
  client, // [!code hl] 
}) // [!code hl]

const supply = await contract.read.totalSupply()
const unwatch = contract.watchEvent.Transfer({
  onLogs: logs => {
    const { args: { from, to, amount }, eventName } = logs[0]
    // ...
  },
})
unwatch()
```

## ABI Utilities

### abiCoder.encode

#### Ethers

```ts
import { utils } from 'ethers'

const abiCoder = utils.defaultAbiCoder()

// Object
abiCoder.encode(
  [{ type: 'uint', name: 'x' }, { type: 'string', name: 'y' }],
  [1234, 'Hello world']
)

// Human Readable
abiCoder.encode(
  ['uint', 'string'], 
  [1234, 'Hello World']
);
```

#### viem

```ts
import { encodeAbiParameters, parseAbiParameters } from 'viem'

// Object
encodeAbiParameters(
  [{ type: 'uint', name: 'x' }, { type: 'string', name: 'y' }],
  [1234, 'Hello world']
)

// Human Readable
encodeAbiParameters(
  parseAbiParameters('uint, string'),
  [1234, 'Hello world']
)
```

### abiCoder.decode

#### Ethers

```ts
import { utils } from 'ethers'

const abiCoder = utils.defaultAbiCoder()

// Object
abiCoder.decode(
  [{ type: 'uint', name: 'x' }, { type: 'string', name: 'y' }],
  '0x00000000000000000000000000000000000000000000000000000000000004d20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20576f726c64000000000000000000000000000000000000000000'
)

// Human Readable
abiCoder.decode(
  ['uint', 'string'], 
  '0x00000000000000000000000000000000000000000000000000000000000004d20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20576f726c64000000000000000000000000000000000000000000'
);
```

#### viem

```ts
import { decodeAbiParameters, parseAbiParameters } from 'viem'

// Object
decodeAbiParameters(
  [{ type: 'uint', name: 'x' }, { type: 'string', name: 'y' }],
  '0x00000000000000000000000000000000000000000000000000000000000004d20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20576f726c64000000000000000000000000000000000000000000'
)

// Human Readable
decodeAbiParameters(
  parseAbiParameters('uint, string'),
  '0x00000000000000000000000000000000000000000000000000000000000004d20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20576f726c64000000000000000000000000000000000000000000'
)
```

Notice: different from ethers, viem only supports [standard tuple expression](https://docs.soliditylang.org/en/latest/grammar#a4.SolidityParser.tupleExpression) for Human Readable.
example: `(uint a, string b)` is valid, but `tuple(uint a, string b)` is not.

### Fragments & Interfaces

In viem, there is no concept of "fragments" & "interfaces". We want to stick as close to the wire as possible and not introduce middleware abstractions and extra layers over ABIs. Instead of working with "fragments", we encourage you to work with the ABI itself.
We provide utilities such as `getAbiItem`, `parseAbi` `parseAbiItem`, `parseAbiParameters` and `parseAbiParameter` which covers the use cases of interfaces & fragments.

### Interface.format

viem only supports Human Readable → Object format.

#### Ethers

```ts 
import { utils } from 'ethers'

const interface = new Interface([ // [!code hl]
  'constructor(string symbol, string name)', // [!code hl]
  'function transferFrom(address from, address to, uint amount)', // [!code hl]
  'function transferFrom(address from, address to, uint amount, bool x)', // [!code hl]
  'function mint(uint amount) payable', // [!code hl]
  'function balanceOf(address owner) view returns (uint)' // [!code hl]
]) // [!code hl]
const json = interface.format(utils.FormatTypes.json) // [!code hl]
```

#### viem

```ts
import { parseAbi } from 'viem'

const json = parseAbi([ // [!code hl]
  'constructor(string symbol, string name)', // [!code hl]
  'function transferFrom(address from, address to, uint amount)', // [!code hl]
  'function transferFrom(address from, address to, uint amount, bool x)', // [!code hl]
  'function mint(uint amount) payable', // [!code hl]
  'function balanceOf(address owner) view returns (uint)', // [!code hl]
  'event Transfer(address indexed from, address indexed to, uint256 amount)' // [!code hl]
]) // [!code hl]
```

### Fragment.from

#### ethers

```ts 
import { utils } from 'ethers'

const fragment = utils.Fragment.from('function balanceOf(address owner) view returns (uint)') // [!code hl]
```

#### viem

```ts 
import { parseAbiItem } from 'viem'

const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint)') // [!code hl]
```

### ParamType.from

#### ethers

```ts 
import { utils } from 'ethers'

const param = utils.ParamType.from('address owner') // [!code hl]
```

#### viem

```ts 
import { parseAbiParameter } from 'viem'

const param = parseAbiParameter('address owner') // [!code hl]
```

### Fragment Access

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const interface = new utils.Interface(abi)  // [!code hl]
interface.getFunction('transferFrom') // [!code hl]
interface.getEvent('Transfer') // [!code hl]
```

#### viem

```ts
import { getAbiItem } from 'viem'
import { abi } from './abi'

getAbiItem({ abi, name: 'transferFrom' })  // [!code hl]
getAbiItem({ abi, name: 'Transfer' }) // [!code hl]
```

### Interface.encodeDeploy

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi);  // [!code hl]
const data = iface.encodeDeploy(['SYM', 'Some Name']) // [!code hl]
```

#### viem

```ts 
import { encodeDeployData } from 'viem'
import { abi, bytecode } from './abi'

const data = encodeDeployData({ // [!code hl]
  abi, // [!code hl]
  bytecode, // [!code hl]
  args: ['SYM', 'Some Name'] // [!code hl]
}) // [!code hl]
```

> Note: viem concatenates the contract bytecode onto the ABI encoded data.

### Interface.encodeErrorResult

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi);  // [!code hl]
const data = iface.encodeErrorResult('AccountLocked', [ // [!code hl]
  '0x8ba1f109551bD432803012645Ac136ddd64DBA72', // [!code hl]
  utils.parseEther('1.0') // [!code hl]
]); // [!code hl]
```

#### viem

```ts 
import { encodeErrorResult, parseEther } from 'viem'
import { abi } from './abi'

const data = encodeErrorResult({  // [!code hl]
  abi: wagmiAbi, // [!code hl]
  errorName: 'AccountLocked', // [!code hl]
  args: [ // [!code hl]
    '0x8ba1f109551bD432803012645Ac136ddd64DBA72', // [!code hl]
    parseEther('1.0') // [!code hl]
  ] // [!code hl]
}) // [!code hl]
```

### Interface.encodeFilterTopics

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi);  // [!code hl]
const data = iface.encodeFilterTopics('Transfer', [ // [!code hl]
  null, // [!code hl]
  '0x8ba1f109551bD432803012645Ac136ddd64DBA72' // [!code hl]
]) // [!code hl]
```

#### viem

```ts 
import { encodeEventTopics } from 'viem'
import { abi } from './abi'

const data = encodeEventTopics({ // [!code hl]
  abi, // [!code hl]
  eventName: 'Transfer', // [!code hl]
  args: { // [!code hl]
    to: '0x8ba1f109551bD432803012645Ac136ddd64DBA72' // [!code hl]
  } // [!code hl]
}) // [!code hl]
```

### Interface.encodeFunctionData

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi); // [!code hl]
const data = iface.encodeFunctionData('transferFrom', [ // [!code hl]
  '0x8ba1f109551bD432803012645Ac136ddd64DBA72', // [!code hl]
  '0xaB7C8803962c0f2F5BBBe3FA8bf41cd82AA1923C', // [!code hl]
  parseEther('1.0') // [!code hl]
]) // [!code hl]
```

#### viem

```ts 
import { encodeFunctionData, parseEther } from 'viem'
import { abi } from './abi'

const data = encodeFunctionData({  // [!code hl]
  abi, // [!code hl]
  functionName: 'transferFrom', // [!code hl]
  args: [ // [!code hl]
    '0x8ba1f109551bD432803012645Ac136ddd64DBA72', // [!code hl]
    '0xaB7C8803962c0f2F5BBBe3FA8bf41cd82AA1923C', // [!code hl]
    parseEther('1.0') // [!code hl]
  ] // [!code hl]
}) // [!code hl]
```

### Interface.encodeFunctionResult

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi); // [!code hl]
const data = iface.encodeFunctionResult('balanceOf', [ // [!code hl]
  '0x8ba1f109551bD432803012645Ac136ddd64DBA72' // [!code hl]
]) // [!code hl]
```

#### viem

```ts 
import { encodeFunctionResult, parseEther } from 'viem'
import { abi } from './abi'

const data = encodeFunctionResult({  // [!code hl]
  abi, // [!code hl]
  functionName: 'balanceOf', // [!code hl]
  value: ['0x8ba1f109551bD432803012645Ac136ddd64DBA72'] // [!code hl]
}) // [!code hl]
```

### Interface.decodeErrorResult

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi); // [!code hl] 
const result = iface.decodeErrorResult("AccountLocked", '0xf7c3865a0000000000000000000000008ba1f109551bd432803012645ac136ddd64dba720000000000000000000000000000000000000000000000000de0b6b3a7640000') // [!code hl]
```

#### viem

```ts
import { decodeErrorResult, parseEther } from 'viem'
import { abi } from './abi'

const result = decodeErrorResult({  // [!code hl]
  abi, // [!code hl]
  data: '0xf7c3865a0000000000000000000000008ba1f109551bd432803012645ac136ddd64dba720000000000000000000000000000000000000000000000000de0b6b3a7640000' // [!code hl]
}) // [!code hl]
```

### Interface.decodeEventLog

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi); // [!code hl]
const result = iface.decodeEventLog( // [!code hl]
  'Transfer', // [!code hl]
  data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000', // [!code hl] 
  topics: [ // [!code hl]
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // [!code hl]
    '0x0000000000000000000000008ba1f109551bd432803012645ac136ddd64dba72', // [!code hl]
    '0x000000000000000000000000ab7c8803962c0f2f5bbbe3fa8bf41cd82aa1923c' // [!code hl]
  ] // [!code hl]
); // [!code hl] 
```

#### viem

```ts 
import { decodeEventLog, parseEther } from 'viem'
import { abi } from './abi'

const result = decodeEventLog({ // [!code hl]
  abi, // [!code hl]
  data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000', // [!code hl] 
  topics: [ // [!code hl]
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // [!code hl]
    '0x0000000000000000000000008ba1f109551bd432803012645ac136ddd64dba72', // [!code hl]
    '0x000000000000000000000000ab7c8803962c0f2f5bbbe3fa8bf41cd82aa1923c' // [!code hl]
  ] // [!code hl]
}) // [!code hl]
```

### Interface.decodeFunctionData

#### Ethers

```ts 
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi); // [!code hl]
const result = iface.decodeFunctionData('transferFrom', '0x23b872dd0000000000000000000000008ba1f109551bd432803012645ac136ddd64dba72000000000000000000000000ab7c8803962c0f2f5bbbe3fa8bf41cd82aa1923c0000000000000000000000000000000000000000000000000de0b6b3a7640000'); // [!code hl]
```

#### viem

```ts
import { decodeFunctionData, parseEther } from 'viem'
import { abi } from './abi'

const result = decodeFunctionData({ // [!code hl]
  abi, // [!code hl]
  data: '0x23b872dd0000000000000000000000008ba1f109551bd432803012645ac136ddd64dba72000000000000000000000000ab7c8803962c0f2f5bbbe3fa8bf41cd82aa1923c0000000000000000000000000000000000000000000000000de0b6b3a7640000', // [!code hl]
}) // [!code hl]
```

### Interface.decodeFunctionResult

#### Ethers

```ts
import { utils } from 'ethers'
import { abi } from './abi'

const iface = new utils.Interface(abi); // [!code hl]
const result = iface.decodeFunctionResult('balanceOf', '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000'); // [!code hl]
```

#### viem

```ts
import { decodeFunctionResult, parseEther } from 'viem'
import { abi } from './abi'

const result = decodeFunctionResult({ // [!code hl]
  abi, // [!code hl]
  functionName: 'balanceOf', // [!code hl]
  data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000', // [!code hl]
}) // [!code hl]
```

### Interface.getSighash

#### Ethers

```ts
import { Interface, FunctionFragment } from '@ethersproject/abi';

const hash = Interface.getSighash(FunctionFragment.from('function ownerOf(uint256)')); // [!code hl]
```

#### viem

```ts 
import { toFunctionHash } from 'viem'

const hash = toFunctionHash('function ownerOf(uint256)') // [!code hl]
```

## Address Utilities

### getAddress

#### Ethers

```ts 
import { utils } from 'ethers'

const address = utils.getAddress('0x8ba1f109551bd432803012645ac136ddd64dba72') // [!code hl]
```

#### viem

```ts
import { getAddress } from 'viem'

const address = getAddress('0x8ba1f109551bd432803012645ac136ddd64dba72') // [!code hl]
```

### isAddress

#### Ethers

```ts 
import { utils } from 'ethers'

const address = utils.isAddress('0x8ba1f109551bd432803012645ac136ddd64dba72') // [!code hl]
```

#### viem

```ts
import { isAddress } from 'viem'

const address = isAddress('0x8ba1f109551bd432803012645ac136ddd64dba72') // [!code hl]
```

### getContractAddress

#### Ethers

```ts 
import { utils } from 'ethers'

const address = utils.getContractAddress({ from: '0x...', nonce: 5 }); // [!code hl]
```

#### viem

```ts 
import { getContractAddress } from 'viem'

const address = getContractAddress({ from: '0x...', nonce: 5 }) // [!code hl]
```

### getCreate2Address

#### Ethers
 
```ts
import { utils } from 'ethers'

const from = '0x8ba1f109551bD432803012645Ac136ddd64DBA72'; // [!code hl]
const salt = '0x7c5ea36004851c764c44143b1dcb59679b11c9a68e5f41497f6cf3d480715331'; // [!code hl]
const initCode = '0x6394198df16000526103ff60206004601c335afa6040516060f3'; // [!code hl]
const initCodeHash = utils.keccak256(initCode); // [!code hl]

const address = utils.getCreate2Address(from, salt, initCodeHash); // [!code hl]
```

#### viem

```ts 
import { getContractAddress } from 'viem'

const address = getContractAddress({ // [!code hl]
  bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3', // [!code hl]
  from: '0x8ba1f109551bD432803012645Ac136ddd64DBA72', // [!code hl]
  opcode: 'CREATE2', // [!code hl]
  salt: '0x7c5ea36004851c764c44143b1dcb59679b11c9a68e5f41497f6cf3d480715331', // [!code hl]
}); // [!code hl]
```

## BigNumber Utilities

### Ethers

Many.

### viem

None. We use browser native [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt).

## Byte Manipulation Utilities

### isBytes

#### Ethers

```ts 
import { utils } from 'ethers'

utils.isBytes(new Uint8Array([1, 69, 420])) // [!code hl]
```

#### viem

```ts 
import { isBytes } from 'viem'

isBytes(new Uint8Array([1, 69, 420])) // [!code hl]
```

### isHexString

#### Ethers

```ts 
import { utils } from 'ethers'

utils.isHexString('0xdeadbeef') // [!code hl]
```

#### viem

```ts
import { isHex } from 'viem'

isHex('0xdeadbeef') // [!code hl]
```

### isBytesLike

#### Ethers

```ts
import { utils } from 'ethers'

utils.isBytesLike('0xdeadbeef') // [!code hl]
```

#### viem

```ts 
import { isBytes, isHex } from 'viem'

isBytes('0xdeadbeef') || isHex('0xdeadbeef') // [!code hl]
```

### arrayify

#### Ethers

```ts 
import { utils } from 'ethers'

utils.arrayify('0xdeadbeef') // [!code hl]
```

#### viem

```ts
import { toBytes } from 'viem'

toBytes('0xdeadbeef') // [!code hl]
```

### hexlify

#### Ethers

```ts
import { utils } from 'ethers'

utils.hexlify(new Uint8Array([1, 69, 420])) // [!code hl]
```

#### viem

```ts
import { toHex } from 'viem'

toHex(new Uint8Array([1, 69, 420])) // [!code hl]
```

### hexValue

#### Ethers

```ts
import { utils } from 'ethers'

utils.hexValue(1) // [!code hl]
```

#### viem

```ts
import { toHex } from 'viem'

toHex(1) // [!code hl]
```

### formatBytes32String

#### Ethers

```ts
import { utils } from 'ethers'

utils.formatBytes32String('Hello world') // [!code hl]
// 0x48656c6c6f20776f726c642e0000000000000000000000000000000000000000
```

#### viem

```ts
import { stringToHex } from 'viem'

stringToHex('Hello world', { size: 32 }) // [!code hl]
// 0x48656c6c6f20776f726c642e0000000000000000000000000000000000000000
```

### parseBytes32String

#### Ethers

```ts 
import { utils } from 'ethers'

utils.parseBytes32String('0x48656c6c6f20776f726c642e0000000000000000000000000000000000000000') // [!code hl]
// "Hello world"
```

#### viem

```ts 
import { hexToString } from 'viem'

hexToString('0x48656c6c6f20776f726c642e0000000000000000000000000000000000000000', { size: 32 }) // [!code hl]
// "Hello world"
```

### concat

#### Ethers

```ts 
import { utils } from 'ethers'

utils.concat([new Uint8Array([69]), new Uint8Array([420])]) // [!code hl]
```

#### viem

```ts 
import { concat, toBytes } from 'viem'

concat([new Uint8Array([69]), new Uint8Array([420])]) // [!code hl]
```

### stripZeros

#### Ethers

```ts 
import { utils } from 'ethers'

utils.stripZeros(new Uint8Array([0, 0, 0, 0, 0, 69])) // [!code hl]
```

#### viem

```ts 
import { trim } from 'viem'

trim(new Uint8Array([0, 0, 0, 0, 0, 69])) // [!code hl]
```

### zeroPad

#### Ethers

```ts 
import { utils } from 'ethers'

utils.zeroPad(new Uint8Array([69]), 32) // [!code hl]
```

#### viem

```ts
import { pad } from 'viem'

pad(new Uint8Array([69]), { size: 32 }) // [!code hl]
```

### hexConcat

#### Ethers

```ts
import { utils } from 'ethers'

utils.hexConcat(['0x00000069', '0x00000420']) // [!code hl]
```

#### viem

```ts
import { concat, toBytes } from 'viem'

concat(['0x00000069', '0x00000420']) // [!code hl]
```

### hexDataLength

#### Ethers

```ts 
import { utils } from 'ethers'

utils.hexDataLength('0x00000069') // [!code hl]
```

#### viem

```ts
import { size } from 'viem'

size('0x00000069') // [!code hl]
```

### hexDataSlice

#### Ethers

```ts
import { utils } from 'ethers'

utils.hexDataSlice('0x00000069', 4) // [!code hl]
```

#### viem

```ts
import { slice } from 'viem'

slice('0x00000069', 4) // [!code hl]
```

### hexStripZeros

#### Ethers

```ts
import { utils } from 'ethers'

utils.hexStripZeros('0x00000069') // [!code hl]
```

#### viem

```ts 
import { trim } from 'viem'

trim('0x00000069') // [!code hl]
```

### hexZeroPad

#### Ethers

```ts 
import { utils } from 'ethers'

utils.hexZeroPad('0x69', 32) // [!code hl]
```

#### viem

```ts 
import { pad } from 'viem'

pad('0x69', { size: 32 }) // [!code hl]
```

## Display Logic & Input Utilities

### formatUnits

#### Ethers

```ts
import { utils } from 'ethers'

utils.formatUnits(BigNumber.from('1000000000'), 9) // [!code hl]
```

#### viem

```ts 
import { formatUnits } from 'viem'

formatUnits(1000000000n, 9) // [!code hl]
```

### formatEther

#### Ethers

```ts 
import { utils } from 'ethers'

utils.formatEther(BigNumber.from('1000000000000000000')) // [!code hl]
```

#### viem

```ts 
import { formatEther } from 'viem'

formatEther(1000000000000000000n) // [!code hl]
```

### parseUnits

#### Ethers

```ts 
import { utils } from 'ethers'

utils.parseUnits('1.0', 18) // [!code hl]
```

#### viem

```ts 
import { parseUnits } from 'viem'

parseUnits('1', 18) // [!code hl]
```

### parseEther

#### Ethers

```ts 
import { utils } from 'ethers'

utils.parseEther('1.0') // [!code hl]
```

#### viem

```ts
import { parseEther } from 'viem'

parseEther('1') // [!code hl]
```

## Encoding Utilities

### RLP.encode

#### Ethers

```ts 
import { utils } from 'ethers'

utils.RLP.encode('0x12345678') // [!code hl]
```

#### viem

```ts 
import { toRlp } from 'viem'

toRlp('0x12345678') // [!code hl]
```

### RLP.decode

#### Ethers

```ts
import { utils } from 'ethers'

utils.RLP.decode('0x8412345678') // [!code hl]
```

#### viem

```ts 
import { fromRlp } from 'viem'

fromRlp('0x8412345678') // [!code hl]
```

## Hashing Utilities

### id

#### Ethers

```ts 
import { utils } from 'ethers'

utils.id('function ownerOf(uint256 tokenId)') // [!code hl]

// hash utf-8 data
utils.id('hello world') // [!code hl]
```

#### viem

```ts 
import { toFunctionSelector, keccak256, toHex } from 'viem'

toFunctionSelector('function ownerOf(uint256 tokenId)') // [!code hl]

// hash utf-8 data
keccak256(toHex('hello world')) // [!code hl]
```

### keccak256

#### Ethers

```ts
import { utils } from 'ethers'

utils.keccak256(utils.toUtf8Bytes('hello world')) // [!code hl]
```

#### viem

```ts 
import { keccak256, toBytes } from 'viem'

keccak256(toBytes('hello world')) // [!code hl]
```

### encodeBase64/decodeBase64

viem does not provide Base64 encoding utilities. 

You can use browser native [`atob`](https://developer.mozilla.org/en-US/docs/Web/API/atob) and [`btoa`](https://developer.mozilla.org/en-US/docs/Web/API/btoa) instead.

### encodeBase58/decodeBase58

viem does not provide Base58 encoding utilities.

You can use libraries such as [`base58-js`](https://www.npmjs.com/package/base58-js) or [`bs58`](https://github.com/cryptocoinjs/bs58) instead.

### namehash

#### Ethers

```ts 
import { utils } from 'ethers'

utils.namehash('awkweb.eth') // [!code hl]
```

#### viem

```ts 
import { namehash } from 'viem'

namehash('awkweb.eth') // [!code hl]
```

### solidityPack & solidityKeccak256

#### Ethers

```ts 
import { utils } from 'ethers'

utils.solidityPack(['int16', 'uint48'], [-1, 12]) // [!code hl]
utils.solidityKeccak256(['int16', 'uint48'], [-1, 12]) // [!code hl]
```

#### viem

```ts
import { encodePacked, keccak256 } from 'viem'

encodePacked(['int16', 'uint48'], [-1, 12]) // [!code hl]
keccak256(encodePacked(['int16', 'uint48'], [-1, 12])) // [!code hl]
```

## String Utilities

### toUtf8Bytes

#### Ethers

```ts 
import { utils } from 'ethers'

utils.toUtf8Bytes('Hello World') // [!code hl]
```

#### viem

```ts 
import { stringToBytes } from 'viem'

stringToBytes('Hello World') // [!code hl]
```

### toUtf8String

#### Ethers

```ts 
import { utils } from 'ethers'

utils.toUtf8String(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])) // [!code hl]
```

#### viem

```ts 
import { bytesToString } from 'viem'

bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])) // [!code hl]
```

## Transaction Utilities

### serializeTransaction

#### Ethers

```ts
import { utils } from 'ethers'

const serialized = utils.serializeTransaction({
  chainId: 1,
  maxFeePerGas: utils.parseGwei('20'),
  maxPriorityFeePerGas: utils.parseGwei('2'),
  nonce: 69,
  to: "0x1234512345123451234512345123451234512345",
  type: 2,
  value: utils.parseEther('0.01'),
})
```

#### viem

```ts
import { serializeTransaction, parseEther, parseGwei } from 'viem'

const serialized = serializeTransaction({
  chainId: 1,
  gas: 21001n,
  maxFeePerGas: parseGwei('20'),
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  to: "0x1234512345123451234512345123451234512345",
  value: parseEther('0.01'),
})
```

### parseTransaction

#### Ethers

```ts
import { utils } from 'ethers'

const transaction = utils.parseTransaction('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')
```

#### viem

```ts
import { parseTransaction } from 'viem'

const transaction = parseTransaction('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')
```
</file>

<file path="faq.mdx">
# Frequently Asked Questions

Frequently asked questions related to viem.

**TL;DR: viem tries to avoid creating unnecessary abstractions on top of existing systems.**

Feel free to add to this document if you notice frequently asked questions that are not covered here.

{/* [[toc]] */}

## Why use the terms "Wallet" & "Account" instead of "Signer"

viem attempts to align to the "Wallet" and "Account" [terminology on Ethereum.org](https://ethereum.org/en/glossary/). The term "Signer" was adapted from ethers.js.

Let's clear up on some terms before we dive in.

- Wallet: An application or interface that holds Account(s).
- Account: An object that represents an address, balance, nonce, and optional storage and code.
- Private Key: Proves ownership of an Account, and can sign messages & transactions.

In the context of viem, a Wallet Client is an interface that can hold an Account. The Account may or may not hold a Private Key.

In viem, there are two types of Accounts:
- Local Account: can **synchronously & directly** sign messages and transactions using its Private Key. A signature is guaranteed.
- JSON-RPC Account: **asynchronously requests** signing of messages and transactions from the target Wallet over JSON-RPC (e.g. Browser Extension or WalletConnect). The target Wallet holds the Account & Private Key. A signature is not guaranteed (the target Wallet may not have permitted the Account, or the Wallet may have rejected the request).

We do not use the term "Signer" because there are noticeable behavioral differences between signing locally and signing over JSON-RPC.

## Why are contract function `args` with fully-named inputs represented as unnamed tuple types instead of object types?

Let's look at an example! Suppose I have the following function in my contract:

```solidity
function transferFrom(address sender, address recipient, uint256 amount) returns (bool)
```

All the inputs are named (`sender`, `recipient`, and `amount`) so I might be tempted to represent the parameters as the following TypeScript type:

```ts
type Args = {
  sender: `0x${string}`;
  recipient: `0x${string}`;
  amount: bigint;
}
```

This improves developer experience a bit because now I can see the names of the parameters in my editor.

```ts
import { createWalletClient, parseAbi } from 'viem'

const client = createWalletClient(…)
client.writeContract({
  address: '0x…',
  abi: parseAbi([
    'function transferFrom(address sender, address recipient, uint256 amount) returns (bool)',
  ]),
  functionName: 'transferFrom',
  args: {
    sender: '0x…',
    recipient: '0x…',
    amount: 100n,
  },
})
```

However, this only works if all the inputs are named (some compilers will strip names from inputs). If any of the inputs are unnamed, then you'll have to use a tuple instead:

```ts
client.writeContract({
  address: '0x…',
  abi: parseAbi([
    'function transferFrom(address, address, uint256) returns (bool)',
  ]),
  functionName: 'transferFrom',
  args: ['0x…', '0x…', 100n],
})
```

This can get even more complicated when a function has overloads:

```solidity
function safeTransferFrom(address, address, uint256) {}
function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) {}
```

In this case, the type of the overload parameters start to diverge from each other:

```ts
type Args =
  | [`0x${string}`, `0x${string}`, bigint]
  | {
      from: `0x${string}`;
      to: `0x${string}`;
      tokenId: bigint;
      data: string;
    }
```

If you want to switch between the two overloads in your code, you'll need to completely change the type instead of just adding or removing a single positional argument from the end. (Objects also don't enforce type-level ordering so you can put them in whatever order you want. This would also mean that viem would also need to internally validate order during runtime, adding some extra overhead.)

```diff
client.writeContract({
  address: '0x…',
  abi: parseAbi([
    'function safeTransferFrom(address, address, uint256)',
    'function safeTransferFrom(address from, address to, uint256 tokenId, bytes data)',
  ]),
  functionName: 'safeTransferFrom',
- args: ['0x…', '0x…', 100n],
+ args: {
+   from: '0x…',
+   to: '0x…',
+   tokenId: 100n,
+   data: '0x…',
+ },
})
```

Even though overloads are an edge case, it would be sufficiently [astonishing](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) to come across this behavior. So what's the best way to represent `args`? Well, they are positional at the contract-level so it makes sense to represent them that way in viem too.

Not all is lost when it comes to developer experience though! Tuple types in TypeScript can have [names](https://www.typescriptlang.org/play?ts=4.0.2#example/named-tuples) attached to them:

```ts
type Args = [from: `0x${string}`, to: `0x${string}`, tokenId: bigint]
```

These names show up in your editor so you get nice developer experience when using autocomplete, etc. Unfortunately, TypeScript doesn't support dynamic named tuples right now, but we are watching [this issue](https://github.com/microsoft/TypeScript/issues/44939) closely and once it is implemented, we will add it to viem. In the meantime, hang tight!

## Why is a contract function return type returning an array instead of an object?

Suppose your ABI looks like this:

```ts
[
  {
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { name: "roundId", type: "uint80" },
      { name: "answer", type: "int256" },
      { name: "startedAt", type: "uint256" },
      { name: "updatedAt", type: "uint256" },
      { name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  }
]
```

You might be confused why the following does not return an object:

```ts
import { createPublicClient, parseAbi } from 'viem'

const client = createPublicClient(…)
const res = await client.readContract({
  address: '0x…',
  abi: […], // abi from above
  functionName: 'latestRoundData',
})
res
// ^? const res: [bigint, bigint, bigint, bigint, bigint]
```

This is expected. `"latestRoundData"` `outputs` is an array of types, so you get an array of decoded values as the return type. viem only maps explicitly typed tuples as objects

Why does viem follow this approach? Here is the contract function definition for `latestRoundData` with two different return types:

```solidity
function latestRoundData() external view
  returns (
    uint80 roundId,
    int256 answer,
    uint256 startedAt,
    uint256 updatedAt,
    uint80 answeredInRound
  );

struct Data {
  uint80 roundId;
  uint256 answer;
  uint256 startedAt;
  uint256 updatedAt;
  uint80 answeredInRound
}

function latestRoundData() external view returns (Data data);
```

The first function returns a set of five items, so viem maps it to an array. The reason why we don't convert it to an object is because things get ambiguous when we come to decode structs. How do you determine the difference between a "return" tuple (first function) and a "struct" tuple (second function).

Another reason is that folks might expect it to be an array (because it is a set of return items). Other libraries, like ethers, mitigate this by returning a hybrid Array/Object type, but that kind of type is not serializable in JavaScript, and viem prefers to not try and "hack" JavaScript types.

## Why doesn't Wallet Client support public actions?

Wallet Client doesn't support public actions because wallet providers (Injected `window.ethereum`, WalletConnect v2, etc.) may not provide a large majority of "node"/"public" RPC methods like `eth_call`, `eth_newFilter`, `eth_getLogs`, etc. This is because these methods are not required for a wallet provider to function properly. For example, a wallet provider may only support `eth_sendTransaction` and `eth_sign` and nothing else.
</file>

<file path="getting-started.mdx">
# Getting Started [Get started with viem in just a few lines of code.]

## Overview

viem is a TypeScript interface for Ethereum that provides low-level stateless primitives for interacting with Ethereum. viem is focused on developer experience, stability, bundle size, and performance:

- **Developer experience** Automatic [type safety and inference](/docs/typescript), comprehensive documentation, composable APIs.
- **Stability** Test suite runs against forked Ethereum networks, complete [test coverage](https://app.codecov.io/gh/wevm/viem).
- **Bundle size** Tree-shakable lightweight modules.
- **Performance** Optimized encoding/parsing, async tasks only when necessary.

You can learn more about the rationale behind the project in the [Why viem](/docs/introduction) section.

## Installation

:::code-group

```bash [npm]
npm i viem
```

```bash [pnpm]
pnpm i viem
```

```bash [bun]
bun i viem
```

:::

## Quick Start

### 1. Set up your Client & Transport

Firstly, set up your [Client](/docs/clients/intro) with a desired [Transport](/docs/clients/intro) & [Chain](/docs/chains/introduction).

```ts twoslash
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({ // [!code focus]
  chain: mainnet, // [!code focus]
  transport: http(), // [!code focus]
}) // [!code focus]
```

:::info
In a production app, it is highly recommended to pass through your authenticated RPC provider URL (Infura, thirdweb, etc). If no URL is provided, viem will default to a public RPC provider. [Read more](/docs/clients/transports/http#usage).
:::

### 2. Consume Actions

Now that you have a Client set up, you can now interact with Ethereum and consume [Actions](/docs/actions/public/introduction)!

```ts twoslash 
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})

const blockNumber = await client.getBlockNumber() // [!code focus]
```

## Live example

<iframe className="mt-6" width="100%" height="600px" frameBorder="0" src="https://stackblitz.com/edit/viem-getting-started?embed=1&file=index.ts&hideNavigation=1&hideDevTools=true&terminalHeight=1&hideExplorer=1&devtoolsheight=1&ctl=1"></iframe>
</file>

<file path="installation.mdx">
# Installation

Install Viem via your package manager, a `<script>` tag, or build from source.

## Package Manager

Install the required packages.

:::code-group
```bash [pnpm]
pnpm add viem
```

```bash [npm]
npm install viem
```

```bash [yarn]
yarn add viem
```

```bash [bun]
bun add viem
```
:::

## CDN

If you're not using a package manager, you can also use Viem via an ESM-compatible CDN such as [esm.sh](https://esm.sh). Simply add a `<script type="module">` tag to the bottom of your HTML file with the following content.

```html
<script type="module">
  import { createClient } from 'https://esm.sh/viem'
</script>
```

## Using Unreleased Commits

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/viem/tree/main) branch).

:::code-group
```bash [pnpm]
pnpm add viem@canary
```

```bash [npm]
npm install viem@canary
```

```bash [yarn]
yarn add viem@canary
```

```bash [bun]
bun add viem@canary
```
:::

Or clone the [Viem repo](https://github.com/wevm/viem) to your local machine, build, and link it yourself.

```bash
gh repo clone wevm/viem
cd viem
pnpm install
pnpm build
pnpm link --global
```

Then go to the project where you are using Viem and run `pnpm link --global viem` (or the package manager that you used to link Viem globally).

## Security

Ethereum-related projects are often targeted in attacks to steal users' assets. Make sure you follow security best-practices for your project. Some quick things to get started.

- Pin package versions, upgrade mindfully, and inspect lockfile changes to minimize the risk of [supply-chain attacks](https://nodejs.org/en/guides/security/#supply-chain-attacks).
- Install the [Socket Security](https://socket.dev) [GitHub App](https://github.com/apps/socket-security) to help detect and block supply-chain attacks.
- Add a [Content Security Policy](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) to defend against external scripts running in your app.
</file>

<file path="introduction.mdx">
# Why Viem [A brief preamble on why we built Viem]

## The Problems

The current state of low-level Ethereum interface abstractions lack in at least one of the following four areas: **developer experience**, **stability**, **bundle size** and/or **performance** — a quadrilemma.

As the authors of [wagmi](https://wagmi.sh), a popular React Hooks library for Ethereum, we struggled to work with the existing low-level TypeScript Ethereum libraries. We wanted to provide the users of wagmi with the best possible developer experience, but we were limited by the underlying technologies wagmi was built on. We knew an _always_ stable, predictable implementation with a tiny bundle size and performant modules was paramount to interacting with the world's largest blockchain ecosystem.

So we created **viem**: a TypeScript Interface for Ethereum that provides low-level stateless primitives for interacting with Ethereum. An alternative to ethers.js and web3.js with a focus on reliability, efficiency, and excellent developer experience.

## Developer Experience

viem delivers a great developer experience through modular and composable APIs, comprehensive documentation, and automatic type safety and inference.

It provides developers with intuitive building blocks to build their Ethereum apps and libraries. While viem's APIs may be more verbose than alternative libraries, we believe this is the right trade-off as it makes viem's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows the developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use viem is a great way to learn how to interact with Ethereum in general.

We aim to provide extensive API documentation and usage for _every_ module in viem. viem uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](<https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20(TDD),software%20against%20all%20test%20cases.>) development approach to building modules, which leads to predictable and stable APIs.

viem also provides consumers with [strongly typed APIs](/docs/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/_jxom/status/1570244174502588417?s=20), as well as static validation.

## Stability

Stability is a fundamental principle for viem. As the authors of [wagmi](https://wagmi.sh), we have many organizations, large and small, that rely heavily on the library and expect it to be entirely stable for their users.

viem takes the following steps to ensure stability:

- We run our test suite against a forked Ethereum node
- We aim for complete test coverage and test all potential behavioral cases
- We build deterministic and pure APIs

## Bundle Size

Maintaining a low bundle size is critical when building web applications. End users should not be required to download a module of over 100kB in order to interact with Ethereum. On a slow 3G mobile network loading a 100kB library would take at least **two seconds** (plus additional time to establish an HTTP connection).

Furthermore, viem is tree-shakable, meaning only the modules you use are included in your final bundle.

<div className="h-4"></div>
<img src="/bench-bundlesize.svg" />

## Performance

In addition to the fast load times mentioned above, viem further tunes performance by only executing heavy asynchronous tasks when required and optimized encoding/parsing algorithms. The benchmarks speak for themselves:

<div className="m-auto mt-10 space-y-14 w-10/12">
  <img src="/bench-isaddress.svg" />
  <img src="/bench-parseabi.svg" />
  <img src="/bench-encodeabi.svg" />
</div>

## Opinions & Escape Hatches

Unlike other low-level interfaces that impose opinions on consumers, viem enables consumers to choose their opinions while still maintaining sensible and secure defaults. This allows consumers to create their own opinionated implementations, such as [wagmi](https://wagmi.sh), without the need for tedious workarounds.

---

**viem** will help developers build with a higher level of accuracy and correctness through type safety and developer experience. It will also integrate extremely well with [wagmi](https://wagmi.sh) so folks can start using it without much upfront switching cost.
</file>

<file path="migration-guide.mdx">
---
head:
  - - meta
    - property: og:title
      content: Migration Guide
  - - meta
    - name: description
      content: Guide to migrate to newer versions of viem.
  - - meta
    - property: og:description
      content: Guide to migrate to newer versions of viem.
---

# Migration Guide

If you are coming from an earlier version of `viem`, you will need to make sure to update the following APIs listed below.

## 2.x.x Breaking changes

The 2.x.x release includes very minor breaking changes to the Contract Instances API, entrypoints, chain modules, and miscellaneous actions + utilities listed below.

Not ready to migrate? [Head to the 1.x.x docs.](https://v1.viem.sh)

### Actions: Modified `getContract` Client API

The `publicClient` and `walletClient` parameters of the `getContract` API has been removed in favour of `client` to support Client's that [extend](/docs/clients/wallet#optional-extend-with-public-actions) (ie. [a Wallet Client extended with Public Actions](/docs/clients/wallet#optional-extend-with-public-actions)).

[Read more.](/docs/contract/getContract)

```tsx
import { getContract } from 'viem'
import { publicClient, walletClient } from './client'

const contract = getContract({
  abi,
  address,
  publicClient, // [!code --]
  walletClient, // [!code --]
  client: { // [!code ++]
    public: publicClient, // [!code ++]
    wallet: walletClient, // [!code ++]
  } // [!code ++]
})
```

### Removed entrypoints

The following entrypoints have been removed:

- `viem/abi`
- `viem/contract`
- `viem/public`
- `viem/test`
- `viem/wallet`

You can import the entrypoints directly from `viem`:

```ts
import { encodeAbiParameters } from 'viem/abi' // [!code --]
import { getContract } from 'viem/contract' // [!code --]
import { getBlock } from 'viem/public' // [!code --]
import { mine } from 'viem/test' // [!code --]
import { sendTransaction } from 'viem/wallet' // [!code --]
import { // [!code ++]
  encodeAbiParameters, // [!code ++] 
  getContract, // [!code ++]
  getBlock, // [!code ++]
  mine, // [!code ++]
  sendTransaction, // [!code ++]
} from 'viem' // [!code ++]
```

### Moved chain-specific exports in `viem/chains/utils`

Chain-specific exports in `viem/chains/utils` have been moved to `viem/{celo|op-stack|zksync}`:

```ts
import {
  parseTransactionCelo,
  parseTransaction // [!code ++]
  serializeTransactionCelo, // [!code --]
  serializeTransaction // [!code ++]
  // ...
} from 'viem/chains/utils' // [!code --]
} from 'viem/celo' // [!code ++]

import {
  // ...
} from 'viem/chains/utils'  // [!code --]
} from 'viem/op-stack' // [!code ++]

import {
  parseTransactionZkSync, // [!code --]
  parseTransaction, // [!code ++]
  serializeTransactionZkSync, // [!code --]
  serializeTransaction, // [!code ++]
  // ...
} from 'viem/chains/utils'  // [!code --]
} from 'viem/zksync' // [!code ++]
```

### Actions: `getBlockNumber`

The `maxAge` parameter has been removed in favor of `cacheTime`.

```ts
const blockNumber = await client.getBlockNumber({
  maxAge: 84_600 // [!code --]
  cacheTime: 84_600 // [!code ++]
})
```

### Actions: `OnLogFn` & `OnLogParameter` types

The `OnLogFn` & `OnLogParameter` types have been renamed.

```ts
import {
  OnLogFn, // [!code --]
  WatchEventOnLogsFn, // [!code ++]
  OnLogParameter, // [!code --]
  WatchEventOnLogsParameter, // [!code ++]
} from 'viem' 
```

### Actions: `prepareRequest`

The `prepareRequest` Action has been renamed to `prepareTransactionRequest` and moved to `viem/actions` entrypoint.

```ts
import {
  prepareRequest, // [!code --]
  prepareTransactionRequest, // [!code ++]
} from 'viem' // [!code --]
} from 'viem/actions' // [!code ++]
```

### Actions: `SimulateContractParameters` & `SimulateContractReturnType` types

Note the following breaking generic slot changes:

```ts
type SimulateContractParameters<
  TAbi,
  TFunctionName,
  TArgs, // Args added to Slot 2 // [!code ++]
  TChain,
  TChainOverride,
  TAccountOverride,
>

type SimulateContractReturnType<
  TAbi,
  TFunctionName,
  TArgs, // Args added to Slot 2 // [!code ++]
  TChain,
  TAccount, // Account added to Slot 4 // [!code ++]
  TChainOverride,
  TAccountOverride,
>
```

### Utilities: Removed `extractFunctionParts`, `extractFunctionName`, `extractFunctionParams`, `extractFunctionType`

The `extractFunctionParts`, `extractFunctionName`, `extractFunctionParams`, `extractFunctionType` utility functions have been removed. You can use the [`parseAbiItem` utility function from abitype](https://abitype.dev/api/human#parseabiitem-1) instead.

### Utilities: Renamed `bytesToBigint`

The `bytesToBigint` utility function has been renamed to `bytesToBigInt`.

```ts
import {
  bytesToBigint, // [!code --]
  bytesToBigInt, // [!code ++]
} from 'viem'
```

### Utilities: Renamed chain types

The following chain types have been renamed:

```ts
import {
  Formatter, // [!code --]
  ChainFormatter, // [!code ++]
  Formatters, // [!code --]
  ChainFormatters, // [!code ++]
  Serializers, // [!code --]
  ChainSerializers, // [!code ++]
  ExtractFormatterExclude, // [!code --]
  ExtractChainFormatterExclude, // [!code ++]
  ExtractFormatterParameters, // [!code --]
  ExtractChainFormatterParameters, // [!code ++]
  ExtractFormatterReturnType, // [!code --]
  ExtractChainFormatterReturnType, // [!code ++]
} from 'viem'
```

### Utilities: `isAddress` & `getAddress` perform checksum validation

The `isAddress` utility function now performs checksum validation by default. 

To opt-out of this behavior, you can pass `strict: false` or lowercase the address.

```ts
import { isAddress } from 'viem'

isAddress('0xa5cc3c03994db5b0d9a5eEdD10Cabab0813678ac', {
  strict: false // [!code ++]
})

isAddress(
  '0xa5cc3c03994db5b0d9a5eEdD10Cabab0813678ac'.toLowerCase() // [!code ++]
)
```

## 1.x.x Breaking changes

The 1.x.x release only includes very minor changes to the behavior in event log decoding, and removes the redundant ethers.js Wallet Adapter. If you do not directly use these APIs, you do not need to update any of your code for this version.

### Removed `ethersWalletToAccount`

The `ethersWalletToAccount` adapter has been removed.

This adapter was introduced when viem did not have Private Key & HD Accounts. Since 0.2, viem provides all the utilities needed to create and import [Private Key](https://viem.sh/docs/accounts/local/privateKeyToAccount) & [HD Accounts](https://viem.sh/docs/accounts/local/mnemonicToAccount).

If you still need it, you can copy + paste the [old implementation](https://github.com/wevm/viem/blob/a9a71507032db896295fa1f3fa2dd6c2bdc85137/src/adapters/ethers.ts).

### `logIndex` & `transactionIndex` on Logs

`logIndex` & `transactionIndex` on `Log` now return a `number` instead of a `bigint`.

```ts
const log: Log = {
  ...
  logIndex: 1n, // [!code --]
  logIndex: 1, // [!code ++]
  transactionIndex: 1n, // [!code --]
  transactionIndex: 1, // [!code ++]
  ...
}
```

### Minor: `decodeEventLog` behavior change

`decodeEventLog` no longer attempts to partially decode events. If the Log does not conform to the ABI (mismatch between the number of indexed/non-indexed arguments to topics/data), it will throw an error. 

For example, the following Log will throw an error as there is a mismatch in non-`indexed` arguments & `data` length.

```ts 
decodeEventLog({
  abi: parseAbi(['event Transfer(address indexed, address, uint256)']), // [!code focus]
  // `data` should be 64 bytes, but is only 32 bytes. // [!code focus]
  data: '0x0000000000000000000000000000000000000000000000000000000000000001' // [!code focus]
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
    '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  ]
})
```

Previously, the above would only decode the `indexed` arguments. 

If you would like to partially decode event logs (previous behavior), you can turn off `strict` mode:

```ts 
decodeEventLog({
  abi: parseAbi(['event Transfer(address indexed, address, uint256)']),
  data: '0x0000000000000000000000000000000000000000000000000000000000000001'
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
    '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  ],
  strict: false // [!code ++]
})
```

## 0.3.x Breaking changes

The 0.3.x release only includes breaking changes around RPC errors. If you do not directly use the APIs listed below, you do not need to update any of your code for this version.

### Renamed `RequestError` to `RpcError`

`RequestError` was renamed `RpcError` for clarity.

```ts
import { RequestError } from 'viem'  // [!code --]
import { RpcError } from 'viem'  // [!code ++]

throw new RequestError(new Error('An error occurred.'))  // [!code --]
throw new RpcError(new Error('An error occurred.'))  // [!code ++]
```

### Removed `RpcRequestError`

`RpcRequestError` was removed. Use `RpcError` instead.

```ts
import { RpcRequestError } from 'viem' // [!code --]
import { RpcError } from 'viem'  // [!code ++]

throw new RpcRequestError(new Error('An error occurred.')) // [!code --]
throw new RpcError(new Error('An error occurred.')) // [!code ++]
```

### Renamed `RpcError` to `RpcRequestError`

`RpcError` was renamed `RpcRequestError` for consistency.

```ts
import { RpcError } from 'viem' // [!code --]
import { RpcRequestError } from 'viem'  // [!code ++]

const err = new RpcError({ // [!code --]
const err = new RpcRequestError({  // [!code ++]
  body: { foo: 'bar' },
  error: { code: 420, message: 'Error' },
  url: 'https://example-rpc.com',
})
```

## 0.2.x Breaking changes

### `chain` is required for `sendTransaction`, `writeContract`, `deployContract`

A chain is now required for the `sendTransaction`, `writeContract`, `deployContract` Actions.

You can hoist the Chain on the Client:

```ts
import { createWalletClient, custom, getAccount } from 'viem'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet, // [!code ++]
  transport: custom(window.ethereum)
})
 
const account = getAccount('0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266')
 
const hash = await walletClient.sendTransaction({ 
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

Alternatively, you can pass the Chain directly to the Action:

```ts
import { createWalletClient, custom, getAccount } from 'viem'
import { mainnet } from 'viem/chains'

export const walletClient = createWalletClient({
  chain: mainnet, // [!code --]
  transport: custom(window.ethereum)
})
 
const account = getAccount('0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266')
 
const hash = await walletClient.sendTransaction({ 
  account,
  chain: mainnet, // [!code ++]
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: 1000000000000000000n
})
```

### `recoverAddress`, `recoverMessageAddress`, `verifyMessage` are now async

The following functions are now `async` functions instead of synchronous functions:

- `recoverAddress`
- `recoverMessageAddress`
- `verifyMessage`

```ts
import { recoverMessageAddress } from 'viem'

recoverMessageAddress({ message: 'hello world', signature: '0x...' }) // [!code --]
await recoverMessageAddress({ message: 'hello world', signature: '0x...' }) // [!code ++]
```

### `assertChain` removed from `sendTransaction`

Removed `assertChain` argument on `sendTransaction`, `writeContract` & `deployContract`. If you wish to bypass the chain check (not recommended unless for testing purposes), you can pass `chain: null`.

```ts
await walletClient.sendTransaction({
  assertChain: false, // [!code --]
  chain: null, // [!code ++]
  ...
})
```

### `getAccount` removed

Removed the `getAccount` function.

#### For JSON-RPC Accounts, use the address itself.

You can now pass the address directly to the `account` option.

```ts
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

const address = '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'

const client = createWalletClient({
  account: getAccount(address), // [!code --]
  account: address, // [!code ++]
  chain: mainnet,
  transport: custom(window.ethereum)
})
```

#### For Ethers Wallet Adapter, use `ethersWalletToAccount`.

If you were using the Ethers Wallet adapter, you can use the `ethersWalletToAccount` function.

> Note: viem 0.2.0 now has a [Private Key](/docs/accounts/local/privateKeyToAccount) & [Mnemonic Account](/docs/accounts/local/mnemonicToAccount) implementation. You probably do not need this adapter anymore. This adapter may be removed in a future version.

```ts
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'
import { getAccount } from 'viem/ethers' // [!code --]
import { ethersWalletToAccount } from 'viem/ethers' // [!code ++]
import { Wallet } from 'ethers'

const account = getAccount(new Wallet('0x...')) // [!code --]
const account = ethersWalletToAccount(new Wallet('0x...')) // [!code ++]

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: custom(window.ethereum)
})
```

#### For Local Accounts, use `toAccount`.

If you are using a custom signing implementation, you can use the `toAccount` function.

```ts
import { createWalletClient, http, getAccount } from 'viem' // [!code --]
import { createWalletClient, http } from 'viem' // [!code ++]
import { toAccount } from 'viem/accounts' // [!code ++]
import { mainnet } from 'viem/chains'
import { getAddress, signMessage, signTransaction } from './sign-utils' 

const privateKey = '0x...' 
const account = getAccount({ // [!code --]
const account = toAccount({ // [!code ++]
  address: getAddress(privateKey),
  signMessage(message) {
    return signMessage(message, privateKey)
  },
  signTransaction(transaction) {
    return signTransaction(transaction, privateKey)
  },
  signTypedData(typedData) {
    return signTypedData(typedData, privateKey)
  }
})

const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
})
```

### `data` renamed in `signMessage`

Renamed the `data` parameter in `signMessage` to `message`.

```ts
walletClient.signMessage({
  data: 'hello world', // [!code --]
  message: 'hello world', // [!code ++]
})
```
</file>

<file path="typescript.mdx">
# TypeScript [TypeScript support for Viem]

viem is designed to be as type-safe as possible! Things to keep in mind:

- Types currently require using TypeScript v5.0.4 or greater.
- Changes to types in this repository are considered non-breaking and are usually released as patch semver changes (otherwise every type enhancement would be a major version!).
- It is highly recommended that you lock your `viem` package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release.
- The non-type-related public API of `viem` still follows semver very strictly.

To ensure everything works correctly, make sure that your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`:

```json [tsconfig.json]
{
  "compilerOptions": {
    "strict": true // [!code focus]
  }
}
```

## Type Inference

viem can infer types based on [ABI](https://docs.soliditylang.org/en/v0.8.24/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions (powered by [ABIType](https://abitype.dev)), giving you full end-to-end type-safety from your contracts to your frontend and incredible developer experience (e.g. autocomplete ABI function names and catch misspellings, strongly-typed ABI function arguments, etc.).

For this to work, you must either add [const assertions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4#const-assertions) to specific configuration parameters (more info on those below) or **define them inline**. For example, [`readContract`](/docs/contract/readContract)'s `abi` configuration parameter:

```ts twoslash
import { createPublicClient, http, parseAbi } from 'viem'

const client = createPublicClient({
  transport: http()
})
// ---cut---
const abi = [{ // [!code focus]
  type: 'function', // [!code focus]
  name: 'balanceOf', // [!code focus]
  stateMutability: 'view', // [!code focus]
  inputs: [{ type: 'address' }], // [!code focus]
  outputs: [{ type: 'uint256' }], // [!code focus]
}] as const // [!code focus]
// @log:       ↑ const assertion

const result = client.readContract({
  address: '0x27a69ffba1e939ddcfecc8c7e0f967b872bac65c',
  abi, 
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

```ts twoslash
import { createPublicClient, http, parseAbi } from 'viem'

const client = createPublicClient({
  transport: http()
})
// ---cut---
// @log:   ↓ defined inline
const result = client.readContract({
  address: '0x27a69ffba1e939ddcfecc8c7e0f967b872bac65c',
  abi: [{ // [!code focus]
    type: 'function', // [!code focus]
    name: 'balanceOf', // [!code focus]
    stateMutability: 'view', // [!code focus]
    inputs: [{ type: 'address' }], // [!code focus]
    outputs: [{ type: 'uint256' }], // [!code focus]
  }], // [!code focus]
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline.

:::tip
Unfortunately [TypeScript doesn't support importing JSON as const](https://github.com/microsoft/TypeScript/issues/32063). Check out [`@wagmi/cli`](https://wagmi.sh/cli) to help with this! It can automatically fetch ABIs from Etherscan, resolve ABIs from your Foundry/Hardhat projects, and much more.
:::

### Contract ABIs

The following actions and utilities support type inference when you add a const assertion to `abi` or define `abi` inline:

#### Actions

- [`createEventFilter`](/docs/actions/public/createEventFilter)
- [`watchEvent`](/docs/actions/public/watchEvent)
- [`createContractEventFilter`](/docs/contract/createContractEventFilter)
- [`deployContract`](/docs/contract/deployContract)
- [`estimateContractGas`](/docs/contract/estimateContractGas)
- [`multicall`](/docs/contract/multicall)
- [`readContract`](/docs/contract/readContract)
- [`simulateContract`](/docs/contract/simulateContract)
- [`writeContract`](/docs/contract/writeContract)
- [`watchContractEvent`](/docs/contract/watchContractEvent)

#### Utilities

- [`decodeEventLog` ](/docs/contract/decodeEventLog)
- [`decodeFunctionResult` ](/docs/contract/decodeFunctionResult)
- [`encodeDeployData` ](/docs/contract/encodeDeployData)
- [`encodeErrorResult` ](/docs/contract/encodeErrorResult)
- [`encodeEventTopics` ](/docs/contract/encodeEventTopics)
- [`encodeFunctionData` ](/docs/contract/encodeFunctionData)
- [`encodeFunctionResult` ](/docs/contract/encodeFunctionResult)
- [`getAbiItem` ](/docs/abi/getAbiItem)

For example, `readContract`:

```ts twoslash
// @noErrors
import { createPublicClient, http, erc20Abi, parseAbi } from 'viem'

const client = createPublicClient({
  transport: http()
})
// ---cut---
const result = await client.readContract({
  //  ^?


  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
  abi: erc20Abi,
  functionName: 'balanceOf',
  //         ^?
  
  

  // ↑ Notice how "transfer" is not included since it is not a "read" function

  args: ['0x27a69ffba1e939ddcfecc8c7e0f967b872bac65c'],
  // ^?
})
```

### EIP-712 Typed Data

Adding a const assertion to `types` or defining `types` inline adds type inference to [`signTypedData`](/docs/actions/wallet/signTypedData)'s `value` configuration parameter:

```ts twoslash
import { createWalletClient, http, erc20Abi, parseAbi } from 'viem'

const client = createWalletClient({
  account: '0x',
  transport: http()
})
// ---cut---
const result = client.signTypedData({
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },

  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },

  primaryType: 'Mail',

  message: {
    // ^?












    from: {
      name: 'Cow',
      wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
    },
    to: {
      name: 'Bob',
      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
    },
    contents: 'Hello, Bob!',
  },
})
```

### Other

The following utilities support type inference when you use const assertions or define arguments inline:

- [`decodeAbiParameters` ](/docs/abi/decodeAbiParameters)
- [`encodeAbiParameters` ](/docs/abi/encodeAbiParameters)
- [`encodePacked` ](/docs/abi/encodePacked)
- [`parseAbi` ](/docs/abi/parseAbi)
- [`parseAbiItem` ](/docs/abi/parseAbiItem)
- [`parseAbiParameter` ](/docs/abi/parseAbiParameter)
- [`parseAbiParameters` ](/docs/abi/parseAbiParameters)

## Configuring Internal Types

For advanced use-cases, you may want to configure viem's internal types. Most of viem's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://abitype.dev). See ABIType's [documentation](https://abitype.dev/config) for more info on how to configure types.

## `window` Polyfill

By importing the `viem/window` Polyfill, the global `window.ethereum` will typed as an [`EIP1193Provider`](https://github.com/wagmi-dev/viem/blob/4bdbf15be0d61b52a195e11c97201e707fb616cc/src/types/eip1193.ts#L24-L26) (including a fully-typed `request` function & typed events).

```ts twoslash
// @noErrors
import 'viem/window';

const hash = await window.ethereum.request({
  method: 'e 
//          ^|
})








const hash = await window.ethereum.request({
  method: 'eth_getTransactionByHash',
  params: [
//     ^?
})
```
</file>

</files>
